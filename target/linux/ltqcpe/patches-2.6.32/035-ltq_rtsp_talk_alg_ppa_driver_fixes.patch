Index: linux/include/linux/netfilter/nf_conntrack_rtsp.h
===================================================================
--- linux.orig/include/linux/netfilter/nf_conntrack_rtsp.h	2011-01-07 12:09:08.000000000 +0530
+++ linux/include/linux/netfilter/nf_conntrack_rtsp.h	2011-01-07 12:16:19.764652359 +0530
@@ -1,6 +1,6 @@
 /*
  * RTSP extension for IP connection tracking.
- * (C) 2003 by Tom Marshall <tmarshall at real.com>
+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
  * based on ip_conntrack_irc.h
  *
  *      This program is free software; you can redistribute it and/or
@@ -11,10 +11,11 @@
 #ifndef _IP_CONNTRACK_RTSP_H
 #define _IP_CONNTRACK_RTSP_H
 
-//#define IP_NF_RTSP_DEBUG 1
+/* #define IP_NF_RTSP_DEBUG */
+//#define IP_NF_RTSP_VERSION "0.01"
 #define IP_NF_RTSP_VERSION "0.6.21"
 
-#ifdef __KERNEL__
+
 /* port block types */
 typedef enum {
     pb_single,  /* client_port=x */
@@ -22,6 +23,16 @@
     pb_discon   /* client_port=x/y (rtspbis) */
 } portblock_t;
 
+
+typedef enum
+{
+    // RTP used by other players
+    IP_CT_RTSP_RTP,
+
+    // RDT used by Realplayer
+    IP_CT_RTSP_RDT
+}nf_ct_rtsp_protocol_type;
+
 /* We record seq number and length of rtsp headers here, all in host order. */
 
 /*
@@ -36,7 +47,7 @@
  * multiple times in a message.  We must treat two Transport headers the
  * same as one Transport header with two entries.
  */
-struct ip_ct_rtsp_expect
+struct nf_ct_rtsp_expect
 {
     u_int32_t   len;        /* length of header block */
     portblock_t pbtype;     /* Type of port block that was requested */
@@ -46,18 +57,49 @@
     uint        method;     /* RTSP method */
     uint        cseq;       /* CSeq from request */
 #endif
+    nf_ct_rtsp_protocol_type rtsp_protocol;
+
+	// RTCP from client to server or server to client
+	enum ip_conntrack_dir rtcp_dir;
+    /* [ Sumedh:15Sep06. Fix RTSP ALG to store RTP/RTCP port translated values */
+    /* Store the translated ports */
+    u_int16_t nat_rtp_port;  /* Translated loport for RTP */
+    u_int16_t nat_rtcp_port; /* Translated hiport for RTCP if applicable */
+    /* ] End changes */
+};
+
+/* This structure exists only once per master */
+struct nf_ct_rtsp_master
+{
+    /* Empty (?) */
 };
 
-extern unsigned int (*nf_nat_rtsp_hook)(struct sk_buff *skb,
-				 enum ip_conntrack_info ctinfo,
+
+
+
+extern unsigned int (*nf_nat_rtsp_hook)(struct sk_buff **pskb,
+                                 enum ip_conntrack_info ctinfo,
 				 unsigned int matchoff, unsigned int matchlen,
-				 struct ip_ct_rtsp_expect *prtspexp,
-				 struct nf_conntrack_expect *exp);
+                                 struct nf_ct_rtsp_expect *expinfo,
+                                 struct nf_conntrack_expect *exp);
+
 
 extern void (*nf_nat_rtsp_hook_expectfn)(struct nf_conn *ct, struct nf_conntrack_expect *exp);
 
+#ifdef __KERNEL__
+
+//#include <linux/netfilter_ipv4/lockhelp.h>
+
 #define RTSP_PORT   554
 
+//struct ip_ct_rtsp_expect exp_rtsp_info_master_common;   // added because help is removed which had this declaration
+//struct ip_ct_rtsp_expect exp_rtsp_info_common;
+
+/* Protects rtsp part of conntracks */
+//DECLARE_LOCK_EXTERN(ip_rtsp_lock);
+extern spinlock_t ip_rtsp_lock;
+
 #endif /* __KERNEL__ */
 
 #endif /* _IP_CONNTRACK_RTSP_H */
+
Index: linux/net/ipv4/netfilter/nf_nat_rtsp.c
===================================================================
--- linux.orig/net/ipv4/netfilter/nf_nat_rtsp.c	2011-01-07 12:09:09.000000000 +0530
+++ linux/net/ipv4/netfilter/nf_nat_rtsp.c	2011-01-07 12:15:20.335902870 +0530
@@ -1,6 +1,6 @@
 /*
  * RTSP extension for TCP NAT alteration
- * (C) 2003 by Tom Marshall <tmarshall at real.com>
+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
  * based on ip_nat_irc.c
  *
  *      This program is free software; you can redistribute it and/or
@@ -9,7 +9,7 @@
  *      2 of the License, or (at your option) any later version.
  *
  * Module load syntax:
- *      insmod nf_nat_rtsp.o ports=port1,port2,...port<MAX_PORTS>
+ *      insmod ip_nat_rtsp.o ports=port1,port2,...port<MAX_PORTS>
  *                           stunaddr=<address>
  *                           destaction=[auto|strip|none]
  *
@@ -31,12 +31,30 @@
  */
 
 #include <linux/module.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/kernel.h>
 #include <net/tcp.h>
+#include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_helper.h>
 #include <net/netfilter/nf_nat_rule.h>
 #include <linux/netfilter/nf_conntrack_rtsp.h>
+#include <net/netfilter/nf_conntrack_helper.h>
 #include <net/netfilter/nf_conntrack_expect.h>
 
+//#include <linux/netfilter_ipv4/ip_conntrack.h>
+
+//#include <linux/netfilter_ipv4/lockhelp.h>
+//DECLARE_RWLOCK_EXTERN(ip_rtsp_rwlock);
+
+extern rwlock_t ip_rtsp_rwlock;
+
+//#define ASSERT_READ_LOCK MUST_BE_READ_LOCKED(&ip_rtsp_rwlock);
+//#define ASSERT_WRITE_LOCK MUST_BE_WRITE_LOCKED(&ip_rtsp_rwlock);
+
+
 #include <linux/inet.h>
 #include <linux/ctype.h>
 #define NF_NEED_STRNCASECMP
@@ -44,40 +62,93 @@
 #include <linux/netfilter_helpers.h>
 #define NF_NEED_MIME_NEXTLINE
 #include <linux/netfilter_mime.h>
+#include <linux/unistd.h>
 
-#undef IFX_RTSP_NAT_ALG 
+#define IFX_RTSP_NAT_ALG
+#undef IFX_RTSP_NAT_ALG // The IFX_RTSP_NAT_ALG is defined when the NAT module is used as DRIVER . As it is not
+						// ported so it is undefined . 
 
 #ifdef IFX_RTSP_NAT_ALG
 #include <linux/netfilter_ipv4/listhelp.h>
+//#include "rtsp_alg.h"
 #include <linux/netfilter/ifx_alg.h>
 #endif
 
-#define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
-#if 0
-#define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
+
+#define INFOP(args...) printk(KERN_INFO __FILE__ ":", __FUNCTION__ ":" args)
+
+#undef RTSP_NAT_DEBUG
+//#define IFX_DEBUG 0 //testing
+//#undef IFX_DEBUG
+///#define DEBUGP printk  //testing
+
+
+#ifdef RTSP_NAT_DEBUG
+#define NDEBUG(format,args...) printk(" \n Neeraj " ": " __FILE__  " : " __FUNCTION__ " : " format,##args)
+#else
+#define NDEBUG(format,args...)
+#endif
+
+//#define IP_NF_RTSP_DEBUG
+
+#ifdef IP_NF_RTSP_DEBUG
+//#define DEBUGP(args...) printk(KERN_DEBUG __FILE__ ":" __FUNCTION__ ":" args);
+#define DEBUGP(args...) printk(args)
 #else
-#define DEBUGP(fmt, args...)
+#define DEBUGP(args...)
 #endif
 
+//#define DEBUGP printk
+
 #define MAX_PORTS       8
 #define DSTACT_AUTO     0
 #define DSTACT_STRIP    1
 #define DSTACT_NONE     2
 
-static char*    stunaddr = NULL;
-static char*    destaction = NULL;
+#define CONFIG_IFX_ALG_QOS
+
+/*#ifndef IFX_RTSP_NAT_ALG
+
+static int      ports[MAX_PORTS];
+static int       num_ports = 0;
+
+#endif*/
 
+
+
+static char *    stunaddr = NULL;
+static char *    destaction = NULL;
 static u_int32_t extip = 0;
 static int       dstact = 0;
 
-MODULE_AUTHOR("Tom Marshall <tmarshall at real.com>");
+
+MODULE_AUTHOR("Tom Marshall <tmarshall@real.com>");
 MODULE_DESCRIPTION("RTSP network address translation module");
 MODULE_LICENSE("GPL");
-module_param(stunaddr, charp, 0644);
+
+#ifdef MODULE_PARM
+
+#ifndef IFX_RTSP_NAT_ALG
+
+MODULE_PARM(ports, "1-" __MODULE_STRING(MAX_PORTS) "i");
+MODULE_PARM_DESC(ports, "port numbers of RTSP servers");
+MODULE_PARM(stunaddr, "s");
 MODULE_PARM_DESC(stunaddr, "Address for detecting STUN");
-module_param(destaction, charp, 0644);
+MODULE_PARM(destaction, "s");
 MODULE_PARM_DESC(destaction, "Action for destination parameter (auto/strip/none)");
 
+#endif
+
+#endif
+
+/* protects rtsp part of conntracks */
+//DECLARE_LOCK_EXTERN(ip_rtsp_lock);
+extern spinlock_t ip_rtsp_lock ;
+
+//static void expected(struct nf_conn * , struct nf_conntrack_expect *);
+// 6th july DECLARE_RWLOCK(ip_rtsp_rwlock);
+
+
 #define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
 
 #ifdef IFX_RTSP_NAT_ALG
@@ -125,24 +196,29 @@
 
 #endif
 
-
-
-
-
-
+struct nf_ct_rtsp_expect *exp_driver_info;
 
 /*** helper functions ***/
 
 static void
+
 get_skb_tcpdata(struct sk_buff* skb, char** pptcpdata, uint* ptcpdatalen)
 {
-    struct iphdr*   iph  = ip_hdr(skb);
-    struct tcphdr*  tcph = (void *)iph + ip_hdrlen(skb);
+	struct iphdr*   iph  = ip_hdr(skb); //(struct iphdr*)skb->nh.iph;
+	struct tcphdr*  tcph = (struct tcphdr*)((char*)iph + iph->ihl*4);
+
+	*pptcpdata = (char*)tcph + tcph->doff*4;
+	*ptcpdatalen = ((char*)skb_transport_header(skb) + skb->len) - *pptcpdata; //((char*)skb->h.raw + skb->len) - *pptcpdata;
+}
 
-    *pptcpdata = (char*)tcph +  tcph->doff*4;
-    *ptcpdatalen = ((char*)skb_transport_header(skb) + skb->len) - *pptcpdata;
+
+//static void expected(struct ip_conntrack* ct, struct nf_conntrack_expect *exp)
+static void expected(struct nf_conn* ct, struct nf_conntrack_expect *exp)
+{
+	nf_nat_follow_master(ct,exp);
 }
 
+
 /*** nat functions ***/
 
 /*
@@ -152,7 +228,7 @@
  *
  * In:
  *   ct, ctinfo = conntrack context
- *   skb        = packet
+ *   pskb       = packet
  *   tranoff    = Transport header offset from TCP data
  *   tranlen    = Transport header length (incl. CRLF)
  *   rport_lo   = replacement low  port (host endian)
@@ -163,284 +239,619 @@
  * Assumes that a complete transport header is present, ending with CR or LF
  */
 static int
-rtsp_mangle_tran(enum ip_conntrack_info ctinfo,
-                 struct nf_conntrack_expect* exp,
-								 struct ip_ct_rtsp_expect* prtspexp,
-                 struct sk_buff* skb, uint tranoff, uint tranlen)
-{
-    char*       ptcp;
-    uint        tcplen;
-    char*       ptran;
-    char        rbuf1[16];      /* Replacement buffer (one port) */
-    uint        rbuf1len;       /* Replacement len (one port) */
-    char        rbufa[16];      /* Replacement buffer (all ports) */
-    uint        rbufalen;       /* Replacement len (all ports) */
-    u_int32_t   newip;
-    u_int16_t   loport, hiport;
-    uint        off = 0;
-    uint        diff;           /* Number of bytes we removed */
-
-    struct nf_conn *ct = exp->master;
-    struct nf_conntrack_tuple *t;
-
-    char    szextaddr[15+1];
-    uint    extaddrlen;
-    int     is_stun;
+rtsp_mangle_tran(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
+		struct nf_conntrack_expect *exp, struct nf_ct_rtsp_expect *prtspexp,
+		struct sk_buff **pskb, uint tranoff, uint tranlen)
+{
+	char*       ptcp;
+	uint        tcplen;
+	char*       ptran;
+	char        rbuf1[16];      /* Replacement buffer (one port) */
+	uint        rbuf1len;       /* Replacement len (one port) */
+	char        rbufa[16];      /* Replacement buffer (all ports) */
+	uint        rbufalen;       /* Replacement len (all ports) */
+	u_int32_t   newip;
+	u_int16_t   loport, hiport;
+	uint        off = 0;
+	uint        diff;           /* Number of bytes we removed */
+//uint temp_1 = 0;
+//	struct ip_ct_rtsp_expect* prtspexp = &exp->help.exp_rtsp_info;
+       
+        struct nf_conntrack_tuple t;
+ //       ct = exp->master; //added
+	//struct sk_buff* skb_test;
+      //    struct nf_conntrack_expect *exp1;
+int dir = CTINFO2DIR(ctinfo); 
+
+	char    szextaddr[15+1];
+	uint    extaddrlen;
+	int     is_stun;
+       
+      DEBUGP(" INSIDE MANGLE  TRANS \n");
+ 
+         ct = exp->master; //added
+	get_skb_tcpdata(*pskb, &ptcp, &tcplen);
+	ptran = ptcp+tranoff;
+
+	if (tranoff+tranlen > tcplen || tcplen-tranoff < tranlen ||
+			tranlen < 10 || !iseol(ptran[tranlen-1]) ||
+			nf_strncasecmp(ptran, "Transport:", 10) != 0)
+	{
+		//INFOP("sanity check failed\n");
+		return 0;
+	}
+	off += 10;
+	SKIP_WSPACE(ptcp+tranoff, tranlen, off);
 
-#ifdef CONFIG_RTSP_ALG_FIX
-    int dir = CTINFO2DIR(ctinfo);
+
+#if 0
+
+       exp->tuple.src.u3 = ct->tuplehash[!dir].tuple.src.u3;
+       exp->mask.src.u3.ip  = 0xffffffff; //orginal
+	    // exp->mask.src.u3.ip  = 0 ;
+	     // exp->tuple.src.l3num = PF_INET ;
+	    //exp->mask.src.l3num = 0xff;
+
+         exp->tuple.dst.u3 = ct->tuplehash[dir].tuple.src.u3;
+          exp->mask.dst.u3.ip  = 0xffffffff;
+       // exp1->tuple.dst.u.udp.port = prtspexp->loport;
+         // exp1->mask.dst.u.udp.port  =  0xffff;
+         //exp->mask.dst.u.udp.port  = 0xffff;
+         exp->tuple.dst.protonum = IPPROTO_UDP;
+		 exp->mask.dst.protonum  = 0xff;
+																		  
 #endif
 
-    get_skb_tcpdata(skb, &ptcp, &tcplen);
-    ptran = ptcp+tranoff;
 
-    if (tranoff+tranlen > tcplen || tcplen-tranoff < tranlen ||
-        tranlen < 10 || !iseol(ptran[tranlen-1]) ||
-        nf_strncasecmp(ptran, "Transport:", 10) != 0)
-    {
-        INFOP("sanity check failed\n");
-        return 0;
-    }
-    off += 10;
-    SKIP_WSPACE(ptcp+tranoff, tranlen, off);
+#ifdef CONFIG_IFX_ALG_QOS // testing : desai 
 
-    newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
-    t = &exp->tuple;
-    t->dst.u3.ip = newip;
-
-    extaddrlen = extip ? sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(extip))
-                       : sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(newip));
-    DEBUGP("stunaddr=%s (%s)\n", szextaddr, (extip?"forced":"auto"));
+	if (exp->tuple.dst.u.udp.port == 0) {
+		newip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+		t = exp->tuple;
+		t.src.u3.ip = newip;
+	exp->tuple.src.u3.ip = newip ;
+	//exp->mask.src.u3.ip  = 0xffffffff;
+	} else {
+		newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+		t = exp->tuple;
+		t.dst.u3.ip = newip;
+		exp->tuple.dst.u3.ip = newip ;
+	//	exp->mask.dst.u3.ip  = 0xffffffff;
+	}
+#else
+	newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+	t = exp->tuple;
+	t.dst.u3.ip = newip;
+    exp->tuple.dst.u3.ip = newip;
+	//exp->mask.dst.u3.ip  = 0xffffffff;
+#endif
+
+/********** QOS*********/
+#if 1 // CONFIG_IFX_ALG_QOS
+// exp->expectfn = rtsp_expect;
+//exp->expectfn = expected ;
+
+
+exp->expectfn = nf_nat_follow_master;
+
+
+DEBUGP("expect_NAT %u.%u.%u.%u:%u-%u.%u.%u.%u:%u\n",
+             NIPQUAD(exp->tuple.src.u3.ip),
+             ntohs(exp->tuple.src.u.udp.port),
+            NIPQUAD(exp->tuple.dst.u3.ip),
+            ntohs(exp->tuple.dst.u.udp.port));
+														
 
-    rbuf1len = rbufalen = 0;
-    switch (prtspexp->pbtype)
-    {
-    case pb_single:
-        for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
-        {
-            t->dst.u.udp.port = htons(loport);
-#ifdef CONFIG_RTSP_ALG_FIX
-	    exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
-	    exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
-	    exp->dir = !dir;
 #endif
-            if (nf_ct_expect_related(exp) == 0)
-            {
-                DEBUGP("using port %hu\n", loport);
-                break;
-            }
-        }
-        if (loport != 0)
-        {
-            rbuf1len = sprintf(rbuf1, "%hu", loport);
-            rbufalen = sprintf(rbufa, "%hu", loport);
-        }
-        break;
-    case pb_range:
-        for (loport = prtspexp->loport; loport != 0; loport += 2) /* XXX: improper wrap? */
-        {
-            t->dst.u.udp.port = htons(loport);
-#ifdef CONFIG_RTSP_ALG_FIX
-	exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
-	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
-	exp->dir = !dir;
+
+/******************/
+
+	extaddrlen = extip ? sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(extip))
+		: sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(newip));
+	DEBUGP("stunaddr=%s (%s)\n", szextaddr, (extip?"forced":"auto"));
+
+	rbuf1len = rbufalen = 0;
+	switch (prtspexp->pbtype)
+	{
+		case pb_single:
+			for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
+			{
+#ifdef CONFIG_IFX_ALG_QOS 
+				if (exp->tuple.dst.u.udp.port == 0) {
+				   	t.src.u.udp.port = htons(loport);
+				} else {
+					t.dst.u.udp.port = htons(loport);
+				}
+#else
+				t.dst.u.udp.port = htons(loport);
 #endif
-            if (nf_ct_expect_related(exp) == 0)
-            {
-                hiport = loport + ~exp->mask.src.u.udp.port;
-                DEBUGP("using ports %hu-%hu\n", loport, hiport);
-                break;
-            }
-        }
-        if (loport != 0)
-        {
-            rbuf1len = sprintf(rbuf1, "%hu", loport);
-            rbufalen = sprintf(rbufa, "%hu-%hu", loport, loport+1);
-        }
-        break;
-    case pb_discon:
-        for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
-        {
-            t->dst.u.udp.port = htons(loport);
-#ifdef CONFIG_RTSP_ALG_FIX
-	exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
-	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
-	exp->dir = !dir;
+
+#if 1 //  IFX_DEBUG
+ 
+// memcpy(&exp->tuple,&t,sizeof(exp->tuple));
+
+exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+//exp->mask.dst.u.udp.port  = 0xffff;
+
+//printk("inside debug in nat %u  ,  %u \n",t.dst.u.udp.port,  prtspexp->loport );
+
+exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+exp->dir = !dir;
+#endif 
+
+             if ((nf_ct_expect_related(exp) == 0))
+				{
+					prtspexp->nat_rtp_port = loport;
+					//prtspexp->loport = loport ;
+					//exp->master->rtcp_expect_registered = loport ;
+
+					DEBUGP("using port %hu\n", loport);
+					break;
+				}
+			else
+			{
+			   //printk(" \n expectation FAILED \n");
+			   break;
+			}
+			
+			}
+			if (loport != 0)
+			{
+				rbuf1len = sprintf(rbuf1, "%hu", loport);
+				rbufalen = sprintf(rbufa, "%hu", loport);
+			}
+			break;
+		case pb_range:
+			for (loport = prtspexp->loport; loport != 0; loport += 2) /* XXX: improper wrap? */
+			{
+				t.dst.u.udp.port = htons(loport);
+				//if (ip_conntrack_change_expect(exp, &t) == 0)
+
+ #if 1 //def IFX_DEBUG
+
+//  memcpy(&exp->tuple,&t,sizeof(exp->tuple));
+
+exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+//exp->mask.dst.u.udp.port  = 0xffff ;
+exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+exp->dir = !dir;
+ #endif
+   
+				if (nf_ct_expect_related(exp) == 0)
+				{
+					hiport = loport + ~exp->mask.src.u.udp.port;
+					prtspexp->nat_rtp_port = loport;
+					prtspexp->nat_rtcp_port = hiport;
+					
+			/*		if(prtspexp->nat_rtp_port != prtspexp->loport)
+					{
+					DEBUGP("using ports %hu-%hu\n",exp->tuple.dst.u.udp.port, prtspexp->nat_rtp_port);
+					 exp->tuple.dst.u.udp.port = prtspexp->nat_rtp_port ;
+					 exp->mask.dst.u.udp.port  = 0xffff ;
+					 
+					 if (nf_conntrack_expect_related(exp) == 0)
+					 {
+					   printk("\n DONE \n " );
+					 }
+				    }*/
+
+					DEBUGP("using ports %hu-%hu\n", loport, hiport);
+					break;
+				}
+				else
+				{
+				      break;
+				}
+			}
+			if (loport != 0)
+			{
+				rbuf1len = sprintf(rbuf1, "%hu", loport);
+				rbufalen = sprintf(rbufa, "%hu-%hu", loport, loport+1);
+			}
+			break;
+		case pb_discon:
+			for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
+			{
+				t.dst.u.udp.port = htons(loport);
+//				if (ip_conntrack_change_expect(exp, &t) == 0)
+
+ #if 1 //def IFX_DEBUG
+
+//  memcpy(&exp->tuple,&t,sizeof(exp->tuple));
+
+exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+
+//printk("inside debug in nat %u\n",t.dst.u.udp.port );
+
+//exp->mask.dst.u.udp.port  = 0xffff ;
+exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+exp->dir = !dir ;
 #endif
-            if (nf_ct_expect_related(exp) == 0)
-            {
-                DEBUGP("using port %hu (1 of 2)\n", loport);
-                break;
-            }
-        }
-        for (hiport = prtspexp->hiport; hiport != 0; hiport++) /* XXX: improper wrap? */
-        {
-            t->dst.u.udp.port = htons(hiport);
-#ifdef CONFIG_RTSP_ALG_FIX
-	exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
-	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
-	exp->dir = !dir;
+   
+  				if (nf_ct_expect_related(exp) == 0)
+				{
+					prtspexp->nat_rtp_port = loport;
+					DEBUGP("using port %hu (1 of 2)\n", loport);
+					break;
+				}
+				else
+				{
+				  break;
+				}
+			}
+			for (hiport = prtspexp->hiport; hiport != 0; hiport++) /* XXX: improper wrap? */
+			{
+				t.dst.u.udp.port = htons(hiport);
+//				if (ip_conntrack_change_expect(exp, &t) == 0)
+ #if 1 //def IFX_DEBUG
+
+//  memcpy(&exp->tuple,&t,sizeof(exp->tuple));
+
+exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+
+//printk("inside debug in nat %u\n",t.dst.u.udp.port );
+//exp->mask.dst.u.udp.port  = 0xffff;
+exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+exp->dir = !dir;
+   #endif
+
+				if (nf_ct_expect_related(exp) == 0)
+				{
+					prtspexp->nat_rtcp_port = hiport;
+					DEBUGP("using port %hu (2 of 2)\n", hiport);
+					break;
+				}
+				else
+				{
+				break;
+				}
+			}
+			if (loport != 0 && hiport != 0)
+			{
+				rbuf1len = sprintf(rbuf1, "%hu", loport);
+				if (hiport == loport+1)
+				{
+					rbufalen = sprintf(rbufa, "%hu-%hu", loport, hiport);
+				}
+				else
+				{
+					rbufalen = sprintf(rbufa, "%hu/%hu", loport, hiport);
+				}
+			}
+			break;
+		default:
+			/* oops */
+   			break;
+	}
+
+	if (rbuf1len == 0)
+	{
+		return 0;   /* cannot get replacement port(s) */
+	}
+
+#ifdef CONFIG_IFX_ALG_QOS
+
+	//Nirav : Check in case this is RTCP port i.e. odd port.
+	if ((prtspexp->loport % 2) != 0) {
+		DEBUGP("This is RTCP request to port %d\n",prtspexp->loport);
+		return 0;
+	} else 
+		DEBUGP("This is NOT RTCP request to port %d\n",prtspexp->loport);
 #endif
-            if (nf_ct_expect_related(exp) == 0)
-            {
-                DEBUGP("using port %hu (2 of 2)\n", hiport);
-                break;
-            }
-        }
-        if (loport != 0 && hiport != 0)
-        {
-            rbuf1len = sprintf(rbuf1, "%hu", loport);
-            if (hiport == loport+1)
-            {
-                rbufalen = sprintf(rbufa, "%hu-%hu", loport, hiport);
-            }
-            else
-            {
-                rbufalen = sprintf(rbufa, "%hu/%hu", loport, hiport);
-            }
-        }
-        break;
-    }
+//	skb_test = *pskb;
+	/* Transport: tran;field;field=val,tran;field;field=val,... */
+	while (off < tranlen)
+	{
+		uint        saveoff;
+		const char* pparamend;
+		uint        nextparamoff;
+
+		pparamend = memchr(ptran+off, ',', tranlen-off);
+		pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
+		nextparamoff = pparamend-ptcp;
+
+		/*
+		 * We pass over each param twice.  On the first pass, we look for a
+		 * destination= field.  It is handled by the security policy.  If it
+		 * is present, allowed, and equal to our external address, we assume
+		 * that STUN is being used and we leave the client_port= field alone.
+		 */
+		is_stun = 0;
+		saveoff = off;
+		while (off < nextparamoff)
+		{
+			const char* pfieldend;
+			uint        nextfieldoff;
 
-    if (rbuf1len == 0)
-    {
-        return 0;   /* cannot get replacement port(s) */
-    }
+			pfieldend = memchr(ptran+off, ';', nextparamoff-off);
+			nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
 
-    /* Transport: tran;field;field=val,tran;field;field=val,... */
-    while (off < tranlen)
-    {
-        uint        saveoff;
-        const char* pparamend;
-        uint        nextparamoff;
-
-        pparamend = memchr(ptran+off, ',', tranlen-off);
-        pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
-        nextparamoff = pparamend-ptcp;
-
-        /*
-         * We pass over each param twice.  On the first pass, we look for a
-         * destination= field.  It is handled by the security policy.  If it
-         * is present, allowed, and equal to our external address, we assume
-         * that STUN is being used and we leave the client_port= field alone.
-         */
-        is_stun = 0;
-        saveoff = off;
-        while (off < nextparamoff)
-        {
-            const char* pfieldend;
-            uint        nextfieldoff;
+			if (dstact != DSTACT_NONE && strncmp(ptran+off, "destination=", 12) == 0)
+			{
+				if (strncmp(ptran+off+12, szextaddr, extaddrlen) == 0)
+				{
+					is_stun = 1;
+				}
+				if (dstact == DSTACT_STRIP || (dstact == DSTACT_AUTO && !is_stun))
+				{
+					diff = nextfieldoff-off;
+					if (!nf_nat_mangle_tcp_packet(*pskb, ct, ctinfo,
+								off, diff, NULL, 0))
+					{
+						/* mangle failed, all we can do is bail */
+						return 0;
+					}
+					get_skb_tcpdata(*pskb, &ptcp, &tcplen);
+					ptran = ptcp+tranoff;
+					tranlen -= diff;
+					nextparamoff -= diff;
+					nextfieldoff -= diff;
+				}
+			}
 
-            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
-            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
+			off = nextfieldoff;
+		}
+		if (is_stun)
+		{
+			continue;
+		}
+		off = saveoff;
+		while (off < nextparamoff)
+		{
+			const char* pfieldend;
+			uint        nextfieldoff;
 
-            if (dstact != DSTACT_NONE && strncmp(ptran+off, "destination=", 12) == 0)
-            {
-                if (strncmp(ptran+off+12, szextaddr, extaddrlen) == 0)
-                {
-                    is_stun = 1;
-                }
-                if (dstact == DSTACT_STRIP || (dstact == DSTACT_AUTO && !is_stun))
-                {
-                    diff = nextfieldoff-off;
-                    if (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo,
-                                                         off, diff, NULL, 0))
-                    {
-                        /* mangle failed, all we can do is bail */
-			nf_ct_unexpect_related(exp);
-                        return 0;
-                    }
-                    get_skb_tcpdata(skb, &ptcp, &tcplen);
-                    ptran = ptcp+tranoff;
-                    tranlen -= diff;
-                    nextparamoff -= diff;
-                    nextfieldoff -= diff;
-                }
-            }
+			pfieldend = memchr(ptran+off, ';', nextparamoff-off);
+			nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
 
-            off = nextfieldoff;
-        }
-        if (is_stun)
-        {
-            continue;
-        }
-        off = saveoff;
-        while (off < nextparamoff)
-        {
-            const char* pfieldend;
-            uint        nextfieldoff;
+			if (strncmp(ptran+off, "client_port=", 12) == 0)
+			{
+				u_int16_t   port;
+				uint        numlen;
+				uint        origoff;
+				uint        origlen;
+				char*       rbuf    = rbuf1;
+				uint        rbuflen = rbuf1len;
+
+				off += 12;
+				origoff = (ptran-ptcp)+off;
+				origlen = 0;
+				numlen = nf_strtou16(ptran+off, &port);
+				off += numlen;
+				origlen += numlen;
+				if (port != prtspexp->loport)
+				{
+					DEBUGP("multiple ports found, port %hu ignored\n", port);
+				}
+				else
+				{
+					if (ptran[off] == '-' || ptran[off] == '/')
+					{
+						off++;
+						origlen++;
+						numlen = nf_strtou16(ptran+off, &port);
+						off += numlen;
+						origlen += numlen;
+						rbuf = rbufa;
+						rbuflen = rbufalen;
+						DEBUGP("NO multiple ports found, port %hu ignored\n", port);
+					}
+
+					/*
+					 * note we cannot just memcpy() if the sizes are the same.
+					 * the mangle function does skb resizing, checks for a
+					 * cloned skb, and updates the checksums.
+					 *
+					 * parameter 4 below is offset from start of tcp data.
+					 */
+					diff = origlen-rbuflen;
+					if (!nf_nat_mangle_tcp_packet(*pskb, ct, ctinfo,
+								origoff, origlen, rbuf, rbuflen))
+					{
+						/* mangle failed, all we can do is bail */
+						//nf_conntrack_unexpect_related(exp);
+						nf_ct_unexpect_related(exp);
+						return 0;
+					}
+					get_skb_tcpdata(*pskb, &ptcp, &tcplen);
+					ptran = ptcp+tranoff;
+					tranlen -= diff;
+					nextparamoff -= diff;
+					nextfieldoff -= diff;
+				}
+			}
 
-            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
-            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
+			off = nextfieldoff;
+		}
 
-            if (strncmp(ptran+off, "client_port=", 12) == 0)
-            {
-                u_int16_t   port;
-                uint        numlen;
-                uint        origoff;
-                uint        origlen;
-                char*       rbuf    = rbuf1;
-                uint        rbuflen = rbuf1len;
-
-                off += 12;
-                origoff = (ptran-ptcp)+off;
-                origlen = 0;
-                numlen = nf_strtou16(ptran+off, &port);
-                off += numlen;
-                origlen += numlen;
-                if (port != prtspexp->loport)
-                {
-                    DEBUGP("multiple ports found, port %hu ignored\n", port);
-                }
-                else
-                {
-                    if (ptran[off] == '-' || ptran[off] == '/')
-                    {
-                        off++;
-                        origlen++;
-                        numlen = nf_strtou16(ptran+off, &port);
-                        off += numlen;
-                        origlen += numlen;
-                        rbuf = rbufa;
-                        rbuflen = rbufalen;
-                    }
-
-                    /*
-                     * note we cannot just memcpy() if the sizes are the same.
-                     * the mangle function does skb resizing, checks for a
-                     * cloned skb, and updates the checksums.
-                     *
-                     * parameter 4 below is offset from start of tcp data.
-                     */
-                    diff = origlen-rbuflen;
-                    if (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo,
-                                              origoff, origlen, rbuf, rbuflen))
-                    {
-                        /* mangle failed, all we can do is bail */
-			nf_ct_unexpect_related(exp);
-                        return 0;
-                    }
-                    get_skb_tcpdata(skb, &ptcp, &tcplen);
-                    ptran = ptcp+tranoff;
-                    tranlen -= diff;
-                    nextparamoff -= diff;
-                    nextfieldoff -= diff;
-                }
-            }
+		off = nextparamoff;
+	}
 
-            off = nextfieldoff;
-        }
+        DEBUGP(" outside MANGLE  TRANS \n");
+	return 1;
+}
 
-        off = nextparamoff;
-    }
+int  get_src_port_num2(struct sk_buff **pskb, u_int16_t *port)
+{
+	struct iphdr *iph = ip_hdr(*pskb); //(*pskb)->nh.iph;
+	struct udphdr *udph;
+	struct tcphdr *tcph;
+	if(iph->protocol == 0x06) {
+		tcph = (void*)iph+iph->ihl*4;
+		*port = tcph->source;
+	} else if(iph->protocol == 0x11) {
+		udph = (void*)iph+iph->ihl*4;
+		*port = udph->source;
+	} else
+		return -1;
+	return 0;
+}
+int  get_dest_port_num2(struct sk_buff **pskb, u_int16_t *port)
+{
+	struct iphdr *iph = ip_hdr(*pskb); //(*pskb)->nh.iph;
+	struct udphdr *udph;
+	struct tcphdr *tcph;
+	if(iph->protocol == 0x06) {
+		tcph = (void*)iph+iph->ihl*4;
+		*port = tcph->dest;
+	} else if(iph->protocol == 0x11) {
+		udph = (void*)iph+iph->ihl*4;
+		*port = udph->dest;
+	} else
+		return -1;
+	return 0;
+
+}
+//	static unsigned int
+//expected(struct sk_buff **pskb, uint hooknum, struct nf_conn *ct, struct nf_nat_info *info)
+
+/* static void
+ expected(struct nf_conn *ct, struct nf_conntrack_expect *exp)
+{
+	struct nf_nat_multi_range_compat  mr;
+         
+          //struct ip_nat_multi_range mr;
+
+	u_int32_t newdstip, newsrcip, newip;
+	u_int16_t newdstport, newsrcport, newport;
+
+	struct nf_conn *master = master_ct(ct);
+
+	//IP_NF_ASSERT(info);
+	//IP_NF_ASSERT(master);
+
+	//IP_NF_ASSERT(!(info->initialized & (1 << HOOK2MANIP(hooknum))));
+
+     //     memset(&mr, 0, sizeof(struct ip_nat_multi_range)); // added
 
-    return 1;
+ 
+#ifdef IFX_RTSP_NAT_ALG   // ask sumedh
+	newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;  // testing 
+	newsrcip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+	//newip = (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) ? newsrcip : newdstip;
+#else
+	newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+	newsrcip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+	newdstport = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
+	newsrcport = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
+	
+//	newsrcport = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.udp.port;
+	//newip = (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) ? newsrcip : newdstip;
+
+	newip = (master->status == 0) ? newsrcip : newdstip ;
+	
+		 Fix the port handling. The ALG only worked if NAT could provide the same
+		 * ports for RTP/RTCP as the client. Essentially, making it a single client
+		 * RTSP ALG. In boundary cases, even one RTSP client wouldn't work if its
+		 * specified client RTP/RTCP port is not available for NAPT - Ritesh, 19Aug'06 
+	//get_dest_port_num2(pskb, &newdstport);
+	//get_src_port_num2(pskb, &newsrcport);
+	//newport = (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) ? newsrcport : newdstport;
+	//if (newport == exp_driver_info->nat_rtp_port) {
+//		newport = exp_driver_info->loport;
+//	} else if (newport == exp_driver_info->nat_rtcp_port) {
+//		newport = exp_driver_info->hiport;
+//	}     // implement it in different way
+
+newport = (master->status == 0) ? newsrcport : newdstport ;
+
+if (newport == exp->master->rtcp_expect_registered ) {
+      newport = exp->master->rtcp_expect_registered;
+  } else if (newport == exp_driver_info->nat_rtcp_port) {
+      newport = exp_driver_info->hiport;
+  }     // implement it in different way
+
+
+
+	printk("\n(%s): newport =%u  %u   %u   %u", __FUNCTION__,newport,newdstport,newsrcport,ct->status);
+	mr.range[0].flags = IP_NAT_RANGE_PROTO_SPECIFIED;
+	mr.range[0].min.udp.port = newport;
+	mr.range[0].max.udp.port = newport;
+#endif
+
+//newip = newdstip;
+
+// newport = (ct->status == 0) ? newsrcport : newdstport ;
+ 
+	DEBUGP("newsrcip=%u.%u.%u.%u, newdstip=%u.%u.%u.%u, newip=%u.%u.%u.%u \n",
+			NIPQUAD(newsrcip), NIPQUAD(newdstip), NIPQUAD(newip));
+
+	mr.rangesize = 1;
+	 We don't want to manip the per-protocol, just the IPs. 
+	mr.range[0].flags |= IP_NAT_RANGE_MAP_IPS;
+	mr.range[0].min_ip = mr.range[0].max_ip = newip;
+	
+ printk("\n(%s): newport1 = %u   %u   %u    %u ", __FUNCTION__, master->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.udp.port,
+ ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.udp.port,master->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.udp.port,ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.udp.port );
+
+	// return nf_nat_setup_info(ct,(struct nf_nat_multi_range *)&mr, hooknum);
+	 nf_nat_setup_info(ct,(struct nf_nat_multi_range *)&mr, NF_IP_PRE_ROUTING);
 }
+*/
 
+#if 0
 static uint
-help_out(struct sk_buff *skb, enum ip_conntrack_info ctinfo,
-	 unsigned int matchoff, unsigned int matchlen, struct ip_ct_rtsp_expect* prtspexp,
-	 struct nf_conntrack_expect* exp)
+help_out(struct ip_conntrack* ct, enum ip_conntrack_info ctinfo,
+		struct ip_conntrack_expect* exp, struct sk_buff** pskb)
+{
+	char*   ptcp;
+	uint    tcplen;
+	uint    hdrsoff;
+	uint    hdrslen;
+	uint    lineoff;
+	uint    linelen;
+	uint    off;
+
+	struct iphdr* iph = (struct iphdr*)(*pskb)->nh.iph;
+	struct tcphdr* tcph = (struct tcphdr*)((void*)iph + iph->ihl*4);
+
+	struct ip_ct_rtsp_expect* prtspexp = &exp->help.exp_rtsp_info;
+
+	get_skb_tcpdata(*pskb, &ptcp, &tcplen);
+
+	hdrsoff = exp->seq - ntohl(tcph->seq);
+	hdrslen = prtspexp->len;
+	off = hdrsoff;
+
+	while (nf_mime_nextline(ptcp, hdrsoff+hdrslen, &off, &lineoff, &linelen))
+	{
+		if (linelen == 0)
+		{
+			break;
+		}
+		if (off > hdrsoff+hdrslen)
+		{
+			INFOP("!! overrun !!");
+			break;
+		}
+		DEBUGP("hdr: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
+
+		if (nf_strncasecmp(ptcp+lineoff, "Transport:", 10) == 0)
+		{
+			uint oldtcplen = tcplen;
+			if (!rtsp_mangle_tran(ct, ctinfo, exp, pskb, lineoff, linelen))
+			{
+				break;
+			}
+			get_skb_tcpdata(*pskb, &ptcp, &tcplen);
+			hdrslen -= (oldtcplen-tcplen);
+			off -= (oldtcplen-tcplen);
+			lineoff -= (oldtcplen-tcplen);
+			linelen -= (oldtcplen-tcplen);
+			DEBUGP("rep: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
+		}
+	}
+
+
+	return NF_ACCEPT;
+}
+#endif
+
+static uint
+help_out(struct sk_buff **pskb, enum ip_conntrack_info ctinfo,
+	 unsigned int matchoff, unsigned int matchlen,
+         struct nf_ct_rtsp_expect *prtspexp,
+         struct nf_conntrack_expect *exp)
 {
     char*   ptcp;
     uint    tcplen;
@@ -449,15 +860,30 @@
     uint    lineoff;
     uint    linelen;
     uint    off;
+   
+    struct nf_conn *ct ; //added check
+    struct iphdr* iph = ip_hdr(*pskb); //(struct iphdr*)(*pskb)->nh.iph;
+    struct tcphdr* tcph = (struct tcphdr*)((void*)iph + iph->ihl*4);
+ 
+    get_skb_tcpdata(*pskb, &ptcp, &tcplen);
+    DEBUGP(" INSIDE nat help_out \n");
+    hdrsoff = matchoff; //exp->id - ntohl(tcph->seq); //check
+    //hdrsoff = ntohl(tcph->seq); //added
+	//exp->id = ntohl(tcph->seq) - hdrsoff ;
 
-    //struct iphdr* iph = (struct iphdr*)skb->nh.iph;
-    //struct tcphdr* tcph = (struct tcphdr*)((void*)iph + iph->ihl*4);
-
-    get_skb_tcpdata(skb, &ptcp, &tcplen);
-    hdrsoff = matchoff;//exp->seq - ntohl(tcph->seq);
-    hdrslen = matchlen;
+    hdrslen = prtspexp->len;
     off = hdrsoff;
-    DEBUGP("NAT rtsp help_out\n");
+
+
+  DEBUGP("\n help-OUT %u.%u.%u.%u:%u-%u.%u.%u.%u:%u    %u\n",
+                  NIPQUAD(exp->tuple.src.u3.ip),
+                 ntohs(exp->tuple.src.u.udp.port),
+                 NIPQUAD(exp->tuple.dst.u3.ip),
+             ntohs(exp->tuple.dst.u.udp.port),prtspexp->loport);
+
+
+
+ DEBUGP(" INSIDE 2 nat help_out  \n");
 
     while (nf_mime_nextline(ptcp, hdrsoff+hdrslen, &off, &lineoff, &linelen))
     {
@@ -467,91 +893,184 @@
         }
         if (off > hdrsoff+hdrslen)
         {
-            INFOP("!! overrun !!");
+           // INFOP("!! overrun !!");
             break;
         }
-        DEBUGP("hdr: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
+
+       DEBUGP(" INSIDE 3 nat help_out  \n");
+        DEBUGP("hdr: len=%u, %.*s \n", linelen, (int)linelen, ptcp+lineoff);
 
         if (nf_strncasecmp(ptcp+lineoff, "Transport:", 10) == 0)
         {
             uint oldtcplen = tcplen;
-	    DEBUGP("hdr: Transport\n");
-            if (!rtsp_mangle_tran(ctinfo, exp, prtspexp, skb, lineoff, linelen))
+            if (!rtsp_mangle_tran(ct, ctinfo, exp, prtspexp, pskb, lineoff, linelen))
             {
-		DEBUGP("hdr: Transport mangle failed");
                 break;
             }
-            get_skb_tcpdata(skb, &ptcp, &tcplen);
+            get_skb_tcpdata(*pskb, &ptcp, &tcplen);
             hdrslen -= (oldtcplen-tcplen);
-            off -= (oldtcplen-tcplen);
+	    off -= (oldtcplen-tcplen);
             lineoff -= (oldtcplen-tcplen);
             linelen -= (oldtcplen-tcplen);
-            DEBUGP("rep: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
+            DEBUGP("rep: len=%u, %.*s \n", linelen, (int)linelen, ptcp+lineoff);
         }
     }
-
+   
+    DEBUGP(" outside nat help_out \n"); 
     return NF_ACCEPT;
 }
 
-static unsigned int
-help(struct sk_buff *skb, enum ip_conntrack_info ctinfo,
-     unsigned int matchoff, unsigned int matchlen, struct ip_ct_rtsp_expect* prtspexp,
-     struct nf_conntrack_expect* exp)
+
+
+#if 0
+static uint
+help_in(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
+		struct nf_conntrack_expect *exp, struct sk_buff **pskb)
+{
+	/* XXX: unmangle */
+	return NF_ACCEPT;
+}
+#endif
+
+#if 0
+static uint
+help(struct ip_conntrack* ct,
+		struct ip_conntrack_expect* exp,
+		struct ip_nat_info* info,
+		enum ip_conntrack_info ctinfo,
+		unsigned int hooknum,
+		struct sk_buff** pskb)
 {
+	struct iphdr*  iph  = (struct iphdr*)(*pskb)->nh.iph;
+	struct tcphdr* tcph = (struct tcphdr*)((char*)iph + iph->ihl * 4);
+	uint datalen;
+	int dir;
+	struct ip_ct_rtsp_expect* ct_rtsp_info;
+	int rc = NF_ACCEPT;
+
+
+	if (ct == NULL || exp == NULL || info == NULL || pskb == NULL)
+	{
+		DEBUGP("!! null ptr (%p,%p,%p,%p) !!\n", ct, exp, info, pskb);
+		return NF_ACCEPT;
+	}
+
+	ct_rtsp_info = &exp->help.exp_rtsp_info;
+
+	/*
+	 * Only mangle things once: original direction in POST_ROUTING
+	 * and reply direction on PRE_ROUTING.
+	 */
+	dir = CTINFO2DIR(ctinfo);
+	if (!((hooknum == NF_IP_POST_ROUTING && dir == IP_CT_DIR_ORIGINAL)
+				|| (hooknum == NF_IP_PRE_ROUTING && dir == IP_CT_DIR_REPLY)))
+	{
+		DEBUGP("Not touching dir %s at hook %s\n",
+				dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
+				hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
+				: hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
+				: hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???");
+		return NF_ACCEPT;
+	}
+	DEBUGP("got beyond not touching\n");
+
+	datalen = (*pskb)->len - iph->ihl * 4 - tcph->doff * 4;
+
+	//LOCK_BH(&ip_rtsp_lock);
+	  spin_lock_bh(&ip_rtsp_lock);
+
+	/* Ensure the packet contains all of the marked data */
+	if (!between(exp->seq + ct_rtsp_info->len,
+				ntohl(tcph->seq), ntohl(tcph->seq) + datalen))
+	{
+		/* Partial retransmission?  Probably a hacker. */
+		if (net_ratelimit())
+		{
+			INFOP("partial packet %u/%u in %u/%u\n",
+					exp->seq, ct_rtsp_info->len, ntohl(tcph->seq), ntohl(tcph->seq) + datalen);
+		}
+		//UNLOCK_BH(&ip_rtsp_lock);
+		spin_unlock_bh(&ip_rtsp_lock);
+
+		return NF_DROP;
+	}
+
+	switch (dir)
+	{
+		case IP_CT_DIR_ORIGINAL:
+			rc = help_out(ct, ctinfo, exp, pskb);
+			break;
+		case IP_CT_DIR_REPLY:
+			rc = help_in(ct, ctinfo, exp, pskb);
+			break;
+		default:
+			/* oops */
+	}
+	//UNLOCK_BH(&ip_rtsp_lock);
+      spin_unlock_bh(&ip_rtsp_lock);
+
+	return rc;
+}
+#endif
+
+//added 
+
+
+
+static unsigned  int
+nf_nat_rtsp(struct sk_buff **pskb,
+     enum ip_conntrack_info ctinfo,
+    unsigned int matchoff, unsigned int matchlen,
+     struct nf_ct_rtsp_expect *ct_rtsp_info,
+     struct nf_conntrack_expect *exp)
+{
+//    struct iphdr*  iph  = (struct iphdr*)(*pskb)->nh.iph;
+   // struct tcphdr* tcph = (struct tcphdr*)((char*)iph + iph->ihl * 4);
+   // uint datalen;
     int dir = CTINFO2DIR(ctinfo);
     int rc = NF_ACCEPT;
-
+    exp_driver_info = ct_rtsp_info;
+     DEBUGP(" INSIDE nf_nat_rtsp  \n"); 
     switch (dir)
     {
     case IP_CT_DIR_ORIGINAL:
-        rc = help_out(skb, ctinfo, matchoff, matchlen, prtspexp, exp);
+        rc = help_out(pskb, ctinfo, matchoff, matchlen, ct_rtsp_info, exp);
         break;
     case IP_CT_DIR_REPLY:
-	DEBUGP("unmangle ! %u\n", ctinfo);
-    	/* XXX: unmangle */
-	rc = NF_ACCEPT;
+         DEBUGP(" INSIDE nat ip_ct_dir_reply \n");
+        /* XXX: unmangle */
+        rc = NF_ACCEPT;
         break;
     }
-    //UNLOCK_BH(&ip_rtsp_lock);
 
     return rc;
 }
 
-static void expected(struct nf_conn* ct, struct nf_conntrack_expect *exp)
-{
-#ifdef CONFIG_RTSP_ALG_FIX
-	nf_nat_follow_master(ct,exp);
-#else
-    struct nf_nat_multi_range_compat mr;
-    u_int32_t newdstip, newsrcip, newip;
-
-    struct nf_conn *master = ct->master;
 
-    newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
-    newsrcip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
-    //FIXME (how to port that ?)
-    //code from 2.4 : newip = (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) ? newsrcip : newdstip;
-    newip = newdstip;
 
-    DEBUGP("newsrcip=%u.%u.%u.%u, newdstip=%u.%u.%u.%u, newip=%u.%u.%u.%u\n",
-           NIPQUAD(newsrcip), NIPQUAD(newdstip), NIPQUAD(newip));
-
-    mr.rangesize = 1;
-    // We don't want to manip the per-protocol, just the IPs.
-    mr.range[0].flags = IP_NAT_RANGE_MAP_IPS;
-    mr.range[0].min_ip = mr.range[0].max_ip = newip;
-
-    nf_nat_setup_info(ct, &mr.range[0], IP_NAT_MANIP_DST);
+#ifndef IFX_RTSP_NAT_ALG
+//static struct ip_nat_helper ip_nat_rtsp_helpers[MAX_PORTS];
+//static char rtsp_names[MAX_PORTS][10];
 #endif
-}
 
-
-static void __exit fini(void)
+/* This function is intentionally _NOT_ defined as  __exit */
+	static void
+fini(void)
 {
 #ifndef IFX_RTSP_NAT_ALG
-	nf_nat_rtsp_hook = NULL;
-        nf_nat_rtsp_hook_expectfn = NULL;
-	synchronize_net();
+
+	/*int i;
+
+	for (i = 0; i < num_ports; i++)
+	{
+		DEBUGP("unregistering helper for port %d\n", ports[i]);
+		ip_nat_helper_unregister(&ip_nat_rtsp_helpers[i]);
+	}*/
+
+        //ip_nat_rtsp_hook = NULL;
+	rcu_assign_pointer(nf_nat_rtsp_hook, NULL);
+	nf_nat_rtsp_hook_expectfn = NULL;
+        synchronize_net();
 
 #else
 
@@ -587,20 +1106,73 @@
 
 }
 
-static int __init init(void)
+	static int __init
+init(void)
 {
-	printk("nf_nat_rtsp v" IP_NF_RTSP_VERSION " loading\n");
+	int ret = 0;
+
+/*#ifndef IFX_RTSP_NAT_ALG
+	int i;
+	struct ip_nat_helper* hlpr;
+	char* tmpname;
+#endif*/
+
+	printk("ip_nat_rtsp v" IP_NF_RTSP_VERSION " loading\n");
+
 #ifndef IFX_RTSP_NAT_ALG
-	BUG_ON(nf_nat_rtsp_hook);
-	nf_nat_rtsp_hook = help;
-        nf_nat_rtsp_hook_expectfn = &expected;
-#else
 
+	/*if (ports[0] == 0)
+	{
+		ports[0] = RTSP_PORT;
+	}
+
+	for (i = 0; (i < MAX_PORTS) && ports[i] != 0; i++)
+	{
+		hlpr = &ip_nat_rtsp_helpers[i];
+		memset(hlpr, 0, sizeof(struct ip_nat_helper));
+
+		hlpr->tuple.dst.protonum = IPPROTO_TCP;
+		hlpr->tuple.src.u.tcp.port = htons(ports[i]);
+		hlpr->mask.src.u.tcp.port = 0xFFFF;
+		hlpr->mask.dst.protonum = 0xFFFF;
+		hlpr->help = help;
+		hlpr->flags = 0;
+		hlpr->me = THIS_MODULE;
+		hlpr->expect = expected;
+
+		tmpname = &rtsp_names[i][0];
+		if (ports[i] == RTSP_PORT)
+		{
+			sprintf(tmpname, "rtsp");
+		}
+		else
+		{
+			sprintf(tmpname, "rtsp-%d", i);
+		}
+		hlpr->name = tmpname;
+
+		DEBUGP("registering helper for port %d: name %s\n", ports[i], hlpr->name);
+		ret = ip_nat_helper_register(hlpr);
+
+		if (ret)
+		{
+			printk("ip_nat_rtsp: error registering helper for port %d\n", ports[i]);
+			fini();
+			return 1;
+		}
+		num_ports++;
+	}*/
 
+     //   ip_nat_rtsp_hook = ip_nat_rtsp;
 
+ rcu_assign_pointer(nf_nat_rtsp_hook, nf_nat_rtsp );
+ nf_nat_rtsp_hook_expectfn = &expected ;
 
+ DEBUGP(" INSIDE INIT \n");
 
- NDEBUG("Registering Rtsp_device\n");
+#else
+
+	NDEBUG("Registering Rtsp_device\n");
 	ret = register_chrdev(MAJOR_NUM_RTSP, DEVICE_FILE_NAME_RTSP, &rtsp_Fops);
 
 	/* Negative values signify an error */
@@ -617,21 +1189,30 @@
 #endif
 
 	if (stunaddr != NULL)
+	{
 		extip = in_aton(stunaddr);
-
-	if (destaction != NULL) {
-	        if (strcmp(destaction, "auto") == 0)
+	}
+	if (destaction != NULL)
+	{
+		if (strcmp(destaction, "auto") == 0)
+		{
 			dstact = DSTACT_AUTO;
-
+		}
 		if (strcmp(destaction, "strip") == 0)
+		{
 			dstact = DSTACT_STRIP;
-
+		}
 		if (strcmp(destaction, "none") == 0)
+		{
 			dstact = DSTACT_NONE;
+		}
 	}
-	return 0; 
+	return ret;
 }
 
+
+
+
 #ifdef IFX_RTSP_NAT_ALG
 
 static int rtsp_device_port_register(struct rtsp_params* rtspparam)
@@ -914,3 +1495,4 @@
 
 module_init(init);
 module_exit(fini);
+
Index: linux/net/netfilter/nf_conntrack_rtsp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_rtsp.c	2011-01-07 12:09:09.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_rtsp.c	2011-01-07 12:15:00.674651272 +0530
@@ -1,6 +1,6 @@
 /*
  * RTSP extension for IP connection tracking
- * (C) 2003 by Tom Marshall <tmarshall at real.com>
+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
  * based on ip_conntrack_irc.c
  *
  *      This program is free software; you can redistribute it and/or
@@ -9,7 +9,7 @@
  *      2 of the License, or (at your option) any later version.
  *
  * Module load syntax:
- *   insmod nf_conntrack_rtsp.o ports=port1,port2,...port<MAX_PORTS>
+ *   insmod ip_conntrack_rtsp.o ports=port1,port2,...port<MAX_PORTS>
  *                              max_outstanding=n setup_timeout=secs
  *
  * If no ports are specified, the default will be port 554.
@@ -18,27 +18,21 @@
  * answered SETUP requests per RTSP session (default 8).
  * With setup_timeout you can specify how long the system waits for
  * an expected data channel (default 300 seconds).
- *
- * 2005-02-13: Harald Welte <laforge at netfilter.org>
- * 	- port to 2.6
- * 	- update to recent post-2.6.11 api changes
- * 2006-09-14: Steven Van Acker <deepstar at singularity.be>
- *      - removed calls to NAT code from conntrack helper: NAT no longer needed to use rtsp-conntrack
- * 2007-04-18: Michael Guntsche <mike at it-loops.com>
- * 			- Port to new NF API
  */
 
+
 #include <linux/module.h>
 #include <linux/netfilter.h>
 #include <linux/ip.h>
-#include <linux/inet.h>
+#include <net/checksum.h>
 #include <net/tcp.h>
 
-#include <net/netfilter/nf_conntrack.h>
-#include <net/netfilter/nf_conntrack_expect.h>
+//#include <linux/netfilter_ipv4/lockhelp.h>
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <linux/netfilter/nf_conntrack_rtsp.h>
+#include <net/netfilter/nf_conntrack_expect.h>
 
+#include <linux/ctype.h>
 #define NF_NEED_STRNCASECMP
 #define NF_NEED_STRTOU16
 #define NF_NEED_STRTOU32
@@ -47,8 +41,9 @@
 #define NF_NEED_MIME_NEXTLINE
 #include <linux/netfilter_mime.h>
 
-#include <linux/ctype.h>
+#define IFX_RTSP_NAT_ALG
 #undef IFX_RTSP_NAT_ALG
+#define IFX_TEST
 #undef IFX_TEST
 
 #ifdef IFX_RTSP_NAT_ALG
@@ -66,13 +61,28 @@
 #endif
 
 #define MAX_SIMUL_SETUP 8 /* XXX: use max_outstanding */
-#define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
-#if 0
-#define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
+
+//#define IP_NF_RTSP_DEBUG
+#undef IP_DYNAMIC_RTSP_DEBUG
+
+#define INFOP(args...) printk(KERN_INFO __FILE__ ":" __FUNCTION__ ":" args)
+
+#ifdef IP_DYNAMIC_RTSP_DEBUG
+#define NCDEBUG(format,args...) printk(" \n Neeraj_CONN " ": " __FILE__  " : " __FUNCTION__ " : "format,##args)
+#else
+#define NCDEBUG(format,args...)
+#endif
+
+#ifdef IP_NF_RTSP_DEBUG
+//#define DEBUGP(args...) printk(KERN_DEBUG __FILE__ ":" __FUNCTION__ ":" args)
+#define DEBUGP(args...) printk(args)
 #else
-#define DEBUGP(fmt, args...)
+#define DEBUGP(args...)
+//#define DEBUGP printk
 #endif
 
+//#define DEBUGP printk
+
 #define MAX_PORTS 8
 #ifndef IFX_RTSP_NAT_ALG
 
@@ -83,30 +93,42 @@
 static int max_outstanding = 8;
 static unsigned int setup_timeout =100; //300;
 
-MODULE_AUTHOR("Tom Marshall <tmarshall at real.com>");
+
+MODULE_AUTHOR("Tom Marshall <tmarshall@real.com>");
 MODULE_DESCRIPTION("RTSP connection tracking module");
 MODULE_LICENSE("GPL");
-module_param_array(ports, int, &num_ports, 0400);
+
+#ifdef MODULE_PARM
+
+#ifndef IFX_RTSP_NAT_ALG
+MODULE_PARM(ports, "1-" __MODULE_STRING(MAX_PORTS) "i");
 MODULE_PARM_DESC(ports, "port numbers of RTSP servers");
-module_param(max_outstanding, int, 0400);
+MODULE_PARM(max_outstanding, "i");
 MODULE_PARM_DESC(max_outstanding, "max number of outstanding SETUP requests per RTSP session");
-module_param(setup_timeout, int, 0400);
+MODULE_PARM(setup_timeout, "i");
 MODULE_PARM_DESC(setup_timeout, "timeout on for unestablished data channels");
+#endif
+
+#endif
 
-static char *rtsp_buffer;
-static DEFINE_SPINLOCK(rtsp_buffer_lock);
 
-unsigned int (*nf_nat_rtsp_hook)(struct sk_buff *skb,
-				 enum ip_conntrack_info ctinfo,
-				 unsigned int matchoff, unsigned int matchlen,struct ip_ct_rtsp_expect* prtspexp,
-				 struct nf_conntrack_expect *exp);
-void (*nf_nat_rtsp_hook_expectfn)(struct nf_conn *ct, struct nf_conntrack_expect *exp);
+//DECLARE_LOCK(ip_rtsp_lock);
 
-#ifdef CONFIG_RTSP_ALG_FIX
-extern void nf_ct_expect_insert_rtcp (struct nf_conntrack_expect *exp) ;
+DEFINE_SPINLOCK(ip_rtsp_lock);
+
+#ifndef  IFX_RTSP_NAT_ALG
+struct module* nf_conntrack_rtsp = THIS_MODULE;
 #endif
 
-EXPORT_SYMBOL_GPL(nf_nat_rtsp_hook);
+
+/* protects rtsp part of conntracks */
+
+//DECLARE_LOCK_EXTERN(ip_rtsp_lock);
+
+ extern spinlock_t ip_rtsp_lock;
+ 
+// 6th july DECLARE_RWLOCK(ip_rtsp_rwlock);
+
 
 /*
  * Max mappings we will allow for one RTSP connection (for RTP, the number
@@ -116,8 +138,21 @@
  */
 #define MAX_PORT_MAPS 16
 
+#ifndef IFX_RTSP_NAT_ALG
+static char rtsp_buffer[65536];
+//static DEFINE_SPINLOCK(rtsp_buffer_lock);
+unsigned int (*nf_nat_rtsp_hook)(struct sk_buff **pskb,
+                                 enum ip_conntrack_info ctinfo,
+				 unsigned int matchoff, unsigned int matchlen,
+                                 struct nf_ct_rtsp_expect *expinfo,
+                                 struct nf_conntrack_expect *exp);
 
+void (*nf_nat_rtsp_hook_expectfn)(struct nf_conn *ct, struct nf_conntrack_expect *exp);
 
+extern void nf_ct_expect_insert_rtcp (struct nf_conntrack_expect *exp) ;
+
+EXPORT_SYMBOL_GPL(nf_nat_rtsp_hook);
+#endif
 
 #ifdef IFX_RTSP_NAT_ALG
 
@@ -184,40 +219,42 @@
  */
 static int
 rtsp_parse_message(char* ptcp, uint tcplen, uint* ptcpoff,
-                   uint* phdrsoff, uint* phdrslen,
-                   uint* pcseqoff, uint* pcseqlen,
-                   uint* transoff, uint* translen)
+		uint* phdrsoff, uint* phdrslen,
+		uint* pcseqoff, uint* pcseqlen)
 {
 	uint    entitylen = 0;
 	uint    lineoff;
 	uint    linelen;
 
 	if (!nf_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen))
+	{
 		return 0;
+	}
 
 	*phdrsoff = *ptcpoff;
-	while (nf_mime_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen)) {
-		if (linelen == 0) {
+	while (nf_mime_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen))
+	{
+		if (linelen == 0)
+		{
 			if (entitylen > 0)
+			{
 				*ptcpoff += min(entitylen, tcplen - *ptcpoff);
+			}
 			break;
 		}
-		if (lineoff+linelen > tcplen) {
-			INFOP("!! overrun !!\n");
+		if (lineoff+linelen > tcplen)
+		{
+			//INFOP("!! overrun !!\n");
 			break;
 		}
 
-		if (nf_strncasecmp(ptcp+lineoff, "CSeq:", 5) == 0) {
+		if (nf_strncasecmp(ptcp+lineoff, "CSeq:", 5) == 0)
+		{
 			*pcseqoff = lineoff;
 			*pcseqlen = linelen;
 		}
-
-		if (nf_strncasecmp(ptcp+lineoff, "Transport:", 10) == 0) {
-			*transoff = lineoff;
-			*translen = linelen;
-		}
-
-		if (nf_strncasecmp(ptcp+lineoff, "Content-Length:", 15) == 0) {
+		if (nf_strncasecmp(ptcp+lineoff, "Content-Length:", 15) == 0)
+		{
 			uint off = lineoff+15;
 			SKIP_WSPACE(ptcp+lineoff, linelen, off);
 			nf_strtou32(ptcp+off, &entitylen);
@@ -228,6 +265,21 @@
 	return 1;
 }
 
+#ifdef CONFIG_IFX_ALG_QOS
+
+static void rtsp_expect(struct nf_conn *ct, struct nf_conntrack_expect *this)
+{
+	DEBUGP("rtsp_expect: helper for %p added\n", ct);
+
+	// Tranport protocol helper
+	ct->ifx_alg_qos_mark = IFX_ALG_APP_RTSP | IFX_ALG_PROTO_RTP ;
+
+	DEBUGP("rtsp_expect: helper for %p added and ifx_alg_qos_mark is %x\n", ct,ct->ifx_alg_qos_mark);
+
+	//return NF_ACCEPT;   /* unused */
+}
+#endif
+
 /*
  * Find lo/hi client ports (if any) in transport header
  * In:
@@ -244,23 +296,25 @@
  */
 static int
 rtsp_parse_transport(char* ptran, uint tranlen,
-                     struct ip_ct_rtsp_expect* prtspexp)
+		struct nf_ct_rtsp_expect* prtspexp)
 {
 	int     rc = 0;
 	uint    off = 0;
 
+
 	if (tranlen < 10 || !iseol(ptran[tranlen-1]) ||
-	    nf_strncasecmp(ptran, "Transport:", 10) != 0) {
-		INFOP("sanity check failed\n");
+			nf_strncasecmp(ptran, "Transport:", 10) != 0)
+	{
+		//INFOP("sanity check failed\n");
 		return 0;
 	}
-
 	DEBUGP("tran='%.*s'\n", (int)tranlen, ptran);
 	off += 10;
 	SKIP_WSPACE(ptran, tranlen, off);
 
 	/* Transport: tran;field;field=val,tran;field;field=val,... */
-	while (off < tranlen) {
+	while (off < tranlen)
+	{
 		const char* pparamend;
 		uint        nextparamoff;
 
@@ -268,42 +322,54 @@
 		pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
 		nextparamoff = pparamend-ptran;
 
-		while (off < nextparamoff) {
+		while (off < nextparamoff)
+		{
 			const char* pfieldend;
 			uint        nextfieldoff;
 
 			pfieldend = memchr(ptran+off, ';', nextparamoff-off);
 			nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
 
-			if (strncmp(ptran+off, "client_port=", 12) == 0) {
+			if (strncmp(ptran+off, "client_port=", 12) == 0)
+			{
 				u_int16_t   port;
 				uint        numlen;
 
 				off += 12;
 				numlen = nf_strtou16(ptran+off, &port);
 				off += numlen;
+				//for testing 
+			//	prtspexp->pbtype = pb_single;
+				
 				if (prtspexp->loport != 0 && prtspexp->loport != port)
+				{
 					DEBUGP("multiple ports found, port %hu ignored\n", port);
-				else {
-					DEBUGP("lo port found : %hu\n", port);
+				}
+				else
+				{
 					prtspexp->loport = prtspexp->hiport = port;
-					if (ptran[off] == '-') {
+					if (ptran[off] == '-')
+					{
 						off++;
 						numlen = nf_strtou16(ptran+off, &port);
 						off += numlen;
 						prtspexp->pbtype = pb_range;
 						prtspexp->hiport = port;
-
+                       
+					    //printk ("\n INSIDE the RANGE \n ");
 						// If we have a range, assume rtp:
 						// loport must be even, hiport must be loport+1
 						if ((prtspexp->loport & 0x0001) != 0 ||
-						    prtspexp->hiport != prtspexp->loport+1) {
+								prtspexp->hiport != prtspexp->loport+1)
+						{
 							DEBUGP("incorrect range: %hu-%hu, correcting\n",
-							       prtspexp->loport, prtspexp->hiport);
+									prtspexp->loport, prtspexp->hiport);
 							prtspexp->loport &= 0xfffe;
 							prtspexp->hiport = prtspexp->loport+1;
 						}
-					} else if (ptran[off] == '/') {
+					}
+					else if (ptran[off] == '/')
+					{
 						off++;
 						numlen = nf_strtou16(ptran+off, &port);
 						off += numlen;
@@ -327,238 +393,613 @@
 		off = nextparamoff;
 	}
 
+
 	return rc;
 }
 
-void expected(struct nf_conn *ct, struct nf_conntrack_expect *exp)
+/*
+ * Find lo/hi server and client ports (if any) in transport header
+ * In:
+ *   ptcp, tcplen = packet
+ *   tranoff, tranlen = buffer to search
+ *
+ * Out:
+ *   pport_lo, pport_hi = lo/hi ports (host endian)
+ *
+ * Returns nonzero if any client ports found
+ *
+ * Note: it is valid (and expected) for the client to request multiple
+ * transports, so we need to parse the entire line.
+*/
+
+#if 0
+static int
+rtsp_parse_transport_reply (char* ptran, uint tranlen,
+		struct nf_ct_rtsp_expect* prtspexp)
 {
-    if(nf_nat_rtsp_hook_expectfn) {
-        nf_nat_rtsp_hook_expectfn(ct,exp);
-    }
+	int     rc = 0;
+	uint    off = 0;
+
+	if (tranlen < 10 || !iseol(ptran[tranlen-1]) ||
+			nf_strncasecmp(ptran, "Transport:", 10) != 0)
+	{
+		//INFOP("sanity check failed\n");
+		return 0;
+	}
+	DEBUGP("tran='%.*s'\n", (int)tranlen, ptran);
+	off += 10;
+	SKIP_WSPACE(ptran, tranlen, off);
+
+	/* Transport: tran;field;field=val,tran;field;field=val,... */
+	while (off < tranlen)
+	{
+		const char* pparamend;
+		uint        nextparamoff;
+
+		pparamend = memchr(ptran+off, ',', tranlen-off);
+		pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
+		nextparamoff = pparamend-ptran;
+
+		DEBUGP ("[435] Default Streaming using RTP..\n");
+		prtspexp->rtsp_protocol = IP_CT_RTSP_RTP;
+
+		while (off < nextparamoff)
+		{
+			const char* pfieldend;
+			uint        nextfieldoff;
+
+			pfieldend = memchr(ptran+off, ';', nextparamoff-off);
+			nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
+
+
+			if (strncmp(ptran+off, "x-real-rdt/udp", 14) == 0)
+			{
+				DEBUGP ("[491] Streaming using RDT..\n");
+				prtspexp->rtsp_protocol = IP_CT_RTSP_RDT;
+			}
+
+			/*
+			 * Note we don't look for the destination parameter here.
+			 * If we are using NAT, the NAT module will handle it.  If not,
+			 * and the client is sending packets elsewhere, the expectation
+			 * will quietly time out.
+			 */
+
+			off = nextfieldoff;
+		}
+
+		off = nextparamoff;
+	}
+
+	return rc;
 }
 
+#endif
+
+/* Expect for RTCP port */
+static void expected(struct nf_conn *ct, struct nf_conntrack_expect *exp)                                                                            
+{                                                                                                                                                    
+    if(nf_nat_rtsp_hook_expectfn) {                                                                                                                  
+        nf_nat_rtsp_hook_expectfn(ct,exp);                                                                                                           
+    }                                                                                                                                                
+}                                                                                                                                                    
+  
+
+
 /*** conntrack functions ***/
 
 /* outbound packet: client->server */
-
-static inline int
-help_out(struct sk_buff *skb, unsigned char *rb_ptr, unsigned int datalen,
-                struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+int
+help_out(struct sk_buff *skb,unsigned char *rb_ptr,unsigned int datalen,
+		struct nf_conn* ct, enum ip_conntrack_info ctinfo)
 {
-	struct ip_ct_rtsp_expect expinfo;
-
 	int dir = CTINFO2DIR(ctinfo);   /* = IP_CT_DIR_ORIGINAL */
 	//struct  tcphdr* tcph = (void*)iph + iph->ihl * 4;
 	//uint    tcplen = pktlen - iph->ihl * 4;
-	char*   pdata = rb_ptr;
-	//uint    datalen = tcplen - tcph->doff * 4;
-	uint    dataoff = 0;
-	int ret = NF_ACCEPT;
+	//char*   pdata = (char*)tcph + tcph->doff * 4;
+	//uint    datalen = tcplen - tcph->doff * 4
+      struct iphdr* iph = ip_hdr(skb); //(struct iphdr*)(*pskb)->nh.iph;
+      struct tcphdr* tcph = (struct tcphdr*)((void*)iph + iph->ihl*4);
 
-#ifdef CONFIG_RTSP_ALG_FIX
+	struct nf_ct_rtsp_expect expinfo;
+	uint    dataoff = 0;
+        char *pdata = rb_ptr;
 	struct nf_conntrack_expect *exp, *exp1;
-	 struct nf_conn *ct1;
-	 u_int32_t   newip1;
-	  __be16   be_lortcpport;
-#else
-	struct nf_conntrack_expect *exp;
-#endif
-	__be16 be_loport;
+         int ret = NF_ACCEPT;
+	typeof(nf_nat_rtsp_hook) nf_nat_rtsp;
+
+	struct sk_buff *pskb;
+         struct nf_conn *ct1;                                                                                                             
+         u_int32_t   newip1;                                                                                                                   
+
+
+   DEBUGP("dir %u\n", dir);
 
-	memset(&expinfo, 0, sizeof(expinfo));
+#ifdef CONFIG_IFX_ALG_QOS //  Suresh
+
+
+	ct->ifx_alg_qos_mark = IFX_ALG_APP_RTSP;
+	DEBUGP ("\nRTSP_ALG: help_out marked ct->ifx_alg_qos_mark to : %x ***\n",
+							                                ct->ifx_alg_qos_mark );
+#endif
 
-	while (dataoff < datalen) {
+	while (dataoff < datalen)
+	{
 		uint    cmdoff = dataoff;
 		uint    hdrsoff = 0;
 		uint    hdrslen = 0;
 		uint    cseqoff = 0;
 		uint    cseqlen = 0;
-		uint    transoff = 0;
-		uint    translen = 0;
+		uint    lineoff = 0;
+		uint    linelen = 0;
 		uint    off;
+	//	int     rc;
 
 		if (!rtsp_parse_message(pdata, datalen, &dataoff,
 					&hdrsoff, &hdrslen,
-					&cseqoff, &cseqlen,
-					&transoff, &translen))
+					&cseqoff, &cseqlen))
+		{
 			break;      /* not a valid message */
+		}
 
 		if (strncmp(pdata+cmdoff, "SETUP ", 6) != 0)
+		{
 			continue;   /* not a SETUP message */
+		}
 		DEBUGP("found a setup message\n");
 
+		memset(&expinfo, 0, sizeof(expinfo));
+
 		off = 0;
-		if(translen) {
-			rtsp_parse_transport(pdata+transoff, translen, &expinfo);
+		while (nf_mime_nextline(pdata+hdrsoff, hdrslen, &off,
+					&lineoff, &linelen))
+		{
+			if (linelen == 0)
+			{
+				break;
+			}
+			if (off > hdrsoff+hdrslen)
+			{
+				//INFOP("!! overrun !!");
+				break;
+			}
+
+			if (nf_strncasecmp(pdata+hdrsoff+lineoff, "Transport:", 10) == 0)
+			{
+				rtsp_parse_transport(pdata+hdrsoff+lineoff, linelen,
+						&expinfo);
+			}
 		}
 
-		if (expinfo.loport == 0) {
-			DEBUGP("no udp transports found\n");
+		if (expinfo.loport == 0)
+		{
+			printk("no udp transports found\n");
 			continue;   /* no udp transports found */
 		}
 
-		DEBUGP("udp transport found, ports=(%d,%hu,%hu)\n",
-		       (int)expinfo.pbtype, expinfo.loport, expinfo.hiport);
+		DEBUGP("udp transport found, ports=(%d,%hu,%hu) \n",
+				(int)expinfo.pbtype,
+				expinfo.loport,
+				expinfo.hiport);
+
 
 		exp = nf_ct_expect_alloc(ct);
-		if (!exp) {
-			ret = NF_DROP;
-			goto out;
-		}
+		        if (!exp) {
+                		ret = NF_DROP;
+		                goto out;
+			         }
 
-		be_loport = htons(expinfo.loport);
 
+		//LOCK_BH(&ip_rtsp_lock);
+		spin_lock_bh(&ip_rtsp_lock);
+	
 		nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,
-			ct->tuplehash[!dir].tuple.src.l3num,
-			&ct->tuplehash[!dir].tuple.src.u3, &ct->tuplehash[!dir].tuple.dst.u3,
-			IPPROTO_UDP, NULL, &be_loport);
+				ct->tuplehash[!dir].tuple.src.l3num,
+				&ct->tuplehash[!dir].tuple.src.u3,
+				&ct->tuplehash[!dir].tuple.dst.u3,
+				IPPROTO_UDP, NULL, &(expinfo.loport));
+
+		 //exp->id = ntohl(tcph->seq) + hdrsoff; /* mark all the headers */ //added
+		expinfo.len = hdrslen; // added
+        	exp->master = ct ;
+
+		exp->tuple.src.u3 = ct->tuplehash[!dir].tuple.src.u3;
+	   //	exp->mask.src.u3.ip  = 0xffffffff; //orginal
+	  
+	    //exp->timeout = time_out;
+	   // exp->mask.src.u3.ip  = 0;
+	//	exp->timeout.data = (unsigned long)exp;
+	    //exp->timeout.function = expectation_timed_out;
+	  //  exp->timeout.expires = jiffies + time_out * HZ;
+				
+
+	   
+	    exp->tuple.src.u.tcp.port = 0;
+//		exp->mask.src.u.udp.port  = 0 ; 
+		
+	    exp->tuple.src.l3num = PF_INET ;
+		//exp->mask.src.u.all = 0xffff;
+		
+		exp->tuple.dst.u3 = ct->tuplehash[dir].tuple.src.u3;
+		//exp->mask.dst.u3.ip  = 0xffffffff;
+	//	exp->tuple.dst.u.udp.port = expinfo.loport; //check
+	//	exp->mask.dst.u.udp.port  = (expinfo.pbtype == pb_range) ? 0xfffe : 0xffff; //check
+		//exp->mask.dst.u.udp.port  = 0xffff;
 
-		exp->master = ct;
+		if (expinfo.pbtype == pb_range) {
+		//	printk("Changing expectation mask to handle multiple ports\n");
+		//	exp->mask.src.u.udp.port  = 0xfffe;  // commented for
+		//	testing : desai
+		}
 
-		exp->expectfn = expected;
+		exp->tuple.dst.protonum = IPPROTO_UDP;
+		//exp->mask.dst.protonum  = 0xff;
+        
+		exp->helper = NULL;
 		exp->flags = 0;
+		exp->expectfn = expected; //NULL; //testing : desai
 
-		if (expinfo.pbtype == pb_range) {
-			DEBUGP("Changing expectation mask to handle multiple ports\n");
-			exp->mask.src.u.udp.port  = 0xfffe;
-		}
+        expinfo.hiport = expinfo.loport + 1 ;
+		
+		//Nirav
+#ifdef CONFIG_IFX_ALG_QOS
+		exp->expectfn =  rtsp_expect;
+		//exp.help.exp_rtsp_info.rtcp_dir = IP_CT_DIR_ORIGINAL; //check out 
+		//exp->helper = &transport_helper;
 
-		DEBUGP("expect_related %u.%u.%u.%u:%u-%u.%u.%u.%u:%u\n",
-		       NIPQUAD(exp->tuple.src.u3.ip),
-		       ntohs(exp->tuple.src.u.udp.port),
-		       NIPQUAD(exp->tuple.dst.u3.ip),
-		       ntohs(exp->tuple.dst.u.udp.port));
-
-		if (nf_nat_rtsp_hook)
-			/* pass the request off to the nat helper */
-			ret = nf_nat_rtsp_hook(skb, ctinfo, hdrsoff, hdrslen, &expinfo, exp);
-		else if (nf_ct_expect_related(exp) != 0) {
-			INFOP("nf_ct_expect_related failed\n");
-#ifndef CONFIG_RTSP_ALG_FIX
-			ret  = NF_DROP;
+		exp->master->rtcp_expect_registered = 2 ;
+		expinfo.rtcp_dir = IP_CT_DIR_ORIGINAL;
+#endif
+
+		DEBUGP("expect_related %u.%u.%u.%u:%u-%u.%u.%u.%u:%u    %u\n",
+				NIPQUAD(exp->tuple.src.u3.ip),
+				ntohs(exp->tuple.src.u.udp.port),
+				NIPQUAD(exp->tuple.dst.u3.ip),
+				ntohs(exp->tuple.dst.u.udp.port),expinfo.loport);
+                 
+#if 0 // IFX_TEST
+   if(nf_conntrack_expect_related(exp) != 0)
+   {
+       printk ("\n expect FAILED \n");
+	   goto test;
+   }
 #endif
+		//printk("Changing pskb --->skb 1\n"); 
+				 
+		nf_nat_rtsp = rcu_dereference(nf_nat_rtsp_hook);
+
+		//printk("Changing pskb --->skb 2 \n");
+
+		//*pskb = skb;
+		pskb = (struct sk_buff *)skb;
+
+		//printk("Changing pskb --->skb 3 \n");
+
+                 if(nf_nat_rtsp)
+                 {
+                 
+                     /* pass the request off to the nat helper */
+                ret = nf_nat_rtsp(&pskb, ctinfo, hdrsoff, hdrslen, &expinfo, exp);
+               // nf_conntrack_expect_related(exp); 
+
+                }
+                else if (nf_ct_expect_related(exp) != 0) {
+                printk("ip_conntrack_expect_related failed\n");
+                //ip_conntrack_expect_free(exp);
+               // ret  = NF_DROP;
 		}
+		// UNLOCK_BH(&ip_rtsp_lock);
+//test:
+                                                                                                                                                    
+//// For RTCP port
+			exp1 = nf_ct_expect_alloc(ct);
+			if (!exp1) { 
+				ret = NF_DROP;
+				goto out;
+			}
+			expinfo.loport += 1;
+			nf_ct_expect_init(exp1, NF_CT_EXPECT_CLASS_DEFAULT,
+					 ct->tuplehash[!dir].tuple.src.l3num,
+					 &ct->tuplehash[!dir].tuple.src.u3,
+					 &ct->tuplehash[!dir].tuple.dst.u3,
+					 IPPROTO_UDP, NULL, &(expinfo.loport));
+
+			exp1->tuple.src.u3 = ct->tuplehash[!dir].tuple.src.u3;
+			exp1->mask.src.u3.ip  = 0xffffffff; //orginal
+			exp1->tuple.src.u.tcp.port = 0;
+			exp1->mask.src.u.udp.port  = 0 ;
+			exp1->tuple.src.l3num = PF_INET ;
+			//exp1->mask.src.l3num = 0xffff;
+			exp1->tuple.dst.u3 = ct->tuplehash[dir].tuple.src.u3;
+			//exp1->mask.dst.u3.ip  = 0xffffffff;
+			exp1->tuple.dst.u.udp.port = htons(expinfo.loport);
+			//exp1->mask.dst.u.udp.port  = 0xffff;
+			exp1->tuple.dst.protonum = IPPROTO_UDP;
+			//exp1->mask.dst.protonum  = 0xff;
+			expinfo.pbtype = pb_single;
+			exp1->helper = NULL;
+			exp1->flags = 0;
+			exp1->expectfn = expected;
+			ct1 = exp->master;
+			newip1 = ct1->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+			exp1->tuple.dst.u3.ip = newip1;
+			exp1->saved_proto.udp.port = exp1->tuple.dst.u.udp.port;
+			exp1->dir = !dir;
+
+		DEBUGP("expect_related_RTCP %u.%u.%u.%u:%u-%u.%u.%u.%u:%u    %u\n",
+				NIPQUAD(exp->tuple.src.u3.ip),
+				ntohs(exp->tuple.src.u.udp.port),
+				NIPQUAD(exp->tuple.dst.u3.ip),
+				ntohs(exp->tuple.dst.u.udp.port),expinfo.loport);
 	
-#ifdef CONFIG_RTSP_ALG_FIX
-	/* RTCP expect */
-		exp1 = nf_ct_expect_alloc(ct);
-		if (!exp1) {
-			 ret = NF_DROP;
-			 goto out;
+		if (nf_ct_expect_related(exp1) != 0) {
+			nf_ct_expect_insert_rtcp(exp1);
 		}
 
-		be_lortcpport = htons(expinfo.loport + 1);
-		nf_ct_expect_init(exp1, NF_CT_EXPECT_CLASS_DEFAULT,
-			ct->tuplehash[!dir].tuple.src.l3num,
-			&ct->tuplehash[!dir].tuple.src.u3, &ct->tuplehash[!dir].tuple.dst.u3,
-			IPPROTO_UDP, NULL, &be_lortcpport);
-	
-		exp1->expectfn = expected;
-		exp1->flags = 0;
-		ct1 = exp->master;
-		newip1 = ct1->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
-		exp1->tuple.dst.u3.ip = newip1;
-		exp1->dir = !dir;
+		spin_unlock_bh(&ip_rtsp_lock);
+                
+		/* pass the request off to the nat helper */
+	/*	rc = nf_conntrack_expect_related(ct, &exp);
+		//UNLOCK_BH(&ip_rtsp_lock);
+		if (rc == 0)
+		{
+			DEBUGP("ip_conntrack_expect_related succeeded\n");
+		}
+		else
+		{
+			INFOP("ip_conntrack_expect_related failed (%d)\n", rc);
+		}*/
+
+		//Nirav : Registering for RTCP in both directions...
+#if 0   // made as 0
+		//From server to client ---
+        //         LOCK_BH(&ip_rtsp_lock);
+
+		spin_lock_bh(&ip_rtsp_lock);
+		
+             exp1 = nf_conntrack_expect_alloc(ct);
+               if (!exp1) {
+                      ret = NF_DROP;
+					  printk("DROP\n");
+                        goto out;
+                     }
+																							  
+          exp1->id = ntohl(tcph->seq) + hdrsoff; /* mark all the headers */ //added
+		  expinfo.len = hdrslen; // 
+        expinfo.rtcp_dir = IP_CT_DIR_ORIGINAL;
+
+		//expinfo.loport += 1;
+                exp1->master= ct ;
+ 
+        // exp1->expectfn = expected ;
+
+		exp1->tuple.src.u3.ip = ct->tuplehash[!dir].tuple.src.u3.ip;
+	//	exp1->mask.src.u3.ip  = 0xffffffff;
+		 exp1->mask.src.u3.ip  = 0;
+		exp1->tuple.src.l3num = PF_INET ;
+	    exp1->mask.src.l3num = 0xffff;
+		
+		exp1->mask.src.u.udp.port = 0 ;
+		
+		exp1->tuple.dst.u3.ip = ct->tuplehash[dir].tuple.src.u3.ip;
+		exp1->mask.dst.u3.ip  = 0xffffffff;
+		exp1->tuple.dst.u.udp.port = (expinfo.loport+1);
+		exp1->mask.dst.u.udp.port  = 0xffff;
+		exp1->tuple.dst.protonum = IPPROTO_UDP;
+		exp1->mask.dst.protonum  = 0xff;
 		expinfo.pbtype = pb_single;
+		expinfo.rtcp_dir = IP_CT_DIR_ORIGINAL;
 
-		if (nf_ct_expect_related(exp1) != 0) {
-			nf_ct_expect_insert_rtcp(exp1);
+		printk("expect_related %u.%u.%u.%u:%u-%u.%u.%u.%u:%u ,  %u \n",
+				NIPQUAD(exp1->tuple.src.u3.ip),
+				ntohs(exp1->tuple.src.u.tcp.port),
+				NIPQUAD(exp1->tuple.dst.u3.ip),
+				ntohs(exp1->tuple.dst.u.tcp.port), PF_INET);
+
+#if 0 // IFX_TEST
+   if(nf_conntrack_expect_related(exp1) != 0)
+      {
+	         printk ("\n expect1 FAILED \n");
+			 goto test1; 
+       }
+#endif
+				
+#if 1
+nf_nat_rtsp = rcu_dereference(nf_nat_rtsp_hook);
+             if (nf_nat_rtsp)
+                /* pass the request off to the nat helper */
+                {
+		printk("INside 2 ip_nat_hook \n");
+		ret = nf_nat_rtsp(pskb, ctinfo, &expinfo, exp1);
+		//nf_conntrack_expect_put(exp1);
 		}
+	        else if (nf_conntrack_expect_related(exp1) != 0) {
+               // INFOP("ip_conntrack_expect_related failed\n");
+       //         ip_conntrack_expect_free(exp);
+               // ret  = NF_DROP;
+        	}
+ 
+	//	 UNLOCK_BH(&ip_rtsp_lock);
+
+//test1:
+	spin_unlock_bh(&ip_rtsp_lock);
 #endif
 
-		nf_ct_expect_put(exp); 
-		/*FIX ME : Check nf_ct_expect_put(exp1) is required , impact on
-		 * memory and functionality*/
+#if 0
+if (nf_conntrack_expect_related(exp1) != 0) {
+               // INFOP("ip_conntrack_expect_related failed\n");
+	          //         ip_conntrack_expect_free(exp);
+               // ret  = NF_DROP;
+           }
+												 
+spin_unlock_bh(&ip_rtsp_lock);
+#endif
+
+		/* pass the request off to the nat helper */
+	       /*	rc = ip_conntrack_expect_related(ct, &exp);
+		UNLOCK_BH(&ip_rtsp_lock);
+		if (rc == 0)
+		{
+			DEBUGP("ip_conntrack_expect_related succeeded\n");
+		}
+		else
+		{
+			INFOP("ip_conntrack_expect_related failed (%d)\n", rc);
+		}*/
+
+#if 0
+		//From client to server ---
+		exp.tuple.src.ip = ct->tuplehash[dir].tuple.src.ip;
+		exp.mask.src.ip  = 0xffffffff;
+		exp.tuple.dst.ip = ct->tuplehash[!dir].tuple.src.ip;
+		exp.mask.dst.ip  = 0xffffffff;
+		exp.tuple.src.u.udp.port = exp.help.exp_rtsp_info.loport;
+		exp.mask.src.u.udp.port  = 0xffff;
+		exp.tuple.dst.u.all = 0;
+		exp.mask.dst.u.all = 0;
+		exp.tuple.dst.protonum = IPPROTO_UDP;
+		exp.mask.dst.protonum  = 0xffff;
+		exp.help.exp_rtsp_info.rtcp_dir = IP_CT_DIR_REPLY;
+
+		DEBUGP("expect_related %u.%u.%u.%u:%u-%u.%u.%u.%u:%u\n",
+				NIPQUAD(exp.tuple.src.ip),
+				ntohs(exp.tuple.src.u.tcp.port),
+				NIPQUAD(exp.tuple.dst.ip),
+				ntohs(exp.tuple.dst.u.tcp.port));
+
+		/* pass the request off to the nat helper */
+		rc = ip_conntrack_expect_related(ct, &exp);
+		//UNLOCK_BH(&ip_rtsp_lock);
+		if (rc == 0)
+		{
+			DEBUGP("ip_conntrack_expect_related succeeded\n");
+		}
+		else
+		{
+			INFOP("ip_conntrack_expect_related failed (%d)\n", rc);
+		}
+#endif
+#endif
+       /****for testing ****/
+   // nf_conntrack_expect_related(exp);
+	//nf_conntrack_expect_related(exp1);
+
+		//nf_conntrack_expect_put(exp);
+		nf_ct_expect_put(exp);
 		goto out;
 	}
-out:
 
-	return ret;
+//    nf_conntrack_expect_put(exp); //works without this check out,IT MAY CRASH , IT FREES MEMORY
+ 
+out:
+	//return NF_ACCEPT;
+          return ret;
 }
 
-
+/* inbound packet: server->client */
 static inline int
-help_in(struct sk_buff *skb, size_t pktlen,
- struct nf_conn* ct, enum ip_conntrack_info ctinfo)
+help_in(struct sk_buff *skb , size_t pktlen,
+		struct nf_conn* ct, enum ip_conntrack_info ctinfo)
 {
- return NF_ACCEPT;
+
+// ct->ifx_alg_qos_mark = IFX_ALG_APP_RTSP | IFX_ALG_PROTO_RTP ; //for test
+
+  //DEBUGP ("\nRTSP_ALG: help_out marked ct->ifx_alg_qos_mark to : %x ***\n",
+   //                                                           ct->ifx_alg_qos_mark );
+
+	return NF_ACCEPT;
 }
 
-static int help(struct sk_buff *skb, unsigned int protoff,
-		struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+static int
+help(struct sk_buff *skb,unsigned int protoff,
+		struct nf_conn* ct, enum ip_conntrack_info ctinfo)
 {
-	struct tcphdr _tcph, *th;
-	unsigned int dataoff, datalen;
-	char *rb_ptr;
-	int ret = NF_DROP;
+	/* tcplen not negative guarenteed by ip_conntrack_tcp.c */
+	//struct tcphdr* tcph = (void*)iph + iph->ihl * 4;
+	//u_int32_t tcplen = pktlen - iph->ihl * 4;
+         struct tcphdr _tcph, *th;
+         unsigned int dataoff, datalen;
+         char *rb_ptr;
+         int ret = NF_DROP;
 
 	/* Until there's been traffic both ways, don't look in packets. */
-	if (ctinfo != IP_CT_ESTABLISHED &&
-	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
+	if (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY)
+	{
 		DEBUGP("conntrackinfo = %u\n", ctinfo);
 		return NF_ACCEPT;
-	}
+	} 
 
-	/* Not whole TCP header? */
-	th = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);
 
-	if (!th)
-		return NF_ACCEPT;
+        th = skb_header_pointer(skb, protoff,
+                            sizeof(_tcph), &_tcph);
+      if (!th)
+             return NF_ACCEPT;
 
-	/* No data ? */
+    /* No data ? */
 	dataoff = protoff + th->doff*4;
 	datalen = skb->len - dataoff;
 	if (dataoff >= skb->len)
-		return NF_ACCEPT;
+            return NF_ACCEPT;
 
-	spin_lock_bh(&rtsp_buffer_lock);
-	rb_ptr = skb_header_pointer(skb, dataoff,
-				    skb->len - dataoff, rtsp_buffer);
-	BUG_ON(rb_ptr == NULL);
+    	//spin_lock_bh(&rtsp_buffer_lock);
+    	rb_ptr = skb_header_pointer(skb, dataoff,
+                                skb->len - dataoff, rtsp_buffer);
+    	BUG_ON(rb_ptr == NULL);
+
+	/* Not whole TCP header? */
+/*	if (tcplen < sizeof(struct tcphdr) || tcplen < tcph->doff * 4)
+	{
+		DEBUGP("tcplen = %u\n", (unsigned)tcplen);
+		return NF_ACCEPT;
+	}*/
 
-#if 0
 	/* Checksum invalid?  Ignore. */
 	/* FIXME: Source route IP option packets --RR */
-	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
-			 csum_partial((char*)tcph, tcplen, 0)))
+/*	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
+				csum_partial((char*)tcph, tcplen, 0)))
 	{
 		DEBUGP("bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
-		       tcph, tcplen, NIPQUAD(iph->saddr), NIPQUAD(iph->daddr));
+				tcph, tcplen, NIPQUAD(iph->saddr), NIPQUAD(iph->daddr));
 		return NF_ACCEPT;
-	}
-#endif
+	}*/
 
-	switch (CTINFO2DIR(ctinfo)) {
-	case IP_CT_DIR_ORIGINAL:
-		ret = help_out(skb, rb_ptr, datalen, ct, ctinfo);
-		break;
-	case IP_CT_DIR_REPLY:
-		DEBUGP("IP_CT_DIR_REPLY\n");
-		/* inbound packet: server->client */
-		ret = NF_ACCEPT;
-		break;
+	switch (CTINFO2DIR(ctinfo))
+	{
+		case IP_CT_DIR_ORIGINAL:
+			
+			//help_out(iph, pktlen, ct, ctinfo);
+                        ret = help_out(skb, rb_ptr, datalen, ct, ctinfo);
+			break;
+		case IP_CT_DIR_REPLY:
+			DEBUGP("Calling help_in ********* \n");
+			 //ret = help_in(pskb, datalen, ct, ctinfo);
+			 return NF_ACCEPT;
+			break;
+		default:
+			/* oops */
+                       break;
 	}
 
-	spin_unlock_bh(&rtsp_buffer_lock);
-
-	return ret;
+	return NF_ACCEPT;
 }
 
+#ifndef IFX_RTSP_NAT_ALG
 static struct nf_conntrack_helper rtsp_helpers[MAX_PORTS];
 static char rtsp_names[MAX_PORTS][10];
 static struct nf_conntrack_expect_policy rtsp_expect_policy;
+#endif
 
 /* This function is intentionally _NOT_ defined as __exit */
-static void
+	static void
 fini(void)
 {
 #ifndef IFX_RTSP_NAT_ALG
 	int i;
-	for (i = 0; i < num_ports; i++) {
+	for (i = 0; i < num_ports; i++)
+	{
 		DEBUGP("unregistering port %d\n", ports[i]);
 		nf_conntrack_helper_unregister(&rtsp_helpers[i]);
 	}
-	kfree(rtsp_buffer);
 
 #else
 
@@ -594,55 +1035,67 @@
 #endif
 }
 
-static int __init
+	static int __init
 init(void)
 {
-	int i, ret;
-
 
+	int  ret;
 
 #ifndef IFX_RTSP_NAT_ALG
 
 	struct nf_conntrack_helper *hlpr;
 	char *tmpname;
+	int i = 0;
 
 #endif
-	printk("nf_conntrack_rtsp v" IP_NF_RTSP_VERSION " loading\n");
 
-	if (max_outstanding < 1) {
-		printk("nf_conntrack_rtsp: max_outstanding must be a positive integer\n");
+	printk("ip_conntrack_rtsp v" IP_NF_RTSP_VERSION " loading\n");
+
+	if (max_outstanding < 1)
+	{
+		printk("ip_conntrack_rtsp: max_outstanding must be a positive integer\n");
 		return -EBUSY;
 	}
-	if (setup_timeout < 0) {
-		printk("nf_conntrack_rtsp: setup_timeout must be a positive integer\n");
+	if (setup_timeout < 0)
+	{
+		printk("ip_conntrack_rtsp: setup_timeout must be a positive integer\n");
 		return -EBUSY;
 	}
-
+#ifndef IFX_RTSP_NAT_ALG
+	
 	rtsp_expect_policy.max_expected = max_outstanding;
 	rtsp_expect_policy.timeout = setup_timeout;
 
-	rtsp_buffer = kmalloc(65536, GFP_KERNEL);
-	if (!rtsp_buffer)
-		return -ENOMEM;
-#ifndef IFX_RTSP_NAT_ALG
 	/* If no port given, default to standard rtsp port */
-	if (ports[0] == 0) {
+	if (ports[0] == 0)
+	{
 		ports[0] = RTSP_PORT;
 	}
 
-	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++)
+	{
 		hlpr = &rtsp_helpers[i];
 		memset(hlpr, 0, sizeof(struct nf_conntrack_helper));
+    		 hlpr->tuple.src.l3num = PF_INET;
+                //hlpr->mask.src.l3num = 0xFFFF;
 		hlpr->tuple.src.u.tcp.port = htons(ports[i]);
 		hlpr->tuple.dst.protonum = IPPROTO_TCP;
+		//hlpr->mask.src.u.tcp.port = 0xFFFF;
+		//hlpr->mask.dst.protonum = 0xFF;
+//		hlpr->max_expected = max_outstanding;
+//		hlpr->timeout = setup_timeout;
+		//hlpr->flags = IP_CT_HELPER_F_REUSE_EXPECT;
 		hlpr->expect_policy = &rtsp_expect_policy;
 		hlpr->me = THIS_MODULE;
 		hlpr->help = help;
 
 		tmpname = &rtsp_names[i][0];
-		if (ports[i] == RTSP_PORT) {
+		if (ports[i] == RTSP_PORT)
+		{
 			sprintf(tmpname, "rtsp");
-		} else {
+		}
+		else
+		{
 			sprintf(tmpname, "rtsp-%d", i);
 		}
 		hlpr->name = tmpname;
@@ -651,7 +1104,8 @@
 
 		ret = nf_conntrack_helper_register(hlpr);
 
-		if (ret) {
+		if (ret)
+		{
 			printk("nf_conntrack_rtsp: ERROR registering port %d\n", ports[i]);
 			fini();
 			return -EBUSY;
@@ -960,5 +1414,3 @@
 module_init(init);
 module_exit(fini);
 
-EXPORT_SYMBOL(nf_nat_rtsp_hook_expectfn);
-
Index: linux/net/netfilter/nf_conntrack_talk.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_talk.c	2011-01-07 12:09:09.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_talk.c	2011-01-07 12:24:47.995900919 +0530
@@ -429,17 +429,17 @@
 int lookup_help(struct sk_buff *skb, unsigned int protoff,
 		       struct nf_conn *ct, enum ip_conntrack_info ctinfo)
 {
-	 struct sk_buff **pskb=NULL;
-	 *pskb = skb;
-	return talk_help(pskb, ct, ctinfo, TALK_PORT, LOOK_UP, protoff);
+	 struct sk_buff *pskb;
+	 pskb = (struct sk_buff *)skb;
+	return talk_help(&pskb, ct, ctinfo, TALK_PORT, LOOK_UP, protoff);
 }
 
 int lookup_nhelp(struct sk_buff *skb, unsigned int protoff,
 		        struct nf_conn *ct, enum ip_conntrack_info ctinfo)
 {
-	struct sk_buff **pskb=NULL;
-	*pskb = skb;
-	return talk_help(pskb, ct, ctinfo, NTALK_PORT, LOOK_UP, protoff);
+	struct sk_buff *pskb;
+	pskb = (struct sk_buff *)skb;
+	return talk_help(&pskb, ct, ctinfo, NTALK_PORT, LOOK_UP, protoff);
 }
 
 #if 0
Index: linux/drivers/net/pppoe.c
===================================================================
--- linux.orig/drivers/net/pppoe.c	2011-01-07 21:29:51.000000000 +0530
+++ linux/drivers/net/pppoe.c	2011-01-08 00:59:09.114652407 +0530
@@ -1243,7 +1243,9 @@
 	int32_t ret = -EFAULT;
 
     pn = pppoe_pernet(dev_net(dev));
-    pppoe_netdev = dev_get_by_name(dev_net(dev), pa->dev); 
+    if (pppoe_netdev = dev_get_by_name(dev_net(dev), pa->dev)) {
+	    dev_put (pppoe_netdev);
+    }
 	po = get_item(pn, pa->sid, pa->remote, pppoe_netdev->ifindex);
 	if (!po){
 		printk("Cannot find the pppoe addr in hash table \n");
