diff -crNB --new-file ../llinux-2.6.32.42/drivers/net/usb/Kconfig ./drivers/net/usb/Kconfig
*** ../llinux-2.6.32.42/drivers/net/usb/Kconfig	2015-06-08 14:32:18.263752888 -0700
--- ./drivers/net/usb/Kconfig	2015-06-08 14:33:31.019755479 -0700
***************
*** 350,355 ****
--- 350,377 ----
  	  really need this non-conformant variant of CDC Ethernet (or in
  	  some cases CDC MDLM) protocol, not "g_ether".
  
+ config USB_NET_QMI_WWAN
+ 	tristate "QMI WWAN driver for Qualcomm MSM based 3G and LTE modems"
+ 	depends on USB_USBNET
+ 	select USB_WDM
+ 	help
+ 	  Support WWAN LTE/3G devices based on Qualcomm Mobile Data Modem
+ 	  (MDM) chipsets.  Examples of such devices are
+ 	    * Huawei E392/E398
+ 
+ 	  This driver will only drive the ethernet part of the chips.
+ 	  The devices require additional configuration to be usable.
+ 	  Multiple management interfaces with linux drivers are
+ 	  available:
+ 
+ 	    * option: AT commands on /dev/ttyUSBx
+ 	    * cdc-wdm: Qualcomm MSM Interface (QMI) protocol on /dev/cdc-wdmx
+ 
+ 	  A modem manager with support for QMI is recommended.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called qmi_wwan.
+ 
  config USB_HSO
  	tristate "Option USB High Speed Mobile Devices"
  	depends on USB && RFKILL
diff -crNB --new-file ../llinux-2.6.32.42/drivers/net/usb/Makefile ./drivers/net/usb/Makefile
*** ../llinux-2.6.32.42/drivers/net/usb/Makefile	2015-06-08 14:32:18.263752888 -0700
--- ./drivers/net/usb/Makefile	2015-06-08 14:33:31.019755479 -0700
***************
*** 22,25 ****
--- 22,26 ----
  obj-$(CONFIG_USB_USBNET)	+= usbnet.o
  obj-$(CONFIG_USB_NET_INT51X1)	+= int51x1.o
  obj-$(CONFIG_USB_CDC_PHONET)	+= cdc-phonet.o
+ obj-$(CONFIG_USB_NET_QMI_WWAN)	+= qmi_wwan.o
  
diff -crNB --new-file ../llinux-2.6.32.42/drivers/net/usb/qmi_wwan.c ./drivers/net/usb/qmi_wwan.c
*** ../llinux-2.6.32.42/drivers/net/usb/qmi_wwan.c	1969-12-31 16:00:00.000000000 -0800
--- ./drivers/net/usb/qmi_wwan.c	2015-06-08 14:33:30.987755477 -0700
***************
*** 0 ****
--- 1,619 ----
+ /*
+  * Copyright (c) 2012  Bj√∏rn Mork <bjorn@mork.no>
+  *
+  * The probing code is heavily inspired by cdc_ether, which is:
+  * Copyright (C) 2003-2005 by David Brownell
+  * Copyright (C) 2006 by Ole Andre Vadla Ravnas (ActiveSync)
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * version 2 as published by the Free Software Foundation.
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/netdevice.h>
+ #include <linux/ethtool.h>
+ #include <linux/etherdevice.h>
+ #include <linux/mii.h>
+ #include <linux/usb.h>
+ #include <linux/usb/cdc.h>
+ #include <linux/usb/usbnet.h>
+ #include <linux/usb/cdc-wdm.h>
+ 
+ /* This driver supports wwan (3G/LTE/?) devices using a vendor
+  * specific management protocol called Qualcomm MSM Interface (QMI) -
+  * in addition to the more common AT commands over serial interface
+  * management
+  *
+  * QMI is wrapped in CDC, using CDC encapsulated commands on the
+  * control ("master") interface of a two-interface CDC Union
+  * resembling standard CDC ECM.  The devices do not use the control
+  * interface for any other CDC messages.  Most likely because the
+  * management protocol is used in place of the standard CDC
+  * notifications NOTIFY_NETWORK_CONNECTION and NOTIFY_SPEED_CHANGE
+  *
+  * Alternatively, control and data functions can be combined in a
+  * single USB interface.
+  *
+  * Handling a protocol like QMI is out of the scope for any driver.
+  * It is exported as a character device using the cdc-wdm driver as
+  * a subdriver, enabling userspace applications ("modem managers") to
+  * handle it.
+  *
+  * These devices may alternatively/additionally be configured using AT
+  * commands on a serial interface
+  */
+ 
+ /* driver specific data */
+ struct qmi_wwan_state {
+ 	struct usb_driver *subdriver;
+ 	atomic_t pmcount;
+ 	unsigned long unused;
+ 	struct usb_interface *control;
+ 	struct usb_interface *data;
+ };
+ 
+ /* default ethernet address used by the modem */
+ static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+ 
+ /* Make up an ethernet header if the packet doesn't have one.
+  *
+  * A firmware bug common among several devices cause them to send raw
+  * IP packets under some circumstances.  There is no way for the
+  * driver/host to know when this will happen.  And even when the bug
+  * hits, some packets will still arrive with an intact header.
+  *
+  * The supported devices are only capably of sending IPv4, IPv6 and
+  * ARP packets on a point-to-point link. Any packet with an ethernet
+  * header will have either our address or a broadcast/multicast
+  * address as destination.  ARP packets will always have a header.
+  *
+  * This means that this function will reliably add the appropriate
+  * header iff necessary, provided our hardware address does not start
+  * with 4 or 6.
+  *
+  * Another common firmware bug results in all packets being addressed
+  * to 00:a0:c6:00:00:00 despite the host address being different.
+  * This function will also fixup such packets.
+  */
+ static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+ {
+ 	__be16 proto;
+ 
+ 	/* usbnet rx_complete guarantees that skb->len is at least
+ 	 * hard_header_len, so we can inspect the dest address without
+ 	 * checking skb->len
+ 	 */
+ 	switch (skb->data[0] & 0xf0) {
+ 	case 0x40:
+ 		proto = htons(ETH_P_IP);
+ 		break;
+ 	case 0x60:
+ 		proto = htons(ETH_P_IPV6);
+ 		break;
+ 	case 0x00:
+ 		if (is_multicast_ether_addr(skb->data))
+ 			return 1;
+ 		/* possibly bogus destination - rewrite just in case */
+ 		skb_reset_mac_header(skb);
+ 		goto fix_dest;
+ 	default:
+ 		/* pass along other packets without modifications */
+ 		return 1;
+ 	}
+ 	if (skb_headroom(skb) < ETH_HLEN)
+ 		skb_cow(skb, NET_IP_ALIGN + ETH_HLEN);
+ 	skb_push(skb, ETH_HLEN);
+ 	skb_reset_mac_header(skb);
+ 	eth_hdr(skb)->h_proto = proto;
+ 	memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+ fix_dest:
+ 	memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+ 	return 1;
+ }
+ 
+ /* very simplistic detection of IPv4 or IPv6 headers */
+ static bool possibly_iphdr(const char *data)
+ {
+ 	return (data[0] & 0xd0) == 0x40;
+ }
+ 
+ static int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)
+ {
+ 	return 0;
+ }
+ 
+ /* collect all three endpoints and register subdriver */
+ static int qmi_wwan_register_subdriver(struct usbnet *dev)
+ {
+ 	int rv;
+ 	struct usb_driver *subdriver = NULL;
+ 	struct qmi_wwan_state *info = (void *)&dev->data;
+ 
+ 	/* collect bulk endpoints */
+ 	rv = usbnet_get_endpoints(dev, info->data);
+ 	if (rv < 0)
+ 		goto err;
+ 
+ 	/* update status endpoint if separate control interface */
+ 	if (info->control != info->data)
+ 		dev->status = &info->control->cur_altsetting->endpoint[0];
+ 
+ 	/* require interrupt endpoint for subdriver */
+ 	if (!dev->status) {
+ 		rv = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	/* for subdriver power management */
+ 	atomic_set(&info->pmcount, 0);
+ 
+ 	/* register subdriver */
+ 	subdriver = usb_cdc_wdm_register(info->control, &dev->status->desc, 4096, &qmi_wwan_cdc_wdm_manage_power);
+ 	if (IS_ERR(subdriver)) {
+ 		dev_err(&info->control->dev, "subdriver registration failed\n");
+ 		rv = PTR_ERR(subdriver);
+ 		goto err;
+ 	}
+ 
+ 	/* prevent usbnet from using status endpoint */
+ 	dev->status = NULL;
+ 
+ 	/* save subdriver struct for suspend/resume wrappers */
+ 	info->subdriver = subdriver;
+ 
+ err:
+ 	return rv;
+ }
+ 
+ static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)
+ {
+ 	int status = -1;
+ 	u8 *buf = intf->cur_altsetting->extra;
+ 	int len = intf->cur_altsetting->extralen;
+ 	struct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;
+ 	struct usb_cdc_union_desc *cdc_union = NULL;
+ 	struct usb_cdc_ether_desc *cdc_ether = NULL;
+ 	u32 found = 0;
+ 	struct usb_driver *driver = driver_of(intf);
+ 	struct qmi_wwan_state *info = (void *)&dev->data;
+ 
+ 	BUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) < sizeof(struct qmi_wwan_state)));
+ 
+ 	/* set up initial state */
+ 	info->control = intf;
+ 	info->data = intf;
+ 
+ 	/* and a number of CDC descriptors */
+ 	while (len > 3) {
+ 		struct usb_descriptor_header *h = (void *)buf;
+ 
+ 		/* ignore any misplaced descriptors */
+ 		if (h->bDescriptorType != USB_DT_CS_INTERFACE)
+ 			goto next_desc;
+ 
+ 		/* buf[2] is CDC descriptor subtype */
+ 		switch (buf[2]) {
+ 		case USB_CDC_HEADER_TYPE:
+ 			if (found & 1 << USB_CDC_HEADER_TYPE) {
+ 				dev_dbg(&intf->dev, "extra CDC header\n");
+ 				goto err;
+ 			}
+ 			if (h->bLength != sizeof(struct usb_cdc_header_desc)) {
+ 				dev_dbg(&intf->dev, "CDC header len %u\n", h->bLength);
+ 				goto err;
+ 			}
+ 			break;
+ 		case USB_CDC_UNION_TYPE:
+ 			if (found & 1 << USB_CDC_UNION_TYPE) {
+ 				dev_dbg(&intf->dev, "extra CDC union\n");
+ 				goto err;
+ 			}
+ 			if (h->bLength != sizeof(struct usb_cdc_union_desc)) {
+ 				dev_dbg(&intf->dev, "CDC union len %u\n", h->bLength);
+ 				goto err;
+ 			}
+ 			cdc_union = (struct usb_cdc_union_desc *)buf;
+ 			break;
+ 		case USB_CDC_ETHERNET_TYPE:
+ 			if (found & 1 << USB_CDC_ETHERNET_TYPE) {
+ 				dev_dbg(&intf->dev, "extra CDC ether\n");
+ 				goto err;
+ 			}
+ 			if (h->bLength != sizeof(struct usb_cdc_ether_desc)) {
+ 				dev_dbg(&intf->dev, "CDC ether len %u\n",  h->bLength);
+ 				goto err;
+ 			}
+ 			cdc_ether = (struct usb_cdc_ether_desc *)buf;
+ 			break;
+ 		}
+ 
+ 		/*
+ 		 * Remember which CDC functional descriptors we've seen.  Works
+ 		 * for all types we care about, of which USB_CDC_ETHERNET_TYPE
+ 		 * (0x0f) is the highest numbered
+ 		 */
+ 		if (buf[2] < 32)
+ 			found |= 1 << buf[2];
+ 
+ next_desc:
+ 		len -= h->bLength;
+ 		buf += h->bLength;
+ 	}
+ 
+ 	/* Use separate control and data interfaces if we found a CDC Union */
+ 	if (cdc_union) {
+ 		info->data = usb_ifnum_to_if(dev->udev, cdc_union->bSlaveInterface0);
+ 		if (desc->bInterfaceNumber != cdc_union->bMasterInterface0 || !info->data) {
+ 			dev_err(&intf->dev, "bogus CDC Union: master=%u, slave=%u\n",
+ 				cdc_union->bMasterInterface0, cdc_union->bSlaveInterface0);
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	/* errors aren't fatal - we can live with the dynamic address */
+ 	if (cdc_ether) {
+ 		dev->hard_mtu = le16_to_cpu(cdc_ether->wMaxSegmentSize);
+ 		usbnet_get_ethernet_addr(dev, cdc_ether->iMACAddress);
+ 	}
+ 
+ 	/* claim data interface and set it up */
+ 	if (info->control != info->data) {
+ 		status = usb_driver_claim_interface(driver, info->data, dev);
+ 		if (status < 0)
+ 			goto err;
+ 	}
+ 
+ 	status = qmi_wwan_register_subdriver(dev);
+ 	if (status < 0 && info->control != info->data) {
+ 		usb_set_intfdata(info->data, NULL);
+ 		usb_driver_release_interface(driver, info->data);
+ 	}
+ 
+ 	/* Never use the same address on both ends of the link, even
+ 	 * if the buggy firmware told us to.
+ 	 */
+ 	if (!compare_ether_addr(dev->net->dev_addr, default_modem_addr))
+ 		random_ether_addr(dev->net->dev_addr);
+ 
+ 	/* make MAC addr easily distinguishable from an IP header */
+ 	if (possibly_iphdr(dev->net->dev_addr)) {
+ 		dev->net->dev_addr[0] |= 0x02;	/* set local assignment bit */
+ 		dev->net->dev_addr[0] &= 0xbf;	/* clear "IP" bit */
+ 	}
+ err:
+ 	return status;
+ }
+ 
+ static void qmi_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)
+ {
+ 	struct qmi_wwan_state *info = (void *)&dev->data;
+ 	struct usb_driver *driver = driver_of(intf);
+ 	struct usb_interface *other;
+ 
+ 	if (info->subdriver && info->subdriver->disconnect)
+ 		info->subdriver->disconnect(info->control);
+ 
+ 	/* allow user to unbind using either control or data */
+ 	if (intf == info->control)
+ 		other = info->data;
+ 	else
+ 		other = info->control;
+ 
+ 	/* only if not shared */
+ 	if (other && intf != other) {
+ 		usb_set_intfdata(other, NULL);
+ 		usb_driver_release_interface(driver, other);
+ 	}
+ 
+ 	info->subdriver = NULL;
+ 	info->data = NULL;
+ 	info->control = NULL;
+ }
+ 
+ /* suspend/resume wrappers calling both usbnet and the cdc-wdm
+  * subdriver if present.
+  *
+  * NOTE: cdc-wdm also supports pre/post_reset, but we cannot provide
+  * wrappers for those without adding usbnet reset support first.
+  */
+ static int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)
+ {
+ 	struct usbnet *dev = usb_get_intfdata(intf);
+ 	struct qmi_wwan_state *info = (void *)&dev->data;
+ 	int ret;
+ 
+ 	ret = usbnet_suspend(intf, message);
+ 	if (ret < 0)
+ 		goto err;
+ 
+ 	if (intf == info->control && info->subdriver && info->subdriver->suspend)
+ 		ret = info->subdriver->suspend(intf, message);
+ 	if (ret < 0)
+ 		usbnet_resume(intf);
+ err:
+ 	return ret;
+ }
+ 
+ static int qmi_wwan_resume(struct usb_interface *intf)
+ {
+ 	struct usbnet *dev = usb_get_intfdata(intf);
+ 	struct qmi_wwan_state *info = (void *)&dev->data;
+ 	int ret = 0;
+ 	bool callsub = (intf == info->control && info->subdriver && info->subdriver->resume);
+ 
+ 	if (callsub)
+ 		ret = info->subdriver->resume(intf);
+ 	if (ret < 0)
+ 		goto err;
+ 	ret = usbnet_resume(intf);
+ 	if (ret < 0 && callsub && info->subdriver->suspend)
+ 		info->subdriver->suspend(intf, PMSG_SUSPEND);
+ err:
+ 	return ret;
+ }
+ 
+ static const struct driver_info	qmi_wwan_info = {
+ 	.description	= "WWAN/QMI v3.9r2e",
+ 	.flags		= FLAG_WWAN,
+ 	.bind		= qmi_wwan_bind,
+ 	.unbind		= qmi_wwan_unbind,
+ 	.rx_fixup       = qmi_wwan_rx_fixup,
+ };
+ 
+ #define HUAWEI_VENDOR_ID	0x12D1
+ 
+ /* map QMI/wwan function by a fixed interface number */
+ #define QMI_FIXED_INTF(vend, prod, num) \
+ 	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+ 	.driver_info = (unsigned long)&qmi_wwan_info
+ 
+ /* Gobi 1000 QMI/wwan interface number is 3 according to qcserial */
+ #define QMI_GOBI1K_DEVICE(vend, prod) \
+ 	QMI_FIXED_INTF(vend, prod, 3)
+ 
+ /* Gobi 2000/3000 QMI/wwan interface number is 0 according to qcserial */
+ #define QMI_GOBI_DEVICE(vend, prod) \
+ 	QMI_FIXED_INTF(vend, prod, 0)
+ 
+ static const struct usb_device_id products[] = {
+ 	/* 1. CDC ECM like devices match on the control interface */
+ 	{	/* Huawei E392, E398 and possibly others sharing both device id and more... */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 9),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Vodafone/Huawei K5005 (12d1:14c8) and similar modems */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 57),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* HUAWEI_INTERFACE_NDIS_CONTROL_QUALCOMM */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x69),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 
+ 	/* 2. Combined interface devices matching on class+protocol */
+ 	{	/* Huawei E367 and possibly others in "Windows mode" */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 7),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Huawei E392, E398 and possibly others in "Windows mode" */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 17),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* HUAWEI_NDIS_SINGLE_INTERFACE_VDF */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x37),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* HUAWEI_INTERFACE_NDIS_HW_QUALCOMM */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x67),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Pantech UML290, P4200 and more */
+ 		USB_VENDOR_AND_INTERFACE_INFO(0x106c, USB_CLASS_VENDOR_SPEC, 0xf0, 0xff),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Pantech UML290 - newer firmware */
+ 		USB_VENDOR_AND_INTERFACE_INFO(0x106c, USB_CLASS_VENDOR_SPEC, 0xf1, 0xff),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Novatel USB551L and MC551 */
+ 		USB_DEVICE_AND_INTERFACE_INFO(0x1410, 0xb001,
+ 		                              USB_CLASS_COMM,
+ 		                              USB_CDC_SUBCLASS_ETHERNET,
+ 		                              USB_CDC_PROTO_NONE),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Novatel E362 */
+ 		USB_DEVICE_AND_INTERFACE_INFO(0x1410, 0x9010,
+ 		                              USB_CLASS_COMM,
+ 		                              USB_CDC_SUBCLASS_ETHERNET,
+ 		                              USB_CDC_PROTO_NONE),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Dell Wireless 5800 (Novatel E362) */
+ 		USB_DEVICE_AND_INTERFACE_INFO(0x413C, 0x8195,
+ 					      USB_CLASS_COMM,
+ 					      USB_CDC_SUBCLASS_ETHERNET,
+ 					      USB_CDC_PROTO_NONE),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* Dell Wireless 5800 V2 (Novatel E362) */
+ 		USB_DEVICE_AND_INTERFACE_INFO(0x413C, 0x8196,
+ 					      USB_CLASS_COMM,
+ 					      USB_CDC_SUBCLASS_ETHERNET,
+ 					      USB_CDC_PROTO_NONE),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 	{	/* ADU960S */
+ 		USB_DEVICE_AND_INTERFACE_INFO(0x16d5, 0x650a,
+ 					      USB_CLASS_COMM,
+ 					      USB_CDC_SUBCLASS_ETHERNET,
+ 					      USB_CDC_PROTO_NONE),
+ 		.driver_info        = (unsigned long)&qmi_wwan_info,
+ 	},
+ 
+ 	/* 3. Combined interface devices matching on interface number */
+ 	{QMI_FIXED_INTF(0x0408, 0xea42, 4)},	/* Yota / Megafon M100-1 */
+ 	{QMI_FIXED_INTF(0x12d1, 0x140c, 1)},	/* Huawei E173 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0002, 1)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0012, 1)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0017, 3)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0021, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0025, 1)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0031, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0042, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0049, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0052, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0055, 1)},	/* ZTE (Vodafone) K3520-Z */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0058, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0063, 4)},	/* ZTE (Vodafone) K3565-Z */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0104, 4)},	/* ZTE (Vodafone) K4505-Z */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0113, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0118, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0121, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0123, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0124, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0125, 6)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0126, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0130, 1)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0133, 3)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0141, 5)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0157, 5)},	/* ZTE MF683 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0158, 3)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0167, 4)},	/* ZTE MF820D */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0168, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0176, 3)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0178, 3)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0191, 4)},	/* ZTE EuFi890 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0199, 1)},	/* ZTE MF820S */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0200, 1)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x0257, 3)},	/* ZTE MF821 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0265, 4)},	/* ONDA MT8205 4G LTE */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0284, 4)},	/* ZTE MF880 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x0326, 4)},	/* ZTE MF821D */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1008, 4)},	/* ZTE (Vodafone) K3570-Z */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1010, 4)},	/* ZTE (Vodafone) K3571-Z */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1012, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1018, 3)},	/* ZTE (Vodafone) K5006-Z */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1021, 2)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1245, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1247, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1252, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1254, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1255, 3)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1255, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1256, 4)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1401, 2)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1402, 2)},	/* ZTE MF60 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1424, 2)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1425, 2)},
+ 	{QMI_FIXED_INTF(0x19d2, 0x1426, 2)},	/* ZTE MF91 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x2002, 4)},	/* ZTE (Vodafone) K3765-Z */
+ 	{QMI_FIXED_INTF(0x0f3d, 0x68a2, 8)},    /* Sierra Wireless MC7700 */
+ 	{QMI_FIXED_INTF(0x114f, 0x68a2, 8)},    /* Sierra Wireless MC7750 */
+ 	{QMI_FIXED_INTF(0x1199, 0x68a2, 8)},	/* Sierra Wireless MC7710 in QMI mode */
+ 	{QMI_FIXED_INTF(0x1199, 0x68a2, 19)},	/* Sierra Wireless MC7710 in QMI mode */
+ 	{QMI_FIXED_INTF(0x1199, 0x901c, 8)},    /* Sierra Wireless EM7700 */
+ 	{QMI_FIXED_INTF(0x1bbb, 0x011e, 4)},	/* Telekom Speedstick LTE II (Alcatel One Touch L100V LTE) */
+ 	{QMI_FIXED_INTF(0x2357, 0x0201, 4)},	/* TP-LINK HSUPA Modem MA180 */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},	/* Telit LE920 */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1201, 2)},	/* Telit LE910 */
+ 
+ 	/* 4. Gobi 1000 devices */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9212)},	/* Acer Gobi Modem Device */
+ 	{QMI_GOBI1K_DEVICE(0x03f0, 0x1f1d)},	/* HP un2400 Gobi Modem Device */
+ 	{QMI_GOBI1K_DEVICE(0x04da, 0x250d)},	/* Panasonic Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x413c, 0x8172)},	/* Dell Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x1410, 0xa001)},	/* Novatel Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x0b05, 0x1776)},	/* Asus Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x19d2, 0xfff3)},	/* ONDA Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9001)},	/* Generic Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9002)},	/* Generic Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9202)},	/* Generic Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9203)},	/* Generic Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9222)},	/* Generic Gobi Modem device */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9009)},	/* Generic Gobi Modem device */
+ 
+ 	/* 5. Gobi 2000 and 3000 devices */
+ 	{QMI_GOBI_DEVICE(0x413c, 0x8186)},	/* Dell Gobi 2000 Modem device (N0218, VU936) */
+ 	{QMI_GOBI_DEVICE(0x413c, 0x8194)},	/* Dell Gobi 3000 Composite */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x920b)},	/* Generic Gobi 2000 Modem device */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x920d)},	/* Gobi 3000 Composite */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9225)},	/* Sony Gobi 2000 Modem device (N0279, VU730) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9245)},	/* Samsung Gobi 2000 Modem device (VL176) */
+ 	{QMI_GOBI_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9235)},	/* Top Global Gobi 2000 Modem device (VR306) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9275)},	/* iRex Technologies Gobi 2000 Modem device (VR307) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x68a5)},	/* Sierra Wireless Modem */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x68a9)},	/* Sierra Wireless Modem */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9001)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9002)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9003)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9004)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9005)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9006)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9007)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9008)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9009)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x900a)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9011)},	/* Sierra Wireless Gobi 2000 Modem device (MC8305) */
+ 	{QMI_FIXED_INTF(0x1199, 0x9011, 5)},	/* alternate interface number!? */
+ 	{QMI_GOBI_DEVICE(0x16d8, 0x8002)},	/* CMDTech Gobi 2000 Modem device (VU922) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9205)},	/* Gobi 2000 Modem device */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9013)},	/* Sierra Wireless Gobi 3000 Modem device (MC8355) */
+ 	{QMI_GOBI_DEVICE(0x03f0, 0x371d)},	/* HP un2430 Mobile Broadband Module */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9015)},	/* Sierra Wireless Gobi 3000 Modem device */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9019)},	/* Sierra Wireless Gobi 3000 Modem device */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x901b)},	/* Sierra Wireless MC7770 */
+ 	{QMI_GOBI_DEVICE(0x12d1, 0x14f1)},	/* Sony Gobi 3000 Composite */
+ 	{QMI_GOBI_DEVICE(0x1410, 0xa021)},	/* Foxconn Gobi 3000 Modem device (Novatel E396) */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9001, 3)},	/* MDM9X00 9001 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x900f, 3)},	/* MDM9X00 900F-3 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x900f, 4)},	/* MDM9X00 900F-4 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x900f, 5)},	/* MDM9X00 900F-5 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9011, 3)},	/* MDM9X00 9011-3 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9011, 4)},	/* MDM9X00 9011-4 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9025, 4)},    /* MDM9X15 9025 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9046, 3)},    /* MDM9X15 9046-3 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9046, 4)},    /* MDM9X15 9046-4 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9046, 5)},    /* MDM9X15 9046-5 */
+ 
+ 	{ }					/* END */
+ };
+ MODULE_DEVICE_TABLE(usb, products);
+ 
+ static int qmi_wwan_probe(struct usb_interface *intf, const struct usb_device_id *prod)
+ {
+ 	struct usb_device_id *id = (struct usb_device_id *)prod;
+ 
+ 	/* Workaround to enable dynamic IDs.  This disables usbnet
+ 	 * blacklisting functionality.  Which, if required, can be
+ 	 * reimplemented here by using a magic "blacklist" value
+ 	 * instead of 0 in the static device id table
+ 	 */
+ 	if (!id->driver_info) {
+ 		dev_dbg(&intf->dev, "setting defaults for dynamic device id\n");
+ 		id->driver_info = (unsigned long)&qmi_wwan_info;
+ 	}
+ 
+ 	return usbnet_probe(intf, id);
+ }
+ 
+ static struct usb_driver qmi_wwan_driver = {
+ 	.name		      = "qmi_wwan",
+ 	.id_table	      = products,
+ 	.probe		      = qmi_wwan_probe,
+ 	.disconnect	      = usbnet_disconnect,
+ 	.suspend	      = qmi_wwan_suspend,
+ 	.resume		      =	qmi_wwan_resume,
+ 	.reset_resume         = qmi_wwan_resume,
+ 	.supports_autosuspend = 1,
+ };
+ 
+ module_usb_driver(qmi_wwan_driver);
+ 
+ MODULE_AUTHOR("Bj√∏rn Mork <bjorn@mork.no>");
+ MODULE_DESCRIPTION("Qualcomm MSM Interface (QMI) WWAN driver");
+ MODULE_LICENSE("GPL");
diff -crNB --new-file ../llinux-2.6.32.42/drivers/net/usb/usbnet.c ./drivers/net/usb/usbnet.c
*** ../llinux-2.6.32.42/drivers/net/usb/usbnet.c	2015-06-08 14:32:18.263752888 -0700
--- ./drivers/net/usb/usbnet.c	2015-06-08 14:33:35.871755651 -0700
***************
*** 87,94 ****
  
  /*-------------------------------------------------------------------------*/
  
- // randomly generated ethernet address
- static u8	node_id [ETH_ALEN];
  
  static const char driver_name [] = "usbnet";
  
--- 87,92 ----
***************
*** 1768,1773 ****
--- 1766,1774 ----
  	int				status;
  	const char			*name;
  
+ 	// randomly generated ethernet address
+ 	u8	node_id [ETH_ALEN];
+ 
  	name = udev->dev.driver->name;
  	info = (struct driver_info *) prod->driver_info;
  	if (!info) {
***************
*** 1812,1817 ****
--- 1813,1823 ----
  	#ifdef USBNET_PPA_FP
  		dev->usbnet_ppadp_on = 0;
  	#endif
+ 	do {
+ 		random_ether_addr(node_id);
+ 		if ((node_id[0] & 0xd0) != 0x40)
+ 			break;
+ 	} while(1);
  
  	strcpy (net->name, "usb%d");
  	memcpy (net->dev_addr, node_id, sizeof node_id);
***************
*** 1965,1971 ****
  	BUILD_BUG_ON (sizeof (((struct sk_buff *)0)->cb)
  			< sizeof (struct skb_data));
  
- 	random_ether_addr(node_id);
  	return 0;
  }
  module_init(usbnet_init);
--- 1971,1976 ----
diff -crNB --new-file ../llinux-2.6.32.42/drivers/usb/class/cdc-wdm.c ./drivers/usb/class/cdc-wdm.c
*** ../llinux-2.6.32.42/drivers/usb/class/cdc-wdm.c	2015-06-08 14:32:18.239752888 -0700
--- ./drivers/usb/class/cdc-wdm.c	2015-06-08 14:33:35.871755651 -0700
***************
*** 23,28 ****
--- 23,29 ----
  #include <linux/usb/cdc.h>
  #include <asm/byteorder.h>
  #include <asm/unaligned.h>
+ #include <linux/usb/cdc-wdm.h>
  
  /*
   * Version Information
***************
*** 31,37 ****
  #define DRIVER_AUTHOR "Oliver Neukum"
  #define DRIVER_DESC "USB Abstract Control Model driver for USB WCM Device Management"
  
! static struct usb_device_id wdm_ids[] = {
  	{
  		.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS |
  				 USB_DEVICE_ID_MATCH_INT_SUBCLASS,
--- 32,38 ----
  #define DRIVER_AUTHOR "Oliver Neukum"
  #define DRIVER_DESC "USB Abstract Control Model driver for USB WCM Device Management"
  
! static const struct usb_device_id wdm_ids[] = {
  	{
  		.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS |
  				 USB_DEVICE_ID_MATCH_INT_SUBCLASS,
***************
*** 52,63 ****
  #define WDM_READ		4
  #define WDM_INT_STALL		5
  #define WDM_POLL_RUNNING	6
! 
  
  #define WDM_MAX			16
  
  
  static DEFINE_MUTEX(wdm_mutex);
  
  /* --- method tables --- */
  
--- 53,71 ----
  #define WDM_READ		4
  #define WDM_INT_STALL		5
  #define WDM_POLL_RUNNING	6
! #define WDM_RESPONDING		7
! #define WDM_SUSPENDING		8
! #define WDM_RESETTING		9
! #define WDM_OVERFLOW		10
  
  #define WDM_MAX			16
  
+ /* CDC-WMC r1.1 requires wMaxCommand to be "at least 256 decimal (0x100)" */
+ #define WDM_DEFAULT_BUFSIZE	256
  
  static DEFINE_MUTEX(wdm_mutex);
+ static DEFINE_SPINLOCK(wdm_device_list_lock);
+ static LIST_HEAD(wdm_device_list);
  
  /* --- method tables --- */
  
***************
*** 79,85 ****
  	u16			bufsize;
  	u16			wMaxCommand;
  	u16			wMaxPacketSize;
- 	u16			bMaxPacketSize0;
  	__le16			inum;
  	int			reslength;
  	int			length;
--- 87,92 ----
***************
*** 89,103 ****
  	dma_addr_t		ihandle;
  	struct mutex		wlock;
  	struct mutex		rlock;
- 	struct mutex		plock;
  	wait_queue_head_t	wait;
  	struct work_struct	rxwork;
  	int			werr;
  	int			rerr;
  };
  
  static struct usb_driver wdm_driver;
  
  /* --- callbacks --- */
  static void wdm_out_callback(struct urb *urb)
  {
--- 96,143 ----
  	dma_addr_t		ihandle;
  	struct mutex		wlock;
  	struct mutex		rlock;
  	wait_queue_head_t	wait;
  	struct work_struct	rxwork;
  	int			werr;
  	int			rerr;
+ 
+ 	struct list_head	device_list;
+ 	int			(*manage_power)(struct usb_interface *, int);
  };
  
  static struct usb_driver wdm_driver;
  
+ /* return intfdata if we own the interface, else look up intf in the list */
+ static struct wdm_device *wdm_find_device(struct usb_interface *intf)
+ {
+ 	struct wdm_device *desc;
+ 
+ 	spin_lock(&wdm_device_list_lock);
+ 	list_for_each_entry(desc, &wdm_device_list, device_list)
+ 		if (desc->intf == intf)
+ 			goto found;
+ 	desc = NULL;
+ found:
+ 	spin_unlock(&wdm_device_list_lock);
+ 
+ 	return desc;
+ }
+ 
+ static struct wdm_device *wdm_find_device_by_minor(int minor)
+ {
+ 	struct wdm_device *desc;
+ 
+ 	spin_lock(&wdm_device_list_lock);
+ 	list_for_each_entry(desc, &wdm_device_list, device_list)
+ 		if (desc->intf->minor == minor)
+ 			goto found;
+ 	desc = NULL;
+ found:
+ 	spin_unlock(&wdm_device_list_lock);
+ 
+ 	return desc;
+ }
+ 
  /* --- callbacks --- */
  static void wdm_out_callback(struct urb *urb)
  {
***************
*** 106,113 ****
  	spin_lock(&desc->iuspin);
  	desc->werr = urb->status;
  	spin_unlock(&desc->iuspin);
- 	clear_bit(WDM_IN_USE, &desc->flags);
  	kfree(desc->outbuf);
  	wake_up(&desc->wait);
  }
  
--- 146,154 ----
  	spin_lock(&desc->iuspin);
  	desc->werr = urb->status;
  	spin_unlock(&desc->iuspin);
  	kfree(desc->outbuf);
+ 	desc->outbuf = NULL;
+ 	clear_bit(WDM_IN_USE, &desc->flags);
  	wake_up(&desc->wait);
  }
  
***************
*** 115,137 ****
  {
  	struct wdm_device *desc = urb->context;
  	int status = urb->status;
  
  	spin_lock(&desc->iuspin);
  
  	if (status) {
  		switch (status) {
  		case -ENOENT:
  			dev_dbg(&desc->intf->dev,
  				"nonzero urb status received: -ENOENT");
! 			break;
  		case -ECONNRESET:
  			dev_dbg(&desc->intf->dev,
  				"nonzero urb status received: -ECONNRESET");
! 			break;
  		case -ESHUTDOWN:
  			dev_dbg(&desc->intf->dev,
  				"nonzero urb status received: -ESHUTDOWN");
! 			break;
  		case -EPIPE:
  			dev_err(&desc->intf->dev,
  				"nonzero urb status received: -EPIPE\n");
--- 156,180 ----
  {
  	struct wdm_device *desc = urb->context;
  	int status = urb->status;
+ 	int length = urb->actual_length;
  
  	spin_lock(&desc->iuspin);
+ 	clear_bit(WDM_RESPONDING, &desc->flags);
  
  	if (status) {
  		switch (status) {
  		case -ENOENT:
  			dev_dbg(&desc->intf->dev,
  				"nonzero urb status received: -ENOENT");
! 			goto skip_error;
  		case -ECONNRESET:
  			dev_dbg(&desc->intf->dev,
  				"nonzero urb status received: -ECONNRESET");
! 			goto skip_error;
  		case -ESHUTDOWN:
  			dev_dbg(&desc->intf->dev,
  				"nonzero urb status received: -ESHUTDOWN");
! 			goto skip_error;
  		case -EPIPE:
  			dev_err(&desc->intf->dev,
  				"nonzero urb status received: -EPIPE\n");
***************
*** 144,152 ****
  	}
  
  	desc->rerr = status;
! 	desc->reslength = urb->actual_length;
! 	memmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);
! 	desc->length += desc->reslength;
  	wake_up(&desc->wait);
  
  	set_bit(WDM_READ, &desc->flags);
--- 187,204 ----
  	}
  
  	desc->rerr = status;
! 	if (length + desc->length > desc->wMaxCommand) {
! 		/* The buffer would overflow */
! 		set_bit(WDM_OVERFLOW, &desc->flags);
! 	} else {
! 		/* we may already be in overflow */
! 		if (!test_bit(WDM_OVERFLOW, &desc->flags)) {
! 			memmove(desc->ubuf + desc->length, desc->inbuf, length);
! 			desc->length += length;
! 			desc->reslength = length;
! 		}
! 	}
! skip_error:
  	wake_up(&desc->wait);
  
  	set_bit(WDM_READ, &desc->flags);
***************
*** 158,168 ****
  	int rv = 0;
  	int status = urb->status;
  	struct wdm_device *desc;
- 	struct usb_ctrlrequest *req;
  	struct usb_cdc_notification *dr;
  
  	desc = urb->context;
- 	req = desc->irq;
  	dr = (struct usb_cdc_notification *)desc->sbuf;
  
  	if (status) {
--- 210,218 ----
***************
*** 209,241 ****
  		goto exit;
  	}
  
- 	req->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
- 	req->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
- 	req->wValue = 0;
- 	req->wIndex = desc->inum;
- 	req->wLength = cpu_to_le16(desc->wMaxCommand);
- 
- 	usb_fill_control_urb(
- 		desc->response,
- 		interface_to_usbdev(desc->intf),
- 		/* using common endpoint 0 */
- 		usb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),
- 		(unsigned char *)req,
- 		desc->inbuf,
- 		desc->wMaxCommand,
- 		wdm_in_callback,
- 		desc
- 	);
- 	desc->response->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  	spin_lock(&desc->iuspin);
  	clear_bit(WDM_READ, &desc->flags);
! 	if (!test_bit(WDM_DISCONNECTING, &desc->flags)) {
  		rv = usb_submit_urb(desc->response, GFP_ATOMIC);
  		dev_dbg(&desc->intf->dev, "%s: usb_submit_urb %d",
  			__func__, rv);
  	}
  	spin_unlock(&desc->iuspin);
  	if (rv < 0) {
  		if (rv == -EPERM)
  			return;
  		if (rv == -ENOMEM) {
--- 259,276 ----
  		goto exit;
  	}
  
  	spin_lock(&desc->iuspin);
  	clear_bit(WDM_READ, &desc->flags);
! 	set_bit(WDM_RESPONDING, &desc->flags);
! 	if (!test_bit(WDM_DISCONNECTING, &desc->flags)
! 		&& !test_bit(WDM_SUSPENDING, &desc->flags)) {
  		rv = usb_submit_urb(desc->response, GFP_ATOMIC);
  		dev_dbg(&desc->intf->dev, "%s: usb_submit_urb %d",
  			__func__, rv);
  	}
  	spin_unlock(&desc->iuspin);
  	if (rv < 0) {
+ 		clear_bit(WDM_RESPONDING, &desc->flags);
  		if (rv == -EPERM)
  			return;
  		if (rv == -ENOMEM) {
***************
*** 272,285 ****
  
  static void cleanup(struct wdm_device *desc)
  {
! 	usb_buffer_free(interface_to_usbdev(desc->intf),
! 			desc->wMaxPacketSize,
! 			desc->sbuf,
! 			desc->validity->transfer_dma);
! 	usb_buffer_free(interface_to_usbdev(desc->intf),
! 			desc->wMaxCommand,
! 			desc->inbuf,
! 			desc->response->transfer_dma);
  	kfree(desc->orq);
  	kfree(desc->irq);
  	kfree(desc->ubuf);
--- 307,314 ----
  
  static void cleanup(struct wdm_device *desc)
  {
! 	kfree(desc->sbuf);
! 	kfree(desc->inbuf);
  	kfree(desc->orq);
  	kfree(desc->irq);
  	kfree(desc->ubuf);
***************
*** 305,343 ****
  	if (we < 0)
  		return -EIO;
  
! 	r = mutex_lock_interruptible(&desc->wlock); /* concurrent writes */
  	rv = -ERESTARTSYS;
! 	if (r)
  		goto outnl;
  
  	r = usb_autopm_get_interface(desc->intf);
! 	if (r < 0)
  		goto outnp;
  
! 	if (!file->f_flags && O_NONBLOCK)
  		r = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,
  								&desc->flags));
  	else
  		if (test_bit(WDM_IN_USE, &desc->flags))
  			r = -EAGAIN;
- 	if (r < 0)
- 		goto out;
  
! 	if (test_bit(WDM_DISCONNECTING, &desc->flags)) {
! 		rv = -ENODEV;
! 		goto out;
! 	}
  
! 	desc->outbuf = buf = kmalloc(count, GFP_KERNEL);
! 	if (!buf) {
! 		rv = -ENOMEM;
! 		goto out;
! 	}
! 
! 	r = copy_from_user(buf, buffer, count);
! 	if (r > 0) {
  		kfree(buf);
! 		rv = -EFAULT;
  		goto out;
  	}
  
--- 334,386 ----
  	if (we < 0)
  		return -EIO;
  
! 	buf = kmalloc(count, GFP_KERNEL);
! 	if (!buf) {
! 		rv = -ENOMEM;
! 		goto outnl;
! 	}
! 
! 	r = copy_from_user(buf, buffer, count);
! 	if (r > 0) {
! 		kfree(buf);
! 		rv = -EFAULT;
! 		goto outnl;
! 	}
! 
! 	/* concurrent writes and disconnect */
! 	r = mutex_lock_interruptible(&desc->wlock);
  	rv = -ERESTARTSYS;
! 	if (r) {
! 		kfree(buf);
  		goto outnl;
+ 	}
+ 
+ 	if (test_bit(WDM_DISCONNECTING, &desc->flags)) {
+ 		kfree(buf);
+ 		rv = -ENODEV;
+ 		goto outnp;
+ 	}
  
  	r = usb_autopm_get_interface(desc->intf);
! 	if (r < 0) {
! 		kfree(buf);
! 		rv = usb_translate_errors(r);
  		goto outnp;
+ 	}
  
! 	if (!(file->f_flags & O_NONBLOCK))
  		r = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,
  								&desc->flags));
  	else
  		if (test_bit(WDM_IN_USE, &desc->flags))
  			r = -EAGAIN;
  
! 	if (test_bit(WDM_RESETTING, &desc->flags))
! 		r = -EIO;
  
! 	if (r < 0) {
  		kfree(buf);
! 		rv = r;
  		goto out;
  	}
  
***************
*** 361,372 ****
--- 404,418 ----
  	req->wIndex = desc->inum;
  	req->wLength = cpu_to_le16(count);
  	set_bit(WDM_IN_USE, &desc->flags);
+ 	desc->outbuf = buf;
  
  	rv = usb_submit_urb(desc->command, GFP_KERNEL);
  	if (rv < 0) {
  		kfree(buf);
+ 		desc->outbuf = NULL;
  		clear_bit(WDM_IN_USE, &desc->flags);
  		dev_err(&desc->intf->dev, "Tx URB error: %d\n", rv);
+ 		rv = usb_translate_errors(rv);
  	} else {
  		dev_dbg(&desc->intf->dev, "Tx URB has been submitted index=%d",
  			req->wIndex);
***************
*** 382,388 ****
  static ssize_t wdm_read
  (struct file *file, char __user *buffer, size_t count, loff_t *ppos)
  {
! 	int rv, cntr = 0;
  	int i = 0;
  	struct wdm_device *desc = file->private_data;
  
--- 428,434 ----
  static ssize_t wdm_read
  (struct file *file, char __user *buffer, size_t count, loff_t *ppos)
  {
! 	int rv, cntr;
  	int i = 0;
  	struct wdm_device *desc = file->private_data;
  
***************
*** 391,403 ****
  	if (rv < 0)
  		return -ERESTARTSYS;
  
! 	if (desc->length == 0) {
  		desc->read = 0;
  retry:
  		if (test_bit(WDM_DISCONNECTING, &desc->flags)) {
  			rv = -ENODEV;
  			goto err;
  		}
  		i++;
  		if (file->f_flags & O_NONBLOCK) {
  			if (!test_bit(WDM_READ, &desc->flags)) {
--- 437,455 ----
  	if (rv < 0)
  		return -ERESTARTSYS;
  
! 	cntr = ACCESS_ONCE(desc->length);
! 	if (cntr == 0) {
  		desc->read = 0;
  retry:
  		if (test_bit(WDM_DISCONNECTING, &desc->flags)) {
  			rv = -ENODEV;
  			goto err;
  		}
+ 		if (test_bit(WDM_OVERFLOW, &desc->flags)) {
+ 			clear_bit(WDM_OVERFLOW, &desc->flags);
+ 			rv = -ENOBUFS;
+ 			goto err;
+ 		}
  		i++;
  		if (file->f_flags & O_NONBLOCK) {
  			if (!test_bit(WDM_READ, &desc->flags)) {
***************
*** 415,420 ****
--- 467,476 ----
  			rv = -ENODEV;
  			goto err;
  		}
+ 		if (test_bit(WDM_RESETTING, &desc->flags)) {
+ 			rv = -EIO;
+ 			goto err;
+ 		}
  		usb_mark_last_busy(interface_to_usbdev(desc->intf));
  		if (rv < 0) {
  			rv = -ERESTARTSYS;
***************
*** 424,434 ****
  		spin_lock_irq(&desc->iuspin);
  
  		if (desc->rerr) { /* read completed, error happened */
- 			int t = desc->rerr;
  			desc->rerr = 0;
  			spin_unlock_irq(&desc->iuspin);
- 			dev_err(&desc->intf->dev,
- 				"reading had resulted in %d\n", t);
  			rv = -EIO;
  			goto err;
  		}
--- 480,487 ----
***************
*** 440,460 ****
  			spin_unlock_irq(&desc->iuspin);
  			goto retry;
  		}
  		if (!desc->reslength) { /* zero length read */
  			spin_unlock_irq(&desc->iuspin);
  			goto retry;
  		}
! 		clear_bit(WDM_READ, &desc->flags);
  		spin_unlock_irq(&desc->iuspin);
  	}
  
! 	cntr = count > desc->length ? desc->length : count;
  	rv = copy_to_user(buffer, desc->ubuf, cntr);
  	if (rv > 0) {
  		rv = -EFAULT;
  		goto err;
  	}
  
  	for (i = 0; i < desc->length - cntr; i++)
  		desc->ubuf[i] = desc->ubuf[i + cntr];
  
--- 493,519 ----
  			spin_unlock_irq(&desc->iuspin);
  			goto retry;
  		}
+ 
  		if (!desc->reslength) { /* zero length read */
+ 			dev_dbg(&desc->intf->dev, "%s: zero length - clearing WDM_READ\n", __func__);
+ 			clear_bit(WDM_READ, &desc->flags);
  			spin_unlock_irq(&desc->iuspin);
  			goto retry;
  		}
! 		cntr = desc->length;
  		spin_unlock_irq(&desc->iuspin);
  	}
  
! 	if (cntr > count)
! 		cntr = count;
  	rv = copy_to_user(buffer, desc->ubuf, cntr);
  	if (rv > 0) {
  		rv = -EFAULT;
  		goto err;
  	}
  
+ 	spin_lock_irq(&desc->iuspin);
+ 
  	for (i = 0; i < desc->length - cntr; i++)
  		desc->ubuf[i] = desc->ubuf[i + cntr];
  
***************
*** 462,473 ****
  	/* in case we had outstanding data */
  	if (!desc->length)
  		clear_bit(WDM_READ, &desc->flags);
  	rv = cntr;
  
  err:
  	mutex_unlock(&desc->rlock);
- 	if (rv < 0 && rv != -EAGAIN)
- 		dev_err(&desc->intf->dev, "wdm_read: exit error\n");
  	return rv;
  }
  
--- 521,533 ----
  	/* in case we had outstanding data */
  	if (!desc->length)
  		clear_bit(WDM_READ, &desc->flags);
+ 
+ 	spin_unlock_irq(&desc->iuspin);
+ 
  	rv = cntr;
  
  err:
  	mutex_unlock(&desc->rlock);
  	return rv;
  }
  
***************
*** 476,486 ****
  	struct wdm_device *desc = file->private_data;
  
  	wait_event(desc->wait, !test_bit(WDM_IN_USE, &desc->flags));
! 	if (desc->werr < 0)
  		dev_err(&desc->intf->dev, "Error in flush path: %d\n",
  			desc->werr);
  
! 	return desc->werr;
  }
  
  static unsigned int wdm_poll(struct file *file, struct poll_table_struct *wait)
--- 536,548 ----
  	struct wdm_device *desc = file->private_data;
  
  	wait_event(desc->wait, !test_bit(WDM_IN_USE, &desc->flags));
! 
! 	/* cannot dereference desc->intf if WDM_DISCONNECTING */
! 	if (desc->werr < 0 && !test_bit(WDM_DISCONNECTING, &desc->flags))
  		dev_err(&desc->intf->dev, "Error in flush path: %d\n",
  			desc->werr);
  
! 	return usb_translate_errors(desc->werr);
  }
  
  static unsigned int wdm_poll(struct file *file, struct poll_table_struct *wait)
***************
*** 491,497 ****
  
  	spin_lock_irqsave(&desc->iuspin, flags);
  	if (test_bit(WDM_DISCONNECTING, &desc->flags)) {
! 		mask = POLLERR;
  		spin_unlock_irqrestore(&desc->iuspin, flags);
  		goto desc_out;
  	}
--- 553,559 ----
  
  	spin_lock_irqsave(&desc->iuspin, flags);
  	if (test_bit(WDM_DISCONNECTING, &desc->flags)) {
! 		mask = POLLHUP | POLLERR;
  		spin_unlock_irqrestore(&desc->iuspin, flags);
  		goto desc_out;
  	}
***************
*** 517,527 ****
  	struct wdm_device *desc;
  
  	mutex_lock(&wdm_mutex);
! 	intf = usb_find_interface(&wdm_driver, minor);
! 	if (!intf)
  		goto out;
  
! 	desc = usb_get_intfdata(intf);
  	if (test_bit(WDM_DISCONNECTING, &desc->flags))
  		goto out;
  	file->private_data = desc;
--- 579,589 ----
  	struct wdm_device *desc;
  
  	mutex_lock(&wdm_mutex);
! 	desc = wdm_find_device_by_minor(minor);
! 	if (!desc)
  		goto out;
  
! 	intf = desc->intf;
  	if (test_bit(WDM_DISCONNECTING, &desc->flags))
  		goto out;
  	file->private_data = desc;
***************
*** 531,550 ****
  		dev_err(&desc->intf->dev, "Error autopm - %d\n", rv);
  		goto out;
  	}
- 	intf->needs_remote_wakeup = 1;
  
! 	mutex_lock(&desc->plock);
  	if (!desc->count++) {
  		rv = usb_submit_urb(desc->validity, GFP_KERNEL);
  		if (rv < 0) {
  			desc->count--;
  			dev_err(&desc->intf->dev,
  				"Error submitting int urb - %d\n", rv);
  		}
  	} else {
  		rv = 0;
  	}
! 	mutex_unlock(&desc->plock);
  	usb_autopm_put_interface(desc->intf);
  out:
  	mutex_unlock(&wdm_mutex);
--- 593,617 ----
  		dev_err(&desc->intf->dev, "Error autopm - %d\n", rv);
  		goto out;
  	}
  
! 	/* using write lock to protect desc->count */
! 	mutex_lock(&desc->wlock);
  	if (!desc->count++) {
+ 		desc->werr = 0;
+ 		desc->rerr = 0;
  		rv = usb_submit_urb(desc->validity, GFP_KERNEL);
  		if (rv < 0) {
  			desc->count--;
  			dev_err(&desc->intf->dev,
  				"Error submitting int urb - %d\n", rv);
+ 			rv = usb_translate_errors(rv);
  		}
  	} else {
  		rv = 0;
  	}
! 	mutex_unlock(&desc->wlock);
! 	if (desc->count == 1)
! 		desc->manage_power(intf, 1);
  	usb_autopm_put_interface(desc->intf);
  out:
  	mutex_unlock(&wdm_mutex);
***************
*** 556,570 ****
  	struct wdm_device *desc = file->private_data;
  
  	mutex_lock(&wdm_mutex);
! 	mutex_lock(&desc->plock);
  	desc->count--;
! 	mutex_unlock(&desc->plock);
  
  	if (!desc->count) {
! 		dev_dbg(&desc->intf->dev, "wdm_release: cleanup");
! 		kill_urbs(desc);
! 		if (!test_bit(WDM_DISCONNECTING, &desc->flags))
! 			desc->intf->needs_remote_wakeup = 0;
  	}
  	mutex_unlock(&wdm_mutex);
  	return 0;
--- 623,644 ----
  	struct wdm_device *desc = file->private_data;
  
  	mutex_lock(&wdm_mutex);
! 
! 	/* using write lock to protect desc->count */
! 	mutex_lock(&desc->wlock);
  	desc->count--;
! 	mutex_unlock(&desc->wlock);
  
  	if (!desc->count) {
! 		if (!test_bit(WDM_DISCONNECTING, &desc->flags)) {
! 			dev_dbg(&desc->intf->dev, "wdm_release: cleanup");
! 			kill_urbs(desc);
! 			desc->manage_power(desc->intf, 0);
! 		} else {
! 			/* must avoid dev_printk here as desc->intf is invalid */
! 			pr_debug(KBUILD_MODNAME " %s: device gone - cleaning up\n", __func__);
! 			cleanup(desc);
! 		}
  	}
  	mutex_unlock(&wdm_mutex);
  	return 0;
***************
*** 577,587 ****
  	.open =		wdm_open,
  	.flush =	wdm_flush,
  	.release =	wdm_release,
! 	.poll =		wdm_poll
  };
  
  static struct usb_class_driver wdm_class = {
! 	.name =		"cdc-wdm%d",
  	.fops =		&wdm_fops,
  	.minor_base =	WDM_MINOR_BASE,
  };
--- 651,661 ----
  	.open =		wdm_open,
  	.flush =	wdm_flush,
  	.release =	wdm_release,
! 	.poll =		wdm_poll,
  };
  
  static struct usb_class_driver wdm_class = {
! 	.name =		"qcqmi%d",
  	.fops =		&wdm_fops,
  	.minor_base =	WDM_MINOR_BASE,
  };
***************
*** 610,681 ****
  
  /* --- hotplug --- */
  
! static int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
! 	int rv = -EINVAL;
! 	struct usb_device *udev = interface_to_usbdev(intf);
  	struct wdm_device *desc;
- 	struct usb_host_interface *iface;
- 	struct usb_endpoint_descriptor *ep;
- 	struct usb_cdc_dmm_desc *dmhd;
- 	u8 *buffer = intf->altsetting->extra;
- 	int buflen = intf->altsetting->extralen;
- 	u16 maxcom = 0;
  
- 	if (!buffer)
- 		goto out;
- 
- 	while (buflen > 2) {
- 		if (buffer [1] != USB_DT_CS_INTERFACE) {
- 			dev_err(&intf->dev, "skipping garbage\n");
- 			goto next_desc;
- 		}
- 
- 		switch (buffer [2]) {
- 		case USB_CDC_HEADER_TYPE:
- 			break;
- 		case USB_CDC_DMM_TYPE:
- 			dmhd = (struct usb_cdc_dmm_desc *)buffer;
- 			maxcom = le16_to_cpu(dmhd->wMaxCommand);
- 			dev_dbg(&intf->dev,
- 				"Finding maximum buffer length: %d", maxcom);
- 			break;
- 		default:
- 			dev_err(&intf->dev,
- 				"Ignoring extra header, type %d, length %d\n",
- 				buffer[2], buffer[0]);
- 			break;
- 		}
- next_desc:
- 		buflen -= buffer[0];
- 		buffer += buffer[0];
- 	}
- 
- 	rv = -ENOMEM;
  	desc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);
  	if (!desc)
  		goto out;
! 	mutex_init(&desc->wlock);
  	mutex_init(&desc->rlock);
! 	mutex_init(&desc->plock);
  	spin_lock_init(&desc->iuspin);
  	init_waitqueue_head(&desc->wait);
! 	desc->wMaxCommand = maxcom;
  	/* this will be expanded and needed in hardware endianness */
  	desc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);
  	desc->intf = intf;
  	INIT_WORK(&desc->rxwork, wdm_rxwork);
  
  	rv = -EINVAL;
! 	iface = intf->cur_altsetting;
! 	if (iface->desc.bNumEndpoints != 1)
! 		goto err;
! 	ep = &iface->endpoint[0].desc;
! 	if (!ep || !usb_endpoint_is_int_in(ep))
  		goto err;
  
! 	desc->wMaxPacketSize = le16_to_cpu(ep->wMaxPacketSize);
! 	desc->bMaxPacketSize0 = udev->descriptor.bMaxPacketSize0;
  
  	desc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
  	if (!desc->orq)
--- 684,714 ----
  
  /* --- hotplug --- */
  
! static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor *ep,
! 		u16 bufsize, int (*manage_power)(struct usb_interface *, int))
  {
! 	int rv = -ENOMEM;
  	struct wdm_device *desc;
  
  	desc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);
  	if (!desc)
  		goto out;
! 	INIT_LIST_HEAD(&desc->device_list);
  	mutex_init(&desc->rlock);
! 	mutex_init(&desc->wlock);
  	spin_lock_init(&desc->iuspin);
  	init_waitqueue_head(&desc->wait);
! 	desc->wMaxCommand = bufsize;
  	/* this will be expanded and needed in hardware endianness */
  	desc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);
  	desc->intf = intf;
  	INIT_WORK(&desc->rxwork, wdm_rxwork);
  
  	rv = -EINVAL;
! 	if (!usb_endpoint_is_int_in(ep))
  		goto err;
  
! 	desc->wMaxPacketSize = usb_endpoint_maxp(ep);
  
  	desc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
  	if (!desc->orq)
***************
*** 700,718 ****
  	if (!desc->ubuf)
  		goto err;
  
! 	desc->sbuf = usb_buffer_alloc(interface_to_usbdev(intf),
! 					desc->wMaxPacketSize,
! 					GFP_KERNEL,
! 					&desc->validity->transfer_dma);
  	if (!desc->sbuf)
  		goto err;
  
! 	desc->inbuf = usb_buffer_alloc(interface_to_usbdev(intf),
! 					desc->bMaxPacketSize0,
! 					GFP_KERNEL,
! 					&desc->response->transfer_dma);
  	if (!desc->inbuf)
! 		goto err2;
  
  	usb_fill_int_urb(
  		desc->validity,
--- 733,745 ----
  	if (!desc->ubuf)
  		goto err;
  
! 	desc->sbuf = kmalloc(desc->wMaxPacketSize, GFP_KERNEL);
  	if (!desc->sbuf)
  		goto err;
  
! 	desc->inbuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);
  	if (!desc->inbuf)
! 		goto err;
  
  	usb_fill_int_urb(
  		desc->validity,
***************
*** 724,768 ****
  		desc,
  		ep->bInterval
  	);
- 	desc->validity->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  
! 	usb_set_intfdata(intf, desc);
  	rv = usb_register_dev(intf, &wdm_class);
  	if (rv < 0)
! 		goto err3;
  	else
! 		dev_info(&intf->dev, "cdc-wdm%d: USB WDM device\n",
! 			intf->minor - WDM_MINOR_BASE);
  out:
  	return rv;
- err3:
- 	usb_set_intfdata(intf, NULL);
- 	usb_buffer_free(interface_to_usbdev(desc->intf),
- 			desc->bMaxPacketSize0,
- 			desc->inbuf,
- 			desc->response->transfer_dma);
- err2:
- 	usb_buffer_free(interface_to_usbdev(desc->intf),
- 			desc->wMaxPacketSize,
- 			desc->sbuf,
- 			desc->validity->transfer_dma);
  err:
! 	free_urbs(desc);
! 	kfree(desc->ubuf);
! 	kfree(desc->orq);
! 	kfree(desc->irq);
! 	kfree(desc);
  	return rv;
  }
  
  static void wdm_disconnect(struct usb_interface *intf)
  {
  	struct wdm_device *desc;
  	unsigned long flags;
  
  	usb_deregister_dev(intf, &wdm_class);
  	mutex_lock(&wdm_mutex);
- 	desc = usb_get_intfdata(intf);
  
  	/* the spinlock makes sure no new urbs are generated in the callbacks */
  	spin_lock_irqsave(&desc->iuspin, flags);
--- 751,902 ----
  		desc,
  		ep->bInterval
  	);
  
! 	desc->irq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
! 	desc->irq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
! 	desc->irq->wValue = 0;
! 	desc->irq->wIndex = desc->inum;
! 	desc->irq->wLength = cpu_to_le16(desc->wMaxCommand);
! 
! 	usb_fill_control_urb(
! 		desc->response,
! 		interface_to_usbdev(intf),
! 		/* using common endpoint 0 */
! 		usb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),
! 		(unsigned char *)desc->irq,
! 		desc->inbuf,
! 		desc->wMaxCommand,
! 		wdm_in_callback,
! 		desc
! 	);
! 
! 	desc->manage_power = manage_power;
! 
! 	spin_lock(&wdm_device_list_lock);
! 	list_add(&desc->device_list, &wdm_device_list);
! 	spin_unlock(&wdm_device_list_lock);
! 
  	rv = usb_register_dev(intf, &wdm_class);
  	if (rv < 0)
! 		goto err;
  	else
! 		dev_info(&intf->dev, "%s: USB WDM device\n", dev_name(intf->usb_dev));
  out:
  	return rv;
  err:
! 	spin_lock(&wdm_device_list_lock);
! 	list_del(&desc->device_list);
! 	spin_unlock(&wdm_device_list_lock);
! 	cleanup(desc);
  	return rv;
  }
  
+ static int wdm_manage_power(struct usb_interface *intf, int on)
+ {
+ 	/* need autopm_get/put here to ensure the usbcore sees the new value */
+ 	int rv = usb_autopm_get_interface(intf);
+ 	if (rv < 0)
+ 		goto err;
+ 
+ 	intf->needs_remote_wakeup = on;
+ 	usb_autopm_put_interface(intf);
+ err:
+ 	return rv;
+ }
+ 
+ static int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)
+ {
+ 	int rv = -EINVAL;
+ 	struct usb_host_interface *iface;
+ 	struct usb_endpoint_descriptor *ep;
+ 	struct usb_cdc_dmm_desc *dmhd;
+ 	u8 *buffer = intf->altsetting->extra;
+ 	int buflen = intf->altsetting->extralen;
+ 	u16 maxcom = WDM_DEFAULT_BUFSIZE;
+ 
+ 	if (!buffer)
+ 		goto err;
+ 	while (buflen > 2) {
+ 		if (buffer[1] != USB_DT_CS_INTERFACE) {
+ 			dev_err(&intf->dev, "skipping garbage\n");
+ 			goto next_desc;
+ 		}
+ 
+ 		switch (buffer[2]) {
+ 		case USB_CDC_HEADER_TYPE:
+ 			break;
+ 		case USB_CDC_DMM_TYPE:
+ 			dmhd = (struct usb_cdc_dmm_desc *)buffer;
+ 			maxcom = le16_to_cpu(dmhd->wMaxCommand);
+ 			dev_dbg(&intf->dev,
+ 				"Finding maximum buffer length: %d", maxcom);
+ 			break;
+ 		default:
+ 			dev_err(&intf->dev,
+ 				"Ignoring extra header, type %d, length %d\n",
+ 				buffer[2], buffer[0]);
+ 			break;
+ 		}
+ next_desc:
+ 		buflen -= buffer[0];
+ 		buffer += buffer[0];
+ 	}
+ 
+ 	iface = intf->cur_altsetting;
+ 	if (iface->desc.bNumEndpoints != 1)
+ 		goto err;
+ 	ep = &iface->endpoint[0].desc;
+ 
+ 	rv = wdm_create(intf, ep, maxcom, &wdm_manage_power);
+ 
+ err:
+ 	return rv;
+ }
+ 
+ /**
+  * usb_cdc_wdm_register - register a WDM subdriver
+  * @intf: usb interface the subdriver will associate with
+  * @ep: interrupt endpoint to monitor for notifications
+  * @bufsize: maximum message size to support for read/write
+  *
+  * Create WDM usb class character device and associate it with intf
+  * without binding, allowing another driver to manage the interface.
+  *
+  * The subdriver will manage the given interrupt endpoint exclusively
+  * and will issue control requests referring to the given intf. It
+  * will otherwise avoid interferring, and in particular not do
+  * usb_set_intfdata/usb_get_intfdata on intf.
+  *
+  * The return value is a pointer to the subdriver's struct usb_driver.
+  * The registering driver is responsible for calling this subdriver's
+  * disconnect, suspend, resume, pre_reset and post_reset methods from
+  * its own.
+  */
+ struct usb_driver *usb_cdc_wdm_register(struct usb_interface *intf,
+ 					struct usb_endpoint_descriptor *ep,
+ 					int bufsize,
+ 					int (*manage_power)(struct usb_interface *, int))
+ {
+ 	int rv = -EINVAL;
+ 
+ 	rv = wdm_create(intf, ep, bufsize, manage_power);
+ 	if (rv < 0)
+ 		goto err;
+ 
+ 	return &wdm_driver;
+ err:
+ 	return ERR_PTR(rv);
+ }
+ EXPORT_SYMBOL(usb_cdc_wdm_register);
+ 
  static void wdm_disconnect(struct usb_interface *intf)
  {
  	struct wdm_device *desc;
  	unsigned long flags;
  
  	usb_deregister_dev(intf, &wdm_class);
+ 	desc = wdm_find_device(intf);
  	mutex_lock(&wdm_mutex);
  
  	/* the spinlock makes sure no new urbs are generated in the callbacks */
  	spin_lock_irqsave(&desc->iuspin, flags);
***************
*** 771,807 ****
  	/* to terminate pending flushes */
  	clear_bit(WDM_IN_USE, &desc->flags);
  	spin_unlock_irqrestore(&desc->iuspin, flags);
- 	cancel_work_sync(&desc->rxwork);
- 	kill_urbs(desc);
  	wake_up_all(&desc->wait);
  	if (!desc->count)
  		cleanup(desc);
  	mutex_unlock(&wdm_mutex);
  }
  
  static int wdm_suspend(struct usb_interface *intf, pm_message_t message)
  {
! 	struct wdm_device *desc = usb_get_intfdata(intf);
  	int rv = 0;
  
  	dev_dbg(&desc->intf->dev, "wdm%d_suspend\n", intf->minor);
  
! 	mutex_lock(&desc->plock);
! #ifdef CONFIG_PM
! 	if ((message.event & PM_EVENT_AUTO) &&
! 			test_bit(WDM_IN_USE, &desc->flags)) {
  		rv = -EBUSY;
  	} else {
! #endif
! 		cancel_work_sync(&desc->rxwork);
  		kill_urbs(desc);
! #ifdef CONFIG_PM
  	}
- #endif
- 	mutex_unlock(&desc->plock);
  
  	return rv;
  }
  
  static int recover_from_urb_loss(struct wdm_device *desc)
  {
--- 905,966 ----
  	/* to terminate pending flushes */
  	clear_bit(WDM_IN_USE, &desc->flags);
  	spin_unlock_irqrestore(&desc->iuspin, flags);
  	wake_up_all(&desc->wait);
+ 	mutex_lock(&desc->rlock);
+ 	mutex_lock(&desc->wlock);
+ 	kill_urbs(desc);
+ 	cancel_work_sync(&desc->rxwork);
+ 	mutex_unlock(&desc->wlock);
+ 	mutex_unlock(&desc->rlock);
+ 
+ 	/* the desc->intf pointer used as list key is now invalid */
+ 	spin_lock(&wdm_device_list_lock);
+ 	list_del(&desc->device_list);
+ 	spin_unlock(&wdm_device_list_lock);
+ 
  	if (!desc->count)
  		cleanup(desc);
+ 	else
+ 		dev_dbg(&intf->dev, "%s: %d open files - postponing cleanup\n", __func__, desc->count);
  	mutex_unlock(&wdm_mutex);
  }
  
+ #ifdef CONFIG_PM
  static int wdm_suspend(struct usb_interface *intf, pm_message_t message)
  {
! 	struct wdm_device *desc = wdm_find_device(intf);
  	int rv = 0;
  
  	dev_dbg(&desc->intf->dev, "wdm%d_suspend\n", intf->minor);
  
! 	/* if this is an autosuspend the caller does the locking */
! 	if (!PMSG_IS_AUTO(message)) {
! 		mutex_lock(&desc->rlock);
! 		mutex_lock(&desc->wlock);
! 	}
! 	spin_lock_irq(&desc->iuspin);
! 
! 	if (PMSG_IS_AUTO(message) &&
! 			(test_bit(WDM_IN_USE, &desc->flags)
! 			|| test_bit(WDM_RESPONDING, &desc->flags))) {
! 		spin_unlock_irq(&desc->iuspin);
  		rv = -EBUSY;
  	} else {
! 
! 		set_bit(WDM_SUSPENDING, &desc->flags);
! 		spin_unlock_irq(&desc->iuspin);
! 		/* callback submits work - order is essential */
  		kill_urbs(desc);
! 		cancel_work_sync(&desc->rxwork);
! 	}
! 	if (!PMSG_IS_AUTO(message)) {
! 		mutex_unlock(&desc->wlock);
! 		mutex_unlock(&desc->rlock);
  	}
  
  	return rv;
  }
+ #endif
  
  static int recover_from_urb_loss(struct wdm_device *desc)
  {
***************
*** 815,847 ****
  	}
  	return rv;
  }
  static int wdm_resume(struct usb_interface *intf)
  {
! 	struct wdm_device *desc = usb_get_intfdata(intf);
  	int rv;
  
  	dev_dbg(&desc->intf->dev, "wdm%d_resume\n", intf->minor);
! 	mutex_lock(&desc->plock);
  	rv = recover_from_urb_loss(desc);
! 	mutex_unlock(&desc->plock);
  	return rv;
  }
  
  static int wdm_pre_reset(struct usb_interface *intf)
  {
! 	struct wdm_device *desc = usb_get_intfdata(intf);
  
! 	mutex_lock(&desc->plock);
  	return 0;
  }
  
  static int wdm_post_reset(struct usb_interface *intf)
  {
! 	struct wdm_device *desc = usb_get_intfdata(intf);
  	int rv;
  
  	rv = recover_from_urb_loss(desc);
! 	mutex_unlock(&desc->plock);
  	return 0;
  }
  
--- 974,1029 ----
  	}
  	return rv;
  }
+ 
+ #ifdef CONFIG_PM
  static int wdm_resume(struct usb_interface *intf)
  {
! 	struct wdm_device *desc = wdm_find_device(intf);
  	int rv;
  
  	dev_dbg(&desc->intf->dev, "wdm%d_resume\n", intf->minor);
! 
! 	clear_bit(WDM_SUSPENDING, &desc->flags);
  	rv = recover_from_urb_loss(desc);
! 
  	return rv;
  }
+ #endif
  
  static int wdm_pre_reset(struct usb_interface *intf)
  {
! 	struct wdm_device *desc = wdm_find_device(intf);
  
! 	/*
! 	 * we notify everybody using poll of
! 	 * an exceptional situation
! 	 * must be done before recovery lest a spontaneous
! 	 * message from the device is lost
! 	 */
! 	spin_lock_irq(&desc->iuspin);
! 	set_bit(WDM_RESETTING, &desc->flags);	/* inform read/write */
! 	set_bit(WDM_READ, &desc->flags);	/* unblock read */
! 	clear_bit(WDM_IN_USE, &desc->flags);	/* unblock write */
! 	desc->rerr = -EINTR;
! 	spin_unlock_irq(&desc->iuspin);
! 	wake_up_all(&desc->wait);
! 	mutex_lock(&desc->rlock);
! 	mutex_lock(&desc->wlock);
! 	kill_urbs(desc);
! 	cancel_work_sync(&desc->rxwork);
  	return 0;
  }
  
  static int wdm_post_reset(struct usb_interface *intf)
  {
! 	struct wdm_device *desc = wdm_find_device(intf);
  	int rv;
  
+ 	clear_bit(WDM_OVERFLOW, &desc->flags);
+ 	clear_bit(WDM_RESETTING, &desc->flags);
  	rv = recover_from_urb_loss(desc);
! 	mutex_unlock(&desc->wlock);
! 	mutex_unlock(&desc->rlock);
  	return 0;
  }
  
***************
*** 849,881 ****
  	.name =		"cdc_wdm",
  	.probe =	wdm_probe,
  	.disconnect =	wdm_disconnect,
  	.suspend =	wdm_suspend,
  	.resume =	wdm_resume,
  	.reset_resume =	wdm_resume,
  	.pre_reset =	wdm_pre_reset,
  	.post_reset =	wdm_post_reset,
  	.id_table =	wdm_ids,
  	.supports_autosuspend = 1,
  };
  
! /* --- low level module stuff --- */
! 
! static int __init wdm_init(void)
! {
! 	int rv;
! 
! 	rv = usb_register(&wdm_driver);
! 
! 	return rv;
! }
! 
! static void __exit wdm_exit(void)
! {
! 	usb_deregister(&wdm_driver);
! }
! 
! module_init(wdm_init);
! module_exit(wdm_exit);
  
  MODULE_AUTHOR(DRIVER_AUTHOR);
  MODULE_DESCRIPTION(DRIVER_DESC);
--- 1031,1048 ----
  	.name =		"cdc_wdm",
  	.probe =	wdm_probe,
  	.disconnect =	wdm_disconnect,
+ #ifdef CONFIG_PM
  	.suspend =	wdm_suspend,
  	.resume =	wdm_resume,
  	.reset_resume =	wdm_resume,
+ #endif
  	.pre_reset =	wdm_pre_reset,
  	.post_reset =	wdm_post_reset,
  	.id_table =	wdm_ids,
  	.supports_autosuspend = 1,
  };
  
! module_usb_driver(wdm_driver);
  
  MODULE_AUTHOR(DRIVER_AUTHOR);
  MODULE_DESCRIPTION(DRIVER_DESC);
diff -crNB --new-file ../llinux-2.6.32.42/drivers/usb/core/driver.c ./drivers/usb/core/driver.c
*** ../llinux-2.6.32.42/drivers/usb/core/driver.c	2015-06-08 14:32:18.243752889 -0700
--- ./drivers/usb/core/driver.c	2015-06-08 14:33:35.871755651 -0700
***************
*** 465,478 ****
  	if (!usb_match_device(dev, id))
  		return 0;
  
! 	/* The interface class, subclass, and protocol should never be
  	 * checked for a match if the device class is Vendor Specific,
  	 * unless the match record specifies the Vendor ID. */
  	if (dev->descriptor.bDeviceClass == USB_CLASS_VENDOR_SPEC &&
  			!(id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
  			(id->match_flags & (USB_DEVICE_ID_MATCH_INT_CLASS |
  				USB_DEVICE_ID_MATCH_INT_SUBCLASS |
! 				USB_DEVICE_ID_MATCH_INT_PROTOCOL)))
  		return 0;
  
  	if ((id->match_flags & USB_DEVICE_ID_MATCH_INT_CLASS) &&
--- 465,479 ----
  	if (!usb_match_device(dev, id))
  		return 0;
  
! 	/* The interface class, subclass, protocol and number should never be
  	 * checked for a match if the device class is Vendor Specific,
  	 * unless the match record specifies the Vendor ID. */
  	if (dev->descriptor.bDeviceClass == USB_CLASS_VENDOR_SPEC &&
  			!(id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
  			(id->match_flags & (USB_DEVICE_ID_MATCH_INT_CLASS |
  				USB_DEVICE_ID_MATCH_INT_SUBCLASS |
! 				USB_DEVICE_ID_MATCH_INT_PROTOCOL |
! 				USB_DEVICE_ID_MATCH_INT_NUMBER)))
  		return 0;
  
  	if ((id->match_flags & USB_DEVICE_ID_MATCH_INT_CLASS) &&
***************
*** 487,492 ****
--- 488,497 ----
  	    (id->bInterfaceProtocol != intf->desc.bInterfaceProtocol))
  		return 0;
  
+ 	if ((id->match_flags & USB_DEVICE_ID_MATCH_INT_NUMBER) &&
+ 	    (id->bInterfaceNumber != intf->desc.bInterfaceNumber))
+ 		return 0;
+ 
  	return 1;
  }
  EXPORT_SYMBOL_GPL(usb_match_one_id);
diff -crNB --new-file ../llinux-2.6.32.42/drivers/usb/core/message.c ./drivers/usb/core/message.c
*** ../llinux-2.6.32.42/drivers/usb/core/message.c	2015-06-08 14:32:18.243752889 -0700
--- ./drivers/usb/core/message.c	2015-06-08 14:33:35.871755651 -0700
***************
*** 1504,1510 ****
  
  	if (add_uevent_var(env,
  		   "MODALIAS=usb:"
! 		   "v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
  		   le16_to_cpu(usb_dev->descriptor.idVendor),
  		   le16_to_cpu(usb_dev->descriptor.idProduct),
  		   le16_to_cpu(usb_dev->descriptor.bcdDevice),
--- 1504,1510 ----
  
  	if (add_uevent_var(env,
  		   "MODALIAS=usb:"
! 		   "v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X",
  		   le16_to_cpu(usb_dev->descriptor.idVendor),
  		   le16_to_cpu(usb_dev->descriptor.idProduct),
  		   le16_to_cpu(usb_dev->descriptor.bcdDevice),
***************
*** 1513,1519 ****
  		   usb_dev->descriptor.bDeviceProtocol,
  		   alt->desc.bInterfaceClass,
  		   alt->desc.bInterfaceSubClass,
! 		   alt->desc.bInterfaceProtocol))
  		return -ENOMEM;
  
  	return 0;
--- 1513,1520 ----
  		   usb_dev->descriptor.bDeviceProtocol,
  		   alt->desc.bInterfaceClass,
  		   alt->desc.bInterfaceSubClass,
! 		   alt->desc.bInterfaceProtocol,
! 		   alt->desc.bInterfaceNumber))
  		return -ENOMEM;
  
  	return 0;
diff -crNB --new-file ../llinux-2.6.32.42/drivers/usb/core/sysfs.c ./drivers/usb/core/sysfs.c
*** ../llinux-2.6.32.42/drivers/usb/core/sysfs.c	2015-06-08 14:32:18.243752889 -0700
--- ./drivers/usb/core/sysfs.c	2015-06-08 14:33:35.871755651 -0700
***************
*** 733,739 ****
  	alt = intf->cur_altsetting;
  
  	return sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X"
! 			"ic%02Xisc%02Xip%02X\n",
  			le16_to_cpu(udev->descriptor.idVendor),
  			le16_to_cpu(udev->descriptor.idProduct),
  			le16_to_cpu(udev->descriptor.bcdDevice),
--- 733,739 ----
  	alt = intf->cur_altsetting;
  
  	return sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X"
! 			"ic%02Xisc%02Xip%02Xin%02X\n",
  			le16_to_cpu(udev->descriptor.idVendor),
  			le16_to_cpu(udev->descriptor.idProduct),
  			le16_to_cpu(udev->descriptor.bcdDevice),
***************
*** 742,748 ****
  			udev->descriptor.bDeviceProtocol,
  			alt->desc.bInterfaceClass,
  			alt->desc.bInterfaceSubClass,
! 			alt->desc.bInterfaceProtocol);
  }
  static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
  
--- 742,749 ----
  			udev->descriptor.bDeviceProtocol,
  			alt->desc.bInterfaceClass,
  			alt->desc.bInterfaceSubClass,
! 			alt->desc.bInterfaceProtocol,
! 			alt->desc.bInterfaceNumber);
  }
  static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
  
diff -crNB --new-file ../llinux-2.6.32.42/drivers/usb/serial/option.c ./drivers/usb/serial/option.c
*** ../llinux-2.6.32.42/drivers/usb/serial/option.c	2015-06-08 14:32:18.243752889 -0700
--- ./drivers/usb/serial/option.c	2015-06-08 14:33:30.999755480 -0700
***************
*** 305,310 ****
--- 305,313 ----
  #define TELIT_PRODUCT_UC864E			0x1003
  #define TELIT_PRODUCT_UC864G			0x1004
  
+ /* ConnectedIP */
+ #define TELIT_PRODUCT_LE910			0x1201
+ 
  /* ZTE PRODUCTS */
  #define ZTE_VENDOR_ID				0x19d2
  #define ZTE_PRODUCT_MF622			0x0001
***************
*** 404,409 ****
--- 407,417 ----
  #define SAMSUNG_VENDOR_ID                       0x04e8
  #define SAMSUNG_PRODUCT_GT_B3730                0x6889
  
+ /* static const struct option_blacklist_info telit_le910_blacklist = {
+ 	.sendsetup = BIT(0),
+ 	.reserved = BIT(1) | BIT(2),
+ };*/
+ 
  static struct usb_device_id option_ids[] = {
  	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
  	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
***************
*** 597,602 ****
--- 605,616 ----
  	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6008) },
  	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UC864E) },
  	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UC864G) },
+ 
+ /*	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
+ 		.driver_info = (kernel_ulong_t)&telit_le910_blacklist },
+ */
+ 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910)},
+ 
  	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
  	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
diff -crNB --new-file ../llinux-2.6.32.42/include/linux/mod_devicetable.h ./include/linux/mod_devicetable.h
*** ../llinux-2.6.32.42/include/linux/mod_devicetable.h	2015-06-08 14:32:37.035753558 -0700
--- ./include/linux/mod_devicetable.h	2015-06-08 14:33:35.871755651 -0700
***************
*** 78,83 ****
--- 78,86 ----
   *	of a given interface; other interfaces may support other classes.
   * @bInterfaceSubClass: Subclass of interface; associated with bInterfaceClass.
   * @bInterfaceProtocol: Protocol of interface; associated with bInterfaceClass.
+  * @bInterfaceNumber: Number of interface; composite devices may use
+  *	fixed interface numbers to differentiate between vendor-specific
+  *	interfaces.
   * @driver_info: Holds information used by the driver.  Usually it holds
   *	a pointer to a descriptor understood by the driver, or perhaps
   *	device flags.
***************
*** 115,122 ****
  	__u8		bInterfaceSubClass;
  	__u8		bInterfaceProtocol;
  
  	/* not matched against */
! 	kernel_ulong_t	driver_info;
  };
  
  /* Some useful macros to use to create struct usb_device_id */
--- 118,129 ----
  	__u8		bInterfaceSubClass;
  	__u8		bInterfaceProtocol;
  
+ 	/* Used for vendor-specific interface matches */
+ 	__u8		bInterfaceNumber;
+ 
  	/* not matched against */
! 	kernel_ulong_t	driver_info
! 		__attribute__((aligned(sizeof(kernel_ulong_t))));
  };
  
  /* Some useful macros to use to create struct usb_device_id */
***************
*** 130,135 ****
--- 137,143 ----
  #define USB_DEVICE_ID_MATCH_INT_CLASS		0x0080
  #define USB_DEVICE_ID_MATCH_INT_SUBCLASS	0x0100
  #define USB_DEVICE_ID_MATCH_INT_PROTOCOL	0x0200
+ #define USB_DEVICE_ID_MATCH_INT_NUMBER		0x0400
  
  #define HID_ANY_ID				(~0)
  
diff -crNB --new-file ../llinux-2.6.32.42/include/linux/usb/cdc-wdm.h ./include/linux/usb/cdc-wdm.h
*** ../llinux-2.6.32.42/include/linux/usb/cdc-wdm.h	1969-12-31 16:00:00.000000000 -0800
--- ./include/linux/usb/cdc-wdm.h	2015-06-08 14:33:35.907755653 -0700
***************
*** 0 ****
--- 1,128 ----
+ /*
+  * USB CDC Device Management subdriver
+  *
+  * Copyright (c) 2012  Bj√∏rn Mork <bjorn@mork.no>
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * version 2 as published by the Free Software Foundation.
+  */
+ 
+ #ifndef __LINUX_USB_CDC_WDM_H
+ #define __LINUX_USB_CDC_WDM_H
+ 
+ /* include/uapi/linux/usb/ch9.h */
+ /**
+  * usb_endpoint_maxp - get endpoint's max packet size
+  * @epd: endpoint to be checked
+  *
+  * Returns @epd's max packet
+  */
+ static inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)
+ {
+ 	return __le16_to_cpu(epd->wMaxPacketSize);
+ }
+ 
+ /* from include/linux/usb/usbnet.h */
+ #define FLAG_WWAN	0x0400		/* use "wwan%d" names */
+ 
+ /* from include/linux/mod_devicetable.h */
+ #define USB_DEVICE_ID_MATCH_INT_NUMBER		0x0400
+ 
+ /* from include/linux/device.h */
+ /**
+  * module_driver() - Helper macro for drivers that don't do anything
+  * special in module init/exit. This eliminates a lot of boilerplate.
+  * Each module may only use this macro once, and calling it replaces
+  * module_init() and module_exit().
+  *
+  * @__driver: driver name
+  * @__register: register function for this driver type
+  * @__unregister: unregister function for this driver type
+  * @...: Additional arguments to be passed to __register and __unregister.
+  *
+  * Use this macro to construct bus specific macros for registering
+  * drivers, and do not use it on its own.
+  */
+ #define module_driver(__driver, __register, __unregister, ...) \
+ static int __init __driver##_init(void) \
+ { \
+ 	return __register(&(__driver) , ##__VA_ARGS__); \
+ } \
+ module_init(__driver##_init); \
+ static void __exit __driver##_exit(void) \
+ { \
+ 	__unregister(&(__driver) , ##__VA_ARGS__); \
+ } \
+ module_exit(__driver##_exit);
+ 
+ /* from include/linux/usb.h */
+ /**
+  * USB_DEVICE_INTERFACE_NUMBER - describe a usb device with a specific interface number
+  * @vend: the 16 bit USB Vendor ID
+  * @prod: the 16 bit USB Product ID
+  * @num: bInterfaceNumber value
+  *
+  * This macro is used to create a struct usb_device_id that matches a
+  * specific interface number of devices.
+  */
+ #define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \
+ 	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+ 		       USB_DEVICE_ID_MATCH_INT_NUMBER, \
+ 	.idVendor = (vend), \
+ 	.idProduct = (prod), \
+ 	.bInterfaceNumber = (num)
+ 
+ /**
+  * USB_VENDOR_AND_INTERFACE_INFO - describe a specific usb vendor with a class of usb interfaces
+  * @vend: the 16 bit USB Vendor ID
+  * @cl: bInterfaceClass value
+  * @sc: bInterfaceSubClass value
+  * @pr: bInterfaceProtocol value
+  *
+  * This macro is used to create a struct usb_device_id that matches a
+  * specific vendor with a specific class of interfaces.
+  *
+  * This is especially useful when explicitly matching devices that have
+  * vendor specific bDeviceClass values, but standards-compliant interfaces.
+  */
+ #define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \
+ 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+ 		| USB_DEVICE_ID_MATCH_VENDOR, \
+ 	.idVendor = (vend), \
+ 	.bInterfaceClass = (cl), \
+ 	.bInterfaceSubClass = (sc), \
+ 	.bInterfaceProtocol = (pr)
+ 
+ /**
+  * module_usb_driver() - Helper macro for registering a USB driver
+  * @__usb_driver: usb_driver struct
+  *
+  * Helper macro for USB drivers which do not do anything special in module
+  * init/exit. This eliminates a lot of boilerplate. Each module may only
+  * use this macro once, and calling it replaces module_init() and module_exit()
+  */
+ #define module_usb_driver(__usb_driver) \
+ 	module_driver(__usb_driver, usb_register, \
+ 		       usb_deregister)
+ 
+ /* translate USB error codes to codes user space understands */
+ static inline int usb_translate_errors(int error_code)
+ {
+ 	switch (error_code) {
+ 	case 0:
+ 	case -ENOMEM:
+ 	case -ENODEV:
+ 	case -EOPNOTSUPP:
+ 		return error_code;
+ 	default:
+ 		return -EIO;
+ 	}
+ }
+ 
+ extern struct usb_driver *usb_cdc_wdm_register(struct usb_interface *intf,
+ 					struct usb_endpoint_descriptor *ep,
+ 					int bufsize,
+ 					int (*manage_power)(struct usb_interface *, int));
+ 
+ #endif /* __LINUX_USB_CDC_WDM_H */
diff -crNB --new-file ../llinux-2.6.32.42/include/linux/usb.h ./include/linux/usb.h
*** ../llinux-2.6.32.42/include/linux/usb.h	2015-06-08 14:32:37.039753557 -0700
--- ./include/linux/usb.h	2015-06-08 14:33:35.875755651 -0700
***************
*** 724,729 ****
--- 724,745 ----
  	.bInterfaceProtocol = (pr)
  
  /**
+  * USB_DEVICE_INTERFACE_NUMBER - describe a usb device with a specific interface number
+  * @vend: the 16 bit USB Vendor ID
+  * @prod: the 16 bit USB Product ID
+  * @num: bInterfaceNumber value
+  *
+  * This macro is used to create a struct usb_device_id that matches a
+  * specific interface number of devices.
+  */
+ #define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \
+ 	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+ 		       USB_DEVICE_ID_MATCH_INT_NUMBER, \
+ 	.idVendor = (vend), \
+ 	.idProduct = (prod), \
+ 	.bInterfaceNumber = (num)
+ 
+ /**
   * USB_DEVICE_INFO - macro used to describe a class of usb devices
   * @cl: bDeviceClass value
   * @sc: bDeviceSubClass value
diff -crNB --new-file ../llinux-2.6.32.42/scripts/mod/file2alias.c ./scripts/mod/file2alias.c
*** ../llinux-2.6.32.42/scripts/mod/file2alias.c	2015-06-08 14:32:18.135752885 -0700
--- ./scripts/mod/file2alias.c	2015-06-08 14:33:35.907755653 -0700
***************
*** 100,106 ****
  }
  
  /* USB is special because the bcdDevice can be matched against a numeric range */
! /* Looks like "usb:vNpNdNdcNdscNdpNicNiscNipN" */
  static void do_usb_entry(struct usb_device_id *id,
  			 unsigned int bcdDevice_initial, int bcdDevice_initial_digits,
  			 unsigned char range_lo, unsigned char range_hi,
--- 100,106 ----
  }
  
  /* USB is special because the bcdDevice can be matched against a numeric range */
! /* Looks like "usb:vNpNdNdcNdscNdpNicNiscNipNinN" */
  static void do_usb_entry(struct usb_device_id *id,
  			 unsigned int bcdDevice_initial, int bcdDevice_initial_digits,
  			 unsigned char range_lo, unsigned char range_hi,
***************
*** 141,146 ****
--- 141,149 ----
  	ADD(alias, "ip",
  	    id->match_flags&USB_DEVICE_ID_MATCH_INT_PROTOCOL,
  	    id->bInterfaceProtocol);
+ 	ADD(alias, "in",
+ 	    id->match_flags&USB_DEVICE_ID_MATCH_INT_NUMBER,
+ 	    id->bInterfaceNumber);
  
  	add_wildcard(alias);
  	buf_printf(&mod->dev_table_buf,
