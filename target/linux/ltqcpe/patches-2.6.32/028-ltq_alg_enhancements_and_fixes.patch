Index: linux/net/ipv4/netfilter/nf_nat_rtsp.c
===================================================================
--- linux.orig/net/ipv4/netfilter/nf_nat_rtsp.c	2010-12-02 18:55:00.000000000 +0530
+++ linux/net/ipv4/netfilter/nf_nat_rtsp.c	2010-12-07 16:07:31.274599336 +0530
@@ -45,6 +45,13 @@
 #define NF_NEED_MIME_NEXTLINE
 #include <linux/netfilter_mime.h>
 
+#undef IFX_RTSP_NAT_ALG 
+
+#ifdef IFX_RTSP_NAT_ALG
+#include <linux/netfilter_ipv4/listhelp.h>
+#include <linux/netfilter/ifx_alg.h>
+#endif
+
 #define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
 #if 0
 #define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
@@ -73,6 +80,57 @@
 
 #define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
 
+#ifdef IFX_RTSP_NAT_ALG
+
+#define BUF_LEN 80
+static int Device_Open = 0;
+static char Message[BUF_LEN];
+static char *Message_Ptr;
+
+struct list_head rtsp_registration_list;/* stores the registered port and protocols*/
+
+/* initialize the list */
+LIST_HEAD(rtsp_registration_list);
+
+int rtsp_device_ioctl(struct inode *,struct file *,unsigned int ,unsigned long);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static int rtsp_device_release(struct inode *,struct file *);
+#else
+static void rtsp_device_release(struct inode *,struct file *);
+#endif
+
+static int rtsp_device_open(struct inode *,struct file *);
+
+/* This structure will hold the functions to be called 
+ * when a process does something to the device we 
+ * created. Since a pointer to this structure is kept in 
+ * the devices table, it can't be local to
+ * init_module. NULL is for unimplemented functions. */
+struct file_operations rtsp_Fops = {
+llseek: NULL,   /* seek */
+read: NULL, 
+write: NULL,
+readdir: NULL,   /* readdir */
+poll: NULL,   /* select */
+ioctl: rtsp_device_ioctl,   /* ioctl */
+mmap: NULL,   /* mmap */
+open: rtsp_device_open,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+flush: NULL,  /* flush */
+#endif
+release: rtsp_device_release  /* a.k.a. close */
+};
+
+
+#endif
+
+
+
+
+
+
+
 /*** helper functions ***/
 
 static void
@@ -462,18 +520,73 @@
 
 static void __exit fini(void)
 {
+#ifndef IFX_RTSP_NAT_ALG
 	nf_nat_rtsp_hook = NULL;
         nf_nat_rtsp_hook_expectfn = NULL;
 	synchronize_net();
+
+#else
+
+	struct list_head  *cur_item;
+	struct list_head  *temp_item;
+	struct rtsp_registration_data* cur_registration;
+	int ret =0;
+
+	list_for_each_safe(cur_item, temp_item, &rtsp_registration_list)
+	{
+		cur_registration = list_entry(cur_item, struct rtsp_registration_data, list);
+
+		nf_nat_helper_unregister(cur_registration->helper);
+
+		kfree(cur_registration->helper->name );
+
+		kfree(cur_registration->helper);
+
+		list_del(&(cur_registration->list));
+		kfree(cur_registration);
+
+		MOD_DEC_USE_COUNT;
+
+
+	}
+
+	ret = unregister_chrdev(MAJOR_NUM_RTSP, DEVICE_FILE_NAME_RTSP);
+	/* If there's an error, report it */ 
+	if (ret < 0)
+		printk("Error in module_unregister_chrdev: %d\n", ret);
+
+#endif
+
 }
 
 static int __init init(void)
 {
 	printk("nf_nat_rtsp v" IP_NF_RTSP_VERSION " loading\n");
-
+#ifndef IFX_RTSP_NAT_ALG
 	BUG_ON(nf_nat_rtsp_hook);
 	nf_nat_rtsp_hook = help;
         nf_nat_rtsp_hook_expectfn = &expected;
+#else
+
+
+
+
+
+ NDEBUG("Registering Rtsp_device\n");
+	ret = register_chrdev(MAJOR_NUM_RTSP, DEVICE_FILE_NAME_RTSP, &rtsp_Fops);
+
+	/* Negative values signify an error */
+	if (ret < 0) 
+	{
+		printk (" %s failed with %d\n","Sorry, registering the character device ",ret);
+	}
+	else
+	{
+		printk(" SUCCESS %d MAJOR_NUM_RTSP ",MAJOR_NUM_RTSP);
+	}
+
+
+#endif
 
 	if (stunaddr != NULL)
 		extip = in_aton(stunaddr);
@@ -488,9 +601,288 @@
 		if (strcmp(destaction, "none") == 0)
 			dstact = DSTACT_NONE;
 	}
+	return 0; 
+}
+
+#ifdef IFX_RTSP_NAT_ALG
+
+static int rtsp_device_port_register(struct rtsp_params* rtspparam)
+{
+
+	int port = RTSP_PORT;
+	struct nf_nat_helper *hlpr;
+	struct rtsp_registration_data *rtsp_reg_data;
+	int ret = 0;
+	char * tmp_name;
+
+
+	hlpr = kmalloc(sizeof(struct nf_nat_helper), GFP_ATOMIC);
+	if (hlpr == NULL)
+	{	
+		NDEBUG("RTSP: Memory not available\n");
+		return -1;
+	}
+
+	rtsp_reg_data = kmalloc(sizeof(struct rtsp_registration_data), GFP_ATOMIC);
+	if(rtsp_reg_data == NULL)
+	{
+		NDEBUG("RTSP : hlpr rtsp_reg_data Memory not available\n");
+
+		return -1;
+	}
+
+	tmp_name = kmalloc(20, GFP_ATOMIC);
+	if(tmp_name == NULL)
+	{
+		NDEBUG("RTSP : tmp_name memeory not available \n");
+
+		return -1;
+	}
+
+
+	memset(hlpr, 0, sizeof(struct nf_nat_helper));
+	memset(rtsp_reg_data,0,sizeof(struct rtsp_registration_data));
+	memset(tmp_name,'\0',20);
+
+
+	NDEBUG("\n INIT_LIST_HEAD try init list rtsp_reg_data is %p",rtsp_reg_data);
+	/* Init list head of the rtsp_registration_data*/
+	INIT_LIST_HEAD(&(rtsp_reg_data->list));
+
+
+	port = rtspparam->rtsp_port;
+
+
+	hlpr->tuple.src.u.tcp.port = htons(port);
+	hlpr->tuple.dst.protonum = IPPROTO_TCP;
+	hlpr->mask.src.u.tcp.port = 0xFFFF;
+
+	hlpr->list.next =NULL;
+	hlpr->list.prev =NULL;
+
+	hlpr->mask.dst.protonum = 0xFFFF;
+	hlpr->help = help;
+	hlpr->flags = 0;
+	hlpr->me = THIS_MODULE;
+	//hlpr->expect = expected; //testing
+
+
+	if (port == RTSP_PORT)
+	{
+		sprintf(tmp_name , "rtsp");
+	}
+	else
+	{
+		sprintf(tmp_name , "rtsp-%d",port );
+	}
+
+	hlpr->name = tmp_name;
+
+
+	NDEBUG(" Trying to register helper register ....port #%d and name is %s \n", port,hlpr->name);
+
+	ret = nf_nat_helper_register(hlpr);
+
+	NDEBUG(" \n register helper register ...........return %d\n", ret);
+
+
+	if (ret < 0)
+	{
+		printk("ip_nat_helper_register: ERROR registering port %d\n", port);
+		fini();	
+
+		return -EBUSY;
+	}
+
+	MOD_INC_USE_COUNT;
+
+
+	rtsp_reg_data->helper = hlpr;
+	rtsp_reg_data->proto = rtspparam->ip_proto;
+	rtsp_reg_data->port = port;
+
+	list_prepend(&(rtsp_registration_list), &(rtsp_reg_data->list));
+
+
+	return 0;	   
+}
+
+static int  get_reg_data(const struct rtsp_registration_data* data, int port, enum AlgControlProtocol proto)
+{
+	if((data->port == port)&&(data->proto == proto))
+	{
+		return 1;
+	}
+	else
+	{
+
+		return 0;
+	}
+
+}
+
+
+static int rtsp_device_port_deregister(struct rtsp_params* rtspparam)
+{
+	struct rtsp_registration_data* rtsp_reg_data;
+
+	rtsp_reg_data = LIST_FIND(&rtsp_registration_list,
+			get_reg_data,
+			struct rtsp_registration_data *,
+			rtspparam->rtsp_port, 
+			rtspparam->ip_proto );
+
+	NDEBUG("\n rtsp_reg_data is %p\n",rtsp_reg_data);
+
+	if(rtsp_reg_data == NULL)
+	{
+		NDEBUG("RTSP: No registration for this port exists\n");
+		return -1;
+	}
+
+	nf_nat_helper_unregister(rtsp_reg_data->helper);
+	NDEBUG("RTSP: ip_nat_helper_unregister helper unregistered\n");
+
+	NDEBUG("Trying to free rtsp_reg_data->helper->name");
+	kfree(rtsp_reg_data->helper->name );
+
+	NDEBUG(" Trying to free nat helper");
+	kfree(rtsp_reg_data->helper);
+
+	NDEBUG("RTSP: Freeing up rtsp_registration_data->list\n");
+	list_del(&(rtsp_reg_data->list));
+
+	NDEBUG(" Trying to free rtsp_reg_data");
+	kfree(rtsp_reg_data);
+
+
+	MOD_DEC_USE_COUNT;
 
 	return 0;
 }
 
+/* This function is called whenever a process attempts 
+ * to open the device file */
+static int rtsp_device_open(struct inode *inode, 
+		struct file *file)
+{
+#ifdef DEBUG
+	printk ("device_open(%p)\n", file);
+#endif
+
+	/* We don't want to talk to two processes at the 
+	 * same time */
+	if (Device_Open)
+	{
+		return -EBUSY;
+	}
+
+	/* If this was a process, we would have had to be 
+	 * more careful here, because one process might have 
+	 * checked Device_Open right before the other one 
+	 * tried to increment it. However, we're in the 
+	 * kernel, so we're protected against context switches.
+	 *
+	 * This is NOT the right attitude to take, because we
+	 * might be running on an SMP box, but we'll deal with
+	 * SMP in a later chapter.
+	 */ 
+
+	Device_Open++;
+
+	/* Initialize the message */
+	Message_Ptr = Message;
+
+	//  MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+/* This function is called when a process closes the 
+ * device file. It doesn't have a return value because 
+ * it cannot fail. Regardless of what else happens, you 
+ * should always be able to close a device (in 2.0, a 2.2
+ * device file could be impossible to close).
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static int rtsp_device_release(struct inode *inode, 
+		struct file *file)
+#else
+static void rtsp_device_release(struct inode *inode, 
+		struct file *file)
+#endif
+{
+#ifdef DEBUG
+	printk ("device_release(%p,%p)\n", inode, file);
+#endif
+
+
+	/* We're now ready for our next caller */
+	Device_Open --;
+
+	//  MOD_DEC_USE_COUNT;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	return 0;
+#endif
+}
+
+
+
+int rtsp_device_ioctl(
+		struct inode *inode,
+		struct file *file,
+		unsigned int ioctl_num,/* The number of the ioctl */
+		unsigned long ioctl_param) /* The parameter to it */
+{
+	struct rtsp_params *rtspparam;
+	int ret = 0;
+	/* Switch according to the ioctl called */
+	switch (ioctl_num) {
+		//case IOCTL_SET_RTSP_MSG:
+		//	break;
+
+		case IOCTL_DEREGISTER_RTSP_PORT:
+			NDEBUG("\n IOCTL_DEREGISTER_RTSP_PORT is called...........\n");
+			rtspparam=(struct rtsp_params*)ioctl_param;
+			NDEBUG("rtspparam.rtsp_port %d,rtspparam.ip_proto %d",rtspparam->rtsp_port,rtspparam->ip_proto);
+
+			ret = rtsp_device_port_deregister(rtspparam);
+			if (ret < 0 )
+			{
+				printk("\n ERROR : rtsp_device_port_deregister is failed \n");
+				return -1;
+			}
+			break;
+			//case IOCTL_GET_NTH_BYTE:
+		case IOCTL_REGISTER_RTSP_PORT:
+			NDEBUG("Received IOCTL_REGISTER_PORT\n");
+			rtspparam = (struct rtsp_params*)ioctl_param;
+
+			NDEBUG("Sip Port: [%d]\n",rtspparam->rtsp_port);
+			if(rtspparam->ip_proto== IP_PROTO_TCP)
+				NDEBUG("Sip Proto: TCP\n");
+			else if(rtspparam->ip_proto== IP_PROTO_UDP)
+				NDEBUG("Sip Proto: UDP\n");
+			NDEBUG("rtspparam.rtsp_port %d,rtspparam.ip_proto %d",rtspparam->rtsp_port,rtspparam->ip_proto);
+
+			ret = rtsp_device_port_register(rtspparam);
+			if (ret < 0 )
+			{
+				printk("\n ERROR : rtsp_device_port_register is failed \n");
+				return -1;
+			}
+
+
+			break;
+	}
+
+	return 0;
+}
+
+#endif
+
+
 module_init(init);
 module_exit(fini);
Index: linux/net/netfilter/nf_conntrack_rtsp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_rtsp.c	2010-12-02 18:55:00.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_rtsp.c	2010-12-07 15:19:25.734600282 +0530
@@ -48,6 +48,23 @@
 #include <linux/netfilter_mime.h>
 
 #include <linux/ctype.h>
+#undef IFX_RTSP_NAT_ALG
+#undef IFX_TEST
+
+#ifdef IFX_RTSP_NAT_ALG
+//#include <linux/netfilter_ipv4/lockhelp.h>
+
+//DECLARE_RWLOCK_EXTERN(ip_rtsp_rwlock);
+//#define ASSERT_READ_LOCK MUST_BE_READ_LOCKED(&ip_rtsp_rwlock);
+//#define ASSERT_WRITE_LOCK MUST_BE_WRITE_LOCKED(&ip_rtsp_rwlock);
+
+ extern rwlock_t ip_rtsp_rwlock ;
+ #include <linux/netfilter_ipv4/listhelp.h>
+//#include "rtsp_conn_alg.h"
+#include <linux/netfilter/ifx_alg.h>
+
+#endif
+
 #define MAX_SIMUL_SETUP 8 /* XXX: use max_outstanding */
 #define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
 #if 0
@@ -57,10 +74,14 @@
 #endif
 
 #define MAX_PORTS 8
+#ifndef IFX_RTSP_NAT_ALG
+
 static int ports[MAX_PORTS];
 static int num_ports = 0;
+#endif
+
 static int max_outstanding = 8;
-static unsigned int setup_timeout = 300;
+static unsigned int setup_timeout =100; //300;
 
 MODULE_AUTHOR("Tom Marshall <tmarshall at real.com>");
 MODULE_DESCRIPTION("RTSP connection tracking module");
@@ -91,6 +112,54 @@
  */
 #define MAX_PORT_MAPS 16
 
+
+
+
+#ifdef IFX_RTSP_NAT_ALG
+
+static int rtsp_conn_device_open(struct inode *,struct file *);
+
+int rtsp_conn_device_ioctl(struct inode *,struct file *,unsigned int ,unsigned long); 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static int rtsp_conn_device_release(struct inode *,struct file *);
+#else
+static void rtsp_conn_device_release(struct inode *,struct file *);
+#endif
+
+static int rtsp_conn_device_port_deregister(struct rtsp_params *);
+
+static int rtsp_conn_device_port_register(struct rtsp_params *);
+
+
+struct file_operations rtsp_Fops_conn = {
+llseek: NULL,   /* seek */
+read: NULL, 
+write: NULL,
+readdir: NULL,   /* readdir */
+poll: NULL,   /* select */
+ioctl: rtsp_conn_device_ioctl,   /* ioctl */
+mmap: NULL,   /* mmap */
+open: rtsp_conn_device_open,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+flush: NULL,  /* flush */
+#endif
+release: rtsp_conn_device_release  /* a.k.a. close */
+};
+
+struct list_head rtsp_conn_registration_list;/* stores the registered port and protocols*/
+
+
+/* initialize the list */
+LIST_HEAD(rtsp_conn_registration_list);
+
+#define BUF_LEN 80
+static int Device_Open = 0;
+static char Message[BUF_LEN];
+static char *Message_Ptr;
+
+#endif
+
 /*** default port list was here in the masq code: 554, 3030, 4040 ***/
 
 #define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
@@ -441,21 +510,61 @@
 static void
 fini(void)
 {
+#ifndef IFX_RTSP_NAT_ALG
 	int i;
 	for (i = 0; i < num_ports; i++) {
 		DEBUGP("unregistering port %d\n", ports[i]);
 		nf_conntrack_helper_unregister(&rtsp_helpers[i]);
 	}
 	kfree(rtsp_buffer);
+
+#else
+
+	struct list_head  *cur_item;
+	struct list_head  *temp_item;
+	struct rtsp_conn_registration_data* cur_registration;
+	int ret =0;
+
+	list_for_each_safe(cur_item, temp_item, &rtsp_conn_registration_list)
+	{
+		cur_registration = list_entry(cur_item, struct rtsp_conn_registration_data, list);
+		NCDEBUG("cur_registration is %p",cur_registration);
+
+		nf_conntrack_helper_unregister(cur_registration->conntrack_helper);
+
+		kfree(cur_registration->conntrack_helper->name );
+
+		kfree(cur_registration->conntrack_helper);
+
+		list_del(&(cur_registration->list));
+		kfree(cur_registration);
+
+		MOD_DEC_USE_COUNT;
+
+
+	}
+
+	ret = unregister_chrdev(MAJOR_NUM_RTSP_CONN, DEVICE_FILE_NAME_RTSP_CONN);
+	/* If there's an error, report it */ 
+	if (ret < 0)
+		printk("Error in Connection track module_unregister_chrdev: %d\n", ret);
+
+#endif
 }
 
 static int __init
 init(void)
 {
 	int i, ret;
+
+
+
+#ifndef IFX_RTSP_NAT_ALG
+
 	struct nf_conntrack_helper *hlpr;
 	char *tmpname;
 
+#endif
 	printk("nf_conntrack_rtsp v" IP_NF_RTSP_VERSION " loading\n");
 
 	if (max_outstanding < 1) {
@@ -473,7 +582,7 @@
 	rtsp_buffer = kmalloc(65536, GFP_KERNEL);
 	if (!rtsp_buffer)
 		return -ENOMEM;
-
+#ifndef IFX_RTSP_NAT_ALG
 	/* If no port given, default to standard rtsp port */
 	if (ports[0] == 0) {
 		ports[0] = RTSP_PORT;
@@ -507,9 +616,305 @@
 		}
 		num_ports++;
 	}
+#else
+#warning IFX_RTSP_NAT_ALG
+
+	NCDEBUG("Registering Rtsp_connection_device\n");
+	ret = register_chrdev(MAJOR_NUM_RTSP_CONN, DEVICE_FILE_NAME_RTSP_CONN, &rtsp_Fops_conn);
+
+	/* Negative values signify an error */
+	if (ret < 0) 
+	{
+		printk (" Sorry, registering the character device fails ret is %d ",ret);
+		return -1;
+	}
+
+
+#endif
+	return 0;
+
+}
+
+#ifdef IFX_RTSP_NAT_ALG
+int rtsp_conn_device_ioctl(
+		struct inode *inode,
+		struct file *file,
+		unsigned int ioctl_num,/* The number of the ioctl */
+		unsigned long ioctl_param) /* The parameter to it */
+{
+	struct rtsp_params *rtspparam;
+	int ret = 0 ;
+	/* Switch according to the ioctl called */
+	switch (ioctl_num) {
+		//case IOCTL_SET_RTSP_MSG:
+
+		//	break;
+
+		case IOCTL_DEREGISTER_RTSP_PORT_CONN:
+
+			rtspparam=(struct rtsp_params*)ioctl_param;
+			NCDEBUG("rtspparam.rtsp_port %d,rtspparam.ip_proto %d",rtspparam->rtsp_port,rtspparam->ip_proto);
+			ret = rtsp_conn_device_port_deregister(rtspparam);
+			if (ret < 0 )
+			{
+				printk("\n ERROR : rtsp_conn_device_port_deregister is failed \n");
+				return -1;
+			}
+
+			break;
+		case IOCTL_REGISTER_RTSP_PORT_CONN:
+
+			NCDEBUG("Received IOCTL_REGISTER_PORT\n");
+			rtspparam = (struct rtsp_params*)ioctl_param;
+
+			NCDEBUG("RTSP conn Port: [%d]\n",rtspparam->rtsp_port);
+			if(rtspparam->ip_proto== IP_PROTO_TCP)
+				NCDEBUG("RTSP conn Proto: TCP\n");
+			else if(rtspparam->ip_proto== IP_PROTO_UDP)
+				NCDEBUG("RTSP conn Proto: UDP\n");
+			NCDEBUG("rtspparam.rtsp_port %d,rtspparam.ip_proto %d",rtspparam->rtsp_port,rtspparam->ip_proto);
+			ret = rtsp_conn_device_port_register(rtspparam);
+			if (ret < 0 )
+			{
+				printk("\n ERROR : rtsp_conn_device_port_register is failed \n");
+				return -1;
+			}
+
+			break;
+	}
+
+	return 0;
+}
+
+/* This function is called whenever a process attempts 
+ * to open the device file */
+static int rtsp_conn_device_open(struct inode *inode,struct file *file)
+{
+#ifdef DEBUG
+	printk ("device_open(%p)\n", file);
+#endif
+
+	/* We don't want to talk to two processes at the 
+	 * same time */
+	if (Device_Open)
+	{
+		return -EBUSY;
+	}
+
+	/* If this was a process, we would have had to be 
+	 * more careful here, because one process might have 
+	 * checked Device_Open right before the other one 
+	 * tried to increment it. However, we're in the 
+	 * kernel, so we're protected against context switches.
+	 *
+	 * This is NOT the right attitude to take, because we
+	 * might be running on an SMP box, but we'll deal with
+	 * SMP in a later chapter.
+	 */ 
+
+	Device_Open++;
+
+	/* Initialize the message */
+	Message_Ptr = Message;
+
+	return 0;
+}
+
+/* This function is called when a process closes the 
+ * device file. It doesn't have a return value because 
+ * it cannot fail. Regardless of what else happens, you 
+ * should always be able to close a device (in 2.0, a 2.2
+ * device file could be impossible to close).
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static int rtsp_conn_device_release(struct inode *inode, 
+		struct file *file)
+#else
+static void rtsp_conn_device_release(struct inode *inode, 
+		struct file *file)
+#endif
+{
+#ifdef DEBUG
+	printk ("device_release(%p,%p)\n", inode, file);
+#endif
+
+	/* We're now ready for our next caller */
+	Device_Open --;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	return 0;
+#endif
+}
+
+static int rtsp_conn_device_port_register(struct rtsp_params* rtspparam)
+{
+
+	int port = RTSP_PORT;
+
+	struct rtsp_conn_registration_data *rtsp_conn_reg_data;
+	int ret = 0;
+	char *tmp_name;
+
+	struct nf_conntrack_helper *rtsp_conntrack_hlpr;
+
+
+	rtsp_conn_reg_data = kmalloc(sizeof(struct rtsp_conn_registration_data), GFP_ATOMIC);
+	if(rtsp_conn_reg_data == NULL)
+	{
+		NCDEBUG("RTSP : hlpr rtsp_reg_data Memory not available\n");
+		return -1;
+	}
+
+	rtsp_conntrack_hlpr = kmalloc(sizeof(struct ip_conntrack_helper), GFP_ATOMIC);
+	if(rtsp_conntrack_hlpr == NULL)
+	{
+		NCDEBUG("RTSP : rtsp_conntrack_hlpr Memory not available\n");
+
+		return -1;
+	}
+
+	tmp_name = kmalloc(20, GFP_ATOMIC);
+	if(tmp_name == NULL)
+	{
+		NCDEBUG("RTSP : tmp_name memeory not available \n");
+
+		return -1;
+	}
+
+
+	memset(rtsp_conn_reg_data,0,sizeof(struct rtsp_conn_registration_data));
+
+	memset(rtsp_conntrack_hlpr,0,sizeof(struct ip_conntrack_helper));
+	memset(tmp_name,'\0',20);
+
+
+	NCDEBUG("\n INIT_LIST_HEAD try init list... rtsp_conn_reg_data %p",rtsp_conn_reg_data);
+	/* Init list head of the rtsp_registration_data*/
+	INIT_LIST_HEAD(&(rtsp_conn_reg_data->list));
+
+	port = rtspparam->rtsp_port;
+
+
+
+
+	rtsp_conntrack_hlpr->tuple.src.u.tcp.port = htons(port);
+	rtsp_conntrack_hlpr->tuple.dst.protonum = IPPROTO_TCP;
+	rtsp_conntrack_hlpr->mask.src.u.tcp.port = 0xFFFF;
+
+
+	rtsp_conntrack_hlpr->list.next =NULL;
+	rtsp_conntrack_hlpr->list.prev =NULL;
+
+	rtsp_conntrack_hlpr->mask.dst.protonum = 0xFFFF;
+	rtsp_conntrack_hlpr->max_expected = max_outstanding;
+	rtsp_conntrack_hlpr->timeout = setup_timeout;
+	rtsp_conntrack_hlpr->flags = IP_CT_HELPER_F_REUSE_EXPECT;
+	//      rtsp_conntrack_hlpr->me = ip_conntrack_rtsp;
+	rtsp_conntrack_hlpr->me = THIS_MODULE;
+	rtsp_conntrack_hlpr->help = help;
+
+
+	if (port == RTSP_PORT)
+	{
+		sprintf(tmp_name, "rtsp");
+	}
+	else
+	{
+		sprintf(tmp_name, "rtsp-%d", port);
+	}
+
+	rtsp_conntrack_hlpr->name = tmp_name;
+
+	NCDEBUG("port # %d and name is %s\n", port,rtsp_conntrack_hlpr->name);
+
+	NCDEBUG(" calling ip_conntrack_helper_register  and name is %s",rtsp_conntrack_hlpr->name);
+	ret = nf_conntrack_helper_register(rtsp_conntrack_hlpr);
+	NCDEBUG(" \n Connection register helper register ...........return %d\n", ret);
+
+	if (ret < 0)
+	{
+		printk("ip_conntrack_rtsp: rtsp_conntrack_hlpr ERROR registering port %d\n", port);
+		fini();
+		return -EBUSY;
+	}
+
+
+
+	MOD_INC_USE_COUNT;
+
+
+	rtsp_conn_reg_data->conntrack_helper = rtsp_conntrack_hlpr;
+	rtsp_conn_reg_data->proto = rtspparam->ip_proto;
+	rtsp_conn_reg_data->port = port;
+
+	NCDEBUG("RTSP: Adding rtsp info to the list\n");
+	list_prepend(&(rtsp_conn_registration_list), &(rtsp_conn_reg_data->list));
+
+
+	return 0;	   
+}
+
+static int  get_reg_data(const struct rtsp_conn_registration_data* data, int port, enum AlgControlProtocol proto)
+{
+	if((data->port == port)&&(data->proto == proto))
+	{
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+
+}
+
+
+static int rtsp_conn_device_port_deregister(struct rtsp_params* rtspparam)
+{
+	struct rtsp_conn_registration_data* rtsp_conn_reg_data;
+
+	rtsp_conn_reg_data = LIST_FIND(&rtsp_conn_registration_list,
+			get_reg_data,
+			struct rtsp_conn_registration_data *,
+			rtspparam->rtsp_port, 
+			rtspparam->ip_proto );
+
+	NCDEBUG("\n rtsp_reg_data is %p\n",rtsp_conn_reg_data);
+
+	if(rtsp_conn_reg_data == NULL)
+	{
+		NCDEBUG("RTSP: No registration for this port exists\n");
+		return -1;
+	}
+
+	ip_conntrack_helper_unregister(rtsp_conn_reg_data->conntrack_helper);
+	NCDEBUG("RTSP: Conntrack helper unregistered\n");
+
+	NCDEBUG("Trying to free rtsp_conntrack_hlpr->name ");
+	kfree(rtsp_conn_reg_data->conntrack_helper->name );
+
+	NCDEBUG(" Trying to free conntrack helper");
+	kfree(rtsp_conn_reg_data->conntrack_helper);
+
+	NCDEBUG("RTSP: Freeing up rtsp_registration_data->list\n");
+	list_del(&(rtsp_conn_reg_data->list));
+
+	NCDEBUG(" Trying to free rtsp_reg_data");
+	kfree(rtsp_conn_reg_data);
+
+	MOD_DEC_USE_COUNT;
+
+
 	return 0;
 }
 
+#endif
+
+
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+EXPORT_SYMBOL(ip_rtsp_lock);
+#endif
+
 module_init(init);
 module_exit(fini);
 
Index: linux/net/ipv4/netfilter/nf_nat_rtsp.c
===================================================================
--- linux.orig/net/ipv4/netfilter/nf_nat_rtsp.c	2010-12-07 18:14:47.000000000 +0530
+++ linux/net/ipv4/netfilter/nf_nat_rtsp.c	2010-12-08 11:34:15.055850117 +0530
@@ -215,6 +215,11 @@
         for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
         {
             t->dst.u.udp.port = htons(loport);
+#ifdef CONFIG_RTSP_ALG_FIX
+	    exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	    exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+	    exp->dir = !dir;
+#endif
             if (nf_ct_expect_related(exp) == 0)
             {
                 DEBUGP("using port %hu\n", loport);
@@ -231,6 +236,11 @@
         for (loport = prtspexp->loport; loport != 0; loport += 2) /* XXX: improper wrap? */
         {
             t->dst.u.udp.port = htons(loport);
+#ifdef CONFIG_RTSP_ALG_FIX
+	exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+	exp->dir = !dir;
+#endif
             if (nf_ct_expect_related(exp) == 0)
             {
                 hiport = loport + ~exp->mask.src.u.udp.port;
@@ -248,6 +258,11 @@
         for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
         {
             t->dst.u.udp.port = htons(loport);
+#ifdef CONFIG_RTSP_ALG_FIX
+	exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+	exp->dir = !dir;
+#endif
             if (nf_ct_expect_related(exp) == 0)
             {
                 DEBUGP("using port %hu (1 of 2)\n", loport);
@@ -257,6 +272,11 @@
         for (hiport = prtspexp->hiport; hiport != 0; hiport++) /* XXX: improper wrap? */
         {
             t->dst.u.udp.port = htons(hiport);
+#ifdef CONFIG_RTSP_ALG_FIX
+	exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+	exp->dir = !dir;
+#endif
             if (nf_ct_expect_related(exp) == 0)
             {
                 DEBUGP("using port %hu (2 of 2)\n", hiport);
@@ -495,6 +515,9 @@
 
 static void expected(struct nf_conn* ct, struct nf_conntrack_expect *exp)
 {
+#ifdef CONFIG_RTSP_ALG_FIX
+	nf_nat_follow_master(ct,exp);
+#else
     struct nf_nat_multi_range_compat mr;
     u_int32_t newdstip, newsrcip, newip;
 
@@ -515,6 +538,7 @@
     mr.range[0].min_ip = mr.range[0].max_ip = newip;
 
     nf_nat_setup_info(ct, &mr.range[0], IP_NAT_MANIP_DST);
+#endif
 }
 
 
Index: linux/net/netfilter/nf_conntrack_expect.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_expect.c	2010-04-02 04:29:14.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_expect.c	2010-12-08 11:09:27.975850155 +0530
@@ -330,6 +330,16 @@
 	NF_CT_STAT_INC(net, expect_create);
 }
 
+#ifdef CONFIG_RTSP_ALG_FIX
+/* wrapper to put expectation for RTCP port */
+void nf_ct_expect_insert_rtcp(struct nf_conntrack_expect *exp)
+{
+	  nf_ct_expect_insert(exp);
+	  nf_ct_expect_event_report(IPEXP_NEW, exp, 0, 0);
+}
+#endif
+
+
 /* Race with expectations being used means we could have none to find; OK. */
 static void evict_oldest_expect(struct nf_conn *master,
 				struct nf_conntrack_expect *new)
Index: linux/net/netfilter/nf_conntrack_rtsp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_rtsp.c	2010-12-07 18:15:38.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_rtsp.c	2010-12-08 11:36:08.894599083 +0530
@@ -103,6 +103,10 @@
 				 struct nf_conntrack_expect *exp);
 void (*nf_nat_rtsp_hook_expectfn)(struct nf_conn *ct, struct nf_conntrack_expect *exp);
 
+#ifdef CONFIG_RTSP_ALG_FIX
+extern void nf_ct_expect_insert_rtcp (struct nf_conntrack_expect *exp) ;
+#endif
+
 EXPORT_SYMBOL_GPL(nf_nat_rtsp_hook);
 
 /*
@@ -352,8 +356,14 @@
 	uint    dataoff = 0;
 	int ret = NF_ACCEPT;
 
+#ifdef CONFIG_RTSP_ALG_FIX
+	struct nf_conntrack_expect *exp, *exp1;
+	 struct nf_conn *ct1;
+	 u_int32_t   newip1;
+	  __be16   be_lortcpport;
+#else
 	struct nf_conntrack_expect *exp;
-
+#endif
 	__be16 be_loport;
 
 	memset(&expinfo, 0, sizeof(expinfo));
@@ -425,9 +435,41 @@
 			ret = nf_nat_rtsp_hook(skb, ctinfo, hdrsoff, hdrslen, &expinfo, exp);
 		else if (nf_ct_expect_related(exp) != 0) {
 			INFOP("nf_ct_expect_related failed\n");
+#ifndef CONFIG_RTSP_ALG_FIX
 			ret  = NF_DROP;
+#endif
+		}
+	
+#ifdef CONFIG_RTSP_ALG_FIX
+	/* RTCP expect */
+		exp1 = nf_ct_expect_alloc(ct);
+		if (!exp1) {
+			 ret = NF_DROP;
+			 goto out;
 		}
-		nf_ct_expect_put(exp);
+
+		be_lortcpport = htons(expinfo.loport + 1);
+		nf_ct_expect_init(exp1, NF_CT_EXPECT_CLASS_DEFAULT,
+			ct->tuplehash[!dir].tuple.src.l3num,
+			&ct->tuplehash[!dir].tuple.src.u3, &ct->tuplehash[!dir].tuple.dst.u3,
+			IPPROTO_UDP, NULL, &be_lortcpport);
+	
+		exp1->expectfn = expected;
+		exp1->flags = 0;
+		ct1 = exp->master;
+		newip1 = ct1->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+		exp1->tuple.dst.u3.ip = newip1;
+		exp1->dir = !dir;
+		expinfo.pbtype = pb_single;
+
+		if (nf_ct_expect_related(exp1) != 0) {
+			nf_ct_expect_insert_rtcp(exp1);
+		}
+#endif
+
+		nf_ct_expect_put(exp); 
+		/*FIX ME : Check nf_ct_expect_put(exp1) is required , impact on
+		 * memory and functionality*/
 		goto out;
 	}
 out:
Index: linux/net/netfilter/Kconfig
===================================================================
--- linux.orig/net/netfilter/Kconfig	2010-12-02 18:55:00.000000000 +0530
+++ linux/net/netfilter/Kconfig	2010-12-08 12:55:31.455850135 +0530
@@ -158,6 +158,14 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config FTP_ALG_FIX
+	tristate "LTQ Fixes in FTP ALG"
+	depends on NF_CONNTRACK_FTP && LTQ_ADDON
+	default y
+	help
+		This is a fix to assign the mask for the port in the expectation
+		structure
+
 config NF_CONNTRACK_H323
 	tristate "H.323 protocol support"
 	depends on NETFILTER_ADVANCED
@@ -230,6 +238,14 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config PPTP_ALG_FIX
+	tristate "LTQ fixes for PPTP ALG"
+	depends on LTQ_ADDON && NF_CONNTRACK_PPTP
+	default y
+	help
+		Fix to timeout (child) GRE connections if RST/FIN is recieved
+		for parent PPTP connection
+	
 config NF_CONNTRACK_SANE
 	tristate "SANE protocol support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -277,6 +293,13 @@
 		If you want to compile it as a module, say 'M' here and read
 		Documentation/modules.txt.  If unsure, say 'Y'.
 
+config RTSP_ALG_FIX
+	tristate "LTQ fixes for RTSP ALG"
+	depends on LTQ_ADDON && NF_CONNTRACK_RTSP
+	default y
+	help
+		Fix to support RTCP port expectation
+
 config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface'
 	select NETFILTER_NETLINK
Index: linux/net/netfilter/nf_conntrack_ftp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_ftp.c	2010-04-02 04:29:14.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_ftp.c	2010-12-08 12:46:15.354599734 +0530
@@ -435,6 +435,12 @@
 		goto out_update_nl;
 	}
 
+#if defined(CONFIG_IP_NF_MATCH_LTQATTACK) || defined(CONFIG_IP_NF_MATCH_LTQATTACK_MODULE)
+	if (search[dir][i].ftptype == NF_CT_FTP_PORT) {
+		DEBUGP("Found FTP port command with port %d\n", cmd.u.tcp.port);
+		ct_ftp_info->active_ftp_port =  cmd.u.tcp.port;
+	}
+#endif
 	pr_debug("conntrack_ftp: match `%.*s' (%u bytes at %u)\n",
 		 matchlen, fb_ptr + matchoff,
 		 matchlen, ntohl(th->seq) + matchoff);
@@ -483,6 +489,17 @@
 			  &ct->tuplehash[!dir].tuple.src.u3, daddr,
 			  IPPROTO_TCP, NULL, &cmd.u.tcp.port);
 
+#ifdef CONFIG_FTP_ALG_FIX
+exp->mask = (struct nf_conntrack_tuple)
+	    { .src = { .l3num = 0xFFFF,
+		       .u = { .tcp = { .port = 0 }},
+	   	     },
+	     .dst = { .protonum = 0xFF,
+		      .u = { .tcp = { .port = __constant_htons(0xFFFF) }},
+	             };
+	    };
+#endif
+
 	/* Now, NAT might want to mangle the packet, and register the
 	 * (possibly changed) expectation itself. */
 	nf_nat_ftp = rcu_dereference(nf_nat_ftp_hook);
Index: linux/net/netfilter/nf_conntrack_pptp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_pptp.c	2010-04-02 04:29:14.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_pptp.c	2010-12-08 12:52:04.284599919 +0530
@@ -527,6 +527,17 @@
 	nexthdr_off += tcph->doff * 4;
 	datalen = tcplen - tcph->doff * 4;
 
+#ifdef CONFIG_PPTP_ALG_FIX
+	if (tcph->fin || tcph->rst) {
+		DEBUGP("RST/FIN received, timeouting GRE\n");
+		/* can't do this after real newnat */
+		info->cstate = PPTP_CALL_NONE;
+		/* untrack this call id, unexpect GRE packets */
+		pptp_destroy_siblings(ct);
+	}
+#endif
+
+
 	pptph = skb_header_pointer(skb, nexthdr_off, sizeof(_pptph), &_pptph);
 	if (!pptph) {
 		pr_debug("no full PPTP header, can't track\n");
Index: linux/include/linux/netfilter/nf_conntrack_mms.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/linux/netfilter/nf_conntrack_mms.h	2010-12-08 15:49:29.194599938 +0530
@@ -0,0 +1,36 @@
+#ifndef _IP_CONNTRACK_MMS_H
+#define _IP_CONNTRACK_MMS_H
+/* MMS tracking. */
+
+#ifdef __KERNEL__
+
+extern spinlock_t ip_mms_lock;
+
+#define MMS_PORT                         1755
+#define MMS_SRV_MSG_ID                   196610
+
+#define MMS_SRV_MSG_OFFSET               36
+#define MMS_SRV_UNICODE_STRING_OFFSET    60
+#define MMS_SRV_CHUNKLENLV_OFFSET        16
+#define MMS_SRV_CHUNKLENLM_OFFSET        32
+#define MMS_SRV_MESSAGELENGTH_OFFSET     8
+
+/* This structure is per expected connection */
+struct nf_ct_mms_expect {
+	u_int32_t offset;
+	u_int32_t len;
+	u_int32_t padding;
+	u_int16_t port;
+};
+
+/* This structure exists only once per master */
+struct nf_ct_mms_master {
+};
+
+struct nf_conntrack_expect;
+extern unsigned int (*nf_nat_mms_hook)(struct sk_buff *skb,
+				       enum ip_conntrack_info ctinfo,
+				       const struct nf_ct_mms_expect *exp_mms_info,
+				       struct nf_conntrack_expect *exp);
+#endif
+#endif /* _IP_CONNTRACK_MMS_H */
Index: linux/net/ipv4/netfilter/Kconfig
===================================================================
--- linux.orig/net/ipv4/netfilter/Kconfig	2010-12-02 18:55:00.000000000 +0530
+++ linux/net/ipv4/netfilter/Kconfig	2010-12-08 16:12:45.005849392 +0530
@@ -262,6 +262,16 @@
  	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
  	default NF_NAT && NF_CONNTRACK_RTSP
 
+config NF_NAT_MMS
+	tristate
+	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT && LTQ_ADDON
+	default NF_NAT && NF_CONNTRACK_MMS
+
+config NF_NAT_TALK
+	tristate
+	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT && LTQ_ADDON
+	default NF_NAT && NF_CONNTRACK_TALK
+
 config NF_NAT_TFTP
 	tristate
 	depends on NF_CONNTRACK && NF_NAT
Index: linux/net/ipv4/netfilter/Makefile
===================================================================
--- linux.orig/net/ipv4/netfilter/Makefile	2010-12-02 18:55:00.000000000 +0530
+++ linux/net/ipv4/netfilter/Makefile	2010-12-08 16:12:36.375850146 +0530
@@ -31,6 +31,8 @@
 obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
 obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
 obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
+obj-$(CONFIG_NF_NAT_MMS) += nf_nat_mms.o
+obj-$(CONFIG_NF_NAT_TALK) += nf_nat_talk.o
 
 # NAT protocols (nf_nat)
 obj-$(CONFIG_NF_NAT_PROTO_DCCP) += nf_nat_proto_dccp.o
Index: linux/net/ipv4/netfilter/nf_nat_mms.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/net/ipv4/netfilter/nf_nat_mms.c	2010-12-08 15:54:23.434599906 +0530
@@ -0,0 +1,218 @@
+/* MMS extension for TCP NAT alteration.
+ * (C) 2002 by Filip Sneppe <filip.sneppe@cronos.be>
+ * based on ip_nat_ftp.c and ip_nat_irc.c
+ *
+ * ip_nat_mms.c v0.3 2002-09-22
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *      Module load syntax:
+ *      insmod ip_nat_mms.o ports=port1,port2,...port<MAX_PORTS>
+ *
+ *      Please give the ports of all MMS servers You wish to connect to.
+ *      If you don't specify ports, the default will be TCP port 1755.
+ *
+ *      More info on MMS protocol, firewalls and NAT:
+ *      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwmt/html/MMSFirewall.asp
+ *      http://www.microsoft.com/windows/windowsmedia/serve/firewall.asp
+ *
+ *      The SDP project people are reverse-engineering MMS:
+ *      http://get.to/sdp
+ *
+ *  2005-02-13: Harald Welte <laforge@netfilter.org>
+ *  	- port to 2.6.x
+ *  	- update to work with post 2.6.11 helper API changes
+
+ */
+
+/* FIXME: issue with UDP & fragmentation with this URL:
+   http://www.cnn.com/video/world/2002/01/21/jb.shoe.bomb.cafe.cnn.low.asx
+   may be related to out-of-order first packets:
+   basically the expectation is set up correctly, then the server sends
+   a first UDP packet which is fragmented plus arrives out-of-order.
+   the MASQUERADING firewall with ip_nat_mms loaded responds with
+   an ICMP unreachable back to the server */
+
+#include <linux/module.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <net/tcp.h>
+#include <net/netfilter/nf_nat.h>
+#include <net/netfilter/nf_nat_helper.h>
+#include <net/netfilter/nf_nat_rule.h>
+#include <linux/netfilter/nf_conntrack_mms.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+
+#if 0
+#define DEBUGP printk
+#define DUMP_BYTES(address, counter)                                \
+({                                                                  \
+	int temp_counter;                                           \
+	for(temp_counter=0; temp_counter<counter; ++temp_counter) { \
+		DEBUGP("%u ", (u8)*(address+temp_counter));         \
+	};                                                          \
+	DEBUGP("\n");                                               \
+})
+#else
+#define DEBUGP(format, args...)
+#define DUMP_BYTES(address, counter)
+#endif
+
+MODULE_AUTHOR("Filip Sneppe <filip.sneppe@cronos.be>");
+MODULE_DESCRIPTION("Microsoft Windows Media Services (MMS) NAT module");
+MODULE_LICENSE("GPL");
+
+static unsigned int mms_data_fixup(struct sk_buff *skb,
+                          enum ip_conntrack_info ctinfo,
+			  const struct nf_ct_mms_expect *ct_mms_info,
+                          struct nf_conntrack_expect *expect)
+{
+	u_int32_t newip;
+	struct nf_conn *ct = expect->master;
+	struct iphdr *iph = skb->nh.iph;
+	struct tcphdr *tcph = (void *) iph + iph->ihl * 4;
+	char *data = (char *)tcph + tcph->doff * 4;
+	int i, j, k, port;
+	u_int16_t mms_proto;
+
+	u_int32_t *mms_chunkLenLV    = (u_int32_t *)(data + MMS_SRV_CHUNKLENLV_OFFSET);
+	u_int32_t *mms_chunkLenLM    = (u_int32_t *)(data + MMS_SRV_CHUNKLENLM_OFFSET);
+	u_int32_t *mms_messageLength = (u_int32_t *)(data + MMS_SRV_MESSAGELENGTH_OFFSET);
+
+	int zero_padding;
+
+	char buffer[28];         /* "\\255.255.255.255\UDP\65635" * 2
+				    (for unicode) */
+	char unicode_buffer[75]; /* 27*2 (unicode) + 20 + 1 */
+	char proto_string[6];
+
+	/* what was the protocol again ? */
+	mms_proto = expect->tuple.dst.protonum;
+	sprintf(proto_string, "%u", mms_proto);
+
+	//DEBUGP("ip_nat_mms: mms_data_fixup: info (seq %u + %u) "
+	  //     "in %u, proto %s\n",
+	    //   expect->seq, ct_mms_info->len, ntohl(tcph->seq),
+	      // mms_proto == IPPROTO_UDP ? "UDP"
+	      // : mms_proto == IPPROTO_TCP ? "TCP":proto_string);
+
+	newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+	expect->saved_proto.tcp.port = expect->tuple.dst.u.tcp.port;
+	expect->expectfn = nf_nat_follow_master;
+
+	/* Alter conntrack's expectations. */
+	for (port = ct_mms_info->port; port != 0; port++) {
+		expect->tuple.dst.u.tcp.port = htons(port);
+		if (nf_ct_expect_related(expect) == 0) {
+			DEBUGP("ip_nat_mms: mms_data_fixup: using port %d\n",
+				port);
+			break;
+		}
+	}
+
+	if (port == 0)
+		return NF_DROP;
+
+	sprintf(buffer, "\\\\%u.%u.%u.%u\\%s\\%u",
+	        NIPQUAD(newip),
+		expect->tuple.dst.protonum == IPPROTO_UDP ? "UDP"
+		: expect->tuple.dst.protonum == IPPROTO_TCP ? "TCP":proto_string,
+		port);
+	DEBUGP("ip_nat_mms: new unicode string=%s\n", buffer);
+
+	memset(unicode_buffer, 0, sizeof(char)*75);
+
+	for (i=0; i<strlen(buffer); ++i)
+		*(unicode_buffer+i*2)=*(buffer+i);
+
+	DEBUGP("ip_nat_mms: mms_data_fixup: padding: %u len: %u\n",
+		ct_mms_info->padding, ct_mms_info->len);
+	DEBUGP("ip_nat_mms: mms_data_fixup: offset: %u\n",
+		MMS_SRV_UNICODE_STRING_OFFSET+ct_mms_info->len);
+	DUMP_BYTES(data+MMS_SRV_UNICODE_STRING_OFFSET, 60);
+
+	/* add end of packet to it */
+	for (j=0; j<ct_mms_info->padding; ++j) {
+		DEBUGP("ip_nat_mms: mms_data_fixup: i=%u j=%u byte=%u\n",
+		       i, j, (u8)*(data+MMS_SRV_UNICODE_STRING_OFFSET+ct_mms_info->len+j));
+		*(unicode_buffer+i*2+j) = *(data+MMS_SRV_UNICODE_STRING_OFFSET+ct_mms_info->len+j);
+	}
+
+	/* pad with zeroes at the end ? see explanation of weird math below */
+	zero_padding = (8-(strlen(buffer)*2 + ct_mms_info->padding + 4)%8)%8;
+	for (k=0; k<zero_padding; ++k)
+		*(unicode_buffer+i*2+j+k)= (char)0;
+
+	DEBUGP("ip_nat_mms: mms_data_fixup: zero_padding = %u\n", zero_padding);
+	//DEBUGP("ip_nat_mms: original=> chunkLenLV=%u chunkLenLM=%u "
+	  //     "messageLength=%u\n", *mms_chunkLenLV, *mms_chunkLenLM,
+	    //   *mms_messageLength);
+
+	 // 20040516 IFX TC Chen, add le32_to_cpu code for big enddien platform
+#ifdef CONFIG_CPU_BIG_ENDIAN
+DEBUGP("ip_nat_mms: original=> chunkLenLV=%u chunkLenLM=%u messageLength=%u\n",
+           le32_to_cpu(*mms_chunkLenLV), le32_to_cpu(*mms_chunkLenLM), le32_to_cpu(*mms_messageLength));
+#else
+DEBUGP("ip_nat_mms: original=> chunkLenLV=%u chunkLenLM=%u "
+      "messageLength=%u\n", *mms_chunkLenLV, *mms_chunkLenLM,
+      *mms_messageLength);
+						  
+#endif
+
+	/* explanation, before I forget what I did:
+	   strlen(buffer)*2 + ct_mms_info->padding + 4 must be divisable by 8;
+	   divide by 8 and add 3 to compute the mms_chunkLenLM field,
+	   but note that things may have to be padded with zeroes to align by 8
+	   bytes, hence we add 7 and divide by 8 to get the correct length */
+
+        // 20040516 IFX TC Chen, add le32_to_cpu code for big enddien platform
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	*mms_chunkLenLM    = cpu_to_le32((u_int32_t) (3+(strlen(buffer)*2+ct_mms_info->padding+11)/8));
+	*mms_chunkLenLV    = cpu_to_le32(le32_to_cpu(*mms_chunkLenLM)+2);
+	*mms_messageLength = cpu_to_le32(le32_to_cpu(*mms_chunkLenLV)*8);
+#else
+	*mms_chunkLenLM    = (u_int32_t) (3+(strlen(buffer)*2+ct_mms_info->padding+11)/8);
+    *mms_chunkLenLV    = *mms_chunkLenLM+2;
+    *mms_messageLength = *mms_chunkLenLV*8;
+					
+
+#endif
+
+	DEBUGP("ip_nat_mms: modified=> chunkLenLV=%u chunkLenLM=%u"
+	       " messageLength=%u\n", *mms_chunkLenLV, *mms_chunkLenLM,
+	       *mms_messageLength);
+
+	nf_nat_mangle_tcp_packet(skb, ct, ctinfo,
+	                         ct_mms_info->offset,
+	                         ct_mms_info->len + ct_mms_info->padding,
+				 unicode_buffer, strlen(buffer)*2 +
+				 ct_mms_info->padding + zero_padding);
+	DUMP_BYTES(unicode_buffer, 60);
+
+	return NF_ACCEPT;
+}
+
+static void __exit fini(void)
+{
+	//nf_nat_mms_hook = NULL;
+
+	 rcu_assign_pointer(nf_nat_mms_hook,NULL);
+	synchronize_net();
+}
+
+static int __init init(void)
+{
+	BUG_ON(rcu_dereference(nf_nat_mms_hook));
+
+       rcu_assign_pointer(nf_nat_mms_hook,mms_data_fixup);
+
+	return 0;
+}
+
+module_init(init);
+module_exit(fini);
Index: linux/net/netfilter/Kconfig
===================================================================
--- linux.orig/net/netfilter/Kconfig	2010-12-08 12:55:31.000000000 +0530
+++ linux/net/netfilter/Kconfig	2010-12-08 16:14:33.234599916 +0530
@@ -300,6 +300,29 @@
 	help
 		Fix to support RTCP port expectation
 
+config NF_CONNTRACK_MMS
+	tristate "MMS protocol support (EXPERIMENTAL) "
+	depends on NETFILTER_ADVANCED && LTQ_ADDON
+	help
+		This option supports MMS protocol connection tracking and NAT .
+		Microsoft Media Server (MMS) protocol is used to transfer
+		unicast data. MMS can be transported via UDP or TCP. If the
+		Windows Media Player client cannot negotiate a reliable
+		connection with MMS over UDP,it will attempt connection over
+		TCP. The MMS default port is UDP/TCP 1755.
+
+		To compile it as a module, choose M here.  If unsure, say N.
+
+config NF_CONNTRACK_TALK
+	 tristate "TALK protocol support (EXPERIMENTAL) "
+	 depends on NETFILTER_ADVANCED && LTQ_ADDON
+	 help
+	 	This option supports TALK protocol connection tracking and NAT.
+		Talk was a program originally used for live text communication
+		between different users of a single multi-user computer .
+
+	        To compile it as a module, choose M here.  If unsure, say N.
+
 config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface'
 	select NETFILTER_NETLINK
Index: linux/net/netfilter/Makefile
===================================================================
--- linux.orig/net/netfilter/Makefile	2010-12-02 18:55:00.000000000 +0530
+++ linux/net/netfilter/Makefile	2010-12-08 16:15:01.665850316 +0530
@@ -34,6 +34,8 @@
 obj-$(CONFIG_NF_CONNTRACK_SIP) += nf_conntrack_sip.o
 obj-$(CONFIG_NF_CONNTRACK_TFTP) += nf_conntrack_tftp.o
 obj-$(CONFIG_NF_CONNTRACK_RTSP) += nf_conntrack_rtsp.o
+obj-$(CONFIG_NF_CONNTRACK_MMS) += nf_conntrack_mms.o
+obj-$(CONFIG_NF_CONNTRACK_TALK) += nf_conntrack_talk.o
 
 # transparent proxy support
 obj-$(CONFIG_NETFILTER_TPROXY) += nf_tproxy_core.o
Index: linux/net/netfilter/nf_conntrack_mms.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/net/netfilter/nf_conntrack_mms.c	2010-12-08 15:55:48.024600042 +0530
@@ -0,0 +1,401 @@
+/* MMS extension for IP connection tracking
+ * (C) 2002 by Filip Sneppe <filip.sneppe@cronos.be>
+ * based on ip_conntrack_ftp.c and ip_conntrack_irc.c
+ *
+ * ip_conntrack_mms.c v0.3 2002-09-22
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *      Module load syntax:
+ *      insmod ip_conntrack_mms.o ports=port1,port2,...port<MAX_PORTS>
+ *
+ *      Please give the ports of all MMS servers You wish to connect to.
+ *      If you don't specify ports, the default will be TCP port 1755.
+ *
+ *      More info on MMS protocol, firewalls and NAT:
+ *      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwmt/html/MMSFirewall.asp
+ *      http://www.microsoft.com/windows/windowsmedia/serve/firewall.asp
+ *
+ *      The SDP project people are reverse-engineering MMS:
+ *      http://get.to/sdp
+ *
+ *  2005-02-13: Harald Welte <laforge@netfilter.org>
+ *  	- port to 2.6.x
+ *  	- update to work with post 2.6.11 helper API changes
+ *  2010-12-08: LTQ changes
+ *  	- port to 2.6.32
+ *  	- reference to (*pskb)->nh.iph->ihl*4 has changed to protoff
+ */
+
+//#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/ip.h>
+#include <linux/ctype.h>
+#include <net/checksum.h>
+#include <net/tcp.h>
+
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <linux/netfilter/nf_conntrack_mms.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+
+#define MAX_PORTS 8
+static int ports[MAX_PORTS];
+static int ports_c;
+module_param_array(ports, int, &ports_c, 0400);
+MODULE_PARM_DESC(ports, "port numbers of MMS");
+
+static char mms_buffer[65536];
+static DEFINE_SPINLOCK(mms_buffer_lock);
+
+unsigned int (*nf_nat_mms_hook)(struct sk_buff *skb,
+				enum ip_conntrack_info ctinfo,
+				const struct nf_ct_mms_expect *exp_mms_info,
+				struct nf_conntrack_expect *exp);
+EXPORT_SYMBOL(nf_nat_mms_hook);
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(format, args...)
+#endif
+
+MODULE_AUTHOR("Filip Sneppe <filip.sneppe@cronos.be>");
+MODULE_DESCRIPTION("Microsoft Windows Media Services (MMS) connection tracking module");
+MODULE_LICENSE("GPL");
+
+/* #define isdigit(c) (c >= '0' && c <= '9') */
+
+/* copied from drivers/usb/serial/io_edgeport.c - not perfect but will do the trick */
+static void unicode_to_ascii (char *string, short *unicode, int unicode_size)
+{
+	int i;
+	for (i = 0; i < unicode_size; ++i) {
+                 
+	 // 20040516 IFX TC Chen, add le16_to_cpu code for big enddien platform
+
+		#ifdef CONFIG_CPU_BIG_ENDIAN
+         	string[i] = (char)(le16_to_cpu(unicode[i])); // added for big endian
+        #else 
+		   string[i] = (char)(unicode[i]);
+		#endif
+
+	}
+	string[unicode_size] = 0x00;
+}
+
+__inline static int atoi(char *s)
+{
+	int i=0;
+	while (isdigit(*s)) {
+		i = i*10 + *(s++) - '0';
+	}
+	return i;
+}
+
+/* convert ip address string like "192.168.0.10" to unsigned int */
+__inline static u_int32_t asciiiptoi(char *s)
+{
+	unsigned int i, j, k;
+
+	for(i=k=0; k<3; ++k, ++s, i<<=8) {
+		i+=atoi(s);
+		for(j=0; (*(++s) != '.') && (j<3); ++j)
+			;
+	}
+	i+=atoi(s);
+	return ntohl(i);
+}
+
+int parse_mms(const char *data,
+	      const unsigned int datalen,
+	      u_int32_t *mms_ip,
+	      u_int16_t *mms_proto,
+	      u_int16_t *mms_port,
+	      char **mms_string_b,
+	      char **mms_string_e,
+	      char **mms_padding_e)
+{
+	int unicode_size, i;
+	char tempstring[28];       /* "\\255.255.255.255\UDP\65535" */
+	char getlengthstring[28];
+
+	for(unicode_size=0;
+	    (char) *(data+(MMS_SRV_UNICODE_STRING_OFFSET+unicode_size*2)) != (char)0;
+	    unicode_size++)
+		if ((unicode_size == 28) || (MMS_SRV_UNICODE_STRING_OFFSET+unicode_size*2 >= datalen))
+			return -1; /* out of bounds - incomplete packet */
+
+	unicode_to_ascii(tempstring, (short *)(data+MMS_SRV_UNICODE_STRING_OFFSET), unicode_size);
+	DEBUGP("nf_conntrack_mms: offset 60: %s\n", (const char *)(tempstring));
+
+	/* IP address ? */
+	*mms_ip = asciiiptoi(tempstring+2);
+
+	i=sprintf(getlengthstring, "%u.%u.%u.%u", HIPQUAD(*mms_ip));
+
+	/* protocol ? */
+	if(strncmp(tempstring+3+i, "TCP", 3)==0)
+		*mms_proto = IPPROTO_TCP;
+	else if(strncmp(tempstring+3+i, "UDP", 3)==0)
+		*mms_proto = IPPROTO_UDP;
+
+	/* port ? */
+	*mms_port = atoi(tempstring+7+i);
+
+	/* we store a pointer to the beginning of the "\\a.b.c.d\proto\port"
+	   unicode string, one to the end of the string, and one to the end
+	   of the packet, since we must keep track of the number of bytes
+	   between end of the unicode string and the end of packet (padding) */
+	*mms_string_b  = (char *)(data + MMS_SRV_UNICODE_STRING_OFFSET);
+	*mms_string_e  = (char *)(data + MMS_SRV_UNICODE_STRING_OFFSET + unicode_size * 2);
+	*mms_padding_e = (char *)(data + datalen); /* looks funny, doesn't it */
+	return 0;
+}
+
+
+/* FIXME: This should be in userspace.  Later. */
+static int help(struct sk_buff *skb, unsigned int protoff,
+		struct nf_conn *ct,
+		enum ip_conntrack_info ctinfo)
+{
+	int ret = NF_DROP;
+	struct tcphdr _tcph, *th;
+	char *data, *mb_ptr;
+	unsigned int datalen, dataoff;
+        typeof(nf_nat_mms_hook) mms_data_fixup; 
+
+	//struct tcphdr *tcph = (void *)iph + iph->ihl * 4;
+	//unsigned int tcplen = len - iph->ihl * 4;
+	//unsigned int datalen = tcplen - tcph->doff * 4;
+	int dir = CTINFO2DIR(ctinfo);
+	struct nf_conntrack_expect *exp;
+	struct nf_ct_mms_expect _emmi, *exp_mms_info = &_emmi;
+	struct nf_conntrack_man cmd = {};
+	u_int32_t mms_ip;
+	u_int16_t mms_proto;
+	char mms_proto_string[8];
+	u_int16_t mms_port;
+	char *mms_string_b, *mms_string_e, *mms_padding_e;
+
+	/* Until there's been traffic both ways, don't look in packets. */
+	if (ctinfo != IP_CT_ESTABLISHED
+	    && ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY) {
+		DEBUGP("ip_conntrack_mms: Conntrackinfo = %u\n", ctinfo);
+		return NF_ACCEPT;
+	}
+
+	/* Not whole TCP header? */
+	th = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);
+	if (!th)
+		return NF_ACCEPT;
+
+	/* No data ? */
+	/*reference to (*pskb)->nh.iph->ihl*4 has changed to protoff */
+	dataoff = protoff  + th->doff*4;
+	datalen = skb->len - dataoff;
+	if (dataoff >= skb->len)
+		return NF_ACCEPT;
+
+	spin_lock_bh(&mms_buffer_lock);
+	mb_ptr = skb_header_pointer(skb, dataoff,
+				    skb->len - dataoff, mms_buffer);
+	BUG_ON(mb_ptr == NULL);
+
+	data = mb_ptr;
+
+#if 0
+	/* Checksum invalid?  Ignore. */
+	/* FIXME: Source route IP option packets --RR */
+	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
+	    csum_partial((char *)tcph, tcplen, 0))) {
+		DEBUGP("mms_help: bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
+		       tcph, tcplen, NIPQUAD(iph->saddr),
+		       NIPQUAD(iph->daddr));
+		return NF_ACCEPT;
+	}
+#endif
+
+	/* Only look at packets with 0x00030002/196610 on bytes 36->39 of TCP
+	 * payload */
+
+	/* FIXME: There is an issue with only looking at this packet: before
+	 * this packet, the client has already sent a packet to the server with
+	 * the server's hostname according to the client (think of it as the
+	 * "Host: " header in HTTP/1.1). The server will break the connection
+	 * if this doesn't correspond to its own host header. The client can
+	 * also connect to an IP address; if it's the server's IP address, it
+	 * will not break the connection. When doing DNAT on a connection where
+	 * the client uses a server's IP address, the nat module should detect
+	 * this and change this string accordingly to the DNATed address. This
+	 * should probably be done by checking for an IP address, then storing
+	 * it as a member of struct ip_ct_mms_expect and checking for it in
+	 * ip_nat_mms...
+	 */
+	
+	// 20040516 IFX TC Chen, add le32_to_cpu code for big enddien platform
+
+	#ifdef CONFIG_CPU_BIG_ENDIAN
+	if ((MMS_SRV_MSG_OFFSET >= datalen) ||
+		(le32_to_cpu(*(u32 *)(data+MMS_SRV_MSG_OFFSET)) != MMS_SRV_MSG_ID)) 
+		goto out;
+    #else
+     if ((MMS_SRV_MSG_OFFSET >= datalen) ||
+        ((*(u32 *)(data+MMS_SRV_MSG_OFFSET)) != MMS_SRV_MSG_ID))
+         goto out;
+						 
+	#endif
+	DEBUGP("nf_conntrack_mms: offset 37: %u %u %u %u, datalen:%u\n",
+		   (u8)*(data+36), (u8)*(data+37), (u8)*(data+38), (u8)*(data+39),
+		   datalen);
+	if (parse_mms(data, datalen, &mms_ip, &mms_proto, &mms_port,
+				  &mms_string_b, &mms_string_e, &mms_padding_e))
+		if (net_ratelimit())
+			/* FIXME: more verbose debugging ? */
+			printk(KERN_WARNING
+				   "ip_conntrack_mms: Unable to parse "
+				   "data payload\n");
+
+	sprintf(mms_proto_string, "(%u)", mms_proto);
+	DEBUGP("nf_conntrack_mms: adding %s expectation "
+		   "%u.%u.%u.%u -> %u.%u.%u.%u:%u\n",
+		   mms_proto == IPPROTO_TCP ? "TCP"
+		   : mms_proto == IPPROTO_UDP ? "UDP":mms_proto_string,
+		   NIPQUAD(ct->tuplehash[!dir].tuple.src.ip),
+		   NIPQUAD(mms_ip),
+		   mms_port);
+
+	/* it's possible that the client will just ask the server to
+	 * tunnel the stream over the same TCP session (from port
+	 * 1755): there's shouldn't be a need to add an expectation in
+	 * that case, but it makes NAT packet mangling so much easier
+	 * */
+
+	//DEBUGP("ip_conntrack_mms: tcph->seq = %u\n", tcph->seq);
+
+	cmd.l3num = nf_ct_l3num(ct);
+	memcpy(cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,
+			sizeof(cmd.u3.all));
+
+	if ((exp = nf_ct_expect_alloc(ct)) == NULL) {
+		ret = NF_DROP;
+		goto out;
+	}
+
+	exp_mms_info->offset  = (mms_string_b - data);
+	exp_mms_info->len     = (mms_string_e  - mms_string_b);
+	exp_mms_info->padding = (mms_padding_e - mms_string_e);
+	exp_mms_info->port    = mms_port;
+
+	DEBUGP("nf_conntrack_mms: wrote info  (ofs=%u), "
+		   "len=%d, padding=%u\n",  (mms_string_e - data),
+		   exp_mms_info->len, exp_mms_info->padding);
+
+	/*exp->tuple = ((struct ip_conntrack_tuple)
+		{ { ct->tuplehash[!dir].tuple.src.ip, { 0 } },
+		  { mms_ip,
+			{ .tcp = { (__u16) ntohs(mms_port) } },
+			mms_proto } }
+		);
+	exp->mask  = ((struct ip_conntrack_tuple)
+		{ { 0xFFFFFFFF, { 0 } },
+		  { 0xFFFFFFFF, { .tcp = { 0xFFFF } }, 0xFF }});*/
+
+	nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
+			&ct->tuplehash[!dir].tuple.src.u3,
+			mms_ip, mms_proto, NULL, &htons(mms_port));
+
+//               exp->tuple.src.u3 =  ct->tuplehash[!dir].tuple.src.u3;
+                exp->mask.src.u3.ip = 0xffffffff;
+                exp->tuple.src.u.tcp.port = 0 ;
+                exp->mask.src.u.tcp.port = 0;
+
+  //              exp->tuple.dst.u3.ip = mms_ip;
+   //             exp->mask.src.u3.ip = 0xffffffff;
+     //           exp->tuple.dst.u.tcp.port =  htons(mms_port);
+       //         exp->mask.dst.u.tcp.port = 0xffff;
+         //       exp->tuple.dst.protonum = mms_proto;
+           //     exp->mask.dst.protonum = 0xff;
+
+
+	exp->expectfn = NULL;
+	exp->master = ct;
+
+
+     mms_data_fixup = rcu_dereference(nf_nat_mms_hook);
+	if (mms_data_fixup && ct->status & IPS_NAT_MASK)
+		ret = mms_data_fixup(skb, ctinfo, exp_mms_info, exp);
+	else if (nf_ct_expect_related(exp) != 0)
+		ret = NF_DROP;
+
+	nf_ct_expect_put(exp);
+
+out:
+	spin_unlock_bh(&mms_buffer_lock);
+	return ret;
+}
+
+static struct nf_conntrack_helper mms[MAX_PORTS];
+static char mms_names[MAX_PORTS][10];
+
+static const struct nf_conntrack_expect_policy mms_exp_policy {
+		.max_expected   = 1,
+		.timeout        = 120,
+};
+
+/* Not __exit: called from init() */
+static void fini(void)
+{
+	int i;
+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
+		DEBUGP("ip_conntrack_mms: unregistering helper for port %d\n",
+				ports[i]);
+		nf_conntrack_helper_unregister(&mms[i]);
+	}
+}
+
+static int __init init(void)
+{
+	int i, ret;
+	char *tmpname;
+
+	if (ports[0] == 0)
+		ports[0] = MMS_PORT;
+
+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
+		memset(&mms[i], 0, sizeof(struct nf_conntrack_helper));
+		mms[i].tuple.src.l3num = PF_INET;
+		mms[i].tuple.src.u.tcp.port = htons(ports[i]);
+		mms[i].tuple.dst.protonum = IPPROTO_TCP;
+		mms[i].mask.src.u.tcp.port = 0xFFFF;
+		mms[i].mask.dst.protonum = 0xFF;
+		mms[i].expect_policy = &mms_exp_policy;
+		mms[i].me = THIS_MODULE;
+		mms[i].help = help;
+
+		tmpname = &mms_names[i][0];
+		if (ports[i] == MMS_PORT)
+			sprintf(tmpname, "mms");
+		else
+			sprintf(tmpname, "mms-%d", ports[i]);
+		mms[i].name = tmpname;
+
+		printk("nf_conntrack_mms: registering helper for port %d\n",
+				ports[i]);
+		ret = nf_conntrack_helper_register(&mms[i]);
+
+		if (ret) {
+			fini();
+			return ret;
+		}
+		ports_c++;
+	}
+	return 0;
+}
+
+module_init(init);
+module_exit(fini);
Index: linux/include/linux/netfilter/nf_conntrack_talk.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/linux/netfilter/nf_conntrack_talk.h	2010-12-08 16:45:11.255850056 +0530
@@ -0,0 +1,173 @@
+#ifndef _IP_CONNTRACK_TALK_H
+#define _IP_CONNTRACK_TALK_H
+/* TALK tracking. */
+
+#ifdef __KERNEL__
+#include <linux/in.h>
+//#include <linux/netfilter_ipv4/lockhelp.h>
+
+/* Protects talk part of conntracks */
+//DECLARE_LOCK_EXTERN(ip_talk_lock);
+#endif
+
+
+#define TALK_PORT	517
+#define NTALK_PORT	518
+
+/* talk structures and constants from <protocols/talkd.h> */
+
+/*
+ * 4.3BSD struct sockaddr
+ */
+struct talk_addr {
+	u_int16_t ta_family;
+	u_int16_t ta_port;
+	u_int32_t ta_addr;
+	u_int32_t ta_junk1;
+	u_int32_t ta_junk2;
+};
+
+#define	TALK_OLD_NSIZE	9
+#define	TALK_NSIZE	12
+#define	TALK_TTY_NSIZE	16
+
+/*
+ * Client->server request message formats.
+ */
+struct talk_msg {
+	u_char	type;		/* request type, see below */
+	char	l_name[TALK_OLD_NSIZE];/* caller's name */
+	char	r_name[TALK_OLD_NSIZE];/* callee's name */
+	u_char	pad;
+	u_int32_t id_num;	/* message id */
+	int32_t	pid;		/* caller's process id */
+	char	r_tty[TALK_TTY_NSIZE];/* callee's tty name */
+	struct	talk_addr addr;		/* old (4.3) style */
+	struct	talk_addr ctl_addr;	/* old (4.3) style */
+};
+
+struct ntalk_msg {
+	u_char	vers;		/* protocol version */
+	u_char	type;		/* request type, see below */
+	u_char	answer;		/* not used */
+	u_char	pad;
+	u_int32_t id_num;	/* message id */
+	struct	talk_addr addr;		/* old (4.3) style */
+	struct	talk_addr ctl_addr;	/* old (4.3) style */
+	int32_t	pid;		/* caller's process id */
+	char	l_name[TALK_NSIZE];/* caller's name */
+	char	r_name[TALK_NSIZE];/* callee's name */
+	char	r_tty[TALK_TTY_NSIZE];/* callee's tty name */
+};
+
+struct ntalk2_msg {
+	u_char	vers;		/* talk protocol version    */
+	u_char	type;		/* request type             */
+	u_char	answer;		/*  */
+	u_char	extended;	/* !0 if additional parts   */
+	u_int32_t id_num;	/* message id number (dels) */
+	struct	talk_addr addr;		/* target address   */
+	struct	talk_addr ctl_addr;	/* reply to address */
+	int32_t	pid;		/* caller's process id */
+	char	l_name[TALK_NSIZE];  /* caller's name */
+	char	r_name[TALK_NSIZE];  /* callee's name */
+	char	r_tty[TALK_TTY_NSIZE];    /* callee's tty */
+};
+
+/*
+ * Server->client response message formats.
+ */
+struct talk_response {
+	u_char	type;		/* type of request message, see below */
+	u_char	answer;		/* response to request message, see below */
+	u_char	pad[2];
+	u_int32_t id_num;	/* message id */
+	struct	talk_addr addr;	/* address for establishing conversation */
+};
+
+struct ntalk_response {
+	u_char	vers;		/* protocol version */
+	u_char	type;		/* type of request message, see below */
+	u_char	answer;		/* response to request message, see below */
+	u_char	pad;
+	u_int32_t id_num;	/* message id */
+	struct	talk_addr addr;	/* address for establishing conversation */
+};
+
+struct ntalk2_response {
+	u_char	vers;		/* protocol version         */
+	u_char	type;		/* type of request message  */
+	u_char	answer;		/* response to request      */
+	u_char	rvers;		/* Version of answering vers*/
+	u_int32_t id_num;	/* message id number        */
+	struct	talk_addr addr;	/* address for connection   */
+	/* This is at the end to compatiblize this with NTALK version.   */
+	char	r_name[TALK_NSIZE]; /* callee's name            */
+};
+
+#define TALK_STR(data, talk_str, member) ((struct talk_str *)data)->member)
+#define TALK_RESP(data, ver, member) (ver ? ((struct ntalk_response *)data)->member : ((struct talk_response *)data)->member)
+#define TALK_MSG(data, ver, member) (ver ? ((struct ntalk_msg *)data)->member : ((struct talk_msg *)data)->member)
+
+#define	TALK_VERSION	0		/* protocol versions */
+#define	NTALK_VERSION	1
+#define	NTALK2_VERSION	2
+
+/* message type values */
+#define LEAVE_INVITE	0	/* leave invitation with server */
+#define LOOK_UP		1	/* check for invitation by callee */
+#define DELETE		2	/* delete invitation by caller */
+#define ANNOUNCE	3	/* announce invitation by caller */
+/* NTALK2 */
+#define REPLY_QUERY	4	/* request reply data from local daemon */
+
+/* answer values */
+#define SUCCESS		0	/* operation completed properly */
+#define NOT_HERE	1	/* callee not logged in */
+#define FAILED		2	/* operation failed for unexplained reason */
+#define MACHINE_UNKNOWN	3	/* caller's machine name unknown */
+#define PERMISSION_DENIED 4	/* callee's tty doesn't permit announce */
+#define UNKNOWN_REQUEST	5	/* request has invalid type value */
+#define	BADVERSION	6	/* request has invalid protocol version */
+#define	BADADDR		7	/* request has invalid addr value */
+#define	BADCTLADDR	8	/* request has invalid ctl_addr value */
+/* NTALK2 */
+#define NO_CALLER	9	/* no-one calling answer from REPLY   */
+#define TRY_HERE	10	/* Not on this machine, try this      */
+#define SELECTIVE_REFUSAL 11	/* User Filter refusal.               */
+#define MAX_RESPONSE_TYPE 11	/* Make sure this is updated          */
+
+/* We don't really need much for talk */
+struct nf_ct_talk_expect
+{
+	/* Port that was to be used */
+	u_int16_t port;
+};
+
+/* This structure exists only once per master */
+struct nf_ct_talk_master
+{
+};
+
+struct nf_conn;
+struct nf_conntrack_expect;
+
+extern unsigned int (*nf_nat_talk_resp_hook)(struct sk_buff **pskb,
+                                      struct nf_conntrack_expect *exp,
+                                      u_char type,
+                                      u_char answer,
+                                      struct talk_addr *addr);
+
+extern unsigned int (*nf_nat_talk_msg_hook)(struct sk_buff **pskb,
+                                     struct nf_conn *ct,
+                                     u_char type,
+                                     struct talk_addr *addr,
+                                     struct talk_addr *ctl_addr);
+
+
+extern  void  talk_expect(struct nf_conn *ct, struct nf_conntrack_expect *exp);
+extern  void  ntalk_expect(struct nf_conn *ct, struct nf_conntrack_expect *exp);
+
+
+#endif /* _IP_CONNTRACK_TALK_H */
+
Index: linux/net/ipv4/netfilter/nf_nat_talk.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/net/ipv4/netfilter/nf_nat_talk.c	2010-12-08 16:43:28.384599931 +0530
@@ -0,0 +1,248 @@
+/* 
+ * talk extension for UDP NAT alteration. 
+ * Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ **
+ *
+ * Modifications:
+ * 2005-02-13 Harald Welte <laforge@netfilter.org>
+ * 	- update to 2.6.x API
+ * 	- update to post 2.6.11 helper infrastructure
+ * 	- use c99 structure initializers
+ *  
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/kernel.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+//#include <linux/udp.h>
+//#include <linux/netfilter.h>
+//#include <linux/skbuff.h>
+
+#include<linux/moduleparam.h>
+#include <net/netfilter/nf_nat.h>
+#include <net/netfilter/nf_nat_helper.h>
+#include <net/netfilter/nf_nat_rule.h>
+#include <linux/netfilter/nf_conntrack_talk.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+
+
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("talk network address translation module");
+
+#if 0
+#define DEBUGP printk
+#define IP_NAT_TALK_DEBUG
+#else
+#define DEBUGP(format, args...)
+#endif
+
+
+
+ void
+nat_talk_expect(struct nf_conn *ct,
+		struct nf_conntrack_expect *exp)
+{
+	nf_nat_follow_master(ct, exp);
+
+       
+
+	talk_expect(ct, exp);
+}
+
+static void
+nat_ntalk_expect(struct nf_conn *ct,
+		 struct nf_conntrack_expect *exp)
+{
+	nf_nat_follow_master(ct, exp);
+        
+
+	ntalk_expect(ct, exp);
+}
+
+static int
+mangle_packet(struct sk_buff **pskb,
+	      struct nf_conn *ct,
+	      u_int32_t newip,
+	      u_int16_t port,
+	      struct talk_addr *addr,
+	      struct talk_addr *ctl_addr)
+{
+	struct iphdr *iph = (*pskb)->nh.iph;
+	struct udphdr *udph = (void *)iph + iph->ihl * 4;
+	size_t udplen = (*pskb)->len - iph->ihl * 4;
+
+	/* Fortunately talk sends a structure with the address and
+	   port in it. The size of the packet won't change. */
+
+	if (ctl_addr == NULL) {
+		/* response */
+		if (addr->ta_addr == INADDR_ANY)
+			return 1;
+		DEBUGP("ip_nat_talk_mangle_packet: response orig "
+		       "%u.%u.%u.%u:%u, inserting %u.%u.%u.%u:%u\n", 
+		       NIPQUAD(addr->ta_addr), ntohs(addr->ta_port),
+		       NIPQUAD(newip), ntohs(port));
+		addr->ta_addr = newip;
+		addr->ta_port = port;
+	} else {
+		/* message */
+		if (addr->ta_addr != INADDR_ANY) {
+			/* Change address inside packet to match way we're
+			 * mapping this connection. */
+			DEBUGP("ip_nat_talk_mangle_packet: message orig addr "
+			       "%u.%u.%u.%u:%u, inserting %u.%u.%u.%u:%u\n", 
+			       NIPQUAD(addr->ta_addr), ntohs(addr->ta_port),
+			       NIPQUAD(ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip), 
+			       ntohs(addr->ta_port));
+			addr->ta_addr = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+		}
+		DEBUGP("ip_nat_talk_mangle_packet: message orig ctl_addr "
+		       "%u.%u.%u.%u:%u, inserting %u.%u.%u.%u:%u\n", 
+		       NIPQUAD(ctl_addr->ta_addr), ntohs(ctl_addr->ta_port),
+		       NIPQUAD(newip), ntohs(port));
+		ctl_addr->ta_addr = newip;
+		ctl_addr->ta_port = port;
+	}
+
+	/* Fix checksums */
+	(*pskb)->csum = csum_partial((char *)udph + sizeof(struct udphdr), udplen - sizeof(struct udphdr), 0);
+	udph->check = 0;
+	udph->check = csum_tcpudp_magic(iph->saddr, iph->daddr, udplen, IPPROTO_UDP,
+				        csum_partial((char *)udph, sizeof(struct udphdr), (*pskb)->csum));
+		
+	ip_send_check(iph);
+	return 1;
+}
+
+static unsigned int talk_help_msg(struct sk_buff **pskb,
+			 struct nf_conn *ct,
+		         u_char type,
+		         struct talk_addr *addr,
+		         struct talk_addr *ctl_addr)
+{
+	u_int32_t newip;
+	u_int16_t port;
+	
+	unsigned int verdict = NF_ACCEPT;
+
+	DEBUGP("ip_nat_talk_help_msg: addr: %u.%u.%u.%u:%u, ctl_addr: %u.%u.%u.%u:%u, type %d\n",
+		NIPQUAD(addr->ta_addr), ntohs(addr->ta_port),
+		NIPQUAD(ctl_addr->ta_addr), ntohs(ctl_addr->ta_port),
+		type);
+
+	/* Change address inside packet to match way we're mapping
+	   this connection. */
+	newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+	port  = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.udp.port;
+	DEBUGP("ip_nat_talk_help_msg: inserting: %u.%u.%u.%u:%u\n",
+		NIPQUAD(newip), ntohs(port));
+
+	if (!mangle_packet(pskb, ct, newip, port, addr, ctl_addr))
+		verdict = NF_DROP;
+
+	return verdict;
+}
+
+static unsigned int talk_help_resp(struct sk_buff **pskb,
+			      struct nf_conntrack_expect *exp,
+		              u_char type,
+			      u_char answer,
+		              struct talk_addr *addr)
+{
+	struct nf_conn *ct = exp->master;
+	u_int32_t newip;
+	u_int16_t port, *pport = NULL, *tport;
+
+	DEBUGP("ip_nat_talk_help_response: addr: %u.%u.%u.%u:%u, "
+	       "type %d answer %d\n", NIPQUAD(addr->ta_addr),
+	       ntohs(addr->ta_port), type, answer);
+	
+	DEBUGP("ip_nat_talk_help_response: talkinfo port %u (%s)\n", 
+		ntohs(exp->tuple.dst.u.tcp.port),
+		type == LOOK_UP ? "LOOK_UP" : "ANNOUNCE");
+
+	/* Change address inside packet to match way we're mapping
+	   this connection. */
+	newip = ct->tuplehash[type == LOOK_UP ? IP_CT_DIR_ORIGINAL : 
+						IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+	/* We can read expect here without conntrack lock, since it's
+	   only set in ip_conntrack_talk , with ip_talk_lock held
+	   writable */ 
+	if (type == LOOK_UP) {
+		//pport = &exp->saved_proto.tcp.port;
+		tport = &exp->tuple.dst.u.tcp.port;
+	} else {
+		//pport = &exp->saved_proto.udp.port;
+		tport = &exp->tuple.dst.u.udp.port;
+	}
+
+	*pport = *tport;
+
+	exp->tuple.dst.u3.ip = newip;
+
+	if (exp->expectfn == talk_expect)
+		exp->expectfn = nat_talk_expect;
+	else if (exp->expectfn == ntalk_expect)
+		exp->expectfn = nat_ntalk_expect;
+	else
+		BUG();
+
+	/* Try to get same port: if not, try to change it. */
+	for (port = ntohs(*pport); port != 0; port++) {
+		*tport = htons(port);
+
+		if (nf_ct_expect_related(exp) == 0) {
+			DEBUGP("ip_nat_talk_help_response: using "
+			       "%u.%u.%u.%u:%u\n", NIPQUAD(newip), port);
+			break;
+		}
+	}
+	if (port == 0) {
+	//	ip_conntrack_expect_free(exp);
+		return NF_DROP;
+	}
+
+	if (!mangle_packet(pskb, ct, newip, htons(port), addr, NULL)) {
+		nf_ct_unexpect_related(exp);
+		return NF_DROP;
+	}
+	return NF_ACCEPT;
+}
+
+static int __init init(void)
+{
+	BUG_ON(rcu_dereference(nf_nat_talk_msg_hook));
+	BUG_ON(rcu_dereference(nf_nat_talk_resp_hook));
+	
+	//ip_nat_talk_msg_hook = talk_help_msg;
+	//ip_nat_talk_resp_hook = talk_help_response;
+	
+	rcu_assign_pointer(nf_nat_talk_msg_hook,talk_help_msg );
+	rcu_assign_pointer(nf_nat_talk_resp_hook,talk_help_resp );
+	
+	return 0;
+}
+
+static void __exit fini(void)
+{
+	//ip_nat_talk_resp_hook = NULL;
+	//ip_nat_talk_msg_hook = NULL;
+	rcu_assign_pointer(nf_nat_talk_msg_hook,NULL );
+	 rcu_assign_pointer(nf_nat_talk_resp_hook,NULL );
+	/* Make sure noone calls it, meanwhile */
+	synchronize_net();
+}
+
+module_init(init);
+module_exit(fini);
+
+
Index: linux/net/netfilter/nf_conntrack_talk.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/net/netfilter/nf_conntrack_talk.c	2010-12-08 16:40:06.795850080 +0530
@@ -0,0 +1,648 @@
+/* 
+ * talk extension for IP connection tracking. 
+ * Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ **
+ *     Module load syntax:
+ *     insmod ip_nat_talk.o talk=[0|1] ntalk=[0|1] ntalk2=[01]
+ *
+ *		talk=[0|1]	disable|enable old talk support
+ *	       ntalk=[0|1]	disable|enable ntalk support
+ *	      ntalk2=[0|1]	disable|enable ntalk2 support
+ *
+ *     The default is talk=1 ntalk=1 ntalk2=1
+ *
+ *     The helper does not support simultaneous talk requests.
+ **
+ *
+ *		ASCII art on talk protocols
+ *	
+ *	
+ *	caller server		    callee server
+ *		|     \	          /
+ *		|	\       /
+ *		|	  \   /
+ *		|	    /  
+ *	 	|	  /   \
+ *	      2 |     1 /       \ 3
+ *	caller client  ----------- callee client
+ *	               		 4
+ *
+ *	1. caller client <-> callee server: LOOK_UP, then ANNOUNCE invitation 
+ *    ( 2. caller client <-> caller server: LEAVE_INVITE to server )
+ *	3. callee client <-> caller server: LOOK_UP invitation
+ *	4. callee client <-> caller client: talk data channel
+ *
+ * [1]: M. Hunter, talk: a historical protocol for interactive communication
+ *      draft-hunter-talk-00.txt
+ * [2]: D.B. Chapman, E.D. Zwicky: Building Internet Firewalls (O'Reilly)	
+ */
+//#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/ip.h>
+#include <net/checksum.h>
+#include <linux/udp.h>
+#include <net/udp.h>
+#include <linux/moduleparam.h>
+
+
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+
+#include <linux/netfilter/nf_conntrack_talk.h>
+
+/* Default all talk protocols are supported */
+static int talk = 1;
+static int ntalk = 1;
+static int ntalk2 = 1;
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("talk connection tracking module");
+MODULE_LICENSE("GPL");
+#ifdef MODULE_PARM
+MODULE_PARM(talk, "i");
+MODULE_PARM_DESC(talk, "support (old) talk protocol");
+MODULE_PARM(ntalk, "i");
+MODULE_PARM_DESC(ntalk, "support ntalk protocol");
+MODULE_PARM(ntalk2, "i");
+MODULE_PARM_DESC(ntalk2, "support ntalk2 protocol");
+#endif
+
+//DECLARE_LOCK(ip_talk_lock);
+
+rwlock_t ip_talk_rwlock ;
+
+static DEFINE_SPINLOCK(ip_talk_lock);
+
+struct module *nf_conntrack_talk = THIS_MODULE;
+
+static char talk_buffer[65536];
+
+extern spinlock_t ip_talk_lock;
+
+unsigned int (*nf_nat_talk_resp_hook)(struct sk_buff **pskb,
+                                      struct nf_conntrack_expect *exp,
+                                      u_char type,
+                                      u_char answer,
+                                      struct talk_addr *addr);
+EXPORT_SYMBOL_GPL(nf_nat_talk_resp_hook);
+
+unsigned int (*nf_nat_talk_msg_hook)(struct sk_buff **pskb,
+                                     struct nf_conn *ct,
+                                     u_char type,
+                                     struct talk_addr *addr,
+                                     struct talk_addr *ctl_addr);
+EXPORT_SYMBOL_GPL(nf_nat_talk_msg_hook);
+
+
+
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(format, args...)
+#endif
+
+//static int talk_expect(struct ip_conntrack *ct);
+//static int ntalk_expect(struct ip_conntrack *ct);
+
+void  talk_expect(struct nf_conn *ct,
+                       struct nf_conntrack_expect *exp);
+
+
+void  ntalk_expect(struct nf_conn *ct,
+                        struct nf_conntrack_expect *exp);
+
+
+ void  (*talk_expectfn[2])(struct nf_conn *ct, struct nf_conntrack_expect *exp) = {talk_expect, ntalk_expect};
+
+static int talk_help_response(struct sk_buff **pskb,
+		              struct nf_conn *ct,
+		              enum ip_conntrack_info ctinfo,
+		              int talk_port,
+		              u_char mode,
+		              u_char type,
+		              u_char answer,
+		              struct talk_addr *addr)
+{
+	int dir = CTINFO2DIR(ctinfo);
+	//struct ip_conntrack_expect expect, *exp = &expect;
+	//struct ip_ct_talk_expect *exp_talk_info = &exp->help.exp_talk_info;
+
+        int ret;
+        struct nf_conntrack_expect *exp;
+        u_int16_t exp_talk_port;
+         struct nf_conntrack_man cmd = {}; 
+         typeof(nf_nat_talk_resp_hook) talk_help_resp;
+        
+	DEBUGP("ip_ct_talk_help_response: %u.%u.%u.%u:%u, type %d answer %d\n",
+		NIPQUAD(addr->ta_addr), ntohs(addr->ta_port),
+		type, answer);
+
+	if (!(answer == SUCCESS && type == mode))
+		return NF_ACCEPT;
+	
+	//memset(&expect, 0, sizeof(expect));
+	
+         exp = nf_ct_expect_alloc(ct);
+        if (exp == NULL) {
+                return NF_DROP;
+        }
+
+	
+	if (type == ANNOUNCE) {
+
+		DEBUGP("ip_ct_talk_help_response: ANNOUNCE\n");
+
+		/* update the talk info */
+		//LOCK_BH(&ip_talk_lock);
+		spin_lock_bh(&ip_talk_lock);
+
+		exp_talk_port = htons(talk_port);
+
+		/* expect callee client -> caller server message */
+	/*	exp->tuple = ((struct  nf_conntrack_tuple)
+			{ { {.u3 =  ct->tuplehash[dir].tuple.src.u3},
+			    { 0 }, PF_INET },
+			  { ct->tuplehash[dir].tuple.dst.u3,
+			    { .udp = { .port = htons(talk_port) } },
+			    IPPROTO_UDP }});
+		exp->mask = ((struct nf_conntrack_tuple)
+			{ { 0xFFFFFFFF, { 0 },{0xFFFF} },
+			  { 0xFFFFFFFF, { .udp = { .port = 0xFFFF } }, 0xFF }});*/
+		cmd.l3num = nf_ct_l3num(ct);
+		 memcpy(cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,
+				 sizeof(cmd.u3.all));
+
+		nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
+				&ct->tuplehash[dir].tuple.src.u3,
+				&ct->tuplehash[dir].tuple.dst.u3,
+				IPPROTO_UDP, NULL, exp_talk_port);
+
+        /*        exp->tuple.src.u3 =  ct->tuplehash[dir].tuple.src.u3;              
+                exp->mask.src.u3.ip = 0xffffffff;*/
+                exp->tuple.src.u.udp.port = 0 ;
+                exp->mask.src.u.udp.port = 0;
+                /*
+                exp->tuple.dst.u3 = ct->tuplehash[dir].tuple.dst.u3;
+                exp->mask.src.u3.ip = 0xffffffff;
+		exp->tuple.dst.u.udp.port =  htons(talk_port);		
+                exp->mask.dst.u.udp.port = 0xffff;
+                exp->tuple.dst.protonum = IPPROTO_UDP ;
+                exp->mask.dst.protonum = 0xff;
+		*/
+
+		exp->expectfn = talk_expectfn[talk_port - TALK_PORT];
+	        exp->master = ct ; // added
+
+		DEBUGP("ip_ct_talk_help_response: callee client %u.%u.%u.%u:%u -> caller daemon %u.%u.%u.%u:%u!\n",
+		       NIPQUAD(exp->tuple.src.u3.ip), ntohs(exp->tuple.src.u.udp.port),
+		       NIPQUAD(exp->tuple.dst.u3.ip), ntohs(exp->tuple.dst.u.udp.port));
+
+		/* Ignore failure; should only happen with NAT */
+		//ip_conntrack_expect_related(ct, &expect);
+
+		talk_help_resp = rcu_dereference(nf_nat_talk_resp_hook);
+
+		 if (talk_help_resp)
+                        ret = talk_help_resp(pskb, exp, type, answer,
+                                                    addr);
+                else if (nf_ct_expect_related(exp) != 0) {
+//                        ip_conntrack_expect_free(exp);
+                        ret = NF_DROP;
+                }
+
+
+	//	UNLOCK_BH(&ip_talk_lock);
+		spin_unlock_bh(&ip_talk_lock);
+
+	}
+	if (type == LOOK_UP) {
+
+		DEBUGP("ip_ct_talk_help_response: LOOK_UP\n");
+
+		/* update the talk info */
+	//	LOCK_BH(&ip_talk_lock);
+		spin_lock_bh(&ip_talk_lock);
+
+		exp_talk_port = htons(addr->ta_port);
+
+		/* expect callee client -> caller client connection */
+		/*exp->tuple = ((struct nf_conntrack_tuple)
+			{ { {.u3 = ct->tuplehash[!dir].tuple.src.u3},
+			    { 0 },PF_INET },
+			  { {.ip = addr->ta_addr},
+			    { .udp = { .port = addr->ta_port } },
+			    IPPROTO_UDP }});
+		exp->mask = ((struct nf_conntrack_tuple)
+			{ { 0xFFFFFFFF, { 0 },{0xFFFF} },
+			  { 0xFFFFFFFF, { .udp = { .port = 0xFFFF } }, 0xFF }});*/
+
+		cmd.l3num = nf_ct_l3num(ct);
+		memcpy(cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,
+				sizeof(cmd.u3.all));
+		nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
+				&ct->tuplehash[dir].tuple.src.u3,
+				&addr->ta_addr,
+				IPPROTO_UDP, NULL, exp_talk_port);
+		/*
+                exp->tuple.src.u3 =  ct->tuplehash[!dir].tuple.src.u3;
+                exp->mask.src.u3.ip = 0xffffffff;*/
+                exp->tuple.src.u.udp.port = 0 ;
+                exp->mask.src.u.udp.port = 0;
+/*
+                exp->tuple.dst.u3.ip = addr->ta_addr;
+                exp->mask.src.u3.ip = 0xffffffff;
+                exp->tuple.dst.u.udp.port =  addr->ta_port;
+                exp->mask.dst.u.udp.port = 0xffff;
+                exp->tuple.dst.protonum = IPPROTO_UDP ;
+                exp->mask.dst.protonum = 0xff;
+*/
+		
+		exp->expectfn = NULL;
+		exp->master= ct;
+		DEBUGP("ip_ct_talk_help_response: callee client %u.%u.%u.%u:%u -> caller client %u.%u.%u.%u:%u!\n",
+		       NIPQUAD(exp->tuple.src.u3.ip), ntohs(exp->tuple.src.u.tcp.port),
+		       NIPQUAD(exp->tuple.dst.u3.ip), ntohs(exp->tuple.dst.u.tcp.port));
+
+		/* Ignore failure; should only happen with NAT */
+		//ip_conntrack_expect_related(ct, &expect);
+
+                talk_help_resp = rcu_dereference(nf_nat_talk_resp_hook);
+         
+       		if (talk_help_resp)
+                        ret = talk_help_resp(pskb, exp, type, answer,
+                                                    addr);
+                else if (nf_ct_expect_related(exp) != 0) {
+//                        ip_conntrack_expect_free(exp);
+                        ret = NF_DROP;
+                }
+
+
+	//	UNLOCK_BH(&ip_talk_lock);
+       spin_unlock_bh(&ip_talk_lock);
+
+	}
+		    
+	return NF_ACCEPT;
+}
+
+/* FIXME: This should be in userspace.  Later. */
+ static int talk_help(struct sk_buff **pskb,
+		     struct nf_conn *ct,
+		     enum ip_conntrack_info ctinfo,
+		     int talk_port,
+		     u_char mode)
+{
+	//struct udphdr *udph = (void *)iph + iph->ihl * 4;
+	//const char *data = (const char *)udph + sizeof(struct udphdr);
+     //    int ret;
+
+        unsigned int dataoff;
+        struct udphdr udph, *uh;
+        char *tb_ptr, *data;
+
+        typeof(nf_nat_talk_msg_hook) talk_help_msg ; 
+	int dir = CTINFO2DIR(ctinfo);
+	size_t udplen;
+
+	DEBUGP("ip_ct_talk_help: help entered\n");
+
+	/* Until there's been traffic both ways, don't look in packets. */
+	if (ctinfo != IP_CT_ESTABLISHED
+	    && ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
+		DEBUGP("ip_ct_talk_help: Conntrackinfo = %u\n", ctinfo);
+		return NF_ACCEPT;
+	}
+
+	/* Not whole UDP header? */
+/*	udplen = len - iph->ihl * 4;
+	if (udplen < sizeof(struct udphdr)) {
+		DEBUGP("ip_ct_talk_help: too short for udph, udplen = %u\n", (unsigned)udplen);
+		return NF_ACCEPT;
+	}*/
+
+	/* Checksum invalid?  Ignore. */
+	/* FIXME: Source route IP option packets --RR */
+	/*if (csum_tcpudp_magic(iph->saddr, iph->daddr, udplen, IPPROTO_UDP,
+			      csum_partial((char *)udph, udplen, 0))) {
+		DEBUGP("ip_ct_talk_help: bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
+		       udph, udplen, NIPQUAD(iph->saddr),
+		       NIPQUAD(iph->daddr));
+		return NF_ACCEPT;
+	}*/
+	
+
+ 	  /* Not whole UDP header? */
+        uh = skb_header_pointer(*pskb, (*pskb)->nh.iph->ihl*4,
+                                sizeof(udph), &udph);
+        if (uh == NULL) {
+                DEBUGP("ip_ct_talk_help: short for udph\n");
+                return NF_ACCEPT;
+        }
+
+        udplen = (*pskb)->len - (*pskb)->nh.iph->ihl*4;
+        dataoff = (*pskb)->nh.iph->ihl*4 + sizeof(udph);
+        if (dataoff >= (*pskb)->len)
+                return NF_ACCEPT;
+
+       // LOCK_BH(&talk_buffer_lock);
+        tb_ptr = skb_header_pointer(*pskb, dataoff,
+                                    (*pskb)->len - dataoff, talk_buffer);
+        BUG_ON(tb_ptr == NULL);
+
+        data = tb_ptr;
+
+      talk_help_msg = rcu_dereference(nf_nat_talk_msg_hook);
+
+	DEBUGP("ip_ct_talk_help: %u.%u.%u.%u:%u->%u.%u.%u.%u:%u\n",
+		NIPQUAD(iph->saddr), ntohs(udph->source), NIPQUAD(iph->daddr), ntohs(udph->dest));
+
+	if (dir == IP_CT_DIR_ORIGINAL && talk_help_msg)
+        {
+	    if (talk_port == TALK_PORT) {
+                        if (udplen == sizeof(struct udphdr) +
+                                        sizeof(struct talk_msg)) {
+                                struct talk_msg *tm = (struct talk_msg *)data;
+                                return talk_help_msg(pskb, ct, tm->type,
+                                                &tm->addr, &tm->ctl_addr);
+                        }
+                } else {
+                        if (ntalk &&
+                            udplen == sizeof(struct udphdr) +
+                                        sizeof(struct ntalk_msg) &&
+                            ((struct ntalk_msg *)data)->vers == NTALK_VERSION){
+                                struct ntalk_msg *tm = (struct ntalk_msg *)data;
+                                return talk_help_msg(pskb, ct, tm->type,
+                                                &tm->addr, &tm->ctl_addr);
+                        } else if (ntalk2 &&
+                                   udplen >= sizeof(struct udphdr) +
+                                                sizeof(struct ntalk2_msg) &&
+                                   ((struct ntalk2_msg *)data)->vers == NTALK2_VERSION &&
+                                   udplen == sizeof(struct udphdr)
+                                             + sizeof(struct ntalk2_msg)
+                                             + ((struct ntalk2_msg *)data)->extended) {
+                                struct ntalk2_msg *tm = (struct ntalk2_msg *)data;
+                                return talk_help_msg(pskb, ct, tm->type,
+                                                &tm->addr, &tm->ctl_addr);
+                        }
+                }
+
+        	return NF_ACCEPT;
+        }
+		
+	if (talk_port == TALK_PORT
+	    && udplen == sizeof(struct udphdr) + sizeof(struct talk_response))
+		return talk_help_response(pskb, ct, ctinfo, talk_port, mode,
+					  ((struct talk_response *)data)->type, 
+					  ((struct talk_response *)data)->answer,
+					  &(((struct talk_response *)data)->addr));
+	else if (talk_port == NTALK_PORT
+	 	  && ntalk
+		  && udplen == sizeof(struct udphdr) + sizeof(struct ntalk_response)
+		  && ((struct ntalk_response *)data)->vers == NTALK_VERSION)
+		return talk_help_response(pskb, ct, ctinfo, talk_port, mode,
+					  ((struct ntalk_response *)data)->type, 
+					  ((struct ntalk_response *)data)->answer,
+					  &(((struct ntalk_response *)data)->addr));
+	else if (talk_port == NTALK_PORT
+		 && ntalk2
+		 && udplen >= sizeof(struct udphdr) + sizeof(struct ntalk2_response)
+		 && ((struct ntalk2_response *)data)->vers == NTALK2_VERSION)
+		return talk_help_response(pskb, ct, ctinfo, talk_port, mode,
+					  ((struct ntalk2_response *)data)->type, 
+					  ((struct ntalk2_response *)data)->answer,
+					  &(((struct ntalk2_response *)data)->addr));
+	else {
+		DEBUGP("ip_ct_talk_help: not ntalk/ntalk2 response, datalen %u != %u or %u + max 256\n", 
+		       (unsigned)udplen - sizeof(struct udphdr), 
+		       sizeof(struct ntalk_response), sizeof(struct ntalk2_response));
+		return NF_ACCEPT;
+	}	
+}
+
+int lookup_help(struct sk_buff *skb, unsigned int protoff,
+		       struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	 struct sk_buff **pskb=NULL;
+	 *pskb = skb;
+	return talk_help(pskb, ct, ctinfo, TALK_PORT, LOOK_UP);
+}
+
+int lookup_nhelp(struct sk_buff *skb, unsigned int protoff,
+		        struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	struct sk_buff **pskb=NULL;
+	*pskb = skb;
+	return talk_help(pskb, ct, ctinfo, NTALK_PORT, LOOK_UP);
+}
+
+#if 0
+static struct nf_conntrack_helper lookup_helpers[2] = 
+	{ { { NULL, NULL },
+	    "talk",					/* name */
+	 //   0,						/* flags */
+	    NULL,					/* module */
+	    1,						/* max_expected */
+	    240,					/* timeout */
+            { { { 0}, { .udp = { .port = __constant_htons(TALK_PORT) } },PF_INET },	/* tuple */
+	      { {0}, { 0 }, IPPROTO_UDP } },
+	    { { { 0}, { .udp = { .port = 0xFFFF } },0xFFFF },			/* mask */
+	      { {0}, { 0 }, 0xFF } },
+	    lookup_help },				/* helper */
+          { { NULL, NULL },
+            "ntalk",					
+	   // 0,						
+	    NULL,					
+	    1,						
+	    240,					
+	    { { { 0}, { .udp = { .port = __constant_htons(NTALK_PORT) } },PF_INET },	
+	       { { 0}, { 0 }, IPPROTO_UDP  } },
+	    { { { 0}, { .udp = { .port = 0xFFFF } },0xFFFF },			
+	      { { 0}, { 0 }, 0xFF } },
+    	    lookup_nhelp }				
+        };
+#endif
+static const struct nf_conntrack_expect_policy talk_exp_policy = {
+	.max_expected   = 1,
+	.timeout        = 240,
+};
+
+struct nf_conntrack_helper lookup_helpers[2] =
+{
+{
+
+        .name                   = "talk",
+        .me                     = NULL,
+	.expect_policy 		= &talk_exp_policy,
+        .tuple.src.l3num        = PF_INET,
+        .tuple.src.u.udp.port   = __constant_htons(TALK_PORT),
+        .tuple.dst.protonum     = IPPROTO_UDP,
+        .tuple.dst.u.udp.port   = 0,
+        .mask.src.l3num         = 0xffff,
+        .mask.src.u.udp.port    = __constant_htons(0xffff),
+        .mask.dst.protonum      = 0xff,
+        .mask.dst.u.udp.port    = 0xffff,
+        .help                   = lookup_help,
+
+
+},
+
+{
+	.name                   = "ntalk",
+        .me                     = NULL,
+	.expect_policy          = &talk_exp_policy,
+        .tuple.src.l3num        = PF_INET,
+        .tuple.src.u.udp.port   = __constant_htons(NTALK_PORT),
+        .tuple.dst.protonum     = IPPROTO_UDP,
+        .tuple.dst.u.udp.port   = 0,
+        .mask.src.l3num         = 0xffff,
+        .mask.src.u.udp.port    = __constant_htons(0xffff),
+        .mask.dst.protonum      = 0xff,
+        .mask.dst.u.udp.port    = 0xffff,
+        .help                   = lookup_nhelp,
+
+
+
+}
+};
+
+void talk_expect(struct nf_conn *ct,struct nf_conntrack_expect *exp)
+{
+
+     struct nf_conn_help *ct_help = nfct_help(ct);
+	 
+	DEBUGP("ip_conntrack_talk: calling talk_expectfn for ct %p\n", ct);
+	
+	ct_help->helper = &lookup_helpers[0];
+	
+	      
+
+	//return NF_ACCEPT;       /* unused */
+}
+
+void ntalk_expect(struct nf_conn *ct, struct nf_conntrack_expect *exp)
+{
+
+    struct nf_conn_help *ct_help = nfct_help(ct);
+
+	DEBUGP("ip_conntrack_talk: calling ntalk_expectfn for ct %p\n", ct);
+
+   ct_help->helper = &lookup_helpers[1];
+	 
+	//return NF_ACCEPT;       /* unused */
+}
+
+static int help(struct sk_buff **pskb,unsigned int protoff,
+		struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	return talk_help(pskb, ct, ctinfo, TALK_PORT, ANNOUNCE);
+}
+
+static int nhelp(struct sk_buff **pskb,unsigned int protoff,
+		 struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	return talk_help(pskb, ct, ctinfo, NTALK_PORT, ANNOUNCE);
+}
+
+#if 0
+static struct nf_conntrack_helper talk_helpers[2] = 
+	{ { { NULL, NULL },
+	    "talk",					/* name */
+	    0,						/* flags */
+	    THIS_MODULE,				/* module */
+	    1,						/* max_expected */
+	    240,					/* timeout */
+	    { { .ip =  0 , {.udp = { .port = __constant_htons(TALK_PORT) } },PF_INET },	/* tuple */
+ 	      { .ip = 0 , { 0 }, IPPROTO_UDP } },
+	    { { .ip = 0 , { .udp = { .port = 0xFFFF } },0xFFFF },			/* mask */
+	      { .ip = 0 , { 0 }, 0xFF } },
+	    help },					/* helper */
+          { { NULL, NULL },
+	    "ntalk",					/* name */
+	    0,						/* flags */
+	    THIS_MODULE,				/* module */
+	    1,						/* max_expected */
+	    240,					/* timeout */
+	    { { .ip = 0  , { .udp = { .port = __constant_htons(NTALK_PORT) } },PF_INET },	/* tuple */
+	      { .ip=0 , { 0 }, IPPROTO_UDP } },
+	    { { .ip =  0, { .udp = { .port = 0xFFFF } },0xFFFF },			/* mask */
+	      { .ip= 0, { 0 }, 0xFF } },
+	    nhelp }					/* helper */
+	};
+
+#endif
+
+static const struct nf_conntrack_expect_policy talk_exp_policy = {
+		.max_expected   = 1,
+		.timeout        = 120,
+};
+
+static struct nf_conntrack_helper talk_helpers[2] = {
+       {
+        .name                   = "talk",
+        .me                     = THIS_MODULE,
+	.expect_policy 		= &talk_exp_policy;
+        .tuple.src.l3num        = PF_INET,
+        .tuple.src.u.udp.port   = __constant_htons(TALK_PORT),
+        .tuple.dst.protonum     = IPPROTO_UDP,
+        .tuple.dst.u.udp.port   = 0,
+        .mask.src.l3num         = 0xffff,
+        .mask.src.u.udp.port    = __constant_htons(0xffff),
+        .mask.dst.protonum      = 0xff,
+        .mask.dst.u.udp.port    = 0xffff, 
+        .help                   = help,
+        
+        },
+        {
+ 	.name                   = "ntalk",
+        .me                     = THIS_MODULE,
+	.expect_policy          = &talk_exp_policy;
+        .tuple.src.l3num        = PF_INET,
+        .tuple.src.u.udp.port   = __constant_htons(NTALK_PORT),
+        .tuple.dst.protonum     = IPPROTO_UDP,
+        .tuple.dst.u.udp.port   = 0,
+        .mask.src.l3num         = 0xffff,
+        .mask.src.u.udp.port    = __constant_htons(0xffff),
+        .mask.dst.protonum      = 0xff,
+        .mask.dst.u.udp.port    = 0xffff,
+        .help                   = nhelp,
+
+        }
+};
+
+
+static int __init init(void)
+{
+	if (talk > 0)
+	{
+		printk("tuple->src.u.port[0]=%d\n",talk_helpers[0].tuple.src.u.udp.port);
+		nf_conntrack_helper_register(&talk_helpers[0]);
+	}
+	if (ntalk > 0 || ntalk2 > 0)
+	{
+		printk("tuple->src.u.port[1]=%d\n",talk_helpers[1].tuple.src.u.udp.port);
+		nf_conntrack_helper_register(&talk_helpers[1]);
+	}
+		
+	return 0;
+}
+
+static void __exit fini(void)
+{
+	if (talk > 0)
+		nf_conntrack_helper_unregister(&talk_helpers[0]);
+	if (ntalk > 0 || ntalk2 > 0)
+		nf_conntrack_helper_unregister(&talk_helpers[1]);
+}
+
+EXPORT_SYMBOL(ip_talk_lock);
+
+module_init(init);
+module_exit(fini);
+
Index: linux/net/ipv4/netfilter/nf_nat_rtsp.c
===================================================================
--- linux.orig/net/ipv4/netfilter/nf_nat_rtsp.c	2010-12-08 18:16:39.000000000 +0530
+++ linux/net/ipv4/netfilter/nf_nat_rtsp.c	2010-12-08 18:41:13.755850012 +0530
@@ -187,6 +187,10 @@
     uint    extaddrlen;
     int     is_stun;
 
+#ifdef CONFIG_RTSP_ALG_FIX
+    int dir = CTINFO2DIR(ctinfo);
+#endif
+
     get_skb_tcpdata(skb, &ptcp, &tcplen);
     ptran = ptcp+tranoff;
 
@@ -216,7 +220,7 @@
         {
             t->dst.u.udp.port = htons(loport);
 #ifdef CONFIG_RTSP_ALG_FIX
-	    exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	    exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
 	    exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
 	    exp->dir = !dir;
 #endif
@@ -237,7 +241,7 @@
         {
             t->dst.u.udp.port = htons(loport);
 #ifdef CONFIG_RTSP_ALG_FIX
-	exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
 	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
 	exp->dir = !dir;
 #endif
@@ -259,7 +263,7 @@
         {
             t->dst.u.udp.port = htons(loport);
 #ifdef CONFIG_RTSP_ALG_FIX
-	exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
 	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
 	exp->dir = !dir;
 #endif
@@ -273,7 +277,7 @@
         {
             t->dst.u.udp.port = htons(hiport);
 #ifdef CONFIG_RTSP_ALG_FIX
-	exp->tuple.dst.u.udp.port = t.dst.u.udp.port ;
+	exp->tuple.dst.u.udp.port = t->dst.u.udp.port ;
 	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
 	exp->dir = !dir;
 #endif
Index: linux/net/netfilter/nf_conntrack_ftp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_ftp.c	2010-12-08 20:02:51.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_ftp.c	2010-12-08 21:53:43.395850048 +0530
@@ -490,14 +490,10 @@
 			  IPPROTO_TCP, NULL, &cmd.u.tcp.port);
 
 #ifdef CONFIG_FTP_ALG_FIX
-exp->mask = (struct nf_conntrack_tuple)
-	    { .src = { .l3num = 0xFFFF,
-		       .u = { .tcp = { .port = 0 }},
-	   	     },
-	     .dst = { .protonum = 0xFF,
-		      .u = { .tcp = { .port = __constant_htons(0xFFFF) }},
-	             };
-	    };
+//exp->mask.src.l3num = 0xFFFF;
+exp->mask.src.u.tcp.port  = 0;
+//exp->mask.dst.protonum = 0xFF;
+//exp->mask.dst.u.tcp.port = __constant_htons(0xFFFF);
 #endif
 
 	/* Now, NAT might want to mangle the packet, and register the
Index: linux/net/netfilter/nf_conntrack_pptp.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_pptp.c	2010-12-08 20:02:51.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_pptp.c	2010-12-08 20:34:14.195850123 +0530
@@ -503,7 +503,11 @@
 
 {
 	int dir = CTINFO2DIR(ctinfo);
+#ifdef CONFIG_PPTP_ALG_FIX
+	struct nf_ct_pptp_master *info = &nfct_help(ct)->help.ct_pptp_info;
+#else
 	const struct nf_ct_pptp_master *info = &nfct_help(ct)->help.ct_pptp_info;
+#endif
 	const struct tcphdr *tcph;
 	struct tcphdr _tcph;
 	const struct pptp_pkt_hdr *pptph;
@@ -529,7 +533,7 @@
 
 #ifdef CONFIG_PPTP_ALG_FIX
 	if (tcph->fin || tcph->rst) {
-		DEBUGP("RST/FIN received, timeouting GRE\n");
+		pr_debug("RST/FIN received, timeouting GRE\n");
 		/* can't do this after real newnat */
 		info->cstate = PPTP_CALL_NONE;
 		/* untrack this call id, unexpect GRE packets */
Index: linux/net/ipv4/netfilter/nf_nat_mms.c
===================================================================
--- linux.orig/net/ipv4/netfilter/nf_nat_mms.c	2010-12-08 20:02:51.000000000 +0530
+++ linux/net/ipv4/netfilter/nf_nat_mms.c	2010-12-08 20:56:47.565849451 +0530
@@ -74,7 +74,7 @@
 {
 	u_int32_t newip;
 	struct nf_conn *ct = expect->master;
-	struct iphdr *iph = skb->nh.iph;
+	struct iphdr *iph = ip_hdr(skb); //skb->nh.iph;
 	struct tcphdr *tcph = (void *) iph + iph->ihl * 4;
 	char *data = (char *)tcph + tcph->doff * 4;
 	int i, j, k, port;
Index: linux/net/ipv4/netfilter/nf_nat_talk.c
===================================================================
--- linux.orig/net/ipv4/netfilter/nf_nat_talk.c	2010-12-08 20:02:51.000000000 +0530
+++ linux/net/ipv4/netfilter/nf_nat_talk.c	2010-12-08 20:58:25.845850150 +0530
@@ -76,7 +76,7 @@
 	      struct talk_addr *addr,
 	      struct talk_addr *ctl_addr)
 {
-	struct iphdr *iph = (*pskb)->nh.iph;
+	struct iphdr *iph = ip_hdr(*pskb); //(*pskb)->nh.iph;
 	struct udphdr *udph = (void *)iph + iph->ihl * 4;
 	size_t udplen = (*pskb)->len - iph->ihl * 4;
 
Index: linux/net/netfilter/nf_conntrack_mms.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_mms.c	2010-12-08 20:02:51.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_mms.c	2010-12-08 21:44:19.524599905 +0530
@@ -136,7 +136,7 @@
 	/* IP address ? */
 	*mms_ip = asciiiptoi(tempstring+2);
 
-	i=sprintf(getlengthstring, "%u.%u.%u.%u", HIPQUAD(*mms_ip));
+	i=sprintf(getlengthstring, "%u.%u.%u.%u", NIPQUAD(*mms_ip));
 
 	/* protocol ? */
 	if(strncmp(tempstring+3+i, "TCP", 3)==0)
@@ -177,9 +177,11 @@
 	struct nf_ct_mms_expect _emmi, *exp_mms_info = &_emmi;
 	struct nf_conntrack_man cmd = {};
 	u_int32_t mms_ip;
+	union nf_inet_addr *mms_ip_addr;	
 	u_int16_t mms_proto;
 	char mms_proto_string[8];
 	u_int16_t mms_port;
+	__be16 mms_port_t;
 	char *mms_string_b, *mms_string_e, *mms_padding_e;
 
 	/* Until there's been traffic both ways, don't look in packets. */
@@ -305,9 +307,12 @@
 		{ { 0xFFFFFFFF, { 0 } },
 		  { 0xFFFFFFFF, { .tcp = { 0xFFFF } }, 0xFF }});*/
 
+	mms_ip_addr = (union nf_inet_addr *)&mms_ip;
+	mms_port_t = (__be16)htons(mms_port);
 	nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
 			&ct->tuplehash[!dir].tuple.src.u3,
-			mms_ip, mms_proto, NULL, &htons(mms_port));
+			mms_ip_addr, mms_proto, NULL, 
+			&mms_port_t);
 
 //               exp->tuple.src.u3 =  ct->tuplehash[!dir].tuple.src.u3;
                 exp->mask.src.u3.ip = 0xffffffff;
@@ -342,7 +347,7 @@
 static struct nf_conntrack_helper mms[MAX_PORTS];
 static char mms_names[MAX_PORTS][10];
 
-static const struct nf_conntrack_expect_policy mms_exp_policy {
+static const struct nf_conntrack_expect_policy mms_exp_policy = {
 		.max_expected   = 1,
 		.timeout        = 120,
 };
@@ -371,8 +376,9 @@
 		mms[i].tuple.src.l3num = PF_INET;
 		mms[i].tuple.src.u.tcp.port = htons(ports[i]);
 		mms[i].tuple.dst.protonum = IPPROTO_TCP;
-		mms[i].mask.src.u.tcp.port = 0xFFFF;
-		mms[i].mask.dst.protonum = 0xFF;
+		//mms[i].mask.src.u.tcp.port = 0xFFFF; //mask field not present
+		//in nf_conntrack_helper
+		//mms[i].mask.dst.protonum = 0xFF;
 		mms[i].expect_policy = &mms_exp_policy;
 		mms[i].me = THIS_MODULE;
 		mms[i].help = help;
Index: linux/net/netfilter/nf_conntrack_talk.c
===================================================================
--- linux.orig/net/netfilter/nf_conntrack_talk.c	2010-12-08 20:02:51.000000000 +0530
+++ linux/net/netfilter/nf_conntrack_talk.c	2010-12-08 22:27:00.875850091 +0530
@@ -182,7 +182,7 @@
 		nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
 				&ct->tuplehash[dir].tuple.src.u3,
 				&ct->tuplehash[dir].tuple.dst.u3,
-				IPPROTO_UDP, NULL, exp_talk_port);
+				IPPROTO_UDP, NULL, (__be16 *)&exp_talk_port);
 
         /*        exp->tuple.src.u3 =  ct->tuplehash[dir].tuple.src.u3;              
                 exp->mask.src.u3.ip = 0xffffffff;*/
@@ -248,8 +248,8 @@
 				sizeof(cmd.u3.all));
 		nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
 				&ct->tuplehash[dir].tuple.src.u3,
-				&addr->ta_addr,
-				IPPROTO_UDP, NULL, exp_talk_port);
+				(union nf_inet_addr *)&addr->ta_addr,
+				IPPROTO_UDP, NULL, (__be16 *)&exp_talk_port);
 		/*
                 exp->tuple.src.u3 =  ct->tuplehash[!dir].tuple.src.u3;
                 exp->mask.src.u3.ip = 0xffffffff;*/
@@ -297,7 +297,7 @@
 		     struct nf_conn *ct,
 		     enum ip_conntrack_info ctinfo,
 		     int talk_port,
-		     u_char mode)
+		     u_char mode, unsigned int protoff)
 {
 	//struct udphdr *udph = (void *)iph + iph->ihl * 4;
 	//const char *data = (const char *)udph + sizeof(struct udphdr);
@@ -339,15 +339,15 @@
 	
 
  	  /* Not whole UDP header? */
-        uh = skb_header_pointer(*pskb, (*pskb)->nh.iph->ihl*4,
+        uh = skb_header_pointer(*pskb, protoff,
                                 sizeof(udph), &udph);
         if (uh == NULL) {
                 DEBUGP("ip_ct_talk_help: short for udph\n");
                 return NF_ACCEPT;
         }
 
-        udplen = (*pskb)->len - (*pskb)->nh.iph->ihl*4;
-        dataoff = (*pskb)->nh.iph->ihl*4 + sizeof(udph);
+        udplen = (*pskb)->len - protoff ; //(*pskb)->nh.iph->ihl*4;
+        dataoff = protoff + sizeof(udph);
         if (dataoff >= (*pskb)->len)
                 return NF_ACCEPT;
 
@@ -431,7 +431,7 @@
 {
 	 struct sk_buff **pskb;
 	 *pskb = skb;
-	return talk_help(pskb, ct, ctinfo, TALK_PORT, LOOK_UP);
+	return talk_help(pskb, ct, ctinfo, TALK_PORT, LOOK_UP, protoff);
 }
 
 int lookup_nhelp(struct sk_buff *skb, unsigned int protoff,
@@ -439,7 +439,7 @@
 {
 	struct sk_buff **pskb;
 	*pskb = skb;
-	return talk_help(pskb, ct, ctinfo, NTALK_PORT, LOOK_UP);
+	return talk_help(pskb, ct, ctinfo, NTALK_PORT, LOOK_UP, protoff);
 }
 
 #if 0
@@ -484,10 +484,10 @@
         .tuple.src.u.udp.port   = __constant_htons(TALK_PORT),
         .tuple.dst.protonum     = IPPROTO_UDP,
         .tuple.dst.u.udp.port   = 0,
-        .mask.src.l3num         = 0xffff,
-        .mask.src.u.udp.port    = __constant_htons(0xffff),
-        .mask.dst.protonum      = 0xff,
-        .mask.dst.u.udp.port    = 0xffff,
+       // .mask.src.l3num         = 0xffff,
+        //.mask.src.u.udp.port    = __constant_htons(0xffff),
+        //.mask.dst.protonum      = 0xff,
+        //.mask.dst.u.udp.port    = 0xffff,
         .help                   = lookup_help,
 
 
@@ -501,10 +501,10 @@
         .tuple.src.u.udp.port   = __constant_htons(NTALK_PORT),
         .tuple.dst.protonum     = IPPROTO_UDP,
         .tuple.dst.u.udp.port   = 0,
-        .mask.src.l3num         = 0xffff,
-        .mask.src.u.udp.port    = __constant_htons(0xffff),
-        .mask.dst.protonum      = 0xff,
-        .mask.dst.u.udp.port    = 0xffff,
+        //.mask.src.l3num         = 0xffff,
+        //.mask.src.u.udp.port    = __constant_htons(0xffff),
+        //.mask.dst.protonum      = 0xff,
+        //.mask.dst.u.udp.port    = 0xffff,
         .help                   = lookup_nhelp,
 
 
@@ -541,13 +541,13 @@
 static int help(struct sk_buff **pskb,unsigned int protoff,
 		struct nf_conn *ct, enum ip_conntrack_info ctinfo)
 {
-	return talk_help(pskb, ct, ctinfo, TALK_PORT, ANNOUNCE);
+	return talk_help(pskb, ct, ctinfo, TALK_PORT, ANNOUNCE, protoff);
 }
 
 static int nhelp(struct sk_buff **pskb,unsigned int protoff,
 		 struct nf_conn *ct, enum ip_conntrack_info ctinfo)
 {
-	return talk_help(pskb, ct, ctinfo, NTALK_PORT, ANNOUNCE);
+	return talk_help(pskb, ct, ctinfo, NTALK_PORT, ANNOUNCE, protoff);
 }
 
 #if 0
@@ -578,39 +578,34 @@
 
 #endif
 
-static const struct nf_conntrack_expect_policy talk_exp_policy = {
-		.max_expected   = 1,
-		.timeout        = 120,
-};
-
 static struct nf_conntrack_helper talk_helpers[2] = {
        {
         .name                   = "talk",
         .me                     = THIS_MODULE,
-	.expect_policy 		= &talk_exp_policy;
+	.expect_policy 		= &talk_exp_policy,
         .tuple.src.l3num        = PF_INET,
         .tuple.src.u.udp.port   = __constant_htons(TALK_PORT),
         .tuple.dst.protonum     = IPPROTO_UDP,
         .tuple.dst.u.udp.port   = 0,
-        .mask.src.l3num         = 0xffff,
-        .mask.src.u.udp.port    = __constant_htons(0xffff),
-        .mask.dst.protonum      = 0xff,
-        .mask.dst.u.udp.port    = 0xffff, 
+  //      .mask.src.l3num         = 0xffff,
+    //    .mask.src.u.udp.port    = __constant_htons(0xffff),
+     //   .mask.dst.protonum      = 0xff,
+      //  .mask.dst.u.udp.port    = 0xffff, 
         .help                   = help,
         
         },
         {
  	.name                   = "ntalk",
         .me                     = THIS_MODULE,
-	.expect_policy          = &talk_exp_policy;
+	.expect_policy          = &talk_exp_policy,
         .tuple.src.l3num        = PF_INET,
         .tuple.src.u.udp.port   = __constant_htons(NTALK_PORT),
         .tuple.dst.protonum     = IPPROTO_UDP,
         .tuple.dst.u.udp.port   = 0,
-        .mask.src.l3num         = 0xffff,
-        .mask.src.u.udp.port    = __constant_htons(0xffff),
-        .mask.dst.protonum      = 0xff,
-        .mask.dst.u.udp.port    = 0xffff,
+       // .mask.src.l3num         = 0xffff,
+       // .mask.src.u.udp.port    = __constant_htons(0xffff),
+       // .mask.dst.protonum      = 0xff,
+       // .mask.dst.u.udp.port    = 0xffff,
         .help                   = nhelp,
 
         }
