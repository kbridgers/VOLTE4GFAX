# HG changeset patch
# Parent 91ecfd92fc480b33d95663006eef1ba240f119be
Files in the scripts_platform directory
05/10/2011 bugfix for mk_mlc_image.pl
* * *
HN1 only: added support for GPHY Firmware in a separate partition.

diff --git a/scripts_platform/Kconfig b/scripts_platform/Kconfig
new file mode 100755
--- /dev/null
+++ b/scripts_platform/Kconfig
@@ -0,0 +1,905 @@
+#
+# For a description of the syntax of this configuration file,
+# see Linux Documentation
+#
+#
+
+config IFX_UBOOT_OPTIMIZED
+      bool
+      default y
+
+config CONFIG_REMOVE_GZIP
+      bool
+    default y
+
+config CONFIG_IFX_MIPS
+      bool
+      default y
+
+config CROSS_COMPILE_UCLIBC
+      bool
+      default y
+
+config LANTIQ_UART
+	  bool
+	  default y
+          depends on !LANTIQ_UBOOT_vbg400
+
+menu "Build Options"
+
+choice
+    prompt 'Boot From'
+
+config BOOT_FROM_NOR
+    bool "NOR Flash"
+    select ENV_IS_IN_FLASH
+	depends on !DRIVER_HN1 && !DRIVER_AR10 
+
+config BOOT_FROM_SPI
+    bool "SPI Flash"
+    select ENV_IS_IN_SPI_FLASH
+    select SPI_FLASH
+    help
+    Boots from SPI flash.
+
+config BOOT_FROM_NAND
+    bool "NAND Flash"
+    select NAND_FLASH
+    select NAND_U_BOOT
+	help
+    Boots from NAND flash.
+
+
+config BOOT_FROM_ETHERNET
+    bool "ETHERNET"
+	select ENV_IS_NOWHERE
+    help
+    Boots from ethernet port.
+    depends on !DRIVER_HN1
+	
+config BOOT_FROM_UART
+    bool "UART"
+    select ENV_IS_IN_FLASH
+    help
+    Boots from asc port.
+	depends on !DRIVER_HN1
+
+config BOOT_WITH_NO_FLASH
+    bool "NO FLASH"
+    select ENV_IS_NOWHERE
+    depends on !DRIVER_HN1
+
+endchoice
+
+config ENV_IS_NOWHERE
+    bool 
+	default n
+
+config ENV_IS_IN_FLASH
+    bool
+
+config ENV_IS_IN_SPI_FLASH
+    bool
+
+config ENV_IS_IN_NAND
+    bool
+	default y
+	depends on BOOT_FROM_NAND && !ENV_IS_NOWHERE
+
+config ENV_IS_NOWHERE
+    bool
+
+config NAND_U_BOOT
+    bool
+
+config RAM_TEXT_BASE
+    hex  
+	default "0xA0400000"
+
+config BOOTSTRAP_TEXT_BASE
+    hex
+	default "0x80100000" if ( BOOT_FROM_NAND )
+	default "0xB0000000" if ( BOOT_FROM_NOR )
+    default "0xa0100000" if ( BOOT_FROM_SPI && !LANTIQ_UBOOT_vbg400 )
+    default "0xA0800000" if ( LANTIQ_UBOOT_vbg400 )
+
+config NAND_PRELOAD_TEXT_BASE
+	hex
+	default "0xbe1a0000" if LANTIQ_UBOOT_ar9
+	default "0xbe220000" if LANTIQ_UBOOT_vr9
+	default "0xbf280000" if LANTIQ_UBOOT_hn1
+	default "0xbe1a0000" if LANTIQ_UBOOT_ar10
+
+config NAND_SPL_TEXT_BASE
+    hex 
+	default "0xBE1a0400"  if LANTIQ_UBOOT_ar9
+    default "0xBE220400"  if ( LANTIQ_UBOOT_vr9 && NAND_PRELOAD )
+	default "0xbe220000"  if ( LANTIQ_UBOOT_vr9 && !NAND_PRELOAD )
+    default "0xBF280400"  if LANTIQ_UBOOT_hn1
+	default "0xBE1A0000"  if LANTIQ_UBOOT_ar10 
+	depends on BOOT_FROM_NAND
+
+config SFDDR_TEXT_BASE
+	hex 
+	default "0xbe1a0000" if LANTIQ_UBOOT_ar9
+	default "0xbe220500" if LANTIQ_UBOOT_vr9
+	default "0xbf280500" if LANTIQ_UBOOT_hn1
+	depends on BOOT_FROM_SPI
+
+choice
+     prompt "OS COMPRESSION TYPE"
+     default OS_LZMA
+
+config OS_GZIP
+     bool "GZIP"
+
+config OS_LZMA
+     bool "LZMA"
+
+config OS_LZO
+     bool "LZO"
+
+config OS_BZIP2
+     bool "BZIP2"
+
+endchoice
+						   
+
+config LTQ_SECURE_BOOT
+	bool "SECURE BOOT"
+	default n
+	depends on DRIVER_VR9 || DRIVER_AR10 
+    depends on !BOOT_FROM_NOR
+	depends on !NAND_PRELOAD
+
+config AES_KEY
+    string "aes key"
+	default "0000000000000000000000000000000000000000000000000000000000000000"
+	depends on LTQ_SECURE_BOOT
+
+config LTQ_IMAGE_EXTRA_CHECKS
+    bool "IMAGE EXTRA CHECK"
+	default n
+
+config AUTOBOOT_KEYED
+    bool "AUTOBOOT KEYED"
+	default n
+
+config AUTOBOOT_DELAY_STR
+    string "AUTOBOOT PASSWORD"
+    default ""
+    depends on AUTOBOOT_KEYED
+
+config SILENT_CONSOLE
+    bool "Silent console support"
+	default n
+
+config SUPPRESS_KERNEL_OUTPUT
+    bool "suppress kernel output"
+	default n
+	depends on SILENT_CONSOLE
+
+config VENDOR_NAME
+    string 
+	default "LANTIQ"
+	depends on LTQ_IMAGE_EXTRA_CHECKS
+
+config SW_VERSION
+    string 
+	default "4.2.0"
+	depends on LTQ_IMAGE_EXTRA_CHECKS
+
+config DEBUG
+    bool "VERBOSE"
+	default n
+
+endmenu
+
+menu "Board Settings"
+
+config IFX_MEMORY_SIZE
+        int "RAM Size(M)"
+        default 32
+
+config BAUDRATE
+  int "ASC BAUDRATE"
+  default 115200
+
+config NOR_FLASH
+        bool "NOR FLASH SUPPORT"
+        default y
+        select CMD_FLASH
+        depends on !DRIVER_AR10 && !DRIVER_HN1
+
+config SYS_NO_FLASH
+       bool
+	   default y
+	   depends on !NOR_FLASH
+
+config FLASH_CFI_DRIVER
+       bool
+	   default y
+	   depends on NOR_FLASH
+
+config SYS_FLASH_CFI
+       bool
+	   default y
+	   depends on NOR_FLASH
+
+config FLASH_CFI_MTD
+	   bool "MTD SUPPORT"
+	   default n
+	   depends on NOR_FLASH
+
+choice
+     prompt "NOR Flash Size(M)"
+     depends on BOOT_FROM_NOR
+     default NOR_FLASH_8M
+
+config NOR_FLASH_8M
+     bool "8M"
+
+config NOR_FLASH_4M
+     bool "4M"
+
+config NOR_FLASH_2M
+     bool "2M"
+
+config NOR_FLASH_AUTO
+     bool "auto detect"
+
+endchoice
+
+
+config SPI_FLASH
+      bool "SPI FLASH SUPPORT"
+        select LANTIQ_SPI
+      select CMD_SF
+
+choice
+     prompt "SPI Flash Size(M)"
+	 depends on BOOT_FROM_SPI
+	 default SPI_FLASH_4M
+
+config SPI_FLASH_16M
+     bool "16M"
+
+config SPI_FLASH_8M
+     bool "8M"
+
+config SPI_FLASH_4M
+     bool "4M"
+
+config SPI_FLASH_2M
+     bool "2M"
+
+config SPI_FLASH_1M
+     bool "1M"
+
+endchoice
+							  
+
+config SPI_FLASH_ATMEL
+        bool "ATMEL SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_STMICRO
+        bool  "STMICRO SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_SST
+        bool "SST SFLASH SUPPORT"
+        depends on SPI_FLASH
+
+config SPI_FLASH_SPANSION
+        bool "SPANSION SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_MXIC
+        bool "MXIC SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config LANTIQ_SPI
+        bool
+
+config  SF_DEFAULT_SPEED
+        int "SPI FLASH BAUDRATE(Hz)"
+    default "1000000"
+        depends on SPI_FLASH
+
+config SF_DEFAULT_MODE
+        int "SFLASH SPI MODE"
+    default "0"
+    depends on LANTIQ_SPI
+
+config SPI_EEPROM
+        bool "SPI EEPROM SUPPORT"
+    select CMD_EEPROM
+    select LANTIQ_SPI
+    select SPI_EEPROM_ATMEL
+
+
+config SPI_EEPROM_ATMEL
+        bool "ATMEL 250X0 SUPPORT"
+        depends on SPI_EEPROM
+
+
+config  EEPROM_DEFAULT_SPEED
+        int "EEPROM BAUDRATE(Hz)"
+    default "1000000"
+    depends on SPI_EEPROM
+
+config  EEPROM_DEFAULT_MODE
+        int "EEPROM SPI MODE"
+        default "0"
+        depends on SPI_EEPROM
+
+
+config NAND_FLASH
+      bool "NAND FLASH_SUPPORT"
+      select CMD_NAND
+      select NAND_LANTIQ
+
+choice 
+      prompt "ECC MODE"
+	  depends on NAND_FLASH
+	  default NAND_ECC_SOFT
+
+config NAND_ECC_SOFT
+       bool "SOFTWARE"
+	  
+config NAND_ECC_HW_HAMMING
+       bool "HARDWARE HAMMING"
+
+config NAND_ECC_HW_REED_SOLOMON
+       bool "HARDWARE REED SOLOMON"
+
+endchoice
+
+choice 
+     prompt "ECC LOCATION"
+     depends on NAND_ECC_HW_REED_SOLOMON
+     default NAND_HW_ECC_SPARE_AREA
+
+config NAND_HW_ECC_SPARE_AREA
+      bool "ECC IN OOB AREA"
+
+config NAND_HW_ECC_EMBEDDED
+      bool "ECC EMBEDDED IN DATA AREA"
+	  
+endchoice
+
+choice
+     prompt "ECC LENGTH"
+     depends on NAND_ECC_HW_REED_SOLOMON
+	 default NAND_ECC_HW_4BYTES
+
+config NAND_ECC_HW_4BYTES
+     bool "4 bytes"
+
+config NAND_ECC_HW_3BYTES
+     bool "3 bytes"
+
+endchoice
+
+
+config MLC_NAND_HEADER_NUMBER
+      int "MLC NAND HEADER NUMBER"
+	  default 1
+	  depends on BOOT_FROM_NAND && NAND_ECC_HW_REED_SOLOMON
+
+config NAND_ECC_HW
+	  bool
+	  depends on NAND_ECC_HW_HAMMING || NAND_ECC_HW_REED_SOLOMON
+	  default y
+
+config NAND_BBT_SCAN
+        bool "BAD NAND BLOCK SCAN"
+        depends on NAND_FLASH
+
+config NAND_LANTIQ
+       bool
+       depends on NAND_FLASH
+
+if LANTIQ_UBOOT_ar10 
+config NAND_CS0
+       bool "NAND FLASH ON CS0"
+	   default y
+	   depends on NAND_FLASH 
+endif 
+
+choice
+     prompt "NAND Flash Size(M)"
+	 depends on BOOT_FROM_NAND
+	 default NAND_FLASH_4M
+
+config NAND_FLASH_4096M
+	 bool "4096M" 
+
+config NAND_FLASH_2048M
+     bool "2048M"
+
+config NAND_FLASH_1024M
+     bool "1024M"
+
+config NAND_FLASH_512M
+     bool "512M"
+
+config NAND_FLASH_256M
+     bool "256M"
+
+config NAND_FLASH_128M
+     bool "128M"
+
+config NAND_FLASH_64M
+     bool "64M"
+
+config NAND_FLASH_32M
+     bool "32M"
+
+config NAND_FLASH_8M
+     bool "8M"
+
+config NAND_FLASH_4M
+     bool "4M"
+
+config NAND_FLASH_2M
+     bool "2M"
+
+endchoice
+
+
+config NAND_FLASH_SIZE
+    hex 
+	default "2" if ( NAND_FLASH_2M )
+	default "4" if ( NAND_FLASH_4M )
+	default "8" if ( NAND_FLASH_8M )
+	default "32" if ( NAND_FLASH_32M )
+	default "64" if ( NAND_FLASH_64M )
+	default "128" if ( NAND_FLASH_128M )
+	default "256" if ( NAND_FLASH_256M )
+	default "512" if ( NAND_FLASH_512M )
+	default "1024" if ( NAND_FLASH_1024M )
+	default "2048" if ( NAND_FLASH_2048M )
+	default "4096" if ( NAND_FLASH_4096M )
+	
+config NAND_PAGE_SIZE
+     hex "NAND flash page size(bytes in hex)"
+     default "0x200"
+     depends on BOOT_FROM_NAND
+
+config NAND_BLOCK_SIZE
+	 hex "NAND flash erase block size(bytes in hex)"
+	 default "0x40000"
+	 depends on BOOT_FROM_NAND
+
+config NAND_SPL_BLOCK_SIZE
+     hex "NAND SPL IMAGE SIZE(bytes in hex)"
+	 default "0x4000"
+	 depends on BOOT_FROM_NAND && !NAND_ECC_HW_REED_SOLOMON 
+	 depends on !LTQ_SECURE_BOOT
+
+config NAND_PRELOAD
+     bool "nand mini loader"
+	 default y
+	 depends on BOOT_FROM_NAND && !NAND_ECC_HW_REED_SOLOMON
+
+config FIRMWARE_IN_ROOTFS
+     bool "firmware in rootfs"
+     default n
+
+config OVERLAY
+	 bool "overlay fs support"
+	 default n
+	 depends on DRIVER_VR9 || DRIVER_AR9 || DRIVER_DANUBE
+
+if LANTIQ_UBOOT_ar9
+   source board/ar9/Kconfig
+endif
+
+if LANTIQ_UBOOT_danube
+   source board/danube/Kconfig
+endif
+
+if LANTIQ_UBOOT_amazon_se
+   source board/amazon_se/Kconfig
+endif
+
+if LANTIQ_UBOOT_vr9
+   source board/vr9/Kconfig
+endif
+
+if LANTIQ_UBOOT_hn1
+   source board/hn1/Kconfig
+endif
+
+if LANTIQ_UBOOT_ar10 
+   source board/ar10/Kconfig
+endif
+   
+endmenu
+
+
+menu "Network Settings"
+config IP_ADDRESS
+    string "IP address"
+    default "192.168.1.1"
+
+config SERVER_IP_ADDRESS
+    string "Server IP address"
+    default "192.168.1.2"
+
+config ETHERNET_ADDRESS
+    string "Ethernet Address"
+    default "00:E0:92:00:01:40"
+
+config ETHERNET_DEVICE
+    string "Ethernet Interface"
+    default "eth0"
+endmenu
+
+menu "Environment Settings"
+
+config ENV_SIZE
+	hex "env size"
+	default "0x4000"
+	depends on BOOT_FROM_NAND
+
+config ENV_REDUND
+    bool "redundant env"
+	default no
+
+config ENV_OVERWRITE
+	bool "enable env overwrite"
+	default y
+
+config BUILD_ENV_BLOCK
+    bool "build env block image"
+	default n
+
+config TFTP_LOAD_ADDRESS
+    string "tftp load address"
+    default "0x80800000"
+    
+config MEM
+    string "mem"
+    default "31M"
+
+config PHYM
+    string "phym"
+    default "32M"
+
+config WLANM
+    string "wlanm"
+	default "30M"
+	depends on DRIVER_AR10
+
+config BOOTDELAY
+    int "BOOTDELAY(seconds)"
+	default 5
+
+config ROOT_PATH
+    string "rootpath"
+    default "/mnt/full_fs"
+
+
+config CONSOLE
+    string "console"
+	default "ttyS0" if ( LANTIQ_UBOOT_vbg400 )
+	default "ttyS1" if ( !LANTIQ_UBOOT_vbg400 )
+
+config TFTPPATH
+    string "tftppath"
+	default ""
+
+config ROOTFSMTD
+    string "rootfsmtd" 
+	default "/dev/mtdblock1" if ( FIRMWARE_IN_ROOTFS && !BOOT_FROM_NAND )
+	default "/dev/mtdblock2" if ( !FIRMWARE_IN_ROOTFS && !BOOT_FROM_NAND && !LANTIQ_UBOOT_hn1)
+	default "/dev/mtdblock3" if ( !FIRMWARE_IN_ROOTFS && !BOOT_FROM_NAND && LANTIQ_UBOOT_hn1)
+	default "/dev/mtdblock2" if ( FIRMWARE_IN_ROOTFS && BOOT_FROM_NAND )
+	default "/dev/mtdblock3" if ( !FIRMWARE_IN_ROOTFS && BOOT_FROM_NAND )
+
+config NFSARGS
+    string "nfsargs"
+    default "setenv bootargs root=/dev/nfs rw nfsroot=$(serverip):$(rootpath)"
+
+config RAMARGS
+    string "ramargs"
+    default "setenv bootargs root=/dev/ram rw"
+
+config FLASHARGS
+    string "flashargs"
+    default "setenv bootargs root=$(rootfsmtd) ro rootfstype=squashfs init=/etc/preinit"
+
+config ADDIP
+    string "addip"
+    default "setenv bootargs $(bootargs) ip=$(ipaddr):$(serverip):$(gatewayip):$(netmask):$(hostname):$(netdev):on"
+
+config ADDMISC
+    string "addmisc"
+	default "setenv bootargs $(bootargs) console=$(console),$(baudrate) ethaddr=$(ethaddr) phym=$(phym) mem=$(mem) panic=1 mtdparts=$(mtdparts)" 
+
+config BOOTFILE
+    string "bootfile"
+    default "uImage"
+
+config U_BOOT
+    string "u-boot"
+    default "u-boot.ltq"
+
+config ROOTFS
+    string "rootfs"
+    default "rootfs.img"
+
+config FIRMWARE
+    string "firmware"
+    default "firmware.img"
+
+config FULLIMAGE
+    string "fullimage"
+	default "fullimage.img"
+
+config TOTALIMAGE
+    string "totalimage"
+	default "totalimage.img"
+
+config MTDIDS
+    string "mtdids"
+	default "nand0=ifx_nand"
+	depends on CMD_MTDPARTS 
+
+
+config USE_DEFAULT_MTDPARTS
+    bool "use default MTDPARTS"
+	default y
+
+
+if LANTIQ_UBOOT_danube
+config MTDPARTS
+    string
+	default "ifx_nor0:64k(uboot),256k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && !OVERLAY )
+  default "ifx_nor0:64k(uboot),256k(firmware),7424k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && OVERLAY )
+  default "ifx_nor0:64k(uboot),8000k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && !OVERLAY)
+  default "ifx_nor0:64k(uboot),7680k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && OVERLAY )
+	default "ifx_nor0:64k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	default "" if ( NOR_FLASH_AUTO )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_amazon_se
+config MTDPARTS
+    string
+    default "ifx_nor0:64k(uboot),3904k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_NOR && NOR_FLASH_4M && FIRMWARE_IN_ROOTFS )  
+    default "ifx_nor0:64k(uboot),192k(firmware),3796k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_NOR && NOR_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),256k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),8000k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),3904k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),192k(firmware),3796k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64kk(uboot),192k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_SPI && SPI_FLASH_8M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),-(rootfs)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:64k(uboot),-(rootfs)" if ( BOOT_FROM_NAND && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:64k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_NAND && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	default "" if ( NOR_FLASH_AUTO )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_vbg400
+config MTDPARTS
+    string
+	default "ifx_sflash:64k(uboot),3904k(rootfs),64k(sysconfig),8k(ubootconfig),8k(wlanconfig),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),8000k(rootfs),64k(sysconfig),8k(ubootconfig),8k(wlanconfig),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_8M && FIRMWARE_IN_ROOTFS )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_ar9
+config MTDPARTS
+    string
+	default "ifx_nor0:64k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_NOR && NOR_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),3904k(rootfs),32k(sysconfig),4k(ubootconfig),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),256k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && !OVERLAY )
+  default "ifx_nor0:64k(uboot),256k(firmware),7424k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && OVERLAY )
+  default "ifx_nor0:64k(uboot),8000k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && !OVERLAY )
+  default "ifx_nor0:64k(uboot),7680k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && OVERLAY )
+  default "ifx_sflash:128k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_SPI && SPI_FLASH_1M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),192k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_SPI && SPI_FLASH_8M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),-(rootfs)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:128k(uboot),2688k(kernel),28800k(rootfs),64k(sysconfig),16k(ubootconfig),16k(fwdiag),-(res)" if ( BOOT_FROM_NAND && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:128k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_NAND && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	default "" if ( NOR_FLASH_AUTO )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+
+if LANTIQ_UBOOT_vr9
+config MTDPARTS
+    string 
+	default "ifx_nor0:128k(uboot),7936k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && FIRMWARE_IN_ROOTFS && !OVERLAY )
+	default "ifx_nor0:128k(uboot),7616k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && FIRMWARE_IN_ROOTFS && OVERLAY )
+	default "ifx_nor0:128k(uboot),512k(firmware),7424k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && !FIRMWARE_IN_ROOTFS && !OVERLAY )
+	default "ifx_nor0:128k(uboot),512k(firmware),7104k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && !FIRMWARE_IN_ROOTFS && OVERLAY )
+	default "ifx_sflash:128k(uboot),512k(firmware),-(rootfs)" if ( SPI_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),512k(firmware),7424k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( SPI_FLASH_8M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),7936k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+  default "ifx_nand:256k(uboot),2560k(kernel),111872k(rootfs),256k(sysconfig),256k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:256k(uboot),512k(firmware),2m(kernel),111872k(rootfs),256k(sysconfig),256k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:128k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+if LANTIQ_UBOOT_hn1
+config MTDPARTS
+    string 
+	default "ifx_sflash:64k(uboot),64k(gphyfirmware),512k(firmware),-(rootfs)" if ( BOOT_FROM_SPI && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),64k(gphyfirmware),-(rootfs)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),2560k(kernel),111872k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_128M && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),512k(firmware),2m(kernel),111872k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_128M && !FIRMWARE_IN_ROOTFS )	
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),2560k(kernel),505088k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_512M && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),512k(firmware),2048k(kernel),505088k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_512M && !FIRMWARE_IN_ROOTFS )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+if LANTIQ_UBOOT_ar10 
+config MTDPARTS
+    string 
+    default "ifx_nand:64k(uboot),-(rootfs)"
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+config MTDPARTS
+    string "MTDPARTS"
+	default "ifx_nor0:64k(uboot),-(rootfs)"
+	depends on !USE_DEFAULT_MTDPARTS
+
+
+config NET_RAM
+    string "net_ram"
+    default "tftp $(loadaddr) $(tftppath)$(bootfile); run ramargs addip addmisc; bootm"
+
+config NET_FLASH
+    string "net_flash"
+    default "tftp $(loadaddr) $(tftppath)$(bootfile); run flashargs addip addmisc; bootm"
+
+config FLASH_NFS
+    string "flash_nfs"
+    default "run nfsargs addip addmisc;bootm $(kernel_addr)"
+
+config NET_NFS
+    string "net_nfs"
+    default "tftp $(loadaddr) $(tftppath)$(bootfile);run nfsargs addip addmisc;bootm"
+
+config FLASH_FLASH
+    string "flash_flash"
+    default "run flashargs addip addmisc; bootm $(kernel_addr)"
+
+config UPDATE_NANDBOOT
+    string "update_nandboot"
+	default "tftp $(loadaddr) $(tftppath)u-boot-nand.bin; nand erase clean 0 0x08000000; nand write $(loadaddr) 0 $(filesize)"
+	depends on BOOT_FROM_NAND
+
+config UPDATE_UBOOT
+    string "update_uboot"
+    default "tftpboot $(loadaddr) $(tftppath)$(u-boot);erase b0000000 b001ffff;cp.b $(loadaddr) b0000000 $(filesize);reset"
+
+config UPDATE_BOOTLOADER
+    string "update_bootloader"
+	default "update_uboot" if LANTIQ_UBOOT_ar9 
+	default "update_uboot;update gphyfirmware" if LANTIQ_UBOOT_vr9 
+	default "update_uboot;update gphyfirmware" if LANTIQ_UBOOT_ar10 
+	default "update_uboot"
+
+config UPDATE_KERNEL
+    string "update_kernel"
+    default "tftpboot $(loadaddr) $(tftppath)$(bootfile);upgrade $(loadaddr) $(filesize)"
+
+config UPDATE_ROOTFS
+    string "update_rootfs"
+    default "tftpboot $(loadaddr) $(tftppath)$(rootfs); upgrade $(loadaddr) $(filesize)"
+
+config UPDATE_FIRMWARE
+    string "update_firmware"
+    default "tftpboot $(loadaddr) $(tftppath)$(firmware);upgrade $(loadaddr) $(filesize)"
+    depends on !FIRMWARE_IN_ROOTFS
+
+config UPDATE_GPHYFIRMWARE
+    string "update_gphyfirmware"
+	default "tftpboot $(loadaddr) $(tftppath)gphy_firmware.img;nand write.partial $(loadaddr) 24000 10000" if ( !VR9_GPHY_FW_EMBEDDED )
+	default "tftpboot $(loadaddr) $(tftppath)gphy_firmware.img; sf probe 3; sf erase 0x10000 0x10000; sf write $(loadaddr) 0x10000 $(filesize)" if ( LANTIQ_UBOOT_hn1 && !HN1_GPHY_FW_EMBEDDED && BOOT_FROM_SPI)
+	default "tftpboot $(loadaddr) $(tftppath)gphy_firmware.img; nand write.partial $(loadaddr) 0x24000 10000" if ( LANTIQ_UBOOT_hn1 && !HN1_GPHY_FW_EMBEDDED && BOOT_FROM_NAND)
+	depends on !VR9_GPHY_FW_EMBEDDED && !HN1_GPHY_FW_EMBEDDED && !AR10_GPHY_FW_EMBEDDED
+
+config UPDATE_FULLIMAGE
+    string "update_fullimage"
+	default "tftpboot $(loadaddr) $(tftppath)$(fullimage);upgrade $(loadaddr) $(filesize)"
+
+config UPDATE_TOTALIMAGE
+    string "update_totalimage"
+	default "tftpboot $(loadaddr) $(tftppath)$(totalimage);upgrade $(loadaddr) $(filesize)"
+
+config UBI_INIT
+  string "ubi_init"
+	default "ubi part data;setenv kernelA_vol_id 0;setenv rootfsA_vol_id 1;setenv firmwareA_vol_id 2;setenv kernelB_vol_id 3;setenv rootfsB_vol_id 4;setenv firmwareB_vol_id 5;setenv setbank check_image$(update_chk);run $(setbank)"
+	depends on CMD_UBI 
+
+config DUAL_IMAGE
+  bool "dual image support"
+  default n
+  depends on BOOT_FROM_NAND
+ 
+config UPDATE_CHK
+  string "update_chk"
+  default "0"
+  depends on DUAL_IMAGE
+ 
+config SWITCH_BANKA
+  string "switchbankA"
+  default "setenv active_bank A;setenv kernel_vol kernelA_vol;setenv rootfs_vol rootfsA_vol;setenv firmware_vol firmwareA_vol;setenv rootfsmtd /dev/mtdblock5"  
+  depends on DUAL_IMAGE
+
+config SWITCH_BANKB
+  string "switchbankB"
+  default "setenv active_bank B;setenv kernel_vol kernelB_vol;setenv rootfs_vol rootfsB_vol;setenv firmware_vol firmwareB_vol;setenv rootfsmtd /dev/mtdblock7"
+  depends on DUAL_IMAGE
+
+config CHECK_IMAGE0
+  string "check_image0"
+  default "run switchbankA"
+  depends on DUAL_IMAGE
+  
+config CHECK_IMAGE1
+  string "check_image1"
+  default "run switchbankB;setenv update_chk 0;save"
+  depends on DUAL_IMAGE
+  
+config CHECK_IMAGE2
+  string "check_image2"
+  default "run switchbankB"
+  depends on DUAL_IMAGE
+  
+config CHECK_IMAGE3
+  string "check_image3"
+  default "run switchbankA;setenv update_chk 2;save"
+  depends on DUAL_IMAGE
+      
+config BOOTCOMMAND
+    string "bootcmd"
+	default "run flash_flash"
+
+config RESET_UBOOT_CONFIG
+	string    
+	default "prot off $(f_ubootconfig_addr) $(f_ubootconfig_end); erase $(f_ubootconfig_addr) $(f_ubootconfig_end)" if ( BOOT_FROM_NOR )
+	default "sf probe 3; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar9 ) 
+	default "sf probe 0; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_amazon_se )
+	default "sf probe 3; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_vr9 )
+	default "sf probe 3; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_hn1 )
+	default "sf probe 0; sf write A0400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_vbg400 )
+	default "sf probe 0; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar10 )
+	default "nand write.partial 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)" if ( BOOT_FROM_NAND )
+
+config RESET_DDR_CONFIG
+    string
+	default "prot off $(f_ddrconfig_addr) $(f_ddrconfig_end); erase $(f_ddrconfig_addr) $(f_ddrconfig_end)" if ( BOOT_FROM_NOR )
+    default "sf probe 3; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar9 )
+    default "sf probe 0; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_amazon_se	)
+    default "sf probe 3; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_vr9 )
+    default "sf probe 3; sf read 0x80800000 0x0 0x10000; mw 0x8080ffe8 0xffffffff 0x6; sf erase 0x0 0x10000; sf write 0x80800000 0x0 0x10000"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_hn1 )
+    default "sf probe 0; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar10 )
+	default "nand write.partial 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)" if ( BOOT_FROM_NAND )
+					
+config RESET_SYSCONFIG
+    string 
+	default "erase $(f_sysconfig_addr) 10000" if BOOT_FROM_NOR 
+	default "sf probe 0;sf erase $(f_sysconfig_addr) 10000" if BOOT_FROM_SPI && ( LANTIQ_UBOOT_ar10 || LANTIQ_UBOOT_vbg400 || LANTIQ_UBOOT_amazon_se )
+	default "sf probe 3;sf erase $(f_sysconfig_addr) 10000" if BOOT_FROM_SPI && ( LANTIQ_UBOOT_vr9 || LANTIQ_UBOOT_ar9 || LANTIQ_UBOOT_hn1 )
+	default "run ubi_init;ubi remove sysconfig;ubi remove sysconfigA;ubi remove sysconfigB" if ( BOOT_FROM_NAND && CMD_UBI )
+
+endmenu
+
+
+source lib/Kconfig
+source common/Kconfig
diff --git a/scripts_platform/big_nand_gct b/scripts_platform/big_nand_gct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/big_nand_gct
@@ -0,0 +1,52 @@
+# shell script for making u-boot image for big nand flash
+# Written by Wu Qi Ming Qi-Ming.Wu@infineon.com
+
+#!/bin/sh
+
+
+FILESIZE=0
+PADSIZE=0
+TARGET_FILE=u-boot.nand
+MINIBOOTROM=scripts_platform/minibootrom.img
+#modify this for different page size
+NAND_PAGE_SIZE=2048
+
+
+scripts_platform/sgct scripts_platform/minibootrom/dummy scripts_platform/minibootrom/bootrom.rec ${MINIBOOTROM}
+
+cat ${MINIBOOTROM} >${TARGET_FILE}
+
+FILESIZE=`ls -l ${TARGET_FILE} | awk '{print $5}'`  
+
+
+PADSIZE=`expr ${NAND_PAGE_SIZE} - ${FILESIZE}`
+
+
+dd if=/dev/zero of=zero bs=${PADSIZE} count=1
+
+cat zero >>${TARGET_FILE}
+
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' $2 | awk '{printf "%s %s\n", $1, $2}' >tmp
+
+scripts_platform/gen_ram.pl tmp ram_tmp
+
+cat ram_tmp >>${TARGET_FILE}
+
+FILESIZE=`ls -l ${TARGET_FILE} | awk '{print $5}'`
+
+
+PADSIZE=`expr ${NAND_PAGE_SIZE} + ${NAND_PAGE_SIZE} - ${FILESIZE}`
+
+
+dd if=/dev/zero of=zero bs=${PADSIZE} count=1
+
+cat zero >>${TARGET_FILE}
+
+cat $3 >>${TARGET_FILE}
+
+rm -rf tmp ram_tmp zero ${MINIBOOTROM} 
+
+
+
+
+
diff --git a/scripts_platform/build_asc.pl b/scripts_platform/build_asc.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/build_asc.pl
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+
+if(@ARGV < 3){
+	print "\n not enough arguments";
+	print "\n Syntax: build_asc.pl ram.conf data.bin offset u-boot.asc\n";
+    exit;
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+
+binmode INFILE2;
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+           }
+        }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+                   printf OUTFILE "00"x8;
+		   $i=$i+1;
+		   }
+
+$i=0;
+$addr=$ARGV[2];
+$addr=hex($addr);
+$chsum=0x0;
+
+while (read (INFILE2, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+     printf OUTFILE ("\n%08x",$addr);
+	 $chsum+=$addr;
+	 $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $chsum+=$data;
+}
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+
+$chsum=$chsum & 0xffffffff;
+
+printf OUTFILE ("\n11111111");
+printf OUTFILE ("%08x",$chsum);
+$i=0;
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+
+printf OUTFILE ("\n99999999");
+
+printf OUTFILE ("%08x",hex($ARGV[2]));
+
+$i=0;
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+printf OUTFILE ("\n");
+
+close(INFILE1);
+close(INFILE2);
+close(OUTFILE);
diff --git a/scripts_platform/duplicate.sh b/scripts_platform/duplicate.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/duplicate.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+#duplicate file to a specific times
+#Revision history
+#19/09/2011 Author: Wu Qi Ming Qi-Ming.Wu@infineon.com
+
+COUNTER=1
+TARGETFILE=$2
+
+cp $TARGETFILE tmp 
+
+while [ $COUNTER -lt $1 ]; do
+  echo "duplicate!"
+  cat $TARGETFILE >> tmp
+  COUNTER=$(($COUNTER+1))
+done
+
+cp tmp $2
+rm tmp
diff --git a/scripts_platform/eegct b/scripts_platform/eegct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/eegct
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+#perl script to generate spi bootable u-boot
+#Revision history
+#03/27/08 Author Wu Qi Ming
+
+my $SPI_MAGIC=0xAA55;
+my $PHY1=0x1;
+my $PHY0=0x0;
+my $MAC0=0x2c;
+my $MAC1=0x02;
+my $MAC2=0x00;
+my $MAC3=0x92;
+my $MAC4=0xe0;
+my $MAC5=0x00;
+my $VALID=0x1; #always valid
+my $OFFSET=0x0c;
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+	print "Syntax: ./sgct input output\n";
+	print "example: ./sgct ddr_setting.conf u-boot.srec u-boot.sflash\n";
+	exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=sprintf("%08x",($SPI_MAGIC<<16)|($PHY1<<8)|($PHY0));
+$head=$head.sprintf("%08x",($MAC3<<24)|($MAC2<<16)|($MAC1<<8)|($MAC0));
+$head=$head.sprintf("%08x",($OFFSET<<24)|($VALID<<16)|($MAC5)|($MAC4));
+printf OUTFILE pack("H*",$head);
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+
+printf OUTFILE pack("H*",$string);
+$string="";
+$firsttime=1;
+$count=0;
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if($aline=~/^S0/);
+        ($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+        $length = hex($length);
+        $address = hex($address);
+	$i=0;
+        if($lineid eq "S3")
+        { 
+         if($firsttime==1)
+          {
+             $addstr = sprintf("%08x", $address+1); 
+             $string=$addstr;
+             $loadaddr=$address;
+             $firsttime=0;
+          }
+          $length=$length-4;
+          while($length>1){
+           $bytes[$i]=~tr/ABCDEF/abcdef/;
+	   #printf ("length=%d,i=%d,byte=%02x\n",$length,$i,hex(@bytes[$i]));
+           $string=$string.@bytes[$i];
+           #printf ("string=%s\n",$string);
+	   $length=$length-1;
+           $i=$i+1;
+           $count++;
+          }
+        }
+        elsif($lineid eq "S7")
+        {
+           $exehead=sprintf("%08x",0xffffffff).sprintf("%08x",$address);
+	   #print $exehead
+        }
+}
+
+
+
+
+if($firsttime==1){
+    $string=sprintf("%08x",3);
+    printf OUTFILE pack("H*",$string);
+}
+else{
+   printf("addstr=%s\n",$addstr); 
+   printf OUTFILE pack("H*",$addstr);
+   printf OUTFILE pack("H*",sprintf("%08x",$count/4));
+   #printf OUTFILE pack("H*",$string);
+   @bytes=unpack"A2"x$count,$string;
+   for ($i=0;$i<$count;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+   printf OUTFILE pack("H*",$exehead);
+}
+
+
+
+
+
diff --git a/scripts_platform/gct b/scripts_platform/gct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/gct
@@ -0,0 +1,157 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+
+if(@ARGV < 2){
+	print "\n not enough arguments";
+	print "\n Syntax: ./gct input output\n";
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+               }
+             }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+                   printf OUTFILE "00"x8;
+		   $i=$i+1;
+		   }
+        if($i eq 8){
+	printf OUTFILE ("\n");
+        }
+
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if(($aline=~/^S0/) || ($aline=~/^S7/));
+	($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+	$length = hex($length);
+	$address = hex($address);
+	$length -=5;
+	$i=0;
+
+	while($length>0){
+		if($firstime==1){
+				$addstr = sprintf("%x", $address);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$firstime=0;
+				$currentaddr=$address;
+				$loadaddr = $addstr;
+		}
+		else{
+			if($count==64){
+				$addstr = sprintf("%x", $currentaddr);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$count=0;
+			}
+		}
+		while($count<64){
+		        $bytes[$i]=~tr/ABCDEF/abcdef/;
+			print OUTFILE "$bytes[$i]";
+			addchsum($bytes[$i]);
+			$i++;
+			$count++;
+			$length--;
+			last if($length==0);
+		}
+		if($count==64){
+			print OUTFILE "\n";
+			#print OUTFILE "\r";
+			$currentaddr+=64;
+		}
+	}
+}
+if($count != 64){
+	$tmp = "00";
+	for($i=0;$i<(64-$count);$i++){
+		print OUTFILE "00";
+		addchsum($tmp);
+	}
+	print OUTFILE "\n";
+	#print OUTFILE "\r";
+}
+
+
+print OUTFILE "11"x4;
+use integer;
+$chsum=$chsum & 0xffffffff;
+$chsum = sprintf("%X", $chsum);
+$chsum = "0"x(8-length($chsum)).$chsum;
+$chsum =~tr/ABCDEF/abcdef/;
+print OUTFILE $chsum;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+print OUTFILE "99"x4;
+print OUTFILE $loadaddr;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+
+close OUTFILE;
+#END of Program
+
+
+
+sub addchsum{
+	my $cc=$_[0];
+	$holder=$holder.$cc;
+	if(length($holder)==8){
+		$holder = hex($holder);
+		$chsum+=$holder;
+		$holder="";
+	}
+}
+#END
+
+
diff --git a/scripts_platform/gen_ram.pl b/scripts_platform/gen_ram.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/gen_ram.pl
@@ -0,0 +1,21 @@
+#!/usr/bin/perl
+#perl script to generate ram parameters for big nand flash
+#Revision history
+#7/7/08 Author Wu Qi Ming
+
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[1]") || die("\nOutput file open fail\n");
+
+$string="";
+while ($line = <INFILE1>){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+		  $addr=@array[0];
+	          $regval=@array[1];
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+}
+
+printf OUTFILE pack("H*",$string);
+
diff --git a/scripts_platform/hn1_ddr.pl b/scripts_platform/hn1_ddr.pl
new file mode 100644
--- /dev/null
+++ b/scripts_platform/hn1_ddr.pl
@@ -0,0 +1,103 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+####################################################################################################
+# this perl script is used to convert vr9 chiptest/palladium image to support new ddr model in vr9 #
+####################################################################################################
+# Identical with vr9_ddr.pl and intented to be used for HN1                                        #
+####################################################################################################
+
+my $versioninfo = "V1.0.0 29 Oct 2008";
+
+my $infile = "";
+my $outfile = "";
+
+my $read_line;
+my $line1;
+my $line2;
+my $line3;
+my $line4;
+
+#
+# Verify the input/output parameters 
+#
+
+if (($#ARGV + 1) != 2 ) {
+    die "Usage: $0 <input asc file> <output asc file>\n"
+}
+
+$infile = shift(@ARGV);
+$outfile = shift(@ARGV);
+
+#
+# Read/Write file handler
+#
+open (INFILE, $infile) || go_die("Can't open $infile fo read :$!", 1);
+
+open (OUTFILE, ">$outfile") || go_die("Can't open $outfile for write :$!", 1);
+
+#
+# Force it to binary mode 
+#
+binmode (INFILE);
+
+binmode (OUTFILE);
+
+#
+# to skip @00000000, so that it still inherits the original address
+#
+$read_line = <INFILE>;  
+print OUTFILE $read_line;
+while (1) {
+    
+    if (eof(INFILE)){
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }
+    $line1 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line2 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }   
+    $line3 = <INFILE>;
+    
+    if (eof(INFILE)){
+        print OUTFILE $line3;
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line4 = <INFILE>;    
+    
+    print OUTFILE $line3;
+    print OUTFILE $line4;
+    print OUTFILE $line1;
+    print OUTFILE $line2;
+
+}
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message) {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+    
+    print " done\n";
+    exit (0);
+}
+
+
+
diff --git a/scripts_platform/mk_eeprom.pl b/scripts_platform/mk_eeprom.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_eeprom.pl
@@ -0,0 +1,77 @@
+#!/usr/bin/perl
+#perl script to generate an bootable image for eeprom
+#Revision history
+#03/27/08 Author Wu Qi Ming
+
+my $SPI_MAGIC=0xAA55;
+my $PHY1=0x1;
+my $PHY0=0x0;
+my $MAC0=0x2c;
+my $MAC1=0x02;
+my $MAC2=0x00;
+my $MAC3=0x92;
+my $MAC4=0xe0;
+my $MAC5=0x00;
+my $VALID=0x1; #always valid
+my $OFFSET=0x0c;
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+    print "Syntax: ./mk_eeprom.pl config data address output\n";
+	print "example: ./mk_eeprom.pl ram.conf u-boot.ifx 0xa0100000 u-boot.eeprom\n";
+    exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=sprintf("%08x",($SPI_MAGIC<<16)|($PHY1<<8)|($PHY0));
+$head=$head.sprintf("%08x",($MAC3<<24)|($MAC2<<16)|($MAC1<<8)|($MAC0));
+$head=$head.sprintf("%08x",($OFFSET<<24)|($VALID<<16)|($MAC5)|($MAC4));
+printf OUTFILE pack("H*",$head);
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+
+printf OUTFILE pack("H*",$string);
+
+
+$datafile_size=(-s $ARGV[1]);
+$datafile_size=sprintf("%08x",$datafile_size/4);
+$start_address=sprintf("%08x",hex($ARGV[2])+1);
+printf OUTFILE pack("H*",$start_address.$datafile_size);
+
+binmode(INFILE2,":raw");
+binmode(OUTFILE,":raw");
+
+read(INFILE2,$buf,(-s $ARGV[1]));
+print OUTFILE $buf;
+
+$exehead=sprintf("%08x",0xffffffff);
+$start_address=sprintf("%08x",hex($ARGV[2]));
+
+printf OUTFILE pack("H*", $exehead.$start_address);
+
diff --git a/scripts_platform/mk_envimg.sh b/scripts_platform/mk_envimg.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_envimg.sh
@@ -0,0 +1,56 @@
+#!/bin/bash
+#Build uboot environment block image
+#To be used in u-boot root directory of UGW package
+#Copyright (C) 2007-2010 Lantiq Asia Pacific Pte. Ltd
+#Revision history
+#10/07/2012 Wu Qi Ming Qi-Ming.Wu@lantiq.com
+#Usage: mk_envimg.sh target_file
+
+packhex(){
+    PACK_DATA_LEN=`echo $1 |wc -c`
+    let PACK_DATA_LEN=$PACK_DATA_LEN-1
+    PACK_START=1
+    PACK_RESULT=
+    while [ $PACK_START -le $PACK_DATA_LEN ]
+    do
+      PACK_TMP=`echo $1 | awk '{print substr($0, '$PACK_START', 2)}'`
+      PACK_RESULT="${PACK_RESULT}\x${PACK_TMP}"
+      let PACK_START=$PACK_START+2
+    done
+    echo $PACK_RESULT
+}
+
+
+OUTPUT=$1
+
+ADDRHEX=`sed -e '/default_environment/!d' u-boot.sym |awk '{print substr($1,length($1)-4,5)}'`
+
+ADDR=`echo $((16#$ADDRHEX))`
+
+
+LENHEX=`sed -e '/default_environment/!d' u-boot.sym |awk '{print $2}'`
+
+LEN=`echo $((16#$LENHEX))`
+
+
+dd if=u-boot.bin of=env.tmp ibs=1 skip=$ADDR count=$LEN
+
+CRC=`tools/envcrc env.tmp`
+
+echo -en `packhex $CRC` >$OUTPUT
+
+REDUND=`grep -r CONFIG_ENV_REDUND .config | awk -F'=' '{print $2}'`
+
+if [ "$REDUND" = "y" ];then
+   echo -en "\x0" >>$OUTPUT
+fi
+
+cat env.tmp >>$OUTPUT
+
+CONFIG_ENV_SIZE=`strings env.tmp | grep f_ubootconfig_size=|awk -F'=' '{print $2}'`
+
+scripts_platform/pad2align.sh -n $CONFIG_ENV_SIZE $OUTPUT
+
+rm -rf env.tmp
+
+
diff --git a/scripts_platform/mk_hn1_nand.sh b/scripts_platform/mk_hn1_nand.sh
new file mode 100644
--- /dev/null
+++ b/scripts_platform/mk_hn1_nand.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/hn1/bootrom.rec u-boot.nand
+scripts_platform/pad2align.sh -n 2048 u-boot.nand
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.nand
+cat u-boot.ifx >>u-boot.nand
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mk_hn1_sf.sh b/scripts_platform/mk_hn1_sf.sh
new file mode 100644
--- /dev/null
+++ b/scripts_platform/mk_hn1_sf.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/hn1/sf_bootrom.rec u-boot.sflash
+scripts_platform/pad2align.sh -n 2048 u-boot.sflash
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.sflash
+cat u-boot.ifx >>u-boot.sflash
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mk_mlc_image.pl b/scripts_platform/mk_mlc_image.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_mlc_image.pl
@@ -0,0 +1,132 @@
+#!/usr/bin/perl
+
+# only works on LINUX (not for Windows)
+# this perl script does the following:
+# 1. copy input file to output file.
+# 2. pads output file to filesize 0x8000. 
+# 3. add checksum to end of file. 
+
+use strict;
+use bigint;
+
+use File::stat;
+
+
+#********************************************************************************************
+
+$ARGV[0] || go_die();
+$ARGV[1] || go_die();
+
+my $infile = $ARGV[0];
+my $outfile = $ARGV[1];
+
+my $csum = 0;
+my $csum1;
+
+my $stat;
+
+my $zero = 0;
+
+my $OUTPUTFILE;
+
+my $INFILE;
+my $WIDTH;
+my $packFormat;
+my $pack;
+my $buf;
+
+my $stat;
+
+#********************************************************************************************
+
+
+if ($stat = stat $infile) {
+    print "$infile is ", $stat->size, " bytes\n";
+} else {
+    go_die("Can't open $infile for read", 1);
+}
+
+open ($INFILE, $infile) || go_die("Can't open $infile fo read",1);
+
+binmode $INFILE;
+
+$WIDTH = 4;   # number of bytes to read per loop
+$packFormat  = "H" . 2 * $WIDTH;  # must use big "H" ie high nibble first
+
+# compute U32 addition checksum
+while ( read $INFILE, $buf, $WIDTH )
+{
+    $pack = unpack $packFormat, $buf;
+
+    #$pack = sprintf("%08X", hex($pack));  # change to upper case
+    $pack = hex($pack);
+    
+    $csum += $pack;
+    $csum &= 0xFFFFFFFF;
+}
+
+
+system ("cp $infile $outfile");
+
+open ($OUTPUTFILE, ">>$outfile") || go_die("Can't open $outfile for write",1);
+
+binmode $OUTPUTFILE;
+
+my $pad_cnt = $stat->size;
+
+if ($pad_cnt > (0x8000 - 4))
+{
+    go_die("$infile is too big for MLC image", 1);
+}
+
+if ($pad_cnt != 0)
+{
+    $pad_cnt = 0x8000 - $pad_cnt - 4;
+}
+
+$zero = pack("C", $zero);   # note that data is saved in little-endian on Intel-based PC 
+while ($pad_cnt > 0)
+{
+    print $OUTPUTFILE $zero;
+    $pad_cnt--;
+}
+
+$csum = (($csum & 0x000000FF) << 24) | (($csum & 0x0000FF00) << 8) | (($csum & 0x00FF0000) >> 8) | (($csum & 0xFF000000) >> 24);
+$csum = pack("L", $csum);   # note that data is saved in little-endian on Intel-based PC 
+print $OUTPUTFILE $csum;
+
+close ($OUTPUTFILE);
+
+if ($stat = stat $outfile) {
+    print "$outfile is ", $stat->size, " bytes\n";
+} else {
+    go_die("Can't open $outfile for read", 1);
+}
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message)
+    {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+
+    unless ($supressformat)
+    {
+        print "format is: \n";
+        print " perl mk_mlc_image.pl original.bin mlc.bin\n";
+    }
+    else
+    {
+       print "----------------------------------------------------------\n";
+    }
+
+    die ("\n");
+}
+
diff --git a/scripts_platform/mk_sf.pl b/scripts_platform/mk_sf.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_sf.pl
@@ -0,0 +1,89 @@
+#!/usr/bin/perl
+#perl script to generate spi bootable u-boot using binary file
+#Revision history
+#1/7/2009 Author Wu Qi Ming
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+	print "Syntax: ./mk_sf.pl config data address output\n";
+	print "example: ./mk_sf.pl ram.conf u-boot.ifx 0xa0100000 u-boot.sflash\n";
+	exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+$head=$head|(0xffff-($head>>16));
+
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+printf OUTFILE pack("H*",$head.$string);
+
+#form a TAG_DWNLD head
+$head=$TAG_DWNLD|$FLAG_SDBG|$FLAG_START;
+$head=$head|(0xffff-($head>>16));
+$head=sprintf("%08x",$head);
+$datafile_size=(-s $ARGV[1]) + 4;
+#printf "datafilesize=$datafile_size\n";
+$datafile_size=sprintf("%08x",$datafile_size);
+$start_address=sprintf("%08x",hex($ARGV[2]));
+printf OUTFILE pack("H*",$head.$datafile_size.$start_address);
+binmode(INFILE2,":raw");
+binmode(OUTFILE,":raw");
+#while(<INFILE2>){
+#  printf OUTFILE $_;
+#}
+read(INFILE2,$buf,(-s $ARGV[1]));
+print OUTFILE $buf;
+
+$exehead=$TAG_START|$FLAG_SDBG;
+$exehead=$exehead|(0xffff-($exehead>>16));
+$exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,hex($ARGV[2]));
+
+printf OUTFILE pack("H*", $exehead);
diff --git a/scripts_platform/mk_vr9_nand.sh b/scripts_platform/mk_vr9_nand.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_vr9_nand.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/vr9/bootrom.rec u-boot.nand
+scripts_platform/pad2align.sh -n 2048 u-boot.nand
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.nand
+cat u-boot.ifx >>u-boot.nand
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mk_vr9_sf.sh b/scripts_platform/mk_vr9_sf.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_vr9_sf.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/vr9/sf_bootrom.rec u-boot.sflash
+scripts_platform/pad2align.sh -n 2048 u-boot.sflash
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.sflash
+cat u-boot.ifx >>u-boot.sflash
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/pad2align.sh b/scripts_platform/pad2align.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/pad2align.sh
@@ -0,0 +1,64 @@
+#!/bin/bash
+#pad file to align with specific alignments
+#Revision history
+#30/4/2009 Author: Wu Qi Ming Qi-Ming.Wu@infineon.com
+#26/08/2011 Modified to accept hex number input  Wu Qi Ming Qi-Ming.Wu@lantiq.com
+
+Usage(){
+  echo "Usage: pad2align [option]...[file]..."
+  echo "Pad file to align with specified number of bytes"
+  echo "-n  --number bytes    specify alignment boundary"
+  echo "-h  --help            print help information"
+  return
+}
+
+ALIGNMENT=
+ALIGNFILE=
+
+parse_args() {
+  while [ "$#" -gt "0" ]
+  do
+     case $1 in
+	        --number | -n)
+		        ALIGNMENT=$2
+		        ALIGNFILE=$3		
+				;;
+			--help | -h)
+				Usage
+				exit 1
+				;;
+	 esac			
+	 shift
+  done
+  return
+}
+ 
+
+
+parse_args $@
+
+if [ "$ALIGNFILE" == "" ]; then
+      echo "no file specified!"
+	  exit 1;
+fi
+
+TMP=`echo $2 | sed -n "/0x/p"`
+if [ "$TMP" ];
+then
+   TMP=`echo $2 | sed "s/0x//g"`
+   ALIGNMENT=`echo 'ibase=16;' $TMP | bc`
+else
+   ALIGNMENT=$2
+fi
+
+
+FILESIZE=`wc -c $ALIGNFILE | awk '{print $1}'`
+MODULO=`expr $FILESIZE % $ALIGNMENT`
+
+
+if [ $MODULO != 0 ];then
+  PADSIZE=`expr $ALIGNMENT - $MODULO` 
+  dd if=/dev/zero of=tmppad bs=$PADSIZE count=1 
+  cat tmppad >>$ALIGNFILE
+  rm tmppad
+fi
diff --git a/scripts_platform/sgct b/scripts_platform/sgct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/sgct
@@ -0,0 +1,131 @@
+#!/usr/bin/perl
+#perl script to generate spi bootable u-boot
+#Revision history
+#03/27/08 Author Wu Qi Ming
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+	print "Syntax: ./sgct input output\n";
+	print "example: ./sgct ddr_setting.conf u-boot.srec u-boot.sflash\n";
+	exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+$head=$head|(0xffff-($head>>16));
+
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+printf OUTFILE pack("H*",$head.$string);
+
+#form a TAG_DWNLD head
+$head=$TAG_DWNLD|$FLAG_SDBG|$FLAG_START;
+$head=$head|(0xffff-($head>>16));
+
+$firsttime=1;
+$count=0;
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if($aline=~/^S0/);
+        ($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+        $length = hex($length);
+        $address = hex($address);
+	$i=0;
+        if($lineid eq "S3")
+        { 
+         if($firsttime==1)
+          {
+             $addstr = sprintf("%x", $address); 
+             $count=$count+4;
+             
+             $string=$addstr;
+             $loadaddr=$address;
+             $firsttime=0;
+          }
+          $length=$length-4;
+          while($length>1){
+           $bytes[$i]=~tr/ABCDEF/abcdef/;
+	   #printf ("length=%d,i=%d,byte=%02x\n",$length,$i,hex(@bytes[$i]));
+           $string=$string.@bytes[$i];
+           #printf ("string=%s\n",$string);
+	   $length=$length-1;
+           $i=$i+1;
+           $count++;
+          }
+        }
+        elsif($lineid eq "S7")
+        {
+           $exehead=$TAG_START|$FLAG_SDBG;
+           $exehead=$exehead|(0xffff-($exehead>>16));
+           $exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,$address);
+	   #print $exehead
+        }
+}
+
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count);
+@bytes=unpack"A2"x8,$head;
+for ($i=0;$i<8;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+@bytes=unpack"A2"x$count,$string;
+for ($i=0;$i<$count;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+@bytes=unpack"A2"x12,$exehead;
+for ($i=0;$i<12;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+
+
+
+
+
diff --git a/scripts_platform/swap_bin.pl b/scripts_platform/swap_bin.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/swap_bin.pl
@@ -0,0 +1,25 @@
+#!/usr/bin/perl
+
+if(@ARGV < 2){
+     die("\n not enough arguments\n Syntax: ./swap_bin.pl input output\n");
+	}
+		
+open(INFILE, "<$ARGV[0]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[1]") || die("\nOutput file open fail\n");
+
+binmode INFILE;
+binmode OUTFILE;
+
+
+while (read (INFILE, $buffer, 4))
+{
+   ($b1,$b2,$b3,$b4)=unpack("C*",$buffer);
+   
+   print OUTFILE pack("C*",$b4);
+   print OUTFILE pack("C*",$b3);
+   print OUTFILE pack("C*",$b2);
+   print OUTFILE pack("C*",$b1);
+};
+
+close INFILE;
+close OUTFILE;
diff --git a/scripts_platform/vr9_ddr.pl b/scripts_platform/vr9_ddr.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/vr9_ddr.pl
@@ -0,0 +1,101 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+####################################################################################################
+# this perl script is used to convert vr9 chiptest/palladium image to support new ddr model in vr9 #
+####################################################################################################
+
+my $versioninfo = "V1.0.0 29 Oct 2008";
+
+my $infile = "";
+my $outfile = "";
+
+my $read_line;
+my $line1;
+my $line2;
+my $line3;
+my $line4;
+
+#
+# Verify the input/output parameters 
+#
+
+if (($#ARGV + 1) != 2 ) {
+    die "Usage: $0 <input asc file> <output asc file>\n"
+}
+
+$infile = shift(@ARGV);
+$outfile = shift(@ARGV);
+
+#
+# Read/Write file handler
+#
+open (INFILE, $infile) || go_die("Can't open $infile fo read :$!", 1);
+
+open (OUTFILE, ">$outfile") || go_die("Can't open $outfile for write :$!", 1);
+
+#
+# Force it to binary mode 
+#
+binmode (INFILE);
+
+binmode (OUTFILE);
+
+#
+# to skip @00000000, so that it still inherits the original address
+#
+$read_line = <INFILE>;  
+print OUTFILE $read_line;
+while (1) {
+    
+    if (eof(INFILE)){
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }
+    $line1 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line2 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }   
+    $line3 = <INFILE>;
+    
+    if (eof(INFILE)){
+        print OUTFILE $line3;
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line4 = <INFILE>;    
+    
+    print OUTFILE $line3;
+    print OUTFILE $line4;
+    print OUTFILE $line1;
+    print OUTFILE $line2;
+
+}
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message) {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+    
+    print " done\n";
+    exit (0);
+}
+
+
+
