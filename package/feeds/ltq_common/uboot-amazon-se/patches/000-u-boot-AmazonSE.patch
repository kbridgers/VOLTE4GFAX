Patch for Amazon-SE, based on RT-3.5.2

Only minimal changes done, to allow sync with sources from Taiwan.

--- a/MAKEALL
+++ b/MAKEALL
@@ -14,8 +14,8 @@
 	LOG_DIR="LOG"
 fi
 
-if [ ! "${BUILD_DIR}" ] ; then
-	BUILD_DIR="."
+if [ ! "${UBOOT_BUILD_DIR}" ] ; then
+	UBOOT_BUILD_DIR="."
 fi
 
 [ -d ${LOG_DIR} ] || mkdir ${LOG_DIR} || exit 1
@@ -318,7 +318,7 @@
 	${MAKE} ${JOBS} all 2>&1 >${LOG_DIR}/$target.MAKELOG \
 				| tee ${LOG_DIR}/$target.ERR
 
-	${CROSS_COMPILE:-ppc_8xx-}size ${BUILD_DIR}/u-boot \
+	${CROSS_COMPILE:-ppc_8xx-}size ${UBOOT_BUILD_DIR}/u-boot \
 				| tee -a ${LOG_DIR}/$target.MAKELOG
 }
 
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 1
 PATCHLEVEL = 1
 SUBLEVEL = 5
-EXTRAVERSION =
+EXTRAVERSION = -1.0.4
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 VERSION_FILE = $(obj)include/version_autogenerated.h
 
@@ -44,6 +44,25 @@
 # Deal with colliding definitions from tcsh etc.
 VENDOR=
 
+# Default algorithm form compressing u-boot.bin
+ifndef COMPRESS
+COMPRESS=none
+COMPRESS_FILE=$(obj)u-boot.img
+else
+ifeq ($(COMPRESS),lzma)
+COMPRESS_FILE=$(obj)u-boot.limg
+endif
+ifeq ($(COMPRESS),bz2)
+COMPRESS_FILE=$(obj)u-boot.bzimg
+endif
+ifeq ($(COMPRESS),gzip)
+COMPRESS_FILE=$(obj)u-boot.zimg
+endif
+ifeq ($(COMPRESS),none)
+COMPRESS_FILE=$(obj)u-boot.img
+endif
+endif
+
 #########################################################################
 #
 # U-boot build supports producing a object files to the separate external
@@ -52,15 +71,15 @@
 # 1) Add O= to the make command line
 # 'make O=/tmp/build all'
 #
-# 2) Set environement variable BUILD_DIR to point to the desired location
-# 'export BUILD_DIR=/tmp/build'
+# 2) Set environement variable UBOOT_BUILD_DIR to point to the desired location
+# 'export UBOOT_BUILD_DIR=/tmp/build'
 # 'make'
 #
 # The second approach can also be used with a MAKEALL script
-# 'export BUILD_DIR=/tmp/build'
+# 'export UBOOT_BUILD_DIR=/tmp/build'
 # './MAKEALL'
 #
-# Command line 'O=' setting overrides BUILD_DIR environent variable.
+# Command line 'O=' setting overrides UBOOT_BUILD_DIR environent variable.
 #
 # When none of the above methods is used the local build is performed and
 # the object files are placed in the source directory.
@@ -68,22 +87,23 @@
 
 ifdef O
 ifeq ("$(origin O)", "command line")
-BUILD_DIR := $(O)
+UBOOT_BUILD_DIR := $(O)
 endif
 endif
 
-ifneq ($(BUILD_DIR),)
-saved-output := $(BUILD_DIR)
+ifneq ($(UBOOT_BUILD_DIR),)
+saved-output := $(UBOOT_BUILD_DIR)
 
 # Attempt to create a output directory.
-$(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})
+$(shell [ -d ${UBOOT_BUILD_DIR} ] || mkdir -p ${UBOOT_BUILD_DIR})
 
 # Verify if it was successful.
-BUILD_DIR := $(shell cd $(BUILD_DIR) && /bin/pwd)
-$(if $(BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))
-endif # ifneq ($(BUILD_DIR),)
+UBOOT_BUILD_DIR := $(shell cd $(UBOOT_BUILD_DIR) && /bin/pwd)
+$(if $(UBOOT_BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))
+endif # ifneq ($(UBOOT_BUILD_DIR),)
 
-OBJTREE		:= $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR))
+OBJTREE		:= $(if $(UBOOT_BUILD_DIR),$(UBOOT_BUILD_DIR),$(CURDIR))
+#OBJTREE		:= $(CURDIR)
 SRCTREE		:= $(CURDIR)
 TOPDIR		:= $(SRCTREE)
 LNDIR		:= $(OBJTREE)
@@ -164,6 +184,11 @@
 # U-Boot objects....order is important (i.e. start must be first)
 
 OBJS  = cpu/$(CPU)/start.o
+OBJS_BOOTSTRAP  = cpu/$(CPU)/start_bootstrap.o
+
+cpu/$(CPU)/start_bootstrap.S: cpu/$(CPU)/start.S
+	ln -s start.S cpu/$(CPU)/start_bootstrap.S
+
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
 OBJS += cpu/$(CPU)/reset.o
@@ -183,6 +208,7 @@
 endif
 
 OBJS := $(addprefix $(obj),$(OBJS))
+OBJS_BOOTSTRAP := $(addprefix $(obj),$(OBJS_BOOTSTRAP))
 
 LIBS  = lib_generic/libgeneric.a
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
@@ -206,19 +232,46 @@
 LIBS += $(BOARDLIBS)
 
 LIBS := $(addprefix $(obj),$(LIBS))
-.PHONY : $(LIBS)
+
+LIBS_BOOTSTRAP  = lib_bootstrap/libbootstrap.a
+#LIBS_BOOTSTRAP+= board/$(BOARDDIR)/lib$(BOARD).a
+LIBS_BOOTSTRAP+= board/ifx/libifx.a
+LIBS_BOOTSTRAP+= cpu/$(CPU)/lib$(CPU).a
+
+LIBS_BOOTSTRAP := $(addprefix $(obj),$(LIBS_BOOTSTRAP))
+
+#HEAD_OBJS = cpu/$(CPU)/start.o lib_$(ARCH)/board.o
+
+#HEAD_LIBS  = board/$(BOARDDIR)/lib$(BOARD).a
+#HEAD_LIBS += cpu/$(CPU)/lib$(CPU).a
+#HEAD_LIBS += lib_$(ARCH)/lib$(ARCH).a
+#HEAD_LIBS += lib_generic/libgeneric.a
+#HEAD_LIBS += common/console.o
+#HEAD_LIBS += common/devices.o
+#HEAD_LIBS += common/cmd_bootm.o
+
+#.PHONY : $(LIBS) $(HEAD_LIBS)
+.PHONY : $(LIBS) $(obj)lib_bootstrap/libbootstrap.a
 
 # Add GCC lib
 PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
 
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
+	  #examples
 SUBDIRS	= tools \
-	  examples \
 	  post \
 	  post/cpu
 .PHONY : $(SUBDIRS)
 
+# HEAD_SUBDIRS = tools
+#HEAD_SUBDIRS = lib_generic \
+#	  cpu/$(CPU) \
+#	  board/$(BOARDDIR) \
+#	  common \
+#	  lib_$(ARCH)
+#.PHONY : $(HEAD_SUBDIRS)
+
 ifeq ($(CONFIG_NAND_U_BOOT),y)
 NAND_SPL = nand_spl
 U_BOOT_NAND = $(obj)u-boot-nand.bin
@@ -226,14 +279,75 @@
 
 __OBJS := $(subst $(obj),,$(OBJS))
 __LIBS := $(subst $(obj),,$(LIBS))
+__LIBS_BOOTSTRAP := $(subst $(obj),,$(LIBS_BOOTSTRAP))
+
+#__HEAD_OBJS := $(subst $(obj),,$(HEAD_OBJS))
+#__HEAD_LIBS := $(subst $(obj),,$(HEAD_LIBS))
 
 #########################################################################
 #########################################################################
 
 ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)
+#IFX_ALL = $(obj)u-boot.ifx $(obj)head.srec $(obj)head.bin $(obj)head $(obj)head.map $(COMPRESS_FILE) $(obj)u-boot.srec
+IFX_ALL = $(obj)u-boot.srec $(obj)u-boot.ifx $(obj)u-boot.lzimg $(obj)System.map $(obj)bootstrap.bin $(obj)System_bootstrap.map
+IFX_BOOTSTRAP = $(obj)bootstrap.bin
 
 all:		$(ALL)
 
+ifx_all:	$(IFX_ALL)
+
+ifx_bootstrap:	$(IFX_BOOTSTRAP)
+
+$(obj)u-boot.ifx: $(obj)bootstrap.bin $(obj)u-boot.lzimg
+		@cat $(obj)bootstrap.bin > $(obj)u-boot.ifx
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.ifx
+
+$(obj)u-boot.lzimg: $(obj)u-boot.bin $(obj)System.map
+		@lzma e $(obj)u-boot.bin $(obj)u-boot.lzma
+		$(obj)tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.lzma $@
+
+$(obj)ld_uboot.img: $(obj)u-boot.ifx $(obj)u-boot.lzimg $(obj)bootstrap.bin
+		@  cp -f $(obj)u-boot.ifx $(obj)u-boot.bin
+		@ ./mkbootimg.incaip2 $(obj)ld_uboot.img < ld_uboot.conf
+
+$(obj)u-boot.zimg:	$(obj)u-boot.bin $(obj)System.map
+		gzip $(obj)u-boot.bin
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C gzip \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.gz $@
+
+$(obj)u-boot.bzimg:	$(obj)u-boot.bin $(obj)System.map
+		bzip $(obj)u-boot.bin
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C bzip2 \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bz2 $@
+
+$(obj)u-boot.limg:	$(obj)u-boot.bin $(obj)System.map
+		@lzma e $(obj)u-boot.bin $(obj)u-boot.lzma
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.lzma $@
+
+$(obj)u-boot.img:	$(obj)u-boot.bin $(obj)System.map
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C none \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bin $@
+
 $(obj)u-boot.hex:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
 
@@ -243,28 +357,33 @@
 $(obj)u-boot.bin:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 
-$(obj)u-boot.img:	$(obj)u-boot.bin
-		./tools/mkimage -A $(ARCH) -T firmware -C none \
-		-a $(TEXT_BASE) -e 0 \
-		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
-			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
-		-d $< $@
-
 $(obj)u-boot.dis:	$(obj)u-boot
 		$(OBJDUMP) -d $< > $@
 
-$(obj)u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
+$(obj)u-boot:	depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
 		cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
 			--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
 			-Map u-boot.map -o u-boot
 
+$(obj)bootstrap.bin:	$(obj)bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(obj)bootstrap :	depend version $(SUBDIRS) $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) $(LDSCRIPT_BOOTSTRAP)
+		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS_BOOTSTRAP) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+		$(LD) $(LDFLAGS_BOOTSTRAP) $$UNDEF_SYM $(OBJS_BOOTSTRAP) \
+			--start-group $(__LIBS_BOOTSTRAP) --end-group $(PLATFORM_LIBS) \
+			-Map bootstrap.map -o bootstrap
+
 $(OBJS):
 		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+$(obj)lib_bootstrap/libbootstrap.a:
+		$(MAKE) -C $(dir $(subst $(obj),,$@))
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -310,7 +429,12 @@
 $(obj)System.map:	$(obj)u-boot
 		@$(NM) $< | \
 		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
-		sort > $(obj)System.map
+		sort > $@
+
+$(obj)System_bootstrap.map:	$(obj)bootstrap
+		@$(NM) $< | \
+		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
+		sort > $@
 
 #########################################################################
 else
@@ -2032,7 +2156,13 @@
 # MIPS
 #========================================================================
 #########################################################################
-## MIPS32 4Kc
+## Infineon MIPS generic u-boot config
+#########################################################################
+ifx_mips_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips ifx
+
+#########################################################################
+## MIPS32 4kc
 #########################################################################
 
 xtract_incaip = $(subst _100MHz,,$(subst _133MHz,,$(subst _150MHz,,$(subst _config,,$1))))
@@ -2254,7 +2384,7 @@
 		| xargs -0 rm -f
 	rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS $(obj)include/version_autogenerated.h
 	rm -fr $(obj)*.*~
-	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
+	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL) $(IFX_ALL)
 	rm -f $(obj)tools/crc32.c $(obj)tools/environment.c $(obj)tools/env/crc32.c
 	rm -f $(obj)tools/inca-swap-bytes $(obj)cpu/mpc824x/bedbug_603e.c
 	rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
--- a/README
+++ b/README
@@ -2333,14 +2333,14 @@
 	make O=/tmp/build NAME_config
 	make O=/tmp/build all
 
-2. Set environment variable BUILD_DIR to point to the desired location:
+2. Set environment variable UBOOT_BUILD_DIR to point to the desired location:
 
-	export BUILD_DIR=/tmp/build
+	export UBOOT_BUILD_DIR=/tmp/build
 	make distclean
 	make NAME_config
 	make all
 
-Note that the command line "O=" setting overrides the BUILD_DIR environment
+Note that the command line "O=" setting overrides the UBOOT_BUILD_DIR environment
 variable.
 
 
@@ -2398,12 +2398,12 @@
 
 When using the MAKEALL script, the default behaviour is to build U-Boot
 in the source directory. This location can be changed by setting the
-BUILD_DIR environment variable. Also, for each target built, the MAKEALL
+UBOOT_BUILD_DIR environment variable. Also, for each target built, the MAKEALL
 script saves two log files (<target>.ERR and <target>.MAKEALL) in the
 <source dir>/LOG directory. This default location can be changed by
 setting the MAKEALL_LOGDIR environment variable. For example:
 
-	export BUILD_DIR=/tmp/build
+	export UBOOT_BUILD_DIR=/tmp/build
 	export MAKEALL_LOGDIR=/tmp/log
 	CROSS_COMPILE=ppc_8xx- MAKEALL
 
--- /dev/null
+++ b/board/ifx/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= $(BOARD).o flash.o gpio.o
+SOBJS	= lowlevel_init.o pmuenable.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- /dev/null
+++ b/board/ifx/README
@@ -0,0 +1,49 @@
+/*
+** Copyright (C) 2005 Wu Qi Ming <Qi-Ming.Wu@infineon.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+To build a u-boot for danube board, user need to do the following things:
+To configure u-boot for a proper board, user need to modify two files accordingly.
+
+To configure u-boot for evaluation board, in danube-uboot/include/configs/danube.h, set
+#define USE_EVALUATION_BOARD
+#undef  USE_REFERENCE_BOARD
+and vice-versa.
+
+To let u-boot boot from ebu(flash,e.g), in danube-uboot/include/configus/ifx_mips.h, set
+#define	AMAZON_SE_BOOT_FROM_EBU
+Otherwise u-boot will be compiled for booting from RAM.
+
+To define RAM size of RAM, in danube-uboot/include/configus/danube.
+h, set
+#define RAM_SIZE                0x2000000 /*32M ram*/
+This is an example for a 32M RAM.
+
+
+Besides above settings, user need to change danube-uboot/board/danube/config.mk to set the loading address of u-boot.
+If U-Boot is to boot from EBU(flash), user needs to set
+TEXT_BASE=0xB0000000
+If u-boot is to boot from RAM, user needs to set
+TEXT_BASE=0xa0400000
+
+Use the script gct to build a uart downloadable u-boot image:
+./gct danube_ref_ddr166.conf u-boot.srec u-boot.asc
+
+
+
+
+
--- /dev/null
+++ b/board/ifx/config.mk
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Danube board with MIPS 24Kec CPU core
+#boot from ebu
+TEXT_BASE = 0xB0000000
+BOOTSTRAP_TEXT_BASE = 0xB0000000
+
+#boot from ram
+#TEXT_BASE = 0xa0400000
+#TEXT_BASE = 0x807c0000
+
--- /dev/null
+++ b/board/ifx/flash.c
@@ -0,0 +1,953 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+//leon 06/21/2007  for spansions29AL016M
+//joelin 10/07/2004 for MXIC MX29LV320ABTC-90
+#include <common.h>
+#include <asm/ifx_mips.h>
+
+/*
+#ifdef CONFIG_AMAZON
+	#define FLASH_DELAY 	{int i; \
+				for(i=0;i<800;i++) \
+					*((volatile u32 *)CFG_SDRAM_BASE_UNCACHE); \
+				}
+#else
+	#define FLASH_DELAY
+#endif
+*/
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+
+/* NOTE - CONFIG_FLASH_16BIT means the CPU interface is 16-bit, it
+ *        has nothing to do with the flash chip being 8-bit or 16-bit.
+ */
+#ifdef CONFIG_FLASH_16BIT
+typedef unsigned short FLASH_PORT_WIDTH;
+typedef volatile unsigned short FLASH_PORT_WIDTHV;
+#define	FLASH_ID_MASK	0xFFFF
+#else
+typedef unsigned long FLASH_PORT_WIDTH;
+typedef volatile unsigned long FLASH_PORT_WIDTHV;
+#define	FLASH_ID_MASK	0xFFFFFFFF
+#endif
+
+#define FPW	FLASH_PORT_WIDTH
+#define FPWV	FLASH_PORT_WIDTHV
+
+#define ORMASK(size) ((-size) & OR_AM_MSK)	// 0xffff8000
+
+#if 0
+#define FLASH_CYCLE1	0x0555
+#define FLASH_CYCLE2	0x02aa
+#else
+#define FLASH_CYCLE1	0x0554			//joelin for MX29LV320AT/B  0x0555
+#define FLASH_CYCLE2	0x02ab			//joelin for MX29LV320AT/B  0x02aa
+#endif
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(FPWV *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word_intel(flash_info_t *info, FPWV *dest, FPW data);
+static int write_word_amd(flash_info_t *info, FPWV *dest, FPW data);
+static void flash_get_offsets(ulong base, flash_info_t *info);
+static flash_info_t *flash_get_info(ulong base);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i;
+
+	/* Init: no FLASHes known */
+	for (i=0; i < CFG_MAX_FLASH_BANKS; ++i) {         // 1 bank
+		ulong flashbase = (i == 0) ? PHYS_FLASH_1 : PHYS_FLASH_2;      // 0xb0000000,  0xb4000000
+
+       volatile ulong * buscon = (ulong *)
+			((i == 0) ? AMAZON_SE_EBU_BUSCON0 : AMAZON_SE_EBU_BUSCON1);
+
+		/* Disable write protection */
+//		*buscon &= ~AMAZON_EBU_BUSCON0_WRDIS;
+		/* Enable write protection */
+		*buscon |= AMAZON_SE_EBU_BUSCON0_WRDIS;
+
+#if 1
+		memset(&flash_info[i], 0, sizeof(flash_info_t));
+#endif
+
+		flash_info[i].size =
+			flash_get_size((FPW *)flashbase, &flash_info[i]);
+
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx\n",
+			i, flash_info[i].size);
+		}
+		printf ("/n Detect flash id is %x  \n",flash_info[i].flash_id	);
+		size += flash_info[i].size;
+	}
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE    // TEXT_BASE >= 0xB3000000
+	/* monitor protection ON by default */  /* only use software protection, info->protect[i]=0/1 */
+/*	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+CFG_MONITOR_LEN-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+*/
+	flash_protect(FLAG_PROTECT_CLEAR,    // clear protect
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+CFG_MONITOR_LEN-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH     /* 1 */
+	/* ENV protection ON by default */
+/*	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+*/
+	flash_protect(FLAG_PROTECT_CLEAR,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+
+#endif
+
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	FPWV *base = (FPWV *)(info->start[0]);
+
+	(*AMAZON_SE_EBU_BUSCON0)&=(~0x80000000);	// enable writing
+	(*AMAZON_SE_EBU_BUSCON1)&=(~0x80000000);	// enable writing
+	(*EBU_NAND_CON)=0;
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL){
+		*base = (FPW)0x00FF00FF;	/* Intel Read Mode */
+		asm("SYNC");
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD){
+		*base = (FPW)0x00F000F0;	/* AMD Read Mode */
+		asm("SYNC");			//joelin
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_MX){
+		*base = (FPW)0x00F000F0;	/* MXIC Read Mode */
+		asm("SYNC");			//joelin
+	}
+
+	(*AMAZON_SE_EBU_BUSCON0)|=0x80000000;	// disable writing
+	(*AMAZON_SE_EBU_BUSCON1)|=0x80000000;	// disable writing
+
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t *info)
+{
+	int i;
+
+	/* set up sector start address table */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL
+	    && (info->flash_id & FLASH_BTYPE)) {
+		int bootsect_size;	/* number of bytes/boot sector	*/
+		int sect_size;		/* number of bytes/regular sector */
+
+		bootsect_size = 0x00002000 * (sizeof(FPW)/2);
+		sect_size =     0x00010000 * (sizeof(FPW)/2);
+
+		/* set sector offsets for bottom boot block type	*/
+		for (i = 0; i < 8; ++i) {
+			info->start[i] = base + (i * bootsect_size);
+		}
+		for (i = 8; i < info->sector_count; i++) {
+			info->start[i] = base + ((i - 7) * sect_size);
+		}
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD
+		 && (info->flash_id & FLASH_TYPEMASK) == FLASH_AM640U) {
+
+		int sect_size;		/* number of bytes/sector */
+
+		sect_size = 0x00010000 * (sizeof(FPW)/2);
+
+		/* set up sector start address table (uniform sector type) */
+		for( i = 0; i < info->sector_count; i++ )
+			info->start[i] = base + (i * sect_size);
+	}
+	else if(((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_28F128J3A)){
+		int sect_size;
+		sect_size = 0x20000;
+		for(i=0;i < info->sector_count; i++)
+			info->start[i]= base + (i*sect_size);
+	}
+	else if(((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_28F320J3A)){
+		int sect_size;
+		sect_size = 0x20000;
+		for(i=0;i < info->sector_count; i++)
+			info->start[i]= base + (i*sect_size);
+	}
+//joelin add for MX29LV320AB-- SA0~SA7:sector size=8K bytes ,SA9~SA70 :sector size=64k bytes
+	else if(((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_MX)
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_29LV320AB)){
+		int bootsect_size;	/* number of bytes/boot sector	*/
+		int sect_size;		/* number of bytes/regular sector */
+
+		bootsect_size = 0x00002000 * (sizeof(FPW)/2);
+		sect_size =     0x00010000 * (sizeof(FPW)/2);
+
+		/* set sector offsets for bottom boot block type	*/
+		for (i = 0; i < 8; ++i) {
+			info->start[i] = base + (i * bootsect_size);
+		}
+		for (i = 8; i < info->sector_count; i++) {
+			info->start[i] = base + ((i - 7) * sect_size);
+		}
+	}
+//joelin add for MX29LV160BB-- SA0=16K,SA1,SA2=8K,SA3=32K bytes ,SA4~SA34 :sector size=64k bytes
+//leon 06/21/2007  for spansions29AL016M
+	else if((((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_MX) ||((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD))
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_29LV160BB)){
+		int bootsect_size;	/* number of bytes/boot sector	*/
+		int sect_size;		/* number of bytes/regular sector */
+
+		bootsect_size = 0x00002000 * (sizeof(FPW)/2);
+		sect_size =     0x00010000 * (sizeof(FPW)/2);
+/* set sector offsets for bottom boot block type	*/
+//MX29LV160BB
+		info->start[0] = base ;				//SA0=16K bytes
+		info->start[1] = info->start[0]  + (1 * 0x00004000 * (sizeof(FPW)/2)); //SA1=8K bytes
+		info->start[2] = info->start[1]  + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA2=8K bytes
+		info->start[3] = info->start[2]  + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA3=32K bytes
+
+		for (i = 4; i < info->sector_count; i++) {
+			info->start[i] = base + ((i - 3) * sect_size);
+		}
+	}
+	/* set sector offsets for top boot block type*/
+//leon add for MX29LV160BT--SA0~SA30 :sector size=64k bytes,SA31=32K bytes,SA32,SA33=8K,SA34=16K,
+//leon  for spansion flash
+	else if((((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_MX)||((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD))
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_29LV160BT)){
+ 		int sect_size;		/* number of bytes/regular sector */
+		sect_size =     0x00010000 * (sizeof(FPW)/2); //64k bytes
+/* set sector offsets for top boot block type	*/
+//MX29LV160BT
+ 		for (i = 0; i < 32; i++) {
+			info->start[i] = base + (i * sect_size);
+		}
+		info->start[32] = info->start[31] + (1 * 0x00008000 * (sizeof(FPW)/2)); //SA31=32K bytes;				//SA0=16K bytes
+		info->start[33] = info->start[32] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA32=8K bytes
+		info->start[34] = info->start[33] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA33=8K bytes
+	}
+//Subbi added for MX29LV320CT--SA0~SA62 :sector size=64k bytes,SA63~SA70=8K
+	else if((((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_MX)||((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD))
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_29LV320CT)){
+ 		int sect_size;		/* number of bytes/regular sector */
+		sect_size =     0x00010000 * (sizeof(FPW)/2); //64k bytes
+/* set sector offsets for top boot block type	*/
+//MX29LV320CT
+ 		for (i = 0; i < 63; i++) {
+			info->start[i] = base + (i * sect_size);
+		}
+		info->start[63] = info->start[62] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA63=8K bytes
+		info->start[64] = info->start[63] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA64=8K bytes
+		info->start[65] = info->start[64] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA65=8K bytes
+		info->start[66] = info->start[65] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA66=8K bytes
+		info->start[67] = info->start[66] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA67=8K bytes
+		info->start[68] = info->start[67] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA68=8K bytes
+		info->start[69] = info->start[68] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA69=8K bytes
+		info->start[70] = info->start[69] + (1 * 0x00002000 * (sizeof(FPW)/2)); //SA70=8K bytes
+	}
+//liupeng add for MX29LV640BB-- SA0~SA7:sector size=8k bytes ,SA8~SA134 :sector size=64k bytes
+	else if(((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_MX)
+		&& ((info->flash_id & FLASH_TYPEMASK)==FLASH_29LV640BB)){
+		int bootsect_size;	/* number of bytes/boot sector	*/
+		int sect_size;		/* number of bytes/regular sector */
+
+		bootsect_size = 0x00002000 * (sizeof(FPW)/2);
+		sect_size =     0x00010000 * (sizeof(FPW)/2);
+
+		/* set sector offsets for bottom boot block type	*/
+		for (i = 0; i < 8; ++i) {
+			info->start[i] = base + (i * bootsect_size);
+		}
+		for (i = 8; i < info->sector_count; i++) {
+			info->start[i] = base + ((i - 7) * sect_size);
+		}
+	}
+	else{
+		printf("flash get offsets fail\n");
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->start[0] <= base && base < info->start[0] + info->size)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	uchar *boottype;
+	uchar *bootletter;
+	uchar *fmt;
+	uchar botbootletter[] = "B";
+	uchar topbootletter[] = "T";
+	uchar botboottype[] = "bottom boot sector";
+	uchar topboottype[] = "top boot sector";
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("AMD ");		break;
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	case FLASH_MAN_MX:	printf ("MXIC  ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	/* check for top or bottom boot, if it applies */
+	if (info->flash_id & FLASH_BTYPE) {
+		boottype = botboottype;
+		bootletter = botbootletter;
+	}
+	else {
+		boottype = topboottype;
+		bootletter = topbootletter;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM640U:
+		fmt = "29LV641D (64 Mbit, uniform sectors)\n";
+		break;
+        case FLASH_28F800C3B:
+        case FLASH_28F800C3T:
+		fmt = "28F800C3%s (8 Mbit, %s)\n";
+		break;
+	case FLASH_INTEL800B:
+	case FLASH_INTEL800T:
+		fmt = "28F800B3%s (8 Mbit, %s)\n";
+		break;
+        case FLASH_28F160C3B:
+        case FLASH_28F160C3T:
+		fmt = "28F160C3%s (16 Mbit, %s)\n";
+		break;
+	case FLASH_INTEL160B:
+	case FLASH_INTEL160T:
+		fmt = "28F160B3%s (16 Mbit, %s)\n";
+		break;
+        case FLASH_28F320C3B:
+        case FLASH_28F320C3T:
+		fmt = "28F320C3%s (32 Mbit, %s)\n";
+		break;
+	case FLASH_INTEL320B:
+	case FLASH_INTEL320T:
+		fmt = "28F320B3%s (32 Mbit, %s)\n";
+		break;
+        case FLASH_28F640C3B:
+        case FLASH_28F640C3T:
+		fmt = "28F640C3%s (64 Mbit, %s)\n";
+		break;
+	case FLASH_INTEL640B:
+	case FLASH_INTEL640T:
+		fmt = "28F640B3%s (64 Mbit, %s)\n";
+		break;
+	case FLASH_28F128J3A:
+		fmt = "28F128J3A (128 Mbit, 128 uniform sectors)\n";
+		break;
+	case FLASH_28F320J3A:
+		fmt = "28F320J3A (32 Mbit, 32 uniform sectors)\n";
+		break;
+	case FLASH_29LV640BB:		//liupeng for MXIC FLASH_29LV640BB
+		fmt = "29LV640BB (64 Mbit, boot sector SA0~SA126 size 64k bytes,other sectors SA127~SA135 size 8k bytes)\n";
+		break;
+	case FLASH_29LV320AB:		//joelin for MXIC FLASH_29LV320AB
+		fmt = "29LV320AB (32 Mbit, boot sector SA0~SA7 size 8K bytes,other sectors SA8~SA70 size 64K bytes)\n";
+		break;
+	case FLASH_29LV320CT:		//Subbi for MXIC FLASH_29LV320CT
+		fmt = "29LV320CT (32 Mbit, boot sector SA0~SA62 size 64K bytes,other sectors SA63~SA70 size 8K bytes)\n";
+		break;
+	case FLASH_29LV160BB:		//joelin for MXIC FLASH_29LV160BB
+		fmt = "29LV160BB (16 Mbit, boot sector SA0 size 16K bytes,SA1,SA2 size 8K bytes,SA3 size 32k bytes,other sectors SA4~SA34 size 64K bytes)\n";
+		break;
+    case FLASH_29LV160BT:		//leon for MXIC FLASH_29LV160BT
+		fmt = "29LV160BT (16 Mbit)\n";
+		break;
+	default:
+		fmt = "Unknown Chip Type\n";
+		break;
+	}
+
+	printf (fmt, bootletter, boottype);
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (FPWV *addr, flash_info_t *info)
+{
+        (*AMAZON_SE_EBU_BUSCON0)=0x1d7ff;  //value from Aikann, should be used on the real chip
+	(*EBU_ADDR_SEL_0) = 0x10000031; //starting address from 0xb0000000
+	(*EBU_NAND_CON)=0;
+	(*AMAZON_SE_EBU_BUSCON0)&=(~0x80000000);	// enable writing
+	(*AMAZON_SE_EBU_BUSCON1)&=(~0x80000000);	// enable writing
+	/* Write auto select command: read Manufacturer ID */
+
+	/* Write auto select command sequence and test FLASH answer */
+  	addr[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* for AMD, Intel ignores this */
+  	asm("SYNC");
+  	addr[FLASH_CYCLE2] = (FPW)0x00550055;	/* for AMD, Intel ignores this */
+  	asm("SYNC");
+  	addr[FLASH_CYCLE1] = (FPW)0x00900090;	/* selects Intel or AMD */
+  	asm("SYNC");
+
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+
+//	printf("\n type is %08lx", addr[1] & 0xff); 	//joelin 10/06/2004 flash type
+//	printf("\n type is %08lx", addr[0] & 0xff); 	//joelin 10/06/2004 flash type
+//		asm("SYNC");
+	switch (addr[1] & 0xff) {
+	case (uchar)AMD_MANUFACT:
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (uchar)INTEL_MANUFACT:			// 0x0089
+		info->flash_id = FLASH_MAN_INTEL; //0x00300000
+		break;
+
+//joelin for MXIC
+	case (uchar)MX_MANUFACT:		// 0x00c2
+		info->flash_id = FLASH_MAN_MX ;//0x00030000
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+/*	default:
+		info->flash_id = FLASH_MAN_INTEL; //0x00300000
+		break;*/
+	}
+
+	/* Check 16 bits or 32 bits of ID so work on 32 or 16 bit bus. */
+	if (info->flash_id != FLASH_UNKNOWN) switch (addr[0]) {
+	case (FPW)AMD_ID_LV640U:	/* 29LV640 and 29LV641 have same ID */
+		info->flash_id += FLASH_AM640U;
+		info->sector_count = 128;
+		info->size = 0x00800000 * (sizeof(FPW)/2);
+		break;				/* => 8 or 16 MB	*/
+
+	case (FPW)INTEL_ID_28F800C3B:
+		info->flash_id += FLASH_28F800C3B;
+		info->sector_count = 23;
+		info->size = 0x00100000 * (sizeof(FPW)/2);
+		break;				/* => 1 or 2 MB		*/
+
+	case (FPW)INTEL_ID_28F800B3B:
+		info->flash_id += FLASH_INTEL800B;
+		info->sector_count = 23;
+		info->size = 0x00100000 * (sizeof(FPW)/2);
+		break;				/* => 1 or 2 MB		*/
+
+	case (FPW)INTEL_ID_28F160C3B:
+		info->flash_id += FLASH_28F160C3B;
+		info->sector_count = 39;
+		info->size = 0x00200000 * (sizeof(FPW)/2);
+		break;				/* => 2 or 4 MB		*/
+
+	case (FPW)INTEL_ID_28F160B3B:
+		info->flash_id += FLASH_INTEL160B;
+		info->sector_count = 39;
+		info->size = 0x00200000 * (sizeof(FPW)/2);
+		break;				/* => 2 or 4 MB		*/
+
+	case (FPW)INTEL_ID_28F320C3B:
+		info->flash_id += FLASH_28F320C3B;
+		info->sector_count = 71;
+		info->size = 0x00400000 * (sizeof(FPW)/2);
+		break;				/* => 4 or 8 MB		*/
+
+	case (FPW)INTEL_ID_28F320B3B:
+		info->flash_id += FLASH_INTEL320B;
+		info->sector_count = 71;
+		info->size = 0x00400000 * (sizeof(FPW)/2);
+		break;				/* => 4 or 8 MB		*/
+
+	case (FPW)INTEL_ID_28F640C3B:
+		info->flash_id += FLASH_28F640C3B;
+		info->sector_count = 135;
+		info->size = 0x00800000 * (sizeof(FPW)/2);
+		break;				/* => 8 or 16 MB	*/
+
+	case (FPW)INTEL_ID_28F640B3B:
+		info->flash_id += FLASH_INTEL640B;
+		info->sector_count = 135;
+		info->size = 0x00800000 * (sizeof(FPW)/2);
+		break;				/* => 8 or 16 MB	*/
+
+	case (FPW)INTEL_ID_28F128J3A:
+		info->flash_id +=FLASH_28F128J3A;
+		info->sector_count = 128;
+		info->size = 0x01000000 * (sizeof(FPW)/2);
+		break;				/* => 16 MB */
+	case (FPW)INTEL_ID_28F320J3A:
+		info->flash_id += FLASH_28F320J3A;
+		info->sector_count = 32;
+		info->size = 0x00400000 * (sizeof(FPW)/2);
+		break;
+//joelin for MXIC
+	case (FPW)MX_ID_29LV320AB:
+		info->flash_id += FLASH_29LV320AB;
+		info->sector_count = 71;
+		info->size = 0x00400000 * (sizeof(FPW)/2);
+		break;				/* => 4 MB		*/
+
+// Subbi for MXIC 29LV320CT					/* => 4 MB */
+	case (FPW)MX_ID_29LV320CT:
+		info->flash_id += FLASH_29LV320CT;
+		info->sector_count = 71;
+		info->size = 0x00400000 * (sizeof(FPW)/2);
+		break;				/* => 4 MB		*/
+					/* => 4 MB */
+//joelin for MXIC
+	case (FPW)MX_ID_29LV160BB:
+		info->flash_id += FLASH_29LV160BB;
+		info->sector_count = 35;
+		info->size = 0x00200000 * (sizeof(FPW)/2);
+		break;				/* => 2 MB		*/
+					/* => 2 MB */
+//leon for MXIC 29LV160BT
+	case (FPW)MX_ID_29LV160BT:
+		info->flash_id += FLASH_29LV160BT;
+		info->sector_count = 35;
+		info->size = 0x00200000 * (sizeof(FPW)/2);
+		break;				/* => 2 MB		*/
+					/* => 2 MB */
+
+	/* liupeng*/
+	case (FPW)MX_ID_29LV640BB:
+		info->flash_id += FLASH_29LV640BB;
+		info->sector_count = 135;
+		info->size = 0x00800000 * (sizeof(FPW)/2);
+		break;				/* => 2 MB		*/
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* => no or unknown flash */
+/*	default:
+		info->flash_id += FLASH_28F320J3A;
+		info->sector_count = 32;
+		info->size = 0x00400000 * (sizeof(FPW)/2);
+		break;*/
+	}
+
+
+	(*AMAZON_SE_EBU_BUSCON0)|=0x80000000;	// disable writing
+	(*AMAZON_SE_EBU_BUSCON1)|=0x80000000;	// disable writing
+
+	flash_get_offsets((ulong)addr, info);
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	FPWV *addr;
+	int flag, prot, sect;
+	int intel = (info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL;
+	ulong start, now, last;
+	int rcode = 0;
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_INTEL800B:
+	case FLASH_INTEL160B:
+	case FLASH_INTEL320B:
+	case FLASH_INTEL640B:
+	case FLASH_28F800C3B:
+	case FLASH_28F160C3B:
+	case FLASH_28F320C3B:
+	case FLASH_28F640C3B:
+	case FLASH_28F128J3A:
+	case FLASH_28F320J3A:
+	case FLASH_AM640U:
+	case FLASH_29LV640BB:	//liupeng for MXIC MX29LV640BB
+	case FLASH_29LV320AB:	//joelin for MXIC MX29LV320AB
+	case FLASH_29LV320CT:	//Subbi for MXIC MX29LV320CT
+	case FLASH_29LV160BB:	//joelin for MXIC MX29LV160BB
+    case FLASH_29LV160BT:	//leon for MXIC MX29LV160BT
+		break;
+	case FLASH_UNKNOWN:
+	default:
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	last  = get_timer(0);
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last && rcode == 0; sect++) {
+
+		if (info->protect[sect] != 0)	/* protected, skip it */
+			continue;
+
+		/* Disable interrupts which might cause a timeout here */
+		flag = disable_interrupts();
+
+		(*AMAZON_SE_EBU_BUSCON0)&=(~0x80000000);	// enable writing
+		(*AMAZON_SE_EBU_BUSCON1)&=(~0x80000000);	// enable writing
+		(*EBU_NAND_CON)=0;
+		addr = (FPWV *)(info->start[sect]);
+		if (intel) {
+			*addr = (FPW)0x00500050; /* clear status register */
+			*addr = (FPW)0x00200020; /* erase setup */
+			*addr = (FPW)0x00D000D0; /* erase confirm */
+			asm("SYNC");
+		}
+		else {
+			/* must be AMD style if not Intel */
+			FPWV *base;		/* first address in bank */
+
+			base = (FPWV *)(info->start[0]);
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[FLASH_CYCLE1] = (FPW)0x00800080;	/* erase mode */
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			*addr = (FPW)0x00300030;	/* erase sector */
+		}
+
+		/* re-enable interrupts if necessary */
+		if (flag)
+			enable_interrupts();
+
+		start = get_timer(0);
+
+		/* wait at least 50us for AMD, 80us for Intel.
+		 * Let's wait 1 ms.
+		 */
+		udelay (1000);
+
+		while ((*addr & (FPW)0x00800080) != (FPW)0x00800080) {
+			if ((now = get_timer(start)) > CFG_FLASH_ERASE_TOUT) {
+				printf ("Erase Timeout\n");
+
+				if (intel) {
+					/* suspend erase	*/
+					*addr = (FPW)0x00B000B0;
+				}
+
+				flash_reset(info);	/* reset to read mode */
+				rcode = 1;		/* failed */
+				break;
+			}
+
+			/* show that we're waiting */
+			if ((get_timer(last)) > CFG_HZ) {/* every second */
+				putc ('.');
+				last = get_timer(0);
+			}
+		}
+
+
+//joelin for MXIC
+	switch (info->flash_id & FLASH_VENDMASK) {
+ 	case FLASH_MAN_MX:		//joelin for MXIC
+ 	case FLASH_MAN_AMD:		//leon for spansion
+ 		break;
+ 	default:
+		if((*addr & (FPW)0x00200020) != (FPW)0x0)
+			printf("Erase Error\n");
+		break;
+	}
+
+
+
+		/* show that we're waiting */
+		if ((get_timer(last)) > CFG_HZ) {	/* every second */
+			putc ('.');
+			last = get_timer(0);
+		}
+
+		//flash_reset(info);	/* reset to read mode	*/
+	}
+
+	(*AMAZON_SE_EBU_BUSCON0)|=0x80000000;	// disable writing
+	(*AMAZON_SE_EBU_BUSCON1)|=0x80000000;	// disable writing
+
+	printf (" done\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+    FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */
+    int bytes;	  /* number of bytes to program in current word		*/
+    int left;	  /* number of bytes left to program			*/
+    int i, res;
+
+    for (left = cnt, res = 0;
+	 left > 0 && res == 0;
+	 addr += sizeof(data), left -= sizeof(data) - bytes) {
+
+        bytes = addr & (sizeof(data) - 1);
+        addr &= ~(sizeof(data) - 1);
+
+	/* combine source and destination data so can program
+	 * an entire word of 16 or 32 bits
+	 */
+        for (i = 0; i < sizeof(data); i++) {
+            data <<= 8;
+            if (i < bytes || i - bytes >= left )
+		data += *((uchar *)addr + i);
+	    else
+		data += *src++;
+	}
+
+	/* write one word to the flash */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:
+	case FLASH_MAN_MX:		//joelin for MXIC
+		res = write_word_amd(info, (FPWV *)addr, data);
+		break;
+	case FLASH_MAN_INTEL:
+		res = write_word_intel(info, (FPWV *)addr, data);
+		break;
+	default:
+		/* unknown flash type, error! */
+		printf ("missing or unknown FLASH type\n");
+		res = 1;	/* not really a timeout, but gives error */
+		break;
+	}
+    }
+
+    return (res);
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash for AMD FLASH
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word_amd (flash_info_t *info, FPWV *dest, FPW data)
+{
+    ulong start;
+    int flag;
+    int res = 0;	/* result, assume success	*/
+    FPWV *base;		/* first address in flash bank	*/
+
+    /* Check if Flash is (sufficiently) erased */
+    if ((*dest & data) != data) {
+	return (2);
+    }
+
+    base = (FPWV *)(info->start[0]);
+
+    /* Disable interrupts which might cause a timeout here */
+    flag = disable_interrupts();
+
+    (*AMAZON_SE_EBU_BUSCON0)&=(~0x80000000);	// enable writing
+    (*AMAZON_SE_EBU_BUSCON1)&=(~0x80000000);	// enable writing
+    (*EBU_NAND_CON)=0;
+
+    base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+    base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+    base[FLASH_CYCLE1] = (FPW)0x00A000A0;	/* selects program mode */
+
+    *dest = data;		/* start programming the data	*/
+
+    /* re-enable interrupts if necessary */
+    if (flag)
+	enable_interrupts();
+
+    start = get_timer (0);
+
+    /* data polling for D7 */
+    while (res == 0 && (*dest & (FPW)0x00800080) != (data & (FPW)0x00800080)) {
+	if (get_timer(start) > CFG_FLASH_WRITE_TOUT) {
+	    *dest = (FPW)0x00F000F0;	/* reset bank */
+	    res = 1;
+	}
+    }
+
+	(*AMAZON_SE_EBU_BUSCON0)|=0x80000000;	// disable writing
+	(*AMAZON_SE_EBU_BUSCON1)|=0x80000000;	// disable writing
+
+        return (res);
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash for Intel FLASH
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word_intel (flash_info_t *info, FPWV *dest, FPW data)
+{
+    ulong start;
+    int flag;
+    int res = 0;	/* result, assume success	*/
+#if 0
+    /* Check if Flash is (sufficiently) erased */
+    if ((*dest & data) != data) {
+	return (2);
+    }
+#endif
+    /* Disable interrupts which might cause a timeout here */
+    flag = disable_interrupts();
+
+    (*AMAZON_SE_EBU_BUSCON0)&=(~0x80000000);	// enable writing
+    (*AMAZON_SE_EBU_BUSCON1)&=(~0x80000000);	// enable writing
+    (*EBU_NAND_CON)=0;
+    *dest = (FPW)0x00500050;	/* clear status register	*/
+    *dest = (FPW)0x00FF00FF;	/* make sure in read mode	*/
+    *dest = (FPW)0x00400040;	/* program setup		*/
+    *dest = data;		/* start programming the data	*/
+    asm("SYNC");
+
+    /* re-enable interrupts if necessary */
+    if (flag)
+	enable_interrupts();
+
+    start = get_timer (0);
+
+    while (res == 0 && (*dest & (FPW)0x00800080) != (FPW)0x00800080) {
+	if (get_timer(start) > CFG_FLASH_WRITE_TOUT) {
+	    *dest = (FPW)0x00B000B0;	/* Suspend program	*/
+	    res = 1;
+	}
+    }
+
+    if (res == 0 && (*dest & (FPW)0x00100010))
+	res = 1;	/* write failed, time out error is close enough	*/
+
+    *dest = (FPW)0x00500050;	/* clear status register	*/
+    flash_reset(info);
+
+    (*AMAZON_SE_EBU_BUSCON0)|=0x80000000;	// disable writing
+    (*AMAZON_SE_EBU_BUSCON1)|=0x80000000;	// disable writing
+
+        return (res);
+}
--- /dev/null
+++ b/board/ifx/gpio.c
@@ -0,0 +1,34 @@
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/ifx_mips.h>
+
+int gpio_init(void)
+{
+
+#ifdef IFX_CONFIG_LED_TYPE_LEDC
+        *AMAZON_SE_GPIO_P0_ALTSEL0 = *AMAZON_SE_GPIO_P0_ALTSEL0 & ~((1<<12));
+        *AMAZON_SE_GPIO_P0_ALTSEL1 = *AMAZON_SE_GPIO_P0_ALTSEL1 & ~((1<<12));
+        *AMAZON_SE_GPIO_P0_DIR = *AMAZON_SE_GPIO_P0_DIR | (1<<12);
+        *AMAZON_SE_GPIO_P0_OUT = *AMAZON_SE_GPIO_P0_OUT | (1<<12);
+#endif
+
+#ifdef IFX_CONFIG_LED_TYPE_GPIO
+        *AMAZON_SE_GPIO_P0_ALTSEL0 = *AMAZON_SE_GPIO_P0_ALTSEL0 & ~((1<<1) | (1<<2) | (1<<3) | (1<<4) | (1<<12) | (1<<13));
+        *AMAZON_SE_GPIO_P0_ALTSEL1 = *AMAZON_SE_GPIO_P0_ALTSEL1 & ~((1<<1) | (1<<2) | (1<<3) | (1<<4) | (1<<12) | (1<<13));
+        *AMAZON_SE_GPIO_P0_DIR = *AMAZON_SE_GPIO_P0_DIR | (1<<1) | (1<<2) | (1<<3) | (1<<4) | (1<<12) | (1<<13);
+#ifdef IFX_CONFIG_CHINA_MKT_1
+        *AMAZON_SE_GPIO_P0_OUT = *AMAZON_SE_GPIO_P0_OUT & ((~((1<<13) | (1<<12))) | (1<<1) | (1<<2) | (1<<3) | (1<<4));
+#else
+        *AMAZON_SE_GPIO_P0_OUT = *AMAZON_SE_GPIO_P0_OUT & ((~(1<<13)) | (1<<1) | (1<<2) | (1<<3) | (1<<4) | (1<<12));
+#endif
+#if 0
+        *AMAZON_SE_GPIO_P1_ALTSEL0 = *AMAZON_SE_GPIO_P1_ALTSEL0 & ~((1<<8) | (1<<11));
+        *AMAZON_SE_GPIO_P1_ALTSEL1 = *AMAZON_SE_GPIO_P1_ALTSEL1 & ~((1<<8) | (1<<11));
+        *AMAZON_SE_GPIO_P1_DIR = *AMAZON_SE_GPIO_P1_DIR | (1<<8) | (1<<11);
+        *AMAZON_SE_GPIO_P1_OUT = *AMAZON_SE_GPIO_P1_OUT & ~(1<<8) | (1<<11);
+#endif
+#endif
+
+	return 0;
+}
--- /dev/null
+++ b/board/ifx/ifx.c
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/ifx_mips.h>
+
+#if 1
+long int initdram(int board_type)
+{
+	return (1024*1024*IFX_CONFIG_MEMORY_SIZE);
+}
+#else
+extern uint amazon_se_get_cpuclk(void);
+
+static ulong max_sdram_size(void)     /* per Chip Select */
+{
+	/* The only supported SDRAM data width is 16bit.
+	 */
+#define CFG_DW	4
+
+	/* The only supported number of SDRAM banks is 4.
+	 */
+#define CFG_NB	4
+
+	ulong cfgpb0 = *AMAZON_SE_SDRAM_MC_CFGPB0;
+	int   cols   = cfgpb0 & 0xF;
+	int   rows   = (cfgpb0 & 0xF0) >> 4;
+	ulong size   = (1 << (rows + cols)) * CFG_DW * CFG_NB;
+
+	return size;
+}
+
+/*
+ * Check memory range for valid RAM. A simple memory test determines
+ * the actually available RAM size between addresses `base' and
+ * `base + maxsize'.
+ */
+
+static long int dram_size(long int *base, long int maxsize)
+{
+	volatile long int *addr;
+	ulong cnt, val;
+	ulong save[32];			/* to make test non-destructive */
+	unsigned char i = 0;
+
+	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
+		addr = base + cnt;		/* pointer arith! */
+
+		save[i++] = *addr;
+		*addr = ~cnt;
+	}
+
+	/* write 0 to base address */
+	addr = base;
+	save[i] = *addr;
+	*addr = 0;
+
+	/* check at base address */
+	if ((val = *addr) != 0) {
+		*addr = save[i];
+		return (0);
+	}
+
+	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
+		addr = base + cnt;		/* pointer arith! */
+
+		val = *addr;
+		*addr = save[--i];
+
+		if (val != (~cnt)) {
+			return (cnt * sizeof (long));
+		}
+	}
+	return (maxsize);
+}
+
+long int initdram(int board_type)
+{
+	int   rows, cols, best_val = *AMAZON_SE_SDRAM_MC_CFGPB0;
+	ulong size, max_size       = 0;
+	ulong our_address;
+
+	/* load t9 into our_address */
+	asm volatile ("move %0, $25" : "=r" (our_address) :);
+
+		/* Can't probe for RAM size unless we are running from Flash.
+		 * find out whether running from DRAM or Flash.
+		 */
+	if (PHYSADDR(our_address) < PHYSADDR(PHYS_FLASH_1))
+	{
+		return max_sdram_size();
+	}
+
+	for (cols = 0x8; cols <= 0xC; cols++)
+	{
+		for (rows = 0xB; rows <= 0xD; rows++)
+		{
+			*AMAZON_SE_SDRAM_MC_CFGPB0 = (0x14 << 8) |
+			                           (rows << 4) | cols;
+			size = dram_size((ulong *)CFG_SDRAM_BASE,
+			                                     max_sdram_size());
+
+			if (size > max_size)
+			{
+				best_val = *AMAZON_SE_SDRAM_MC_CFGPB0;
+				max_size = size;
+			}
+		}
+	}
+
+	*AMAZON_SE_SDRAM_MC_CFGPB0 = best_val;
+	return max_size;
+}
+#endif
+
+int checkboard (void)
+{
+	/*    No such register in Amazon */
+#if 0
+	unsigned long chipid = *AMAZON_MCD_CHIPID;
+	int part_num;
+
+	puts ("Board: AMAZON ");
+	part_num = AMAZON_MCD_CHIPID_PART_NUMBER_GET(chipid);
+	switch (part_num) {
+	case AMAZON_CHIPID_STANDARD:
+		printf ("Standard Version, ");
+		break;
+	case AMAZON_CHIPID_YANGTSE:
+		printf ("Yangtse Version, ");
+		break;
+	default:
+		printf ("Unknown Part Number 0x%x ", part_num);
+		break;
+	}
+
+	printf ("Chip V1.%ld, ", AMAZON_MCD_CHIPID_VERSION_GET(chipid));
+
+
+	printf("CPU Speed %d MHz\n", AMAZON_SE_get_cpuclk()/1000000);
+
+#endif
+	return 0;
+}
+
+/*
+ * Disk On Chip (NAND) Millenium initialization.
+ * The NAND lives in the CS2* space
+ */
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+extern void
+nand_probe(ulong physadr);
+
+#define AT91_SMARTMEDIA_BASE 0x40000000  /* physical address to access memory on NCS3 */
+void
+nand_init(void)
+{
+       	int devtype;
+	/* Configure EBU */
+//TODO: should we keep this?
+        //Set GPIO23 to be Flash CS1;
+	*AMAZON_SE_GPIO_P1_ALTSEL0 = *AMAZON_SE_GPIO_P1_ALTSEL0 | (1<<7);
+	*AMAZON_SE_GPIO_P1_ALTSEL1 = *AMAZON_SE_GPIO_P1_ALTSEL1 & ~(1<<7);
+	*AMAZON_SE_GPIO_P1_DIR = *AMAZON_SE_GPIO_P1_DIR | (1<<7) ;
+	*AMAZON_SE_GPIO_P1_OD = *AMAZON_SE_GPIO_P1_OD | (1<<7) ;
+
+	*EBU_ADDR_SEL_1 = (NAND_BASE_ADDRESS&0x1fffff00)|0x31;
+	/* byte swap;minimum delay*/
+	*EBU_CON_1      = 0x40C155;
+	*EBU_NAND_CON   = 0x000005F3;
+
+	/* Set bus signals to inactive */
+	 NAND_READY_CLEAR;
+
+	 NAND_CE_CLEAR;
+         nand_probe(NAND_BASE_ADDRESS);
+
+
+
+	//nand_probe(AT91_SMARTMEDIA_BASE);
+}
+#endif
+
+
+
--- /dev/null
+++ b/board/ifx/lowlevel_init.S
@@ -0,0 +1,326 @@
+
+/*
+ *  Memory sub-system initialization code for INCA-IP2 development board.
+ *  Andre Messerschmidt
+ *  Copyright (c) 2005	Infineon Technologies AG
+ *
+ *  Based on Inca-IP code
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/* History:
+      peng liu May 25, 2006, for PLL setting after reset, 05252006
+ */
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <configs/ifx_mips.h>
+
+
+
+/*TODO: liupeng check !!! */
+#define EBU_MODUL_BASE		0xB4102000
+#define EBU_CLC(value)		0x0000(value)
+#define EBU_CON(value)		0x0010(value)
+#define EBU_ADDSEL0(value)	0x0020(value)
+#define EBU_ADDSEL1(value)	0x0024(value)
+#define EBU_ADDSEL2(value)	0x0028(value)
+#define EBU_ADDSEL3(value)	0x002C(value)
+#define EBU_BUSCON0(value)	0x0060(value)
+#define EBU_BUSCON1(value)	0x0064(value)
+#define EBU_BUSCON2(value)	0x0068(value)
+#define EBU_BUSCON3(value)	0x006C(value)
+
+#define MC_MODUL_BASE		0xBF800000
+#define MC_ERRCAUSE(value)	0x0010(value)
+#define MC_ERRADDR(value)	0x0020(value)
+#define MC_CON(value)		0x0060(value)
+
+#define MC_SRAM_ENABLE		0x00000004
+#define MC_SDRAM_ENABLE		0x00000002
+#define MC_DDRRAM_ENABLE	0x00000001
+
+#define MC_SDR_MODUL_BASE	0xBF800200
+#define MC_IOGP(value)		0x0000(value)
+#define MC_CTRLENA(value)	0x0010(value)
+#define MC_MRSCODE(value)	0x0020(value)
+#define MC_CFGDW(value)		0x0030(value)
+#define MC_CFGPB0(value)	0x0040(value)
+#define MC_LATENCY(value)	0x0080(value)
+#define MC_TREFRESH(value)	0x0090(value)
+#define MC_SELFRFSH(value)	0x00A0(value)
+
+#define MC_DDR_MODUL_BASE	0xBF801000
+#define MC_DC00(value)		0x0000(value)
+#define MC_DC01(value)		0x0010(value)
+#define MC_DC02(value)		0x0020(value)
+#define MC_DC03(value)		0x0030(value)
+#define MC_DC04(value)		0x0040(value)
+#define MC_DC05(value)		0x0050(value)
+#define MC_DC06(value)		0x0060(value)
+#define MC_DC07(value)		0x0070(value)
+#define MC_DC08(value)		0x0080(value)
+#define MC_DC09(value)		0x0090(value)
+#define MC_DC10(value)		0x00A0(value)
+#define MC_DC11(value)		0x00B0(value)
+#define MC_DC12(value)		0x00C0(value)
+#define MC_DC13(value)		0x00D0(value)
+#define MC_DC14(value)		0x00E0(value)
+#define MC_DC15(value)		0x00F0(value)
+#define MC_DC16(value)		0x0100(value)
+#define MC_DC17(value)		0x0110(value)
+#define MC_DC18(value)		0x0120(value)
+#define MC_DC19(value)		0x0130(value)
+#define MC_DC20(value)		0x0140(value)
+#define MC_DC21(value)		0x0150(value)
+#define MC_DC22(value)		0x0160(value)
+#define MC_DC23(value)		0x0170(value)
+#define MC_DC24(value)		0x0180(value)
+#define MC_DC25(value)		0x0190(value)
+#define MC_DC26(value)		0x01A0(value)
+#define MC_DC27(value)		0x01B0(value)
+#define MC_DC28(value)		0x01C0(value)
+#define MC_DC29(value)		0x01D0(value)
+#define MC_DC30(value)		0x01E0(value)
+#define MC_DC31(value)		0x01F0(value)
+#define MC_DC32(value)		0x0200(value)
+#define MC_DC33(value)		0x0210(value)
+#define MC_DC34(value)		0x0220(value)
+#define MC_DC35(value)		0x0230(value)
+#define MC_DC36(value)		0x0240(value)
+#define MC_DC37(value)		0x0250(value)
+#define MC_DC38(value)		0x0260(value)
+#define MC_DC39(value)		0x0270(value)
+#define MC_DC40(value)		0x0280(value)
+#define MC_DC41(value)		0x0290(value)
+#define MC_DC42(value)		0x02A0(value)
+#define MC_DC43(value)		0x02B0(value)
+#define MC_DC44(value)		0x02C0(value)
+#define MC_DC45(value)		0x02D0(value)
+#define MC_DC46(value)		0x02E0(value)
+
+#define RCU_OFFSET  0xBF203000
+#define RCU_RST_REQ      (RCU_OFFSET + 0x0010)
+#define RCU_STS          (RCU_OFFSET + 0x0014)
+
+#define CGU_OFFSET  0xBF103000
+#define  PLL0_CFG     (CGU_OFFSET + 0x0004)
+#define  PLL1_CFG     (CGU_OFFSET + 0x0008)
+#define  PLL2_CFG     (CGU_OFFSET + 0x000C)
+#define  CGU_SYS      (CGU_OFFSET + 0x0010)
+#define  CGU_UPDATE   (CGU_OFFSET + 0x0014)
+#define  IF_CLK       (CGU_OFFSET + 0x0018)
+#define  CGU_SMD      (CGU_OFFSET + 0x0020)
+#define  CGU_CT1SR    (CGU_OFFSET + 0x0028)
+#define  CGU_CT2SR    (CGU_OFFSET + 0x002C)
+#define  CGU_PCMCR    (CGU_OFFSET + 0x0030)
+#define  PCI_CR_PCI   (CGU_OFFSET + 0x0034)
+#define  CGU_OSC_CTRL (CGU_OFFSET + 0x001C)
+#define  CGU_MIPS_PWR_DWN (CGU_OFFSET + 0x0038)
+#define  CLK_MEASURE  (CGU_OFFSET + 0x003C)
+
+//05252006
+#define  pll0_35MHz_CONFIG 0x9D861059
+#define  pll1_35MHz_CONFIG 0x1A260CD9
+#define  pll2_35MHz_CONFIG 0x8000f1e5
+#define  pll0_36MHz_CONFIG 0x1000125D
+#define  pll1_36MHz_CONFIG 0x1B1E0C99
+#define  pll2_36MHz_CONFIG 0x8002f2a1
+//05252006
+
+//06063001-joelin disable the PCI CFRAME mask -start
+/*CFRAME is an I/O signal, in the chip, the output CFRAME is selected via GPIO altsel pins, so if you select MII1 RXD1, the CFRAME will not come out.
+But the CFRAME input still take the signal from the pad and not disabled when altsel choose other function. So when MII1_RXD1 is low from other device, the EBU interface will be disabled.
+
+The chip function in such a way that disable the CFRAME mask mean EBU not longer check CFRAME to be the device using the bus.
+The side effect is the entire PCI block will see CFRAME low all the time meaning PCI cannot use the bus at all so no more PCI function.
+*/
+#define PCI_CR_PR_OFFSET  0xBE105400
+#define PCI_CR_PCI_MOD_REG          (PCI_CR_PR_OFFSET + 0x0030)
+#define PCI_CONFIG_SPACE  0xB7000000
+#define CS_CFM		(PCI_CONFIG_SPACE + 0x6C)
+//06063001-joelin disable the PCI CFRAME mask -end
+	.set	noreorder
+
+
+/*
+ * void ebu_init(long)
+ *
+ * a0 has the clock value we are going to run at
+ */
+	.globl	ebu_init
+	.ent	ebu_init
+ebu_init:
+/*TODO:liupeng */
+	j	ra
+	nop
+
+	.end	ebu_init
+
+
+/*
+ * void cgu_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	cgu_init
+	.ent	cgu_init
+cgu_init:
+	li  t2, CGU_SYS
+  lw  t2,0(t2)
+  beq t2,a0,freq_up2date
+  nop
+
+	li  t2, RCU_STS
+	lw  t2, 0(t2)
+	and t2,0x00020000
+	beq t2,0x00020000,boot_36MHZ
+  nop
+//05252006
+	li  t1, PLL0_CFG
+	li  t2, pll0_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL1_CFG
+	li  t2, pll1_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL2_CFG
+	li  t2, pll2_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, CGU_SYS
+	sw	a0,0(t1)
+	li  t1, RCU_RST_REQ
+	li  t2, 0x40000008
+	sw	t2,0(t1)
+	b   wait_reset
+	nop
+boot_36MHZ:
+	li  t1, PLL0_CFG
+	li  t2, pll0_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL1_CFG
+	li  t2, pll1_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL2_CFG
+	li  t2, pll2_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, CGU_SYS
+	sw	a0,0(t1)
+	li  t1, RCU_RST_REQ
+	li  t2, 0x40000008
+	sw	t2,0(t1)
+//05252006
+
+wait_reset:
+    b   wait_reset
+    nop
+freq_up2date:
+    j ra
+    nop
+	.end	cgu_init
+
+
+/*
+ * void sdram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	sdram_init
+	.ent	sdram_init
+sdram_init:
+
+	/* SDRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+
+	li      t2, 0x2
+	sw      t2, 0x200(t1)
+
+	li      t2, 0x0
+	sw      t2, 0x210(t1)
+
+	li      t2, 0x2
+	sw      t2, 0x230(t1)
+
+	li      t2, 0x20
+	sw      t2, 0x220(t1)
+
+#if (IFX_CONFIG_MEMORY_SIZE == 8)
+	li      t2, 0x14c8
+#endif
+
+#if (IFX_CONFIG_MEMORY_SIZE == 16)
+	li      t2, 0x14c9
+#endif
+	sw      t2, 0x240(t1)
+
+#if (IFX_CONFIG_MEMORY_SIZE == 8)
+        li      t2, 0x14c8
+#endif
+
+#if (IFX_CONFIG_MEMORY_SIZE == 16)
+        li      t2, 0x14c9
+#endif
+        sw      t2, 0x250(t1)
+
+	li      t2, 0x36325
+	sw      t2, 0x280(t1)
+
+	li      t2, 0x81d
+	sw      t2, 0x290(t1)
+
+	li      t2, 0x0
+	sw      t2, 0x2A0(t1)
+
+        li      t2, 0x1
+	sw      t2, 0x210(t1)
+
+        li      t1, 0xbe190400
+	li      t2, 0
+	sw      t2, 0x0(t1)
+
+	j	ra
+	nop
+
+	.end	sdram_init
+
+
+	.globl	lowlevel_init
+	.ent	lowlevel_init
+lowlevel_init:
+	/* EBU, CGU and SDRAM/DDR-RAM Initialization.
+	 */
+	move	t0, ra
+        /*cgu initialization*/
+        li      t1, 0xbf103010
+        li      t2, 0x20
+        sw      t2, 0(t1)
+
+#ifdef AMAZON_SE_BOOT_FROM_EBU
+	bal	sdram_init
+	nop
+#endif
+	move	ra, t0
+	j	ra
+	nop
+	.end	lowlevel_init
--- /dev/null
+++ b/board/ifx/pmuenable.S
@@ -0,0 +1,48 @@
+/*
+ *  Power Management unit initialization code for AMAZON development board.
+ *
+ *  Copyright (c) 2003	Ou Ke, Infineon.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+
+#define PMU_PWDCR 		0xBF10201C
+#define PMU_SR			0xBF102020
+
+	.globl	pmuenable
+
+pmuenable:
+	li      t0, PMU_PWDCR
+	li      t1, 0x43		/* enable everything except USB */
+	sw      t1, 0(t0)
+#if 0
+1:
+	li	t0, PMU_SR
+	lw      t2, 0(t0)
+	bne     t1, t2, 1b
+	nop
+#endif
+	j	ra
+	nop
+
+
--- /dev/null
+++ b/board/ifx/u-boot-bootstrap.lds
@@ -0,0 +1,69 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+	__u_boot_cmd_start_bootstrap = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end_bootstrap = .;
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+        . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
--- /dev/null
+++ b/board/ifx/u-boot.lds
@@ -0,0 +1,69 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+        __u_boot_cmd_start = .;
+        .u_boot_cmd : { *(.u_boot_cmd) }
+        __u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+        . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end = .;
+}
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,80 @@
+#!/bin/sh
+
+APPS_NAME="uboot"
+if [ -e sysconfig.sh ]; then
+	. sysconfig.sh
+	. config.sh
+	. model_config.sh
+else
+        echo "Application "$APPS_NAME" not configured"
+        exit 0
+fi
+display_info "----------------------------------------------------------------------"
+display_info "                      build ${IFX_PLATFORM_NAME} u-boot               "
+display_info "----------------------------------------------------------------------"
+
+parse_args $@
+
+UBOOT_CFLAGS="-DCONFIG_IFX_MIPS -DCONFIG_LZMA -DIFX_CONFIG_MEMORY_SIZE=${IFX_CONFIG_MEMORY_SIZE} -DIFX_CONFIG_FLASH_SIZE=${IFX_CONFIG_FLASH_SIZE}"
+
+UBOOT_EXTRA_CFLAGS=
+
+if [ "A${IFX_CONFIG_KERNEL_MEMORY_SIZE}" != "A" ]; then
+	UBOOT_EXTRA_CFLAGS="-DIFX_CONFIG_KERNEL_MEMORY_SIZE=${IFX_CONFIG_KERNEL_MEMORY_SIZE}"
+fi
+if [ "A${IFX_CONFIG_CPU1_SUPPORT}" != "A" -a "${IFX_CONFIG_CPU1_SUPPORT}" = "1" ] ;then
+	UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CPU1_SUPPORT"
+fi
+if [ "${IFX_ADSL_FIRMWARE_IN_ROOTFS}" = "1" ]; then
+        UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_ADSL_FIRMWARE_IN_ROOTFS=1"
+else
+        UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_ADSL_FIRMWARE_IN_ROOTFS=0"
+fi
+if [ "A${IFX_CONFIG_ETHERNET_TYPE}" != "A" ]; then
+	if [ "${IFX_CONFIG_ETHERNET_TYPE}" == "RMII" ]; then
+		UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CONFIG_ETHERNET_TYPE_RMII"
+	elif [ "${IFX_CONFIG_ETHERNET_TYPE}" == "EPHY" ]; then
+		UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CONFIG_ETHERNET_TYPE_EPHY"
+	fi
+fi
+if [ "A${IFX_CONFIG_LED_TYPE}" != "A" ]; then
+	if [ "${IFX_CONFIG_LED_TYPE}" == "GPIO" ]; then
+		UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CONFIG_LED_TYPE_GPIO"
+	elif [ "${IFX_CONFIG_LED_TYPE}" == "LEDC" ]; then
+		UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CONFIG_LED_TYPE_LEDC"
+	fi
+fi
+if [ "A${IFX_CONFIG_WIRELESS_TSC}" != "A" ]; then
+	if [ "${IFX_CONFIG_WIRELESS_TSC}" == "1" ]; then
+		UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CONFIG_WIRELESS_TSC"
+	fi
+fi
+#Sumedh-board specific change
+if [ "A${IFX_CONFIG_CHINA_MKT_1}" != "A" ]; then
+	UBOOT_EXTRA_CFLAGS="${UBOOT_EXTRA_CFLAGS} -DIFX_CONFIG_CHINA_MKT_1"
+fi
+
+UBOOT_CFLAGS="${UBOOT_CFLAGS} ${UBOOT_EXTRA_CFLAGS}"
+
+UBOOT_COMPRESS=lzma
+
+if [ $BUILD_CLEAN -eq 1 ]; then
+        rm -f .config_ok
+	CROSS_COMPILE="mips-linux-" CROSS_COMPILE_UCLIBC=1 COMPRESS=${UBOOT_COMPRESS} PLATFORM_CPU=4kc IFX_CFLAGS="${UBOOT_CFLAGS}" make HEAD_FLASH_TEXT_BASE=${IFX_HEAD_FLASH_TEXT_BASE} UBOOT_RAM_TEXT_BASE=${IFX_UBOOT_RAM_TEXT_BASE} IN_PAD_LEN=${IFX_IN_PAD_LEN} CPU_TYPE=${IFX_CONFIG_CPU} distclean
+        [ $BUILD_CONFIGURE -ne 1 ] && exit 0
+fi
+
+if [ $BUILD_CONFIGURE -eq 1 -o ! -f .config_ok ] ;then
+CROSS_COMPILE="mips-linux-" CROSS_COMPILE_UCLIBC=1 COMPRESS=${UBOOT_COMPRESS} PLATFORM_CPU=4kc IFX_CFLAGS="${UBOOT_CFLAGS}" make UBOOT_RAM_TEXT_BASE=${IFX_UBOOT_RAM_TEXT_BASE} CPU_TYPE=${IFX_CONFIG_CPU} ifx_mips_config
+        echo -n > .config_ok
+fi
+
+CROSS_COMPILE="mips-linux-" CROSS_COMPILE_UCLIBC=1 COMPRESS=${UBOOT_COMPRESS} PLATFORM_CPU=4kc IFX_CFLAGS="${UBOOT_CFLAGS}" make UBOOT_RAM_TEXT_BASE=${IFX_UBOOT_RAM_TEXT_BASE} BOOTSTRAP_PRINTF_STATUS=$2 CPU_TYPE=${IFX_CONFIG_CPU} ifx_all
+
+
+if [ -e u-boot.ifx ];then
+	cp -f u-boot.ifx "$BUILD_DIR"
+	if [ "$COPY_TFTP" = "y" ];then
+		cp -f u-boot.ifx "$TFTP_DIR"
+	fi
+fi
--- a/common/Makefile
+++ b/common/Makefile
@@ -40,7 +40,7 @@
 	  cmd_nand.o cmd_net.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o \
-	  cmd_usb.o cmd_vfd.o \
+	  cmd_usb.o cmd_vfd.o cmd_dhry.o cmd_upgrade.o \
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
@@ -51,7 +51,7 @@
 	  memsize.o miiphybb.o miiphyutil.o \
 	  s_record.o serial.o soft_i2c.o soft_spi.o spartan2.o spartan3.o \
 	  usb.o usb_kbd.o usb_storage.o \
-	  virtex2.o xilinx.o crc16.o xyzModem.o
+	  virtex2.o xilinx.o crc16.o xyzModem.o upgrade.o
 
 SRCS	:= $(AOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(AOBJS) $(COBJS))
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -31,6 +31,7 @@
 #include <malloc.h>
 #include <zlib.h>
 #include <bzlib.h>
+#include <LzmaWrapper.h>
 #include <environment.h>
 #include <asm/byteorder.h>
 
@@ -79,6 +80,8 @@
 # define CHUNKSZ (64 * 1024)
 #endif
 
+#ifndef CFG_HEAD_CODE
+
 int  gunzip (void *, int, unsigned char *, unsigned long *);
 
 static void *zalloc(void *, unsigned, unsigned);
@@ -149,6 +152,102 @@
 image_header_t header;
 
 ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */
+#if (IFX_ADSL_FIRMWARE_IN_ROOTFS == 1)
+#define TOTAL_IMAGES	2
+#else
+#define TOTAL_IMAGES	3
+#endif
+#define IMAGE_STATUS_KERNEL	0x1
+#define IMAGE_STATUS_ROOTFS	0x2
+#define IMAGE_STATUS_FIRMWARE	0x4
+
+static int upgrade_error_recovery(void)
+{
+	char *addr_str, *size_str, *crc_str;
+	ulong addr, size, crc;
+	int len;
+	char *data;
+	int bReset = 0;
+	int verify_fullimage;
+	char *s;
+	int i=0;
+#if (IFX_ADSL_FIRMWARE_IN_ROOTFS == 1)
+	struct st_img_array {
+		char *name;
+		char *addr_str;
+		char *size_str;
+		char *crc_str;
+		int offset;
+	} img_array[TOTAL_IMAGES] = {
+		{ "Kernel", "f_kernel_addr", "f_kernel_size", "f_kernel_crc", sizeof(image_header_t) },
+		{ "Rootfs", "f_rootfs_addr", "f_rootfs_size", "f_rootfs_crc", 0 },
+	};
+#else
+	struct st_img_array {
+		char *name;
+		char *addr_str;
+		char *size_str;
+		char *crc_str;
+		int offset;
+	} img_array[TOTAL_IMAGES] = {
+		{ "Kernel", "f_kernel_addr", "f_kernel_size", "f_kernel_crc", sizeof(image_header_t) },
+		{ "Rootfs", "f_rootfs_addr", "f_rootfs_size", "f_rootfs_crc", 0 },
+		{ "Firmware", "f_firmware_addr", "f_firmware_size", "f_firmware_crc", 0 },
+	};
+#endif
+
+
+	s = getenv ("disable_recovery");
+	if (s && (*s == 'y'))
+		return;
+
+	s = getenv ("multiimage");
+	verify_fullimage = (s && (*s == 'y')) ? 0 : 1;
+	puts ("Checking Images Integrity ...\n");
+	for (i=0; i<TOTAL_IMAGES; i++)
+	{
+		addr_str = getenv(img_array[i].addr_str);
+		size_str = getenv(img_array[i].size_str);
+		crc_str = getenv(img_array[i].crc_str);
+		if (crc_str)
+		{
+			addr = simple_strtoul(addr_str, NULL, 16);
+			size = simple_strtoul(size_str, NULL, 16);
+			crc  = simple_strtoul(crc_str, NULL, 16);
+
+			data = (char *)(addr + img_array[i].offset);
+			len  = size - img_array[i].offset;
+
+			if (crc32 (0, (uchar *)data, len) != crc ) {
+				printf ("  %s: CRC Error\n", img_array[i].name);
+				bReset |= 1<<i;
+			}
+			else
+				printf ("  %s: OK\n", img_array[i].name);
+		}
+		else
+		{
+			printf("  %s: not existing\n", img_array[i].name);
+			bReset |= 1<<i;
+		}
+	}
+	if ( bReset != 0 )
+	{
+		if ( verify_fullimage )
+			run_command("run update_fullimage",0);
+		else
+		{
+			if (bReset & IMAGE_STATUS_KERNEL)
+				run_command("run update_kernel",0);
+			if (bReset & IMAGE_STATUS_ROOTFS)
+				run_command("run update_rootfs",0);
+			if (bReset & IMAGE_STATUS_FIRMWARE)
+				run_command("run update_firmware",0);
+		}
+		run_command("reset",0);
+	}
+	return 0;
+}
 
 int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -162,6 +261,8 @@
 	int	(*appl)(int, char *[]);
 	image_header_t *hdr = &header;
 
+	upgrade_error_recovery();
+
 	s = getenv ("verify");
 	verify = (s && (*s == 'n')) ? 0 : 1;
 
@@ -341,6 +442,7 @@
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 		}
 		break;
+#ifndef CONFIG_REMOVE_GZIP
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
@@ -350,6 +452,7 @@
 			do_reset (cmdtp, flag, argc, argv);
 		}
 		break;
+#endif /* CONFIG_REMOVE_GZIP */
 #ifdef CONFIG_BZIP2
 	case IH_COMP_BZIP2:
 		printf ("   Uncompressing %s ... ", name);
@@ -369,6 +472,18 @@
 		}
 		break;
 #endif /* CONFIG_BZIP2 */
+#ifdef CONFIG_LZMA
+	case IH_COMP_LZMA:
+		printf ("   Uncompressing %s ... ", name);
+		i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &unc_len);
+		if (i != LZMA_RESULT_OK) {
+			printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+			SHOW_BOOT_PROGRESS (-6);
+			udelay(100000);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		break;
+#endif /* CONFIG_LZMA */
 	default:
 		if (iflag)
 			enable_interrupts();
@@ -413,11 +528,12 @@
 	default:			/* handled by (original) Linux case */
 	case IH_OS_LINUX:
 #ifdef CONFIG_SILENT_CONSOLE
-	    fixup_silent_linux();
+		fixup_silent_linux();
 #endif
-	    do_bootm_linux  (cmdtp, flag, argc, argv,
+		mips_cache_unlock();
+		do_bootm_linux  (cmdtp, flag, argc, argv,
 			     addr, len_ptr, verify);
-	    break;
+		break;
 	case IH_OS_NETBSD:
 	    do_bootm_netbsd (cmdtp, flag, argc, argv,
 			     addr, len_ptr, verify);
@@ -1176,6 +1292,8 @@
 );
 #endif	/* CFG_CMD_IMLS */
 
+#endif	/* ! CFG_HEAD_CODE */
+
 void
 print_image_hdr (image_header_t *hdr)
 {
@@ -1211,7 +1329,43 @@
 	}
 }
 
+#ifdef IFX_UBOOT_OPTIMIZED
+static void
+print_type (image_header_t *hdr)
+{
+	char *os, *arch, *type, *comp;
+
+	switch (hdr->ih_os) {
+	case IH_OS_INVALID:	os = "Invalid OS";		break;
+	case IH_OS_LINUX:	os = "Linux";			break;
+	case IH_OS_U_BOOT:	os = "U-Boot";			break;
+	default:		os = "Unknown OS";		break;
+	}
+
+	switch (hdr->ih_arch) {
+	case IH_CPU_INVALID:	arch = "Invalid CPU";		break;
+	case IH_CPU_MIPS:	arch = "MIPS";			break;
+	default:		arch = "Unknown Architecture";	break;
+	}
+
+	switch (hdr->ih_type) {
+	case IH_TYPE_INVALID:	type = "Invalid Image";		break;
+	case IH_TYPE_KERNEL:	type = "Kernel Image";		break;
+	case IH_TYPE_FIRMWARE:	type = "Firmware";		break;
+	default:		type = "Unknown Image";		break;
+	}
+
+	switch (hdr->ih_comp) {
+	case IH_COMP_NONE:	comp = "uncompressed";		break;
+	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
+	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	case IH_COMP_LZMA:      comp = "lzma compressed";       break;
+	default:		comp = "unknown compression";	break;
+	}
 
+	printf ("%s %s %s (%s)", arch, os, type, comp);
+}
+#else
 static void
 print_type (image_header_t *hdr)
 {
@@ -1270,11 +1424,15 @@
 	case IH_COMP_NONE:	comp = "uncompressed";		break;
 	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
 	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	case IH_COMP_LZMA:      comp = "lzma compressed";       break;
 	default:		comp = "unknown compression";	break;
 	}
 
 	printf ("%s %s %s (%s)", arch, os, type, comp);
 }
+#endif
+
+#ifndef CFG_HEAD_CODE
 
 #define	ZALLOC_ALIGNMENT	16
 
@@ -1427,3 +1585,5 @@
 }
 
 #endif /* CONFIG_LYNXKDI */
+
+#endif /* ! CFG_HEAD_CODE */
--- /dev/null
+++ b/common/cmd_dhry.c
@@ -0,0 +1,467 @@
+/*
+ *************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *
+ *  Version:    C, Version 2.1
+ *
+ *  File:       cmd_dhry.c
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *
+ *************************************************************************
+ */
+#include <common.h>
+#include <command.h>
+#include <cmd_dhry.h>
+
+#define REG
+#define Too_Small_Time 2
+
+#if (CONFIG_COMMANDS & CFG_CMD_DHRYSTONE)
+
+/* Global Variables: */
+Rec_Pointer     Ptr_Glob, Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob, Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50][50];
+ulong	Begin_Time, End_Time, User_Time;
+//double          Microseconds, Dhrystones_Per_Second, Vax_Mips;
+ulong	Microseconds, Dhrystones_Per_Second, Vax_Mips;
+
+int do_dhrystone (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]) {
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Initializations */
+  Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+  /* Was missing in published program. Without this statement,    */
+  /* Arr_2_Glob [8][7] would have an undefined value.             */
+  /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+  /* overflow may occur for this array element.                   */
+
+  printf ("\n");
+  printf ("Dhrystone Benchmark, Version 2.1 (Language: C)\n");
+  printf ("\n");
+
+  Number_Of_Runs = 500000;
+  printf ("Execution starts, %d runs through Dhrystone\n", Number_Of_Runs);
+
+  /***************/
+  /* Start timer */
+  /***************/
+  reset_timer();
+  Begin_Time = get_timer(0);
+
+  for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+  {
+    Proc_5();
+    Proc_4();
+      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+    Int_1_Loc = 2;
+    Int_2_Loc = 3;
+    strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+    Enum_Loc = Ident_2;
+    Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+      /* Bool_Glob == 1 */
+    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+    {
+      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+        /* Int_3_Loc == 7 */
+      Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+        /* Int_3_Loc == 7 */
+      Int_1_Loc += 1;
+    } /* while */
+      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+      /* Int_Glob == 5 */
+    Proc_1 (Ptr_Glob);
+    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+                             /* loop body executed twice */
+    {
+      if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+          /* then, not executed */
+        {
+        Proc_6 (Ident_1, &Enum_Loc);
+        strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+        Int_2_Loc = Run_Index;
+        Int_Glob = Run_Index;
+        }
+    }
+      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+    Int_2_Loc = Int_2_Loc * Int_1_Loc;
+    Int_1_Loc = Int_2_Loc / Int_3_Loc;
+    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+    Proc_2 (&Int_1_Loc);
+      /* Int_1_Loc == 5 */
+
+  } /* loop "for Run_Index" */
+
+  /**************/
+  /* Stop timer */
+  /**************/
+  End_Time = get_timer(Begin_Time);
+
+  printf ("Execution ends\n");
+  printf ("\n");
+  printf ("Final values of the variables used in the benchmark:\n");
+  printf ("\n");
+  printf ("Int_Glob:            %d\n", Int_Glob);
+  printf ("        should be:   %d\n", 5);
+  printf ("Bool_Glob:           %d\n", Bool_Glob);
+  printf ("        should be:   %d\n", 1);
+  printf ("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  printf ("        should be:   %c\n", 'A');
+  printf ("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  printf ("        should be:   %c\n", 'B');
+  printf ("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  printf ("        should be:   %d\n", 7);
+  printf ("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  printf ("        should be:   Number_Of_Runs + 10\n");
+  printf ("Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %lu\n", Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent)\n");
+  printf ("  Discr:             %d\n", Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 2);
+  printf ("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 17);
+  printf ("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Next_Ptr_Glob->\n");
+  printf ("        should be:   (implementation-dependent), same as above\n");
+  printf ("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 1);
+  printf ("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 18);
+  printf ("  Str_Comp:          %s\n", Next_Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Int_1_Loc:           %d\n", Int_1_Loc);
+  printf ("        should be:   %d\n", 5);
+  printf ("Int_2_Loc:           %d\n", Int_2_Loc);
+  printf ("        should be:   %d\n", 13);
+  printf ("Int_3_Loc:           %d\n", Int_3_Loc);
+  printf ("        should be:   %d\n", 7);
+  printf ("Enum_Loc:            %d\n", Enum_Loc);
+  printf ("        should be:   %d\n", 1);
+  printf ("Str_1_Loc:           %s\n", Str_1_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  printf ("Str_2_Loc:           %s\n", Str_2_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  printf ("\n");
+
+  User_Time = End_Time/CFG_HZ;
+
+  if (User_Time < Too_Small_Time)
+  {
+    printf ("Measured time too small to obtain meaningful results\n");
+    printf ("Please increase number of runs\n");
+    printf ("\n");
+  }
+  else
+  {
+#if 1
+//    Microseconds = User_Time * Mic_secs_Per_Second / (double) Number_Of_Runs;
+    Microseconds = User_Time * Mic_secs_Per_Second /  Number_Of_Runs;
+//    Dhrystones_Per_Second = (double) Number_Of_Runs / User_Time;
+    Dhrystones_Per_Second =  Number_Of_Runs / User_Time;
+//    Vax_Mips = Dhrystones_Per_Second / 1757.0;
+    Vax_Mips = Dhrystones_Per_Second / 1757;
+
+//    printf ("Microseconds for one run through Dhrystone: ");
+//    printf ("%7.1lf \n", Microseconds);
+//    printf ("%lu \n", Microseconds);
+//    printf ("Dhrystones per Second:                      ");
+//    printf ("%10.1lf \n", Dhrystones_Per_Second);
+//    printf ("%lu \n", Dhrystones_Per_Second);
+//    printf ("VAX MIPS rating = %10.3lf \n",Vax_Mips);
+    printf ("Dhrystones per Second: %lu \n", Dhrystones_Per_Second);
+    printf ("VAX MIPS rating = %lu \n", Vax_Mips);
+    printf ("\n");
+#endif
+  }
+
+  return 0;
+}
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob);
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp,
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10,
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1:
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2:
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5:
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+U_BOOT_CMD(
+	dhrystone,	1,	1,	do_dhrystone,
+	"dhrystone	- benchmark\n",
+	"dhrystone\n"
+);
+
+#endif	//CFG_CMD_DHRYSTONE
--- a/common/cmd_flash.c
+++ b/common/cmd_flash.c
@@ -196,9 +196,17 @@
 }
 
 static int
-flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
-			int *s_first, int *s_last,
-			int *s_count )
+flash_fill_sect_ranges(
+	ulong *addr_first_sect_start,
+	ulong addr_first,
+	ulong *addr_last_sect_end,
+	ulong addr_last,
+	int *s_first,
+	int *s_last,
+	int *bPartialStart,
+	int *bPartialEnd,
+	int *s_count,
+	unsigned int bPartialErase)
 {
 	flash_info_t *info;
 	ulong bank;
@@ -211,9 +219,7 @@
 		s_last [bank] = -1;	/* last  sector to erase	*/
 	}
 
-	for (bank=0,info=&flash_info[0];
-	     (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last);
-	     ++bank, ++info) {
+	for (bank=0, info=&flash_info[0]; (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last); ++bank, ++info) {
 		ulong b_end;
 		int sect;
 		short s_end;
@@ -225,7 +231,6 @@
 		b_end = info->start[0] + info->size - 1;	/* bank end addr */
 		s_end = info->sector_count - 1;			/* last sector   */
 
-
 		for (sect=0; sect < info->sector_count; ++sect) {
 			ulong end;	/* last address in current sect	*/
 
@@ -238,11 +243,21 @@
 
 			if (addr_first == info->start[sect]) {
 				s_first[bank] = sect;
+			} else if (addr_first > info->start[sect] && addr_first <= end && bPartialErase) {
+				*addr_first_sect_start = info->start[sect];
+				s_first[bank] = sect;
+				*bPartialStart = 1;
 			}
+
 			if (addr_last  == end) {
 				s_last[bank]  = sect;
+			} else if (addr_last >= info->start[sect] && addr_last < end && bPartialErase) {
+				*addr_last_sect_end = end;
+				s_last[bank] = sect;
+				*bPartialEnd = 1;
 			}
 		}
+
 		if (s_first[bank] >= 0) {
 			if (s_last[bank] < 0) {
 				if (addr_last > b_end) {
@@ -316,6 +331,8 @@
 	struct part_info *part;
 	u8 dev_type, dev_num, pnum;
 #endif
+	unsigned int bPartialErase = 0;
+
 	int rcode = 0;
 
 	if (argc < 2) {
@@ -369,7 +386,7 @@
 	}
 #endif
 
-	if (argc != 3) {
+	if (argc != 4) {
 		printf ("Usage:\n%s\n", cmdtp->usage);
 		return 1;
 	}
@@ -397,11 +414,95 @@
 		return 1;
 	}
 
-	rcode = flash_sect_erase(addr_first, addr_last);
+	printf ("Erase Flash from 0x%08lx to 0x%08lx\n", addr_first, addr_last);
+	if(argc == 4) {
+		bPartialErase = simple_strtoul(argv[3], NULL, 10);
+	}
+
+	rcode = flash_sect_erase(addr_first, addr_last, bPartialErase);
 	return rcode;
 }
 
-int flash_sect_erase (ulong addr_first, ulong addr_last)
+static char flerase_sector_buf[CFG_MAX_FLASH_SECT_SIZE];
+
+int flerase_Partial(
+	ulong addr_first_sect_start,
+	ulong addr_first,
+	ulong addr_last_sect_end,
+	ulong addr_last,
+	flash_info_t *info,
+	int first_sect,
+	int last_sect,
+	int bFirstPartial,
+	int bLastPartial)
+{
+	unsigned int sectMemLen = 0;
+	uchar *pSavedSectMem = flerase_sector_buf;
+	int rt_code = 0;
+
+	debug("%s ... 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%p, %d, %d, %d, %d\n", __FUNCTION__, addr_first_sect_start, addr_first, addr_last_sect_end, addr_last, info, first_sect, last_sect, bFirstPartial, bLastPartial);
+
+	if (bFirstPartial && bLastPartial && (first_sect == last_sect)) {
+		ulong b_end = info->start[0] + info->size - 1;
+		ulong end = (first_sect == (info->sector_count - 1)) ? b_end : info->start[first_sect + 1] - 1;
+
+		sectMemLen = end - info->start[first_sect] + 1;
+		memset(pSavedSectMem, 0xff, CFG_MAX_FLASH_SECT_SIZE);
+		memcpy(pSavedSectMem, (uchar *)addr_first_sect_start, addr_first - addr_first_sect_start);
+		memcpy(pSavedSectMem + (addr_last - info->start[first_sect]) + 1, addr_last + 1, end - addr_last);
+		if (flash_erase(info, first_sect, first_sect)) {
+			printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, first_sect);
+			rt_code = 1;
+			goto ret;
+		}
+		debug("%s ... erase sector %d done!\n", __FUNCTION__, first_sect);
+		if (flash_write(pSavedSectMem, (uchar *)addr_first_sect_start, sectMemLen)) {
+			printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_first_sect_start, sectMemLen);
+			rt_code = 1;
+			goto ret;
+		}
+		debug("flash_write from 0x%08x with len %u\n", addr_first_sect_start, sectMemLen);
+	} else {
+		if (bFirstPartial) {
+			sectMemLen = addr_first - addr_first_sect_start + 1;
+			memset(pSavedSectMem, 0xff, CFG_MAX_FLASH_SECT_SIZE);
+			memcpy(pSavedSectMem, (uchar *)addr_first_sect_start, sectMemLen - 1);
+			if (flash_erase(info, first_sect, first_sect)) {
+				printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, first_sect);
+				rt_code = 1;
+				goto ret;
+			}
+			debug("%s ... erase sector %d done!\n", __FUNCTION__, first_sect);
+			if (flash_write(pSavedSectMem, (uchar *)addr_first_sect_start, sectMemLen - 1)) {
+				printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_first_sect_start, sectMemLen - 1);
+				rt_code = 1;
+				goto ret;
+			}
+			debug("flash_write from 0x%08x with len %u\n", addr_first_sect_start, sectMemLen);
+		}
+		if (bLastPartial) {
+			sectMemLen = addr_last_sect_end - addr_last + 1;
+			memset(pSavedSectMem, 0xff, CFG_MAX_FLASH_SECT_SIZE);
+			memcpy(pSavedSectMem, (uchar *)addr_last + 1, sectMemLen - 1);
+			if(flash_erase (info, last_sect, last_sect)) {
+				printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, last_sect);
+				rt_code = 1;
+				goto ret;
+			}
+			debug("%s ... erase sector %d done!\n", __FUNCTION__, last_sect);
+			if (flash_write(pSavedSectMem, (uchar *)addr_last + 1, sectMemLen - 1)) {
+				printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_last, sectMemLen - 1);
+				rt_code = 1;
+				goto ret;
+			}
+			debug("flash_write from 0x%08x with len %u\n", addr_last, sectMemLen);
+		}
+	}
+ret:
+	return rt_code;
+}
+
+int flash_sect_erase (ulong addr_first, ulong addr_last, unsigned int bPartialErase)
 {
 	flash_info_t *info;
 	ulong bank;
@@ -412,28 +513,66 @@
 #endif
 	int erased = 0;
 	int planned;
-	int rcode = 0;
-
-	rcode = flash_fill_sect_ranges (addr_first, addr_last,
-					s_first, s_last, &planned );
+	int rcode = 1;
+	int bPartialStart = 0;		// Start sector has to be erased partially
+	int bPartialEnd = 0;		// End sector has to be erased partially
+	ulong addr_first_sect_start = 0;// Sector start address of location addr_start
+	ulong addr_last_sect_end = 0;	// Sector end address of location addr_last
+
+	rcode = flash_fill_sect_ranges (
+			&addr_first_sect_start,
+			addr_first,
+			&addr_last_sect_end,
+			addr_last,
+			s_first,
+			s_last,
+			&bPartialStart,
+			&bPartialEnd,
+			&planned,
+			bPartialErase );
 
 	if (planned && (rcode == 0)) {
-		for (bank=0,info=&flash_info[0];
-		     (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0);
-		     ++bank, ++info) {
+		for (bank=0, info=&flash_info[0]; (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0); ++bank, ++info) {
+			ulong b_end = info->start[0] + info->size - 1;	/* bank end addr */
 			if (s_first[bank]>=0) {
-				erased += s_last[bank] - s_first[bank] + 1;
-				debug ("Erase Flash from 0x%08lx to 0x%08lx "
-					"in Bank # %ld ",
-					info->start[s_first[bank]],
-					(s_last[bank] == info->sector_count) ?
-						info->start[0] + info->size - 1:
-						info->start[s_last[bank]+1] - 1,
-					bank+1);
-				rcode = flash_erase (info, s_first[bank], s_last[bank]);
+				if(bPartialErase) {
+					rcode = flerase_Partial(
+							addr_first_sect_start,
+							addr_first,
+							addr_last_sect_end,
+							addr_last,
+							info,
+							s_first[bank],
+							s_last[bank],
+							bPartialStart,
+							bPartialEnd);
+				}
+				//Erase full sectores
+				if (bPartialStart)
+					s_first[bank] += 1;
+				if (bPartialEnd)
+					s_last[bank] -= 1;
+				if (s_last[bank] >= s_first[bank]) {
+					erased += s_last[bank] - s_first[bank] + 1;
+					debug ("Erase Flash from 0x%08lx to 0x%08lx in Bank # %ld ",
+						info->start[s_first[bank]],
+						(s_last[bank] == info->sector_count) ?
+							info->start[0] + info->size - 1:
+							info->start[s_last[bank]+1] - 1,
+						bank + 1);
+					rcode = flash_erase (info, s_first[bank], s_last[bank]);
+				}
 			}
 		}
-		printf ("Erased %d sectors\n", erased);
+
+		if (erased && !bPartialErase) {
+			printf ("Erased %d sectors\n", erased);
+		} else if (bPartialErase){
+			printf ("Partial erased from 0x%08lx to 0x%08lx\n", addr_first, addr_last);
+		} else {
+			printf ("Error: start and/or end address not on sector boundary\n");
+			rcode = 1;
+		}
 	} else if (rcode == 0) {
 		puts ("Error: start and/or end address"
 			" not on sector boundary\n");
@@ -629,8 +768,22 @@
 	int protected, i;
 	int planned;
 	int rcode;
-
-	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
+	int bPartialStart = 0;		// Start sector has to be erased partially
+	int bPartialEnd = 0;		// End sector has to be erased partially
+	ulong addr_first_sect_start = 0;// Sector start address of location addr_start
+	ulong addr_last_sect_end = 0;	// Sector end address of location addr_last
+
+	rcode = flash_fill_sect_ranges (
+			&addr_first_sect_start,
+			addr_first,
+			&addr_last_sect_end,
+			addr_last,
+			s_first,
+			s_last,
+			&bPartialStart,
+			&bPartialEnd,
+			&planned,
+			1 );
 
 	protected = 0;
 
@@ -690,7 +843,7 @@
 );
 
 U_BOOT_CMD(
-	erase,   3,   1,  do_flerase,
+	erase,   4,   1,  do_flerase,
 	"erase   - erase FLASH memory\n",
 	"start end\n"
 	"    - erase FLASH from addr 'start' to addr 'end'\n"
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -540,8 +540,19 @@
 	extern char * env_name_spec;
 
 	printf ("Saving Environment to %s...\n", env_name_spec);
-
+#if 1
+	if(saveenv() == 0) {
+#ifdef UBOOT_ENV_COPY
+		saveenv_copy();
+#else
+		;
+#endif //UBOOT_ENV_COPY
+	} else
+		return 1;
+	return 0;
+#else
 	return (saveenv() ? 1 : 0);
+#endif
 }
 
 
--- /dev/null
+++ b/common/cmd_upgrade.c
@@ -0,0 +1,217 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Cache support: switch on or off, get status
+ */
+#include <common.h>
+#include <command.h>
+#include <cmd_upgrade.h>
+
+#if defined(BUILD_FROM_IFX_UTILITIES)
+#include "crc32.h"
+#include <syslog.h>
+#define getenv(x)		get_env(x)
+#define simple_strtoul(a,b,c)	strtoul(a,b,c)
+#define setenv(x,y)		set_env(x,y)
+#define uchar			unsigned char
+#define ulong			unsigned long
+#define uint32_t		unsigned int
+#define uint8_t			unsigned char
+//#define printf(format, args...)	syslog(LOG_INFO, format, ##args)
+#endif //BUILD_FROM_IFX_UTILITIES
+
+#include "image.h"
+
+#if !defined(BUILD_FROM_IFX_UTILITIES)
+int do_upgrade( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]) {
+	ulong srcAddr=0;
+	int srcLen;
+	ulong srcHeader=0;
+	int curParSize=0, dir, pad;
+	image_header_t *pimg_header = NULL;
+	char name[16], strimg_crc[32], buf[32];;
+
+	if(argc != 3) {
+		printf("Usage :\n%s\n",cmdtp->usage);
+		return 1;
+	}
+
+	srcAddr = simple_strtoul(argv[1], NULL, 16);
+	srcLen = simple_strtoul(argv[2], NULL, 16);
+
+	do {
+		srcHeader = (!srcHeader ? srcAddr : srcHeader + curParSize);
+		pimg_header = (image_header_t *)srcHeader;
+		curParSize = sizeof(image_header_t) + pimg_header->ih_size;
+		pad = (16 - (curParSize % 16)) % 16;
+
+		switch(pimg_header->ih_type) {
+			case IH_TYPE_MULTI:
+				curParSize = sizeof(image_header_t) + 8;
+				continue;
+			case IH_TYPE_FILESYSTEM:
+				sprintf(name, "rootfs");
+				dir = 0;
+				break;
+			case IH_TYPE_KERNEL:
+				sprintf(name, "kernel");
+				dir = 1;
+				break;
+			case IH_TYPE_FIRMWARE:
+				sprintf(name, "firmware");
+				dir = 0;
+				break;
+			default:
+				printf("Unknown image type!!\n");
+				continue;
+		}
+
+		if(upgrade_img(srcHeader, curParSize, name, dir, 0)) {
+			printf("Can not upgrade the image %s\n", name);
+		} else {
+			sprintf(strimg_crc, "f_%s_crc", name);
+			sprintf(buf, "%lX", ntohl(pimg_header->ih_dcrc));
+			setenv(strimg_crc, buf);
+			saveenv();
+#ifdef UBOOT_ENV_COPY
+			saveenv_copy();
+#endif
+		}
+		curParSize = curParSize + pad;
+	} while(srcLen > (srcHeader - srcAddr) + curParSize);
+
+	return 0;
+}
+
+#else
+
+int do_upgrade( int file_fd , int srcLen) {
+	ulong srcHeader=0;
+	uint32_t curParSize=0, dir, pad;
+	char name[16], strimg_crc[32], buf[32];;
+	image_header_t xImgHeader;
+	char *xHeader = NULL;
+	uint32_t iFileReadSize =0, iTotalFileReadSize = 0;
+	int iRet = 0;
+
+	do {
+
+		//first read only the header to figure our the image total size
+		iRet = read(file_fd, (void *)&xImgHeader , (size_t)sizeof(image_header_t));
+		if(iRet < sizeof(image_header_t)){
+			printf("Failure : could read %d out of %d bytes from image\n", iRet, sizeof(image_header_t));
+			return 1; //failure
+		}
+
+		printf("\nImage Header --> Data Size = %d\n Image Name = %s\n",xImgHeader.ih_size , xImgHeader.ih_name);
+
+                if(xImgHeader.ih_type == IH_TYPE_MULTI){
+                        curParSize = sizeof(image_header_t) + 8;
+                        iTotalFileReadSize += curParSize;
+                        if( lseek(file_fd, iTotalFileReadSize, SEEK_SET) == -1){
+                                printf("Can not move the offset for image to upgrade\n");
+                                return 1;  //failure
+                        }
+
+                        continue;
+                }
+
+
+		curParSize = sizeof(image_header_t) + xImgHeader.ih_size;
+		pad = (16 - (curParSize % 16)) % 16;
+
+		// reposition the file read offset to the start of image
+		if( lseek(file_fd, iTotalFileReadSize, SEEK_SET) == -1){
+			printf("Can not move the offset for image to upgrade\n");
+		        return 1;  //failure
+		}
+
+		// then read the total size into a buffer to be passed to upgrade_img
+		iFileReadSize = curParSize + pad;
+	        xHeader = (char *)malloc(iFileReadSize);
+
+		iRet = read(file_fd, xHeader , (size_t)iFileReadSize);
+       		if(iRet < iFileReadSize){
+			printf("Failure : could read %d out of %d bytes from image\n", iRet, iFileReadSize);
+			return 1; //failure
+		}
+
+
+		switch(xImgHeader.ih_type) {
+			case IH_TYPE_MULTI:
+				curParSize = sizeof(image_header_t) + 8;
+				continue;
+			case IH_TYPE_FILESYSTEM:
+				sprintf(name, "rootfs");
+				dir = 0;
+				break;
+			case IH_TYPE_KERNEL:
+				sprintf(name, "kernel");
+				dir = 1;
+				break;
+			case IH_TYPE_FIRMWARE:
+				sprintf(name, "firmware");
+				dir = 0;
+				break;
+			default:
+				printf("Unknown image type!!\n");
+				continue;
+		}
+
+		if(upgrade_img(xHeader, curParSize, name, dir, 0)) {
+			printf("Can not upgrade the image %s\n", name);
+		} else {
+			sprintf(strimg_crc, "f_%s_crc", name);
+			sprintf(buf, "%lX", ntohl(xImgHeader.ih_dcrc));
+			setenv(strimg_crc, buf);
+			saveenv();
+#ifdef UBOOT_ENV_COPY
+			saveenv_copy();
+#endif
+		}
+		iTotalFileReadSize += iFileReadSize;
+
+		if(xHeader != NULL){
+			free(xHeader);
+			xHeader = NULL;
+		}
+
+	} while(srcLen > iTotalFileReadSize );
+
+	return 0;
+}
+#endif
+
+
+#if !defined(BUILD_FROM_IFX_UTILITIES)
+U_BOOT_CMD(
+	upgrade,	3,	1,	do_upgrade,
+	"upgrade - forward/backward copy memory to pre-defined flash location\n",
+	"upgrade <source addr> <size> \n	- upgrade image to pre-define partition.\n"
+);
+#endif
+
+
+
+
--- a/common/console.c
+++ b/common/console.c
@@ -324,7 +324,6 @@
 #endif
 
 /** U-Boot INIT FUNCTIONS *************************************************/
-
 int console_assign (int file, char *devname)
 {
 	int flag, i;
@@ -357,7 +356,6 @@
 
 	return -1;
 }
-
 /* Called before relocation - use serial functions */
 int console_init_f (void)
 {
@@ -484,6 +482,7 @@
 
 #else /* CFG_CONSOLE_IS_IN_ENV */
 
+#ifndef CFG_BOOTSTRAP_CODE
 /* Called after the relocation - use desired console functions */
 int console_init_r (void)
 {
@@ -568,5 +567,6 @@
 
 	return (0);
 }
+#endif //CFG_BOOTSTRAP_CODE
 
 #endif /* CFG_CONSOLE_IS_IN_ENV */
--- a/common/devices.c
+++ b/common/devices.c
@@ -39,6 +39,7 @@
 list_t devlist = 0;
 device_t *stdio_devices[] = { NULL, NULL, NULL };
 char *stdio_names[MAX_FILES] = { "stdin", "stdout", "stderr" };
+#ifndef CFG_BOOTSTRAP_CODE
 
 #if defined(CONFIG_SPLASH_SCREEN) && !defined(CFG_DEVICE_NULLDEV)
 #define	CFG_DEVICE_NULLDEV	1
@@ -214,3 +215,5 @@
 
 	return 0;
 }
+#endif //CFG_BOOTSTRAP_CODE
+
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -136,7 +136,7 @@
 	"pcidelay="	MK_STR(CONFIG_PCI_BOOTDELAY)	"\0"
 #endif
 #ifdef  CONFIG_EXTRA_ENV_SETTINGS
-	CONFIG_EXTRA_ENV_SETTINGS
+#include	CONFIG_EXTRA_ENV_SETTINGS
 #endif
 	"\0"
 };
@@ -219,7 +219,9 @@
 	 * We must allocate a buffer for the environment
 	 */
 	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
-	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
+	if(!env_ptr)
+		DEBUGF ("malloc env_ptr error!!\n");
+	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__, __LINE__, env_ptr);
 #endif
 
 	/*
@@ -227,6 +229,10 @@
 	 */
 	env_get_char = env_get_char_memory;
 
+	//leejack
+	DEBUGF ("%s[%d] gd->env_valid=%d\n", __FUNCTION__, __LINE__, gd->env_valid);
+	DEBUGF ("%s[%d] CFG_ENV_SIZE=%d\n", __FUNCTION__, __LINE__, CFG_ENV_SIZE);
+
 	if (gd->env_valid == 0) {
 #if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
 		puts ("Using default environment\n\n");
@@ -242,18 +248,17 @@
 		}
 
 		memset (env_ptr, 0, sizeof(env_t));
-		memcpy (env_ptr->data,
-			default_environment,
-			sizeof(default_environment));
+		memcpy (env_ptr->data, default_environment, sizeof(default_environment));
+
 #ifdef CFG_REDUNDAND_ENVIRONMENT
 		env_ptr->flags = 0xFF;
 #endif
 		env_crc_update ();
 		gd->env_valid = 1;
-	}
-	else {
+	} else {
 		env_relocate_spec ();
 	}
+
 	gd->env_addr = (ulong)&(env_ptr->data);
 
 #ifdef CONFIG_AMIGAONEG3SE
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -34,6 +34,7 @@
 #include <environment.h>
 #include <linux/stddef.h>
 #include <malloc.h>
+#include <cmd_upgrade.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -66,7 +67,6 @@
 #endif
 
 #else /* ! ENV_IS_EMBEDDED */
-
 env_t *env_ptr = (env_t *)CFG_ENV_ADDR;
 #ifdef CMD_SAVEENV
 static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
@@ -201,6 +201,7 @@
 	debug (" %08lX ... %08lX ...",
 		(ulong)&(flash_addr_new->data),
 		sizeof(env_ptr->data)+(ulong)&(flash_addr_new->data));
+
 	if ((rc = flash_write((char *)env_ptr->data,
 			(ulong)&(flash_addr_new->data),
 			sizeof(env_ptr->data))) ||
@@ -256,7 +257,6 @@
 #endif /* CMD_SAVEENV */
 
 #else /* ! CFG_ENV_ADDR_REDUND */
-
 int  env_init(void)
 {
 #ifdef CONFIG_OMAP2420H4
@@ -280,8 +280,55 @@
 
 #ifdef CMD_SAVEENV
 
+#ifdef UBOOT_ENV_COPY
+int saveenv_copy(void) {
+	uchar *env_buffer = (char *)env_ptr;
+	char *kernel_addr;
+	char *rootfs_addr;
+	char *rootfs_size;
+	ulong start_addr,end_addr,rootfs_end_addr;
+	ulong flash_start;
+
+	kernel_addr = getenv("f_kernel_addr");
+	end_addr = simple_strtoul(kernel_addr,NULL,16) - 1;
+	start_addr = end_addr - CFG_ENV_SIZE - sizeof(UBOOTCONFIG_COPY_HEADER) + 1;
+
+	rootfs_addr = getenv("f_rootfs_addr");
+	rootfs_size = getenv("f_rootfs_size");
+	rootfs_end_addr = simple_strtoul(rootfs_addr,NULL,16) + simple_strtoul(rootfs_size,NULL,16);
+
+	if(rootfs_end_addr >= start_addr)
+	{
+		printf("Can not copy the environment at 0x%08lx as no space left.\nf_kernel_addr = 0x%08lx while rootfs_end_addr = 0x%08lx\n",start_addr,end_addr,rootfs_end_addr);
+		return 1;
+	}
+
+	debug ("Protect off %08lX ... %08lX\n", (ulong)rootfs_end_addr, end_addr);
+	if (flash_sect_protect (0, rootfs_end_addr, end_addr))
+		return 1;
+
+	//delete the old environment copy, if found
+	flash_start = rootfs_end_addr;
+	while(flash_start + sizeof(UBOOTCONFIG_COPY_HEADER) + ENV_SIZE < end_addr)
+	{
+		if(strncmp((char *)flash_start,UBOOTCONFIG_COPY_HEADER,sizeof(UBOOTCONFIG_COPY_HEADER)) == 0)
+		{
+			flash_sect_erase(flash_start,flash_start + sizeof(UBOOTCONFIG_COPY_HEADER),1);
+		}
+		flash_start += 1;
+	}
+	flash_sect_erase(start_addr,end_addr,1);
+	flash_write(UBOOTCONFIG_COPY_HEADER,start_addr,sizeof(UBOOTCONFIG_COPY_HEADER));
+	flash_write(env_buffer,start_addr + sizeof(UBOOTCONFIG_COPY_HEADER), CFG_ENV_SIZE);
+	flash_sect_protect (1, rootfs_end_addr, end_addr);
+	printf("saved copy of the env at 0x%08lx\n",start_addr);
+	return 0;
+}
+#endif	//UBOOT_ENV_COPY
+
 int saveenv(void)
 {
+#define debug printf
 	int	len, rc;
 	ulong	end_addr;
 	ulong	flash_sect_addr;
@@ -331,7 +378,7 @@
 		return 1;
 
 	puts ("Erasing Flash...");
-	if (flash_sect_erase (flash_sect_addr, end_addr))
+	if (flash_sect_erase (flash_sect_addr, end_addr, 1))
 		return 1;
 
 	puts ("Writing to Flash... ");
--- /dev/null
+++ b/common/upgrade.c
@@ -0,0 +1,273 @@
+#include "common.h"
+#include "command.h"
+#include "cmd_upgrade.h"
+#include "flash.h"
+
+#if defined(BUILD_FROM_IFX_UTILITIES)
+#include "crc32.h"
+#define getenv(x)					get_env(x)
+#define simple_strtoul(a,b,c)				strtoul(a,b,c)
+#define setenv(x,y)					set_env(x,y)
+#define uchar						unsigned char
+#define ulong						unsigned long
+#define uint32_t					unsigned int
+#define uint8_t						unsigned char
+#endif
+
+#include "image.h"
+
+#ifdef BUILD_FROM_IFX_UTILITIES
+	#define upgrade_debug_printf(...)	printf
+#else
+	#define upgrade_debug_printf		debug
+#endif
+
+int program_img(ulong srcAddr,int srcLen,ulong destAddr)
+{
+	upgrade_debug_printf("program_img : the srcAddr is 0x%08lx, length is %d while destAddr is 0x%08lx\n",srcAddr,srcLen,destAddr);
+	flash_sect_protect(0,destAddr,destAddr + srcLen-1);
+	upgrade_debug_printf("Erase Flash from 0x%08lx to 0x%08lx\n", destAddr, destAddr + srcLen-1);
+	if(flash_sect_erase(destAddr,destAddr + srcLen-1,1)) {
+		return 1;
+	}
+	puts ("Writing to Flash... ");
+	if(flash_write(srcAddr,destAddr,srcLen)) {
+		return 1;
+	}
+	upgrade_debug_printf("Image at 0x%08lx with size %d is programmed at 0x%08lx successfully\n",srcAddr,srcLen,destAddr);
+	printf ("Saving Environment ...\n");
+	flash_sect_protect(1,destAddr,destAddr + srcLen-1);
+	return 0;
+}
+
+int FindPartBoundary(ulong img_addr,ulong *curpart_begin,ulong *nextpart_begin)
+{
+	char strPartName[16];
+	ulong part_begin_addr[MAX_PARTITION];
+	int nPartNo,i;
+
+	nPartNo = simple_strtoul((char *)getenv("total_part"),NULL,10);
+	if(nPartNo <= 0 || nPartNo >= MAX_PARTITION){
+		printf("Total no. of current partitions [%d] is out of limit (0,%d)\n",MAX_PARTITION);
+		return 1;
+	}
+
+	for(i = 0; i < nPartNo; i++){
+		memset(strPartName,0x00,sizeof(strPartName));
+		sprintf(strPartName,"part%d_begin",i);
+		part_begin_addr[i] = simple_strtoul((char *)getenv(strPartName),NULL,16);
+	}
+
+	part_begin_addr[i] = simple_strtoul((char *)getenv("flash_end"),NULL,16) + 1;
+
+	for(i = 0; i < nPartNo; i++){
+		if(img_addr >= part_begin_addr[i] && img_addr < part_begin_addr[i+1]){
+			*curpart_begin = part_begin_addr[i];
+			*nextpart_begin = part_begin_addr[i+1];
+			return 0;
+		}
+	}
+
+	printf("The begining of the image to be programmed [0x%08lx] is not within current patition boundary\n",img_addr);
+	return 1;
+}
+
+int FindNPImgLoc(ulong img_addr,ulong *nextStartAddr,ulong *preEndAddr)
+{
+	ulong Img_startAddr[MAX_DATABLOCK];
+	ulong Img_size[MAX_DATABLOCK];
+	ulong nDBNo;
+	char strDBName[MAX_DATABLOCK][32];
+	char strTemp[32];
+	char *strT;
+	ulong curpart_begin,nextpart_begin;
+	int i;
+
+	nDBNo = simple_strtoul((char *)getenv("total_db"),NULL,10);
+	if(nDBNo <= 0 || nDBNo >= MAX_DATABLOCK){
+		printf("Total no. of current data blocks [%d] is out of limit (0,%d)\n",nDBNo,MAX_PARTITION);
+		return 1;
+	}
+
+	if(FindPartBoundary(img_addr,&curpart_begin,&nextpart_begin))
+		return 1;
+
+	upgrade_debug_printf("For the image address 0x%08lx, partition boundary is found as [0x%08lx,0x%08lx]\n",img_addr,curpart_begin,nextpart_begin);
+	*nextStartAddr = nextpart_begin;
+	*preEndAddr = curpart_begin;
+
+	for(i = 0; i < nDBNo; i++){
+		memset(strDBName[i],0x00,sizeof(strDBName[i]));
+		memset(strTemp,0x00,sizeof(strTemp));
+		sprintf(strTemp,"data_block%d",i);
+		strcpy(strDBName[i],(char *)getenv(strTemp));
+		if(strcmp(strDBName[i],"") == 0){
+			printf("Variable %s is not set\n",strTemp);
+			return 1;
+		}
+	}
+
+	for(i = 0; i < nDBNo; i++){
+		memset(strTemp,0x00,sizeof(strTemp));
+		strT = NULL;
+		sprintf(strTemp,"f_%s_addr",strDBName[i]);
+		strT = (char *)getenv(strTemp);
+		if(strT == NULL){
+			printf("Variable %s is not set\n",strTemp);
+			return 1;
+		}
+		Img_startAddr[i] = simple_strtoul((char *)strT,NULL,16);
+
+		memset(strTemp,0x00,sizeof(strTemp));
+		strT = NULL;
+		sprintf(strTemp,"f_%s_size",strDBName[i]);
+		strT = (char *)getenv(strTemp);
+		if(strT == NULL){
+			printf("Variable %s is not set\n",strTemp);
+			return 1;
+		}
+		Img_size[i] = simple_strtoul((char *)strT,NULL,16);
+	}
+
+	for(i = 0; i < nDBNo; i++){
+		if(Img_startAddr[i] > img_addr && Img_startAddr[i] < *nextStartAddr)
+			*nextStartAddr = Img_startAddr[i];
+		if(Img_startAddr[i] + Img_size[i] < img_addr && Img_startAddr[i] + Img_size[i] > *preEndAddr)
+			*preEndAddr = Img_startAddr[i] + Img_size[i];
+	}
+	printf("For img_addr 0x%08lx, nextStartAddr 0x%08lx and preEndAddr 0x%08lx\n",img_addr,*nextStartAddr,*preEndAddr);
+	return 0;
+}
+
+int upgrade_img(ulong srcAddr, ulong srcLen, char *imgName, enum ExpandDir dir, int bSaveEnv)
+{
+	ulong img_addr,img_size,img_endaddr;
+	char newimg_para[32];
+	char strimg_addr[32],strimg_size[32];
+	ulong nextStartAddr,preEndAddr;
+	image_header_t *pimg_header = NULL;
+	char *srcData_Copy=NULL;
+
+	memset(strimg_addr,0x00,sizeof(strimg_addr));
+	sprintf(strimg_addr,"f_%s_addr",imgName);
+	sprintf(strimg_size,"f_%s_size",imgName);
+	img_addr = simple_strtoul((char *)getenv(strimg_addr),NULL,16);
+	if (img_addr == 0) {
+		printf("The environment variable %s not found\n",strimg_addr);
+		return 1;
+	}
+
+	if (FindNPImgLoc(img_addr,&nextStartAddr,&preEndAddr))
+		return 1;
+	pimg_header = (image_header_t *)srcAddr;
+	if (pimg_header->ih_magic == IH_MAGIC) {
+		printf("Image contains header with name [%s]\n",pimg_header->ih_name);
+		if(pimg_header->ih_type != IH_TYPE_KERNEL) {
+			printf("This is not kernel image and so removing header\n");
+			srcAddr += sizeof(*pimg_header);
+			srcLen -= sizeof(*pimg_header);
+		}
+		img_size = simple_strtoul((char *)getenv(strimg_size),NULL,16); //509061:tc.chen
+	} else if (!strcmp(imgName,"uboot")) {
+		img_size = simple_strtoul((char *)getenv(strimg_size),NULL,16); //509061:tc.chen
+	} else {
+		struct conf_header *header;
+#if !defined(BUILD_FROM_IFX_UTILITIES)
+		srcData_Copy = srcAddr;
+		memmove(srcData_Copy + sizeof(struct conf_header) ,(void *)srcAddr,srcLen);
+#else
+		srcData_Copy = malloc(srcLen + sizeof(struct conf_header));
+		memcpy(srcData_Copy+sizeof(struct conf_header),srcAddr,srcLen);
+#endif
+		header = (struct conf_header *)srcData_Copy;
+		header->size = srcLen;
+#if defined(BUILD_FROM_IFX_UTILITIES)
+		header->crc = 0 ^ 0xffffffffL;
+#else
+		header->crc = 0;
+#endif
+		header->crc = crc32(header->crc,srcData_Copy+sizeof(struct conf_header),srcLen);
+#if defined(BUILD_FROM_IFX_UTILITIES)
+		header->crc ^= 0xffffffffL;
+#endif
+	}
+
+	if (dir == FORWARD) {
+		if (img_addr + srcLen > nextStartAddr) {
+			printf("Cannot upgrade image %s.\n Error : From start address 0x%08lx, the new size %d is bigger than begining of next image/end of the partition 0x%08lx\n",strimg_addr,img_addr,srcLen,nextStartAddr);
+			return 1;
+		}
+		upgrade_debug_printf("Programming for FORWARD direction\n");
+	} else if (dir == BACKWARD) {
+		img_endaddr = nextStartAddr - 1;
+		if(img_endaddr - srcLen < preEndAddr) {
+			printf("Cannot upgrade image %s.\n Error : From end address 0x%08lx, the new size %d is bigger than end of previous image/begining of the partition 0x%08lx\n",strimg_addr,img_endaddr,srcLen,preEndAddr);
+			return 1;
+		}
+
+		img_addr = img_endaddr - srcLen + 1;
+		img_addr = (img_addr/16)*16;
+
+		upgrade_debug_printf("Programming for BACKWARD direction\n");
+	} else {
+		printf("The expansion direction [%d] is invalid\n",dir);
+		return 1;
+	}
+	if (srcData_Copy) {
+		if (program_img(srcData_Copy,srcLen+sizeof(struct conf_header),img_addr)) {
+#if defined(BUILD_FROM_IFX_UTILITIES)
+			free(srcData_Copy);
+#endif
+			return 1;
+		}
+	} else {
+		if (program_img(srcAddr,srcLen,img_addr)) {
+			return 1;
+		}
+	}
+
+#if !defined(BUILD_FROM_IFX_UTILITIES)
+	if (strcmp(strimg_addr,"f_uboot_addr") == 0) {
+		ulong erase_addr1=0, erase_addr2=0;
+		erase_addr1 = simple_strtoul((char *)getenv("f_firmware_addr"),NULL,16);
+		erase_addr2 = simple_strtoul((char *)getenv("flash_end"),NULL,16);
+		flash_sect_erase(erase_addr1, erase_addr2, 1);
+		do_reset (NULL, 0, 0, NULL);
+		return 0;
+	}
+#endif
+	memset(newimg_para,0x00,sizeof(newimg_para));
+	sprintf(newimg_para,"0x%08lx",srcLen);
+	setenv(strimg_size,newimg_para);
+	upgrade_debug_printf("New variables %s = %s set\n",strimg_size,newimg_para);
+
+	memset(newimg_para,0x00,sizeof(newimg_para));
+	sprintf(newimg_para,"0x%08lx",img_addr);
+	setenv(strimg_addr,newimg_para);
+	upgrade_debug_printf("New variables %s = %s set\n",strimg_addr,newimg_para);
+
+	if (strcmp(strimg_addr,"f_kernel_addr") == 0) {
+		setenv("kernel_addr",newimg_para);
+		upgrade_debug_printf("New variables kernel_addr = %s set\n",newimg_para);
+	}
+
+	if (strcmp(strimg_addr,"f_rootfs_addr") == 0) {
+		memset(newimg_para,0x00,sizeof(newimg_para));
+		sprintf(newimg_para,"0x%08lx",img_addr + srcLen);
+		setenv("f_rootfs_end",newimg_para);
+		upgrade_debug_printf("New variables kernel_addr = %s set\n",newimg_para);
+	}
+
+	if (bSaveEnv) {
+		saveenv();
+#ifdef UBOOT_ENV_COPY
+		saveenv_copy();
+#endif //UBOOT_ENV_COPY
+	}
+#if defined(BUILD_FROM_IFX_UTILITIES)
+	if (srcData_Copy)
+		free(srcData_Copy);
+#endif
+	return 0;
+}
+
--- a/config.mk
+++ b/config.mk
@@ -139,12 +139,15 @@
 LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
 endif
 endif
+
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARDDIR)/u-boot-bootstrap.lds
+
 OBJCFLAGS += --gap-fill=0xff
 
 gccincdir := $(shell $(CC) -print-file-name=include)
 
 CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
-	-D__KERNEL__ -DTEXT_BASE=$(TEXT_BASE)		\
+	-D__KERNEL__ -DUBOOT_RAM_TEXT_BASE=$(UBOOT_RAM_TEXT_BASE)		\
 
 ifneq ($(OBJTREE),$(SRCTREE))
 CPPFLAGS += -I$(OBJTREE)/include2 -I$(OBJTREE)/include
@@ -180,7 +183,10 @@
 
 AFLAGS := $(AFLAGS_DEBUG) -D__ASSEMBLY__ $(CPPFLAGS)
 
-LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
+LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(UBOOT_RAM_TEXT_BASE) $(PLATFORM_LDFLAGS)
+LDFLAGS_BOOTSTRAP += -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(BOOTSTRAP_TEXT_BASE) $(PLATFORM_LDFLAGS)
+
+#HEAD_LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(HEAD_FLASH_TEXT_BASE) $(PLATFORM_LDFLAGS)
 
 # Location of a usable BFD library, where we define "usable" as
 # "built for ${HOST}, supports ${TARGET}".  Sensible values are
@@ -211,15 +217,29 @@
 
 #########################################################################
 
+AFLAGS := $(AFLAGS) $(IFX_CFLAGS)
+CFLAGS := $(CFLAGS) $(IFX_CFLAGS)
+CPPFLAGS := $(CPPFLAGS) $(IFX_CFLAGS)
+
+#########################################################################
+
 export	CONFIG_SHELL HPATH HOSTCC HOSTCFLAGS CROSS_COMPILE \
 	AS LD CC CPP AR NM STRIP OBJCOPY OBJDUMP \
 	MAKE
-export	TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
+#export	UBOOT_RAM_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
+export	UBOOT_RAM_TEXT_BASE BOOTSTRAP_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
 
 #########################################################################
 
 ifndef REMOTE_BUILD
 
+%_bootstrap.s:	%_bootstrap.S
+	$(CPP) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -o $@ $<
+%_bootstrap.o:	%_bootstrap.S
+	$(CC) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+%_bootstrap.o:	%_bootstrap.c
+	$(CC) $(CFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+
 %.s:	%.S
 	$(CPP) $(AFLAGS) -o $@ $<
 %.o:	%.S
@@ -229,12 +249,20 @@
 
 else
 
+$(obj)%_bootstrap.s:	%_bootstrap.S
+	$(CPP) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -o $@ $<
+$(obj)%_bootstrap.o:	%_bootstrap.S
+	$(CC) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+$(obj)%_bootstrap.o:	%_bootstrap.c
+	$(CC) $(CFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+
 $(obj)%.s:	%.S
 	$(CPP) $(AFLAGS) -o $@ $<
 $(obj)%.o:	%.S
 	$(CC) $(AFLAGS) -c -o $@ $<
 $(obj)%.o:	%.c
 	$(CC) $(CFLAGS) -c -o $@ $<
+
 endif
 
 #########################################################################
--- a/cpu/mips/Makefile
+++ b/cpu/mips/Makefile
@@ -27,7 +27,7 @@
 
 START	= start.o
 COBJS	= asc_serial.o au1x00_serial.o au1x00_eth.o au1x00_usb_ohci.o \
-	  cpu.o interrupts.o incaip_clock.o
+	  cpu.o interrupts.o incaip_clock.o ifx_asc.o ifx_clock.o
 SOBJS	= incaip_wdt.o cache.o
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
--- /dev/null
+++ b/cpu/mips/boot.c
@@ -0,0 +1,88 @@
+/*****************************************************************************
+ * DANUBE
+ * Copyright (c) 2005, Infineon Technologies AG, All rights reserved
+ * IFAP DC COM SD
+ *****************************************************************************/
+
+#include <common.h>
+#include "asm/ifx_asc.h"
+#include "boot.h"
+#include "asm/ifx_mips.h"
+
+#define FLAG_DEC	0x00020000
+#define FLAG_SDBG	0x00080000
+
+boot_data bootrom =
+{
+  1,   /** CPU number */
+  0,   /** Boot configuration */
+  0,   /** CPU endianess */
+  0,   /** Debug mode */
+  0};   /** application vector */
+
+void _boot_rvec(void)
+{
+   if (*BOOT_RVEC(bootrom.cpu) == 0)
+   {
+      boot_error(BOOT_ERR_NO_RVEC);
+   }
+   else
+   {
+      void (*decrypt) (u32 addr, int n) = 0xbf0014e8;
+      void (*start)(void) = (void *)*BOOT_RVEC(1);
+      boot_set_status(BOOT_STAT_START, BOOT_STAT_MASK_STAT);
+      if (*BOOT_CFG_STAT(bootrom.cpu) & FLAG_DEC)
+      {
+         u32 size = *BOOT_SIZE(bootrom.cpu);
+         u32 addr = *BOOT_RVEC(bootrom.cpu);
+         decrypt(addr, size);
+      }
+      start();
+   }
+}
+
+void boot_error(u32 berr)
+{
+   int i;
+   boot_set_status(BOOT_STAT_HALT, BOOT_STAT_MASK_STAT);
+   boot_sdbg("** HALT, ", berr);
+   while(1)
+   {
+      for (i = berr; i > 0; i--)
+      {
+         /* Toggle pin */
+      }
+      __asm__("nop;nop;nop;nop;nop;");
+   }
+}
+
+void boot_sdbg(u8* string, u32 value)
+{
+  if (*BOOT_CFG_STAT(bootrom.cpu) & FLAG_SDBG)
+  {
+    puts(string);
+    if (value)
+    {
+      printf("%d",value);
+    }
+    printf("\n\r");
+  }
+}
+
+void boot_set_status(u32 status, u32 mask)
+{
+  *BOOT_CFG_STAT(bootrom.cpu) = (*BOOT_CFG_STAT(bootrom.cpu) & ~mask) | (status & mask);
+}
+
+void boot_cp1(void)
+{
+  int ret = 10;
+
+  bootrom.cpu = 1;
+  while (*BOOT_RVEC(bootrom.cpu) == 0);
+  _boot_rvec();
+  /* never get here...*/
+  boot_error(ret);
+}
+
+
--- a/cpu/mips/cache.S
+++ b/cpu/mips/cache.S
@@ -29,7 +29,9 @@
 #include <asm/mipsregs.h>
 #include <asm/addrspace.h>
 #include <asm/cacheops.h>
-
+#if defined(CONFIG_IFX_MIPS)
+#	include "ifx_cache.S"
+#endif
 
 	/* 16KB is the maximum size of instruction and data caches on
 	 * MIPS 4K.
@@ -131,7 +133,6 @@
 	li	t4, CFG_CACHELINE_SIZE
 	move	t5, t4
 
-
 	li	v0, MIPS_MAX_CACHE_SIZE
 
 	/* Now clear that much memory starting from zero.
@@ -155,6 +156,9 @@
 	 */
 
 	mtc0	zero, CP0_TAGLO
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_EXTRA_INVALID_TAG)
+	IFX_CACHE_EXTRA_INVALID_TAG
+#endif
 
    /*
     * The caches are probably in an indeterminate state,
@@ -171,6 +175,9 @@
 	move	a1, a2
 	icacheopn(a0,a1,a2,a3,121,(Index_Store_Tag_I,Fill))
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_EXTRA_OPERATION)
+	IFX_CACHE_EXTRA_OPERATION
+#else
 	/* To support Orion/R4600, we initialise the data cache in 3 passes.
 	 */
 
@@ -200,6 +207,7 @@
 	move	a3, t5		# dcacheLineSize
 	move	a1, a2
 	icacheop(a0,a1,a2,a3,Index_Store_Tag_D)
+#endif
 
 	j  ra
 	.end  mips_cache_reset
@@ -258,8 +266,12 @@
 	.globl	mips_cache_lock
 	.ent	mips_cache_lock
 mips_cache_lock:
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_LOCK_RAM_AREA)
+	IFX_CACHE_LOCK_RAM_AREA
+#else
 	li	a1, K0BASE - CACHE_LOCK_SIZE
 	addu	a0, a1
+#endif
 	li	a2, CACHE_LOCK_SIZE
 	li	a3, CFG_CACHELINE_SIZE
 	move	a1, a2
@@ -267,3 +279,33 @@
 
 	j	ra
 	.end	mips_cache_lock
+
+/*******************************************************************************
+*
+* mips_cache_unlock - Unlock RAM area pointed to by a0 in cache.
+*
+* cacheop - cache op, offset(base)
+*	op is operation to perform on base+offset address.
+*	op(5) = Operation(3)#CacheType(2)
+*	Operation - Index Invalidate (000), Fetch & Lock (111)...
+*	CacheType - Instruction (00), Data (01) ...
+* RETURNS: N/A
+*
+*/
+
+	.globl	mips_cache_unlock
+	.ent	mips_cache_unlock
+mips_cache_unlock:
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_UNLOCK_RAM_AREA)
+	IFX_CACHE_UNLOCK_RAM_AREA
+#else
+	li      a0, LOCK_DCACHE_ADDR - CACHE_LOCK_SIZE
+#endif
+	li	a2, CACHE_LOCK_SIZE
+	li	a3, CFG_CACHELINE_SIZE
+	move	a1, a2
+	icacheop(a0,a1,a2,a3,0x01)
+
+	j	ra
+	.end	mips_cache_unlock
+
--- a/cpu/mips/config.mk
+++ b/cpu/mips/config.mk
@@ -22,18 +22,31 @@
 #
 v=$(shell \
 $(CROSS_COMPILE)as --version|grep "GNU assembler"|awk '{print $$3}'|awk -F . '{print $$2}')
+
+ifndef PLATFORM_CPU
+PLATFORM_CPU = 4kc
+endif
+
 MIPSFLAGS=$(shell \
 if [ "$v" -lt "14" ]; then \
-	echo "-mcpu=4kc"; \
+	echo "-mcpu=$(PLATFORM_CPU)"; \
 else \
-	echo "-march=4kc -mtune=4kc"; \
+	echo "-march=$(PLATFORM_CPU) -mtune=$(PLATFORM_CPU)"; \
 fi)
 
+ifeq ($(CROSS_COMPILE_UCLIBC),1)
+ifneq (,$(findstring mipsel,$(CROSS_COMIPLE)))
+ENDIANNESS = -el
+else
+ENDIANNESS = -eb
+endif
+else
 ifneq (,$(findstring 4KCle,$(CROSS_COMPILE)))
 ENDIANNESS = -EL
 else
 ENDIANNESS = -EB
 endif
+endif
 
 MIPSFLAGS += $(ENDIANNESS) -mabicalls
 
--- a/cpu/mips/cpu.c
+++ b/cpu/mips/cpu.c
@@ -23,7 +23,12 @@
 
 #include <common.h>
 #include <command.h>
-#include <asm/inca-ip.h>
+#if defined(CONFIG_INCA_IP)
+#	include <asm/inca-ip.h>
+#elif defined(CONFIG_IFX_MIPS)
+#	include <asm/ifx_mips.h>
+#	include "ifx_cpu.c"
+#endif
 #include <asm/mipsregs.h>
 
 int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -34,8 +39,10 @@
 	void (*f)(void) = (void *) 0xbfc00000;
 
 	f();
+#elif defined(CONFIG_IFX_MIPS)
+	IFX_CPU_RESET;
 #endif
-	fprintf(stderr, "*** reset failed ***\n");
+//	fprintf(stderr, "*** reset failed ***\n");
 	return 0;
 }
 
--- /dev/null
+++ b/cpu/mips/ifx_asc.c
@@ -0,0 +1,248 @@
+/*****************************************************************************
+ * AmazonSE BootROM
+ * Copyright (c) 2005, Infineon Technologies AG, All rights reserved
+ * IFAP DC COM SD
+ *****************************************************************************/
+
+#include <config.h>
+#include <asm/lib.h>
+#include <asm/ifx_mips.h>
+#include <asm/addrspace.h>
+#include "ifx_asc.h"
+
+#define ASC_FIFO_PRESENT
+#define SET_BIT(reg, mask)                  reg |= (mask)
+#define CLEAR_BIT(reg, mask)                reg &= (~mask)
+#define CLEAR_BITS(reg, mask)               CLEAR_BIT(reg, mask)
+#define SET_BITS(reg, mask)                 SET_BIT(reg, mask)
+#define SET_BITFIELD(reg, mask, off, val)   {reg &= (~mask); reg |= (val << off);}
+
+void asc_setbrg (void);
+
+/*TODO: undefine this !!!*/
+#undef DEBUG_ASC_RAW
+#ifdef DEBUG_ASC_RAW
+#define DEBUG_ASC_RAW_RX_BUF		0xA0800000
+#define DEBUG_ASC_RAW_TX_BUF		0xA0900000
+#endif
+
+static volatile DanubeAsc_t *pAsc = (DanubeAsc_t *)AMAZON_SE_ASC1;
+
+typedef struct{
+  u16 fdv; /* 0~511 fractional divider value*/
+  u16 reload; /* 13 bit reload value*/
+} ifx_asc_baud_reg_t;
+
+#ifdef ON_VENUS
+/*9600 @1.25M rel 00.08*/
+//#define FDV 503
+//#define RELOAD 7
+/*9600 @0.625M rel final00.01 & rtl_freeze*/
+#define FDV 503
+#define RELOAD 3
+/* first index is DDR_SEL, second index is FPI_SEL */
+#endif
+
+#if 0 // Danube only
+static ifx_asc_baud_reg_t g_danube_asc_baud[4][2] =
+{
+#ifdef ON_VENUS
+     {{503,3},{503,3}},   /* 1152000 @ 166.67M and half*/
+      {{503,3},{503,3}},   /* 1152000 @ 133.3M  and half*/
+      {{503,3},{503,3}},   /* 1152000 @ 111.11M and half*/
+      {{503.3},{503,3}}    /* 1152000 @ 83.33M  and half*/
+#else
+/*  TAPEOUT table */
+     {{436,76},{419,36}},   /* 1152000 @ 166.67M and half*/
+      {{453,63},{453,31}},   /* 1152000 @ 133.3M  and half*/
+      {{501,58},{510,29}},   /* 1152000 @ 111.11M and half*/
+      {{419.36},{453,19}}    /* 1152000 @ 83.33M  and half*/
+#endif
+};
+#endif // Danube only
+
+/******************************************************************************
+*
+* asc_init - initialize a Danube ASC channel
+*
+* This routine initializes the number of data bits, parity
+* and set the selected baud rate. Interrupts are disabled.
+* Set the modem control signals if the option is selected.
+*
+* RETURNS: N/A
+*/
+
+void serial_setbrg (void)
+{
+	u32 uiReloadValue, fdv;
+
+#if defined(ON_IKOS)
+	/*1200 @77K */
+	//fdv=472;
+	//uiReloadValue=5;
+
+	/* 2400bps @76800Hz */
+	fdv=433;
+	uiReloadValue=1;
+#else
+	/*venus & tapeout */
+
+        /* 115200 @133MHz */
+	fdv=453;
+	uiReloadValue=63;
+
+#endif	//ON_IKOS
+
+	/* Disable Baud Rate Generator; BG should only be written when R=0 */
+	CLEAR_BIT(pAsc->asc_con, ASCCON_R);
+
+	/* Enable Fractional Divider */
+	SET_BIT(pAsc->asc_con, ASCCON_FDE); /* FDE = 1 */
+
+	/* Set fractional divider value */
+	pAsc->asc_fdv = fdv & ASCFDV_VALUE_MASK;
+
+	/* Set reload value in BG */
+	pAsc->asc_bg = uiReloadValue;
+
+	/* Enable Baud Rate Generator */
+	SET_BIT(pAsc->asc_con, ASCCON_R);           /* R = 1 */
+}
+
+
+int serial_init (void)
+{
+	/* and we have to set CLC register*/
+	CLEAR_BIT(pAsc->asc_clc, ASCCLC_DISS);
+	SET_BITFIELD(pAsc->asc_clc, ASCCLC_RMCMASK, ASCCLC_RMCOFFSET, 0x0001);
+
+	/* initialy we are in async mode */
+	pAsc->asc_con = ASCCON_M_8ASYNC;
+
+	/* select input port */
+	pAsc->asc_pisel = (CONSOLE_TTY & 0x1);
+
+	/* TXFIFO's filling level */
+	SET_BITFIELD(pAsc->asc_txfcon, ASCTXFCON_TXFITLMASK,
+			ASCTXFCON_TXFITLOFF, DANUBEASC_TXFIFO_FL);
+	/* enable TXFIFO */
+	SET_BIT(pAsc->asc_txfcon, ASCTXFCON_TXFEN);
+
+	/* RXFIFO's filling level */
+	SET_BITFIELD(pAsc->asc_rxfcon, ASCRXFCON_RXFITLMASK,
+			ASCRXFCON_RXFITLOFF, DANUBEASC_RXFIFO_FL);
+	/* enable RXFIFO */
+	SET_BIT(pAsc->asc_rxfcon, ASCRXFCON_RXFEN);
+
+	/* set baud rate */
+	serial_setbrg();
+
+	/* enable error signals &  Receiver enable  */
+	SET_BIT(pAsc->asc_whbstate, ASCWHBSTATE_SETREN);
+
+	return 0;
+}
+
+
+void serial_putc (const char c)
+{
+	u32 txFl = 0;
+#ifdef DEBUG_ASC_RAW
+	static u8 * debug = (u8 *) DEBUG_ASC_RAW_TX_BUF;
+	*debug++=c;
+#endif
+	if (c == '\n')
+		serial_putc ('\r');
+	/* check do we have a free space in the TX FIFO */
+	/* get current filling level */
+	do
+	{
+		txFl = ( pAsc->asc_fstat & ASCFSTAT_TXFFLMASK ) >> ASCFSTAT_TXFFLOFF;
+	}
+	while ( txFl == DANUBEASC_TXFIFO_FULL );
+
+	pAsc->asc_tbuf = c; /* write char to Transmit Buffer Register */
+
+	/* check for errors */
+	if ( pAsc->asc_state & ASCSTATE_TOE )
+	{
+		SET_BIT(pAsc->asc_whbstate, ASCWHBSTATE_CLRTOE);
+		return;
+	}
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	char c;
+	while ((pAsc->asc_fstat & ASCFSTAT_RXFFLMASK) == 0 );
+	c = (char)(pAsc->asc_rbuf & 0xff);
+
+#ifdef 	DEBUG_ASC_RAW
+	static u8* debug=(u8*)(DEBUG_ASC_RAW_RX_BUF);
+	*debug++=c;
+#endif
+	return c;
+}
+
+void asc_clear_input(void)
+{
+	volatile char c;
+	volatile u32 cnt = 0xFFFF;
+
+    while (cnt)
+    {
+        cnt = 0xFFFF;
+
+	while ((pAsc->asc_fstat & ASCFSTAT_RXFFLMASK) == 0 )
+	{
+	    cnt--;
+	    if (cnt == 0)
+	    {
+	        break;
+	    }
+	}
+
+        if (cnt)
+ 	    c = (char)(pAsc->asc_rbuf & 0xff);
+    }
+}
+
+int serial_tstc (void)
+{
+         int res = 1;
+#ifdef ASC_FIFO_PRESENT
+    if ( (pAsc->asc_fstat & ASCFSTAT_RXFFLMASK) == 0 )
+    {
+        res = 0;
+    }
+#else
+    if (!(*(volatile unsigned long*)(SFPI_INTCON_BASEADDR + FBS_ISR) &
+			    					FBS_ISR_AR))
+
+    {
+        res = 0;
+    }
+#endif
+	 return res;
+}
+
+int serial_start(void)
+{
+   return 1;
+}
+
+int serial_stop(void)
+{
+   return 1;
+}
+
+
+
--- /dev/null
+++ b/cpu/mips/ifx_asc.h
@@ -0,0 +1,221 @@
+/*****************************************************************************
+ * DANUBE BootROM
+ * Copyright (c) 2005, Infineon Technologies AG, All rights reserved
+ * IFAP DC COM SD
+ *****************************************************************************/
+#ifndef __ASC_H
+#define __ASC_H
+
+#define DANUBEASC_TXFIFO_FL       		1
+#define DANUBEASC_RXFIFO_FL       		1
+#define DANUBEASC_TXFIFO_FULL     		16
+
+/* channel operating modes */
+#define	ASCOPT_CSIZE	0x00000003
+#define	ASCOPT_CS7	0x00000001
+#define	ASCOPT_CS8	0x00000002
+#define	ASCOPT_PARENB	0x00000004
+#define	ASCOPT_STOPB	0x00000008
+#define	ASCOPT_PARODD	0x00000010
+#define	ASCOPT_CREAD	0x00000020
+
+#define ASC_OPTIONS		(ASCOPT_CREAD | ASCOPT_CS8)
+
+/* ASC input select (0 or 1) */
+#define CONSOLE_TTY	0
+
+#define DANUBEASC_TXFIFO_FL       1
+#define DANUBEASC_RXFIFO_FL       1
+#define DANUBEASC_TXFIFO_FULL     16
+
+/* interrupt lines masks for the ASC device interrupts*/
+/* change these macroses if it's necessary */
+#define DANUBEASC_IRQ_LINE_ALL        0x0000007f  /* all IRQs */
+
+#define DANUBEASC_IRQ_LINE_TIR            0x00000001      /* Tx Int */
+#define DANUBEASC_IRQ_LINE_TBIR           0x00000002      /* Tx Buffer Int */
+#define DANUBEASC_IRQ_LINE_RIR            0x00000004      /* Rx Int */
+#define DANUBEASC_IRQ_LINE_EIR            0x00000008      /* Error Int */
+#define DANUBEASC_IRQ_LINE_ABSTIR         0x00000010      /* Autobaud Start Int */
+#define DANUBEASC_IRQ_LINE_ABDETIP        0x00000020      /* Autobaud Detection Int */
+#define DANUBEASC_IRQ_LINE_SFCIR          0x00000040      /* Software Flow Control Int */
+
+/* interrupt controller access macros */
+#define ASC_INTERRUPTS_ENABLE(X)  \
+*((volatile unsigned int*) DANUBE_ICU_IM0_IER) |= X;
+#define ASC_INTERRUPTS_DISABLE(X) \
+*((volatile unsigned int*) DANUBE_ICU_IM0_IER) &= ~X;
+#define ASC_INTERRUPTS_CLEAR(X)   \
+*((volatile unsigned int*) DANUBE_ICU_IM0_ISR) = X;
+
+/* CLC register's bits and bitfields */
+#define ASCCLC_DISR        0x00000001
+#define ASCCLC_DISS        0x00000002
+#define ASCCLC_RMCMASK     0x0000FF00
+#define ASCCLC_RMCOFFSET   8
+
+/* CON register's bits and bitfields */
+#define ASCCON_MODEMASK	0x0000000f
+#define ASCCON_M_8ASYNC	0x0
+#define ASCCON_M_8IRDA 	0x1
+#define ASCCON_M_7ASYNC	0x2
+#define ASCCON_M_7IRDA 	0x3
+#define ASCCON_WLSMASK 	0x0000000c
+#define ASCCON_WLSOFFSET	2
+#define ASCCON_WLS_8BIT	0x0
+#define ASCCON_WLS_7BIT	0x1
+#define ASCCON_PEN     	0x00000010
+#define ASCCON_ODD     	0x00000020
+#define ASCCON_SP      	0x00000040
+#define ASCCON_STP     	0x00000080
+#define ASCCON_BRS     	0x00000100
+#define ASCCON_FDE     	0x00000200
+#define ASCCON_ERRCLK  	0x00000400
+#define ASCCON_EMMASK  	0x00001800
+#define ASCCON_EMOFFSET	11
+#define ASCCON_EM_ECHO_OFF	0x0
+#define ASCCON_EM_ECHO_AB	0x1
+#define ASCCON_EM_ECHO_ON	0x2
+#define ASCCON_LB       	0x00002000
+#define ASCCON_ACO      	0x00004000
+#define ASCCON_R        	0x00008000
+#define ASCCON_PAL      	0x00010000
+#define ASCCON_FEN      	0x00020000
+#define ASCCON_RUEN     	0x00040000
+#define ASCCON_ROEN     	0x00080000
+#define ASCCON_TOEN     	0x00100000
+#define ASCCON_BEN      	0x00200000
+#define ASCCON_TXINV    	0x01000000
+#define ASCCON_RXINV    	0x02000000
+#define ASCCON_TXMSB    	0x04000000
+#define ASCCON_RXMSB    	0x08000000
+
+/* STATE register's bits and bitfields */
+#define ASCSTATE_REN     	0x00000001
+#define ASCSTATE_PE      	0x00010000
+#define ASCSTATE_FE      	0x00020000
+#define ASCSTATE_RUE     	0x00040000
+#define ASCSTATE_ROE     	0x00080000
+#define ASCSTATE_TOE     	0x00100000
+#define ASCSTATE_BE      	0x00200000
+#define ASCSTATE_TXBVMASK	0x07000000
+#define ASCSTATE_TXBVOFFSET	24
+#define ASCSTATE_TXEOM     	0x08000000
+#define ASCSTATE_RXBVMASK	0x70000000
+#define ASCSTATE_RXBVOFFSET	28
+#define ASCSTATE_RXEOM     	0x80000000
+
+/* WHBSTATE register's bits and bitfields */
+#define ASCWHBSTATE_CLRREN    0x00000001
+#define ASCWHBSTATE_SETREN    0x00000002
+#define ASCWHBSTATE_CLRPE     0x00000004
+#define ASCWHBSTATE_CLRFE     0x00000008
+#define ASCWHBSTATE_CLRRUE    0x00000010
+#define ASCWHBSTATE_CLRROE    0x00000020
+#define ASCWHBSTATE_CLRTOE    0x00000040
+#define ASCWHBSTATE_CLRBE     0x00000080
+#define ASCWHBSTATE_SETPE     0x00000100
+#define ASCWHBSTATE_SETFE     0x00000200
+#define ASCWHBSTATE_SETRUE    0x00000400
+#define ASCWHBSTATE_SETROE    0x00000800
+#define ASCWHBSTATE_SETTOE    0x00001000
+#define ASCWHBSTATE_SETBE     0x00002000
+
+/* ABCON register's bits and bitfields */
+#define ASCABCON_ABEN       0x0001
+#define ASCABCON_AUREN      0x0002
+#define ASCABCON_ABSTEN     0x0004
+#define ASCABCON_ABDETEN    0x0008
+#define ASCABCON_FCDETEN    0x0010
+
+/* FDV register mask, offset and bitfields*/
+#define ASCFDV_VALUE_MASK     0x000001FF
+
+/* WHBABCON register's bits and bitfields */
+#define ASCWHBABCON_CLRABEN     0x0001
+#define ASCWHBABCON_SETABEN     0x0002
+
+/* ABSTAT register's bits and bitfields */
+#define ASCABSTAT_FCSDET    0x0001
+#define ASCABSTAT_FCCDET    0x0002
+#define ASCABSTAT_SCSDET    0x0004
+#define ASCABSTAT_SCCDET    0x0008
+#define ASCABSTAT_DETWAIT   0x0010
+
+/* WHBABSTAT register's bits and bitfields */
+#define ASCWHBABSTAT_CLRFCSDET  0x0001
+#define ASCWHBABSTAT_SETFCSDET  0x0002
+#define ASCWHBABSTAT_CLRFCCDET  0x0004
+#define ASCWHBABSTAT_SETFCCDET  0x0008
+#define ASCWHBABSTAT_CLRSCSDET  0x0010
+#define ASCWHBABSTAT_SETSCSDET  0x0020
+#define ASCWHBABSTAT_CLRSCCDET  0x0040
+#define ASCWHBABSTAT_SETSCCDET  0x0080
+#define ASCWHBABSTAT_CLRDETWAIT 0x0100
+#define ASCWHBABSTAT_SETDETWAIT 0x0200
+
+/* TXFCON register's bits and bitfields */
+#define ASCTXFCON_TXFIFO1       0x00000400
+#define ASCTXFCON_TXFEN         0x0001
+#define ASCTXFCON_TXFFLU        0x0002
+#define ASCTXFCON_TXFITLMASK    0x3F00
+#define ASCTXFCON_TXFITLOFF     8
+
+/* RXFCON register's bits and bitfields */
+#define ASCRXFCON_RXFIFO1       0x00000400
+#define ASCRXFCON_RXFEN         0x0001
+#define ASCRXFCON_RXFFLU        0x0002
+#define ASCRXFCON_RXFITLMASK    0x3F00
+#define ASCRXFCON_RXFITLOFF     8
+
+/* FSTAT register's bits and bitfields */
+#define ASCFSTAT_RXFFLMASK      0x003F
+#define ASCFSTAT_TXFFLMASK      0x3F00
+#define ASCFSTAT_TXFFLOFF       8
+
+typedef  struct         /* DanubeAsc_t */
+{
+	volatile unsigned long  asc_clc;                            /*0x0000*/
+	volatile unsigned long  asc_pisel;                          /*0x0004*/
+	volatile unsigned long  asc_id;                             /*0x0008*/
+	volatile unsigned long  asc_rsvd1[1];   /* for mapping */   /*0x000C*/
+	volatile unsigned long  asc_con;                           /*0x0010*/
+	volatile unsigned long  asc_state;                          /*0x0014*/
+	volatile unsigned long  asc_whbstate;                       /*0x0018*/
+	volatile unsigned long  asc_rsvd2[1];   /* for mapping */   /*0x001C*/
+	volatile unsigned long  asc_tbuf;                           /*0x0020*/
+	volatile unsigned long  asc_rbuf;                           /*0x0024*/
+	volatile unsigned long  asc_rsvd3[2];   /* for mapping */   /*0x0028*/
+	volatile unsigned long  asc_abcon;                          /*0x0030*/
+	volatile unsigned long  asc_abstat;     /* not used */      /*0x0034*/
+	volatile unsigned long  asc_whbabcon;                       /*0x0038*/
+	volatile unsigned long  asc_whbabstat;  /* not used */      /*0x003C*/
+	volatile unsigned long  asc_rxfcon;                         /*0x0040*/
+	volatile unsigned long  asc_txfcon;                         /*0x0044*/
+	volatile unsigned long  asc_fstat;                          /*0x0048*/
+	volatile unsigned long  asc_rsvd4[1];   /* for mapping */   /*0x004C*/
+	volatile unsigned long  asc_bg;                             /*0x0050*/
+	volatile unsigned long  asc_bg_timer;                       /*0x0054*/
+	volatile unsigned long  asc_fdv;                            /*0x0058*/
+	volatile unsigned long  asc_pmw;                            /*0x005C*/
+	volatile unsigned long  asc_modcon;                         /*0x0060*/
+	volatile unsigned long  asc_modstat;                        /*0x0064*/
+	volatile unsigned long  asc_rsvd5[2];   /* for mapping */   /*0x0068*/
+	volatile unsigned long  asc_sfcc;                           /*0x0070*/
+	volatile unsigned long  asc_rsvd6[3];   /* for mapping */   /*0x0074*/
+	volatile unsigned long  asc_eomcon;                         /*0x0080*/
+	volatile unsigned long  asc_rsvd7[26];   /* for mapping */  /*0x0084*/
+	volatile unsigned long  asc_dmacon;                         /*0x00EC*/
+	volatile unsigned long  asc_rsvd8[1];   /* for mapping */   /*0x00F0*/
+	volatile unsigned long  asc_irnen;                          /*0x00F4*/
+	volatile unsigned long  asc_irnicr;                         /*0x00F8*/
+	volatile unsigned long  asc_irncr;                          /*0x00FC*/
+} DanubeAsc_t;
+
+int asc_init (void);
+void asc_puts (const char *s);
+void asc_putc (const char c);
+int asc_getc (void);
+void asc_clear_input(void);
+
+#endif /* __ASC_H */
--- /dev/null
+++ b/cpu/mips/ifx_cache.S
@@ -0,0 +1,67 @@
+
+#define IFX_CACHE_EXTRA_INVALID_TAG						\
+	mtc0	zero, CP0_TAGLO, 1;						\
+	mtc0	zero, CP0_TAGLO, 2;						\
+	mtc0	zero, CP0_TAGLO, 3;						\
+	mtc0	zero, CP0_TAGLO, 4;
+
+#define IFX_CACHE_EXTRA_OPERATION						\
+	/* set WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ECCF_WST;							\
+	or	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	li	a0, K0BASE;							\
+	move	a2, t2;		/* icacheSize */				\
+	move	a3, t4;		/* icacheLineSize */				\
+	move	a1, a2;								\
+	icacheop(a0,a1,a2,a3,(Index_Store_Tag_I));				\
+										\
+	/* clear WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ~ECCF_WST;							\
+	and	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	/* 1: initialise dcache tags. */					\
+										\
+	/* cache line size */							\
+	li	a2, CFG_CACHELINE_SIZE;						\
+	/* kseg0 mem address */							\
+	li	a1, 0;								\
+	li	a3, CFG_CACHE_SETS * CFG_CACHE_WAYS;				\
+1:										\
+	/* store tag (invalid, not locked) */					\
+	cache 0x8, 0(a1);							\
+	cache 0x9, 0(a1);							\
+										\
+	add	a3, -1;								\
+	bne	a3, zero, 1b;							\
+	add	a1, a2;								\
+										\
+	/* set WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ECCF_WST;							\
+	or	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	li	a0, K0BASE;							\
+	move	a2, t3;		/* dcacheSize */				\
+	move	a3, t5;		/* dcacheLineSize */				\
+	move	a1, a2;								\
+	icacheop(a0,a1,a2,a3,(Index_Store_Tag_D));				\
+										\
+	/* clear WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ~ECCF_WST;							\
+	and	a0, a1;								\
+	mtc0	a0, CP0_ECC;
+
+#define IFX_CACHE_LOCK_RAM_AREA							\
+	li      a1, K0BASE - CACHE_LOCK_SIZE;					\
+	addu    a0, a1
+
+#define IFX_CACHE_UNLOCK_RAM_AREA                                               \
+	li      a0, LOCK_DCACHE_ADDR - CACHE_LOCK_SIZE;
+
--- /dev/null
+++ b/cpu/mips/ifx_clock.c
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/ifx_mips.h>
+
+
+/*******************************************************************************
+*
+* get_cpuclk - returns the frequency of the CPU.
+*
+* NOTE:
+*   This functions should be used by the hardware driver to get the correct
+*   frequency of the CPU.
+*/
+
+unsigned int amazon_se_get_ddr_hz(void)
+{
+        switch((*AMAZON_SE_CGU_SYS) & 0x3){
+                case 0:
+                        return 166666667;
+                case 1:
+                        return 133333333;
+                case 2:
+                        return 111111111;
+                case 3:
+                        return 83333333;
+        }
+}
+
+
+uint amazon_se_get_cpuclk(void)
+{
+#ifdef CONFIG_USE_EMULATOR
+        return EMULATOR_CPU_SPEED;
+#else //NOT CONFIG_USE_EMULATOR
+
+	switch((*AMAZON_SE_CGU_SYS) & 0x20){
+		case 0:
+			return CLOCK_266M;
+		case 1:
+			return CLOCK_133M;
+                default:
+			return CLOCK_266M;
+	}
+                        /*reserved*/
+
+#endif
+
+}
+
+
+uint amazon_se_get_fpiclk(void)
+{
+#ifdef CONFIG_USE_EMULATOR
+        unsigned int  clkCPU;
+        clkCPU = amazon_se_get_cpuclk();
+        return clkCPU >> 2;
+#else //NOT CONFIG_USE_EMULATOR
+       return CLOCK_133M;
+#endif
+
+}
+
+
--- /dev/null
+++ b/cpu/mips/ifx_cpu.c
@@ -0,0 +1,5 @@
+
+#define IFX_CPU_RESET					\
+{	*AMAZON_SE_RCU_RST_REQ |=1<<30;			\
+}
+
--- /dev/null
+++ b/cpu/mips/ifx_start.S
@@ -0,0 +1,31 @@
+/*
+ * IFX Platform Dependent CPU Initializations
+ * - for AmazonSE
+ */
+
+#define IFX_EBU_BOOTCFG_DWORD							\
+	.word INFINEON_EBU_BOOTCFG; /* EBU init code, fetched during booting */	\
+	.word 0x00000000;           /* phases of the flash */
+
+#define IFX_MORE_RESERVED_VECTORS						\
+	XVECENT(romExcHandle,0x400);	/* Int, CauseIV=1 */			\
+	RVECENT(romReserved,129);						\
+	RVECENT(romReserved,130);						\
+	RVECENT(romReserved,131);						\
+	RVECENT(romReserved,132);						\
+	RVECENT(romReserved,133);						\
+	RVECENT(romReserved,134);						\
+	RVECENT(romReserved,135);						\
+	RVECENT(romReserved,136);						\
+	RVECENT(romReserved,137);						\
+	RVECENT(romReserved,138);						\
+	RVECENT(romReserved,139);						\
+	RVECENT(romReserved,140);						\
+	RVECENT(romReserved,141);						\
+	RVECENT(romReserved,142);						\
+	RVECENT(romReserved,143);						\
+	XVECENT(romEjtagHandle,0x480);	/* EJTAG debug exception */
+
+#define IFX_CACHE_OPER_MODE							\
+	li	t0, CONF_CM_CACHABLE_NO_WA;
+
--- a/cpu/mips/incaip_clock.c
+++ b/cpu/mips/incaip_clock.c
@@ -21,6 +21,8 @@
  * MA 02111-1307 USA
  */
 
+#ifdef CONFIG_INCA_IP
+
 #include <common.h>
 #include <asm/inca-ip.h>
 
@@ -114,3 +116,5 @@
 
 	return 0;
 }
+
+#endif /* CONFIG_INCA_IP */
--- a/cpu/mips/incaip_wdt.S
+++ b/cpu/mips/incaip_wdt.S
@@ -27,6 +27,7 @@
 #include <version.h>
 #include <asm/regdef.h>
 
+#ifdef CONFIG_INCA_IP
 
 #define WD_BASE            0xb8000000
 #define WD_CON0(value)     0x0020(value)
@@ -70,3 +71,5 @@
 
 	j	ra
 	nop
+
+#endif /* CONFIG_INCA_IP */
--- a/cpu/mips/start.S
+++ b/cpu/mips/start.S
@@ -27,7 +27,9 @@
 #include <version.h>
 #include <asm/regdef.h>
 #include <asm/mipsregs.h>
-
+#if defined(CONFIG_IFX_MIPS)
+#	include "ifx_start.S"
+#endif
 
 #define RVECENT(f,n) \
    b f; nop
@@ -36,15 +38,24 @@
    li k0,bev
 
 	.set noreorder
-
+#ifdef CFG_BOOTSTRAP_CODE
+	.globl _start_bootstrap
+#else
 	.globl _start
+#endif
 	.text
+#ifdef CFG_BOOTSTRAP_CODE
+_start_bootstrap:
+#else
 _start:
+#endif
 	RVECENT(reset,0)	/* U-boot entry point */
 	RVECENT(reset,1)	/* software reboot */
-#if defined(CONFIG_INCA_IP)
+#if defined(CONFIG_INCA_IP) || defined(CONFIG_INCA_IP2)
 	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
 	.word 0x00000000           /* phase of the flash                    */
+#elif defined(CONFIG_IFX_MIPS) && defined(IFX_EBU_BOOTCFG_DWORD)
+	IFX_EBU_BOOTCFG_DWORD
 #elif defined(CONFIG_PURPLE)
 	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
 	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
@@ -181,6 +192,9 @@
 	 * 128 * 8 == 1024 == 0x400
 	 * so this is address R_VEC+0x400 == 0xbfc00400
 	 */
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_MORE_RESERVED_VECTORS)
+	IFX_MORE_RESERVED_VECTORS
+#else
 #ifdef CONFIG_PURPLE
 /* 0xbfc00400 */
 	.word	0xdc870000
@@ -205,8 +219,12 @@
 	.word	0x00000000
 	.word   0x00000000
 #endif /* CONFIG_PURPLE */
+#endif /* CONFIG_IFX_MIPS */
 	.align 4
 reset:
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_RESET_PRECHECK)
+	IFX_RESET_PRECHECK
+#endif
 
 	/* Clear watch registers.
 	 */
@@ -226,6 +244,10 @@
 	/* CAUSE register */
 	mtc0	zero, CP0_CAUSE
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU_EXTRA_INIT)
+	IFX_CPU_EXTRA_INIT
+#endif
+
 	/* Init Timer */
 	mtc0	zero, CP0_COUNT
 	mtc0	zero, CP0_COMPARE
@@ -239,7 +261,7 @@
 	bal     1f
 	nop
 	.word   _GLOBAL_OFFSET_TABLE_
-	1:
+1:
 	move    gp, ra
 	lw      t1, 0(ra)
 	move	gp, t1
@@ -252,12 +274,26 @@
 	nop
 #endif
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU1_SUPPORT) && defined(IFX_SKIP_LOWLEVEL_INIT)
+	IFX_SKIP_LOWLEVEL_INIT
+#endif
+#ifdef CFG_BOOTSTRAP_CODE
 	/* Initialize any external memory.
 	 */
 	la      t9, lowlevel_init
 	jalr    t9
 	nop
+#endif
+lowlevel_init_done:
+
+	beq	s0, zero, init_cache_0
+	nop
+
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU1_SUPPORT) && defined(IFX_CPU1_INIT)
+        IFX_CPU1_INIT
+#endif
 
+init_cache_0:
 	/* Initialize caches...
 	 */
 	la      t9, mips_cache_reset
@@ -266,7 +302,11 @@
 
 	/* ... and enable them.
 	 */
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_OPER_MODE)
+	IFX_CACHE_OPER_MODE
+#else
 	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+#endif
 	mtc0	t0, CP0_CONFIG
 
 
@@ -280,13 +320,38 @@
 	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
 	la	sp, 0(t0)
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU1_SUPPORT) && defined(IFX_BOOT_CLEAR)
+	IFX_BOOT_CLEAR
+#endif
+
+#ifdef CFG_BOOTSTRAP_CODE
+	la	t9, bootstrap_board_init_f
+#else
 	la	t9, board_init_f
+#endif
 	j	t9
 	nop
 
+#ifdef CFG_BOOTSTRAP_CODE
+/*
+ * void jump_unconditional (addr)
+ * This function simply jumps to the location pointed by a0.
+ * a0 = target_location
+ *
+ */
+	.globl  jump_unconditional
+	.ent    jump_unconditional
+jump_unconditional:
+	move t9, a0
+	j       t9
+	nop
+	.end    jump_unconditional
+
+#endif
 
 /*
  * void relocate_code (addr_sp, gd, addr_moni)
+ * void bootstrap_relocate_code (addr_sp, gd, addr_moni)
  *
  * This "function" does not return, instead it continues in RAM
  * after relocating the monitor code.
@@ -295,12 +360,22 @@
  * a1 = gd
  * a2 = destination address
  */
+#ifdef CFG_BOOTSTRAP_CODE
+	.globl	bootstrap_relocate_code
+	.ent	bootstrap_relocate_code
+bootstrap_relocate_code:
+#else
 	.globl	relocate_code
 	.ent	relocate_code
 relocate_code:
+#endif
 	move	sp, a0		/* Set new stack pointer		*/
 
+#ifdef CFG_BOOTSTRAP_CODE
+	li	t0, BOOTSTRAP_CFG_MONITOR_BASE
+#else
 	li	t0, CFG_MONITOR_BASE
+#endif
 	la	t3, in_ram
 	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/
 	move	t1, a2
@@ -311,7 +386,11 @@
 	 * New GOT-PTR = (old GOT-PTR - CFG_MONITOR_BASE) + Destination Address
 	 */
 	move	t6, gp
+#ifdef CFG_BOOTSTRAP_CODE
+	sub	gp, BOOTSTRAP_CFG_MONITOR_BASE
+#else
 	sub	gp, CFG_MONITOR_BASE
+#endif
 	add	gp, a2			/* gp now adjusted		*/
 	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
 
@@ -337,12 +416,21 @@
 
 	/* Jump to where we've relocated ourselves.
 	 */
+#ifdef CFG_BOOTSTRAP_CODE
+	addi	t0, a2, in_ram - _start_bootstrap
+#else
 	addi	t0, a2, in_ram - _start
+#endif
 	j	t0
 	nop
 
+#ifdef CFG_BOOTSTRAP_CODE
+	.word	uboot_end_data_bootstrap
+	.word	uboot_end_bootstrap
+#else
 	.word	uboot_end_data
 	.word	uboot_end
+#endif
 	.word	num_got_entries
 
 in_ram:
@@ -374,12 +462,19 @@
 	sw	zero, 0(t1)	/* delay slot			*/
 
 	move	a0, a1
+#ifdef CFG_BOOTSTRAP_CODE
+	la	t9, bootstrap_board_init_r
+#else
 	la	t9, board_init_r
+#endif
 	j	t9
 	move	a1, a2		/* delay slot			*/
 
+#ifdef CFG_BOOTSTRAP_CODE
+	.end	bootstrap_relocate_code
+#else
 	.end	relocate_code
-
+#endif
 
 	/* Exception handlers.
 	 */
@@ -388,3 +483,11 @@
 
 romExcHandle:
 	b romExcHandle
+
+romEjtagHandle:
+#ifdef CFG_BOOTSTRAP_CODE
+	deret
+	nop
+#endif /* CFG_BOOTSTRAP_CODE */
+1:
+	b 1b
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -31,7 +31,7 @@
 	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o \
 	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000x.o \
 	  e1000.o eepro100.o \
-	  i8042.o inca-ip_sw.o keyboard.o \
+	  i8042.o ifx_sw.o inca-ip_sw.o keyboard.o \
 	  lan91c96.o \
 	  natsemi.o ne2000.o netarm_eth.o netconsole.o \
 	  ns16550.o ns8382x.o ns87308.o ns7520_eth.o omap1510_i2c.o \
--- /dev/null
+++ b/drivers/ifx_sw.c
@@ -0,0 +1,712 @@
+/*
+ * AMAZON_SE internal switch ethernet driver.
+ *
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI) \
+    && defined(CONFIG_AMAZON_SE_SWITCH)
+
+#include <malloc.h>
+#include <net.h>
+#include <asm/ifx_mips.h>
+#include <asm/addrspace.h>
+#include <asm/pinstrap.h>
+#include <boot.h>
+#define SET_GPIO        1       //1, for gpio, 0 for dedicated
+
+#define EPHY_CLOCK      0       //1 External clock, 0 internal clock
+
+#define MII_MODE 1
+#define REV_MII_MODE 2
+#define  RED_MII_MODE    3
+#define  EPHY_MODE      4
+
+
+#define TX_CHAN_NO   3
+#define RX_CHAN_NO   5
+
+#define NUM_RX_DESC	PKTBUFSRX
+#define NUM_TX_DESC	8
+#define MAX_PACKET_SIZE 	1536
+#define TOUT_LOOP	100
+#define PHY0_ADDR       1 /*fixme: set the correct value here*/
+
+#define  RED_MII_MUX_WITH_SPI  1
+
+#define DMA_WRITE_REG(reg, value) *((volatile u32 *)reg) = (u32)value
+#define DMA_READ_REG(reg, value)    value = (u32)*((volatile u32*)reg)
+
+#define SW_WRITE_REG(reg, value)  *((volatile u32*)reg) = (u32)value
+#define SW_READ_REG(reg, value)   value = (u32)*((volatile u32*)reg)
+
+
+#ifdef ENABLE_TRACE
+#define TRACE(fmt,args...) printf("%s: " fmt, __FUNCTION__ , ##args)
+#else
+#define TRACE(fmt,args...)
+#endif
+/*
+extern u8 g_mac_addr[];
+extern u8 g_phy_addr[];
+*/
+int g_ethernet_mode = 0;
+u8 g_mac_addr[]= {0x00,0x03,0x19,00,00,00};
+u8 g_phy_addr[]= {0x00,0x01};
+typedef struct
+{
+	union
+	{
+		struct
+		{
+			volatile u32 OWN                 :1;
+			volatile u32 C	                 :1;
+			volatile u32 Sop                 :1;
+			volatile u32 Eop	         :1;
+			volatile u32 reserved		 :3;
+			volatile u32 Byteoffset		 :2;
+			volatile u32 reserve             :7;
+			volatile u32 DataLen             :16;
+		}field;
+
+		volatile u32 word;
+	}status;
+
+	volatile u32 DataPtr;
+} amazon_se_rx_descriptor_t;
+
+typedef struct
+{
+	union
+	{
+		struct
+		{
+			volatile u32 OWN                 :1;
+			volatile u32 C	                 :1;
+			volatile u32 Sop                 :1;
+			volatile u32 Eop	         :1;
+			volatile u32 Byteoffset		 :5;
+			volatile u32 reserved            :7;
+			volatile u32 DataLen             :16;
+		}field;
+
+		volatile u32 word;
+	}status;
+
+	volatile u32 DataPtr;
+} amazon_se_tx_descriptor_t;
+
+
+
+
+static amazon_se_rx_descriptor_t rx_des_ring[NUM_RX_DESC] __attribute__ ((aligned(8)));
+static amazon_se_tx_descriptor_t tx_des_ring[NUM_TX_DESC] __attribute__ ((aligned(8)));
+static int tx_num, rx_num;
+
+int amazon_se_switch_init(struct eth_device *dev, bd_t * bis);
+int amazon_se_switch_send(struct eth_device *dev, volatile void *packet,int length);
+int amazon_se_switch_recv(struct eth_device *dev);
+void amazon_se_switch_halt(struct eth_device *dev);
+static int amazon_se_sw_chip_init (int mode, int gpio);
+static void amazon_se_dma_init(void);
+
+void
+configureMiiRxClk (int external, int loopback)
+{
+	if (external == 1) {
+		TRACE("\n Configured external Rx clk ");
+//		*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR | (0x3 << 28));
+		*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR & ~(0x3 << 28));
+	}
+	else {
+		//from CGU
+		if (loopback == 0) {
+			TRACE("\n Configured internal Rx clk(from CGU) ");
+			// clock from CGU
+	//		*AMAZON_SE_CGU_IFCCR =
+	//			(*AMAZON_SE_CGU_IFCCR & ~(0x3 << 28));
+			*AMAZON_SE_CGU_IFCCR =
+				(*AMAZON_SE_CGU_IFCCR | (0x3 << 28));
+		}
+		else {
+			TRACE("\n Configured  Rx clk from PADs (loop back)");
+			//looped back from PADs
+		//	*AMAZON_SE_CGU_IFCCR =
+		//		((*AMAZON_SE_CGU_IFCCR & ~(0x1 << 28)) |
+//				 (0x1 << 29));
+			*AMAZON_SE_CGU_IFCCR =
+				((*AMAZON_SE_CGU_IFCCR | (0x1 << 28)) &
+				 ~(0x1 << 29));
+		}
+	}
+}
+
+
+void
+configureMiiTxClk (int external, int loopback)
+{
+	if (external == 1) {
+		TRACE("\n Configured external Tx clk ");
+	//	*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR | (0x3 << 26));
+		*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR & ~(0x3 << 26));
+	}
+	else {
+		if (loopback == 0) {
+			TRACE("\n Configured internal Tx clk(from CGU) ");
+			//from CGU
+	//		*AMAZON_SE_CGU_IFCCR =
+	//			(*AMAZON_SE_CGU_IFCCR & ~(0x3 << 26));
+			*AMAZON_SE_CGU_IFCCR =
+				(*AMAZON_SE_CGU_IFCCR | (0x3 << 26));
+		}
+		else {
+			TRACE("\n Configured Tx clk from PADs (loop back)");
+//			*AMAZON_SE_CGU_IFCCR =
+//				((*AMAZON_SE_CGU_IFCCR & ~(0x1 << 26)) |
+//				 (0x1 << 27));
+			*AMAZON_SE_CGU_IFCCR =
+				((*AMAZON_SE_CGU_IFCCR | (0x1 << 26)) &
+				 ~(0x1 << 27));
+		}
+	}
+}
+
+
+void
+configureRMiiRefClk (int external, int loopback)
+{
+	if (external == 1) {
+		TRACE("\n Configured external Ref clk ");
+	//	*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR | (0x3 << 24));
+		*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR & ~(0x3 << 24));
+	}
+	else {
+		if (loopback == 0)
+		{
+			TRACE("\n Configured internal Ref clk(from CGU) ");
+		//	*AMAZON_SE_CGU_IFCCR =
+		//		(*AMAZON_SE_CGU_IFCCR & ~(0x3 << 24));
+			*AMAZON_SE_CGU_IFCCR =
+				(*AMAZON_SE_CGU_IFCCR | (0x3 << 24));
+		}
+		else
+		{
+			TRACE("\n Configured Ref clk from PADs (loop back)");
+		//	*AMAZON_SE_CGU_IFCCR =
+		//		((*AMAZON_SE_CGU_IFCCR & ~(0x1 << 24)) |
+		//		 (0x1 << 25));
+			*AMAZON_SE_CGU_IFCCR =
+				((*AMAZON_SE_CGU_IFCCR | (0x1 << 24)) &
+				 ~(0x1 << 25));
+		}
+	}
+}
+
+#if 0
+void
+configurePhyClk (int enable)
+{
+	if (enable == 1)
+	{
+                printf("EPHY using internal clock\n");
+		*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR | (0x1 << 4));
+	        *AMAZON_SE_CGU_OSC_CON = (*AMAZON_SE_CGU_OSC_CON ) & (~0x18);
+
+        }
+	else
+	{
+
+                printf("EPHY using external clock\n");
+		*AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR & ~(0x1 << 4));
+		*AMAZON_SE_CGU_OSC_CON = (*AMAZON_SE_CGU_OSC_CON ) | 0x18;
+	}
+
+}
+#endif
+
+void
+configurePhyClk (int enable)
+{
+        if (enable == 1)
+        {
+                //Clock from External
+                *AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR & ~(0x1 << 4));
+                *AMAZON_SE_CGU_OSC_CON = (*AMAZON_SE_CGU_OSC_CON ) | 0x18;
+                printf("External Clock\n");
+        }
+        else
+        {
+                //Clock from CGU
+                *AMAZON_SE_CGU_IFCCR = (*AMAZON_SE_CGU_IFCCR | (0x1 << 4));
+                *AMAZON_SE_CGU_OSC_CON = (*AMAZON_SE_CGU_OSC_CON ) & ~(0x18);
+                printf("Internal Clock\n");
+        }
+
+}
+
+int
+configureMiiGpioChan (int mode, int gpio)
+{
+
+        if (gpio == 0)
+                return;
+
+        if ( mode == MII_MODE )
+        {
+
+        } else if (mode == REV_MII_MODE )
+        {
+                //GPIO 0 (TXD0), 4(TXD1), 12 (RXDV) & 13(TXEN)
+                *AMAZON_SE_GPIO_P0_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P0_ALTSEL0 & 0xCFFF ) | 0x0010;
+                *AMAZON_SE_GPIO_P0_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P0_ALTSEL1 & 0xfffe) | 0x3011;
+#if 1
+                *AMAZON_SE_GPIO_P0_OD = *(AMAZON_SE_GPIO_P0_OD) | 0x3011;
+                *AMAZON_SE_GPIO_P0_DIR = (*AMAZON_SE_GPIO_P0_DIR) & ~(0x3011);
+                *AMAZON_SE_GPIO_P0_DIR = (*AMAZON_SE_GPIO_P0_DIR) | (0x1000);
+                //GPIO 29 (TXD2), 28(TXD3)
+                *AMAZON_SE_GPIO_P1_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL0 & 0xCFFE ) ;
+                *AMAZON_SE_GPIO_P1_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL1 & 0xffff) | 0x3000;
+                *AMAZON_SE_GPIO_P1_DIR = (*AMAZON_SE_GPIO_P1_DIR) | (0x3000);
+
+                //GPIO 19 (RXD3), 20(RXD2), 23 (RXD1), 25 (RXD0), 24 (MDIO) & 27 (MDC)
+                *AMAZON_SE_GPIO_P1_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL0 & 0xFD67 )  | 0x0900;
+                *AMAZON_SE_GPIO_P1_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL1 & 0xffff) | 0x0B98;
+                *AMAZON_SE_GPIO_P1_OD = *(AMAZON_SE_GPIO_P1_OD) | 0x0998;
+                *AMAZON_SE_GPIO_P1_DIR = (*AMAZON_SE_GPIO_P1_DIR) |(0x0998);
+                *AMAZON_SE_GPIO_P1_DIR = (*AMAZON_SE_GPIO_P1_DIR) &(~0x0200);
+
+                //GPIO 21 (CRS), 22(RX Clk) & 26 (TX Clk)
+                *AMAZON_SE_GPIO_P1_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL0 & 0xFB9F ) ;
+                *AMAZON_SE_GPIO_P1_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL1 & 0xffff) | 0x0460;
+                *AMAZON_SE_GPIO_P1_DIR =  ((*AMAZON_SE_GPIO_P1_DIR) & ~(0x0220) ) ;
+#else
+                *AMAZON_SE_GPIO_P1_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL0 & 0xc907 )| 0x0900 ;
+                *AMAZON_SE_GPIO_P1_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL1 & 0xffff) | 0x3ff8;
+                *AMAZON_SE_GPIO_P0_OD = *(AMAZON_SE_GPIO_P0_OD) | 0xffff;
+                *AMAZON_SE_GPIO_P1_DIR =  ((*AMAZON_SE_GPIO_P1_DIR) & (0xff9f) ) ;
+#endif
+                printf("GPIO setting is done for REV MII\n");
+
+        } else if (mode == RED_MII_MODE)
+        {
+                // Red MII
+                //Common  GPIO 0 (TXD0), 4(TXD1) & 13(TXEN)
+                *AMAZON_SE_GPIO_P0_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P0_ALTSEL0 & 0xDFFE ) | 0x0010;
+                *AMAZON_SE_GPIO_P0_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P0_ALTSEL1 & 0xffff) | 0x2011;
+                *AMAZON_SE_GPIO_P0_OD = *(AMAZON_SE_GPIO_P0_OD) | 0x2011;
+                 //GPIO24 (MDIO) & 27 (MDC)
+                *AMAZON_SE_GPIO_P1_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL0 & 0xFFFF )  | 0x0900;
+                *AMAZON_SE_GPIO_P1_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL1 & 0xffff) | 0x0900;
+                *AMAZON_SE_GPIO_P1_DIR = (*AMAZON_SE_GPIO_P1_DIR) |(0x0900);
+
+#if RED_MII_MUX_WITH_SPI
+                //GPIO 7(RXDV),8(RXD1),9(RXD0) & 10(Ref Clock)
+                *AMAZON_SE_GPIO_P0_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P0_ALTSEL0 & 0xF87F ) ;
+                *AMAZON_SE_GPIO_P0_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P0_ALTSEL1 & 0xffff) | 0x0780;
+                *AMAZON_SE_GPIO_P0_OD = *(AMAZON_SE_GPIO_P0_OD) | 0x0400;
+
+                *AMAZON_SE_GPIO_P0_DIR = (*AMAZON_SE_GPIO_P0_DIR) & 0xFC7F;
+
+                printf(" SPI  Inactive\n");
+#else
+                //GPIO 21,22,23 & 25
+                *AMAZON_SE_GPIO_P1_ALTSEL0 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL0 & 0xFD1F) ;
+                *AMAZON_SE_GPIO_P1_ALTSEL1 =
+                        (*AMAZON_SE_GPIO_P1_ALTSEL1 & 0xFFFF ) | 0x02E0;
+                *AMAZON_SE_GPIO_P1_OD = *(AMAZON_SE_GPIO_P1_OD) | 0x0040;
+                *AMAZON_SE_GPIO_P1_DIR = (*AMAZON_SE_GPIO_P1_DIR & 0xFD5F);
+                printf(" FLASH Inactive\n");
+
+#endif
+
+
+        }
+}
+
+
+void
+enableTurboMode ()
+{
+	*AMAZON_SE_PPE32_ETOP_CFG = *AMAZON_SE_PPE32_ETOP_CFG | 0x00000004;
+}
+
+void
+disableTurboMode ()
+{
+	*AMAZON_SE_PPE32_ETOP_CFG = *AMAZON_SE_PPE32_ETOP_CFG & 0xfffffffb;
+}
+
+static int
+amazon_se_sw_chip_init (int mode, int gpio)
+{
+
+        int i;
+        unsigned short data=0;
+
+/* 30 May 2007 start */
+        *(volatile u32*)AMAZON_SE_PPE32_BASE=0x0;
+        *AMAZON_SE_RCU_RST_REQ |= 0x100;   //Reset PPE module
+/* 30 May 2007 end */
+
+
+        *AMAZON_SE_PMU_PWDCR &= ~(1 << 13);     /*enable PPE  from PMU */
+        for (i = 0; i < 0x5000; i++);
+
+        g_ethernet_mode = mode;
+
+        switch (mode) {
+
+        case MII_MODE:
+                configureMiiGpioChan (mode, gpio);
+                configureMiiRxClk (1, 0);       //externel = 0, loop back 0
+                configureMiiTxClk (1, 0);
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        *AMAZON_SE_PPE32_ETOP_CFG & 0xfffffffe;
+                printf("Selected MII_MODE  \n");
+                break;
+        case REV_MII_MODE:
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        (*AMAZON_SE_PPE32_ETOP_CFG ) | 0x00000001;
+                configureMiiRxClk (0, 0);       //externel = 0, loop back 0
+                configureMiiTxClk (0, 0);
+                configureMiiGpioChan (mode, gpio);
+                *AMAZON_SE_PPE32_ETOP_CFG = (*AMAZON_SE_PPE32_ETOP_CFG) & ~(0x4000);
+                *AMAZON_SE_CGU_OSC_CON = (*AMAZON_SE_CGU_OSC_CON ) & ~(0x18);
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        (*AMAZON_SE_PPE32_ETOP_CFG ) | 0x00000002;
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        *AMAZON_SE_PPE32_ETOP_CFG & 0xfffffffe;
+                printf("Selected REV_MII_MODE \n");
+                break;
+
+        case RED_MII_MODE:
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        (*AMAZON_SE_PPE32_ETOP_CFG ) | 0x00000001;
+                configureRMiiRefClk (0, 0);     //clock from CGU
+                configureMiiGpioChan (mode, gpio);
+                *AMAZON_SE_PPE32_ETOP_CFG = (*AMAZON_SE_PPE32_ETOP_CFG) & ~(0x4000);
+                //enable Red Mii mode and clock is from CGU
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        (*AMAZON_SE_PPE32_ETOP_CFG)  | 0x00001000;
+                *AMAZON_SE_CGU_OSC_CON = (*AMAZON_SE_CGU_OSC_CON ) & ~(0x18);
+                //enable Red Mii mode and clock is from External
+//              *AMAZON_SE_PPE32_ETOP_CFG =
+//                      *AMAZON_SE_PPE32_ETOP_CFG  | 0x00009000;
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        *AMAZON_SE_PPE32_ETOP_CFG & 0xfffffffe;
+		//Leon 07092804 disable MDIO auto-sensing mode
+                *AMAZON_SE_PPE32_ETOP_MDIO_CFG &= ~(1 << 1);
+		printf("Selected RED_MII_MODE \n");
+                break;
+        case EPHY_MODE:
+                *AMAZON_SE_PMU_PWDCR &= ~(1 << 7);      /*enable EPHY module  from PMU */
+                for (i = 0; i < 0x500; i++);
+                *AMAZON_SE_PPE32_ETOP_CFG =
+                        (*AMAZON_SE_PPE32_ETOP_CFG ) | 0x00000001;
+#if EPHY_CLOCK
+                configurePhyClk (1);   //clock from External
+#else
+                configurePhyClk (0);   //clock from CGU
+#endif
+//              *AMAZON_SE_PPE32_ETOP_CFG =  0x4141;
+                *AMAZON_SE_PPE32_ETOP_CFG = (*AMAZON_SE_PPE32_ETOP_CFG) |0x4000;
+                //unsigned short data;
+/* 08 June 2007 start */
+#if SET_CLASS_A_VALUE
+//              data = ephy_read_mdio_reg (EPHY_ADDRESS,  EPHY_SET_CLASS_VALUE_REG);
+                ephy_write_mdio_reg (EPHY_ADDRESS, EPHY_SET_CLASS_VALUE_REG, 0xc020);
+#endif
+/* 08 June 2007 End*/
+                printf("Selected EPHY_MODE \n");
+                break;
+
+        default:
+                printf (" Switch Mode is not selected, Error!!! \n");
+                *AMAZON_SE_PPE32_ETOP_CFG = (*AMAZON_SE_PPE32_ETOP_CFG) & ~(0x4000);
+
+        }
+
+/* 14 May 2007 Start */
+//      *AMAZON_SE_PPE32_ETOP_IG_PLEN_CTRL = 0x4005ee;  // set packetlen.
+        *AMAZON_SE_PPE32_ETOP_IG_PLEN_CTRL = 0x4005dc;  // set packetlen.
+/* 14 May 2007 End*/
+        *ENET_MAC_CFG |= 1 << 11;       /*enable the crc */
+
+}
+
+int amazon_se_switch_initialize(bd_t * bis)
+{
+	struct eth_device *dev;
+
+
+
+	if (!(dev = (struct eth_device *) malloc (sizeof *dev)))
+	{
+		printf("Failed to allocate memory\n");
+		return 0;
+	}
+	memset(dev, 0, sizeof(*dev));
+	amazon_se_dma_init();
+#ifdef IFX_CONFIG_ETHERNET_TYPE_EPHY
+	amazon_se_sw_chip_init(EPHY_MODE, 0);
+#endif
+#ifdef IFX_CONFIG_ETHERNET_TYPE_RMII
+	amazon_se_sw_chip_init(RED_MII_MODE, 1);
+#endif
+	sprintf(dev->name, "AMAZON_SE Switch");
+	dev->init = amazon_se_switch_init;
+	dev->halt = amazon_se_switch_halt;
+	dev->send = amazon_se_switch_send;
+	dev->recv = amazon_se_switch_recv;
+
+	eth_register(dev);
+
+
+	return 1;
+}
+
+int amazon_se_switch_init(struct eth_device *dev, bd_t * bis)
+{
+	int i;
+
+	tx_num=0;
+	rx_num=0;
+
+		/* Reset DMA
+		 */
+//	serial_puts("i \n\0");
+
+       *AMAZON_SE_DMA_CS=RX_CHAN_NO;
+       *AMAZON_SE_DMA_CCTRL=0x2;/*fix me, need to reset this channel first?*/
+       *AMAZON_SE_DMA_CPOLL= 0x80000040;
+       /*set descriptor base*/
+       *AMAZON_SE_DMA_CDBA=(u32)rx_des_ring;
+       *AMAZON_SE_DMA_CDLEN=NUM_RX_DESC;
+       *AMAZON_SE_DMA_CIE = 0;
+       *AMAZON_SE_DMA_CCTRL=0x30000;
+
+       *AMAZON_SE_DMA_CS=TX_CHAN_NO;
+       *AMAZON_SE_DMA_CCTRL=0x2;/*fix me, need to reset this channel first?*/
+       *AMAZON_SE_DMA_CPOLL= 0x80000040;
+       *AMAZON_SE_DMA_CDBA=(u32)tx_des_ring;
+       *AMAZON_SE_DMA_CDLEN=NUM_TX_DESC;
+       *AMAZON_SE_DMA_CIE = 0;
+       *AMAZON_SE_DMA_CCTRL=0x30100;
+
+	for(i=0;i < NUM_RX_DESC; i++)
+	{
+		amazon_se_rx_descriptor_t * rx_desc = KSEG1ADDR(&rx_des_ring[i]);
+		rx_desc->status.word=0;
+		rx_desc->status.field.OWN=1;
+		rx_desc->status.field.DataLen=PKTSIZE_ALIGN;   /* 1536  */
+		rx_desc->DataPtr=(u32)KSEG1ADDR(NetRxPackets[i]);
+	}
+
+	for(i=0;i < NUM_TX_DESC; i++)
+	{
+		amazon_se_tx_descriptor_t * tx_desc = KSEG1ADDR(&tx_des_ring[i]);
+		memset(tx_desc, 0, sizeof(tx_des_ring[0]));
+	}
+		/* turn on DMA rx & tx channel
+		 */
+	 *AMAZON_SE_DMA_CS=RX_CHAN_NO;
+	 *AMAZON_SE_DMA_CCTRL|=1;/*reset and turn on the channel*/
+
+	return 0;
+}
+
+void amazon_se_switch_halt(struct eth_device *dev)
+{
+        int i;
+        for(i=0;i<8;i++)
+	{
+	   *AMAZON_SE_DMA_CS=i;
+	   *AMAZON_SE_DMA_CCTRL&=~1;/*stop the dma channel*/
+	}
+//	udelay(1000000);
+}
+
+int amazon_se_switch_send(struct eth_device *dev, volatile void *packet,int length)
+{
+
+	int                    	i;
+	int 		 	res = -1;
+
+	amazon_se_tx_descriptor_t * tx_desc= KSEG1ADDR(&tx_des_ring[tx_num]);
+
+	if (length <= 0)
+	{
+		printf ("%s: bad packet size: %d\n", dev->name, length);
+		goto Done;
+	}
+
+	for(i=0; tx_desc->status.field.OWN==1; i++)
+	{
+		if(i>=TOUT_LOOP)
+		{
+			printf("NO Tx Descriptor...");
+			goto Done;
+		}
+	}
+
+	//serial_putc('s');
+
+	tx_desc->status.field.Sop=1;
+	tx_desc->status.field.Eop=1;
+	tx_desc->status.field.C=0;
+	tx_desc->DataPtr = (u32)KSEG1ADDR(packet);
+	if(length<60)
+		tx_desc->status.field.DataLen = 60;
+	else
+		tx_desc->status.field.DataLen = (u32)length;
+
+	asm("SYNC");
+	tx_desc->status.field.OWN=1;
+
+	res=length;
+	tx_num++;
+        if(tx_num==NUM_TX_DESC) tx_num=0;
+	*AMAZON_SE_DMA_CS=TX_CHAN_NO;
+
+	if(!(*AMAZON_SE_DMA_CCTRL & 1))
+	*AMAZON_SE_DMA_CCTRL|=1;
+
+Done:
+	return res;
+}
+
+int amazon_se_switch_recv(struct eth_device *dev)
+{
+
+	int                    length  = 0;
+        int tmp;
+	amazon_se_rx_descriptor_t * rx_desc;
+        int anchor_num=0;
+	int i;
+	for (;;)
+	{
+	        rx_desc = KSEG1ADDR(&rx_des_ring[rx_num]);
+
+	        if ((rx_desc->status.field.C == 0) || (rx_desc->status.field.OWN == 1))
+		{
+		   break;
+		}
+
+
+		length = rx_desc->status.field.DataLen;
+		if (length)
+		{
+                        /*tmp=(int)KSEG1ADDR(NetRxPackets[rx_num]);
+			printf("%08x\n",tmp);
+                        */
+			NetReceive((void*)KSEG1ADDR(NetRxPackets[rx_num]), length - 4);
+		//	serial_putc('*');
+		}
+		else
+		{
+			printf("Zero length!!!\n");
+		}
+
+		rx_desc->status.field.Sop=0;
+		rx_desc->status.field.Eop=0;
+		rx_desc->status.field.C=0;
+		rx_desc->status.field.DataLen=PKTSIZE_ALIGN;
+		rx_desc->status.field.OWN=1;
+		rx_num++;
+		if(rx_num==NUM_RX_DESC) rx_num=0;
+
+	}
+
+	return length;
+}
+
+
+
+
+static void amazon_se_dma_init(void)
+{
+        int i;
+//	serial_puts("d \n\0");
+
+        *AMAZON_SE_PMU_PWDCR &=~(1<<5);/*enable DMA from PMU*/
+		/* Reset DMA
+		 */
+	*AMAZON_SE_DMA_CTRL|=1;
+        *AMAZON_SE_DMA_IRNEN=0;/*disable all the interrupts first*/
+
+	/* Clear Interrupt Status Register
+	*/
+	*AMAZON_SE_DMA_IRNCR=0xfffff;
+	/*disable all the dma interrupts*/
+	*AMAZON_SE_DMA_IRNEN=0;
+	/*disable channel 0 and channel 1 interrupts*/
+
+	  *AMAZON_SE_DMA_CS=RX_CHAN_NO;
+	  *AMAZON_SE_DMA_CCTRL=0x2;/*fix me, need to reset this channel first?*/
+          *AMAZON_SE_DMA_CPOLL= 0x80000040;
+          /*set descriptor base*/
+          *AMAZON_SE_DMA_CDBA=(u32)rx_des_ring;
+          *AMAZON_SE_DMA_CDLEN=NUM_RX_DESC;
+          *AMAZON_SE_DMA_CIE = 0;
+          *AMAZON_SE_DMA_CCTRL=0x30000;
+
+	*AMAZON_SE_DMA_CS=TX_CHAN_NO;
+	*AMAZON_SE_DMA_CCTRL=0x2;/*fix me, need to reset this channel first?*/
+        *AMAZON_SE_DMA_CPOLL= 0x80000040;
+	*AMAZON_SE_DMA_CDBA=(u32)tx_des_ring;
+        *AMAZON_SE_DMA_CDLEN=NUM_TX_DESC;
+	*AMAZON_SE_DMA_CIE = 0;
+	*AMAZON_SE_DMA_CCTRL=0x30100;
+	/*enable the poll function and set the poll counter*/
+	//*AMAZON_SE_DMA_CPOLL=AMAZON_SE_DMA_POLL_EN | (AMAZON_SE_DMA_POLL_COUNT<<4);
+	/*set port properties, enable endian conversion for switch*/
+	*AMAZON_SE_DMA_PS=0;
+	*AMAZON_SE_DMA_PCTRL|=0xf<<8;/*enable 32 bit endian conversion*/
+
+	return;
+}
+
+
+
+
+
+#endif
--- /dev/null
+++ b/include/LzmaWrapper.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.h
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#ifndef  __LZMA_WRAPPER_H__
+#define  __LZMA_WRAPPER_H__
+
+#ifndef LZMA_RESULT_OK
+#define LZMA_RESULT_OK 0
+#endif
+#ifndef LZMA_RESULT_DATA_ERROR
+#define LZMA_RESULT_DATA_ERROR 1
+#endif
+
+extern int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len);
+
+#endif /*__LZMA_WRAPPER_H__*/
--- /dev/null
+++ b/include/asm-mips/errno.h
@@ -0,0 +1,139 @@
+#ifndef _ARM_ERRNO_H
+#define _ARM_ERRNO_H
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Arg list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+#define	EDEADLK		35	/* Resource deadlock would occur */
+#define	ENAMETOOLONG	36	/* File name too long */
+#define	ENOLCK		37	/* No record locks available */
+#define	ENOSYS		38	/* Function not implemented */
+#define	ENOTEMPTY	39	/* Directory not empty */
+#define	ELOOP		40	/* Too many symbolic links encountered */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	ENOMSG		42	/* No message of desired type */
+#define	EIDRM		43	/* Identifier removed */
+#define	ECHRNG		44	/* Channel number out of range */
+#define	EL2NSYNC	45	/* Level 2 not synchronized */
+#define	EL3HLT		46	/* Level 3 halted */
+#define	EL3RST		47	/* Level 3 reset */
+#define	ELNRNG		48	/* Link number out of range */
+#define	EUNATCH		49	/* Protocol driver not attached */
+#define	ENOCSI		50	/* No CSI structure available */
+#define	EL2HLT		51	/* Level 2 halted */
+#define	EBADE		52	/* Invalid exchange */
+#define	EBADR		53	/* Invalid request descriptor */
+#define	EXFULL		54	/* Exchange full */
+#define	ENOANO		55	/* No anode */
+#define	EBADRQC		56	/* Invalid request code */
+#define	EBADSLT		57	/* Invalid slot */
+#define	EDEADLOCK	58	/* File locking deadlock error */
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EMULTIHOP	72	/* Multihop attempted */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EBADMSG		74	/* Not a data message */
+#define	EOVERFLOW	75	/* Value too large for defined data type */
+#define	ENOTUNIQ	76	/* Name not unique on network */
+#define	EBADFD		77	/* File descriptor in bad state */
+#define	EREMCHG		78	/* Remote address changed */
+#define	ELIBACC		79	/* Can not access a needed shared library */
+#define	ELIBBAD		80	/* Accessing a corrupted shared library */
+#define	ELIBSCN		81	/* .lib section in a.out corrupted */
+#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
+#define	EILSEQ		84	/* Illegal byte sequence */
+#define	ERESTART	85	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	86	/* Streams pipe error */
+#define	EUSERS		87	/* Too many users */
+#define	ENOTSOCK	88	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	89	/* Destination address required */
+#define	EMSGSIZE	90	/* Message too long */
+#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	92	/* Protocol not available */
+#define	EPROTONOSUPPORT	93	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
+#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	96	/* Protocol family not supported */
+#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
+#define	EADDRINUSE	98	/* Address already in use */
+#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
+#define	ENETDOWN	100	/* Network is down */
+#define	ENETUNREACH	101	/* Network is unreachable */
+#define	ENETRESET	102	/* Network dropped connection because of reset */
+#define	ECONNABORTED	103	/* Software caused connection abort */
+#define	ECONNRESET	104	/* Connection reset by peer */
+#define	ENOBUFS		105	/* No buffer space available */
+#define	EISCONN		106	/* Transport endpoint is already connected */
+#define	ENOTCONN	107	/* Transport endpoint is not connected */
+#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
+#define	ETIMEDOUT	110	/* Connection timed out */
+#define	ECONNREFUSED	111	/* Connection refused */
+#define	EHOSTDOWN	112	/* Host is down */
+#define	EHOSTUNREACH	113	/* No route to host */
+#define	EALREADY	114	/* Operation already in progress */
+#define	EINPROGRESS	115	/* Operation now in progress */
+#define	ESTALE		116	/* Stale NFS file handle */
+#define	EUCLEAN		117	/* Structure needs cleaning */
+#define	ENOTNAM		118	/* Not a XENIX named type file */
+#define	ENAVAIL		119	/* No XENIX semaphores available */
+#define	EISNAM		120	/* Is a named type file */
+#define	EREMOTEIO	121	/* Remote I/O error */
+#define	EDQUOT		122	/* Quota exceeded */
+
+#define	ENOMEDIUM	123	/* No medium found */
+#define	EMEDIUMTYPE	124	/* Wrong medium type */
+
+/* Should never be seen by user programs */
+#define ERESTARTSYS	512
+#define ERESTARTNOINTR	513
+#define ERESTARTNOHAND	514	/* restart if no handler.. */
+#define ENOIOCTLCMD	515	/* No ioctl command */
+
+#define _LAST_ERRNO	515
+
+#endif
+
--- /dev/null
+++ b/include/asm-mips/ifx_asc.h
@@ -0,0 +1,220 @@
+/*****************************************************************************
+ * DANUBE BootROM
+ * Copyright (c) 2005, Infineon Technologies AG, All rights reserved
+ * IFAP DC COM SD
+ *****************************************************************************/
+#ifndef __ASC_H
+#define __ASC_H
+
+#define DANUBEASC_TXFIFO_FL       		1
+#define DANUBEASC_RXFIFO_FL       		1
+#define DANUBEASC_TXFIFO_FULL     		16
+
+/* channel operating modes */
+#define	ASCOPT_CSIZE	0x00000003
+#define	ASCOPT_CS7	0x00000001
+#define	ASCOPT_CS8	0x00000002
+#define	ASCOPT_PARENB	0x00000004
+#define	ASCOPT_STOPB	0x00000008
+#define	ASCOPT_PARODD	0x00000010
+#define	ASCOPT_CREAD	0x00000020
+
+#define ASC_OPTIONS		(ASCOPT_CREAD | ASCOPT_CS8)
+
+/* ASC input select (0 or 1) */
+#define CONSOLE_TTY	0
+
+#define DANUBEASC_TXFIFO_FL       1
+#define DANUBEASC_RXFIFO_FL       1
+#define DANUBEASC_TXFIFO_FULL     16
+
+/* interrupt lines masks for the ASC device interrupts*/
+/* change these macroses if it's necessary */
+#define DANUBEASC_IRQ_LINE_ALL        0x0000007f  /* all IRQs */
+
+#define DANUBEASC_IRQ_LINE_TIR            0x00000001      /* Tx Int */
+#define DANUBEASC_IRQ_LINE_TBIR           0x00000002      /* Tx Buffer Int */
+#define DANUBEASC_IRQ_LINE_RIR            0x00000004      /* Rx Int */
+#define DANUBEASC_IRQ_LINE_EIR            0x00000008      /* Error Int */
+#define DANUBEASC_IRQ_LINE_ABSTIR         0x00000010      /* Autobaud Start Int */
+#define DANUBEASC_IRQ_LINE_ABDETIP        0x00000020      /* Autobaud Detection Int */
+#define DANUBEASC_IRQ_LINE_SFCIR          0x00000040      /* Software Flow Control Int */
+
+/* interrupt controller access macros */
+#define ASC_INTERRUPTS_ENABLE(X)  \
+*((volatile unsigned int*) DANUBE_ICU_IM0_IER) |= X;
+#define ASC_INTERRUPTS_DISABLE(X) \
+*((volatile unsigned int*) DANUBE_ICU_IM0_IER) &= ~X;
+#define ASC_INTERRUPTS_CLEAR(X)   \
+*((volatile unsigned int*) DANUBE_ICU_IM0_ISR) = X;
+
+/* CLC register's bits and bitfields */
+#define ASCCLC_DISR        0x00000001
+#define ASCCLC_DISS        0x00000002
+#define ASCCLC_RMCMASK     0x0000FF00
+#define ASCCLC_RMCOFFSET   8
+
+/* CON register's bits and bitfields */
+#define ASCCON_MODEMASK	0x0000000f
+#define ASCCON_M_8ASYNC	0x0
+#define ASCCON_M_8IRDA 	0x1
+#define ASCCON_M_7ASYNC	0x2
+#define ASCCON_M_7IRDA 	0x3
+#define ASCCON_WLSMASK 	0x0000000c
+#define ASCCON_WLSOFFSET	2
+#define ASCCON_WLS_8BIT	0x0
+#define ASCCON_WLS_7BIT	0x1
+#define ASCCON_PEN     	0x00000010
+#define ASCCON_ODD     	0x00000020
+#define ASCCON_SP      	0x00000040
+#define ASCCON_STP     	0x00000080
+#define ASCCON_BRS     	0x00000100
+#define ASCCON_FDE     	0x00000200
+#define ASCCON_ERRCLK  	0x00000400
+#define ASCCON_EMMASK  	0x00001800
+#define ASCCON_EMOFFSET	11
+#define ASCCON_EM_ECHO_OFF	0x0
+#define ASCCON_EM_ECHO_AB	0x1
+#define ASCCON_EM_ECHO_ON	0x2
+#define ASCCON_LB       	0x00002000
+#define ASCCON_ACO      	0x00004000
+#define ASCCON_R        	0x00008000
+#define ASCCON_PAL      	0x00010000
+#define ASCCON_FEN      	0x00020000
+#define ASCCON_RUEN     	0x00040000
+#define ASCCON_ROEN     	0x00080000
+#define ASCCON_TOEN     	0x00100000
+#define ASCCON_BEN      	0x00200000
+#define ASCCON_TXINV    	0x01000000
+#define ASCCON_RXINV    	0x02000000
+#define ASCCON_TXMSB    	0x04000000
+#define ASCCON_RXMSB    	0x08000000
+
+/* STATE register's bits and bitfields */
+#define ASCSTATE_REN     	0x00000001
+#define ASCSTATE_PE      	0x00010000
+#define ASCSTATE_FE      	0x00020000
+#define ASCSTATE_RUE     	0x00040000
+#define ASCSTATE_ROE     	0x00080000
+#define ASCSTATE_TOE     	0x00100000
+#define ASCSTATE_BE      	0x00200000
+#define ASCSTATE_TXBVMASK	0x07000000
+#define ASCSTATE_TXBVOFFSET	24
+#define ASCSTATE_TXEOM     	0x08000000
+#define ASCSTATE_RXBVMASK	0x70000000
+#define ASCSTATE_RXBVOFFSET	28
+#define ASCSTATE_RXEOM     	0x80000000
+
+/* WHBSTATE register's bits and bitfields */
+#define ASCWHBSTATE_CLRREN    0x00000001
+#define ASCWHBSTATE_SETREN    0x00000002
+#define ASCWHBSTATE_CLRPE     0x00000004
+#define ASCWHBSTATE_CLRFE     0x00000008
+#define ASCWHBSTATE_CLRRUE    0x00000010
+#define ASCWHBSTATE_CLRROE    0x00000020
+#define ASCWHBSTATE_CLRTOE    0x00000040
+#define ASCWHBSTATE_CLRBE     0x00000080
+#define ASCWHBSTATE_SETPE     0x00000100
+#define ASCWHBSTATE_SETFE     0x00000200
+#define ASCWHBSTATE_SETRUE    0x00000400
+#define ASCWHBSTATE_SETROE    0x00000800
+#define ASCWHBSTATE_SETTOE    0x00001000
+#define ASCWHBSTATE_SETBE     0x00002000
+
+/* ABCON register's bits and bitfields */
+#define ASCABCON_ABEN       0x0001
+#define ASCABCON_AUREN      0x0002
+#define ASCABCON_ABSTEN     0x0004
+#define ASCABCON_ABDETEN    0x0008
+#define ASCABCON_FCDETEN    0x0010
+
+/* FDV register mask, offset and bitfields*/
+#define ASCFDV_VALUE_MASK     0x000001FF
+
+/* WHBABCON register's bits and bitfields */
+#define ASCWHBABCON_CLRABEN     0x0001
+#define ASCWHBABCON_SETABEN     0x0002
+
+/* ABSTAT register's bits and bitfields */
+#define ASCABSTAT_FCSDET    0x0001
+#define ASCABSTAT_FCCDET    0x0002
+#define ASCABSTAT_SCSDET    0x0004
+#define ASCABSTAT_SCCDET    0x0008
+#define ASCABSTAT_DETWAIT   0x0010
+
+/* WHBABSTAT register's bits and bitfields */
+#define ASCWHBABSTAT_CLRFCSDET  0x0001
+#define ASCWHBABSTAT_SETFCSDET  0x0002
+#define ASCWHBABSTAT_CLRFCCDET  0x0004
+#define ASCWHBABSTAT_SETFCCDET  0x0008
+#define ASCWHBABSTAT_CLRSCSDET  0x0010
+#define ASCWHBABSTAT_SETSCSDET  0x0020
+#define ASCWHBABSTAT_CLRSCCDET  0x0040
+#define ASCWHBABSTAT_SETSCCDET  0x0080
+#define ASCWHBABSTAT_CLRDETWAIT 0x0100
+#define ASCWHBABSTAT_SETDETWAIT 0x0200
+
+/* TXFCON register's bits and bitfields */
+#define ASCTXFCON_TXFIFO1       0x00000400
+#define ASCTXFCON_TXFEN         0x0001
+#define ASCTXFCON_TXFFLU        0x0002
+#define ASCTXFCON_TXFITLMASK    0x3F00
+#define ASCTXFCON_TXFITLOFF     8
+
+/* RXFCON register's bits and bitfields */
+#define ASCRXFCON_RXFIFO1       0x00000400
+#define ASCRXFCON_RXFEN         0x0001
+#define ASCRXFCON_RXFFLU        0x0002
+#define ASCRXFCON_RXFITLMASK    0x3F00
+#define ASCRXFCON_RXFITLOFF     8
+
+/* FSTAT register's bits and bitfields */
+#define ASCFSTAT_RXFFLMASK      0x003F
+#define ASCFSTAT_TXFFLMASK      0x3F00
+#define ASCFSTAT_TXFFLOFF       8
+
+typedef  struct         /* DanubeAsc_t */
+{
+	volatile unsigned long  asc_clc;                            /*0x0000*/
+	volatile unsigned long  asc_pisel;                          /*0x0004*/
+	volatile unsigned long  asc_id;                             /*0x0008*/
+	volatile unsigned long  asc_rsvd1[1];   /* for mapping */   /*0x000C*/
+	volatile unsigned long  asc_con;                           /*0x0010*/
+	volatile unsigned long  asc_state;                          /*0x0014*/
+	volatile unsigned long  asc_whbstate;                       /*0x0018*/
+	volatile unsigned long  asc_rsvd2[1];   /* for mapping */   /*0x001C*/
+	volatile unsigned long  asc_tbuf;                           /*0x0020*/
+	volatile unsigned long  asc_rbuf;                           /*0x0024*/
+	volatile unsigned long  asc_rsvd3[2];   /* for mapping */   /*0x0028*/
+	volatile unsigned long  asc_abcon;                          /*0x0030*/
+	volatile unsigned long  asc_abstat;     /* not used */      /*0x0034*/
+	volatile unsigned long  asc_whbabcon;                       /*0x0038*/
+	volatile unsigned long  asc_whbabstat;  /* not used */      /*0x003C*/
+	volatile unsigned long  asc_rxfcon;                         /*0x0040*/
+	volatile unsigned long  asc_txfcon;                         /*0x0044*/
+	volatile unsigned long  asc_fstat;                          /*0x0048*/
+	volatile unsigned long  asc_rsvd4[1];   /* for mapping */   /*0x004C*/
+	volatile unsigned long  asc_bg;                             /*0x0050*/
+	volatile unsigned long  asc_bg_timer;                       /*0x0054*/
+	volatile unsigned long  asc_fdv;                            /*0x0058*/
+	volatile unsigned long  asc_pmw;                            /*0x005C*/
+	volatile unsigned long  asc_modcon;                         /*0x0060*/
+	volatile unsigned long  asc_modstat;                        /*0x0064*/
+	volatile unsigned long  asc_rsvd5[2];   /* for mapping */   /*0x0068*/
+	volatile unsigned long  asc_sfcc;                           /*0x0070*/
+	volatile unsigned long  asc_rsvd6[3];   /* for mapping */   /*0x0074*/
+	volatile unsigned long  asc_eomcon;                         /*0x0080*/
+	volatile unsigned long  asc_rsvd7[26];   /* for mapping */  /*0x0084*/
+	volatile unsigned long  asc_dmacon;                         /*0x00EC*/
+	volatile unsigned long  asc_rsvd8[1];   /* for mapping */   /*0x00F0*/
+	volatile unsigned long  asc_irnen;                          /*0x00F4*/
+	volatile unsigned long  asc_irnicr;                         /*0x00F8*/
+	volatile unsigned long  asc_irncr;                          /*0x00FC*/
+} DanubeAsc_t;
+
+int asc_init (void);
+void asc_puts (const char *s);
+void asc_putc (const char c);
+int asc_getc (void);
+
+#endif /* __ASC_H */
--- /dev/null
+++ b/include/asm-mips/ifx_mips.h
@@ -0,0 +1,2427 @@
+#ifndef AMAZON_SE_H
+#define AMAZON_SE_H
+/******************************************************************************
+       Copyright (c) 2002, Infineon Technologies.  All rights reserved.
+
+                               No Warranty
+   Because the program is licensed free of charge, there is no warranty for
+   the program, to the extent permitted by applicable law.  Except when
+   otherwise stated in writing the copyright holders and/or other parties
+   provide the program "as is" without warranty of any kind, either
+   expressed or implied, including, but not limited to, the implied
+   warranties of merchantability and fitness for a particular purpose. The
+   entire risk as to the quality and performance of the program is with
+   you.  should the program prove defective, you assume the cost of all
+   necessary servicing, repair or correction.
+
+   In no event unless required by applicable law or agreed to in writing
+   will any copyright holder, or any other party who may modify and/or
+   redistribute the program as permitted above, be liable to you for
+   damages, including any general, special, incidental or consequential
+   damages arising out of the use or inability to use the program
+   (including but not limited to loss of data or data being rendered
+   inaccurate or losses sustained by you or third parties or a failure of
+   the program to operate with any other programs), even if such holder or
+   other party has been advised of the possibility of such damages.
+******************************************************************************/
+
+/***********************************************************************/
+/*  Module      :  WDT register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_BIU_WDT                           (KSEG1+0x1F880000)
+
+/***Watchdog Timer Control Register ***/
+#define AMAZON_SE_BIU_WDT_CR                   ((volatile u32*)(AMAZON_SE_BIU_WDT + 0x03F0))
+#define AMAZON_SE_BIU_WDT_CR_GEN               (1 << 31)
+#define AMAZON_SE_BIU_WDT_CR_DSEN              (1 << 30)
+#define AMAZON_SE_BIU_WDT_CR_LPEN              (1 << 29)
+#define AMAZON_SE_BIU_WDT_CR_PWL_GET(value)    (((value) >> 26) & ((1 << 2) - 1))
+#define AMAZON_SE_BIU_WDT_CR_PWL_SET(value)    (((( 1 << 2) - 1) & (value)) << 26)
+#define AMAZON_SE_BIU_WDT_CR_CLKDIV_GET(value) (((value) >> 24) & ((1 << 2) - 1))
+#define AMAZON_SE_BIU_WDT_CR_CLKDIV_SET(value) (((( 1 << 2) - 1) & (value)) << 24)
+#define AMAZON_SE_BIU_WDT_CR_PW_GET(value)     (((value) >> 16) & ((1 << 8) - 1))
+#define AMAZON_SE_BIU_WDT_CR_PW_SET(value)     (((( 1 << 8) - 1) & (value)) << 16)
+#define AMAZON_SE_BIU_WDT_CR_RELOAD_GET(value) (((value) >> 0) & ((1 << 16) - 1))
+#define AMAZON_SE_BIU_WDT_CR_RELOAD_SET(value) (((( 1 << 16) - 1) & (value)) << 0)
+
+/***Watchdog Timer Status Register***/
+#define AMAZON_SE_BIU_WDT_SR                   ((volatile u32*)(AMAZON_SE_BIU_WDT + 0x03F8))
+#define AMAZON_SE_BIU_WDT_SR_EN                (1 << 31)
+#define AMAZON_SE_BIU_WDT_SR_AE                (1 << 30)
+#define AMAZON_SE_BIU_WDT_SR_PRW               (1 << 29)
+#define AMAZON_SE_BIU_WDT_SR_EXP               (1 << 28)
+#define AMAZON_SE_BIU_WDT_SR_PWD               (1 << 27)
+#define AMAZON_SE_BIU_WDT_SR_DS                (1 << 26)
+#define AMAZON_SE_BIU_WDT_SR_VALUE_GET(value)  (((value) >> 0) & ((1 << 16) - 1))
+#define AMAZON_SE_BIU_WDT_SR_VALUE_SET(value)  (((( 1 << 16) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  PMU register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_PMU 			        (KSEG1+0x1F102000)
+
+/* PMU Power down Control Register */
+#define AMAZON_SE_PMU_PWDCR                        ((volatile u32*)(AMAZON_SE_PMU+0x001C))
+
+/* PMU Status Register */
+#define AMAZON_SE_PMU_SR                           ((volatile u32*)(AMAZON_SE_PMU+0x0020))
+
+#define AMAZON_SE_PMU_DMA_SHIFT                    5
+#define AMAZON_SE_PMU_PPE_SHIFT                    13
+#define AMAZON_SE_PMU_SDIO_SHIFT                   16
+#define AMAZON_SE_PMU_ETOP_SHIFT                   22
+#define AMAZON_SE_PMU_ENET0_SHIFT                  24
+#define AMAZON_SE_PMU_ENET1_SHIFT                  25
+
+/***********************************************************************/
+/*  Module      :  RCU register address and bits                       */
+/***********************************************************************/
+#define AMAZON_SE_RCU_BASE_ADDR 		(0xBF203000)
+
+#define AMAZON_SE_RCU_REQ 			(0x0010 + AMAZON_SE_RCU_BASE_ADDR) /* will remove this, pls use AMAZON_SE_RCU_RST_REQ */
+
+#define AMAZON_SE_RCU_RST_REQ              ((volatile u32*)(AMAZON_SE_RCU_BASE_ADDR + 0x0010))
+#define AMAZON_SE_RCU_RST_STAT             ((volatile u32*)(AMAZON_SE_RCU_BASE_ADDR + 0x0014))
+#define AMAZON_SE_RST_ALL                  (0x40000000)
+
+/***Reset Request Register***/
+#define AMAZON_SE_RCU_RST_REQ_CPU0                 (1 << 31)
+#define AMAZON_SE_RCU_RST_REQ_CPU1                 (1 << 3)
+#define AMAZON_SE_RCU_RST_REQ_CPUSUB               (1 << 29)
+#define AMAZON_SE_RCU_RST_REQ_HRST                 (1 << 28)
+#define AMAZON_SE_RCU_RST_REQ_WDT0                 (1 << 27)
+#define AMAZON_SE_RCU_RST_REQ_WDT1                 (1 << 26)
+#define AMAZON_SE_RCU_RST_REQ_CFG_GET(value)       (((value) >> 23) & ((1 << 3) - 1))
+#define AMAZON_SE_RCU_RST_REQ_CFG_SET(value)       (((( 1 << 3) - 1) & (value)) << 23)
+#define AMAZON_SE_RCU_RST_REQ_SWTBOOT              (1 << 22)
+#define AMAZON_SE_RCU_RST_REQ_DMA                  (1 << 21)
+#define AMAZON_SE_RCU_RST_REQ_ARC_JTAG              (1 << 20)
+#define AMAZON_SE_RCU_RST_REQ_ETHPHY0              (1 << 19)
+#define AMAZON_SE_RCU_RST_REQ_CPU0_BR              (1 << 18)
+
+#define DANBUE_RCU_RST_REQ_AFE			(1 << 11)
+#define DANBUE_RCU_RST_REQ_DFE			(1 << 7)
+
+/* CPU0, CPU1, CPUSUB, HRST, WDT0, WDT1, DMA, ETHPHY1, ETHPHY0 */
+#define AMAZON_SE_RCU_RST_REQ_ALL                  AMAZON_SE_RST_ALL
+
+#define AMAZON_SE_RCU_STAT		        (0x0014 + AMAZON_SE_RCU_BASE_ADDR)
+#define AMAZON_SE_RCU_RST_SR	        ( (volatile u32 *)(AMAZON_SE_RCU_STAT))/* will remove this, pls use AMAZON_SE_RCU_RST_STAT */
+
+/*#define AMAZON_SE_RCU_MON                  (0x0030 + AMAZON_SE_RCU_BASE_ADDR) */
+
+/***********************************************************************/
+/*  Module      :  BCU  register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_BCU_BASE_ADDR 			(KSEG1+0x1E100000)
+
+/***BCU Control Register (0010H)***/
+#define AMAZON_SE_BCU_CON                          ((volatile u32*)(0x0010 + AMAZON_SE_BCU_BASE_ADDR))
+#define AMAZON_SE_BCU_BCU_CON_SPC (value)                (((( 1 << 8) - 1) & (value)) << 24)
+#define AMAZON_SE_BCU_BCU_CON_SPE                              (1 << 19)
+#define AMAZON_SE_BCU_BCU_CON_PSE                              (1 << 18)
+#define AMAZON_SE_BCU_BCU_CON_DBG                              (1 << 16)
+#define AMAZON_SE_BCU_BCU_CON_TOUT (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+
+/***BCU Error Control Capture Register (0020H)***/
+#define AMAZON_SE_BCU_ECON                         ((volatile u32*)(0x0020 + AMAZON_SE_BCU_BASE_ADDR))
+#define AMAZON_SE_BCU_BCU_ECON_TAG (value)                (((( 1 << 4) - 1) & (value)) << 24)
+#define AMAZON_SE_BCU_BCU_ECON_RDN                              (1 << 23)
+#define AMAZON_SE_BCU_BCU_ECON_WRN                              (1 << 22)
+#define AMAZON_SE_BCU_BCU_ECON_SVM                              (1 << 21)
+#define AMAZON_SE_BCU_BCU_ECON_ACK (value)                (((( 1 << 2) - 1) & (value)) << 19)
+#define AMAZON_SE_BCU_BCU_ECON_ABT                              (1 << 18)
+#define AMAZON_SE_BCU_BCU_ECON_RDY                              (1 << 17)
+#define AMAZON_SE_BCU_BCU_ECON_TOUT                             (1 << 16)
+#define AMAZON_SE_BCU_BCU_ECON_ERRCNT (value)             (((( 1 << 16) - 1) & (value)) << 0)
+#define AMAZON_SE_BCU_BCU_ECON_OPC (value)                (((( 1 << 4) - 1) & (value)) << 28)
+
+/***BCU Error Address Capture Register (0024 H)***/
+#define AMAZON_SE_BCU_EADD 			((volatile u32*)(0x0024 + AMAZON_SE_BCU_BASE_ADDR))
+
+/***BCU Error Data Capture Register (0028H)***/
+#define AMAZON_SE_BCU_EDAT 			((volatile u32*)(0x0028 + AMAZON_SE_BCU_BASE_ADDR))
+#define AMAZON_SE_BCU_IRNEN 			((volatile u32*)(0x00F4 + AMAZON_SE_BCU_BASE_ADDR))
+#define AMAZON_SE_BCU_IRNICR 			((volatile u32*)(0x00F8 + AMAZON_SE_BCU_BASE_ADDR))
+#define AMAZON_SE_BCU_IRNCR 			((volatile u32*)(0x00FC + AMAZON_SE_BCU_BASE_ADDR))
+
+
+/***********************************************************************/
+/*  Module      :  MBC register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_MBC                          (0xBF103000)
+/***********************************************************************/
+
+
+/***Mailbox CPU Configuration Register***/
+#define AMAZON_SE_MBC_MBC_CFG                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0080))
+#define AMAZON_SE_MBC_MBC_CFG_SWAP (value)               (((( 1 << 2) - 1) & (value)) << 6)
+#define AMAZON_SE_MBC_MBC_CFG_RES                              (1 << 5)
+#define AMAZON_SE_MBC_MBC_CFG_FWID (value)               (((( 1 << 4) - 1) & (value)) << 1)
+#define AMAZON_SE_MBC_MBC_CFG_SIZE                            (1 << 0)
+
+/***Mailbox CPU Interrupt Status Register***/
+#define AMAZON_SE_MBC_MBC_ISR                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0084))
+#define AMAZON_SE_MBC_MBC_ISR_B3DA                            (1 << 31)
+#define AMAZON_SE_MBC_MBC_ISR_B2DA                            (1 << 30)
+#define AMAZON_SE_MBC_MBC_ISR_B1E                              (1 << 29)
+#define AMAZON_SE_MBC_MBC_ISR_B0E                              (1 << 28)
+#define AMAZON_SE_MBC_MBC_ISR_WDT                              (1 << 27)
+#define AMAZON_SE_MBC_MBC_ISR_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Mask Register***/
+#define AMAZON_SE_MBC_MBC_MSK                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0088))
+#define AMAZON_SE_MBC_MBC_MSK_B3DA                            (1 << 31)
+#define AMAZON_SE_MBC_MBC_MSK_B2DA                            (1 << 30)
+#define AMAZON_SE_MBC_MBC_MSK_B1E                              (1 << 29)
+#define AMAZON_SE_MBC_MBC_MSK_B0E                              (1 << 28)
+#define AMAZON_SE_MBC_MBC_MSK_WDT                              (1 << 27)
+#define AMAZON_SE_MBC_MBC_MSK_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Mask 01 Register***/
+#define AMAZON_SE_MBC_MBC_MSK01                    ((volatile u32*)(AMAZON_SE_MBC+ 0x008C))
+#define AMAZON_SE_MBC_MBC_MSK01_B3DA                            (1 << 31)
+#define AMAZON_SE_MBC_MBC_MSK01_B2DA                            (1 << 30)
+#define AMAZON_SE_MBC_MBC_MSK01_B1E                              (1 << 29)
+#define AMAZON_SE_MBC_MBC_MSK01_B0E                              (1 << 28)
+#define AMAZON_SE_MBC_MBC_MSK01_WDT                              (1 << 27)
+#define AMAZON_SE_MBC_MBC_MSK01_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Mask 10 Register***/
+#define AMAZON_SE_MBC_MBC_MSK10                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0090))
+#define AMAZON_SE_MBC_MBC_MSK10_B3DA                            (1 << 31)
+#define AMAZON_SE_MBC_MBC_MSK10_B2DA                            (1 << 30)
+#define AMAZON_SE_MBC_MBC_MSK10_B1E                              (1 << 29)
+#define AMAZON_SE_MBC_MBC_MSK10_B0E                              (1 << 28)
+#define AMAZON_SE_MBC_MBC_MSK10_WDT                              (1 << 27)
+#define AMAZON_SE_MBC_MBC_MSK10_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Short Command Register***/
+#define AMAZON_SE_MBC_MBC_CMD                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0094))
+#define AMAZON_SE_MBC_MBC_CMD_CS270 (value)             (((( 1 << 28) - 1) & (value)) << 0)
+
+/***Mailbox CPU Input Data of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_ID0                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0000))
+#define AMAZON_SE_MBC_MBC_ID0_INDATA
+
+/***Mailbox CPU Input Data of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_ID1                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0020))
+#define AMAZON_SE_MBC_MBC_ID1_INDATA
+
+/***Mailbox CPU Output Data of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_OD2                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0040))
+#define AMAZON_SE_MBC_MBC_OD2_OUTDATA
+
+/***Mailbox CPU Output Data of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_OD3                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0060))
+#define AMAZON_SE_MBC_MBC_OD3_OUTDATA
+
+/***Mailbox CPU Control Register of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_CR0                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0004))
+#define AMAZON_SE_MBC_MBC_CR0_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Control Register of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_CR1                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0024))
+#define AMAZON_SE_MBC_MBC_CR1_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Control Register of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_CR2                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0044))
+#define AMAZON_SE_MBC_MBC_CR2_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Control Register of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_CR3                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0064))
+#define AMAZON_SE_MBC_MBC_CR3_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Free Space of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_FS0                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0008))
+#define AMAZON_SE_MBC_MBC_FS0_FS
+
+/***Mailbox CPU Free Space of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_FS1                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0028))
+#define AMAZON_SE_MBC_MBC_FS1_FS
+
+/***Mailbox CPU Free Space of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_FS2                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0048))
+#define AMAZON_SE_MBC_MBC_FS2_FS
+
+/***Mailbox CPU Free Space of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_FS3                      ((volatile u32*)(AMAZON_SE_MBC+ 0x0068))
+#define AMAZON_SE_MBC_MBC_FS3_FS
+
+/***Mailbox CPU Data Available in Buffer 0***/
+#define AMAZON_SE_MBC_MBC_DA0                      ((volatile u32*)(AMAZON_SE_MBC+ 0x000C))
+#define AMAZON_SE_MBC_MBC_DA0_DA
+
+/***Mailbox CPU Data Available in Buffer 1***/
+#define AMAZON_SE_MBC_MBC_DA1                      ((volatile u32*)(AMAZON_SE_MBC+ 0x002C))
+#define AMAZON_SE_MBC_MBC_DA1_DA
+
+/***Mailbox CPU Data Available in Buffer 2***/
+#define AMAZON_SE_MBC_MBC_DA2                      ((volatile u32*)(AMAZON_SE_MBC+ 0x004C))
+#define AMAZON_SE_MBC_MBC_DA2_DA
+
+/***Mailbox CPU Data Available in Buffer 3***/
+#define AMAZON_SE_MBC_MBC_DA3                      ((volatile u32*)(AMAZON_SE_MBC+ 0x006C))
+#define AMAZON_SE_MBC_MBC_DA3_DA
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_IABS0                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0010))
+#define AMAZON_SE_MBC_MBC_IABS0_IABS
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_IABS1                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0030))
+#define AMAZON_SE_MBC_MBC_IABS1_IABS
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_IABS2                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0050))
+#define AMAZON_SE_MBC_MBC_IABS2_IABS
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_IABS3                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0070))
+#define AMAZON_SE_MBC_MBC_IABS3_IABS
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_ITMP0                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0014))
+#define AMAZON_SE_MBC_MBC_ITMP0_ITMP
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_ITMP1                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0034))
+#define AMAZON_SE_MBC_MBC_ITMP1_ITMP
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_ITMP2                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0054))
+#define AMAZON_SE_MBC_MBC_ITMP2_ITMP
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_ITMP3                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0074))
+#define AMAZON_SE_MBC_MBC_ITMP3_ITMP
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_OABS0                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0018))
+#define AMAZON_SE_MBC_MBC_OABS0_OABS
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_OABS1                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0038))
+#define AMAZON_SE_MBC_MBC_OABS1_OABS
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_OABS2                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0058))
+#define AMAZON_SE_MBC_MBC_OABS2_OABS
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_OABS3                    ((volatile u32*)(AMAZON_SE_MBC+ 0x0078))
+#define AMAZON_SE_MBC_MBC_OABS3_OABS
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 0***/
+#define AMAZON_SE_MBC_MBC_OTMP0                    ((volatile u32*)(AMAZON_SE_MBC+ 0x001C))
+#define AMAZON_SE_MBC_MBC_OTMP0_OTMP
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 1***/
+#define AMAZON_SE_MBC_MBC_OTMP1                    ((volatile u32*)(AMAZON_SE_MBC+ 0x003C))
+#define AMAZON_SE_MBC_MBC_OTMP1_OTMP
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 2***/
+#define AMAZON_SE_MBC_MBC_OTMP2                    ((volatile u32*)(AMAZON_SE_MBC+ 0x005C))
+#define AMAZON_SE_MBC_MBC_OTMP2_OTMP
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 3***/
+#define AMAZON_SE_MBC_MBC_OTMP3                    ((volatile u32*)(AMAZON_SE_MBC+ 0x007C))
+#define AMAZON_SE_MBC_MBC_OTMP3_OTMP
+
+/***DSP Control Register***/
+#define AMAZON_SE_MBC_DCTRL                        ((volatile u32*)(AMAZON_SE_MBC+ 0x00A0))
+#define AMAZON_SE_MBC_DCTRL_BA                              (1 << 0)
+#define AMAZON_SE_MBC_DCTRL_BMOD (value)               (((( 1 << 3) - 1) & (value)) << 1)
+#define AMAZON_SE_MBC_DCTRL_IDL                              (1 << 4)
+#define AMAZON_SE_MBC_DCTRL_RES                              (1 << 15)
+
+/***DSP Status Register***/
+#define AMAZON_SE_MBC_DSTA                         ((volatile u32*)(AMAZON_SE_MBC+ 0x00A4))
+#define AMAZON_SE_MBC_DSTA_IDLE                            (1 << 0)
+#define AMAZON_SE_MBC_DSTA_PD                              (1 << 1)
+
+/***DSP Test 1 Register***/
+#define AMAZON_SE_MBC_DTST1                        ((volatile u32*)(AMAZON_SE_MBC+ 0x00A8))
+#define AMAZON_SE_MBC_DTST1_ABORT                          (1 << 0)
+#define AMAZON_SE_MBC_DTST1_HWF32                          (1 << 1)
+#define AMAZON_SE_MBC_DTST1_HWF4M                          (1 << 2)
+#define AMAZON_SE_MBC_DTST1_HWFOP                          (1 << 3)
+
+
+/***********************************************************************/
+/*  Module      :  MEI register address and bits                       */
+/***********************************************************************/
+#define MEI_SPACE_ACCESS	0xBE116000
+
+/***	Register address offsets, relative to MEI_SPACE_ADDRESS ***/
+#define MEI_DATA_XFR				((volatile u32*)(0x0000 + MEI_SPACE_ACCESS))
+#define	MEI_VERSION				((volatile u32*)(0x0004 + MEI_SPACE_ACCESS))
+#define	MEI_ARC_GP_STAT				((volatile u32*)(0x0008 + MEI_SPACE_ACCESS))
+#define MEI_DATA_XFR_STAT			((volatile u32*)(0x000C + MEI_SPACE_ACCESS))
+#define	MEI_XFR_ADDR				((volatile u32*)(0x0010 + MEI_SPACE_ACCESS))
+#define MEI_MAX_WAIT				((volatile u32*)(0x0014 + MEI_SPACE_ACCESS))
+#define	MEI_TO_ARC_INT				((volatile u32*)(0x0018 + MEI_SPACE_ACCESS))
+#define	ARC_TO_MEI_INT				((volatile u32*)(0x001C + MEI_SPACE_ACCESS))
+#define	ARC_TO_MEI_INT_MASK			((volatile u32*)(0x0020 + MEI_SPACE_ACCESS))
+#define	MEI_DEBUG_WAD				((volatile u32*)(0x0024 + MEI_SPACE_ACCESS))
+#define MEI_DEBUG_RAD				((volatile u32*)(0x0028 + MEI_SPACE_ACCESS))
+#define	MEI_DEBUG_DATA				((volatile u32*)(0x002C + MEI_SPACE_ACCESS))
+#define	MEI_DEBUG_DEC				((volatile u32*)(0x0030 + MEI_SPACE_ACCESS))
+#define MEI_CONFIG				((volatile u32*)(0x0034 + MEI_SPACE_ACCESS))
+#define	MEI_RST_CONTROL				((volatile u32*)(0x0038 + MEI_SPACE_ACCESS))
+#define	MEI_DBG_MASTER				((volatile u32*)(0x003C + MEI_SPACE_ACCESS))
+#define	MEI_CLK_CONTROL				((volatile u32*)(0x0040 + MEI_SPACE_ACCESS))
+#define	MEI_BIST_CONTROL			((volatile u32*)(0x0044 + MEI_SPACE_ACCESS))
+#define	MEI_BIST_STAT				((volatile u32*)(0x0048 + MEI_SPACE_ACCESS))
+#define MEI_XDATA_BASE_SH			((volatile u32*)(0x004c + MEI_SPACE_ACCESS))
+#define MEI_XDATA_BASE				((volatile u32*)(0x0050 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR_BASE			((volatile u32*)(0x0054 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR0				((volatile u32*)(0x0054 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR1				((volatile u32*)(0x0058 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR2				((volatile u32*)(0x005C + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR3				((volatile u32*)(0x0060 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR4				((volatile u32*)(0x0064 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR5				((volatile u32*)(0x0068 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR6				((volatile u32*)(0x006C + MEI_SPACE_ACCESS)))
+#define MEI_XMEM_BAR7				((volatile u32*)(0x0070 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR8				((volatile u32*)(0x0074 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR9				((volatile u32*)(0x0078 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR10				((volatile u32*)(0x007C + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR11				((volatile u32*)(0x0080 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR12				((volatile u32*)(0x0084 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR13				((volatile u32*)(0x0088 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR14				((volatile u32*)(0x008C + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR15				((volatile u32*)(0x0090 + MEI_SPACE_ACCESS))
+#define MEI_XMEM_BAR16				((volatile u32*)(0x0094 + MEI_SPACE_ACCESS))
+
+
+/***********************************************************************/
+/*  Module      :  SSC1 register address and bits                      */
+/***********************************************************************/
+
+#define AMAZON_SE_SSC1                       	(KSEG1+0x1e100800)
+/***********************************************************************/
+/***SSC Clock Control Register***/
+#define AMAZON_SE_SSC_CLC                      	(0x0000)
+#define AMAZON_SE_SSC_CLC_RMC(value)               (((( 1 << 8) - 1) & (value)) << 8)
+#define AMAZON_SE_SSC_CLC_DISS                     (1 << 1)
+#define AMAZON_SE_SSC_CLC_DISR                     (1 << 0)
+/***SSC Port Input Selection Register***/
+#define AMAZON_SE_SSC_PISEL                        (0x0004)
+/***SSC Identification Register***/
+#define AMAZON_SE_SSC_ID                           (0x0008)
+/***Control Register (Programming Mode)***/
+#define AMAZON_SE_SSC_CON                  		(0x0010)
+#define AMAZON_SE_SSC_CON_RUEN                            (1 << 12)
+#define AMAZON_SE_SSC_CON_TUEN                              (1 << 11)
+#define AMAZON_SE_SSC_CON_AEN                              (1 << 10)
+#define AMAZON_SE_SSC_CON_REN                              (1 << 9)
+#define AMAZON_SE_SSC_CON_TEN                              (1 << 8)
+#define AMAZON_SE_SSC_CON_LB                              (1 << 7)
+#define AMAZON_SE_SSC_CON_PO                              (1 << 6)
+#define AMAZON_SE_SSC_CON_PH                              (1 << 5)
+#define AMAZON_SE_SSC_CON_HB                              (1 << 4)
+#define AMAZON_SE_SSC_CON_BM(value)                	(((( 1 << 5) - 1) & (value)) << 16)
+#define AMAZON_SE_SSC_CON_RX_OFF                          (1 << 1)
+#define AMAZON_SE_SSC_CON_TX_OFF                          (1 << 0)
+/***SCC Status Register***/
+#define AMAZON_SE_SSC_STATE                  (0x0014)
+#define AMAZON_SE_SSC_STATE_EN                              (1 << 0)
+#define AMAZON_SE_SSC_STATE_MS                              (1 << 1)
+#define AMAZON_SE_SSC_STATE_BSY                              (1 << 13)
+#define AMAZON_SE_SSC_STATE_RUE                              (1 << 12)
+#define AMAZON_SE_SSC_STATE_TUE                              (1 << 11)
+#define AMAZON_SE_SSC_STATE_AE                              (1 << 10)
+#define AMAZON_SE_SSC_STATE_RE                              (1 << 9)
+#define AMAZON_SE_SSC_STATE_TE                              (1 << 8)
+#define AMAZON_SE_SSC_STATE_BC(value)                (((( 1 << 5) - 1) & (value)) << 16)
+/***SSC Write Hardware Modified Control Register***/
+#define AMAZON_SE_SSC_WHBSTATE                   ( 0x0018)
+#define AMAZON_SE_SSC_WHBSTATE_SETBE                          (1 << 15)
+#define AMAZON_SE_SSC_WHBSTATE_SETPE                          (1 << 14)
+#define AMAZON_SE_SSC_WHBSTATE_SETRE                          (1 << 13)
+#define AMAZON_SE_SSC_WHBSTATE_SETTE                          (1 << 12)
+#define AMAZON_SE_SSC_WHBSTATE_CLRBE                          (1 << 11)
+#define AMAZON_SE_SSC_WHBSTATE_CLRPE                          (1 << 10)
+#define AMAZON_SE_SSC_WHBSTATE_CLRRE                          (1 << 9)
+#define AMAZON_SE_SSC_WHBSTATE_CLRTE                          (1 << 8)
+/***SSC Transmitter Buffer Register***/
+#define AMAZON_SE_SSC_TB                       (0x0020)
+#define AMAZON_SE_SSC_TB_TB_VALUE(value)          (((( 1 << 16) - 1) & (value)) << 0)
+/***SSC Receiver Buffer Register***/
+#define AMAZON_SE_SSC_RB                       (0x0024)
+#define AMAZON_SE_SSC_RB_RB_VALUE(value)          (((( 1 << 16) - 1) & (value)) << 0)
+/***SSC Receive FIFO Control Register***/
+#define AMAZON_SE_SSC_RXFCON                   (0x0030)
+#define AMAZON_SE_SSC_RXFCON_RXFITL(value)             (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_SSC_RXFCON_RXTMEN                        (1 << 2)
+#define AMAZON_SE_SSC_RXFCON_RXFLU                          (1 << 1)
+#define AMAZON_SE_SSC_RXFCON_RXFEN                          (1 << 0)
+/***SSC Transmit FIFO Control Register***/
+#define AMAZON_SE_SSC_TXFCON                   ( 0x0034)
+#define AMAZON_SE_SSC_TXFCON_RXFITL(value)             (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_SSC_TXFCON_TXTMEN                        (1 << 2)
+#define AMAZON_SE_SSC_TXFCON_TXFLU                          (1 << 1)
+#define AMAZON_SE_SSC_TXFCON_TXFEN                          (1 << 0)
+/***SSC FIFO Status Register***/
+#define AMAZON_SE_SSC_FSTAT                    (0x0038)
+#define AMAZON_SE_SSC_FSTAT_TXFFL(value)              (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_SSC_FSTAT_RXFFL(value)              (((( 1 << 6) - 1) & (value)) << 0)
+/***SSC Baudrate Timer Reload Register***/
+#define AMAZON_SE_SSC_BR                       (0x0040)
+#define AMAZON_SE_SSC_BR_BR_VALUE(value)          (((( 1 << 16) - 1) & (value)) << 0)
+#define AMAZON_SE_SSC_BRSTAT                       (0x0044)
+#define AMAZON_SE_SSC_SFCON                        (0x0060)
+#define AMAZON_SE_SSC_SFSTAT                       (0x0064)
+#define AMAZON_SE_SSC_GPOCON                       (0x0070)
+#define AMAZON_SE_SSC_GPOSTAT                      (0x0074)
+#define AMAZON_SE_SSC_WHBGPOSTAT                   (0x0078)
+#define AMAZON_SE_SSC_RXREQ                        (0x0080)
+#define AMAZON_SE_SSC_RXCNT                        (0x0084)
+/*DMA Registers in Bus Clock Domain*/
+#define AMAZON_SE_SSC_DMA_CON                      (0x00EC)
+/*interrupt Node Registers in Bus Clock Domain*/
+#define AMAZON_SE_SSC_IRNEN                        (0x00F4)
+#define AMAZON_SE_SSC_IRNCR                        (0x00F8)
+#define AMAZON_SE_SSC_IRNICR                       (0x00FC)
+#define AMAZON_SE_SSC_IRN_FIR			0x8
+#define AMAZON_SE_SSC_IRN_EIR			0x4
+#define AMAZON_SE_SSC_IRN_RIR			0x2
+#define AMAZON_SE_SSC_IRN_TIR			0x1
+
+
+#define	AMAZON_SE_SSC1_CLC			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_CLC))
+#define	AMAZON_SE_SSC1_ID			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_ID))
+#define	AMAZON_SE_SSC1_CON			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_CON))
+#define	AMAZON_SE_SSC1_STATE			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_STATE))
+#define	AMAZON_SE_SSC1_WHBSTATE			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_WHBSTATE))
+#define	AMAZON_SE_SSC1_TB			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_TB))
+#define	AMAZON_SE_SSC1_RB			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_RB))
+#define	AMAZON_SE_SSC1_FSTAT			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_FSTAT))
+#define	AMAZON_SE_SSC1_PISEL			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_PISEL))
+#define	AMAZON_SE_SSC1_RXFCON			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_RXFCON))
+#define	AMAZON_SE_SSC1_TXFCON			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_TXFCON))
+#define	AMAZON_SE_SSC1_BR			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_BR))
+#define	AMAZON_SE_SSC1_BRSTAT			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_BRSTAT))
+#define	AMAZON_SE_SSC1_SFCON			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_SFCON))
+#define	AMAZON_SE_SSC1_SFSTAT			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_SFSTAT))
+#define	AMAZON_SE_SSC1_GPOCON			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_GPOCON))
+#define	AMAZON_SE_SSC1_GPOSTAT			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_GPOSTAT))
+#define	AMAZON_SE_SSC1_WHBGPOSTAT			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_WHBGPOSTAT))
+#define	AMAZON_SE_SSC1_RXREQ			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_RXREQ))
+#define	AMAZON_SE_SSC1_RXCNT			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_RXCNT))
+#define	AMAZON_SE_SSC1_DMA_CON			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_DMA_CON))
+#define	AMAZON_SE_SSC1_IRNEN			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_IRNEN))
+#define	AMAZON_SE_SSC1_IRNICR			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_IRNICR))
+#define	AMAZON_SE_SSC1_IRNCR			((volatile u32*)(AMAZON_SE_SSC1+AMAZON_SE_SSC_IRNCR))
+
+/***********************************************************************/
+/*  Module      :  GPIO register address and bits                       */
+/***********************************************************************/
+#define AMAZON_SE_GPIO                     (0xBE100B00)
+/***Port 0 Data Output Register (0010H)***/
+#define AMAZON_SE_GPIO_P0_OUT              ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0010))
+/***Port 1 Data Output Register (0040H)***/
+#define AMAZON_SE_GPIO_P1_OUT              ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0040))
+/***Port 0 Data Input Register (0014H)***/
+#define AMAZON_SE_GPIO_P0_IN               ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0014))
+/***Port 1 Data Input Register (0044H)***/
+#define AMAZON_SE_GPIO_P1_IN               ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0044))
+/***Port 0 Direction Register (0018H)***/
+#define AMAZON_SE_GPIO_P0_DIR              ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0018))
+/***Port 1 Direction Register (0048H)***/
+#define AMAZON_SE_GPIO_P1_DIR              ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0048))
+/***Port 0 Alternate Function Select Register 0 (001C H) ***/
+#define AMAZON_SE_GPIO_P0_ALTSEL0          ((volatile u32 *)(AMAZON_SE_GPIO+ 0x001C))
+/***Port 1 Alternate Function Select Register 0 (004C H) ***/
+#define AMAZON_SE_GPIO_P1_ALTSEL0          ((volatile u32 *)(AMAZON_SE_GPIO+ 0x004C))
+/***Port 0 Alternate Function Select Register 1 (0020 H) ***/
+#define AMAZON_SE_GPIO_P0_ALTSEL1          ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0020))
+/***Port 1 Alternate Function Select Register 0 (0050 H) ***/
+#define AMAZON_SE_GPIO_P1_ALTSEL1          ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0050))
+/***Port 0 Open Drain Control Register (0024H)***/
+#define AMAZON_SE_GPIO_P0_OD               ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0024))
+/***Port 1 Open Drain Control Register (0054H)***/
+#define AMAZON_SE_GPIO_P1_OD               ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0054))
+/***Port 0 Input Schmitt-Trigger Off Register (0028 H) ***/
+#define AMAZON_SE_GPIO_P0_STOFF            ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0028))
+/***Port 1 Input Schmitt-Trigger Off Register (0058 H) ***/
+#define AMAZON_SE_GPIO_P1_STOFF            ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0058))
+/***Port 0 Pull Up/Pull Down Select Register (002C H)***/
+#define AMAZON_SE_GPIO_P0_PUDSEL           ((volatile u32 *)(AMAZON_SE_GPIO+ 0x002C))
+/***Port 1 Pull Up/Pull Down Select Register (005C H)***/
+#define AMAZON_SE_GPIO_P1_PUDSEL           ((volatile u32 *)(AMAZON_SE_GPIO+ 0x005C))
+/***Port 0 Pull Up Device Enable Register (0030 H)***/
+#define AMAZON_SE_GPIO_P0_PUDEN            ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0030))
+/***Port 1 Pull Up Device Enable Register (0060 H)***/
+#define AMAZON_SE_GPIO_P1_PUDEN            ((volatile u32 *)(AMAZON_SE_GPIO+ 0x0060))
+/***********************************************************************/
+/*  Module      :  CGU register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_CGU                          (0xBF103000)
+/***********************************************************************/
+/***CGU Clock PLL0 ***/
+#define AMAZON_SE_CGU_PLL0_CFG                	((volatile u32*)(AMAZON_SE_CGU+ 0x0004))
+/***CGU Clock PLL1 ***/
+#define AMAZON_SE_CGU_PLL1_CFG                	((volatile u32*)(AMAZON_SE_CGU+ 0x0008))
+/***CGU Clock SYS Mux Register***/
+#define AMAZON_SE_CGU_SYS                   	((volatile u32*)(AMAZON_SE_CGU+ 0x0010))
+/***CGU Interface Clock Control Register***/
+#define AMAZON_SE_CGU_IFCCR                        ((volatile u32*)(AMAZON_SE_CGU+ 0x0018))
+/***CGU PCI Clock Control Register**/
+#define AMAZON_SE_CGU_PCICR                          ((volatile u32*)(AMAZON_SE_CGU+ 0x0034))
+#define AMAZON_SE_CGU_OSC_CON                     ((volatile u32*)(AMAZON_SE_CGU+ 0x001c))
+#define CLOCK_60M                60000000
+#define CLOCK_83M                83333333
+#define CLOCK_111M               111111111
+#define CLOCK_133M               133333333
+#define CLOCK_167M               166666667
+#define CLOCK_266M               266666667
+#define CLOCK_333M               333333333
+
+/***********************************************************************/
+/*  Module      :  MCD register address and bits                       */
+/***********************************************************************/
+#define AMAZON_SE_MCD                          		(KSEG1+0x1F106000)
+
+/***Manufacturer Identification Register***/
+#define AMAZON_SE_MCD_MANID                        	((volatile u32*)(AMAZON_SE_MCD+ 0x0024))
+#define AMAZON_SE_MCD_MANID_MANUF(value)              	(((( 1 << 11) - 1) & (value)) << 5)
+
+/***Chip Identification Register***/
+#define AMAZON_SE_MCD_CHIPID                       	((volatile u32*)(AMAZON_SE_MCD+ 0x0028))
+#define AMAZON_SE_MCD_CHIPID_VERSION_GET(value)             (((value) >> 28) & ((1 << 4) - 1))
+#define AMAZON_SE_MCD_CHIPID_VERSION_SET(value)             (((( 1 << 4) - 1) & (value)) << 28)
+#define AMAZON_SE_MCD_CHIPID_PART_NUMBER_GET(value)         (((value) >> 12) & ((1 << 16) - 1))
+#define AMAZON_SE_MCD_CHIPID_PART_NUMBER_SET(value)         (((( 1 << 16) - 1) & (value)) << 12)
+#define AMAZON_SE_MCD_CHIPID_MANID_GET(value)               (((value) >> 1) & ((1 << 11) - 1))
+#define AMAZON_SE_MCD_CHIPID_MANID_SET(value)               (((( 1 << 11) - 1) & (value)) << 1)
+
+#define AMAZON_SE_CHIPID_STANDARD				0x00EB
+#define AMAZON_SE_CHIPID_YANGTSE				0x00ED
+
+/***Redesign Tracing Identification Register***/
+#define AMAZON_SE_MCD_RTID                         	((volatile u32*)(AMAZON_SE_MCD+ 0x002C))
+#define AMAZON_SE_MCD_RTID_LC                              (1 << 15)
+#define AMAZON_SE_MCD_RTID_RIX(value)                	(((( 1 << 3) - 1) & (value)) << 0)
+
+
+/***********************************************************************/
+/*  Module      :  EBU register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_EBU                          (0xBE105300)
+
+/***********************************************************************/
+
+
+/***EBU Clock Control Register***/
+#define AMAZON_SE_EBU_CLC                      ((volatile u32*)(AMAZON_SE_EBU+ 0x0000))
+#define AMAZON_SE_EBU_CLC_DISS                            (1 << 1)
+#define AMAZON_SE_EBU_CLC_DISR                            (1 << 0)
+
+/***EBU Global Control Register***/
+#define AMAZON_SE_EBU_CON                      ((volatile u32*)(AMAZON_SE_EBU+ 0x0010))
+#define AMAZON_SE_EBU_CON_DTACS (value)              (((( 1 << 3) - 1) & (value)) << 20)
+#define AMAZON_SE_EBU_CON_DTARW (value)              (((( 1 << 3) - 1) & (value)) << 16)
+#define AMAZON_SE_EBU_CON_TOUTC (value)              (((( 1 << 8) - 1) & (value)) << 8)
+#define AMAZON_SE_EBU_CON_ARBMODE (value)            (((( 1 << 2) - 1) & (value)) << 6)
+#define AMAZON_SE_EBU_CON_ARBSYNC                      (1 << 5)
+#define AMAZON_SE_EBU_CON_1                              (1 << 3)
+
+/***EBU Address Select Register 0***/
+#define AMAZON_SE_EBU_ADDSEL0                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0020))
+#define AMAZON_SE_EBU_ADDSEL0_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define AMAZON_SE_EBU_ADDSEL0_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_ADDSEL0_MIRRORE                      (1 << 1)
+#define AMAZON_SE_EBU_ADDSEL0_REGEN                          (1 << 0)
+
+/***EBU Address Select Register 1***/
+#define AMAZON_SE_EBU_ADDSEL1                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0024))
+#define AMAZON_SE_EBU_ADDSEL1_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define AMAZON_SE_EBU_ADDSEL1_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_ADDSEL1_MIRRORE                      (1 << 1)
+#define AMAZON_SE_EBU_ADDSEL1_REGEN                          (1 << 0)
+
+/***EBU Address Select Register 2***/
+#define AMAZON_SE_EBU_ADDSEL2                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0028))
+#define AMAZON_SE_EBU_ADDSEL2_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define AMAZON_SE_EBU_ADDSEL2_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_ADDSEL2_MIRRORE                      (1 << 1)
+#define AMAZON_SE_EBU_ADDSEL2_REGEN                          (1 << 0)
+
+/***EBU Address Select Register 3***/
+#define AMAZON_SE_EBU_ADDSEL3                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0028))
+#define AMAZON_SE_EBU_ADDSEL3_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define AMAZON_SE_EBU_ADDSEL3_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_ADDSEL3_MIRRORE                      (1 << 1)
+#define AMAZON_SE_EBU_ADDSEL3_REGEN                          (1 << 0)
+
+/***EBU Bus Configuration Register 0***/
+#define AMAZON_SE_EBU_BUSCON0                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0060))
+#define AMAZON_SE_EBU_BUSCON0_WRDIS                          (1 << 31)
+#define AMAZON_SE_EBU_BUSCON0_ALEC (value)               (((( 1 << 2) - 1) & (value)) << 29)
+#define AMAZON_SE_EBU_BUSCON0_BCGEN (value)              (((( 1 << 2) - 1) & (value)) << 27)
+#define AMAZON_SE_EBU_BUSCON0_AGEN (value)               (((( 1 << 2) - 1) & (value)) << 24)
+#define AMAZON_SE_EBU_BUSCON0_CMULTR (value)             (((( 1 << 2) - 1) & (value)) << 22)
+#define AMAZON_SE_EBU_BUSCON0_WAIT (value)               (((( 1 << 2) - 1) & (value)) << 20)
+#define AMAZON_SE_EBU_BUSCON0_WAITINV                      (1 << 19)
+#define AMAZON_SE_EBU_BUSCON0_SETUP                          (1 << 18)
+#define AMAZON_SE_EBU_BUSCON0_PORTW (value)              (((( 1 << 2) - 1) & (value)) << 16)
+#define AMAZON_SE_EBU_BUSCON0_WAITRDC (value)            (((( 1 << 7) - 1) & (value)) << 9)
+#define AMAZON_SE_EBU_BUSCON0_WAITWRC (value)            (((( 1 << 3) - 1) & (value)) << 6)
+#define AMAZON_SE_EBU_BUSCON0_HOLDC (value)              (((( 1 << 2) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_BUSCON0_RECOVC (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define AMAZON_SE_EBU_BUSCON0_CMULT (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 1***/
+#define AMAZON_SE_EBU_BUSCON1                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0064))
+#define AMAZON_SE_EBU_BUSCON1_WRDIS                          (1 << 31)
+#define AMAZON_SE_EBU_BUSCON1_ALEC (value)               (((( 1 << 2) - 1) & (value)) << 29)
+#define AMAZON_SE_EBU_BUSCON1_BCGEN (value)              (((( 1 << 2) - 1) & (value)) << 27)
+#define AMAZON_SE_EBU_BUSCON1_AGEN (value)               (((( 1 << 2) - 1) & (value)) << 24)
+#define AMAZON_SE_EBU_BUSCON1_CMULTR (value)             (((( 1 << 2) - 1) & (value)) << 22)
+#define AMAZON_SE_EBU_BUSCON1_WAIT (value)               (((( 1 << 2) - 1) & (value)) << 20)
+#define AMAZON_SE_EBU_BUSCON1_WAITINV                      (1 << 19)
+#define AMAZON_SE_EBU_BUSCON1_SETUP                          (1 << 18)
+#define AMAZON_SE_EBU_BUSCON1_PORTW (value)              (((( 1 << 2) - 1) & (value)) << 16)
+#define AMAZON_SE_EBU_BUSCON1_WAITRDC (value)            (((( 1 << 7) - 1) & (value)) << 9)
+#define AMAZON_SE_EBU_BUSCON1_WAITWRC (value)            (((( 1 << 3) - 1) & (value)) << 6)
+#define AMAZON_SE_EBU_BUSCON1_HOLDC (value)              (((( 1 << 2) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_BUSCON1_RECOVC (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define AMAZON_SE_EBU_BUSCON1_CMULT (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 2***/
+#define AMAZON_SE_EBU_BUSCON2                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0068))
+#define AMAZON_SE_EBU_BUSCON2_WRDIS                          (1 << 31)
+#define AMAZON_SE_EBU_BUSCON2_ALEC (value)               (((( 1 << 2) - 1) & (value)) << 29)
+#define AMAZON_SE_EBU_BUSCON2_BCGEN (value)              (((( 1 << 2) - 1) & (value)) << 27)
+#define AMAZON_SE_EBU_BUSCON2_AGEN (value)               (((( 1 << 2) - 1) & (value)) << 24)
+#define AMAZON_SE_EBU_BUSCON2_CMULTR (value)             (((( 1 << 2) - 1) & (value)) << 22)
+#define AMAZON_SE_EBU_BUSCON2_WAIT (value)               (((( 1 << 2) - 1) & (value)) << 20)
+#define AMAZON_SE_EBU_BUSCON2_WAITINV                      (1 << 19)
+#define AMAZON_SE_EBU_BUSCON2_SETUP                          (1 << 18)
+#define AMAZON_SE_EBU_BUSCON2_PORTW (value)              (((( 1 << 2) - 1) & (value)) << 16)
+#define AMAZON_SE_EBU_BUSCON2_WAITRDC (value)            (((( 1 << 7) - 1) & (value)) << 9)
+#define AMAZON_SE_EBU_BUSCON2_WAITWRC (value)            (((( 1 << 3) - 1) & (value)) << 6)
+#define AMAZON_SE_EBU_BUSCON2_HOLDC (value)              (((( 1 << 2) - 1) & (value)) << 4)
+#define AMAZON_SE_EBU_BUSCON2_RECOVC (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define AMAZON_SE_EBU_BUSCON2_CMULT (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+#define AMAZON_SE_EBU_PCC_CON                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0090))
+#define AMAZON_SE_EBU_PCC_STAT                  ((volatile u32*)(AMAZON_SE_EBU+ 0x0094))
+#define AMAZON_SE_EBU_PCC_ISTAT                  ((volatile u32*)(AMAZON_SE_EBU+ 0x00A0))
+#define AMAZON_SE_EBU_PCC_IEN                  ((volatile u32*)(AMAZON_SE_EBU+ 0x00A4))
+/***********************************************************************/
+/*  Module      :  SDRAM register address and bits                     */
+/***********************************************************************/
+
+#define AMAZON_SE_SDRAM                        (0xBF800000)
+/***********************************************************************/
+
+
+/***MC Access Error Cause Register***/
+#define AMAZON_SE_SDRAM_MC_ERRCAUSE                  ((volatile u32*)(AMAZON_SE_SDRAM+ 0x0100))
+#define AMAZON_SE_SDRAM_MC_ERRCAUSE_ERR                              (1 << 31)
+#define AMAZON_SE_SDRAM_MC_ERRCAUSE_PORT (value)               (((( 1 << 4) - 1) & (value)) << 16)
+#define AMAZON_SE_SDRAM_MC_ERRCAUSE_CAUSE (value)              (((( 1 << 2) - 1) & (value)) << 0)
+#define AMAZON_SE_SDRAM_MC_ERRCAUSE_Res (value)                (((( 1 << NaN) - 1) & (value)) << NaN)
+
+/***MC Access Error Address Register***/
+#define AMAZON_SE_SDRAM_MC_ERRADDR                   ((volatile u32*)(AMAZON_SE_SDRAM+ 0x0108))
+#define AMAZON_SE_SDRAM_MC_ERRADDR_ADDR
+
+/***MC I/O General Purpose Register***/
+#define AMAZON_SE_SDRAM_MC_IOGP                      ((volatile u32*)(AMAZON_SE_SDRAM+ 0x0800))
+#define AMAZON_SE_SDRAM_MC_IOGP_GPR6 (value)               (((( 1 << 4) - 1) & (value)) << 28)
+#define AMAZON_SE_SDRAM_MC_IOGP_GPR5 (value)               (((( 1 << 4) - 1) & (value)) << 24)
+#define AMAZON_SE_SDRAM_MC_IOGP_GPR4 (value)               (((( 1 << 4) - 1) & (value)) << 20)
+#define AMAZON_SE_SDRAM_MC_IOGP_GPR3 (value)               (((( 1 << 4) - 1) & (value)) << 16)
+#define AMAZON_SE_SDRAM_MC_IOGP_GPR2 (value)               (((( 1 << 4) - 1) & (value)) << 12)
+#define AMAZON_SE_SDRAM_MC_IOGP_CPS                              (1 << 11)
+#define AMAZON_SE_SDRAM_MC_IOGP_CLKDELAY (value)          (((( 1 << 3) - 1) & (value)) << 8)
+#define AMAZON_SE_SDRAM_MC_IOGP_CLKRAT (value)             (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_SDRAM_MC_IOGP_RDDEL (value)              (((( 1 << 4) - 1) & (value)) << 0)
+
+/***MC Self Refresh Register***/
+#define AMAZON_SE_SDRAM_MC_SELFRFSH                  ((volatile u32*)(AMAZON_SE_SDRAM+ 0x0A00))
+#define AMAZON_SE_SDRAM_MC_SELFRFSH_PWDS                            (1 << 1)
+#define AMAZON_SE_SDRAM_MC_SELFRFSH_PWD                              (1 << 0)
+#define AMAZON_SE_SDRAM_MC_SELFRFSH_Res (value)                (((( 1 << 30) - 1) & (value)) << 2)
+
+/***MC Enable Register***/
+#define AMAZON_SE_SDRAM_MC_CTRLENA                   ((volatile u32*)(AMAZON_SE_SDRAM+ 0x1000))
+#define AMAZON_SE_SDRAM_MC_CTRLENA_ENA                              (1 << 0)
+#define AMAZON_SE_SDRAM_MC_CTRLENA_Res (value)                (((( 1 << 31) - 1) & (value)) << 1)
+
+/***MC Mode Register Setup Code***/
+#define AMAZON_SE_SDRAM_MC_MRSCODE                   ((volatile u32*)(AMAZON_SE_SDRAM+ 0x1008))
+#define AMAZON_SE_SDRAM_MC_MRSCODE_UMC (value)                (((( 1 << 5) - 1) & (value)) << 7)
+#define AMAZON_SE_SDRAM_MC_MRSCODE_CL (value)                (((( 1 << 3) - 1) & (value)) << 4)
+#define AMAZON_SE_SDRAM_MC_MRSCODE_WT                              (1 << 3)
+#define AMAZON_SE_SDRAM_MC_MRSCODE_BL (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***MC Configuration Data-word Width Register***/
+#define AMAZON_SE_SDRAM_MC_CFGDW                    ((volatile u32*)(AMAZON_SE_SDRAM+ 0x1010))
+#define AMAZON_SE_SDRAM_MC_CFGDW_DW (value)                (((( 1 << 4) - 1) & (value)) << 0)
+#define AMAZON_SE_SDRAM_MC_CFGDW_Res (value)                (((( 1 << 28) - 1) & (value)) << 4)
+
+/***MC Configuration Physical Bank 0 Register***/
+#define AMAZON_SE_SDRAM_MC_CFGPB0                    ((volatile u32*)(AMAZON_SE_SDRAM+ 0x1018))
+#define AMAZON_SE_SDRAM_MC_CFGPB0_MCSEN0 (value)             (((( 1 << 4) - 1) & (value)) << 12)
+#define AMAZON_SE_SDRAM_MC_CFGPB0_BANKN0 (value)             (((( 1 << 4) - 1) & (value)) << 8)
+#define AMAZON_SE_SDRAM_MC_CFGPB0_ROWW0 (value)              (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_SDRAM_MC_CFGPB0_COLW0 (value)              (((( 1 << 4) - 1) & (value)) << 0)
+#define AMAZON_SE_SDRAM_MC_CFGPB0_Res (value)                (((( 1 << 16) - 1) & (value)) << 16)
+
+/***MC Latency Register***/
+#define AMAZON_SE_SDRAM_MC_LATENCY                   ((volatile u32*)(AMAZON_SE_SDRAM+ 0x1038))
+#define AMAZON_SE_SDRAM_MC_LATENCY_TRP (value)                (((( 1 << 4) - 1) & (value)) << 16)
+#define AMAZON_SE_SDRAM_MC_LATENCY_TRAS (value)               (((( 1 << 4) - 1) & (value)) << 12)
+#define AMAZON_SE_SDRAM_MC_LATENCY_TRCD (value)               (((( 1 << 4) - 1) & (value)) << 8)
+#define AMAZON_SE_SDRAM_MC_LATENCY_TDPL (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_SDRAM_MC_LATENCY_TDAL (value)               (((( 1 << 4) - 1) & (value)) << 0)
+#define AMAZON_SE_SDRAM_MC_LATENCY_Res (value)                (((( 1 << 12) - 1) & (value)) << 20)
+
+/***MC Refresh Cycle Time Register***/
+#define AMAZON_SE_SDRAM_MC_TREFRESH                  ((volatile u32*)(AMAZON_SE_SDRAM+ 0x1040))
+#define AMAZON_SE_SDRAM_MC_TREFRESH_TREF (value)               (((( 1 << 13) - 1) & (value)) << 0)
+#define AMAZON_SE_SDRAM_MC_TREFRESH_Res (value)                (((( 1 << 19) - 1) & (value)) << 13)
+
+
+/***********************************************************************/
+/*  Module      :  GPTC register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_GPTC                   (KSEG1 + 0x1E100A00)
+#define AMAZON_SE_GPTC_CLC               ((volatile u32*) (AMAZON_SE_GPTC + 0x0000))
+#define AMAZON_SE_GPTC_ID                ((volatile u32*) (AMAZON_SE_GPTC + 0x0008))
+#define AMAZON_SE_GPTC_IRNEN             ((volatile u32*) (AMAZON_SE_GPTC + 0x00F4))
+#define AMAZON_SE_GPTC_IRNICR    ((volatile u32*) (AMAZON_SE_GPTC + 0x00F8)
+#define AMAZON_SE_GPTC_IRNCR             ((volatile u32*) (AMAZON_SE_GPTC + 0x00FC))
+
+#define AMAZON_SE_GPTC_CON_1A    ((volatile u32*) (AMAZON_SE_GPTC + 0x0010))
+#define AMAZON_SE_GPTC_RUN_1A    ((volatile u32*) (AMAZON_SE_GPTC + 0x0018))
+#define AMAZON_SE_GPTC_RELOAD_1A ((volatile u32*) (AMAZON_SE_GPTC + 0x0020))
+#define AMAZON_SE_GPTC_COUNT_1A  ((volatile u32*) (AMAZON_SE_GPTC + 0x0028))
+
+#define AMAZON_SE_GPTC_CON_1B    ((volatile u32*) (AMAZON_SE_GPTC + 0x0014))
+#define AMAZON_SE_GPTC_RUN_1B    ((volatile u32*) (AMAZON_SE_GPTC + 0x001C))
+#define AMAZON_SE_GPTC_RELOAD_1B ((volatile u32*) (AMAZON_SE_GPTC + 0x0024))
+#define AMAZON_SE_GPTC_COUNT_1B  ((volatile u32*) (AMAZON_SE_GPTC + 0x002C))
+
+#define AMAZON_SE_GPTC_CON_2A    ((volatile u32*) (AMAZON_SE_GPTC + 0x0030))
+#define AMAZON_SE_GPTC_RUN_2A    ((volatile u32*) (AMAZON_SE_GPTC + 0x0038))
+#define AMAZON_SE_GPTC_RELOAD_2A ((volatile u32*) (AMAZON_SE_GPTC + 0x0040))
+#define AMAZON_SE_GPTC_COUNT_2A  ((volatile u32*) (AMAZON_SE_GPTC + 0x0048))
+
+#define AMAZON_SE_GPTC_CON_2B    ((volatile u32*) (AMAZON_SE_GPTC + 0x0034))
+#define AMAZON_SE_GPTC_RUN_2B    ((volatile u32*) (AMAZON_SE_GPTC + 0x003C))
+#define AMAZON_SE_GPTC_RELOAD_2B ((volatile u32*) (AMAZON_SE_GPTC + 0x0044))
+#define AMAZON_SE_GPTC_COUNT_2B  ((volatile u32*) (AMAZON_SE_GPTC + 0x004C))
+
+
+
+/***********************************************************************/
+/*  Module      :  GPTU register address and bits                      */
+/***********************************************************************/
+
+#define AMAZON_SE_GPTU                         (0xB8000300)
+/***********************************************************************/
+
+
+/***GPT Clock Control Register***/
+#define AMAZON_SE_GPTU_GPT_CLC                      ((volatile u32*)(AMAZON_SE_GPTU+ 0x0000))
+#define AMAZON_SE_GPTU_GPT_CLC_RMC (value)                (((( 1 << 8) - 1) & (value)) << 8)
+#define AMAZON_SE_GPTU_GPT_CLC_DISS                            (1 << 1)
+#define AMAZON_SE_GPTU_GPT_CLC_DISR                            (1 << 0)
+
+/***GPT Timer 3 Control Register***/
+#define AMAZON_SE_GPTU_GPT_T3CON                    ((volatile u32*)(AMAZON_SE_GPTU+ 0x0014))
+#define AMAZON_SE_GPTU_GPT_T3CON_T3RDIR                        (1 << 15)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3CHDIR                      (1 << 14)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3EDGE                        (1 << 13)
+#define AMAZON_SE_GPTU_GPT_T3CON_BPS1 (value)               (((( 1 << 2) - 1) & (value)) << 11)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3OTL                          (1 << 10)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3UD                            (1 << 7)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3R                              (1 << 6)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3M (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define AMAZON_SE_GPTU_GPT_T3CON_T3I (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Write Hardware Modified Timer 3 Control Register
+If set and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define AMAZON_SE_GPTU_GPT_WHBT3CON                 ((volatile u32*)(AMAZON_SE_GPTU+ 0x004C))
+#define AMAZON_SE_GPTU_GPT_WHBT3CON_SETT3CHDIR                (1 << 15)
+#define AMAZON_SE_GPTU_GPT_WHBT3CON_CLRT3CHDIR                (1 << 14)
+#define AMAZON_SE_GPTU_GPT_WHBT3CON_SETT3EDGE                  (1 << 13)
+#define AMAZON_SE_GPTU_GPT_WHBT3CON_CLRT3EDGE                  (1 << 12)
+#define AMAZON_SE_GPTU_GPT_WHBT3CON_SETT3OTL                  (1 << 11)
+#define AMAZON_SE_GPTU_GPT_WHBT3CON_CLRT3OTL                  (1 << 10)
+
+/***GPT Timer 2 Control Register***/
+#define AMAZON_SE_GPTU_GPT_T2CON                    ((volatile u32*)(AMAZON_SE_GPTU+ 0x0010))
+#define AMAZON_SE_GPTU_GPT_T2CON_TxRDIR                        (1 << 15)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxCHDIR                      (1 << 14)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxEDGE                        (1 << 13)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxIRDIS                      (1 << 12)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxRC                            (1 << 9)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxUD                            (1 << 7)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxR                              (1 << 6)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxM (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define AMAZON_SE_GPTU_GPT_T2CON_TxI (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Timer 4 Control Register***/
+#define AMAZON_SE_GPTU_GPT_T4CON                    ((volatile u32*)(AMAZON_SE_GPTU+ 0x0018))
+#define AMAZON_SE_GPTU_GPT_T4CON_TxRDIR                        (1 << 15)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxCHDIR                      (1 << 14)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxEDGE                        (1 << 13)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxIRDIS                      (1 << 12)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxRC                            (1 << 9)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxUD                            (1 << 7)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxR                              (1 << 6)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxM (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define AMAZON_SE_GPTU_GPT_T4CON_TxI (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Write HW Modified Timer 2 Control Register If set
+ and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define AMAZON_SE_GPTU_GPT_WHBT2CON                 ((volatile u32*)(AMAZON_SE_GPTU+ 0x0048))
+#define AMAZON_SE_GPTU_GPT_WHBT2CON_SETTxCHDIR                (1 << 15)
+#define AMAZON_SE_GPTU_GPT_WHBT2CON_CLRTxCHDIR                (1 << 14)
+#define AMAZON_SE_GPTU_GPT_WHBT2CON_SETTxEDGE                  (1 << 13)
+#define AMAZON_SE_GPTU_GPT_WHBT2CON_CLRTxEDGE                  (1 << 12)
+
+/***GPT Write HW Modified Timer 4 Control Register If set
+ and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define AMAZON_SE_GPTU_GPT_WHBT4CON                 ((volatile u32*)(AMAZON_SE_GPTU+ 0x0050))
+#define AMAZON_SE_GPTU_GPT_WHBT4CON_SETTxCHDIR                (1 << 15)
+#define AMAZON_SE_GPTU_GPT_WHBT4CON_CLRTxCHDIR                (1 << 14)
+#define AMAZON_SE_GPTU_GPT_WHBT4CON_SETTxEDGE                  (1 << 13)
+#define AMAZON_SE_GPTU_GPT_WHBT4CON_CLRTxEDGE                  (1 << 12)
+
+/***GPT Capture Reload Register***/
+#define AMAZON_SE_GPTU_GPT_CAPREL                   ((volatile u32*)(AMAZON_SE_GPTU+ 0x0030))
+#define AMAZON_SE_GPTU_GPT_CAPREL_CAPREL (value)             (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 2 Register***/
+#define AMAZON_SE_GPTU_GPT_T2                       ((volatile u32*)(AMAZON_SE_GPTU+ 0x0034))
+#define AMAZON_SE_GPTU_GPT_T2_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 3 Register***/
+#define AMAZON_SE_GPTU_GPT_T3                       ((volatile u32*)(AMAZON_SE_GPTU+ 0x0038))
+#define AMAZON_SE_GPTU_GPT_T3_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 4 Register***/
+#define AMAZON_SE_GPTU_GPT_T4                       ((volatile u32*)(AMAZON_SE_GPTU+ 0x003C))
+#define AMAZON_SE_GPTU_GPT_T4_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 5 Register***/
+#define AMAZON_SE_GPTU_GPT_T5                       ((volatile u32*)(AMAZON_SE_GPTU+ 0x0040))
+#define AMAZON_SE_GPTU_GPT_T5_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 6 Register***/
+#define AMAZON_SE_GPTU_GPT_T6                       ((volatile u32*)(AMAZON_SE_GPTU+ 0x0044))
+#define AMAZON_SE_GPTU_GPT_T6_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 6 Control Register***/
+#define AMAZON_SE_GPTU_GPT_T6CON                    ((volatile u32*)(AMAZON_SE_GPTU+ 0x0020))
+#define AMAZON_SE_GPTU_GPT_T6CON_T6SR                            (1 << 15)
+#define AMAZON_SE_GPTU_GPT_T6CON_T6CLR                          (1 << 14)
+#define AMAZON_SE_GPTU_GPT_T6CON_BPS2 (value)               (((( 1 << 2) - 1) & (value)) << 11)
+#define AMAZON_SE_GPTU_GPT_T6CON_T6OTL                          (1 << 10)
+#define AMAZON_SE_GPTU_GPT_T6CON_T6UD                            (1 << 7)
+#define AMAZON_SE_GPTU_GPT_T6CON_T6R                              (1 << 6)
+#define AMAZON_SE_GPTU_GPT_T6CON_T6M (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define AMAZON_SE_GPTU_GPT_T6CON_T6I (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Write HW Modified Timer 6 Control Register If set
+ and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define AMAZON_SE_GPTU_GPT_WHBT6CON                 ((volatile u32*)(AMAZON_SE_GPTU+ 0x0054))
+#define AMAZON_SE_GPTU_GPT_WHBT6CON_SETT6OTL                  (1 << 11)
+#define AMAZON_SE_GPTU_GPT_WHBT6CON_CLRT6OTL                  (1 << 10)
+
+/***GPT Timer 5 Control Register***/
+#define AMAZON_SE_GPTU_GPT_T5CON                    ((volatile u32*)(AMAZON_SE_GPTU+ 0x001C))
+#define AMAZON_SE_GPTU_GPT_T5CON_T5SC                            (1 << 15)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5CLR                          (1 << 14)
+#define AMAZON_SE_GPTU_GPT_T5CON_CI (value)                (((( 1 << 2) - 1) & (value)) << 12)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5CC                            (1 << 11)
+#define AMAZON_SE_GPTU_GPT_T5CON_CT3                              (1 << 10)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5RC                            (1 << 9)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5UDE                          (1 << 8)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5UD                            (1 << 7)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5R                              (1 << 6)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5M (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define AMAZON_SE_GPTU_GPT_T5CON_T5I (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+
+/***********************************************************************/
+/*  Module      :  IOM register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_IOM                          (0xBF105000)
+/***********************************************************************/
+
+
+/***Receive FIFO***/
+#define AMAZON_SE_IOM_RFIFO                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0000))
+#define AMAZON_SE_IOM_RFIFO_RXD (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Transmit FIFO***/
+#define AMAZON_SE_IOM_XFIFO                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0000))
+#define AMAZON_SE_IOM_XFIFO_TXD (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Interrupt Status Register HDLC***/
+#define AMAZON_SE_IOM_ISTAH                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0080))
+#define AMAZON_SE_IOM_ISTAH_RME                              (1 << 7)
+#define AMAZON_SE_IOM_ISTAH_RPF                              (1 << 6)
+#define AMAZON_SE_IOM_ISTAH_RFO                              (1 << 5)
+#define AMAZON_SE_IOM_ISTAH_XPR                              (1 << 4)
+#define AMAZON_SE_IOM_ISTAH_XMR                              (1 << 3)
+#define AMAZON_SE_IOM_ISTAH_XDU                              (1 << 2)
+
+/***Interrupt Mask Register HDLC***/
+#define AMAZON_SE_IOM_MASKH                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0080))
+#define AMAZON_SE_IOM_MASKH_RME                              (1 << 7)
+#define AMAZON_SE_IOM_MASKH_RPF                              (1 << 6)
+#define AMAZON_SE_IOM_MASKH_RFO                              (1 << 5)
+#define AMAZON_SE_IOM_MASKH_XPR                              (1 << 4)
+#define AMAZON_SE_IOM_MASKH_XMR                              (1 << 3)
+#define AMAZON_SE_IOM_MASKH_XDU                              (1 << 2)
+
+/***Status Register***/
+#define AMAZON_SE_IOM_STAR                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0084))
+#define AMAZON_SE_IOM_STAR_XDOV                            (1 << 7)
+#define AMAZON_SE_IOM_STAR_XFW                              (1 << 6)
+#define AMAZON_SE_IOM_STAR_RACI                            (1 << 3)
+#define AMAZON_SE_IOM_STAR_XACI                            (1 << 1)
+
+/***Command Register***/
+#define AMAZON_SE_IOM_CMDR                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0084))
+#define AMAZON_SE_IOM_CMDR_RMC                              (1 << 7)
+#define AMAZON_SE_IOM_CMDR_RRES                            (1 << 6)
+#define AMAZON_SE_IOM_CMDR_XTF                              (1 << 3)
+#define AMAZON_SE_IOM_CMDR_XME                              (1 << 1)
+#define AMAZON_SE_IOM_CMDR_XRES                            (1 << 0)
+
+/***Mode Register***/
+#define AMAZON_SE_IOM_MODEH                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0088))
+#define AMAZON_SE_IOM_MODEH_MDS2                            (1 << 7)
+#define AMAZON_SE_IOM_MODEH_MDS1                            (1 << 6)
+#define AMAZON_SE_IOM_MODEH_MDS0                            (1 << 5)
+#define AMAZON_SE_IOM_MODEH_RAC                              (1 << 3)
+#define AMAZON_SE_IOM_MODEH_DIM2                            (1 << 2)
+#define AMAZON_SE_IOM_MODEH_DIM1                            (1 << 1)
+#define AMAZON_SE_IOM_MODEH_DIM0                            (1 << 0)
+
+/***Extended Mode Register***/
+#define AMAZON_SE_IOM_EXMR                         ((volatile u32*)(AMAZON_SE_IOM+ 0x008C))
+#define AMAZON_SE_IOM_EXMR_XFBS                            (1 << 7)
+#define AMAZON_SE_IOM_EXMR_RFBS (value)               (((( 1 << 2) - 1) & (value)) << 5)
+#define AMAZON_SE_IOM_EXMR_SRA                              (1 << 4)
+#define AMAZON_SE_IOM_EXMR_XCRC                            (1 << 3)
+#define AMAZON_SE_IOM_EXMR_RCRC                            (1 << 2)
+#define AMAZON_SE_IOM_EXMR_ITF                              (1 << 0)
+
+/***SAPI1 Register***/
+#define AMAZON_SE_IOM_SAP1                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0094))
+#define AMAZON_SE_IOM_SAP1_SAPI1 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+#define AMAZON_SE_IOM_SAP1_MHA                              (1 << 0)
+
+/***Receive Frame Byte Count Low***/
+#define AMAZON_SE_IOM_RBCL                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0098))
+#define AMAZON_SE_IOM_RBCL_RBC(value)              (1 << value)
+
+
+/***SAPI2 Register***/
+#define AMAZON_SE_IOM_SAP2                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0098))
+#define AMAZON_SE_IOM_SAP2_SAPI2 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+#define AMAZON_SE_IOM_SAP2_MLA                              (1 << 0)
+
+/***Receive Frame Byte Count High***/
+#define AMAZON_SE_IOM_RBCH                         ((volatile u32*)(AMAZON_SE_IOM+ 0x009C))
+#define AMAZON_SE_IOM_RBCH_OV                              (1 << 4)
+#define AMAZON_SE_IOM_RBCH_RBC11                          (1 << 3)
+#define AMAZON_SE_IOM_RBCH_RBC10                          (1 << 2)
+#define AMAZON_SE_IOM_RBCH_RBC9                            (1 << 1)
+#define AMAZON_SE_IOM_RBCH_RBC8                            (1 << 0)
+
+/***TEI1 Register 1***/
+#define AMAZON_SE_IOM_TEI1                         ((volatile u32*)(AMAZON_SE_IOM+ 0x009C))
+#define AMAZON_SE_IOM_TEI1_TEI1 (value)               (((( 1 << 7) - 1) & (value)) << 1)
+#define AMAZON_SE_IOM_TEI1_EA                              (1 << 0)
+
+/***Receive Status Register***/
+#define AMAZON_SE_IOM_RSTA                         ((volatile u32*)(AMAZON_SE_IOM+ 0x00A0))
+#define AMAZON_SE_IOM_RSTA_VFR                              (1 << 7)
+#define AMAZON_SE_IOM_RSTA_RDO                              (1 << 6)
+#define AMAZON_SE_IOM_RSTA_CRC                              (1 << 5)
+#define AMAZON_SE_IOM_RSTA_RAB                              (1 << 4)
+#define AMAZON_SE_IOM_RSTA_SA1                              (1 << 3)
+#define AMAZON_SE_IOM_RSTA_SA0                              (1 << 2)
+#define AMAZON_SE_IOM_RSTA_TA                              (1 << 0)
+#define AMAZON_SE_IOM_RSTA_CR                              (1 << 1)
+
+/***TEI2 Register***/
+#define AMAZON_SE_IOM_TEI2                         ((volatile u32*)(AMAZON_SE_IOM+ 0x00A0))
+#define AMAZON_SE_IOM_TEI2_TEI2 (value)               (((( 1 << 7) - 1) & (value)) << 1)
+#define AMAZON_SE_IOM_TEI2_EA                              (1 << 0)
+
+/***Test Mode Register HDLC***/
+#define AMAZON_SE_IOM_TMH                          ((volatile u32*)(AMAZON_SE_IOM+ 0x00A4))
+#define AMAZON_SE_IOM_TMH_TLP                              (1 << 0)
+
+/***Command/Indication Receive 0***/
+#define AMAZON_SE_IOM_CIR0                         ((volatile u32*)(AMAZON_SE_IOM+ 0x00B8))
+#define AMAZON_SE_IOM_CIR0_CODR0 (value)              (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_IOM_CIR0_CIC0                            (1 << 3)
+#define AMAZON_SE_IOM_CIR0_CIC1                            (1 << 2)
+#define AMAZON_SE_IOM_CIR0_SG                              (1 << 1)
+#define AMAZON_SE_IOM_CIR0_BAS                              (1 << 0)
+
+/***Command/Indication Transmit 0***/
+#define AMAZON_SE_IOM_CIX0                         ((volatile u32*)(AMAZON_SE_IOM+ 0x00B8))
+#define AMAZON_SE_IOM_CIX0_CODX0 (value)              (((( 1 << 4) - 1) & (value)) << 4)
+#define AMAZON_SE_IOM_CIX0_TBA2                            (1 << 3)
+#define AMAZON_SE_IOM_CIX0_TBA1                            (1 << 2)
+#define AMAZON_SE_IOM_CIX0_TBA0                            (1 << 1)
+#define AMAZON_SE_IOM_CIX0_BAC                              (1 << 0)
+
+/***Command/Indication Receive 1***/
+#define AMAZON_SE_IOM_CIR1                         ((volatile u32*)(AMAZON_SE_IOM+ 0x00BC))
+#define AMAZON_SE_IOM_CIR1_CODR1 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+
+/***Command/Indication Transmit 1***/
+#define AMAZON_SE_IOM_CIX1                         ((volatile u32*)(AMAZON_SE_IOM+ 0x00BC))
+#define AMAZON_SE_IOM_CIX1_CODX1 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+#define AMAZON_SE_IOM_CIX1_CICW                            (1 << 1)
+#define AMAZON_SE_IOM_CIX1_CI1E                            (1 << 0)
+
+/***Controller Data Access Reg. (CH10)***/
+#define AMAZON_SE_IOM_CDA10                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0100))
+#define AMAZON_SE_IOM_CDA10_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Controller Data Access Reg. (CH11)***/
+#define AMAZON_SE_IOM_CDA11                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0104))
+#define AMAZON_SE_IOM_CDA11_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Controller Data Access Reg. (CH20)***/
+#define AMAZON_SE_IOM_CDA20                        ((volatile u32*)(AMAZON_SE_IOM+ 0x0108))
+#define AMAZON_SE_IOM_CDA20_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Controller Data Access Reg. (CH21)***/
+#define AMAZON_SE_IOM_CDA21                        ((volatile u32*)(AMAZON_SE_IOM+ 0x010C))
+#define AMAZON_SE_IOM_CDA21_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH10)***/
+#define AMAZON_SE_IOM_CDA_TSDP10                   ((volatile u32*)(AMAZON_SE_IOM+ 0x0110))
+#define AMAZON_SE_IOM_CDA_TSDP10_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CDA_TSDP10_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH11)***/
+#define AMAZON_SE_IOM_CDA_TSDP11                   ((volatile u32*)(AMAZON_SE_IOM+ 0x0114))
+#define AMAZON_SE_IOM_CDA_TSDP11_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CDA_TSDP11_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH20)***/
+#define AMAZON_SE_IOM_CDA_TSDP20                   ((volatile u32*)(AMAZON_SE_IOM+ 0x0118))
+#define AMAZON_SE_IOM_CDA_TSDP20_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CDA_TSDP20_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH21)***/
+#define AMAZON_SE_IOM_CDA_TSDP21                   ((volatile u32*)(AMAZON_SE_IOM+ 0x011C))
+#define AMAZON_SE_IOM_CDA_TSDP21_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CDA_TSDP21_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH10)***/
+#define AMAZON_SE_IOM_CO_TSDP10                    ((volatile u32*)(AMAZON_SE_IOM+ 0x0120))
+#define AMAZON_SE_IOM_CO_TSDP10_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CO_TSDP10_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH11)***/
+#define AMAZON_SE_IOM_CO_TSDP11                    ((volatile u32*)(AMAZON_SE_IOM+ 0x0124))
+#define AMAZON_SE_IOM_CO_TSDP11_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CO_TSDP11_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH20)***/
+#define AMAZON_SE_IOM_CO_TSDP20                    ((volatile u32*)(AMAZON_SE_IOM+ 0x0128))
+#define AMAZON_SE_IOM_CO_TSDP20_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CO_TSDP20_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH21)***/
+#define AMAZON_SE_IOM_CO_TSDP21                    ((volatile u32*)(AMAZON_SE_IOM+ 0x012C))
+#define AMAZON_SE_IOM_CO_TSDP21_DPS                              (1 << 7)
+#define AMAZON_SE_IOM_CO_TSDP21_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Ctrl. Reg. Contr. Data Access CH1x***/
+#define AMAZON_SE_IOM_CDA1_CR                      ((volatile u32*)(AMAZON_SE_IOM+ 0x0138))
+#define AMAZON_SE_IOM_CDA1_CR_EN_TBM                        (1 << 5)
+#define AMAZON_SE_IOM_CDA1_CR_EN_I1                          (1 << 4)
+#define AMAZON_SE_IOM_CDA1_CR_EN_I0                          (1 << 3)
+#define AMAZON_SE_IOM_CDA1_CR_EN_O1                          (1 << 2)
+#define AMAZON_SE_IOM_CDA1_CR_EN_O0                          (1 << 1)
+#define AMAZON_SE_IOM_CDA1_CR_SWAP                            (1 << 0)
+
+/***Ctrl. Reg. Contr. Data Access CH1x***/
+#define AMAZON_SE_IOM_CDA2_CR                      ((volatile u32*)(AMAZON_SE_IOM+ 0x013C))
+#define AMAZON_SE_IOM_CDA2_CR_EN_TBM                        (1 << 5)
+#define AMAZON_SE_IOM_CDA2_CR_EN_I1                          (1 << 4)
+#define AMAZON_SE_IOM_CDA2_CR_EN_I0                          (1 << 3)
+#define AMAZON_SE_IOM_CDA2_CR_EN_O1                          (1 << 2)
+#define AMAZON_SE_IOM_CDA2_CR_EN_O0                          (1 << 1)
+#define AMAZON_SE_IOM_CDA2_CR_SWAP                            (1 << 0)
+
+/***Control Register B-Channel Data***/
+#define AMAZON_SE_IOM_BCHA_CR                      ((volatile u32*)(AMAZON_SE_IOM+ 0x0144))
+#define AMAZON_SE_IOM_BCHA_CR_EN_BC2                        (1 << 4)
+#define AMAZON_SE_IOM_BCHA_CR_EN_BC1                        (1 << 3)
+
+/***Control Register B-Channel Data***/
+#define AMAZON_SE_IOM_BCHB_CR                      ((volatile u32*)(AMAZON_SE_IOM+ 0x0148))
+#define AMAZON_SE_IOM_BCHB_CR_EN_BC2                        (1 << 4)
+#define AMAZON_SE_IOM_BCHB_CR_EN_BC1                        (1 << 3)
+
+/***Control Reg. for HDLC and CI1 Data***/
+#define AMAZON_SE_IOM_DCI_CR                       ((volatile u32*)(AMAZON_SE_IOM+ 0x014C))
+#define AMAZON_SE_IOM_DCI_CR_DPS_CI1                      (1 << 7)
+#define AMAZON_SE_IOM_DCI_CR_EN_CI1                        (1 << 6)
+#define AMAZON_SE_IOM_DCI_CR_EN_D                            (1 << 5)
+
+/***Control Reg. for HDLC and CI1 Data***/
+#define AMAZON_SE_IOM_DCIC_CR                      ((volatile u32*)(AMAZON_SE_IOM+ 0x014C))
+#define AMAZON_SE_IOM_DCIC_CR_DPS_CI0                      (1 << 7)
+#define AMAZON_SE_IOM_DCIC_CR_EN_CI0                        (1 << 6)
+#define AMAZON_SE_IOM_DCIC_CR_DPS_D                          (1 << 5)
+
+/***Control Reg. Serial Data Strobe x***/
+#define AMAZON_SE_IOM_SDS_CR                       ((volatile u32*)(AMAZON_SE_IOM+ 0x0154))
+#define AMAZON_SE_IOM_SDS_CR_ENS_TSS                      (1 << 7)
+#define AMAZON_SE_IOM_SDS_CR_ENS_TSS_1                  (1 << 6)
+#define AMAZON_SE_IOM_SDS_CR_ENS_TSS_3                  (1 << 5)
+#define AMAZON_SE_IOM_SDS_CR_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Control Register IOM Data***/
+#define AMAZON_SE_IOM_IOM_CR                       ((volatile u32*)(AMAZON_SE_IOM+ 0x015C))
+#define AMAZON_SE_IOM_IOM_CR_SPU                              (1 << 7)
+#define AMAZON_SE_IOM_IOM_CR_CI_CS                          (1 << 5)
+#define AMAZON_SE_IOM_IOM_CR_TIC_DIS                      (1 << 4)
+#define AMAZON_SE_IOM_IOM_CR_EN_BCL                        (1 << 3)
+#define AMAZON_SE_IOM_IOM_CR_CLKM                            (1 << 2)
+#define AMAZON_SE_IOM_IOM_CR_Res                              (1 << 1)
+#define AMAZON_SE_IOM_IOM_CR_DIS_IOM                      (1 << 0)
+
+/***Synchronous Transfer Interrupt***/
+#define AMAZON_SE_IOM_STI                          ((volatile u32*)(AMAZON_SE_IOM+ 0x0160))
+#define AMAZON_SE_IOM_STI_STOV21                        (1 << 7)
+#define AMAZON_SE_IOM_STI_STOV20                        (1 << 6)
+#define AMAZON_SE_IOM_STI_STOV11                        (1 << 5)
+#define AMAZON_SE_IOM_STI_STOV10                        (1 << 4)
+#define AMAZON_SE_IOM_STI_STI21                          (1 << 3)
+#define AMAZON_SE_IOM_STI_STI20                          (1 << 2)
+#define AMAZON_SE_IOM_STI_STI11                          (1 << 1)
+#define AMAZON_SE_IOM_STI_STI10                          (1 << 0)
+
+/***Acknowledge Synchronous Transfer Interrupt***/
+#define AMAZON_SE_IOM_ASTI                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0160))
+#define AMAZON_SE_IOM_ASTI_ACK21                          (1 << 3)
+#define AMAZON_SE_IOM_ASTI_ACK20                          (1 << 2)
+#define AMAZON_SE_IOM_ASTI_ACK11                          (1 << 1)
+#define AMAZON_SE_IOM_ASTI_ACK10                          (1 << 0)
+
+/***Mask Synchronous Transfer Interrupt***/
+#define AMAZON_SE_IOM_MSTI                         ((volatile u32*)(AMAZON_SE_IOM+ 0x0164))
+#define AMAZON_SE_IOM_MSTI_STOV21                        (1 << 7)
+#define AMAZON_SE_IOM_MSTI_STOV20                        (1 << 6)
+#define AMAZON_SE_IOM_MSTI_STOV11                        (1 << 5)
+#define AMAZON_SE_IOM_MSTI_STOV10                        (1 << 4)
+#define AMAZON_SE_IOM_MSTI_STI21                          (1 << 3)
+#define AMAZON_SE_IOM_MSTI_STI20                          (1 << 2)
+#define AMAZON_SE_IOM_MSTI_STI11                          (1 << 1)
+#define AMAZON_SE_IOM_MSTI_STI10                          (1 << 0)
+
+/***Configuration Register for Serial Data Strobes***/
+#define AMAZON_SE_IOM_SDS_CONF                    ((volatile u32*)(AMAZON_SE_IOM+ 0x0168))
+#define AMAZON_SE_IOM_SDS_CONF_SDS_BCL                      (1 << 0)
+
+/***Monitoring CDA Bits***/
+#define AMAZON_SE_IOM_MCDA                         ((volatile u32*)(AMAZON_SE_IOM+ 0x016C))
+#define AMAZON_SE_IOM_MCDA_MCDA21 (value)             (((( 1 << 2) - 1) & (value)) << 6)
+#define AMAZON_SE_IOM_MCDA_MCDA20 (value)             (((( 1 << 2) - 1) & (value)) << 4)
+#define AMAZON_SE_IOM_MCDA_MCDA11 (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define AMAZON_SE_IOM_MCDA_MCDA10 (value)             (((( 1 << 2) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  ASC0 register address and bits                      */
+/***********************************************************************/
+#define AMAZON_SE_ASC0                          (KSEG1+0x1E100400)
+/***********************************************************************/
+#define AMAZON_SE_ASC0_TBUF                        ((volatile u32*)(AMAZON_SE_ASC0 + 0x0020))
+#define AMAZON_SE_ASC0_RBUF                        ((volatile u32*)(AMAZON_SE_ASC0 + 0x0024))
+#define AMAZON_SE_ASC0_FSTAT                       ((volatile u32*)(AMAZON_SE_ASC0 + 0x0048))
+#define AMAZON_SE_ASC0_FSTAT_TXFREE_GET(value)     (((value) >> 24) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC0_FSTAT_TXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 24)
+#define AMAZON_SE_ASC0_FSTAT_RXFREE_GET(value)     (((value) >> 16) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC0_FSTAT_RXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 16)
+#define AMAZON_SE_ASC0_FSTAT_TXFFL_GET(value)      (((value) >> 8) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC0_FSTAT_TXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC0_FSTAT_RXFFL_GET(value)      (((value) >> 0) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC0_FSTAT_RXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 0)
+
+
+/***********************************************************************/
+/*  Module      :  ASC1 register address and bits                      */
+/***********************************************************************/
+
+#define AMAZON_SE_ASC1                          (KSEG1+0x1E100C00)
+/***********************************************************************/
+/***ASC Clock Control Register***/
+#define AMAZON_SE_ASC1_CLC                      ((volatile u32*)(AMAZON_SE_ASC1+ 0x0000))
+#define AMAZON_SE_ASC1_CLC_RMC(value)                (((( 1 << 8) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC1_CLC_DISS                            (1 << 1)
+#define AMAZON_SE_ASC1_CLC_DISR                            (1 << 0)
+
+/***ASC Port Input Select Register***/
+#define AMAZON_SE_ASC1_PISEL                    ((volatile u32*)(AMAZON_SE_ASC1+ 0x0004))
+#define AMAZON_SE_ASC1_PISEL                    ((volatile u32*)(AMAZON_SE_ASC1+ 0x0004))
+#define AMAZON_SE_ASC1_PISEL_RIS                              (1 << 0)
+
+/***ASC Control Register***/
+#define AMAZON_SE_ASC1_CON                      ((volatile u32*)(AMAZON_SE_ASC1+ 0x0010))
+#define AMAZON_SE_ASC1_CON_BEN                              (1 << 20)
+#define AMAZON_SE_ASC1_CON_TOEN                              (1 << 20)
+#define AMAZON_SE_ASC1_CON_ROEN                              (1 << 19)
+#define AMAZON_SE_ASC1_CON_RUEN                              (1 << 18)
+#define AMAZON_SE_ASC1_CON_FEN                              (1 << 17)
+#define AMAZON_SE_ASC1_CON_PAL                              (1 << 16)
+#define AMAZON_SE_ASC1_CON_R                              (1 << 15)
+#define AMAZON_SE_ASC1_CON_ACO                             (1 << 14)
+#define AMAZON_SE_ASC1_CON_LB                              (1 << 13)
+#define AMAZON_SE_ASC1_CON_ERCLK                             (1 << 10)
+#define AMAZON_SE_ASC1_CON_FDE                              (1 << 9)
+#define AMAZON_SE_ASC1_CON_BRS                              (1 << 8)
+#define AMAZON_SE_ASC1_CON_STP                              (1 << 7)
+#define AMAZON_SE_ASC1_CON_SP                              (1 << 6)
+#define AMAZON_SE_ASC1_CON_ODD                              (1 << 5)
+#define AMAZON_SE_ASC1_CON_PEN                              (1 << 4)
+#define AMAZON_SE_ASC1_CON_M(value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***ASC Staus Register***/
+#define AMAZON_SE_ASC1_STATE                      ((volatile u32*)(AMAZON_SE_ASC1+ 0x0014))
+/***ASC Write Hardware Modified Control Register***/
+#define AMAZON_SE_ASC1_WHBSTATE                   ((volatile u32*)(AMAZON_SE_ASC1+ 0x0018))
+#define AMAZON_SE_ASC1_WHBSTATE_SETBE                          (1 << 113)
+#define AMAZON_SE_ASC1_WHBSTATE_SETTOE                          (1 << 12)
+#define AMAZON_SE_ASC1_WHBSTATE_SETROE                          (1 << 11)
+#define AMAZON_SE_ASC1_WHBSTATE_SETRUE                          (1 << 10)
+#define AMAZON_SE_ASC1_WHBSTATE_SETFE                          (1 << 19)
+#define AMAZON_SE_ASC1_WHBSTATE_SETPE                          (1 << 18)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRBE                          (1 << 17)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRTOE                          (1 << 6)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRROE                          (1 << 5)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRRUE                          (1 << 4)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRFE                          (1 << 3)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRPE                          (1 << 2)
+#define AMAZON_SE_ASC1_WHBSTATE_SETREN                        (1 << 1)
+#define AMAZON_SE_ASC1_WHBSTATE_CLRREN                        (1 << 0)
+
+/***ASC Baudrate Timer/Reload Register***/
+#define AMAZON_SE_ASC1_BG                      ((volatile u32*)(AMAZON_SE_ASC1+ 0x0050))
+#define AMAZON_SE_ASC1_BG_BR_VALUE(value)          (((( 1 << 13) - 1) & (value)) << 0)
+
+/***ASC Fractional Divider Register***/
+#define AMAZON_SE_ASC1_FDV                      ((volatile u32*)(AMAZON_SE_ASC1+ 0x0018))
+#define AMAZON_SE_ASC1_FDV_FD_VALUE(value)          (((( 1 << 9) - 1) & (value)) << 0)
+
+/***ASC Transmit Buffer Register***/
+#define AMAZON_SE_ASC1_TBUF                    ((volatile u32*)(AMAZON_SE_ASC1+ 0x0020))
+#define AMAZON_SE_ASC1_TBUF_TD_VALUE(value)          (((( 1 << 9) - 1) & (value)) << 0)
+
+/***ASC Receive Buffer Register***/
+#define AMAZON_SE_ASC1_RBUF                    ((volatile u32*)(AMAZON_SE_ASC1+ 0x0024))
+#define AMAZON_SE_ASC1_RBUF_RD_VALUE(value)          (((( 1 << 9) - 1) & (value)) << 0)
+
+/***ASC Autobaud Control Register***/
+#define AMAZON_SE_ASC1_ABCON                    ((volatile u32*)(AMAZON_SE_ASC1+ 0x0030))
+#define AMAZON_SE_ASC1_ABCON_RXINV                          (1 << 11)
+#define AMAZON_SE_ASC1_ABCON_TXINV                          (1 << 10)
+#define AMAZON_SE_ASC1_ABCON_ABEM(value)               (((( 1 << 2) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC1_ABCON_FCDETEN                      (1 << 4)
+#define AMAZON_SE_ASC1_ABCON_ABDETEN                      (1 << 3)
+#define AMAZON_SE_ASC1_ABCON_ABSTEN                        (1 << 2)
+#define AMAZON_SE_ASC1_ABCON_AUREN                          (1 << 1)
+#define AMAZON_SE_ASC1_ABCON_ABEN                            (1 << 0)
+
+/***Receive FIFO Control Register***/
+#define AMAZON_SE_ASC1_RXFCON                       ((volatile u32*)(AMAZON_SE_ASC1+ 0x0040))
+#define AMAZON_SE_ASC1_RXFCON_RXFITL(value)             (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC1_RXFCON_RXFFLU                        (1 << 1)
+#define AMAZON_SE_ASC1_RXFCON_RXFEN                          (1 << 0)
+
+/***Transmit FIFO Control Register***/
+#define AMAZON_SE_ASC1_TXFCON                       ((volatile u32*)(AMAZON_SE_ASC1+ 0x0044))
+#define AMAZON_SE_ASC1_TXFCON_TXFITL(value)             (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC1_TXFCON_TXFFLU                        (1 << 1)
+#define AMAZON_SE_ASC1_TXFCON_TXFEN                          (1 << 0)
+
+/***FIFO Status Register***/
+#define AMAZON_SE_ASC1_FSTAT                        ((volatile u32*)(AMAZON_SE_ASC1+ 0x0048))
+#define AMAZON_SE_ASC1_FSTAT_TXFFL(value)              (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC1_FSTAT_RXFFL(value)              (((( 1 << 6) - 1) & (value)) << 0)
+#define AMAZON_SE_ASC1_FSTAT_TXFREE_GET(value)     (((value) >> 24) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC1_FSTAT_TXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 24)
+#define AMAZON_SE_ASC1_FSTAT_RXFREE_GET(value)     (((value) >> 16) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC1_FSTAT_RXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 16)
+#define AMAZON_SE_ASC1_FSTAT_TXFFL_GET(value)      (((value) >> 8) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC1_FSTAT_TXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 8)
+#define AMAZON_SE_ASC1_FSTAT_RXFFL_GET(value)      (((value) >> 0) & ((1 << 6) - 1))
+#define AMAZON_SE_ASC1_FSTAT_RXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 0)
+
+
+/***ASC Autobaud Status Register***/
+#define AMAZON_SE_ASC1_ABSTAT                   ((volatile u32*)(AMAZON_SE_ASC1+ 0x0034))
+#define AMAZON_SE_ASC1_ABSTAT_DETWAIT                      (1 << 4)
+#define AMAZON_SE_ASC1_ABSTAT_SCCDET                        (1 << 3)
+#define AMAZON_SE_ASC1_ABSTAT_SCSDET                        (1 << 2)
+#define AMAZON_SE_ASC1_ABSTAT_FCCDET                        (1 << 1)
+#define AMAZON_SE_ASC1_ABSTAT_FCSDET                        (1 << 0)
+
+/***ASC Write HW Modified Autobaud Status Register***/
+#define AMAZON_SE_ASC1_WHBABSTAT                 ((volatile u32*)(AMAZON_SE_ASC1+ 0x003C))
+#define AMAZON_SE_ASC1_WHBABSTAT_SETDETWAIT                (1 << 9)
+#define AMAZON_SE_ASC1_WHBABSTAT_CLRDETWAIT                (1 << 8)
+#define AMAZON_SE_ASC1_WHBABSTAT_SETSCCDET                  (1 << 7)
+#define AMAZON_SE_ASC1_WHBABSTAT_CLRSCCDET                  (1 << 6)
+#define AMAZON_SE_ASC1_WHBABSTAT_SETSCSDET                  (1 << 5)
+#define AMAZON_SE_ASC1_WHBABSTAT_CLRSCSDET                  (1 << 4)
+#define AMAZON_SE_ASC1_WHBABSTAT_SETFCCDET                  (1 << 3)
+#define AMAZON_SE_ASC1_WHBABSTAT_CLRFCCDET                  (1 << 2)
+#define AMAZON_SE_ASC1_WHBABSTAT_SETFCSDET                  (1 << 1)
+#define AMAZON_SE_ASC1_WHBABSTAT_CLRFCSDET                  (1 << 0)
+
+/***ASC IRNCR0 **/
+#define AMAZON_SE_ASC1_IRNREN			((volatile u32*)(AMAZON_SE_ASC1+ 0x00F4))
+#define AMAZON_SE_ASC1_IRNICR			((volatile u32*)(AMAZON_SE_ASC1+ 0x00FC))
+/***ASC IRNCR1 **/
+#define AMAZON_SE_ASC1_IRNCR			((volatile u32*)(AMAZON_SE_ASC1+ 0x00F8))
+#define ASC_IRNCR_TIR	0x1
+#define ASC_IRNCR_RIR	0x2
+#define ASC_IRNCR_EIR	0x4
+
+
+/***********************************************************************/
+/*  Module      :  DMA register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_DMA                          (0xBE104100)
+/***********************************************************************/
+
+#define AMAZON_SE_DMA_BASE                 AMAZON_SE_DMA
+#define AMAZON_SE_DMA_CLC                  (volatile u32*)AMAZON_SE_DMA_BASE
+#define AMAZON_SE_DMA_ID                   (volatile u32*)(AMAZON_SE_DMA_BASE+0x08)
+#define AMAZON_SE_DMA_CTRL                 (volatile u32*)(AMAZON_SE_DMA_BASE+0x10)
+#define AMAZON_SE_DMA_CPOLL                (volatile u32*)(AMAZON_SE_DMA_BASE+0x14)
+#define AMAZON_SE_DMA_CS                   (volatile u32*)(AMAZON_SE_DMA_BASE+0x18)
+#define AMAZON_SE_DMA_CCTRL                (volatile u32*)(AMAZON_SE_DMA_BASE+0x1C)
+#define AMAZON_SE_DMA_CDBA                 (volatile u32*)(AMAZON_SE_DMA_BASE+0x20)
+#define AMAZON_SE_DMA_CDLEN                (volatile u32*)(AMAZON_SE_DMA_BASE+0x24)
+#define AMAZON_SE_DMA_CIS                  (volatile u32*)(AMAZON_SE_DMA_BASE+0x28)
+#define AMAZON_SE_DMA_CIE                  (volatile u32*)(AMAZON_SE_DMA_BASE+0x2C)
+
+#define AMAZON_SE_DMA_PS                   (volatile u32*)(AMAZON_SE_DMA_BASE+0x40)
+#define AMAZON_SE_DMA_PCTRL                (volatile u32*)(AMAZON_SE_DMA_BASE+0x44)
+
+#define AMAZON_SE_DMA_IRNEN                (volatile u32*)(AMAZON_SE_DMA_BASE+0xf4)
+#define AMAZON_SE_DMA_IRNCR                (volatile u32*)(AMAZON_SE_DMA_BASE+0xf8)
+#define AMAZON_SE_DMA_IRNICR               (volatile u32*)(AMAZON_SE_DMA_BASE+0xfc)
+/***********************************************************************/
+/*  Module      :  Debug register address and bits                     */
+/***********************************************************************/
+
+#define AMAZON_SE_Debug                        (0xBF106000)
+/***********************************************************************/
+
+
+/***MCD Break Bus Switch Register***/
+#define AMAZON_SE_Debug_MCD_BBS                      ((volatile u32*)(AMAZON_SE_Debug+ 0x0000))
+#define AMAZON_SE_Debug_MCD_BBS_BTP1                            (1 << 19)
+#define AMAZON_SE_Debug_MCD_BBS_BTP0                            (1 << 18)
+#define AMAZON_SE_Debug_MCD_BBS_BSP1                            (1 << 17)
+#define AMAZON_SE_Debug_MCD_BBS_BSP0                            (1 << 16)
+#define AMAZON_SE_Debug_MCD_BBS_BT5EN                          (1 << 15)
+#define AMAZON_SE_Debug_MCD_BBS_BT4EN                          (1 << 14)
+#define AMAZON_SE_Debug_MCD_BBS_BT5                              (1 << 13)
+#define AMAZON_SE_Debug_MCD_BBS_BT4                              (1 << 12)
+#define AMAZON_SE_Debug_MCD_BBS_BS5EN                          (1 << 7)
+#define AMAZON_SE_Debug_MCD_BBS_BS4EN                          (1 << 6)
+#define AMAZON_SE_Debug_MCD_BBS_BS5                              (1 << 5)
+#define AMAZON_SE_Debug_MCD_BBS_BS4                              (1 << 4)
+
+/***MCD Multiplexer Control Register***/
+#define AMAZON_SE_Debug_MCD_MCR                      ((volatile u32*)(AMAZON_SE_Debug+ 0x0008))
+#define AMAZON_SE_Debug_MCD_MCR_MUX5                            (1 << 4)
+#define AMAZON_SE_Debug_MCD_MCR_MUX4                            (1 << 3)
+#define AMAZON_SE_Debug_MCD_MCR_MUX1                            (1 << 0)
+
+
+/***********************************************************************/
+/*  Module      :  SRAM register address and bits                      */
+/***********************************************************************/
+
+#define AMAZON_SE_SRAM                         (0xBF980000)
+/***********************************************************************/
+
+
+/***SRAM Size Register***/
+#define AMAZON_SE_SRAM_SRAM_SIZE                    ((volatile u32*)(AMAZON_SE_SRAM+ 0x0800))
+#define AMAZON_SE_SRAM_SRAM_SIZE_SIZE (value)               (((( 1 << 23) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  BIU register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_BIU                          (0xBFA80000)
+/***********************************************************************/
+
+
+/***BIU Identification Register***/
+#define AMAZON_SE_BIU_BIU_ID                       ((volatile u32*)(AMAZON_SE_BIU+ 0x0000))
+#define AMAZON_SE_BIU_BIU_ID_ARCH                            (1 << 16)
+#define AMAZON_SE_BIU_BIU_ID_ID (value)                (((( 1 << 8) - 1) & (value)) << 8)
+#define AMAZON_SE_BIU_BIU_ID_REV (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***BIU Access Error Cause Register***/
+#define AMAZON_SE_BIU_BIU_ERRCAUSE                 ((volatile u32*)(AMAZON_SE_BIU+ 0x0100))
+#define AMAZON_SE_BIU_BIU_ERRCAUSE_ERR                              (1 << 31)
+#define AMAZON_SE_BIU_BIU_ERRCAUSE_PORT (value)               (((( 1 << 4) - 1) & (value)) << 16)
+#define AMAZON_SE_BIU_BIU_ERRCAUSE_CAUSE (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***BIU Access Error Address Register***/
+#define AMAZON_SE_BIU_BIU_ERRADDR                  ((volatile u32*)(AMAZON_SE_BIU+ 0x0108))
+#define AMAZON_SE_BIU_BIU_ERRADDR_ADDR
+
+
+/***********************************************************************/
+/*  Module      :  ICU register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_ICU                          (0xBF880200)
+/***********************************************************************/
+#define AMAZON_SE_ICU_IM0_ISR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0000))
+#define AMAZON_SE_ICU_IM0_IER                      ((volatile u32*)(AMAZON_SE_ICU + 0x0008))
+#define AMAZON_SE_ICU_IM0_IOSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0010))
+#define AMAZON_SE_ICU_IM0_IRSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0018))
+#define AMAZON_SE_ICU_IM0_IMR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0020))
+#define AMAZON_SE_ICU_IM0_IMR_IID                  (1 << 31)
+#define AMAZON_SE_ICU_IM0_IMR_IN_GET(value)        (((value) >> 0) & ((1 << 5) - 1))
+#define AMAZON_SE_ICU_IM0_IMR_IN_SET(value)        (((( 1 << 5) - 1) & (value)) << 0)
+#define AMAZON_SE_ICU_IM0_IR(value)                (1 << (value))
+
+#define AMAZON_SE_ICU_IM1_ISR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0028))
+#define AMAZON_SE_ICU_IM1_IER                      ((volatile u32*)(AMAZON_SE_ICU + 0x0030))
+#define AMAZON_SE_ICU_IM1_IOSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0038))
+#define AMAZON_SE_ICU_IM1_IRSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0040))
+#define AMAZON_SE_ICU_IM1_IMR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0048))
+#define AMAZON_SE_ICU_IM1_IMR_IID                  (1 << 31)
+#define AMAZON_SE_ICU_IM1_IMR_IN_GET(value)        (((value) >> 0) & ((1 << 5) - 1))
+#define AMAZON_SE_ICU_IM1_IMR_IN_SET(value)        (((( 1 << 5) - 1) & (value)) << 0)
+#define AMAZON_SE_ICU_IM1_IR(value)                (1 << (value))
+
+#define AMAZON_SE_ICU_IM2_ISR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0050))
+#define AMAZON_SE_ICU_IM2_IER                      ((volatile u32*)(AMAZON_SE_ICU + 0x0058))
+#define AMAZON_SE_ICU_IM2_IOSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0060))
+#define AMAZON_SE_ICU_IM2_IRSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0068))
+#define AMAZON_SE_ICU_IM2_IMR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0070))
+#define AMAZON_SE_ICU_IM2_IMR_IID                  (1 << 31)
+#define AMAZON_SE_ICU_IM2_IMR_IN_GET(value)        (((value) >> 0) & ((1 << 5) - 1))
+#define AMAZON_SE_ICU_IM2_IMR_IN_SET(value)        (((( 1 << 5) - 1) & (value)) << 0)
+#define AMAZON_SE_ICU_IM2_IR(value)                (1 << (value))
+
+#define AMAZON_SE_ICU_IM3_ISR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0078))
+#define AMAZON_SE_ICU_IM3_IER                      ((volatile u32*)(AMAZON_SE_ICU + 0x0080))
+#define AMAZON_SE_ICU_IM3_IOSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0088))
+#define AMAZON_SE_ICU_IM3_IRSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x0090))
+#define AMAZON_SE_ICU_IM3_IMR                      ((volatile u32*)(AMAZON_SE_ICU + 0x0098))
+#define AMAZON_SE_ICU_IM3_IMR_IID                  (1 << 31)
+#define AMAZON_SE_ICU_IM3_IMR_IN_GET(value)        (((value) >> 0) & ((1 << 5) - 1))
+#define AMAZON_SE_ICU_IM3_IMR_IN_SET(value)        (((( 1 << 5) - 1) & (value)) << 0)
+#define AMAZON_SE_ICU_IM3_IR(value)                (1 << (value))
+
+#define AMAZON_SE_ICU_IM4_ISR                      ((volatile u32*)(AMAZON_SE_ICU + 0x00A0))
+#define AMAZON_SE_ICU_IM4_IER                      ((volatile u32*)(AMAZON_SE_ICU + 0x00A8))
+#define AMAZON_SE_ICU_IM4_IOSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x00B0))
+#define AMAZON_SE_ICU_IM4_IRSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x00B8))
+#define AMAZON_SE_ICU_IM4_IMR                      ((volatile u32*)(AMAZON_SE_ICU + 0x00C0))
+#define AMAZON_SE_ICU_IM4_IMR_IID                  (1 << 31)
+#define AMAZON_SE_ICU_IM4_IMR_IN_GET(value)        (((value) >> 0) & ((1 << 5) - 1))
+#define AMAZON_SE_ICU_IM4_IMR_IN_SET(value)        (((( 1 << 5) - 1) & (value)) << 0)
+#define AMAZON_SE_ICU_IM4_IR(value)                (1 << (value))
+
+#define AMAZON_SE_ICU_IM5_ISR                      ((volatile u32*)(AMAZON_SE_ICU + 0x00C8))
+#define AMAZON_SE_ICU_IM5_IER                      ((volatile u32*)(AMAZON_SE_ICU + 0x00D0))
+#define AMAZON_SE_ICU_IM5_IOSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x00D8))
+#define AMAZON_SE_ICU_IM5_IRSR                     ((volatile u32*)(AMAZON_SE_ICU + 0x00E0))
+#define AMAZON_SE_ICU_IM5_IMR                      ((volatile u32*)(AMAZON_SE_ICU + 0x00E8))
+#define AMAZON_SE_ICU_IM5_IMR_IID                  (1 << 31)
+#define AMAZON_SE_ICU_IM5_IMR_IN_GET(value)        (((value) >> 0) & ((1 << 5) - 1))
+#define AMAZON_SE_ICU_IM5_IMR_IN_SET(value)        (((( 1 << 5) - 1) & (value)) << 0)
+#define AMAZON_SE_ICU_IM5_IR(value)                (1 << (value))
+
+/***Interrupt Vector Value Register***/
+#define AMAZON_SE_ICU_IM_VEC                      ((volatile u32*)(AMAZON_SE_ICU+ 0x00f0))
+
+/***Interrupt Vector Value Mask***/
+#define AMAZON_SE_ICU_IM0_VEC_MASK                0x0000001f
+#define AMAZON_SE_ICU_IM1_VEC_MASK                0x000003e0
+#define AMAZON_SE_ICU_IM2_VEC_MASK                0x00007c00
+#define AMAZON_SE_ICU_IM3_VEC_MASK                0x000f8000
+#define AMAZON_SE_ICU_IM4_VEC_MASK                0x01f00000
+
+#define AMAZON_SE_ICU_IM0_ISR_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM0_IER_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM1_ISR_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM1_IER_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM2_ISR_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM2_IER_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM3_ISR_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM3_IER_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM4_ISR_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM4_IER_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM5_ISR_IR(value)          (1<<(value))
+#define AMAZON_SE_ICU_IM5_IER_IR(value)          (1<<(value))
+
+/***DMA Interrupt Mask Value***/
+#define AMAZON_SE_DMA_H_MASK			0x00000fff
+
+/***External Interrupt Control Register***/
+#define AMAZON_SE_ICU_EIU                    (KSEG1+0x1f101000)
+#define AMAZON_SE_ICU_EIU_EXIN_C                ((volatile u32*)(AMAZON_SE_ICU_EIU+ 0x0000))
+#define AMAZON_SE_ICU_EIU_INIC                  ((volatile u32*)(AMAZON_SE_ICU_EIU+ 0x0004))
+#define AMAZON_SE_ICU_EIU_INC                   ((volatile u32*)(AMAZON_SE_ICU_EIU+ 0x0008))
+#define AMAZON_SE_ICU_EIU_INEN                   ((volatile u32*)(AMAZON_SE_ICU_EIU+ 0x000c))
+
+
+/***********************************************************************/
+/*  Module      :  MPS register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_MPS                          (KSEG1+0x1F107000)
+/***********************************************************************/
+
+#define AMAZON_SE_MPS_CHIPID                       ((volatile u32*)(AMAZON_SE_MPS + 0x0344))
+#define AMAZON_SE_MPS_CHIPID_VERSION_GET(value)    (((value) >> 28) & ((1 << 4) - 1))
+#define AMAZON_SE_MPS_CHIPID_VERSION_SET(value)    (((( 1 << 4) - 1) & (value)) << 28)
+#define AMAZON_SE_MPS_CHIPID_PARTNUM_GET(value)    (((value) >> 12) & ((1 << 16) - 1))
+#define AMAZON_SE_MPS_CHIPID_PARTNUM_SET(value)    (((( 1 << 16) - 1) & (value)) << 12)
+#define AMAZON_SE_MPS_CHIPID_MANID_GET(value)      (((value) >> 1) & ((1 << 10) - 1))
+#define AMAZON_SE_MPS_CHIPID_MANID_SET(value)      (((( 1 << 10) - 1) & (value)) << 1)
+
+
+/* voice channel 0 ... 3 interrupt enable register */
+#define AMAZON_SE_MPS_VC0ENR ((volatile u32*)(AMAZON_SE_MPS + 0x0000))
+#define AMAZON_SE_MPS_VC1ENR ((volatile u32*)(AMAZON_SE_MPS + 0x0004))
+#define AMAZON_SE_MPS_VC2ENR ((volatile u32*)(AMAZON_SE_MPS + 0x0008))
+#define AMAZON_SE_MPS_VC3ENR ((volatile u32*)(AMAZON_SE_MPS + 0x000C))
+/* voice channel 0 ... 3 interrupt status read register */
+#define AMAZON_SE_MPS_RVC0SR ((volatile u32*)(AMAZON_SE_MPS + 0x0010))
+#define AMAZON_SE_MPS_RVC1SR ((volatile u32*)(AMAZON_SE_MPS + 0x0014))
+#define AMAZON_SE_MPS_RVC2SR ((volatile u32*)(AMAZON_SE_MPS + 0x0018))
+#define AMAZON_SE_MPS_RVC3SR ((volatile u32*)(AMAZON_SE_MPS + 0x001C))
+/* voice channel 0 ... 3 interrupt status set register */
+#define AMAZON_SE_MPS_SVC0SR ((volatile u32*)(AMAZON_SE_MPS + 0x0020))
+#define AMAZON_SE_MPS_SVC1SR ((volatile u32*)(AMAZON_SE_MPS + 0x0024))
+#define AMAZON_SE_MPS_SVC2SR ((volatile u32*)(AMAZON_SE_MPS + 0x0028))
+#define AMAZON_SE_MPS_SVC3SR ((volatile u32*)(AMAZON_SE_MPS + 0x002C))
+/* voice channel 0 ... 3 interrupt status clear register */
+#define AMAZON_SE_MPS_CVC0SR ((volatile u32*)(AMAZON_SE_MPS + 0x0030))
+#define AMAZON_SE_MPS_CVC1SR ((volatile u32*)(AMAZON_SE_MPS + 0x0034))
+#define AMAZON_SE_MPS_CVC2SR ((volatile u32*)(AMAZON_SE_MPS + 0x0038))
+#define AMAZON_SE_MPS_CVC3SR ((volatile u32*)(AMAZON_SE_MPS + 0x003C))
+/* common status 0 and 1 read register */
+#define AMAZON_SE_MPS_RAD0SR ((volatile u32*)(AMAZON_SE_MPS + 0x0040))
+#define AMAZON_SE_MPS_RAD1SR ((volatile u32*)(AMAZON_SE_MPS + 0x0044))
+/* common status 0 and 1 set register */
+#define AMAZON_SE_MPS_SAD0SR ((volatile u32*)(AMAZON_SE_MPS + 0x0048))
+#define AMAZON_SE_MPS_SAD1SR ((volatile u32*)(AMAZON_SE_MPS + 0x004C))
+/* common status 0 and 1 clear register */
+#define AMAZON_SE_MPS_CAD0SR ((volatile u32*)(AMAZON_SE_MPS + 0x0050))
+#define AMAZON_SE_MPS_CAD1SR ((volatile u32*)(AMAZON_SE_MPS + 0x0054))
+/* common status 0 and 1 enable register */
+#define AMAZON_SE_MPS_AD0ENR ((volatile u32*)(AMAZON_SE_MPS + 0x0058))
+#define AMAZON_SE_MPS_AD1ENR ((volatile u32*)(AMAZON_SE_MPS + 0x005C))
+/* notification enable register */
+#define AMAZON_SE_MPS_CPU0_NFER ((volatile u32*)(AMAZON_SE_MPS + 0x0060))
+#define AMAZON_SE_MPS_CPU1_NFER ((volatile u32*)(AMAZON_SE_MPS + 0x0064))
+/* CPU to CPU interrup request register */
+#define AMAZON_SE_MPS_CPU0_2_CPU1_IRR ((volatile u32*)(AMAZON_SE_MPS + 0x0070))
+#define AMAZON_SE_MPS_CPU0_2_CPU1_IER ((volatile u32*)(AMAZON_SE_MPS + 0x0074))
+/* Global interrupt request and request enable register */
+#define AMAZON_SE_MPS_GIRR ((volatile u32*)(AMAZON_SE_MPS + 0x0078))
+#define AMAZON_SE_MPS_GIER ((volatile u32*)(AMAZON_SE_MPS + 0x007C))
+
+#define AMAZON_SE_MPS_SRAM ((volatile u32*)(KSEG1 + 0x1F200000))
+
+#define AMAZON_SE_MPS_VCPU_FW_AD ((volatile u32*)(KSEG1 + 0x1F2001E0))
+
+#define AMAZON_SE_FUSE_BASE_ADDR	(KSEG1+0x1F107354)
+
+/************************************************************************/
+/*   Module       :   DEU register address and bits        		*/
+/************************************************************************/
+//#define AMAZON_SE_DEU_BASE_ADDR               (0xBE102000)
+#define AMAZON_SE_DEU_BASE_ADDR               (KSEG1 + 0x1E103100)
+/*   DEU Control Register */
+#define AMAZON_SE_DEU_CLK                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0000))
+#define AMAZON_SE_DEU_ID                      ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0008))
+
+/*   DEU control register */
+#define AMAZON_SE_DES_CON                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0010))
+#define AMAZON_SE_DES_IHR                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0014))
+#define AMAZON_SE_DES_ILR                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0018))
+#define AMAZON_SE_DES_K1HR                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x001C))
+#define AMAZON_SE_DES_K1LR                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0020))
+#define AMAZON_SE_DES_K3HR                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0024))
+#define AMAZON_SE_DES_K3LR                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0028))
+#define AMAZON_SE_DES_IVHR                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x002C))
+#define AMAZON_SE_DES_IVLR                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0030))
+#define AMAZON_SE_DES_OHR                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0040))
+#define AMAZON_SE_DES_OLR                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0050))
+
+/* AES DEU register */
+#define AMAZON_SE_AES_CON 			   ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0050))
+#define AMAZON_SE_AES_ID3R                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0054))
+#define AMAZON_SE_AES_ID2R                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0058))
+#define AMAZON_SE_AES_ID1R                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x005C))
+#define AMAZON_SE_AES_ID0R                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0060))
+
+/* AES Key register */
+#define AMAZON_SE_AES_K7R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0064))
+#define AMAZON_SE_AES_K6R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0068))
+#define AMAZON_SE_AES_K5R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x006C))
+#define AMAZON_SE_AES_K4R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0070))
+#define AMAZON_SE_AES_K3R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0074))
+#define AMAZON_SE_AES_K2R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0078))
+#define AMAZON_SE_AES_K1R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x007C))
+#define AMAZON_SE_AES_K0R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0080))
+
+/* AES vector register */
+#define AMAZON_SE_AES_IV3R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0084))
+#define AMAZON_SE_AES_IV2R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0088))
+#define AMAZON_SE_AES_IV1R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x008C))
+#define AMAZON_SE_AES_IV0R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0090))
+#define AMAZON_SE_AES_0D3R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0094))
+#define AMAZON_SE_AES_0D2R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x0098))
+#define AMAZON_SE_AES_OD1R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x009C))
+#define AMAZON_SE_AES_OD0R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00A0))
+
+/* hash control registe */
+#define AMAZON_SE_HASH_CON                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00B0))
+#define AMAZON_SE_HASH_MR                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00B4))
+#define AMAZON_SE_HASH_D1R                    ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00B8 ))
+#define AMAZON_SE_HASH_D2R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00BC ))
+#define AMAZON_SE_HASH_D3R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00C0 ))
+#define AMAZON_SE_HASH_D4R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00C4))
+#define AMAZON_SE_HASH_D5R                     ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00C8))
+
+#define AMAZON_SE_CON                         ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00EC))
+
+#define AMAZON_SE_DEU_IRNEN                         ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00F4))
+#define AMAZON_SE_DEU_IRNCR                         ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00F8))
+#define AMAZON_SE_DEU_IRNICR                         ((volatile u32 *)(AMAZON_SE_DEU_BASE_ADDR + 0x00FC))
+
+
+
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define AMAZON_SE_PPE32_BASE  0xBE180000
+#define AMAZON_SE_PPE32_DEBUG_BREAK_TRACE_REG   (AMAZON_SE_PPE32_BASE + (0x0000 * 4))
+#define AMAZON_SE_PPE32_INT_MASK_STATUS_REG     (AMAZON_SE_PPE32_BASE + (0x0030 * 4))
+#define AMAZON_SE_PPE32_INT_RESOURCE_REG        (AMAZON_SE_PPE32_BASE + (0x0040 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B0         (AMAZON_SE_PPE32_BASE + (0x1000 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B1         (AMAZON_SE_PPE32_BASE + (0x2000 * 4))
+#define AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE   (AMAZON_SE_PPE32_BASE + (0x4000 * 4))
+
+#define AMAZON_SE_PPE32_SRST		     (AMAZON_SE_PPE32_BASE + 0x10080)
+
+/*
+ *    ETOP MDIO Registers
+ */
+#define AMAZON_SE_PPE32_ETOP_MDIO_CFG           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0600 * 4)))
+#define AMAZON_SE_PPE32_ETOP_MDIO_ACC           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0601 * 4)))
+#define AMAZON_SE_PPE32_ETOP_CFG                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0602 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_VLAN_COS        ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0603 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS3       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0604 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS2       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0605 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS1       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0606 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS0       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0607 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_PLEN_CTRL       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0608 * 4)))
+#define AMAZON_SE_PPE32_ETOP_ISR                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060A * 4)))
+#define AMAZON_SE_PPE32_ETOP_IER                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060B * 4)))
+#define AMAZON_SE_PPE32_ETOP_VPID               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060C * 4)))
+
+
+/* ENET Register */
+#define AMAZON_SE_PPE32_ENET_MAC_CFG            	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define AMAZON_SE_PPE32_ENET_IG_PKTDROP          	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define AMAZON_SE_PPE32_ENET_CoS_CFG          	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+
+/* Sharebuff SB RAM2 control data */
+
+#define AMAZON_SE_PPE32_SB2_DATABASE  	((AMAZON_SE_PPE32_BASE + (0x8C00 * 4)))
+#define AMAZON_SE_PPE32_SB2_CTRLBASE  	((AMAZON_SE_PPE32_BASE + (0x92E0 * 4)))
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define AMAZON_SE_PPE32_BASE  0xBE180000
+#define AMAZON_SE_PPE32_DEBUG_BREAK_TRACE_REG   (AMAZON_SE_PPE32_BASE + (0x0000 * 4))
+#define AMAZON_SE_PPE32_INT_MASK_STATUS_REG     (AMAZON_SE_PPE32_BASE + (0x0030 * 4))
+#define AMAZON_SE_PPE32_INT_RESOURCE_REG        (AMAZON_SE_PPE32_BASE + (0x0040 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B0         (AMAZON_SE_PPE32_BASE + (0x1000 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B1         (AMAZON_SE_PPE32_BASE + (0x2000 * 4))
+#define AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE   (AMAZON_SE_PPE32_BASE + (0x4000 * 4))
+
+/*
+ *    ETOP MDIO Registers
+ */
+#define ETOP_MDIO_CFG           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0600 * 4)))
+#define ETOP_MDIO_ACC           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0601 * 4)))
+#define ETOP_CFG                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0602 * 4)))
+#define ETOP_IG_VLAN_COS        ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0603 * 4)))
+#define ETOP_IG_DSCP_COS3       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0604 * 4)))
+#define ETOP_IG_DSCP_COS2       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0605 * 4)))
+#define ETOP_IG_DSCP_COS1       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0606 * 4)))
+#define ETOP_IG_DSCP_COS0       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0607 * 4)))
+#define ETOP_IG_PLEN_CTRL       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0608 * 4)))
+#define ETOP_ISR                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060A * 4)))
+#define ETOP_IER                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060B * 4)))
+#define ETOP_VPID               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060C * 4)))
+#define ENET_MAC_CFG            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define ENETS_DBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0612 * 4)))
+#define ENETS_CBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0613 * 4)))
+#define ENETS_CFG               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0614 * 4)))
+#define ENETS_PGCNT             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0615 * 4)))
+#define ENETS_PKTCNT            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0616 * 4)))
+#define ENETS_BUF_CTRL          ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0617 * 4)))
+#define ENETS_COS_CFG           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+#define ENETS_IGDROP            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define ENETS_IGERR             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061A * 4)))
+#define ENET_MAC_DA0           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061B * 4)))
+#define ENET_MAC_DA1           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061C * 4)))
+
+#define ENETF_DBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0630 * 4)))
+#define ENETF_CBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0631 * 4)))
+#define ENETF_CFG               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0632 * 4)))
+#define ENETF_PGCNT             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0633 * 4)))
+#define ENETF_PKTCNT            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0634 * 4)))
+#define ENETF_HFCTRL            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0635 * 4)))
+#define ENETF_TXCTRL            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0636 * 4)))
+
+#define ENETF_VLCOS0            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0638 * 4)))
+#define ENETF_VLCOS1            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0639 * 4)))
+#define ENETF_VLCOS2            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063A * 4)))
+#define ENETF_VLCOS3            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063B * 4)))
+#define ENETF_EGERR             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063C * 4)))
+#define ENETF_EGDROP            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063D * 4)))
+
+/* ENET Register */
+#define AMAZON_SE_PPE32_ENET_MAC_CFG            	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define AMAZON_SE_PPE32_ENET_IG_PKTDROP          	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define AMAZON_SE_PPE32_ENET_CoS_CFG          	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+
+/* Sharebuff SB RAM2 control data */
+
+#define AMAZON_SE_PPE32_SB2_DATABASE  	((AMAZON_SE_PPE32_BASE + (0x8C00 * 4)))
+#define AMAZON_SE_PPE32_SB2_CTRLBASE  	((AMAZON_SE_PPE32_BASE + (0x92E0 * 4)))
+
+
+
+/***********************************************************************/
+/*  Module      :  PCI register address and bits                       */
+/***********************************************************************/
+#define PCI_CR_PR_OFFSET            (KSEG1+0x1E105400)
+#define PCI_CFG_BASE      		      (KSEG1+0x17000000)
+#define PCI_MEM_BASE      		      (KSEG1+0x18000000)
+#define PCI_CS_PR_OFFSET            (KSEG1+0x17000000)
+
+/* PCI CONTROLLER REGISTER ADDRESS MAP */
+#define PCI_CR_CLK_CTRL_REG         (PCI_CR_PR_OFFSET + 0x0000)
+#define PCI_CR_PCI_ID_REG	        (PCI_CR_PR_OFFSET + 0x0004)
+#define PCI_CR_SFT_RST_REG	        (PCI_CR_PR_OFFSET + 0x0010)
+#define PCI_CR_PCI_FPI_ERR_ADDR_REG (PCI_CR_PR_OFFSET + 0x0014)
+#define PCI_CR_FCI_PCI_ERR_ADDR_REG (PCI_CR_PR_OFFSET + 0x0018)
+#define PCI_CR_FPI_ERR_TAG_REG	    (PCI_CR_PR_OFFSET + 0x001C)
+#define PCI_CR_PCI_IRR_REG	        (PCI_CR_PR_OFFSET + 0x0020)
+#define PCI_CR_PCI_IRA_REG	        (PCI_CR_PR_OFFSET + 0x0024)
+#define PCI_CR_PCI_IRM_REG	        (PCI_CR_PR_OFFSET + 0x0028)
+#define PCI_CR_PCI_EOI_REG	        (PCI_CR_PR_OFFSET + 0x002C)
+#define PCI_CR_PCI_MOD_REG 	        (PCI_CR_PR_OFFSET + 0x0030)
+#define PCI_CR_DV_ID_REG	        (PCI_CR_PR_OFFSET + 0x0034)
+#define PCI_CR_SUBSYS_ID_REG	    (PCI_CR_PR_OFFSET + 0x0038)
+#define PCI_CR_PCI_PM_REG           (PCI_CR_PR_OFFSET + 0x003C)
+#define PCI_CR_CLASS_CODE1_REG      (PCI_CR_PR_OFFSET + 0x0040)
+#define PCI_CR_BAR11MASK_REG	    (PCI_CR_PR_OFFSET + 0x0044)
+#define PCI_CR_BAR12MASK_REG        (PCI_CR_PR_OFFSET + 0x0048)
+#define PCI_CR_BAR13MASK_REG        (PCI_CR_PR_OFFSET + 0x004C)
+#define PCI_CR_BAR14MASK_REG        (PCI_CR_PR_OFFSET + 0x0050)
+#define PCI_CR_BAR15MASK_REG        (PCI_CR_PR_OFFSET + 0x0054)
+#define PCI_CR_BAR16MASK_REG        (PCI_CR_PR_OFFSET + 0x0058)
+#define PCI_CR_CIS_PT1_REG	        (PCI_CR_PR_OFFSET + 0x005C)
+#define PCI_CR_SUBSYS_ID1_REG	    (PCI_CR_PR_OFFSET + 0x0060)
+#define PCI_CR_PCI_ADDR_MAP11_REG   (PCI_CR_PR_OFFSET + 0x0064)
+#define PCI_CR_PCI_ADDR_MAP12_REG   (PCI_CR_PR_OFFSET + 0x0068)
+#define PCI_CR_PCI_ADDR_MAP13_REG   (PCI_CR_PR_OFFSET + 0x006C)
+#define PCI_CR_PCI_ADDR_MAP14_REG   (PCI_CR_PR_OFFSET + 0x0070)
+#define PCI_CR_PCI_ADDR_MAP15_REG   (PCI_CR_PR_OFFSET + 0x0074)
+#define PCI_CR_PCI_ADDR_MAP16_REG   (PCI_CR_PR_OFFSET + 0x0078)
+#define PCI_CR_FPI_SEG_EN_REG       (PCI_CR_PR_OFFSET + 0x007C)
+#define PCI_CR_PC_ARB_REG	        (PCI_CR_PR_OFFSET + 0x0080)
+#define PCI_CR_BAR21MASK_REG	    (PCI_CR_PR_OFFSET + 0x0084)
+#define PCI_CR_BAR22MASK_REG        (PCI_CR_PR_OFFSET + 0x0088)
+#define PCI_CR_BAR23MASK_REG        (PCI_CR_PR_OFFSET + 0x008C)
+#define PCI_CR_BAR24MASK_REG        (PCI_CR_PR_OFFSET + 0x0090)
+#define PCI_CR_BAR25MASK_REG        (PCI_CR_PR_OFFSET + 0x0094)
+#define PCI_CR_BAR26MASK_REG        (PCI_CR_PR_OFFSET + 0x0098)
+#define PCI_CR_CIS_PT2_REG	        (PCI_CR_PR_OFFSET + 0x009C)
+#define PCI_CR_SUBSYS_ID2_REG	    (PCI_CR_PR_OFFSET + 0x00A0)
+#define PCI_CR_PCI_ADDR_MAP21_REG   (PCI_CR_PR_OFFSET + 0x00A4)
+#define PCI_CR_PCI_ADDR_MAP22_REG   (PCI_CR_PR_OFFSET + 0x00A8)
+#define PCI_CR_PCI_ADDR_MAP23_REG   (PCI_CR_PR_OFFSET + 0x00AC)
+#define PCI_CR_PCI_ADDR_MAP24_REG   (PCI_CR_PR_OFFSET + 0x00B0)
+#define PCI_CR_PCI_ADDR_MAP25_REG   (PCI_CR_PR_OFFSET + 0x00B4)
+#define PCI_CR_PCI_ADDR_MAP26_REG   (PCI_CR_PR_OFFSET + 0x00B8)
+#define PCI_CR_FPI_ADDR_MASK_REG    (PCI_CR_PR_OFFSET + 0x00BC)
+#define PCI_CR_FCI_ADDR_MAP0_REG    (PCI_CR_PR_OFFSET + 0x00C0)
+#define PCI_CR_FCI_ADDR_MAP1_REG    (PCI_CR_PR_OFFSET + 0x00C4)
+#define PCI_CR_FCI_ADDR_MAP2_REG    (PCI_CR_PR_OFFSET + 0x00C8)
+#define PCI_CR_FCI_ADDR_MAP3_REG    (PCI_CR_PR_OFFSET + 0x00CC)
+#define PCI_CR_FCI_ADDR_MAP4_REG    (PCI_CR_PR_OFFSET + 0x00D0)
+#define PCI_CR_FCI_ADDR_MAP5_REG    (PCI_CR_PR_OFFSET + 0x00D4)
+#define PCI_CR_FCI_ADDR_MAP6_REG    (PCI_CR_PR_OFFSET + 0x00D8)
+#define PCI_CR_FCI_ADDR_MAP7_REG    (PCI_CR_PR_OFFSET + 0x00DC)
+#define PCI_CR_FCI_ADDR_MAP11lo_REG (PCI_CR_PR_OFFSET + 0x00E0)
+#define PCI_CR_FCI_ADDR_MAP11hg_REG (PCI_CR_PR_OFFSET + 0x00E4)
+#define PCI_CR_FCI_BURST_LENGTH_REG (PCI_CR_PR_OFFSET + 0x00E8)
+#define PCI_CR_PCI_SET_SERR_REG     (PCI_CR_PR_OFFSET + 0x00EC)
+#define PCI_CR_DMA_FPI_ST_ADDR_REG  (PCI_CR_PR_OFFSET + 0x00F0)
+#define PCI_CR_DMA_PCI_ST_ADDR_REG  (PCI_CR_PR_OFFSET + 0x00F4)
+#define PCI_CR_DMA_TRAN_CNT_REG     (PCI_CR_PR_OFFSET + 0x00F8)
+#define PCI_CR_DMA_TRAN_CTL_REG     (PCI_CR_PR_OFFSET + 0x00FC)
+
+/* PCI CONFIGURATION SPACE REGISTER Base Address */
+#define EXT_PCI1_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x0800
+#define EXT_PCI2_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x1000
+#define EXT_PCI3_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x1800
+#define EXT_PCI4_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x2000
+#define EXT_PCI5_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x2800
+#define EXT_PCI6_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x3000
+#define EXT_PCI7_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x3800
+#define EXT_PCI8_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x4000
+#define EXT_PCI9_CONFIG_SPACE_BASE_ADDR    	PCI_CFG_BASE + 0x4800
+#define EXT_PCI10_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x5000
+#define EXT_PCI11_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x5800
+#define EXT_PCI12_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x6000
+#define EXT_PCI13_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x6800
+#define EXT_PCI14_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x7000
+#define EXT_PCI15_CONFIG_SPACE_BASE_ADDR   	PCI_CFG_BASE + 0x7800
+#define EXT_CARDBUS_CONFIG_SPACE_BASE_ADDR  	PCI_CFG_BASE + 0XF000
+
+/* PCI CONFIGURATION SPACE REGISTER ADDRESS MAP */
+#define PCI_CS_DEV_VEN_ID_REG        (PCI_CS_PR_OFFSET + 0x0000)
+#define PCI_CS_STS_CMD_REG	         (PCI_CS_PR_OFFSET + 0x0004)
+#define PCI_CS_CL_CODE_REVIDG        (PCI_CS_PR_OFFSET + 0x0008)
+#define PCI_CS_BST_HT_LT_CLS_REG     (PCI_CS_PR_OFFSET + 0x000C)
+#define PCI_CS_BASE_ADDR1_REG	     (PCI_CS_PR_OFFSET + 0x0010)
+#define PCI_CS_BASE_ADDR2_REG        (PCI_CS_PR_OFFSET + 0x0014)
+#define PCI_CS_BASE_ADDR3_REG        (PCI_CS_PR_OFFSET + 0x0018)
+#define PCI_CS_BASE_ADDR4_REG        (PCI_CS_PR_OFFSET + 0x001C)
+#define PCI_CS_BASE_ADDR5_REG        (PCI_CS_PR_OFFSET + 0x0020)
+#define PCI_CS_BASE_ADDR6_REG        (PCI_CS_PR_OFFSET + 0x0024)
+#define PCI_CS_CARDBUS_CIS_PT_REG    (PCI_CS_PR_OFFSET + 0x0028)
+#define PCI_CS_SUBSYS_VEN_ID_REG     (PCI_CS_PR_OFFSET + 0x002C)
+#define PCI_CS_EXROM_BAS_ADDR_REG    (PCI_CS_PR_OFFSET + 0x0030)
+#define PCI_CS_RES1_REG	             (PCI_CS_PR_OFFSET + 0x0034)
+#define PCI_CS_RES2_REG	             (PCI_CS_PR_OFFSET + 0x0038)
+#define PCI_CS_LAT_GNT_INTR_REG      (PCI_CS_PR_OFFSET + 0x003C)
+#define PCI_CS_PM_PT_CPID_REG        (PCI_CS_PR_OFFSET + 0x0040)
+#define PCI_CS_DAT_PMCSR_PM_REG	     (PCI_CS_PR_OFFSET + 0x0044)
+#define PCI_CS_RES3_REG              (PCI_CS_PR_OFFSET + 0x0048)
+#define PCI_CS_RES4_REG              (PCI_CS_PR_OFFSET + 0x004C)
+#define PCI_CS_ERR_ADDR_PCI_FPI_REG  (PCI_CS_PR_OFFSET + 0x0050)
+#define PCI_CS_ERR_ADDR_FPI_PCI_REG  (PCI_CS_PR_OFFSET + 0x0054)
+#define PCI_CS_ERR_TAG_FPI_PCI_REG   (PCI_CS_PR_OFFSET + 0x0058)
+#define PCI_CS_PC_ARB_REG	         (PCI_CS_PR_OFFSET + 0x005C)
+#define PCI_CS_FPI_PCI_INT_STS_REG   (PCI_CS_PR_OFFSET + 0x0060)
+#define PCI_CS_FPI_PCI_INT_ACK_REG   (PCI_CS_PR_OFFSET + 0x0064)
+#define PCI_CS_FPI_PCI_INT_MASK_REG  (PCI_CS_PR_OFFSET + 0x0068)
+#define PCI_CS_CARDBUS_CTL_STS_REG   (PCI_CS_PR_OFFSET + 0x006C)
+
+// PCI CONTROLLER ADDRESS SPACE
+#define PCI_CA_PR_OFFSET 0xB8000000
+#define PCI_CA_PR_END    0xBBFFFFFF
+
+// PCI CONTROLLER REGISTER ADDRESS MASK
+#define PCI_CR_CLK_CTRL_MSK              0x82000000
+#define PCI_CR_PCI_ID_MSK	    	     0x00000000
+#define PCI_CR_SFT_RST_MSK	    	     0x00000002
+#define PCI_CR_PCI_FPI_ERR_ADDR_MSK 	 0x00000000
+#define PCI_CR_FCI_PCI_ERR_ADDR_MSK 	 0x00000000
+#define PCI_CR_FPI_ERR_TAG_MSK	    	 0x00000000
+#define PCI_CR_PCI_IRR_MSK	    	     0x07013B2F
+#define PCI_CR_PCI_IRA_MSK	    	     0x07013B2F
+#define PCI_CR_PCI_IRM_MSK	    	     0x07013B2F
+#define PCI_CR_PCI_EOI_MSK	    	     0x07013B2F
+#define PCI_CR_PCI_MOD_MSK 	    	     0x1107070F
+#define PCI_CR_DV_ID_MSK	    	     0x00000000
+#define PCI_CR_SUBSYS_ID_MSK	    	 0x00000000
+#define PCI_CR_PCI_PM_MSK           	 0x0000001F
+#define PCI_CR_CLASS_CODE1_MSK      	 0x00000000
+#define PCI_CR_BAR11MASK_MSK	    	 0x8FFFFFF8
+#define PCI_CR_BAR12MASK_MSK        	 0x80001F08
+#define PCI_CR_BAR13MASK_MSK        	 0x8FF00008
+#define PCI_CR_BAR14MASK_MSK        	 0x8FFFFF08
+#define PCI_CR_BAR15MASK_MSK        	 0x8FFFFF08
+#define PCI_CR_BAR16MASK_MSK        	 0x8FFFFFF9
+#define PCI_CR_CIS_PT1_MSK	    	     0x03FFFFFF
+#define PCI_CR_SUBSYS_ID1_MSK	    	 0x00000000
+#define PCI_CR_PCI_ADDR_MAP11_MSK   	 0x7FFF0001
+#define PCI_CR_PCI_ADDR_MAP12_MSK   	 0x7FFFFF01
+#define PCI_CR_PCI_ADDR_MAP13_MSK   	 0x7FF00001
+#define PCI_CR_PCI_ADDR_MAP14_MSK   	 0x7FFFFF01
+#define PCI_CR_PCI_ADDR_MAP15_MSK   	 0x7FF00001
+#define PCI_CR_PCI_ADDR_MAP16_MSK   	 0x7FF00001
+#define PCI_CR_FPI_SEG_EN_MSK       	 0x000003FF
+#define PCI_CR_CLASS_CODE2_MSK      	 0x00000000
+#define PCI_CR_BAR21MASK_MSK	    	 0x800F0008
+#define PCI_CR_BAR22MASK_MSK        	 0x807F0008
+#define PCI_CR_BAR23MASK_MSK        	 0x8FF00008
+#define PCI_CR_BAR24MASK_MSK        	 0x8FFFFF08
+#define PCI_CR_BAR25MASK_MSK        	 0x8FFFFF08
+#define PCI_CR_BAR26MASK_MSK        	 0x8FFFFFF9
+#define PCI_CR_CIS_PT2_MSK	    	     0x03FFFFFF
+#define PCI_CR_SUBSYS_ID2_MSK	    	 0x00000000
+#define PCI_CR_PCI_ADDR_MAP21_MSK   	 0x7FFE0001
+#define PCI_CR_PCI_ADDR_MAP22_MSK   	 0x7FFF0001
+#define PCI_CR_PCI_ADDR_MAP23_MSK   	 0x7FF00001
+#define PCI_CR_PCI_ADDR_MAP24_MSK   	 0x7FFFFF01
+#define PCI_CR_PCI_ADDR_MAP25_MSK   	 0x7FFFFF01
+#define PCI_CR_PCI_ADDR_MAP26_MSK   	 0x7FF00001
+#define PCI_CR_FPI_ADDR_MASK_MSK    	 0x00070000
+#define PCI_CR_FCI_ADDR_MAP0_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP1_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP2_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP3_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP4_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP5_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP6_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP7_MSK    	 0xFFF00000
+#define PCI_CR_FCI_ADDR_MAP11lo_MSK 	 0xFFFF0000
+#define PCI_CR_FCI_ADDR_MAP11hg_MSK 	 0xFFF00000
+#define PCI_CR_FCI_BURST_LENGTH_MSK 	 0x00000303
+#define PCI_CR_PCI_SET_SERR_MSK     	 0x00000001
+#define PCI_CR_DMA_FPI_ST_ADDR_MSK  	 0xFFFFFFFF
+#define PCI_CR_DMA_PCI_ST_ADDR_MSK  	 0xFFFFFFFF
+#define PCI_CR_DMA_TRAN_CNT_MSK     	 0x000003FF
+#define PCI_CR_DMA_TRAN_CTL_MSK     	 0x00000003
+
+#define INTERNAL_ARB_ENABLE_BIT         	0
+#define ARB_SCHEME_BIT                  	1
+#define PCI_MASTER0_PRIOR_2BITS         	2
+#define PCI_MASTER1_PRIOR_2BITS         	4
+#define PCI_MASTER2_PRIOR_2BITS         	6
+#define PCI_MASTER0_REQ_MASK_2BITS      	8
+#define PCI_MASTER1_REQ_MASK_2BITS      	10
+#define PCI_MASTER2_REQ_MASK_2BITS      	12
+
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define AMAZON_SE_PPE_BASE_ADDR                (KSEG1 + 0x1E180000)
+#define AMAZON_SE_PPE_PP32_DEBUG_REG_ADDR(x)          ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x0000) << 2)))
+#define AMAZON_SE_PPE_PPM_INT_REG_ADDR(x)             ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x0030) << 2)))
+#define AMAZON_SE_PPE_PP32_INTERNAL_RES_ADDR(x)       ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x0040) << 2)))
+#define AMAZON_SE_PPE_PPE_CLOCK_CONTROL_ADDR(x)       ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x0100) << 2)))
+#define AMAZON_SE_PPE_CDM_CODE_MEMORY_RAM0_ADDR(x)    ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x1000) << 2)))
+#define AMAZON_SE_PPE_CDM_CODE_MEMORY_RAM1_ADDR(x)    ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x2000) << 2)))
+#define AMAZON_SE_PPE_REG_ADDR(x)                 ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x4000) << 2)))
+#define AMAZON_SE_PPE_PP32_DATA_MEMORY_RAM1_ADDR(x)   ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x5000) << 2)))
+#define AMAZON_SE_PPE_PPM_INT_UNIT_ADDR(x)            ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x6000) << 2)))
+#define AMAZON_SE_PPE_PPM_TIMER0_ADDR(x)              ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x6100) << 2)))
+#define AMAZON_SE_PPE_PPM_TASK_IND_REG_ADDR(x)        ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x6200) << 2)))
+#define AMAZON_SE_PPE_PPS_BRK_ADDR(x)                 ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x6300) << 2)))
+#define AMAZON_SE_PPE_PPM_TIMER1_ADDR(x)              ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x6400) << 2)))
+#define AMAZON_SE_PPE_SB_RAM0_ADDR(x)                 ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x8000) << 2)))
+#define AMAZON_SE_PPE_SB_RAM1_ADDR(x)                 ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x8400) << 2)))
+#define AMAZON_SE_PPE_SB_RAM2_ADDR(x)                 ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x8C00) << 2)))
+#define AMAZON_SE_PPE_SB_RAM3_ADDR(x)                 ((volatile u32*)(AMAZON_SE_PPE_BASE_ADDR + (((x) + 0x9600) << 2)))
+
+#define AMAZON_SE_PPE_PP32_SLEEP                      AMAZON_SE_PPE_REG_ADDR(0x0010) /* PP32 Power Saving Register */
+#define AMAZON_SE_PPE_CDM_CFG                         AMAZON_SE_PPE_REG_ADDR(0x0100) /* Code/Data Memory (CDM) Register */
+
+/* Mailbox Registers */
+#define AMAZON_SE_PPE_MBOX_IGU0_ISRS                  AMAZON_SE_PPE_REG_ADDR(0x0200)
+#define AMAZON_SE_PPE_MBOX_IGU0_ISRC                  AMAZON_SE_PPE_REG_ADDR(0x0201)
+#define AMAZON_SE_PPE_MBOX_IGU0_ISR                   AMAZON_SE_PPE_REG_ADDR(0x0202)
+#define AMAZON_SE_PPE_MBOX_IGU0_IER                   AMAZON_SE_PPE_REG_ADDR(0x0203)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISRS0                 AMAZON_SE_PPE_REG_ADDR(0x0204)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISRC0                 AMAZON_SE_PPE_REG_ADDR(0x0205)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISR0                  AMAZON_SE_PPE_REG_ADDR(0x0206)
+#define AMAZON_SE_PPE_MBOX_IGU1_IER0                  AMAZON_SE_PPE_REG_ADDR(0x0207)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISRS1                 AMAZON_SE_PPE_REG_ADDR(0x0208)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISRC1                 AMAZON_SE_PPE_REG_ADDR(0x0209)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISR1                  AMAZON_SE_PPE_REG_ADDR(0x020A)
+#define AMAZON_SE_PPE_MBOX_IGU1_IER1                  AMAZON_SE_PPE_REG_ADDR(0x020B)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISRS2                 AMAZON_SE_PPE_REG_ADDR(0x020C)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISRC2                 AMAZON_SE_PPE_REG_ADDR(0x020D)
+#define AMAZON_SE_PPE_MBOX_IGU1_ISR2                  AMAZON_SE_PPE_REG_ADDR(0x020E)
+#define AMAZON_SE_PPE_MBOX_IGU1_IER2                  AMAZON_SE_PPE_REG_ADDR(0x020F)
+#define AMAZON_SE_PPE_MBOX_IGU2_ISRS                  AMAZON_SE_PPE_REG_ADDR(0x0210)
+#define AMAZON_SE_PPE_MBOX_IGU2_ISRC                  AMAZON_SE_PPE_REG_ADDR(0x0211)
+#define AMAZON_SE_PPE_MBOX_IGU2_ISR                   AMAZON_SE_PPE_REG_ADDR(0x0212)
+#define AMAZON_SE_PPE_MBOX_IGU2_IER                   AMAZON_SE_PPE_REG_ADDR(0x0213)
+#define AMAZON_SE_PPE_MBOX_IGU3_ISRS                  AMAZON_SE_PPE_REG_ADDR(0x0214)
+#define AMAZON_SE_PPE_MBOX_IGU3_ISRC                  AMAZON_SE_PPE_REG_ADDR(0x0215)
+#define AMAZON_SE_PPE_MBOX_IGU3_ISR                   AMAZON_SE_PPE_REG_ADDR(0x0216)
+#define AMAZON_SE_PPE_MBOX_IGU3_IER                   AMAZON_SE_PPE_REG_ADDR(0x0217)
+#define AMAZON_SE_PPE_MBOX_IGU4_ISRS                  AMAZON_SE_PPE_REG_ADDR(0x0218)
+#define AMAZON_SE_PPE_MBOX_IGU4_ISRC                  AMAZON_SE_PPE_REG_ADDR(0x0219)
+#define AMAZON_SE_PPE_MBOX_IGU4_ISR                   AMAZON_SE_PPE_REG_ADDR(0x021A)
+#define AMAZON_SE_PPE_MBOX_IGU4_IER                   AMAZON_SE_PPE_REG_ADDR(0x021B)
+/*
+ *    Shared Buffer (SB) Registers
+ */
+#define AMAZON_SE_PPE_SB_MST_PRI0                     AMAZON_SE_PPE_REG_ADDR(0x0300)
+#define AMAZON_SE_PPE_SB_MST_PRI1                     AMAZON_SE_PPE_REG_ADDR(0x0301)
+#define AMAZON_SE_PPE_SB_MST_PRI2                     AMAZON_SE_PPE_REG_ADDR(0x0302)
+#define AMAZON_SE_PPE_SB_MST_PRI3                     AMAZON_SE_PPE_REG_ADDR(0x0303)
+#define AMAZON_SE_PPE_SB_MST_PRI4                     AMAZON_SE_PPE_REG_ADDR(0x0304)
+#define AMAZON_SE_PPE_SB_MST_SEL                      AMAZON_SE_PPE_REG_ADDR(0x0305)
+/*
+ *    RTHA Registers
+ */
+#define AMAZON_SE_PPE_RFBI_CFG                        AMAZON_SE_PPE_REG_ADDR(0x0400)
+#define AMAZON_SE_PPE_RBA_CFG0                        AMAZON_SE_PPE_REG_ADDR(0x0404)
+#define AMAZON_SE_PPE_RBA_CFG1                        AMAZON_SE_PPE_REG_ADDR(0x0405)
+#define AMAZON_SE_PPE_RCA_CFG0                        AMAZON_SE_PPE_REG_ADDR(0x0408)
+#define AMAZON_SE_PPE_RCA_CFG1                        AMAZON_SE_PPE_REG_ADDR(0x0409)
+#define AMAZON_SE_PPE_RDES_CFG0                       AMAZON_SE_PPE_REG_ADDR(0x040C)
+#define AMAZON_SE_PPE_RDES_CFG1                       AMAZON_SE_PPE_REG_ADDR(0x040D)
+#define AMAZON_SE_PPE_SFSM_STATE0                     AMAZON_SE_PPE_REG_ADDR(0x0410)
+#define AMAZON_SE_PPE_SFSM_STATE1                     AMAZON_SE_PPE_REG_ADDR(0x0411)
+#define AMAZON_SE_PPE_SFSM_DBA0                       AMAZON_SE_PPE_REG_ADDR(0x0412)
+#define AMAZON_SE_PPE_SFSM_DBA1                       AMAZON_SE_PPE_REG_ADDR(0x0413)
+#define AMAZON_SE_PPE_SFSM_CBA0                       AMAZON_SE_PPE_REG_ADDR(0x0414)
+#define AMAZON_SE_PPE_SFSM_CBA1                       AMAZON_SE_PPE_REG_ADDR(0x0415)
+#define AMAZON_SE_PPE_SFSM_CFG0                       AMAZON_SE_PPE_REG_ADDR(0x0416)
+#define AMAZON_SE_PPE_SFSM_CFG1                       AMAZON_SE_PPE_REG_ADDR(0x0417)
+#define AMAZON_SE_PPE_SFSM_PGCNT0                     AMAZON_SE_PPE_REG_ADDR(0x041C)
+#define AMAZON_SE_PPE_SFSM_PGCNT1                     AMAZON_SE_PPE_REG_ADDR(0x041D)
+/*
+ *    TTHA Registers
+ */
+#define AMAZON_SE_PPE_FFSM_DBA0                       AMAZON_SE_PPE_REG_ADDR(0x0508)
+#define AMAZON_SE_PPE_FFSM_DBA1                       AMAZON_SE_PPE_REG_ADDR(0x0509)
+#define AMAZON_SE_PPE_FFSM_CFG0                       AMAZON_SE_PPE_REG_ADDR(0x050A)
+#define AMAZON_SE_PPE_FFSM_CFG1                       AMAZON_SE_PPE_REG_ADDR(0x050B)
+#define AMAZON_SE_PPE_FFSM_IDLE_HEAD_BC0              AMAZON_SE_PPE_REG_ADDR(0x050E)
+#define AMAZON_SE_PPE_FFSM_IDLE_HEAD_BC1              AMAZON_SE_PPE_REG_ADDR(0x050F)
+#define AMAZON_SE_PPE_FFSM_PGCNT0                     AMAZON_SE_PPE_REG_ADDR(0x0514)
+#define AMAZON_SE_PPE_FFSM_PGCNT1                     AMAZON_SE_PPE_REG_ADDR(0x0515)
+/*
+ *    ETOP MDIO Registers
+ */
+#define AMAZON_SE_PPE_ETOP_MDIO_CFG                   AMAZON_SE_PPE_REG_ADDR(0x0600)
+#define AMAZON_SE_PPE_ETOP_MDIO_ACC                   AMAZON_SE_PPE_REG_ADDR(0x0601)
+#define AMAZON_SE_PPE_ETOP_CFG                        AMAZON_SE_PPE_REG_ADDR(0x0602)
+#define AMAZON_SE_PPE_ETOP_IG_VLAN_COS                AMAZON_SE_PPE_REG_ADDR(0x0603)
+#define AMAZON_SE_PPE_ETOP_IG_DSCP_COS3               AMAZON_SE_PPE_REG_ADDR(0x0604)
+#define AMAZON_SE_PPE_ETOP_IG_DSCP_COS2               AMAZON_SE_PPE_REG_ADDR(0x0605)
+#define AMAZON_SE_PPE_ETOP_IG_DSCP_COS1               AMAZON_SE_PPE_REG_ADDR(0x0606)
+#define AMAZON_SE_PPE_ETOP_IG_DSCP_COS0               AMAZON_SE_PPE_REG_ADDR(0x0607)
+#define AMAZON_SE_PPE_ETOP_IG_PLEN_CTRL0              AMAZON_SE_PPE_REG_ADDR(0x0608)
+#define AMAZON_SE_PPE_ETOP_IG_PLEN_CTRL1              AMAZON_SE_PPE_REG_ADDR(0x0609)
+#define AMAZON_SE_PPE_ETOP_ISR                        AMAZON_SE_PPE_REG_ADDR(0x060A)
+#define AMAZON_SE_PPE_ETOP_IER                        AMAZON_SE_PPE_REG_ADDR(0x060B)
+#define AMAZON_SE_PPE_ETOP_VPID                       AMAZON_SE_PPE_REG_ADDR(0x060C)
+#define AMAZON_SE_PPE_ENET_MAC_CFG                    AMAZON_SE_PPE_REG_ADDR(0x0610)
+#define AMAZON_SE_PPE_ENETS_DBA                       AMAZON_SE_PPE_REG_ADDR(0x0612)
+#define AMAZON_SE_PPE_ENETS_CBA                       AMAZON_SE_PPE_REG_ADDR(0x0613)
+#define AMAZON_SE_PPE_ENETS_CFG                       AMAZON_SE_PPE_REG_ADDR(0x0614)
+#define AMAZON_SE_PPE_ENETS_PGCNT                     AMAZON_SE_PPE_REG_ADDR(0x0615)
+#define AMAZON_SE_PPE_ENETS_PGCNT_DSRC_PP32	   (0x00020000)
+#define AMAZON_SE_PPE_ENETS_PGCNT_DVAL_SHIFT	   (9)
+#define AMAZON_SE_PPE_ENETS_PGCNT_DCMD	           (0x00000100)
+#define AMAZON_SE_PPE_ENETS_PKTCNT                    AMAZON_SE_PPE_REG_ADDR(0x0616)
+#define AMAZON_SE_PPE_ENETS_PKTCNT_DSRC_PP32	   (0x00000200)
+#define AMAZON_SE_PPE_ENETS_PKTCNT_DCMD	           (0x00000100)
+#define AMAZON_SE_PPE_ENETS_PKTCNT_UPKT	           (0x000000FF)
+#define AMAZON_SE_PPE_ENETS_BUF_CTRL                  AMAZON_SE_PPE_REG_ADDR(0x0617)
+#define AMAZON_SE_PPE_ENETS_COS_CFG                   AMAZON_SE_PPE_REG_ADDR(0x0618)
+#define AMAZON_SE_PPE_ENETS_IGDROP                    AMAZON_SE_PPE_REG_ADDR(0x0619)
+#define AMAZON_SE_PPE_ENETF_DBA                       AMAZON_SE_PPE_REG_ADDR(0x0630)
+#define AMAZON_SE_PPE_ENETF_CBA                       AMAZON_SE_PPE_REG_ADDR(0x0631)
+#define AMAZON_SE_PPE_ENETF_CFG                       AMAZON_SE_PPE_REG_ADDR(0x0632)
+#define AMAZON_SE_PPE_ENETF_PGCNT                     AMAZON_SE_PPE_REG_ADDR(0x0633)
+#define AMAZON_SE_PPE_ENETF_PGCNT_ISRC_PP32	   (0x00020000)
+#define AMAZON_SE_PPE_ENETF_PGCNT_IVAL_SHIFT	   (9)
+#define AMAZON_SE_PPE_ENETF_PGCNT_ICMD	           (0x00000100)
+#define AMAZON_SE_PPE_ENETF_PKTCNT                    AMAZON_SE_PPE_REG_ADDR(0x0634)
+#define AMAZON_SE_PPE_ENETF_PKTCNT_ISRC_PP32	   (0x00000200)
+#define AMAZON_SE_PPE_ENETF_PKTCNT_ICMD	           (0x00000100)
+#define AMAZON_SE_PPE_ENETF_PKTCNT_VPKT	           (0x000000FF)
+#define AMAZON_SE_PPE_ENETF_HFCTRL                    AMAZON_SE_PPE_REG_ADDR(0x0635)
+#define AMAZON_SE_PPE_ENETF_TXCTRL                    AMAZON_SE_PPE_REG_ADDR(0x0636)
+#define AMAZON_SE_PPE_ENETF_VLCOS0                    AMAZON_SE_PPE_REG_ADDR(0x0638)
+#define AMAZON_SE_PPE_ENETF_VLCOS1                    AMAZON_SE_PPE_REG_ADDR(0x0639)
+#define AMAZON_SE_PPE_ENETF_VLCOS2                    AMAZON_SE_PPE_REG_ADDR(0x063A)
+#define AMAZON_SE_PPE_ENETF_VLCOS3                    AMAZON_SE_PPE_REG_ADDR(0x063B)
+#define AMAZON_SE_PPE_ENETF_EGERR                     AMAZON_SE_PPE_REG_ADDR(0x063C)
+#define AMAZON_SE_PPE_ENETF_EGDROP                    AMAZON_SE_PPE_REG_ADDR(0x063D)
+/*
+ *    DPLUS Registers
+ */
+#define AMAZON_SE_PPE_DPLUS_TXDB                      AMAZON_SE_PPE_REG_ADDR(0x0700)
+#define AMAZON_SE_PPE_DPLUS_TXCB                      AMAZON_SE_PPE_REG_ADDR(0x0701)
+#define AMAZON_SE_PPE_DPLUS_TXCFG                     AMAZON_SE_PPE_REG_ADDR(0x0702)
+#define AMAZON_SE_PPE_DPLUS_TXPGCNT                   AMAZON_SE_PPE_REG_ADDR(0x0703)
+#define AMAZON_SE_PPE_DPLUS_RXDB                      AMAZON_SE_PPE_REG_ADDR(0x0710)
+#define AMAZON_SE_PPE_DPLUS_RXCB                      AMAZON_SE_PPE_REG_ADDR(0x0711)
+#define AMAZON_SE_PPE_DPLUS_RXCFG                     AMAZON_SE_PPE_REG_ADDR(0x0712)
+#define AMAZON_SE_PPE_DPLUS_RXPGCNT                   AMAZON_SE_PPE_REG_ADDR(0x0713)
+/*
+ *    BMC Registers
+ */
+#define AMAZON_SE_PPE_BMC_CMD3                        AMAZON_SE_PPE_REG_ADDR(0x0800)
+#define AMAZON_SE_PPE_BMC_CMD2                        AMAZON_SE_PPE_REG_ADDR(0x0801)
+#define AMAZON_SE_PPE_BMC_CMD1                        AMAZON_SE_PPE_REG_ADDR(0x0802)
+#define AMAZON_SE_PPE_BMC_CMD0                        AMAZON_SE_PPE_REG_ADDR(0x0803)
+#define AMAZON_SE_PPE_BMC_CFG0                        AMAZON_SE_PPE_REG_ADDR(0x0804)
+#define AMAZON_SE_PPE_BMC_CFG1                        AMAZON_SE_PPE_REG_ADDR(0x0805)
+#define AMAZON_SE_PPE_BMC_POLY0                       AMAZON_SE_PPE_REG_ADDR(0x0806)
+#define AMAZON_SE_PPE_BMC_POLY1                       AMAZON_SE_PPE_REG_ADDR(0x0807)
+#define AMAZON_SE_PPE_BMC_CRC0                        AMAZON_SE_PPE_REG_ADDR(0x0808)
+#define AMAZON_SE_PPE_BMC_CRC1                        AMAZON_SE_PPE_REG_ADDR(0x0809)
+/*
+ *    SLL Registers
+ */
+#define AMAZON_SE_PPE_SLL_CMD1                        AMAZON_SE_PPE_REG_ADDR(0x0900)
+#define AMAZON_SE_PPE_SLL_CMD0                        AMAZON_SE_PPE_REG_ADDR(0x0901)
+#define AMAZON_SE_PPE_SLL_KEY0                        AMAZON_SE_PPE_REG_ADDR(0x0910)
+#define AMAZON_SE_PPE_SLL_KEY1                        AMAZON_SE_PPE_REG_ADDR(0x0911)
+#define AMAZON_SE_PPE_SLL_KEY2                        AMAZON_SE_PPE_REG_ADDR(0x0912)
+#define AMAZON_SE_PPE_SLL_KEY3                        AMAZON_SE_PPE_REG_ADDR(0x0913)
+#define AMAZON_SE_PPE_SLL_KEY4                        AMAZON_SE_PPE_REG_ADDR(0x0914)
+#define AMAZON_SE_PPE_SLL_KEY5                        AMAZON_SE_PPE_REG_ADDR(0x0915)
+#define AMAZON_SE_PPE_SLL_RESULT                      AMAZON_SE_PPE_REG_ADDR(0x0920)
+/*
+ *    EMA Registers
+ */
+#define AMAZON_SE_PPE_EMA_CMD2                        AMAZON_SE_PPE_REG_ADDR(0x0A00)
+#define AMAZON_SE_PPE_EMA_CMD1                        AMAZON_SE_PPE_REG_ADDR(0x0A01)
+#define AMAZON_SE_PPE_EMA_CMD0                        AMAZON_SE_PPE_REG_ADDR(0x0A02)
+#define AMAZON_SE_PPE_EMA_ISR                         AMAZON_SE_PPE_REG_ADDR(0x0A04)
+#define AMAZON_SE_PPE_EMA_IER                         AMAZON_SE_PPE_REG_ADDR(0x0A05)
+#define AMAZON_SE_PPE_EMA_CFG                         AMAZON_SE_PPE_REG_ADDR(0x0A06)
+/*
+ *    UTPS Registers
+ */
+#define AMAZON_SE_PPE_UTP_TXCA0                       AMAZON_SE_PPE_REG_ADDR(0x0B00)
+#define AMAZON_SE_PPE_UTP_TXNA0                       AMAZON_SE_PPE_REG_ADDR(0x0B01)
+#define AMAZON_SE_PPE_UTP_TXCA1                       AMAZON_SE_PPE_REG_ADDR(0x0B02)
+#define AMAZON_SE_PPE_UTP_TXNA1                       AMAZON_SE_PPE_REG_ADDR(0x0B03)
+#define AMAZON_SE_PPE_UTP_RXCA0                       AMAZON_SE_PPE_REG_ADDR(0x0B10)
+#define AMAZON_SE_PPE_UTP_RXNA0                       AMAZON_SE_PPE_REG_ADDR(0x0B11)
+#define AMAZON_SE_PPE_UTP_RXCA1                       AMAZON_SE_PPE_REG_ADDR(0x0B12)
+#define AMAZON_SE_PPE_UTP_RXNA1                       AMAZON_SE_PPE_REG_ADDR(0x0B13)
+#define AMAZON_SE_PPE_UTP_CFG                         AMAZON_SE_PPE_REG_ADDR(0x0B20)
+#define AMAZON_SE_PPE_UTP_ISR                         AMAZON_SE_PPE_REG_ADDR(0x0B30)
+#define AMAZON_SE_PPE_UTP_IER                         AMAZON_SE_PPE_REG_ADDR(0x0B31)
+/*
+ *    QSB Registers
+ */
+#define AMAZON_SE_PPE_QSB_RELOG                       AMAZON_SE_PPE_REG_ADDR(0x0C00)
+#define AMAZON_SE_PPE_QSB_EMIT0                       AMAZON_SE_PPE_REG_ADDR(0x0C01)
+#define AMAZON_SE_PPE_QSB_EMIT1                       AMAZON_SE_PPE_REG_ADDR(0x0C02)
+#define AMAZON_SE_PPE_QSB_ICDV                        AMAZON_SE_PPE_REG_ADDR(0x0C07)
+#define AMAZON_SE_PPE_QSB_SBL                         AMAZON_SE_PPE_REG_ADDR(0x0C09)
+#define AMAZON_SE_PPE_QSB_CFG                         AMAZON_SE_PPE_REG_ADDR(0x0C0A)
+#define AMAZON_SE_PPE_QSB_RTM                         AMAZON_SE_PPE_REG_ADDR(0x0C0B)
+#define AMAZON_SE_PPE_QSB_RTD                         AMAZON_SE_PPE_REG_ADDR(0x0C0C)
+#define AMAZON_SE_PPE_QSB_RAMAC                       AMAZON_SE_PPE_REG_ADDR(0x0C0D)
+#define AMAZON_SE_PPE_QSB_ISTAT                       AMAZON_SE_PPE_REG_ADDR(0x0C0E)
+#define AMAZON_SE_PPE_QSB_IMR                         AMAZON_SE_PPE_REG_ADDR(0x0C0F)
+#define AMAZON_SE_PPE_QSB_SRC                         AMAZON_SE_PPE_REG_ADDR(0x0C10)
+/*
+ *    DSP User Registers
+ */
+#define AMAZON_SE_PPE_DREG_A_VERSION                  AMAZON_SE_PPE_REG_ADDR(0x0D00)
+#define AMAZON_SE_PPE_DREG_A_CFG                      AMAZON_SE_PPE_REG_ADDR(0x0D01)
+#define AMAZON_SE_PPE_DREG_AT_CTRL                    AMAZON_SE_PPE_REG_ADDR(0x0D02)
+#define AMAZON_SE_PPE_DREG_AR_CTRL                    AMAZON_SE_PPE_REG_ADDR(0x0D08)
+#define AMAZON_SE_PPE_DREG_A_UTPCFG                   AMAZON_SE_PPE_REG_ADDR(0x0D0E)
+#define AMAZON_SE_PPE_DREG_A_STATUS                   AMAZON_SE_PPE_REG_ADDR(0x0D0F)
+#define AMAZON_SE_PPE_DREG_AT_CFG0                    AMAZON_SE_PPE_REG_ADDR(0x0D20)
+#define AMAZON_SE_PPE_DREG_AT_CFG1                    AMAZON_SE_PPE_REG_ADDR(0x0D21)
+#define AMAZON_SE_PPE_DREG_FB_SIZE0                   AMAZON_SE_PPE_REG_ADDR(0x0D22)
+#define AMAZON_SE_PPE_DREG_FB_SIZE1                   AMAZON_SE_PPE_REG_ADDR(0x0D23)
+#define AMAZON_SE_PPE_DREG_AT_CELL0                   AMAZON_SE_PPE_REG_ADDR(0x0D24)
+#define AMAZON_SE_PPE_DREG_AT_CELL1                   AMAZON_SE_PPE_REG_ADDR(0x0D25)
+#define AMAZON_SE_PPE_DREG_AT_IDLE_CNT0               AMAZON_SE_PPE_REG_ADDR(0x0D26)
+#define AMAZON_SE_PPE_DREG_AT_IDLE_CNT1               AMAZON_SE_PPE_REG_ADDR(0x0D27)
+#define AMAZON_SE_PPE_DREG_AT_IDLE0                   AMAZON_SE_PPE_REG_ADDR(0x0D28)
+#define AMAZON_SE_PPE_DREG_AT_IDLE1                   AMAZON_SE_PPE_REG_ADDR(0x0D29)
+#define AMAZON_SE_PPE_DREG_AR_CFG0                    AMAZON_SE_PPE_REG_ADDR(0x0D60)
+#define AMAZON_SE_PPE_DREG_AR_CFG1                    AMAZON_SE_PPE_REG_ADDR(0x0D61)
+#define AMAZON_SE_PPE_DREG_AR_FB_START0               AMAZON_SE_PPE_REG_ADDR(0x0D62)
+#define AMAZON_SE_PPE_DREG_AR_FB_START1               AMAZON_SE_PPE_REG_ADDR(0x0D63)
+#define AMAZON_SE_PPE_DREG_AR_FB_END0                 AMAZON_SE_PPE_REG_ADDR(0x0D64)
+#define AMAZON_SE_PPE_DREG_AR_FB_END1                 AMAZON_SE_PPE_REG_ADDR(0x0D65)
+#define AMAZON_SE_PPE_DREG_AR_ATM_STAT0               AMAZON_SE_PPE_REG_ADDR(0x0D66)
+#define AMAZON_SE_PPE_DREG_AR_ATM_STAT1               AMAZON_SE_PPE_REG_ADDR(0x0D67)
+#define AMAZON_SE_PPE_DREG_AR_CELL0                   AMAZON_SE_PPE_REG_ADDR(0x0D68)
+#define AMAZON_SE_PPE_DREG_AR_CELL1                   AMAZON_SE_PPE_REG_ADDR(0x0D69)
+#define AMAZON_SE_PPE_DREG_AR_IDLE_CNT0               AMAZON_SE_PPE_REG_ADDR(0x0D6A)
+#define AMAZON_SE_PPE_DREG_AR_IDLE_CNT1               AMAZON_SE_PPE_REG_ADDR(0x0D6B)
+#define AMAZON_SE_PPE_DREG_AR_AIIDLE_CNT0             AMAZON_SE_PPE_REG_ADDR(0x0D6C)
+#define AMAZON_SE_PPE_DREG_AR_AIIDLE_CNT1             AMAZON_SE_PPE_REG_ADDR(0x0D6D)
+#define AMAZON_SE_PPE_DREG_AR_BE_CNT0                 AMAZON_SE_PPE_REG_ADDR(0x0D6E)
+#define AMAZON_SE_PPE_DREG_AR_BE_CNT1                 AMAZON_SE_PPE_REG_ADDR(0x0D6F)
+#define AMAZON_SE_PPE_DREG_AR_HEC_CNT0                AMAZON_SE_PPE_REG_ADDR(0x0D70)
+#define AMAZON_SE_PPE_DREG_AR_HEC_CNT1                AMAZON_SE_PPE_REG_ADDR(0x0D71)
+#define AMAZON_SE_PPE_DREG_AR_CD_CNT0                 AMAZON_SE_PPE_REG_ADDR(0x0D72)
+#define AMAZON_SE_PPE_DREG_AR_CD_CNT1                 AMAZON_SE_PPE_REG_ADDR(0x0D73)
+#define AMAZON_SE_PPE_DREG_AR_IDLE0                   AMAZON_SE_PPE_REG_ADDR(0x0D74)
+#define AMAZON_SE_PPE_DREG_AR_IDLE1                   AMAZON_SE_PPE_REG_ADDR(0x0D75)
+#define AMAZON_SE_PPE_DREG_AR_DELIN0                  AMAZON_SE_PPE_REG_ADDR(0x0D76)
+#define AMAZON_SE_PPE_DREG_AR_DELIN1                  AMAZON_SE_PPE_REG_ADDR(0x0D77)
+#define AMAZON_SE_PPE_DREG_RESV0                      AMAZON_SE_PPE_REG_ADDR(0x0D78)
+#define AMAZON_SE_PPE_DREG_RESV1                      AMAZON_SE_PPE_REG_ADDR(0x0D79)
+#define AMAZON_SE_PPE_DREG_RX_MIB_CMD0                AMAZON_SE_PPE_REG_ADDR(0x0D80)
+#define AMAZON_SE_PPE_DREG_RX_MIB_CMD1                AMAZON_SE_PPE_REG_ADDR(0x0D81)
+#define AMAZON_SE_PPE_DREG_AR_OVDROP_CNT0             AMAZON_SE_PPE_REG_ADDR(0x0D98)
+#define AMAZON_SE_PPE_DREG_AR_OVDROP_CNT1             AMAZON_SE_PPE_REG_ADDR(0x0D99)
+
+
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define AMAZON_SE_PPE32_BASE  0xBE180000
+#define AMAZON_SE_PPE32_DEBUG_BREAK_TRACE_REG   (AMAZON_SE_PPE32_BASE + (0x0000 * 4))
+#define AMAZON_SE_PPE32_INT_MASK_STATUS_REG     (AMAZON_SE_PPE32_BASE + (0x0030 * 4))
+#define AMAZON_SE_PPE32_INT_RESOURCE_REG        (AMAZON_SE_PPE32_BASE + (0x0040 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B0         (AMAZON_SE_PPE32_BASE + (0x1000 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B1         (AMAZON_SE_PPE32_BASE + (0x2000 * 4))
+#define AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE   (AMAZON_SE_PPE32_BASE + (0x4000 * 4))
+
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define AMAZON_SE_PPE32_BASE  0xBE180000
+#define AMAZON_SE_PPE32_DEBUG_BREAK_TRACE_REG   (AMAZON_SE_PPE32_BASE + (0x0000 * 4))
+#define AMAZON_SE_PPE32_INT_MASK_STATUS_REG     (AMAZON_SE_PPE32_BASE + (0x0030 * 4))
+#define AMAZON_SE_PPE32_INT_RESOURCE_REG        (AMAZON_SE_PPE32_BASE + (0x0040 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B0         (AMAZON_SE_PPE32_BASE + (0x1000 * 4))
+#define AMAZON_SE_PPE32_CDM_CODE_MEM_B1         (AMAZON_SE_PPE32_BASE + (0x2000 * 4))
+#define AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE   (AMAZON_SE_PPE32_BASE + (0x4000 * 4))
+
+/*
+ *    ETOP MDIO Registers
+ */
+#define ETOP_MDIO_CFG           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0600 * 4)))
+#define ETOP_MDIO_ACC           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0601 * 4)))
+#define ETOP_CFG                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0602 * 4)))
+#define ETOP_IG_VLAN_COS        ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0603 * 4)))
+#define ETOP_IG_DSCP_COS3       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0604 * 4)))
+#define ETOP_IG_DSCP_COS2       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0605 * 4)))
+#define ETOP_IG_DSCP_COS1       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0606 * 4)))
+#define ETOP_IG_DSCP_COS0       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0607 * 4)))
+#define ETOP_IG_PLEN_CTRL       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0608 * 4)))
+#define ETOP_ISR                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060A * 4)))
+#define ETOP_IER                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060B * 4)))
+#define ETOP_VPID               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060C * 4)))
+#define ENET_MAC_CFG            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define ENETS_DBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0612 * 4)))
+#define ENETS_CBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0613 * 4)))
+#define ENETS_CFG               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0614 * 4)))
+#define ENETS_PGCNT             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0615 * 4)))
+#define ENETS_PKTCNT            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0616 * 4)))
+#define ENETS_BUF_CTRL          ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0617 * 4)))
+#define ENETS_COS_CFG           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+#define ENETS_IGDROP            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define ENETS_IGERR             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061A * 4)))
+#define ENET_MAC_DA0           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061B * 4)))
+#define ENET_MAC_DA1           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061C * 4)))
+
+#define ENETF_DBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0630 * 4)))
+#define ENETF_CBA               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0631 * 4)))
+#define ENETF_CFG               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0632 * 4)))
+#define ENETF_PGCNT             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0633 * 4)))
+#define ENETF_PKTCNT            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0634 * 4)))
+#define ENETF_HFCTRL            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0635 * 4)))
+#define ENETF_TXCTRL            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0636 * 4)))
+
+#define ENETF_VLCOS0            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0638 * 4)))
+#define ENETF_VLCOS1            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0639 * 4)))
+#define ENETF_VLCOS2            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063A * 4)))
+#define ENETF_VLCOS3            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063B * 4)))
+#define ENETF_EGERR             ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063C * 4)))
+#define ENETF_EGDROP            ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063D * 4)))
+
+
+/*
+ *    ETOP MDIO Registers
+ */
+#define AMAZON_SE_PPE32_ETOP_MDIO_CFG           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0600 * 4)))
+#define AMAZON_SE_PPE32_ETOP_MDIO_ACC           ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0601 * 4)))
+#define AMAZON_SE_PPE32_ETOP_CFG                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0602 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_VLAN_COS        ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0603 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS3       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0604 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS2       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0605 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS1       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0606 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_DSCP_COS0       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0607 * 4)))
+#define AMAZON_SE_PPE32_ETOP_IG_PLEN_CTRL       ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0608 * 4)))
+#define AMAZON_SE_PPE32_ETOP_ISR                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060A * 4)))
+#define AMAZON_SE_PPE32_ETOP_IER                ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060B * 4)))
+#define AMAZON_SE_PPE32_ETOP_VPID               ((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060C * 4)))
+
+
+/* ENET Register */
+#define AMAZON_SE_PPE32_ENET_MAC_CFG            	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define AMAZON_SE_PPE32_ENET_IG_PKTDROP          	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define AMAZON_SE_PPE32_ENET_CoS_CFG          	((volatile u32 *)(AMAZON_SE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+
+
+										/*********LED register definition****************/
+
+#define AMAZON_SE_LED                      0xBE100BB0
+#define AMAZON_SE_LED_CON0                 ((volatile u32*)(AMAZON_SE_LED + 0x0000))
+#define AMAZON_SE_LED_CON1                 ((volatile u32*)(AMAZON_SE_LED + 0x0004))
+#define AMAZON_SE_LED_CPU0                 ((volatile u32*)(AMAZON_SE_LED + 0x0008))
+#define AMAZON_SE_LED_CPU1                 ((volatile u32*)(AMAZON_SE_LED + 0x000C))
+#define AMAZON_SE_LED_AR                   ((volatile u32*)(AMAZON_SE_LED + 0x0010))
+
+/***********************************************************************/
+/*  Module      :  EBU register address and bits                       */
+/***********************************************************************/
+
+#define AMAZON_SE_EBU                          (0xBE105300)
+#define EBU_ADDR_SEL_0     (volatile u32*)(AMAZON_SE_EBU + 0x20)
+#define EBU_ADDR_SEL_1     (volatile u32*)(AMAZON_SE_EBU + 0x24)
+#define EBU_CON_0          (volatile u32*)(AMAZON_SE_EBU + 0x60)
+#define EBU_CON_1          (volatile u32*)(AMAZON_SE_EBU + 0x64)
+#define EBU_NAND_CON       (volatile u32*)(AMAZON_SE_EBU + 0xB0)
+#define EBU_NAND_WAIT      (volatile u32*)(AMAZON_SE_EBU + 0xB4)
+#define EBU_NAND_ECC0      (volatile u32*)(AMAZON_SE_EBU + 0xB8)
+#define EBU_NAND_ECC_AC    (volatile u32*)(AMAZON_SE_EBU + 0xBC)
+
+
+
+
+/***********************************************************************/
+#define AMAZON_SE_REG32(addr)		   *((volatile u32 *)(addr))
+/***********************************************************************/
+#endif //AMAZON_SE_H
--- /dev/null
+++ b/include/asm-mips/lib.h
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * DANUBE BootROM
+ * Copyright (c) 2005, Infineon Technologies AG, All rights reserved
+ * COM NRW CSE VoIP
+ *****************************************************************************/
+
+#ifndef __LIB_H
+#define __LIB_H
+
+/******************************************************************************
+ * Global types
+ ******************************************************************************/
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned long u32;
+typedef signed   long s32;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+typedef volatile unsigned short vuint;
+
+/* for simulation codes */
+#define REG32(addr) (*((volatile u32*)(addr)))
+
+/******************************************************************************
+ * Global macros
+ ******************************************************************************/
+#define WRITEU32(add, value) *((u32*)addr) = value;
+/* #define U8TOU16(addr) (*(addr) << 8 | *((addr)+1)) */
+/* #define U8TOU32(addr) (*((addr)+3) << 24 | *((addr)+2) << 16 | *((addr)+1) << 8 | *((addr)+0)) */
+/* #define U8TOU32(addr) (*((addr)+0) << 24 | *((addr)+1) << 16 | *((addr)+2) << 8 | *((addr)+3)) */
+#define U8TOU32(addr) (*((u32 *)(addr)))
+
+/******************************************************************************
+ * Global functions
+ ******************************************************************************/
+u8* memcpy(u8* dest, const u8* source, int count);
+u8* icachecpy(u8* dest, const u8* source, int count);
+void cache_wrt(void);
+u32 get_timer(u32 base);
+u32 danube_get_fpiclk (void);
+u32 danube_get_cpuclk (void);
+void htoa(u32 hex, u8 *buf);
+void decrypt(u32 addr, int n);
+void print_u32(u32 data);
+void print_u8(u8 data);
+#ifdef USE_DDR_SDRAM
+#warning "DDR is included"
+void config_ddr(void);
+#endif
+#if 0
+void jump_start(u32 addr);
+#endif
+
+#endif /* __LIB_H */
+
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -48,6 +48,7 @@
 #define CP0_CAUSE $13
 #define CP0_EPC $14
 #define CP0_PRID $15
+#define CP0_EBASE $15,1
 #define CP0_CONFIG $16
 #define CP0_LLADDR $17
 #define CP0_WATCHLO $18
@@ -330,11 +331,32 @@
 #  define KSU_USER		0x00000010
 #  define KSU_SUPERVISOR	0x00000008
 #  define KSU_KERNEL		0x00000000
+#ifdef CONFIG_DANUBE	/* MIPS 24KE */
+/* bits 5 & 6 & 7: reserved */
+/* bits 8~15: IM0~7 */
+/* bits 16: reserved */
+#define ST0_CEE			0x00020000
+/* bits 18: always 0 */
+#define ST0_NMI			0x00080000
+#define ST0_SR			0x00100000
+#define ST0_TS			0x00200000
+#define ST0_BEV			0x00400000
+/* bits 23: reserved */
+#define ST0_MX			0x01000000
+#define ST0_RE			0x02000000
+#define ST0_FR			0x04000000
+#define ST0_RP			0x08000000
+#define ST0_CU0			0x10000000
+#define ST0_CU1			0x20000000
+#define ST0_CU2			0x40000000
+#define ST0_CU3			0x80000000
+#else
 #define ST0_UX			0x00000020
 #define ST0_SX			0x00000040
 #define ST0_KX 			0x00000080
 #define ST0_DE			0x00010000
 #define ST0_CE			0x00020000
+#endif
 
 /*
  * Bitfields in the R[23]000 cp0 status register.
@@ -471,6 +493,14 @@
 #define  CAUSEF_BD		(1   << 31)
 
 /*
+ * Bits in the coprocessor 0 EBase register
+ */
+#define EBASEB_CPUNUM		0
+#define EBASEF_CPUNUM		(0x3ff << EBASEB_CPUNUM)
+#define EBASEB_EXPBASE		12
+#define EBASEF_EXPBASE		(0x3ffff << EBASEB_EXPBASE)
+
+/*
  * Bits in the coprozessor 0 config register.
  */
 #define CONF_CM_CACHABLE_NO_WA		0
@@ -544,4 +574,10 @@
 #define CEB_KERNEL	2	/* Count events in kernel mode EXL = ERL = 0 */
 #define CEB_EXL		1	/* Count events with EXL = 1, ERL = 0 */
 
+/*
+ * Bits in ErrCtl register
+ */
+#define ECCB_WST	29
+#define ECCF_WST	(0x1 << ECCB_WST)
+
 #endif /* _ASM_MIPSREGS_H */
--- /dev/null
+++ b/include/asm-mips/pinstrap.h
@@ -0,0 +1,12 @@
+#define FLASH_STRAP		0x1
+#define MII_0_STRAP		0x2
+#define MII_1_STRAP		0x3
+#define ASC_STRAP		0x4
+#define SFLASH_STRAP		0x5
+#define RESERVE_STRAP		0x6
+#define PRODUCT_TEST_STRAP	0x7
+#define PIN_STRAP_MASK		0x001C0000
+#define PIN_STRAP_SHIFT		18
+#define PIN_STRAP		0xB0100914
+#define SDRAM_WIDTH_MASK	0x400000
+#define SDRAM_WIDTH_SHIFT	22
--- /dev/null
+++ b/include/asm-mips/romconfig.h
@@ -0,0 +1,66 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the DANUBE board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+
+#define EXCEPTION_BASE	0x200
+
+/*****************************************************************************
+ * DANUBE
+ *****************************************************************************/
+/* lock cache for C program stack */
+/* points to ROM */
+/* stack size is 16K */
+#define LOCK_DCACHE_ADDR       	0x9FC00000
+#define LOCK_DCACHE_SIZE       	0x1000
+#define CFG_EBU_BOOTWORD	      0x688c688c
+
+#define CFG_HZ       (danube_get_cpuclk() / 2)
+
+
+/*
+ * Memory layout
+ */
+//#define CFG_SDRAM_BASE       0x80080000
+#define CFG_CACHE_LOCK_SIZE  LOCK_DCACHE_SIZE
+#define CFG_INIT_SP_OFFSET   CFG_CACHE_LOCK_SIZE
+
+/*
+ * Cache settings
+ */
+#define CFG_CACHE_SIZE   16384
+#define CFG_CACHE_LINES  32
+#define CFG_CACHE_WAYS   4
+#define CFG_CACHE_SETS   128
+
+#define CFG_ICACHE_SIZE   CFG_CACHE_SIZE
+#define CFG_DCACHE_SIZE   CFG_CACHE_SIZE
+#define CFG_CACHELINE_SIZE  CFG_CACHE_LINES
+
+#endif	/* __CONFIG_H */
--- /dev/null
+++ b/include/boot.h
@@ -0,0 +1,90 @@
+#ifndef _BOOT_H
+#define _BOOT_H
+
+#include <asm/addrspace.h>
+#include <asm/ifx_mips.h>
+
+
+/* All this should be defined somewhere in danube.h later... */
+
+//#define MPS_SRAM_BASE_ADDRESS   0xBF200000
+//#define MPS_SRAM_BOOT_OFFSET    0x1C0
+
+/* Offset for CPU1 (both CPUs have same register set) */
+#define BOOT_BASE_ADDRESS   (AMAZON_SE_PPE_BASE_ADDR + (0x8200 << 2)) // SB_RAM0
+#define BOOT_CPU_OFFSET     0x20
+
+
+#ifdef __ASSEMBLY__
+#define BOOT_RVEC		      (BOOT_BASE_ADDRESS + 0x00)
+#define BOOT_NVEC		      (BOOT_BASE_ADDRESS + 0x04)
+#define BOOT_EVEC		      (BOOT_BASE_ADDRESS + 0x08)
+#define BOOT_CP0_CAUSE     (BOOT_BASE_ADDRESS + 0x0C)
+#define BOOT_CP0_EPC	      (BOOT_BASE_ADDRESS + 0x10)
+#define BOOT_CP0_EEPC	   (BOOT_BASE_ADDRESS + 0x14)
+#define BOOT_SIZE        (BOOT_BASE_ADDRESS + 0x18)   /* for CPU1 */
+#define BOOT_RCU_SR        (BOOT_BASE_ADDRESS + 0x18) /* for CPU0 */
+#define BOOT_CFG_STAT	   (BOOT_BASE_ADDRESS + 0x1C)
+#else
+#define BOOT_RVEC(cpu)		(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x00)
+#define BOOT_NVEC(cpu)		(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x04)
+#define BOOT_EVEC(cpu)		(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x08)
+#define BOOT_CP0_STATUS(cpu)	(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x0C)
+#define BOOT_CP0_EPC(cpu)	(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x10)
+#define BOOT_CP0_EEPC(cpu)	(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x14)
+#define BOOT_SIZE(cpu)       (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x18)    /* for CPU1 */
+#define BOOT_RCU_SR(cpu)       (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x18)  /* for CPU0 */
+#define BOOT_CFG_STAT(cpu)	(volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x1C)
+#endif
+
+#define BOOT_CFG_NOR   		0x01
+#define BOOT_CFG_EPHY   	0x02
+#define BOOT_CFG_RMII   	0x03
+#define BOOT_CFG_ASC   		0x04
+#define BOOT_CFG_SFLASH		0x05
+#define BOOT_CFG_NAND  		0x06
+#define BOOT_CFG_REVMII   	0x07
+#define BOOT_CFG_TEST   	0x00
+
+#define BOOT_NUM_RETRY  3
+
+#define BOOT_STAT_MASK_ALL     0x0000FFFF
+#define BOOT_STAT_MASK_STAT    0x0000F000
+#define BOOT_STAT_MASK_BERR    0x00000F00
+#define BOOT_STAT_MASK_BSTRAP  0x000000F0
+#define BOOT_STAT_MASK_BMODULE 0x0000000F
+
+#define BOOT_STAT_INIT         0x00000000
+#define BOOT_STAT_BSTRAP       0x00001000
+#define BOOT_STAT_RETRY        0x00002000
+#define BOOT_STAT_START        0x00003000
+#define BOOT_STAT_HALT         0x0000F000
+
+#define BOOT_ERR_NO_RVEC       0x00000100
+#define BOOT_ERR_NO_NVEC       0x00000200
+#define BOOT_ERR_NO_EVEC       0x00000300
+#define BOOT_ERR_BSTRAP        0x00000400
+#define BOOT_ERR_EXC           0x00000800
+
+#ifndef __ASSEMBLY__
+void boot_set_status( u32 status, u32 mask);
+void boot_set_config( u32 config);
+void boot_set_rvec( u32 vector);
+void boot_set_size( u32 size);
+void boot_sdbg( u8* string, u32 value);
+void boot_error( u32 berr);
+int boot_from_ebu(void);
+void _boot_rvec(void);
+typedef struct
+{
+	u32   cpu;              /** CPU number */
+	u32   config;           /** Boot configuration */
+   u32   endian;           /** CPU endianess */
+   u32   debug;            /** Debug mode */
+	u32	(*exit)(void);	   /** application vector */
+} boot_data;
+
+extern boot_data bootrom;
+#endif
+
+#endif /* #ifdef _BOOT_H */
--- a/include/cmd_confdefs.h
+++ b/include/cmd_confdefs.h
@@ -94,6 +94,7 @@
 #define CFG_CMD_EXT2	0x1000000000000000ULL	/* EXT2 Support			*/
 #define CFG_CMD_SNTP	0x2000000000000000ULL	/* SNTP support			*/
 #define CFG_CMD_DISPLAY	0x4000000000000000ULL	/* Display support		*/
+#define CFG_CMD_DHRYSTONE	0x8000000000000000ULL	/* Dhrystone benchmark support		*/
 
 #define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
 
@@ -141,6 +142,7 @@
 			CFG_CMD_SPI	| \
 			CFG_CMD_UNIVERSE | \
 			CFG_CMD_USB	| \
+			CFG_CMD_DHRYSTONE | \
 			CFG_CMD_VFD	)
 
 /* Default configuration
--- /dev/null
+++ b/include/cmd_dhry.h
@@ -0,0 +1,107 @@
+/*
+ *************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *
+ *  Version:    C, Version 2.1
+ *
+ *  File:       dhry.h (part 1 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *              Siemens Nixdorf Inf. Syst.
+ *              STM OS 32
+ *              Otto-Hahn-Ring 6
+ *              W-8000 Muenchen 83
+ *              Germany
+ *                      Phone:    [+49]-89-636-42436
+ *                                (8-17 Central European Time)
+ *                      UUCP:     weicker@ztivax.uucp@unido.uucp
+ *                      Internet: weicker@ztivax.siemens.com
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are
+ *              used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 834-1378 (9-17 EST)
+ *                      UUCP:   ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software
+ *      used. Hardware information includes: Machine type, CPU, type and
+ *      size of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states). Software information includes: Compiler
+ *      (and runtime library) manufacturer and version, compilation
+ *      switches, OS version. The Operating System version may give an
+ *      indication about the compiler; Dhrystone itself performs no OS
+ *      calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ *************************************************************************
+ */
+#ifndef _CMD_DHRYSTONE_H
+#define _CMD_DHRYSTONE_H
+
+#define Mic_secs_Per_Second     1000000.0
+#define structassign(d, s)      d = s
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+#define Null 	0
+#define true 	1
+#define false 	0
+
+typedef int	One_Thirty;
+typedef int	One_Fifty;
+typedef char	Capital_Letter;
+typedef int	Boolean;
+typedef char	Str_30 [31];
+typedef int	Arr_1_Dim [50];
+typedef int	Arr_2_Dim [50] [50];
+typedef int	Enumeration;
+
+typedef struct record {
+	struct record *Ptr_Comp;
+	Enumeration Discr;
+	union {
+		struct {
+			Enumeration Enum_Comp;
+			int Int_Comp;
+			char Str_Comp [31];
+		} var_1;
+
+		struct {
+			Enumeration E_Comp_2;
+			char Str_2_Comp [31];
+		} var_2;
+
+		struct {
+			char Ch_1_Comp;
+			char Ch_2_Comp;
+		} var_3;
+	} variant;
+} Rec_Type, *Rec_Pointer;
+
+int do_dhrystone (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+#endif
+
--- /dev/null
+++ b/include/cmd_upgrade.h
@@ -0,0 +1,48 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+// 509071:tc.che 2005/09/07 Reduced flash writing time.
+
+//509071:tc.chen start
+// the header of configuration data.
+struct conf_header {
+	unsigned long size;
+	unsigned long crc;
+};
+//509061:tc.chen end
+
+enum ExpandDir { FORWARD = 0, BACKWARD = 1 };
+#define MAX_PARTITION	10
+#define MAX_DATABLOCK	16
+
+#define UBOOTCONFIG_COPY_HEADER	"123456789ABCDEF"
+
+#ifndef BUILD_FROM_IFX_UTILITIES
+
+int do_upgrade(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+int do_upgrade_oneimage(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+int upgrade_img(ulong srcAddr,ulong srcLen,char *imgName,enum ExpandDir dir,int bSaveEnv);/*000001:Nirav*/
+
+int saveenv_copy(void);
+
+#endif
--- /dev/null
+++ b/include/configs/ifx_cfg.h
@@ -0,0 +1,275 @@
+/* ============================================================================
+ * Copyright (C) 2003[- 2004] ? Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ *
+ * File Name: ifx_cfg.h
+ * Author : Mars Lin (mars.lin@infineon.com)
+ * Date:
+ *
+ * ===========================================================================
+ *
+ * Project:
+ * Block:
+ *
+ * ===========================================================================
+ * Contents:  This file contains the data structures and definitions used
+ * 	      by the core iptables and the sip alg modules.
+ * ===========================================================================
+ * References:
+ */
+
+/*
+ * This file contains the configuration parameters for the IFX board.
+ */
+#ifndef _IFX_CFG_H_
+#define _IFX_CFG_H_
+
+/*-----------------------------------------------------------------------
+ * U-Boot/Kernel configurations
+ */
+#define IFX_CFG_UBOOT_DEFAULT_CFG_IPADDR		"192.168.1.1"
+#define IFX_CFG_UBOOT_DEFAULT_CFG_SERVERIP		"192.168.1.2"
+#define IFX_CFG_UBOOT_DEFAULT_CFG_ETHADDR		"08:01:11:11:11:11"
+#define IFX_CFG_UBOOT_DEFAULT_CFG_NETDEV		"eth0"
+#define IFX_CFG_UBOOT_DEFAULT_CFG_BAUDRATE		"115200"
+#define IFX_CFG_UBOOT_DEFAULT_CFG_TTY			"ttyS0"
+#define IFX_CFG_UBOOT_DEFAULT_CFG_FLASH_ADDRESS		"B0000000"
+
+/* End of U-Boot/Kernel configurations
+ *-----------------------------------------------------------------------
+ */
+
+/*-----------------------------------------------------------------------
+ * Board specific configurations
+ */
+#ifdef IFX_CONFIG_MEMORY_SIZE
+	#define IFX_CFG_MEM_SIZE	IFX_CONFIG_MEMORY_SIZE
+#else
+	#error "ERROR!! Define memory size first!"
+#endif
+
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#if (IFX_ADSL_FIRMWARE_IN_ROOTFS == 1)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO					\
+	"data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"	\
+	"data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"	\
+	"data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"	\
+	"data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"		\
+	"data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"		\
+	"data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"	\
+	"total_db=6\0"
+
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME		"uboot"
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR		0xB0000000
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME		"/dev/mtdblock0"
+
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME		"rootfs"
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0010000
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME	"/dev/mtdblock1"
+
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME		"kernel"
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR		0xB01FD1FF
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE			0
+
+	#define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME		"sysconfig"
+	#define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR		0xB01FD200
+	#define IFX_CFG_FLASH_SYSTEM_CFG_SIZE			0
+	#define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR		0xB01FF1FF
+
+	#define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME		"ubootconfig"
+	#define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR		0xB01FF200
+	#define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x0C00
+	#define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR		0xB01FFDFF
+
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME		"fwdiag"
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR		0xB01FFE00
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE		0x0200
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR		0xB01FFFFF
+
+	#define IFX_CFG_FLASH_END_ADDR				0xB01FFFFF
+#else
+/* ADSL Firmware exits as a seperate MTD partition */
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "part2_begin=0xB0040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO					\
+	"data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"	\
+	"data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"	\
+	"data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"	\
+	"data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"	\
+	"data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"		\
+	"data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"		\
+	"data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"	\
+	"total_db=7\0"
+
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME		"uboot"
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR		0xB0000000
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME		"/dev/mtdblock0"
+
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME		"firmware"
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0xB0010000
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE		0
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME	"/dev/mtdblock1"
+
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME		"rootfs"
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0040000
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME	"/dev/mtdblock2"
+
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME		"kernel"
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR		0xB01FD1FF
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE			0
+
+	#define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME		"sysconfig"
+	#define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR		0xB01FD200
+	#define IFX_CFG_FLASH_SYSTEM_CFG_SIZE			0
+	#define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR		0xB01FF1FF
+
+	#define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME		"ubootconfig"
+	#define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR		0xB01FF200
+	#define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x0C00
+	#define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR		0xB01FFDFF
+
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME		"fwdiag"
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR		0xB01FFE00
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE		0x0200
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR		0xB01FFFFF
+
+	#define IFX_CFG_FLASH_END_ADDR				0xB01FFFFF
+
+#endif // IFX_ADSL_FIRMWARE_IN_ROOTFS
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#if (IFX_ADSL_FIRMWARE_IN_ROOTFS == 1)
+
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+	"data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"	\
+	"total_db=6\0"
+
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME		"uboot"
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR		0xB0000000
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME		"/dev/mtdblock0"
+
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME		"rootfs"
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0010000
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME	"/dev/mtdblock1"
+
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME		"kernel"
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR		0xB03FB1FF
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE			0
+
+	#define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME		"sysconfig"
+	#define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR		0xB03FB200
+	#define IFX_CFG_FLASH_SYSTEM_CFG_SIZE			0
+	#define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR		0xB03FF1FF
+
+	#define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME		"ubootconfig"
+	#define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR		0xB03FF200
+	#define IFX_CFG_FLASH_UBOOT_CFG_SIZE			0x0C00
+	#define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR		0xB03FFDFF
+
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME		"fwdiag"
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR		0xB03FFE00
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE		0x0200
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR		0xB03FFFFF
+
+	#define IFX_CFG_FLASH_END_ADDR				0xB03FFFFF
+#else
+/* ADSL Firmware exits as a seperate MTD partition */
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "part2_begin=0xB0040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+	"data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"	\
+	"total_db=7\0"
+
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME		"uboot"
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR		0xB0000000
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME		"/dev/mtdblock0"
+
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME		"firmware"
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0xB0010000
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE		0
+	#define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME	"/dev/mtdblock1"
+
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME		"rootfs"
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0040000
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE			0
+	#define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME	"/dev/mtdblock2"
+
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME		"kernel"
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR		0xB03FB1FF
+	#define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE			0
+
+	#define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME		"sysconfig"
+	#define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR		0xB03FB200
+	#define IFX_CFG_FLASH_SYSTEM_CFG_SIZE			0
+	#define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR		0xB03FF1FF
+
+	#define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME		"ubootconfig"
+	#define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR		0xB03FF200
+	#define IFX_CFG_FLASH_UBOOT_CFG_SIZE			0x0C00
+	#define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR		0xB03FFDFF
+
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME		"fwdiag"
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR		0xB03FFE00
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE		0x0200
+	#define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR		0xB03FFFFF
+
+	#define IFX_CFG_FLASH_END_ADDR				0xB03FFFFF
+
+#endif	// IFX_ADSL_FIRMWARE_IN_ROOTFS
+
+#else
+	#error "ERROR!! Define flash size first!"
+#endif
+/* End of Board specific configurations
+ *-----------------------------------------------------------------------
+ */
+
+#endif
--- /dev/null
+++ b/include/configs/ifx_extra_env.h
@@ -0,0 +1,81 @@
+/* ============================================================================
+ * Copyright (C) 2003[- 2004] ? Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ *
+ * File Name: ifx_extra_env.h
+ * Author : Mars Lin (mars.lin@infineon.com)
+ * Date:
+ *
+ * ===========================================================================
+ *
+ * Project:
+ * Block:
+ *
+ * ===========================================================================
+ * Contents:  This file contains the data structures and definitions used
+ * 	      by the core iptables and the sip alg modules.
+ * ===========================================================================
+ * References:
+ */
+	"mem=" MK_STR(IFX_CONFIG_KERNEL_MEMORY_SIZE) "M\0"
+   	"ipaddr=" IFX_CFG_UBOOT_DEFAULT_CFG_IPADDR "\0"
+	"serverip=" IFX_CFG_UBOOT_DEFAULT_CFG_SERVERIP "\0"
+	"ethaddr=" IFX_CFG_UBOOT_DEFAULT_CFG_ETHADDR "\0"
+	"netdev=" IFX_CFG_UBOOT_DEFAULT_CFG_NETDEV "\0"
+	"baudrate=" IFX_CFG_UBOOT_DEFAULT_CFG_BAUDRATE "\0"
+	"rootpath=/opt/nfs\0"
+	"nfsargs=setenv bootargs root=/dev/nfs rw nfsroot=$(serverip):$(rootpath)\0"
+	"ramargs=setenv bootargs root=/dev/ram rw\0"
+	"addip=setenv bootargs $(bootargs) ip=$(ipaddr):$(serverip):$(gatewayip):$(netmask):$(hostname):$(netdev):on\0"
+	"addmisc=setenv bootargs $(bootargs) console=" IFX_CFG_UBOOT_DEFAULT_CFG_TTY ",$(baudrate) ethaddr=$(ethaddr) mem=$(mem) panic=1\0"
+	"flash_nfs=run nfsargs addip addmisc;bootm $(kernel_addr)\0"
+	"ramdisk_addr=B0100000\0"
+	"flash_self=run ramargs addip addmisc;bootm $(kernel_addr) $(ramdisk_addr)\0"
+	"bootfile=uImage\0"
+	"u-boot=u-boot.ifx\0"
+	"firmware=firmware.img\0"
+	"fullimage=ifx_adslrt.img\0"
+	"net_nfs=tftp 80500000 $(bootfile);run nfsargs addip addmisc;bootm\0"
+        "root_filesystem=rootfs.img\0"
+	"load=tftp 80500000 $(u-boot)\0"
+	"update=protect off 1:0-2;era 1:0-2;cp.b 80500000 " IFX_CFG_UBOOT_DEFAULT_CFG_FLASH_ADDRESS " $(filesize)\0"
+	"flashargs=setenv bootargs root=" IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME "\0"
+	"flash_flash=run flashargs addip addmisc; bootm $(kernel_addr)\0"
+	"update_uboot=tftpboot 80400000 $(u-boot);erase all; cp.b 80400000 b0000000 $(filesize)\0"
+	"update_kernel=tftpboot 80400000 $(bootfile);upgrade 80400000 $(filesize)\0"
+	"update_rootfs=tftpboot 80400000 $(root_filesystem);upgrade 80400000 $(filesize)\0"
+	"update_firmware=tftpboot 80400000 $(firmware);upgrade 80400000 $(filesize)\0"
+	"update_fullimage=tftpboot 80400000 $(fullimage);upgrade 80400000 $(filesize)\0"
+	"reset_uboot_config=erase " MK_STR(IFX_CFG_FLASH_UBOOT_CFG_START_ADDR) " " MK_STR(IFX_CFG_FLASH_UBOOT_CFG_END_ADDR) " 1;erase $(f_rootfs_end) $(f_kernel_addr) 1\0"
+	IFX_CFG_FLASH_PARTITIONS_INFO
+	"flash_end=" MK_STR(IFX_CFG_FLASH_END_ADDR) "\0"
+	IFX_CFG_FLASH_DATA_BLOCKS_INFO
+	"f_uboot_addr=" MK_STR(IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR) "\0"
+	"f_uboot_size=" MK_STR(IFX_CFG_FLASH_UBOOT_IMAGE_SIZE) "\0"
+	"f_firmware_addr=" MK_STR(IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR) "\0"
+	"f_firmware_size=" MK_STR(IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE) "\0"
+	"f_rootfs_addr=" MK_STR(IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR) "\0"
+	"f_rootfs_size=" MK_STR(IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE) "\0"
+	"f_rootfs_end=" MK_STR(IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR) "\0"
+	"f_kernel_addr=" MK_STR(IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR) "\0"
+	"kernel_addr=" MK_STR(IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR) "\0"
+	"f_kernel_size=" MK_STR(IFX_CFG_FLASH_KERNEL_IMAGE_SIZE) "\0"
+	"f_sysconfig_addr=" MK_STR(IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR) "\0"
+	"f_sysconfig_size=" MK_STR(IFX_CFG_FLASH_SYSTEM_CFG_SIZE) "\0"
+	"f_ubootconfig_addr=" MK_STR(IFX_CFG_FLASH_UBOOT_CFG_START_ADDR) "\0"
+	"f_ubootconfig_size=" MK_STR(IFX_CFG_FLASH_UBOOT_CFG_SIZE) "\0"
+	"f_fwdiag_addr=" MK_STR(IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR) "\0"
+	"f_fwdiag_size=" MK_STR(IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE) "\0"
+	"chipid=1.2\0"
+	"boardid=112233\0"
+
--- /dev/null
+++ b/include/configs/ifx_mips.h
@@ -0,0 +1,247 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the amazon_se board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ifx_cfg.h>
+
+#define  USE_REFERENCE_BOARD
+//#define   USE_EVALUATION_BOARD
+
+#define   AMAZON_SE_BOOT_FROM_EBU
+
+#define CLK_OUT2_25MHZ
+#define CONFIG_MIPS32		1		/* MIPS 4Kc CPU core	*/
+#define CONFIG_AMAZON_SE	1		/* on a Amazon_SE Board	*/
+
+#ifndef IFX_CONFIG_KERNEL_MEMORY_SIZE
+#define IFX_CONFIG_KERNEL_MEMORY_SIZE	IFX_CONFIG_MEMORY_SIZE
+#endif
+
+#define CPU_CLOCK_RATE		266666666	/* 266 MHz clock for the MIPS core */
+
+#define INFINEON_EBU_BOOTCFG	0x688C688C	/* CMULT = 8 for 150 MHz */
+
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+
+#define CONFIG_BAUDRATE		115200
+
+#define DEBUG_PARSER		2
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 300, 9600, 19200, 38400, 57600, 115200 }
+
+#ifndef CFG_BOOTSTRAP_CODE
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+#endif
+
+#define CONFIG_PREBOOT	"echo;"	\
+	"echo Type \"run flash_nfs\" to mount root filesystem over NFS;" \
+	"echo"
+
+#undef	CONFIG_BOOTARGS
+/* by MarsLin 2005/05/10, to support different hardware configuations */
+#define CONFIG_EXTRA_ENV_SETTINGS	<configs/ifx_extra_env.h>
+
+#define CONFIG_BOOTCOMMAND	"run flash_flash"
+
+#define CONFIG_COMMANDS_YES	(CONFIG_CMD_DFL 	| \
+				 CFG_CMD_ASKENV		| \
+				 CFG_CMD_DHRYSTONE	| \
+				 CFG_CMD_NET    	)
+
+#define CONFIG_COMMANDS_NO	(CFG_CMD_NFS		| \
+				 CFG_CMD_FPGA		| \
+				 CFG_CMD_IMLS		| \
+				 CFG_CMD_ITEST		| \
+				 CFG_CMD_XING		| \
+				 CFG_CMD_IMI		| \
+				 CFG_CMD_BMP		| \
+				 CFG_CMD_BOOTD		| \
+				 CFG_CMD_CONSOLE	| \
+				 CFG_CMD_LOADS		| \
+				 CFG_FLASH_PROTECTION	| \
+				 CFG_CMD_LOADB		)
+
+#define CONFIG_COMMANDS		(CONFIG_COMMANDS_YES & ~CONFIG_COMMANDS_NO)
+
+#if 0
+				 CFG_CMD_DHCP
+				 CFG_CMD_ELF
+				 CFG_CMD_NAND
+#endif
+
+#include <cmd_confdefs.h>
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"AMAZON_SE # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE		(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_HZ			(CPU_CLOCK_RATE / 2)
+
+#define	CFG_LOAD_ADDR		0x80100000	/* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80400000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(135)	/* max number of sectors on one chip */
+#define CFG_MAX_FLASH_SECT_SIZE	65536
+
+#define PHYS_FLASH_1		0xB0000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2		0xB4000000 /* Flash Bank #2 */
+
+#define BOOTSTRAP_TEXT_BASE	0xb0000000
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	UBOOT_RAM_TEXT_BASE 	/* board/ifx/config.mk. = 0xA0800000 */
+#define BOOTSTRAP_CFG_MONITOR_BASE      BOOTSTRAP_TEXT_BASE     /* board/danube/config.mk. = 0xA0800000 */
+#define	CFG_MONITOR_LEN		(256 << 10)
+
+#define CFG_INIT_SP_OFFSET	CFG_CACHE_LOCK_SIZE
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(20 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20 * CFG_HZ) /* Timeout for Flash Write */
+
+#define	CFG_ENV_IS_IN_FLASH	1
+//#define CFG_ENV_IS_NOWHERE	1
+//#define CFG_ENV_IS_IN_NVRAM	1
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		IFX_CFG_FLASH_UBOOT_CFG_START_ADDR
+#define CFG_ENV_SIZE		IFX_CFG_FLASH_UBOOT_CFG_SIZE
+
+#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	1
+
+#define CONFIG_AMAZON_SE_SWITCH
+#define CONFIG_NET_MULTI
+#define CONFIG_ENV_OVERWRITE
+
+#define EXCEPTION_BASE		0x200
+
+/**
+ *\brief definition for nand
+ *
+ */
+#define CFG_MAX_NAND_DEVICE	1	/* Max number of NAND devices		*/
+#define NAND_ChipID_UNKNOWN	0x00
+#define SECTORSIZE		512
+#define NAND_MAX_FLOORS		1
+#define NAND_MAX_CHIPS		1
+
+#define ADDR_COLUMN		1
+#define ADDR_PAGE		2
+#define ADDR_COLUMN_PAGE	3
+
+#define AT91_SMART_MEDIA_ALE	(1 << 22)  /* our ALE is AD22 */
+#define AT91_SMART_MEDIA_CLE	(1 << 21)  /* our CLE is AD21 */
+
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)
+#define WRITE_NAND_COMMAND(d, adr)
+#define WRITE_NAND_ADDRESS(d, adr)
+#define WRITE_NAND(d, adr)
+#define READ_NAND(adr)
+/* the following are NOP's in our implementation */
+#define NAND_CTL_CLRALE(nandptr)
+#define NAND_CTL_SETALE(nandptr)
+#define NAND_CTL_CLRCLE(nandptr)
+#define NAND_CTL_SETCLE(nandptr)
+
+
+#define NAND_BASE_ADDRESS	0xB4000000
+
+#define NAND_WRITE(addr, val)	*((u8*)(NAND_BASE_ADDRESS | (addr))) = val;while((*EBU_NAND_WAIT & 0x08) == 0);
+#define NAND_READ(addr, val)	val = *((u8*)(NAND_BASE_ADDRESS | (addr)))
+#define NAND_CE_SET
+#define NAND_CE_CLEAR
+#define NAND_READY		( ((*EBU_NAND_WAIT)&0x07) == 7)
+#define NAND_READY_CLEAR	*EBU_NAND_WAIT = 0;
+#define WRITE_CMD		0x18
+#define WRITE_ADDR		0x14
+#define WRITE_LADDR		0x10
+#define WRITE_DATA		0x10
+#define READ_DATA		0x10
+#define READ_LDATA		0x00
+#define ACCESS_WAIT
+#define IFX_ATC_NAND		0xc176
+#define IFX_BTC_NAND		0xc166
+#define ST_512WB2_NAND		0x2076
+
+#define NAND_OK			0x00000000    /* Bootstrap succesful, start address in BOOT_RVEC */
+#define NAND_ERR		0x80000000
+#define NAND_ACC_TIMEOUT	(NAND_ERR | 0x00000001)
+#define NAND_ACC_ERR		(NAND_ERR | 0x00000002)
+
+
+/*****************************************************************************
+ * AMAZON_SE
+ *****************************************************************************/
+/* lock cache for C program stack */
+/* points to ROM */
+/* stack size is 8K */
+#define LOCK_DCACHE_ADDR       	0x9FC00000
+#define LOCK_DCACHE_SIZE       	0x2000
+
+/*
+ * Memory layout
+ */
+#define CFG_SDRAM_BASE		0x80000000
+#define CFG_SDRAM_BASE_UNCACHE	0xA0000000
+#define CFG_CACHE_LOCK_SIZE	LOCK_DCACHE_SIZE
+
+/*
+ * Cache settings
+ */
+#define CFG_CACHE_SIZE		8192
+#define CFG_CACHE_LINES		16
+#define CFG_CACHE_WAYS		2
+#define CFG_CACHE_SETS		256
+
+#define CFG_ICACHE_SIZE		CFG_CACHE_SIZE
+#define CFG_DCACHE_SIZE		CFG_CACHE_SIZE
+#define CFG_CACHELINE_SIZE	CFG_CACHE_LINES
+
+#endif	/* __CONFIG_H */
--- a/include/flash.h
+++ b/include/flash.h
@@ -79,7 +79,7 @@
 extern unsigned long flash_init (void);
 extern void flash_print_info (flash_info_t *);
 extern int flash_erase	(flash_info_t *, int, int);
-extern int flash_sect_erase (ulong addr_first, ulong addr_last);
+extern int flash_sect_erase (ulong addr_first, ulong addr_last, unsigned int bPartialErase);
 extern int flash_sect_protect (int flag, ulong addr_first, ulong addr_last);
 
 /* common/flash.c */
@@ -299,6 +299,13 @@
 #define TOSH_ID_FVT160	0xC2		/* TC58FVT160 ID (16 M, top )		*/
 #define TOSH_ID_FVB160	0x43		/* TC58FVT160 ID (16 M, bottom )	*/
 
+#define MX_ID_29LV320AB 0x22A822A8      /* MXIC  MX29LV320AB ID (32 M, bottom ) joelin       */
+#define MX_ID_29LV160BB 0x22492249      /* MXIC  MX29LV160BB ID (16 M, bottom ) joelin       */
+#define MX_ID_29LV640BB 0x22cb22cb      /* MXIC  MX29LV640BB ID (64 M, bottom ) joelin       */
+
+#define MX_ID_29LV160BT	0x22C422C4	/* MXIC  MX29LV160BT ID (16 M, Top ) joelin       */
+#define MX_ID_29LV320ATT	0x22A722A7	/* MXIC  MX29LV320ATT ID (32 M, TOP ) joelin       */
+#define MX_ID_29LV320CT	0x22A722A7	/* MXIC  MX29LV320CT ID (32 M, TOP ) Subbi */
 /*-----------------------------------------------------------------------
  * Internal FLASH identification codes
  *
@@ -369,6 +376,12 @@
 #define FLASH_INTEL640T 0x007A		/* INTEL 28F320B3T ( 64M =  4 M x 16 )	*/
 #define FLASH_INTEL640B 0x007B		/* INTEL 28F320B3B ( 64M =  4 M x 16 )	*/
 
+#if 0
+#define FLASH_28F320J3A 0x007C		/* INTEL 28F320J3A ( 32M = 128K x  32)	*/
+#define FLASH_28F640J3A 0x007D		/* INTEL 28F640J3A ( 64M = 128K x  64)	*/
+#define FLASH_28F128J3A 0x007E		/* INTEL 28F128J3A (128M = 128K x 128)	*/
+#endif
+
 #define FLASH_28F008S5	0x0080		/* Intel 28F008S5  (  1M =  64K x 16 )	*/
 #define FLASH_28F016SV	0x0081		/* Intel 28F016SV  ( 16M = 512k x 32 )	*/
 #define FLASH_28F800_B	0x0083		/* Intel E28F800B  (  1M = ? )		*/
@@ -422,6 +435,13 @@
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 #define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
 
+#define FLASH_29LV320AB 0x00B0          /* MXIC MX29LV320AB( 32M = 4M x 16 ) joelin 10/07/2004*/
+#define FLASH_29LV160BB 0x00B1          /* MXIC MX29LV160BB( 16M = 2M x 16 ) joelin 11/22/2004*/
+#define FLASH_29LV640BB 0x00B2      	/* MXIC MX29LV640BB( 64M = 8M x 16 ) liupeng*/
+#define FLASH_29LV160BT	0x00B3			/* MXIC MX29LV160BT( 16M = 2M x 16 ) joelin 11/29/2004*/
+#define FLASH_29LV320ATT 0x00B4		/* MXIC MX29LV320ATT( 32M = 4M x 16 ) joelin 03/01/2005*/
+#define FLASH_29LV320CT 0x00C2          /* MXIC MX29LV320CT( 16M = 2M x 16 ) */
+
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
 
--- a/include/image.h
+++ b/include/image.h
@@ -132,6 +132,7 @@
 #define IH_COMP_NONE		0	/*  No	 Compression Used	*/
 #define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
 #define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
+#define IH_COMP_LZMA		3	/* lzma Compression Used	*/
 
 #define IH_MAGIC	0x27051956	/* Image Magic Number		*/
 #define IH_NMLEN		32	/* Image Name Length		*/
--- /dev/null
+++ b/lib_bootstrap/Makefile
@@ -0,0 +1,60 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libbootstrap.a
+
+OBJS	:= board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o
+CFLAGS	+= -DCFG_BOOTSTRAP_CODE
+
+ifeq ($(BOOTSTRAP_PRINTF_STATUS), BOOTSTRAP_PRINTF_ENABLED)
+OBJS	+= time.o console.o ctype.o display_options.o vsprintf.o lists.o devices.o
+CFLAGS	+= -DDEBUG_ENABLE_BOOTSTRAP_PRINTF
+endif
+
+SRCS	:= $(OBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(OBJS))
+
+all:	$(SRCS) $(obj).depend $(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+vpath %.c ../common ../lib_generic ../lib_$(CPU)
+
+board_bootstrap.c:
+	ln -s ../lib_$(CPU)/board.c $@
+
+#LzmaDecode.c LzmaWrapper.c string.c crc32.c:
+#	ln -s ../lib_generic/$@ $@
+
+#########################################################################
+
+#include $(SRCTREE)/rules.mk
+$(obj).depend:	$(SRCS)
+		$(CC) -M $(CFLAGS) $^ > $@
+
+sinclude $(obj).depend
+
+#########################################################################
--- /dev/null
+++ b/lib_generic/LzmaDecode.c
@@ -0,0 +1,619 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to
+  statically or dynamically link your Code (or bind by name) to the
+  interfaces of this file without subjecting your linked Code to the
+  terms of the CPL or GNU LGPL. Any modifications or additions
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#ifndef CFG_BOOTSTRAP_CODE
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return result; } \
+  BufferLim = Buffer + size; if (size == 0) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }}
+#else //CFG_BOOTSTRAP_CODE
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { return result; } \
+  BufferLim = Buffer + size; if (size == 0) { return LZMA_RESULT_DATA_ERROR; } }}
+#endif //CFG_BOOTSTRAP_CODE
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else //_LZMA_IN_CB
+
+#ifndef CFG_BOOTSTRAP_CODE
+#define RC_TEST { if (Buffer == BufferLim) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }
+#else //CFG_BOOTSTRAP_CODE
+#define RC_TEST { if (Buffer == BufferLim) { return LZMA_RESULT_DATA_ERROR; } }
+#endif //CFG_BOOTSTRAP_CODE
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+
+#endif //_LZMA_IN_CB
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; }
+
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+  {
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+  {
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1;
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE *
+        (((
+        (nowPos
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+            {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+              printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+              return LZMA_RESULT_DATA_ERROR;
+            }
+
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit)
+      #else
+      if (rep0 > nowPos)
+      #endif
+      {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+        printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
+
+#endif /* CONFIG_LZMA */
--- /dev/null
+++ b/lib_generic/LzmaWrapper.c
@@ -0,0 +1,228 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.c
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+** 24 May 2007	Lin Mars	Fix issue for multiple lzma_inflate involved
+*******************************************************************************/
+#define LZMA_NO_STDIO
+#ifndef LZMA_NO_STDIO
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+#include <config.h>
+#include <common.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+#include "LzmaWrapper.h"
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+static const char *kCantReadMessage = "Can not read from source buffer";
+static const char *kCantAllocateMessage = "Not enough buffer for decompression";
+#endif
+
+static size_t rpos=0, dpos=0;
+
+static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
+{
+  if (size == 0)
+    return 0;
+  memcpy(dest, src + rpos, size);
+  rpos += size;
+  return 1;
+}
+
+int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  SizeT outSizeFull;
+  unsigned char *outStream;
+
+  int waitEOS = 1;
+  /* waitEOS = 1, if there is no uncompressed size in headers,
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  SizeT compressedSize;
+  unsigned char *inStream;
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  rpos=0; dpos=0;
+
+  if (sizeof(UInt32) < 4)
+  {
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+    printf("LZMA decoder needs correct UInt32\n");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  {
+    long length=s_len;
+    if ((long)(SizeT)length != length)
+    {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+      printf("Too big compressed stream\n");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(source, properties, sizeof(properties)))
+  {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+    printf("%s\n", kCantReadMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Read uncompressed size */
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(source, &b, 1))
+      {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+        printf("%s\n", kCantReadMessage);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+
+    if (waitEOS)
+    {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+      printf("Stream with EOS marker is not supported");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+    {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+      printf("Too big uncompressed stream");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+  {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+    printf("Incorrect stream properties");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+  {
+    if (outSizeFull > d_len)
+      outStream = 0;
+    else
+      outStream = dest;
+  }
+
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+  {
+    if ((compressedSize+rpos) > s_len )
+      inStream = 0;
+    else
+      inStream = source + rpos;
+  }
+
+  if (state.Probs == 0
+    || (outStream == 0 && outSizeFull != 0)
+    || (inStream == 0 && compressedSize != 0)
+    )
+  {
+    free(state.Probs);
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+    printf("%s\n", kCantAllocateMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Decompress */
+  {
+    SizeT inProcessed;
+    SizeT outProcessed;
+    res = LzmaDecode(&state,
+      inStream, compressedSize, &inProcessed,
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+
+#if defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF) || !defined(CFG_BOOTSTRAP_CODE)
+      printf("\nDecoding error = %d\n", res);
+#endif
+      res = 1;
+    }
+    else
+    {
+      *d_len = outProcessed;
+    }
+  }
+
+  free(state.Probs);
+  return res;
+}
+
+#endif /* CONFIG_LZMA */
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -28,7 +28,7 @@
 COBJS	= bzlib.o bzlib_crctable.o bzlib_decompress.o \
 	  bzlib_randtable.o bzlib_huffman.o \
 	  crc32.o ctype.o display_options.o ldiv.o \
-	  string.o vsprintf.o zlib.o
+	  string.o vsprintf.o zlib.o LzmaDecode.o LzmaWrapper.o
 
 SRCS 	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
--- a/lib_mips/Makefile
+++ b/lib_mips/Makefile
@@ -27,7 +27,7 @@
 
 SOBJS	=
 
-COBJS	= board.o time.o mips_linux.o
+COBJS	= board.o time.o mips_linux.o efuse.o
 
 SRCS 	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
--- a/lib_mips/board.c
+++ b/lib_mips/board.c
@@ -29,31 +29,64 @@
 #include <net.h>
 #include <environment.h>
 
+#ifndef CFG_BOOTSTRAP_CODE
+#include "efuse.h"
+#endif //CFG_BOOTSTRAP_CODE
+
+#ifdef CFG_BOOTSTRAP_CODE
+#include <asm/ifx_mips.h>
+#include <configs/ifx_mips.h>
+#undef CONFIG_MICROBZIP2
+
+#ifdef CONFIG_BZIP2
+#include <bzlib.h>
+#endif
+
+#ifdef CONFIG_MICROBZIP2
+#include <micro_bzlib.h>
+#endif
+
+#ifdef CONFIG_LZMA
+#include <LzmaWrapper.h>
+#endif
+#endif //CFG_BOOTSTRAP_CODE
+
 DECLARE_GLOBAL_DATA_PTR;
 
-#if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < CFG_MONITOR_BASE) || \
-      (CFG_ENV_ADDR >= (CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
+#if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < BOOTSTRAP_CFG_MONITOR_BASE) || \
+	(CFG_ENV_ADDR >= (BOOTSTRAP_CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
+    defined(CFG_ENV_IS_IN_NVRAM) && defined(CFG_BOOTSTRAP_CODE)
+#define	TOTAL_MALLOC_LEN	(CFG_MALLOC_LEN + CFG_ENV_SIZE)
+#elif ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < CFG_MONITOR_BASE) || \
+	(CFG_ENV_ADDR >= (CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
     defined(CFG_ENV_IS_IN_NVRAM)
 #define	TOTAL_MALLOC_LEN	(CFG_MALLOC_LEN + CFG_ENV_SIZE)
 #else
 #define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
 #endif
 
-#undef DEBUG
+#ifdef CONFIG_IFX_MIPS
+extern int gpio_init(void);
+#endif
 
 extern int timer_init(void);
-
 extern int incaip_set_cpuclk(void);
 
+#ifdef CFG_BOOTSTRAP_CODE
+extern ulong uboot_end_data_bootstrap;
+extern ulong uboot_end_bootstrap;
+#else //CFG_BOOTSTRAP_CODE
 extern ulong uboot_end_data;
 extern ulong uboot_end;
+#endif //CFG_BOOTSTRAP_CODE
 
 ulong monitor_flash_len;
 
-const char version_string[] =
-	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
+const char version_string[] = U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
 
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 static char *failed = "*** failed ***\n";
+#endif
 
 /*
  * Begin and End of memory area for malloc(), and current "brk"
@@ -62,14 +95,15 @@
 static ulong mem_malloc_end;
 static ulong mem_malloc_brk;
 
-
 /*
  * The Malloc area is immediately below the monitor copy in DRAM
  */
-static void mem_malloc_init (void)
-{
+#ifdef CFG_BOOTSTRAP_CODE
+static void mem_malloc_init (ulong dest_addr) {
+#else //CFG_BOOTSTRAP_CODE
+static void mem_malloc_init (void) {
 	ulong dest_addr = CFG_MONITOR_BASE + gd->reloc_off;
-
+#endif //CFG_BOOTSTRAP_CODE
 	mem_malloc_end = dest_addr;
 	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
 	mem_malloc_brk = mem_malloc_start;
@@ -79,6 +113,25 @@
 		mem_malloc_end - mem_malloc_start);
 }
 
+#ifdef CFG_BOOTSTRAP_CODE
+void *malloc(unsigned int size) {
+	if(size < (mem_malloc_end - mem_malloc_start)) {
+		mem_malloc_start += size;
+		debug ("malloc : size required = 0x%08lx and pointer = 0x%08lx\n",size,mem_malloc_start - size);
+		return (void *)(mem_malloc_start - size);
+	}
+	return NULL;
+}
+
+void *realloc(void *src,unsigned int size) {
+	return NULL;
+}
+
+void free(void *src) {
+	return;
+}
+#endif //CFG_BOOTSTRAP_CODE
+
 void *sbrk (ptrdiff_t increment)
 {
 	ulong old = mem_malloc_brk;
@@ -99,42 +152,58 @@
 #else
 	int board_type = 0;	/* use dummy arg */
 #endif
-	puts ("DRAM:  ");
 
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+#ifdef CONFIG_USE_DDR_RAM
+	puts ("DDR-DRAM:  ");
+#else
+	puts ("DRAM:  ");
+#endif
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	if ((gd->ram_size = initdram (board_type)) > 0) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 		print_size (gd->ram_size, "\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 		return (0);
 	}
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	puts (failed);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	return (1);
 }
 
+#if !defined(CFG_BOOTSTRAP_CODE) || defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF)
 static int display_banner(void)
 {
-
 	printf ("\n\n%s\n\n", version_string);
 	return (0);
 }
+#endif
 
+#ifndef CFG_BOOTSTRAP_CODE
 static void display_flash_config(ulong size)
 {
 	puts ("Flash: ");
 	print_size (size, "\n");
 }
+#endif //CFG_BOOTSTRAP_CODE
 
-
+#if !defined(CFG_BOOTSTRAP_CODE) || defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF)
 static int init_baudrate (void)
 {
+#ifndef CFG_BOOTSTRAP_CODE
 	char tmp[64];	/* long enough for environment variables */
 	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
 
 	gd->baudrate = (i > 0)
 			? (int) simple_strtoul (tmp, NULL, 10)
 			: CONFIG_BAUDRATE;
-
+#else //CFG_BOOTSTRAP_CODE
+	gd->baudrate = CONFIG_BAUDRATE;
+#endif //CFG_BOOTSTRAP_CODE
 	return (0);
 }
-
+#endif
 
 /*
  * Breath some life into the board...
@@ -159,6 +228,27 @@
 typedef int (init_fnc_t) (void);
 
 init_fnc_t *init_sequence[] = {
+#ifdef CFG_BOOTSTRAP_CODE
+	//fuse_prg,
+	//timer_init,
+	//env_init,		/* initialize environment */
+#ifdef CONFIG_INCA_IP
+	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
+#endif
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,
+	display_banner,		/* say that we are here */
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	//checkboard,
+	init_func_ram,
+	NULL,
+#else //CFG_BOOTSTRAP_CODE
+	fuse_prg,
+#ifdef CONFIG_IFX_MIPS
+	gpio_init,
+#endif
 	timer_init,
 	env_init,		/* initialize environment */
 #ifdef CONFIG_INCA_IP
@@ -171,15 +261,26 @@
 	checkboard,
 	init_func_ram,
 	NULL,
+#endif //CFG_BOOTSTRAP_CODE
 };
 
+#ifdef CFG_BOOTSTRAP_CODE
+extern void bootstrap_relocate_code(ulong addr_sp, gd_t *id, ulong addr);
 
+void bootstrap_board_init_f(ulong bootflag)
+#else
 void board_init_f(ulong bootflag)
+#endif
 {
 	gd_t gd_data, *id;
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
-	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_MONITOR_BASE;
+#ifdef CFG_BOOTSTRAP_CODE
+	ulong addr, addr_sp, len = (ulong)&uboot_end_bootstrap - BOOTSTRAP_CFG_MONITOR_BASE;
+	ulong lzmaImageaddr = 0;
+#else //CFG_BOOTSTRAP_CODE
+	ulong addr, addr_sp, len = CFG_MONITOR_LEN;
+#endif //CFG_BOOTSTRAP_CODE
 	ulong *s;
 #ifdef CONFIG_PURPLE
 	void copy_code (ulong);
@@ -219,13 +320,12 @@
 	addr -= len;
 	addr &= ~(16 * 1024 - 1);
 
-	debug ("Reserving %ldk for U-Boot at: %08lx\n", len >> 10, addr);
+	debug ("Reserving %d Bytes for U-Boot at: %08lx\n", len, addr);
 
 	 /* Reserve memory for malloc() arena.
 	 */
 	addr_sp = addr - TOTAL_MALLOC_LEN;
-	debug ("Reserving %dk for malloc() at: %08lx\n",
-			TOTAL_MALLOC_LEN >> 10, addr_sp);
+	debug ("Reserving %d Bytes for malloc() at: %08lx\n", TOTAL_MALLOC_LEN, addr_sp);
 
 	/*
 	 * (permanently) allocate a Board Info struct
@@ -234,20 +334,17 @@
 	addr_sp -= sizeof(bd_t);
 	bd = (bd_t *)addr_sp;
 	gd->bd = bd;
-	debug ("Reserving %d Bytes for Board Info at: %08lx\n",
-			sizeof(bd_t), addr_sp);
+	debug ("Reserving %d Bytes for Board Info at: %08lx\n",	sizeof(bd_t), addr_sp);
 
 	addr_sp -= sizeof(gd_t);
 	id = (gd_t *)addr_sp;
-	debug ("Reserving %d Bytes for Global Data at: %08lx\n",
-			sizeof (gd_t), addr_sp);
+	debug ("Reserving %d Bytes for Global Data at: %08lx\n", sizeof (gd_t), addr_sp);
 
  	/* Reserve memory for boot params.
 	 */
 	addr_sp -= CFG_BOOTPARAMS_LEN;
 	bd->bi_boot_params = addr_sp;
-	debug ("Reserving %dk for boot params() at: %08lx\n",
-			CFG_BOOTPARAMS_LEN >> 10, addr_sp);
+	debug ("Reserving %dk for boot params() at: %08lx\n", CFG_BOOTPARAMS_LEN >> 10, addr_sp);
 
 	/*
 	 * Finally, we set up a new (bigger) stack.
@@ -279,7 +376,16 @@
 	copy_code(addr);
 #endif
 
+#ifdef CFG_BOOTSTRAP_CODE
+	lzmaImageaddr = (ulong)&uboot_end_data_bootstrap;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts("\n HEAD: relocate_code start");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	bootstrap_relocate_code (addr_sp, id, addr);
+#else //CFG_BOOTSTRAP_CODE
+	puts("\n relocate_code start");
 	relocate_code (addr_sp, id, addr);
+#endif //CFG_BOOTSTRAP_CODE
 
 	/* NOTREACHED - relocate_code() does not return */
 }
@@ -292,7 +398,121 @@
  *
  ************************************************************************
  */
+#ifdef CFG_BOOTSTRAP_CODE
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+extern void print_image_hdr (image_header_t *hdr);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+//extern void jump_unconditional (ulong addr);
+
+void bootstrap_board_init_r (gd_t *id, ulong dest_addr) {
+	int i;
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong  *len_ptr;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	unsigned int destLen;
+	int (*fn)();
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts("\n HEAD: relocate_code finish.\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+	/* initialize malloc() area */
+	mem_malloc_init(dest_addr);
 
+	addr = (char *)(BOOTSTRAP_CFG_MONITOR_BASE + ((ulong)&uboot_end_data_bootstrap - dest_addr));
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Magic Number at address 0x%08lx\n",addr);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+	if (crc32 (0, (char *)data, len) != checksum) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Header Checksum\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	//print_image_hdr (hdr);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+	len_ptr = (ulong *)data;
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Disabling all the interrupts\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	disable_interrupts();
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("   Uncompressing UBoot Image ... \n" );
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	/*
+	 * If we've got less than 4 MB of malloc() space,
+	 * use slower decompression algorithm which requires
+	 * at most 2300 KB of memory.
+	 */
+	destLen = 0x0;
+
+#ifdef CONFIG_BZIP2
+	i = BZ2_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+					0x400000, (char *)data, len,
+					CFG_MALLOC_LEN < (4096 * 1024), 0);
+	if (i != BZ_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+			printf ("BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+			return;
+	}
+#elif CONFIG_MICROBZIP2
+	i = micro_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+					&destLen, (char *)data, len,
+					CFG_MALLOC_LEN < (4096 * 1024), 0);
+	if (i != RETVAL_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("MICRO_BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+#elif CONFIG_LZMA
+	i = lzma_inflate ((char *)data, len, (char*)ntohl(hdr->ih_load), &destLen);
+	if (i != LZMA_RESULT_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+#else
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("NONE Compressing u-boot body!!\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	memmove ((void *)ntohl(hdr->ih_load), (uchar *)data, len);
+	destLen = len;
+#endif
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("   Uncompression completed successfully with destLen %d.\n ",destLen );
+	debug ("Head: Jumping to u-boot in the ram at 0x%08lx\n", CFG_MONITOR_BASE);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+	//jump_unconditional(CFG_MONITOR_BASE);
+	fn = ntohl(hdr->ih_load);
+	(*fn)();
+	hang ();
+}
+#else //CFG_BOOTSTRAP_CODE
 void board_init_r (gd_t *id, ulong dest_addr)
 {
 	cmd_tbl_t *cmdtp;
@@ -305,6 +525,8 @@
 	bd_t *bd;
 	int i;
 
+	puts("\n relocate_code finish.\n");
+
 	gd = id;
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 
@@ -321,12 +543,10 @@
 		ulong addr;
 
 		addr = (ulong) (cmdtp->cmd) + gd->reloc_off;
-#if 0
-		printf ("Command \"%s\": 0x%08lx => 0x%08lx\n",
-				cmdtp->name, (ulong) (cmdtp->cmd), addr);
-#endif
-		cmdtp->cmd =
-			(int (*)(struct cmd_tbl_s *, int, int, char *[]))addr;
+
+		debug ("Command \"%s\": 0x%08lx => 0x%08lx\n", cmdtp->name, (ulong) (cmdtp->cmd), addr);
+
+		cmdtp->cmd = (int (*)(struct cmd_tbl_s *, int, int, char *[]))addr;
 
 		addr = (ulong)(cmdtp->name) + gd->reloc_off;
 		cmdtp->name = (char *)addr;
@@ -424,9 +644,12 @@
 
 	/* NOTREACHED - no way out of command loop except booting */
 }
+#endif //CFG_BOOTSTRAP_CODE
 
 void hang (void)
 {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	puts ("### ERROR ### Please RESET the board ###\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	for (;;);
 }
--- /dev/null
+++ b/lib_mips/efuse.c
@@ -0,0 +1,89 @@
+#include <config.h>
+#include <asm/lib.h>
+#include <asm/addrspace.h>
+#include <asm/ifx_mips.h>
+
+#define ppe_mem_acc(addr,data) *((volatile u32*)(addr)) = data
+#define fuse_addr  ((volatile u32*)(AMAZON_SE_MPS + 0x0354))
+#define cdm_0_addr_bit_mask   0xFFF
+#define sb_0_addr_bit_mask    0xFFF
+#define sb_1_addr_bit_mask    0xFFF
+#define PPE32_BASE  0xBE180000
+#define PPE32_SB_RAM_B0               PPE32_BASE + (0x8200 * 4)
+#define PPE32_SB_RAM_B1               PPE32_BASE + (0x8C00 * 4)
+#define PPE32_CDM_CODE_MEM_B0         PPE32_BASE + (0x1000 * 4)
+#define PPE32_DATA_MEM_MAP_REG_BASE   PPE32_BASE + (0x4000 * 4)
+#define PPE32_CDM_CFG                 PPE32_DATA_MEM_MAP_REG_BASE + (0x0100 * 4)
+
+#define NO_OF_FUSES 	4
+
+void rar_init(void)
+{
+  /* Set rar_val of CDM RAM block 0 to '0' */
+  ppe_mem_acc(PPE32_CDM_CODE_MEM_B0, 0);
+  ppe_mem_acc(PPE32_CDM_CODE_MEM_B0+4, 0);
+  /* Set rar_val of SB RAM block 0 to '0' */
+  ppe_mem_acc(PPE32_SB_RAM_B0, 0);
+  ppe_mem_acc(PPE32_SB_RAM_B0+4, 0);
+  /* Set rar_val of SB RAM block 1 to '0' */
+  ppe_mem_acc(PPE32_SB_RAM_B1, 0);
+  ppe_mem_acc(PPE32_SB_RAM_B1+4, 0);
+};
+
+int fuse_prg(void)
+{
+  u32 fuse_value;
+  int i=0;
+  /* fuse programming except ARC memories*/
+  /* wait fuse reading is finished */
+  while ((*(AMAZON_SE_RCU_RST_REQ)&0x10000000)==0){
+    //add a watchdog
+    i++;
+    /* 0x4000 translate to  about 16 ms@111M, so should be enough */
+    if (i == 0x4000)return;
+  }
+  // STEP a: Prepare memory for external accesses
+  // Write fuse_en bit27
+  *(AMAZON_SE_RCU_RST_REQ) = (*(AMAZON_SE_RCU_RST_REQ) | 0x08000000);
+
+  // Code memory preparation
+  //ppe_mem_acc(PPE32_CDM_CFG,0x4);
+  ppe_mem_acc(PPE32_CDM_CFG,0x0); // cdm1 as DMEM (reset value); cdm0 as CMEM
+
+  /* Init rar_val of CDM RAM 0 SB RAM 0, 1 */
+  rar_init();
+
+  // STEP b: Write values into the memory addresses
+  //         2 RAR's per memory
+  for (i=0; i<NO_OF_FUSES; i++){
+    fuse_value = *(fuse_addr+i);
+    switch(fuse_value&0xF0000) {
+      case 0x20000:
+        ppe_mem_acc((PPE32_CDM_CODE_MEM_B0), ((fuse_value & cdm_0_addr_bit_mask) | (cdm_0_addr_bit_mask + 0x1)));
+        break;
+      case 0x30000:
+        ppe_mem_acc((PPE32_CDM_CODE_MEM_B0+0x4), ((fuse_value & cdm_0_addr_bit_mask) | (cdm_0_addr_bit_mask + 0x1)));
+        break;
+      case 0x40000:
+        ppe_mem_acc((PPE32_SB_RAM_B0), ((fuse_value & sb_0_addr_bit_mask) | (sb_0_addr_bit_mask + 0x1)));
+        break;
+      case 0x50000:
+        ppe_mem_acc((PPE32_SB_RAM_B0+0x4), ((fuse_value & sb_0_addr_bit_mask) | (sb_0_addr_bit_mask + 0x1)));
+        break;
+      case 0x60000:
+        ppe_mem_acc((PPE32_SB_RAM_B1), ((fuse_value & sb_1_addr_bit_mask) | (sb_1_addr_bit_mask + 0x1)));
+        break;
+      case 0x70000:
+        ppe_mem_acc((PPE32_SB_RAM_B1+0x4), ((fuse_value & sb_1_addr_bit_mask) | (sb_1_addr_bit_mask + 0x1)));
+        break;
+      default :
+        // ADSL related
+        break;
+    };
+  };
+
+  // STEP c: Memory read/write check
+  //  Disable Fuse_en (bit 27)
+  *(AMAZON_SE_RCU_RST_REQ) = (*(AMAZON_SE_RCU_RST_REQ) & 0xF7FFFFFF);
+  return 0;
+};
--- /dev/null
+++ b/lib_mips/efuse.h
@@ -0,0 +1,4 @@
+#ifndef EFUSE_H
+#define EFUSE_H
+int fuse_prg(void);
+#endif
--- a/lib_mips/time.c
+++ b/lib_mips/time.c
@@ -80,6 +80,19 @@
 		/*NOP*/;
 }
 
+#ifndef CFG_BOOTSTRAP_CODE
+void mdelay (unsigned long msec)
+{
+       int i,j;
+       for(i=0;i<msec;i++)
+       {
+          udelay(1000);
+
+       }
+
+}
+#endif
+
 /*
  * This function is derived from PowerPC code (read timebase as long long).
  * On MIPS it just returns the timer value.
--- /dev/null
+++ b/mk_ubootimg.sh
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+	echo $*
+	if test $# -lt 4; then
+		echo "usage: mk_ubootimg file1 file2 [pad_length] destfile"
+		exit 1;
+	fi
+	head_len=`wc -c $1 | awk '{ printf $1}'`
+	if test $head_len -gt $3; then
+		echo "Pad length [$3] must be greater than size of $1"
+		exit 1;
+	fi
+	pad_len=$3
+	echo "head_len = $head_len and pad_len = $pad_len"
+	rm -f $4
+	cat $1 > $4
+
+	while [ "$head_len" -lt "$pad_len" ]
+	do
+		echo -n "0" >> $4
+		head_len=`expr $head_len + 1`
+	done;
+	cat $2 >> $4
--- /dev/null
+++ b/model_config.sh
@@ -0,0 +1,18 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+# CONFIG_AMZ is not set
+# CONFIG_DNB is not set
+CONFIG_AMAZON_SE=y
+IFX_CONFIG_CPU="AMAZON_SE"
+IFX_CONFIG_FUTURE_SET="V35"
+IFX_CONFIG_ETHERNET_TYPE=EPHY
+IFX_CONFIG_LED_TYPE=GPIO
+IFX_CONFIG_MEMORY_SIZE=8
+IFX_CONFIG_FLASH_SIZE=2
+IFX_UBOOT_RAM_TEXT_BASE=80400000
+IFX_HEAD_FLASH_TEXT_BASE=B0000000
+IFX_IN_PAD_LEN=25000
+IFX_BOARD_SWRESET_GPIO=0
+
+####    End of Configuration   ####
--- a/net/eth.c
+++ b/net/eth.c
@@ -25,6 +25,9 @@
 #include <command.h>
 #include <net.h>
 #include <miiphy.h>
+#if defined(CONFIG_IFX_MIPS)
+#       include "ifx_eth.c"
+#endif
 
 #if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI)
 
@@ -54,6 +57,9 @@
 extern int skge_initialize(bd_t*);
 extern int tsec_initialize(bd_t*, int, char *);
 extern int npe_initialize(bd_t *);
+#if defined(CONFIG_IFX_MIPS)
+	IFX_ETH_INITIALIZE_EXTERN
+#endif
 
 static struct eth_device *eth_devices, *eth_current;
 
@@ -235,7 +241,9 @@
 #if defined(CONFIG_RTL8169)
 	rtl8169_initialize(bis);
 #endif
-
+#if defined(CONFIG_IFX_MIPS)
+	IFX_ETH_INITIALIZE(bis)
+#endif
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
 	} else {
--- /dev/null
+++ b/net/ifx_eth.c
@@ -0,0 +1,4 @@
+
+#define IFX_ETH_INITIALIZE_EXTERN	extern int amazon_se_switch_initialize(bd_t *);
+#define IFX_ETH_INITIALIZE(bd_t)	amazon_se_switch_initialize(bd_t);
+
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -117,7 +117,7 @@
 CPPFLAGS   = -idirafter $(SRCTREE)/include \
 		-idirafter $(OBJTREE)/include2 \
 		-idirafter $(OBJTREE)/include \
-		-DTEXT_BASE=$(TEXT_BASE) -DUSE_HOSTCC
+		-DTEXT_BASE=$(TEXT_BASE) -DUSE_HOSTCC $(IFX_CFLAGS)
 CFLAGS     = $(HOST_CFLAGS) $(CPPFLAGS) -O
 AFLAGS	   = -D__ASSEMBLY__ $(CPPFLAGS)
 CC	   = $(HOSTCC)
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -138,6 +138,7 @@
     {	IH_COMP_NONE,	"none",		"uncompressed",		},
     {	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
     {	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+    {	IH_COMP_LZMA,	"lzma",		"lzma compressed",	},
     {	-1,		"",		"",			},
 };
 
--- /dev/null
+++ b/include/LzmaDecode.h
@@ -0,0 +1,113 @@
+/*
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to
+  statically or dynamically link your code (or bind by name) to the
+  interfaces of this file without subjecting your linked code to the
+  terms of the CPL or GNU LGPL. Any modifications or additions
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs,
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
--- /dev/null
+++ b/include/LzmaTypes.h
@@ -0,0 +1,45 @@
+/*
+LzmaTypes.h
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
