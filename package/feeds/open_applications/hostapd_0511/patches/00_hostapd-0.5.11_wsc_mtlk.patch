diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/ChangeLog hostapd-0.5.11/ChangeLog
--- hostapd-0.5.11.ORIG/ChangeLog	2008-11-28 18:20:26.000000000 +0200
+++ hostapd-0.5.11/ChangeLog	2010-06-28 10:18:58.000000000 +0300
@@ -1,5 +1,10 @@
 ChangeLog for hostapd
 
+	* fixed retransmission of EAP requests if no response is received
+	* added a new configuration parameter, rsn_pairwise, to allow different
+	  pairwise cipher suites to be enabled for WPA and RSN/WPA2
+	  (merged from 0.6 branch)
+
 2008-11-28 - v0.5.11
 	* driver_madwifi: Fixed NULL pointer dereference on error path
 	  [Bug 273]
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/common.h hostapd-0.5.11/common.h
--- hostapd-0.5.11.ORIG/common.h	2007-12-28 02:50:13.000000000 +0200
+++ hostapd-0.5.11/common.h	2010-06-28 10:18:58.000000000 +0300
@@ -22,6 +22,12 @@
 #include <byteswap.h>
 #endif /* __linux__ */
 
+// This define fixes gcc-2.95 compilation bug on Sigma8621/22/24 platforms
+// http://www.busybox.net/lists/busybox/2006-August/023674.html
+#if defined(__UCLIBC__) && !defined(__ARCH_HAS_MMU__)
+#define 	daemon	clone
+#endif
+
 #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)
 #include <sys/types.h>
 #include <sys/endian.h>
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/.config hostapd-0.5.11/.config
--- hostapd-0.5.11.ORIG/.config	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/.config	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,121 @@
+# Example hostapd build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cass, these lines should use += in order not
+# to override previous values of the variables.
+
+# Driver interface for Host AP driver
+#CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for wired authenticator
+#CONFIG_DRIVER_WIRED=y
+
+# Driver interface for madwifi driver
+#CONFIG_DRIVER_MADWIFI=y
+#CFLAGS += -I../head # change to reflect local setup; directory for madwifi src
+#CFLAGS += -I/home/assafh/madwifi/madwifi-0.9.2-dongle-WPS
+
+# Driver interface for Prism54 driver
+#CONFIG_DRIVER_PRISM54=y
+
+# Driver interface for drivers using Devicescape IEEE 802.11 stack
+#CONFIG_DRIVER_DEVICESCAPE=y
+# Currently, driver_devicescape.c build requires some additional parameters
+# to be able to include some of the kernel header files. Following lines can
+# be used to set these (WIRELESS_DEV must point to the root directory of the
+# wireless-dev.git tree).
+#WIRELESS_DEV=/usr/src/wireless-dev
+#CFLAGS += -I$(WIRELESS_DEV)/net/mac80211
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+CONFIG_DRIVER_MTLK=y
+
+# IEEE 802.11F/IAPP
+#CONFIG_IAPP=y
+
+# WPA2/IEEE 802.11i RSN pre-authentication
+CONFIG_RSN_PREAUTH=y
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Integrated EAP server
+CONFIG_EAP=y
+
+# EAP-MD5 for the integrated EAP server
+CONFIG_EAP_MD5=y
+
+# EAP-TLS for the integrated EAP server
+CONFIG_EAP_TLS=y
+
+# EAP-MSCHAPv2 for the integrated EAP server
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-PEAP for the integrated EAP server
+CONFIG_EAP_PEAP=y
+
+# EAP-GTC for the integrated EAP server
+CONFIG_EAP_GTC=y
+
+# EAP-TTLS for the integrated EAP server
+CONFIG_EAP_TTLS=y
+
+# EAP-SIM for the integrated EAP server
+CONFIG_EAP_SIM=y
+
+# EAP-AKA for the integrated EAP server
+#CONFIG_EAP_AKA=y
+
+# EAP-PAX for the integrated EAP server
+#CONFIG_EAP_PAX=y
+
+# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-SAKE for the integrated EAP server
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK for the integrated EAP server
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# RADIUS authentication server. This provides access to the integrated EAP
+# server from external hosts using RADIUS.
+CONFIG_RADIUS_SERVER=y
+
+# Build IPv6 support for RADIUS operations
+#CONFIG_IPV6=y
+
+# Wireless Simple Config for the integrated EAP authenticator
+CONFIG_EAP_WSC=y
+
+# Use Madwifi driver that supports new WSC IEs
+CONFIG_WSC_IE=y
+
+CONFIG_NO_AUTH=y
+
+ifdef CONFIG_NO_AUTH
+CFLAGS += -DCONFIG_NO_AUTH
+CONFIG_NO_AUTH=y
+endif
+
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/config.c hostapd-0.5.11/config.c
--- hostapd-0.5.11.ORIG/config.c	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/config.c	2010-06-28 10:18:58.000000000 +0300
@@ -165,6 +165,7 @@
 	bss->wpa_key_mgmt = WPA_KEY_MGMT_PSK;
 	bss->wpa_pairwise = WPA_CIPHER_TKIP;
 	bss->wpa_group = WPA_CIPHER_TKIP;
+	bss->rsn_pairwise = 0;
 
 	bss->max_num_sta = MAX_STA_COUNT;
 
@@ -1157,6 +1158,7 @@
 	char buf[256], *pos;
 	int line = 0;
 	int errors = 0;
+	int pairwise;
 	size_t i;
 
 	f = fopen(fname, "r");
@@ -1519,11 +1521,20 @@
 				       "cipher suite '%s'\n",
 				       bss->wpa_pairwise, pos);
 				errors++;
-			} else {
-				if (bss->wpa_pairwise & WPA_CIPHER_TKIP)
-					bss->wpa_group = WPA_CIPHER_TKIP;
-				else
-					bss->wpa_group = WPA_CIPHER_CCMP;
+			}
+		} else if (strcmp(buf, "rsn_pairwise") == 0) {
+			bss->rsn_pairwise =
+				hostapd_config_parse_cipher(line, pos);
+			if (bss->rsn_pairwise == -1 ||
+			    bss->rsn_pairwise == 0)
+				errors++;
+			else if (bss->rsn_pairwise &
+				 (WPA_CIPHER_NONE | WPA_CIPHER_WEP40 |
+				  WPA_CIPHER_WEP104)) {
+				printf("Line %d: unsupported pairwise "
+				       "cipher suite '%s'\n",
+				       bss->rsn_pairwise, pos);
+				errors++;
 			}
 #ifdef CONFIG_RSN_PREAUTH
 		} else if (strcmp(buf, "rsn_preauth") == 0) {
@@ -1741,6 +1752,21 @@
 	for (i = 0; i < conf->num_bss; i++) {
 		bss = &conf->bss[i];
 
+		/* Select group cipher based on the enabled pairwise cipher
+		 * suites */
+		pairwise = 0;
+		if (bss->wpa & 1)
+			pairwise |= bss->wpa_pairwise;
+		if (bss->wpa & 2) {
+			if (bss->rsn_pairwise == 0)
+				bss->rsn_pairwise = bss->wpa_pairwise;
+			pairwise |= bss->rsn_pairwise;
+		}
+		if (pairwise & WPA_CIPHER_TKIP)
+			bss->wpa_group = WPA_CIPHER_TKIP;
+		else
+			bss->wpa_group = WPA_CIPHER_CCMP;
+
 		bss->radius->auth_server = bss->radius->auth_servers;
 		bss->radius->acct_server = bss->radius->acct_servers;
 
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/config.h hostapd-0.5.11/config.h
--- hostapd-0.5.11.ORIG/config.h	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/config.h	2010-06-28 10:18:58.000000000 +0300
@@ -233,6 +233,7 @@
 	int wpa_group_rekey;
 	int wpa_strict_rekey;
 	int wpa_gmk_rekey;
+	int rsn_pairwise;
 	int rsn_preauth;
 	char *rsn_preauth_interfaces;
 	int peerkey;
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/ctrl_iface.c hostapd-0.5.11/ctrl_iface.c
--- hostapd-0.5.11.ORIG/ctrl_iface.c	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/ctrl_iface.c	2010-06-28 10:18:58.000000000 +0300
@@ -378,6 +378,9 @@
 	fname = hostapd_ctrl_iface_path(hapd);
 	if (fname == NULL)
 		goto fail;
+
+	unlink(fname);
+
 	strncpy(addr.sun_path, fname, sizeof(addr.sun_path));
 	if (bind(s, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 		perror("bind(PF_UNIX)");
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/defconfig hostapd-0.5.11/defconfig
--- hostapd-0.5.11.ORIG/defconfig	2007-05-29 02:15:58.000000000 +0300
+++ hostapd-0.5.11/defconfig	2010-06-28 10:18:58.000000000 +0300
@@ -10,7 +10,7 @@
 # to override previous values of the variables.
 
 # Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
+#CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for wired authenticator
 #CONFIG_DRIVER_WIRED=y
@@ -18,6 +18,7 @@
 # Driver interface for madwifi driver
 #CONFIG_DRIVER_MADWIFI=y
 #CFLAGS += -I../head # change to reflect local setup; directory for madwifi src
+#CFLAGS += -I/home/assafh/madwifi/madwifi-0.9.2-dongle-WPS
 
 # Driver interface for Prism54 driver
 #CONFIG_DRIVER_PRISM54=y
@@ -102,3 +103,10 @@
 
 # Build IPv6 support for RADIUS operations
 CONFIG_IPV6=y
+
+# Wireless Simple Config for the integrated EAP authenticator
+CONFIG_EAP_WSC=y
+
+# Use Madwifi driver that supports new WSC IEs
+#CONFIG_WSC_IE=y
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/driver.h hostapd-0.5.11/driver.h
--- hostapd-0.5.11.ORIG/driver.h	2006-11-04 17:57:21.000000000 +0200
+++ hostapd-0.5.11/driver.h	2010-06-28 10:18:58.000000000 +0300
@@ -141,6 +141,10 @@
 	 * this handler will be called after initial setup has been completed.
 	 */
 	int (*commit)(void *priv);
+#ifdef WSC_NEW_IE
+	int (*set_wsc_beacon_ie)(void *priv, u8 *iebuf, int iebuflen);
+	int (*set_wsc_probe_resp_ie)(void *priv, u8 *iebuf, int iebuflen);
+#endif
 };
 
 static inline int
@@ -644,6 +648,26 @@
 		return 0;
 	return hapd->driver->set_sta_vlan(hapd->driver, addr, ifname, vlan_id);
 }
+ 
+#ifdef WSC_NEW_IE
+static inline int
+hostapd_set_wsc_beacon_ie(struct hostapd_data *hapd, u8 *iebuf, 
+					int iebuflen)
+{
+	if (hapd->driver == NULL || hapd->driver->set_wsc_beacon_ie == NULL)
+		return 0;
+	return hapd->driver->set_wsc_beacon_ie(hapd->driver, iebuf, iebuflen);
+}
+
+static inline int
+hostapd_set_wsc_probe_resp_ie(struct hostapd_data *hapd, u8 *iebuf, 
+					int iebuflen)
+{
+	if (hapd->driver == NULL || hapd->driver->set_wsc_probe_resp_ie == NULL)
+		return 0;
+	return hapd->driver->set_wsc_probe_resp_ie(hapd->driver, iebuf, iebuflen);
+}
+#endif
 
 static inline int
 hostapd_driver_commit(struct hostapd_data *hapd)
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/driver_madwifi.c hostapd-0.5.11/driver_madwifi.c
--- hostapd-0.5.11.ORIG/driver_madwifi.c	2008-07-18 05:57:15.000000000 +0300
+++ hostapd-0.5.11/driver_madwifi.c	2010-06-28 10:18:58.000000000 +0300
@@ -53,6 +53,7 @@
 #include "accounting.h"
 #include "common.h"
 
+#define EAP_WSC_RSN_IE_NOT_FOUND	(-2)
 
 struct madwifi_driver_data {
 	struct driver_ops ops;			/* base class */
@@ -161,7 +162,10 @@
 		    opnames[idx])
 			perror(opnames[idx]);
 		else
+		{
+			printf("IOCTL 0x%x socket %d\n", op, drv->ioctl_sock);
 			perror("ioctl[unknown???]");
+		}
 		return -1;
 	}
 	return 0;
@@ -758,6 +762,49 @@
 	return 0;
 }
 
+#ifdef WSC_NEW_IE
+static int
+madwifi_set_wsc_ie(void *priv, u8 *iebuf, int iebuflen, u32 frametype)
+{
+	struct madwifi_driver_data *drv = priv;
+	hostapd *hapd = drv->hapd;
+	u8 buf[256];
+	struct ieee80211req_getset_appiebuf * beac_ie;
+	// int i;
+
+	HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL, "%s buflen = %d\n", 
+			__func__, iebuflen);
+
+	// for (i = 0; i < iebuflen; i++)
+	// 	printf("%02x ", (unsigned char) iebuf[i]);
+	// printf("\n");
+
+	beac_ie = (struct ieee80211req_getset_appiebuf *) buf;
+	beac_ie->app_frmtype = frametype;
+	beac_ie->app_buflen = iebuflen;
+	memcpy(&(beac_ie->app_buf[0]), iebuf, iebuflen);
+	
+	return set80211priv(priv, IEEE80211_IOCTL_SET_APPIEBUF, beac_ie,
+			sizeof(struct ieee80211req_getset_appiebuf) + iebuflen);
+	return 0;
+}
+
+static int
+madwifi_set_wsc_beacon_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wsc_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_BEACON);
+}
+
+static int
+madwifi_set_wsc_probe_resp_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wsc_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_PROBE_RESP);
+}
+
+#endif /* WSC_NEW_IE */
+
 static int
 madwifi_process_wpa_ie(struct madwifi_driver_data *drv, struct sta_info *sta)
 {
@@ -788,7 +835,12 @@
 	ielen = iebuf[1];
 	if (ielen == 0) {
 		printf("No WPA/RSN information element for station!?\n");
+#ifdef EAP_WSC
+		/* Do Simple Config */
+		return EAP_WSC_RSN_IE_NOT_FOUND;
+#else
 		return -1;		/* XXX not right */
+#endif
 	}
 	ielen += 2;
 	if (sta->wpa_sm == NULL)
@@ -812,6 +864,7 @@
 	struct hostapd_data *hapd = drv->hapd;
 	struct sta_info *sta;
 	int new_assoc;
+	int result_value;
 
 	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
 		HOSTAPD_LEVEL_INFO, "associated");
@@ -833,8 +886,30 @@
 	accounting_sta_get_id(hapd, sta);
 
 	if (hapd->conf->wpa) {
+#ifndef EAP_WSC
 		if (madwifi_process_wpa_ie(drv, sta))
 			return -1;
+#else
+		result_value = madwifi_process_wpa_ie(drv, sta);
+		printf ("madwifi_process_wpa_ie: result_value=%d\n", result_value);
+		if (EAP_WSC_RSN_IE_NOT_FOUND == result_value) {
+		// No RSN or WPA IE present, try Simple Config (WPS)
+			sta->rsnssn_present = 0;
+			free(sta->wpa_ie);
+			sta->wpa_ie = NULL;
+			sta->wpa_ie_len = 0;
+		}
+		else {
+			if (result_value) {
+			// Failed to read WPA/RSN IE
+				return -1;
+			}
+			else {
+			// WPA/RSN IE found
+				sta->rsnssn_present = 1;
+			}
+		}
+#endif
 	}
 
 	/*
@@ -1259,6 +1334,9 @@
 
 	madwifi_set_iface_flags(drv, 0);	/* mark down during setup */
 	madwifi_set_privacy(drv->iface, drv, 0); /* default to no privacy */
+#ifdef CONFIG_NO_AUTH
+	madwifi_set_iface_flags(drv, 1);
+#endif	
 
 	hapd->driver = &drv->ops;
 	return 0;
@@ -1367,6 +1445,10 @@
 	.set_countermeasures	= madwifi_set_countermeasures,
 	.sta_clear_stats        = madwifi_sta_clear_stats,
 	.commit			= madwifi_commit,
+#ifdef WSC_NEW_IE
+	.set_wsc_beacon_ie		= madwifi_set_wsc_beacon_ie,
+	.set_wsc_probe_resp_ie	= madwifi_set_wsc_probe_resp_ie,
+#endif
 };
 
 void madwifi_driver_register(void)
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/driver_mtlk.c hostapd-0.5.11/driver_mtlk.c
--- hostapd-0.5.11.ORIG/driver_mtlk.c	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/driver_mtlk.c	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,1021 @@
+/*
+ * Host AP - driver interaction with MTLK 802.11n driver
+ *
+ * Copyright (c) 2006-2007 Metalink Broadband (Israel)
+ *
+ * Author: Andriy Tkachuk
+ *
+ * $Id: driver_mtlk.c 2470 2008-04-03 07:16:19Z andreit $
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <net/if_arp.h>
+#include "wireless_copy.h"
+
+#include <netinet/in.h>
+#include <netpacket/packet.h>
+
+#include "hostapd.h"
+#include "driver.h"
+#include "ieee802_1x.h"
+#include "eloop.h"
+#include "priv_netlink.h"
+#include "sta_info.h"
+#include "l2_packet.h"
+#include "hostap_common.h"
+
+#include "eapol_sm.h"
+#include "wpa.h"
+#include "radius.h"
+#include "ieee802_11.h"
+#include "accounting.h"
+#include "common.h"
+
+#ifdef WSC_NEW_IE
+enum ietypes {
+	IE_WSC_BEACON     = 0,
+	IE_WSC_PROBE_REQ  = 1,
+	IE_WSC_PROBE_RESP = 2
+};
+#endif
+
+struct mtlk_driver_data {
+	struct driver_ops ops;			/* base class */
+	struct hostapd_data *hapd;		/* back pointer */
+
+	char	iface[IFNAMSIZ + 1];
+	int     ifindex;
+	struct l2_packet_data *sock_xmit;	/* raw packet xmit socket */
+	struct l2_packet_data *sock_recv;	/* raw packet recv socket */
+	int	ioctl_sock;			/* socket for ioctl() use */
+	int	wext_sock;			/* socket for wireless events */
+	int	we_version;
+	u8	acct_mac[ETH_ALEN];
+	struct hostap_sta_driver_data acct_data;
+};
+
+static const struct driver_ops mtlk_driver_ops;
+
+static const char *
+ether_sprintf(const u8 *addr)
+{
+	static char buf[sizeof(MACSTR)];
+
+	if (addr != NULL)
+		snprintf(buf, sizeof(buf), MACSTR, MAC2STR(addr));
+	else
+		snprintf(buf, sizeof(buf), MACSTR, 0,0,0,0,0,0);
+	return buf;
+}
+
+static int
+mtlk_set_iface_flags(void *priv, int dev_up)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct ifreq ifr;
+
+	wpa_printf(MSG_DEBUG, "%s: dev_up=%d", __func__, dev_up);
+
+	if (drv->ioctl_sock < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	snprintf(ifr.ifr_name, IFNAMSIZ, "%s", drv->iface);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, &ifr) != 0) {
+		perror("ioctl[SIOCGIFFLAGS]");
+		return -1;
+	}
+
+	if (dev_up)
+		ifr.ifr_flags |= IFF_UP;
+	else
+		ifr.ifr_flags &= ~IFF_UP;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIFFLAGS, &ifr) != 0) {
+		perror("ioctl[SIOCSIFFLAGS]");
+		return -1;
+	}
+
+	if (dev_up) {
+		memset(&ifr, 0, sizeof(ifr));
+		snprintf(ifr.ifr_name, IFNAMSIZ, "%s", drv->iface);
+		ifr.ifr_mtu = HOSTAPD_MTU;
+		if (ioctl(drv->ioctl_sock, SIOCSIFMTU, &ifr) != 0) {
+			perror("ioctl[SIOCSIFMTU]");
+			printf("Setting MTU failed - trying to survive with "
+			       "current value\n");
+		}
+	}
+
+	return 0;
+}
+
+static int
+mtlk_set_encryption(const char *ifname, void *priv,
+             const char *alg, const u8 *addr,
+             int key_idx, const u8 *key, size_t key_len,
+             int txkey)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct hostapd_data *hapd = drv->hapd;
+	struct iwreq iwr;
+	struct iw_encode_ext *ext;
+	int ret=0;
+
+	HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+		"%s: alg=%s addr=%s key_idx=%d txkey=%d\n",
+		__func__, alg, ether_sprintf(addr), key_idx, txkey);
+
+	ext = malloc(sizeof(*ext) + key_len);
+	if (ext == NULL)
+		return -1;
+	memset(ext, 0, sizeof(*ext) + key_len);
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.encoding.flags = key_idx + 1;
+	iwr.u.encoding.pointer = (caddr_t) ext;
+	iwr.u.encoding.length = sizeof(*ext) + key_len;
+
+	if (addr == NULL ||
+	    memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
+		ext->ext_flags |= IW_ENCODE_EXT_GROUP_KEY;
+	if (txkey)
+		ext->ext_flags |= IW_ENCODE_EXT_SET_TX_KEY;
+	
+	ext->addr.sa_family = ARPHRD_ETHER;
+	if (addr)
+		memcpy(ext->addr.sa_data, addr, ETH_ALEN);
+	else
+		memset(ext->addr.sa_data, 0xff, ETH_ALEN);
+	if (key && key_len) {
+		memcpy(ext + 1, key, key_len);
+		ext->key_len = key_len;
+	}
+
+	if (strcmp(alg, "none") == 0)
+		ext->alg = IW_ENCODE_ALG_NONE;
+	else if (strcmp(alg, "WEP") == 0)
+		ext->alg = IW_ENCODE_ALG_WEP;
+	else if (strcmp(alg, "TKIP") == 0)
+		ext->alg = IW_ENCODE_ALG_TKIP;
+	else if (strcmp(alg, "CCMP") == 0)
+		ext->alg = IW_ENCODE_ALG_CCMP;
+	else {
+		printf("%s: unknown/unsupported algorithm %s\n",
+			__func__, alg);
+		return -1;
+	}
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWENCODEEXT, &iwr) < 0) {
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+		perror("ioctl[SIOCSIWENCODEEXT]");
+	}
+
+	free(ext);
+	return ret;
+}
+
+
+static int
+mtlk_get_seqnum(const char *ifname, void *priv, const u8 *addr, int idx,
+               u8 *seq)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct hostapd_data *hapd = drv->hapd;
+	struct iwreq iwr;
+	struct iw_encode_ext *ext;
+	int ret=0;
+
+	HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+		"%s: addr=%s idx=%d\n", __func__, ether_sprintf(addr), idx);
+
+	ext = malloc(sizeof(*ext));
+	if (ext == NULL)
+		return -1;
+	memset(ext, 0, sizeof(*ext));
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.encoding.pointer = (caddr_t) ext;
+	iwr.u.encoding.length = sizeof(*ext);
+
+	if (addr == NULL ||
+	    memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
+		iwr.u.encoding.flags |= IW_ENCODE_EXT_GROUP_KEY;
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWENCODEEXT, &iwr) < 0) {
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+		perror("ioctl[SIOCGIWENCODEEXT]");
+		goto err;
+	}
+
+	memcpy(seq, ext->rx_seq, 6);
+err:
+	free(ext);
+	return ret;
+}
+
+
+static int 
+mtlk_flush(void *priv)
+{
+	return 0;		/* XXX */
+}
+
+
+
+static int
+mtlk_sta_clear_stats(void *priv, const u8 *addr)
+{
+	return 0; /* FIX */
+}
+
+
+static int
+mtlk_set_generic_elem(const char *ifname, void *priv,
+                      const u8 *ie, size_t ie_len)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) ie;
+	iwr.u.data.length = ie_len;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int
+mtlk_mlme(struct mtlk_driver_data *drv,
+	const u8 *addr, int cmd, int reason_code)
+{
+	struct iwreq iwr;
+	struct iw_mlme mlme;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	memset(&mlme, 0, sizeof(mlme));
+	mlme.cmd = cmd;
+	mlme.reason_code = reason_code;
+	mlme.addr.sa_family = ARPHRD_ETHER;
+	memcpy(mlme.addr.sa_data, addr, ETH_ALEN);
+	iwr.u.data.pointer = (caddr_t) &mlme;
+	iwr.u.data.length = sizeof(mlme);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMLME, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMLME]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int
+mtlk_sta_deauth(void *priv, const u8 *addr, int reason_code)
+{
+	struct mtlk_driver_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return mtlk_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
+}
+
+static int
+mtlk_sta_disassoc(void *priv, const u8 *addr, int reason_code)
+{
+	struct mtlk_driver_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return mtlk_mlme(drv, addr, IW_MLME_DISASSOC, reason_code);
+}
+
+static int
+mtlk_del_sta(struct mtlk_driver_data *drv, u8 *addr)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	struct sta_info *sta;
+
+	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
+		HOSTAPD_LEVEL_INFO, "disassociated");
+
+	sta = ap_get_sta(hapd, addr);
+	if (sta != NULL) {
+		sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+		wpa_auth_sm_event(sta->wpa_sm, WPA_DISASSOC);
+		sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+		ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+		ap_free_sta(hapd, sta);
+	}
+	return 0;
+}
+
+static int
+mtlk_process_wpa_ie(struct mtlk_driver_data *drv, struct sta_info *sta,
+			u8 *rsnie)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	int ielen = rsnie[1] +2;
+
+	if (sta->wpa_sm == NULL)
+		sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth, sta->addr);
+
+	if (sta->wpa_sm == NULL) {
+		printf("test_driver: Failed to initialize WPA state machine\n");
+		return -1;
+	}
+
+	return wpa_validate_wpa_ie(hapd->wpa_auth, sta->wpa_sm, rsnie, ielen);
+}
+
+static int
+mtlk_new_sta(struct mtlk_driver_data *drv, u8 *addr, u8 *rsnie)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	struct sta_info *sta;
+	int new_assoc;
+
+	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
+		HOSTAPD_LEVEL_INFO, "associated");
+
+	sta = ap_get_sta(hapd, addr);
+	if (sta) {
+		accounting_sta_stop(hapd, sta);
+	} else {
+		sta = ap_sta_add(hapd, addr);
+		if (sta == NULL)
+			return -1;
+	}
+
+	if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
+		/* Cached accounting data is not valid anymore. */
+		memset(drv->acct_mac, 0, ETH_ALEN);
+		memset(&drv->acct_data, 0, sizeof(drv->acct_data));
+	}
+	accounting_sta_get_id(hapd, sta);
+
+	if (hapd->conf->wpa && rsnie) {
+		int res = mtlk_process_wpa_ie(drv, sta, rsnie);
+
+		if (res != WPA_IE_OK) {
+			int resp = WLAN_REASON_UNSPECIFIED;
+
+			HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+				      "WPA IE processing failed: %d\n", res);
+
+			ap_free_sta(hapd, sta);
+
+			if (res == WPA_INVALID_GROUP)
+				resp = WLAN_REASON_GROUP_CIPHER_NOT_VALID;
+			else if (res == WPA_INVALID_PAIRWISE)
+				resp = WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID;
+			else if (res == WPA_INVALID_AKMP)
+				resp = WLAN_REASON_AKMP_NOT_VALID;
+			else if (res != WPA_IE_OK)
+				resp = WLAN_REASON_INVALID_IE;
+
+			mtlk_mlme(drv, addr, IW_MLME_DISASSOC, resp);
+
+			return -1;
+		}
+	}
+
+	/*
+	 * Now that the internal station state is setup
+	 * kick the authenticator into action.
+	 */
+	new_assoc = (sta->flags & WLAN_STA_ASSOC) == 0;
+	sta->flags |= WLAN_STA_AUTH | WLAN_STA_ASSOC;
+	wpa_auth_sm_event(sta->wpa_sm, WPA_ASSOC);
+	hostapd_new_assoc_sta(hapd, sta, !new_assoc);
+	ieee802_1x_notify_port_enabled(sta->eapol_sm, 1);
+	return 0;
+}
+
+static int mtlk_wireless_michaelmicfailure(struct mtlk_driver_data *drv,
+				const char *ev, int len)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	const struct iw_michaelmicfailure *mic;
+	u8 *addr;
+
+	if (len < sizeof(*mic)) {
+		HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+			"Invalid MIC Failure data from driver\n");
+		return -1;
+	}
+
+	mic = (const struct iw_michaelmicfailure *) ev;
+
+	addr = (u8*) mic->src_addr.sa_data;
+	HOSTAPD_DEBUG(HOSTAPD_DEBUG_VERBOSE,
+		"Michael MIC failure wireless event: "
+		"flags=0x%x src_addr=" MACSTR "\n", mic->flags, MAC2STR(addr));
+
+	ieee80211_michael_mic_failure(drv->hapd, addr, 1);
+
+	return 0;
+}
+
+static void
+mtlk_wireless_event_wireless_custom(struct mtlk_driver_data *drv,
+				       char *custom)
+{
+	struct hostapd_data *hapd = drv->hapd;
+
+	const char newsta_tag[] = "NEWSTA ";
+	const char rsnie_tag[]  = "RSNIE_LEN ";
+
+	HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL, "Custom wireless event: '%s'\n",
+		      custom);
+
+	if (strncmp(custom, newsta_tag, strlen(newsta_tag)) == 0) {
+		char *pos = custom;
+		u8 addr[ETH_ALEN];
+		u8 *rsnie, ielen;
+		pos += strlen(newsta_tag);
+		if (hwaddr_aton(pos, addr) != 0) {
+			HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+				"NEWSTA with invalid MAC address\n");
+			return;
+		}
+		pos = strstr(pos, rsnie_tag);
+		pos += strlen(rsnie_tag);
+		ielen = atoi(pos);
+		if (!ielen) {
+			HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+				"NEWSTA with zero RSNIE length?\n");
+			return;
+		}
+		rsnie = malloc(ielen);
+		if (!rsnie) {
+			printf("ERROR: can't allocate buffer "
+				"of %d bytes for RSNIE", ielen);
+			return;
+		}
+		pos = strstr(pos, " : ");
+		pos += 3;
+		hexstr2bin(pos, rsnie, ielen);
+		mtlk_new_sta(drv, addr, rsnie);
+		free(rsnie);
+	} else
+	if (strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
+		char *pos;
+		u8 addr[ETH_ALEN];
+		pos = strstr(custom, "addr=");
+		if (pos == NULL) {
+			HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+				      "MLME-MICHAELMICFAILURE.indication "
+				      "without sender address ignored\n");
+			return;
+		}
+		pos += 5;
+		if (hwaddr_aton(pos, addr) == 0) {
+			ieee80211_michael_mic_failure(drv->hapd, addr, 1);
+		} else {
+			HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+				      "MLME-MICHAELMICFAILURE.indication "
+				      "with invalid MAC address");
+		}
+	} else if (strncmp(custom, "STA-TRAFFIC-STAT", 16) == 0) {
+		char *key, *value;
+		u32 val;
+		key = custom;
+		while ((key = strchr(key, '\n')) != NULL) {
+			key++;
+			value = strchr(key, '=');
+			if (value == NULL)
+				continue;
+			*value++ = '\0';
+			val = strtoul(value, NULL, 10);
+			if (strcmp(key, "mac") == 0)
+				hwaddr_aton(value, drv->acct_mac);
+			else if (strcmp(key, "rx_packets") == 0)
+				drv->acct_data.rx_packets = val;
+			else if (strcmp(key, "tx_packets") == 0)
+				drv->acct_data.tx_packets = val;
+			else if (strcmp(key, "rx_bytes") == 0)
+				drv->acct_data.rx_bytes = val;
+			else if (strcmp(key, "tx_bytes") == 0)
+				drv->acct_data.tx_bytes = val;
+			key = value;
+		}
+	}
+}
+
+static void
+mtlk_wireless_event_wireless(struct mtlk_driver_data *drv,
+					    char *data, int len)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	struct iw_event iwe_buf, *iwe = &iwe_buf;
+	char *pos, *end, *custom, *buf;
+
+	pos = data;
+	end = data + len;
+
+	while (pos + IW_EV_LCP_LEN <= end) {
+		/* Event data may be unaligned, so make a local, aligned copy
+		 * before processing. */
+		memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
+		HOSTAPD_DEBUG(HOSTAPD_DEBUG_VERBOSE, "Wireless event: "
+			      "cmd=0x%x len=%d\n", iwe->cmd, iwe->len);
+		if (iwe->len <= IW_EV_LCP_LEN)
+			return;
+
+		custom = pos + IW_EV_POINT_LEN;
+		iwe->u.data.pointer = custom;
+		if (drv->we_version > 18 &&
+		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
+		     iwe->cmd == IWEVCUSTOM)) {
+			/* WE-19 removed the pointer from struct iw_point */
+			char *dpos = (char *) &iwe_buf.u.data.length;
+			int dlen = dpos - (char *) &iwe_buf;
+			memcpy(dpos, pos + IW_EV_LCP_LEN,
+			       sizeof(struct iw_event) - dlen);
+		} else {
+			memcpy(&iwe_buf, pos, sizeof(struct iw_event));
+			custom += IW_EV_POINT_OFF;
+		}
+
+		switch (iwe->cmd) {
+		case IWEVEXPIRED:
+			mtlk_del_sta(drv, (u8 *) iwe->u.addr.sa_data);
+			break;
+		case IWEVREGISTERED:
+			mtlk_new_sta(drv, (u8 *) iwe->u.addr.sa_data, NULL);
+			break;
+		case IWEVMICHAELMICFAILURE:
+			mtlk_wireless_michaelmicfailure(drv, custom,
+							iwe->u.data.length);
+			break;
+		case IWEVCUSTOM:
+			if (custom + iwe->u.data.length > end)
+				return;
+			buf = malloc(iwe->u.data.length + 1);
+			if (buf == NULL)
+				return;		/* XXX */
+			memcpy(buf, custom, iwe->u.data.length);
+			buf[iwe->u.data.length] = '\0';
+			mtlk_wireless_event_wireless_custom(drv, buf);
+			free(buf);
+			break;
+		}
+
+		pos += iwe->len;
+	}
+}
+
+
+static void
+mtlk_wireless_event_rtm_newlink(struct mtlk_driver_data *drv,
+					       struct nlmsghdr *h, int len)
+{
+	struct ifinfomsg *ifi;
+	int attrlen, nlmsg_len, rta_len;
+	struct rtattr * attr;
+
+	if (len < sizeof(*ifi))
+		return;
+
+	ifi = NLMSG_DATA(h);
+
+	if (ifi->ifi_index != drv->ifindex)
+		return;
+
+	nlmsg_len = NLMSG_ALIGN(sizeof(struct ifinfomsg));
+
+	attrlen = h->nlmsg_len - nlmsg_len;
+	if (attrlen < 0)
+		return;
+
+	attr = (struct rtattr *) (((char *) ifi) + nlmsg_len);
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_WIRELESS) {
+			mtlk_wireless_event_wireless(
+				drv, ((char *) attr) + rta_len,
+				attr->rta_len - rta_len);
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+}
+
+
+static void
+mtlk_wireless_event_receive(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	char buf[256];
+	int left;
+	struct sockaddr_nl from;
+	socklen_t fromlen;
+	struct nlmsghdr *h;
+	struct mtlk_driver_data *drv = eloop_ctx;
+
+	fromlen = sizeof(from);
+	left = recvfrom(sock, buf, sizeof(buf), MSG_DONTWAIT,
+			(struct sockaddr *) &from, &fromlen);
+	if (left < 0) {
+		if (errno != EINTR && errno != EAGAIN)
+			perror("recvfrom(netlink)");
+		return;
+	}
+
+	h = (struct nlmsghdr *) buf;
+	while (left >= sizeof(*h)) {
+		int len, plen;
+
+		len = h->nlmsg_len;
+		plen = len - sizeof(*h);
+		if (len > left || plen < 0) {
+			printf("Malformed netlink message: "
+			       "len=%d left=%d plen=%d\n",
+			       len, left, plen);
+			break;
+		}
+
+		switch (h->nlmsg_type) {
+		case RTM_NEWLINK:
+			mtlk_wireless_event_rtm_newlink(drv, h, plen);
+			break;
+		}
+
+		len = NLMSG_ALIGN(len);
+		left -= len;
+		h = (struct nlmsghdr *) ((char *) h + len);
+	}
+
+	if (left > 0) {
+		printf("%d extra bytes in the end of netlink message\n", left);
+	}
+}
+
+
+static int
+mtlk_get_we_version(struct mtlk_driver_data *drv)
+{
+	struct iw_range *range;
+	struct iwreq iwr;
+	int minlen;
+	size_t buflen;
+
+	drv->we_version = 0;
+
+	/*
+	 * Use larger buffer than struct iw_range in order to allow the
+	 * structure to grow in the future.
+	 */
+	buflen = sizeof(struct iw_range) + 500;
+	range = malloc(buflen);
+	if (range == NULL)
+		return -1;
+	memset(range, 0, buflen);
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) range;
+	iwr.u.data.length = buflen;
+
+	minlen = ((char *) &range->enc_capa) - (char *) range +
+		sizeof(range->enc_capa);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWRANGE]");
+		free(range);
+		return -1;
+	} else if (iwr.u.data.length >= minlen &&
+		   range->we_version_compiled >= 18) {
+		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
+			   "WE(source)=%d enc_capa=0x%x",
+			   range->we_version_compiled,
+			   range->we_version_source,
+			   range->enc_capa);
+		drv->we_version = range->we_version_compiled;
+	}
+
+	free(range);
+	return 0;
+}
+
+
+static int
+mtlk_wireless_event_init(void *priv)
+{
+	struct mtlk_driver_data *drv = priv;
+	int s;
+	struct sockaddr_nl local;
+
+	mtlk_get_we_version(drv);
+
+	drv->wext_sock = -1;
+
+	s = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+	if (s < 0) {
+		perror("socket(PF_NETLINK,SOCK_RAW,NETLINK_ROUTE)");
+		return -1;
+	}
+
+	memset(&local, 0, sizeof(local));
+	local.nl_family = AF_NETLINK;
+	local.nl_groups = RTMGRP_LINK;
+	if (bind(s, (struct sockaddr *) &local, sizeof(local)) < 0) {
+		perror("bind(netlink)");
+		close(s);
+		return -1;
+	}
+
+	eloop_register_read_sock(s, mtlk_wireless_event_receive, drv, NULL);
+	drv->wext_sock = s;
+
+	return 0;
+}
+
+
+static void
+mtlk_wireless_event_deinit(void *priv)
+{
+	struct mtlk_driver_data *drv = priv;
+
+	if (drv != NULL) {
+		if (drv->wext_sock < 0)
+			return;
+		eloop_unregister_read_sock(drv->wext_sock);
+		close(drv->wext_sock);
+	}
+}
+
+
+static int
+mtlk_send_eapol(void *priv, const u8 *addr, const u8 *data, size_t data_len,
+               int encrypt, const u8 *own_addr)
+{
+	struct mtlk_driver_data *drv = priv;
+	u8 buf[3000];
+	u8 *bp = buf;
+	struct l2_ethhdr *eth;
+	size_t len;
+	int status;
+
+	/*
+	 * Prepend the Ethernet header.  If the caller left us
+	 * space at the front we could just insert it but since
+	 * we don't know we copy to a local buffer.  Given the frequency
+	 * and size of frames this probably doesn't matter.
+	 */
+	len = data_len + sizeof(struct l2_ethhdr);
+	if (len > sizeof(buf)) {
+		bp = malloc(len);
+		if (bp == NULL) {
+			printf("EAPOL frame discarded, cannot malloc temp "
+			       "buffer of size %lu!\n", (unsigned long) len);
+			return -1;
+		}
+	}
+	eth = (struct l2_ethhdr *) bp;
+	memcpy(eth->h_dest, addr, ETH_ALEN);
+	memcpy(eth->h_source, drv->hapd->own_addr, ETH_ALEN);
+	eth->h_proto = htons(ETH_P_EAPOL);
+	memcpy(eth+1, data, data_len);
+
+	wpa_hexdump(MSG_DEBUG, "TX EAPOL", bp, len);
+
+	status = l2_packet_send(drv->sock_xmit, addr, ETH_P_EAPOL, bp, len);
+
+	if (bp != buf)
+		free(bp);
+	return status;
+}
+
+static void
+handle_read(void *ctx, const u8 *src_addr, const u8 *buf, size_t len)
+{
+	struct mtlk_driver_data *drv = ctx;
+	struct hostapd_data *hapd = drv->hapd;
+	struct sta_info *sta;
+
+	sta = ap_get_sta(hapd, src_addr);
+	if (!sta || !(sta->flags & WLAN_STA_ASSOC)) {
+		printf("Data frame from not associated STA %s\n",
+		       ether_sprintf(src_addr));
+		/* XXX cannot happen */
+		return;
+	}
+	ieee802_1x_receive(hapd, src_addr, buf + sizeof(struct l2_ethhdr),
+			   len - sizeof(struct l2_ethhdr));
+}
+
+static int
+mtlk_init(struct hostapd_data *hapd)
+{
+	struct mtlk_driver_data *drv;
+	struct ifreq ifr;
+	struct iwreq iwr;
+
+	drv = malloc(sizeof(struct mtlk_driver_data));
+	if (drv == NULL) {
+		printf("Could not allocate memory for mtlk driver data\n");
+		goto bad;
+	}
+
+	memset(drv, 0, sizeof(*drv));
+	drv->ops = mtlk_driver_ops;
+	drv->hapd = hapd;
+	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (drv->ioctl_sock < 0) {
+		perror("socket[PF_INET,SOCK_DGRAM]");
+		goto bad;
+	}
+	memcpy(drv->iface, hapd->conf->iface, sizeof(drv->iface));
+
+	memset(&ifr, 0, sizeof(ifr));
+	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", drv->iface);
+	if (ioctl(drv->ioctl_sock, SIOCGIFINDEX, &ifr) != 0) {
+		perror("ioctl(SIOCGIFINDEX)");
+		goto bad;
+	}
+	drv->ifindex = ifr.ifr_ifindex;
+
+	drv->sock_xmit = l2_packet_init(drv->iface, NULL, ETH_P_EAPOL,
+					handle_read, drv, 1);
+	if (drv->sock_xmit == NULL)
+		goto bad;
+	if (l2_packet_get_own_addr(drv->sock_xmit, hapd->own_addr))
+		goto bad;
+	if (hapd->conf->bridge[0] != '\0') {
+		HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
+			"Configure bridge %s for EAPOL traffic.\n",
+			hapd->conf->bridge);
+		drv->sock_recv = l2_packet_init(hapd->conf->bridge, NULL,
+						ETH_P_EAPOL, handle_read, drv,
+						1);
+		if (drv->sock_recv == NULL)
+			goto bad;
+	} else
+		drv->sock_recv = drv->sock_xmit;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+
+	iwr.u.mode = IW_MODE_MASTER;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMODE]");
+		printf("Could not set interface to master mode!\n");
+		goto bad;
+	}
+
+	mtlk_set_iface_flags(drv, 0);	/* mark down during setup */
+
+	hapd->driver = &drv->ops;
+	return 0;
+bad:
+	if (drv->sock_xmit != NULL)
+		l2_packet_deinit(drv->sock_xmit);
+	if (drv->ioctl_sock >= 0)
+		close(drv->ioctl_sock);
+	if (drv != NULL)
+		free(drv);
+	return -1;
+}
+
+
+static void
+mtlk_deinit(void *priv)
+{
+	struct mtlk_driver_data *drv = priv;
+
+	drv->hapd->driver = NULL;
+
+	(void) mtlk_set_iface_flags(drv, 0);
+	if (drv->ioctl_sock >= 0)
+		close(drv->ioctl_sock);
+	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
+		l2_packet_deinit(drv->sock_recv);
+	if (drv->sock_xmit != NULL)
+		l2_packet_deinit(drv->sock_xmit);
+	free(drv);
+}
+
+static int
+mtlk_set_ssid(const char *ifname, void *priv, const u8 *buf, int len)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.essid.flags = 1; /* SSID active */
+	iwr.u.essid.pointer = (caddr_t) buf;
+	iwr.u.essid.length = len + 1;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCSIWESSID]");
+		printf("len=%d\n", len);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+mtlk_get_ssid(const char *ifname, void *priv, u8 *buf, int len)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.essid.pointer = (caddr_t) buf;
+	iwr.u.essid.length = len;
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCGIWESSID]");
+		ret = -1;
+	} else
+		ret = iwr.u.essid.length;
+
+	return ret;
+}
+
+static int
+mtlk_commit(void *priv)
+{
+	return mtlk_set_iface_flags(priv, 1);
+}
+
+#ifdef WSC_NEW_IE
+static int
+mtlk_set_wsc_ie(void *priv, u8 *ie, int ie_len, u16 ie_type)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) ie;
+	iwr.u.data.length = ie_len;
+	iwr.u.data.flags = ie_type;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int
+mtlk_set_wsc_beacon_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return mtlk_set_wsc_ie(priv, iebuf, iebuflen, IE_WSC_BEACON);
+}
+
+static int
+mtlk_set_wsc_probe_resp_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return mtlk_set_wsc_ie(priv, iebuf, iebuflen, IE_WSC_PROBE_RESP);
+}
+
+#endif /* WSC_NEW_IE */
+
+static const struct driver_ops mtlk_driver_ops = {
+	.name			= "mtlk",
+	.init			= mtlk_init,
+	.deinit			= mtlk_deinit,
+	.set_encryption		= mtlk_set_encryption,
+	.get_seqnum		= mtlk_get_seqnum,
+	.flush			= mtlk_flush,
+	.set_generic_elem	= mtlk_set_generic_elem,
+	.wireless_event_init	= mtlk_wireless_event_init,
+	.wireless_event_deinit	= mtlk_wireless_event_deinit,
+	.send_eapol		= mtlk_send_eapol,
+	.sta_disassoc		= mtlk_sta_disassoc,
+	.sta_deauth		= mtlk_sta_deauth,
+	.set_ssid		= mtlk_set_ssid,
+	.get_ssid		= mtlk_get_ssid,
+	.sta_clear_stats        = mtlk_sta_clear_stats,
+	.commit			= mtlk_commit,
+#ifdef WSC_NEW_IE
+	.set_wsc_beacon_ie      = mtlk_set_wsc_beacon_ie,
+	.set_wsc_probe_resp_ie  = mtlk_set_wsc_probe_resp_ie,
+#endif
+};
+
+void mtlk_driver_register(void)
+{
+	driver_register(mtlk_driver_ops.name, &mtlk_driver_ops);
+}
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eap.c hostapd-0.5.11/eap.c
--- hostapd-0.5.11.ORIG/eap.c	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/eap.c	2010-06-28 10:18:58.000000000 +0300
@@ -204,8 +204,11 @@
 {
 	SM_ENTRY(EAP, RETRANSMIT);
 
-	/* TODO: Is this needed since EAPOL state machines take care of
-	 * retransmit? */
+	sm->retransCount++;
+	if (sm->retransCount <= sm->MaxRetrans && sm->lastReqData) {
+		eapol_set_eapReqData(sm, sm->lastReqData, sm->lastReqDataLen);
+		eapol_set_bool(sm, EAPOL_eapReq, TRUE);
+	}
 }
 
 
@@ -273,10 +276,23 @@
 	sm->currentId = eap_sm_nextId(sm, sm->currentId);
 	wpa_printf(MSG_DEBUG, "EAP: building EAP-Request: Identifier %d",
 		   sm->currentId);
-	sm->lastId = sm->currentId;
 	free(sm->eapReqData);
 	sm->eapReqData = sm->m->buildReq(sm, sm->eap_method_priv,
 					 sm->currentId, &sm->eapReqDataLen);
+#ifdef EAP_WSC
+	if ((sm->eapReqData == NULL) && (!sm->m->isDone(sm, sm->eap_method_priv)))
+	{
+		//Do not attempt to send the request, keep trying to get it
+		sm->ignore = TRUE;
+		sm->currentId = sm->lastId;
+		sm->changed = 2;
+	}
+	else
+	{
+		sm->ignore = FALSE;
+	}
+#endif
+	sm->lastId = sm->currentId;
 	if (sm->m->getTimeout)
 		sm->methodTimeout = sm->m->getTimeout(sm, sm->eap_method_priv);
 	else
@@ -522,7 +538,12 @@
 			SM_ENTER(EAP, METHOD_RESPONSE);
 		break;
 	case EAP_METHOD_REQUEST:
-		SM_ENTER(EAP, SEND_REQUEST);
+#ifdef EAP_WSC
+		if (sm->ignore)
+			SM_ENTER(EAP, METHOD_REQUEST);
+		else
+#endif
+			SM_ENTER(EAP, SEND_REQUEST);
 		break;
 	case EAP_METHOD_RESPONSE:
 		/*
@@ -593,10 +614,51 @@
 				   int eapSRTT, int eapRTTVAR,
 				   int methodTimeout)
 {
-	/* For now, retransmission is done in EAPOL state machines, so make
-	 * sure EAP state machine does not end up trying to retransmit packets.
+	int rto, i;
+
+	if (methodTimeout) {
+		/*
+		 * EAP method (either internal or through AAA server, provided
+		 * timeout hint. Use that as-is as a timeout for retransmitting
+		 * the EAP request if no response is received.
+		 */
+		wpa_printf(MSG_DEBUG, "EAP: retransmit timeout %d seconds "
+			   "(from EAP method hint)", methodTimeout);
+		return methodTimeout;
+	}
+
+	/*
+	 * RFC 3748 recommends algorithms described in RFC 2988 for estimation
+	 * of the retransmission timeout. This should be implemented once
+	 * round-trip time measurements are available. For nowm a simple
+	 * backoff mechanism is used instead if there are no EAP method
+	 * specific hints.
+	 *
+	 * SRTT = smoothed round-trip time
+	 * RTTVAR = round-trip time variation
+	 * RTO = retransmission timeout
+	 */
+
+	/*
+	 * RFC 2988, 2.1: before RTT measurement, set RTO to 3 seconds for
+	 * initial retransmission and then double the RTO to provide back off
+	 * per 5.5. Limit the maximum RTO to 20 seconds per RFC 3748, 4.3
+	 * modified RTOmax.
 	 */
-	return 1;
+	rto = 3;
+	for (i = 0; i < retransCount; i++) {
+		rto *= 2;
+		if (rto >= 20) {
+			rto = 20;
+			break;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "EAP: retransmit timeout %d seconds "
+		   "(from dynamic back off; retransCount=%d)",
+		   rto, retransCount);
+
+	return rto;
 }
 
 
@@ -878,7 +940,12 @@
 		sm->changed = FALSE;
 		SM_STEP_RUN(EAP);
 		if (sm->changed)
+#ifdef EAP_WSC
+			if (sm->changed == 2)
+				return 2;
+#else
 			res = 1;
+#endif
 	} while (sm->changed);
 	return res;
 }
@@ -937,7 +1004,7 @@
 		return NULL;
 	sm->eapol_ctx = eapol_ctx;
 	sm->eapol_cb = eapol_cb;
-	sm->MaxRetrans = 10;
+	sm->MaxRetrans = 5; /* RFC 3748: max 3-5 retransmissions suggested */
 	sm->ssl_ctx = conf->ssl_ctx;
 	sm->eap_sim_db_priv = conf->eap_sim_db_priv;
 	sm->backend_auth = conf->backend_auth;
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eap_defs.h hostapd-0.5.11/eap_defs.h
--- hostapd-0.5.11.ORIG/eap_defs.h	2008-11-28 18:21:32.000000000 +0200
+++ hostapd-0.5.11/eap_defs.h	2010-06-28 10:18:58.000000000 +0300
@@ -58,7 +58,8 @@
 	EAP_TYPE_PAX = 46 /* RFC 4746 */,
 	EAP_TYPE_PSK = 47 /* RFC 4764 */,
 	EAP_TYPE_SAKE = 48 /* RFC 4763 */,
-	EAP_TYPE_EXPANDED = 254 /* RFC 3748 */,
+	EAP_TYPE_EXPANDED = 253 /* RFC 3748 */,
+	EAP_TYPE_WSC = 254 /* Wireless Simple Config */,
 	EAP_TYPE_GPSK = 255 /* EXPERIMENTAL - type not yet allocated
 			     * draft-ietf-emu-eap-gpsk-01.txt */
 } EapType;
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eap_methods.c hostapd-0.5.11/eap_methods.c
--- hostapd-0.5.11.ORIG/eap_methods.c	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/eap_methods.c	2010-06-28 10:18:58.000000000 +0300
@@ -247,6 +247,13 @@
 	}
 #endif /* EAP_VENDOR_TEST */
 
+#ifdef EAP_WSC
+	if (ret == 0) {
+		int eap_server_wsc_register(void);
+		ret = eap_server_wsc_register();
+	}
+#endif /* EAP_WSC */
+
 	return ret;
 }
 
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eapol_sm.c hostapd-0.5.11/eapol_sm.c
--- hostapd-0.5.11.ORIG/eapol_sm.c	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/eapol_sm.c	2010-06-28 10:18:58.000000000 +0300
@@ -85,6 +85,15 @@
 		}
 	}
 
+	if (state->eap && state->eap->retransWhile > 0) {
+		state->eap->retransWhile--;
+		if (state->eap->retransWhile == 0) {
+			wpa_printf(MSG_DEBUG, "IEEE 802.1X: " MACSTR
+				   " - (EAP) retransWhile --> 0",
+				   MAC2STR(state->addr));
+		}
+	}
+
 	eapol_sm_step_run(state);
 
 	eloop_register_timeout(1, 0, eapol_port_timers_tick, eloop_ctx, state);
@@ -772,7 +781,7 @@
 	struct hostapd_data *hapd = sm->hapd;
 	u8 addr[ETH_ALEN];
 	unsigned int prev_auth_pae, prev_be_auth, prev_reauth_timer,
-		prev_auth_key_tx, prev_key_rx, prev_ctrl_dir;
+		prev_auth_key_tx, prev_key_rx, prev_ctrl_dir, res_val;
 	int max_steps = 100;
 
 	memcpy(addr, sm->sta->addr, ETH_ALEN);
@@ -817,9 +826,13 @@
 	}
 
 	if (eapol_sm_sta_entry_alive(hapd, addr) && sm->eap) {
-		if (eap_sm_step(sm->eap)) {
+		if ((res_val = eap_sm_step(sm->eap))) {
+#ifdef EAP_WSC
+			if (res_val != 2) //only in WPS case go to re-run
+#else
 			if (--max_steps > 0)
 				goto restart;
+#endif
 			/* Re-run from eloop timeout */
 			eapol_sm_step(sm);
 			return;
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eapol_sm.h hostapd-0.5.11/eapol_sm.h
--- hostapd-0.5.11.ORIG/eapol_sm.h	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/eapol_sm.h	2010-06-28 10:18:58.000000000 +0300
@@ -16,6 +16,7 @@
 #define EAPOL_SM_H
 
 #include "defs.h"
+#include "eap_i.h"
 
 /* IEEE Std 802.1X-2004, Ch. 8.2 */
 
@@ -25,8 +26,6 @@
 typedef enum { Both = 0, In = 1 } ControlledDirection;
 typedef unsigned int Counter;
 
-struct eap_sm;
-
 struct radius_attr_data {
 	u8 *data;
 	size_t len;
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eap_wsc.c hostapd-0.5.11/eap_wsc.c
--- hostapd-0.5.11.ORIG/eap_wsc.c	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/eap_wsc.c	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,565 @@
+/*
+ * hostapd / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2004-2005, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WSC and COPYING for more details.
+ */
+// $Id: eap_wsc.c 2379 2008-03-09 16:46:01Z mayam $
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/dh.h>
+#include <openssl/bn.h>
+
+#include "hostapd.h"
+#include "common.h"
+#include "eloop.h"
+#include "eap_i.h"
+#include "eapol_sm.h"
+#include "eap_wsc.h"
+#include "UdpLib.h"
+#include "sta_info.h"
+#include "wpa.h"
+#include "ieee802_1x.h"
+ 
+#define WSC_EAP_UDP_PORT            37000
+#define WSC_EAP_UDP_ADDR            "127.0.0.1"
+#define WSC_EAP_REGISTRAR_UDP_PORT  39000
+
+typedef struct wsc_eap_header_tag {
+    u8 code;
+    u8 id;
+    u16 length;
+    u8 type;
+    u8 vendorId[3];
+    u32 vendorType;
+    u8 opcode;
+    u8 flags;
+} __attribute__((packed)) WSC_EAP_HEADER;
+
+static int eap_wsc_registrar_fd;
+static u8 *last_eap_wsc_registrar_req;
+static struct hostapd_data *local_copy_of_hapd;
+
+static void eap_wsc_registrar_if_read(void *eloop_ctx, void *timeout_ctx);
+static u8 *eap_wsc_check_for_result(struct eap_wsc_data *data, size_t *reqDataLen);
+ 
+// Function eap_wsc_registrar_if_init initializes socket based 
+// interface with WPS application; this IF will be used for 
+// exchanging EAP WPS messages with EAP Registrar station
+int eap_wsc_registrar_if_init(struct hostapd_data *hapd)
+{
+    char *sendBuf = "PORT";
+    int sendBufLen = 5;
+    struct sockaddr_in to;
+
+    wpa_printf(MSG_DEBUG,"EAP-WSC: Opening socket for EAP WSC Registrar interface");
+    eap_wsc_registrar_fd = udp_open();
+    last_eap_wsc_registrar_req = NULL;
+    local_copy_of_hapd = hapd;
+
+    // Send first time message to initiate the connection via UDP socket
+    to.sin_addr.s_addr = inet_addr(WSC_EAP_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_EAP_REGISTRAR_UDP_PORT);
+
+    udp_write(eap_wsc_registrar_fd, (char *)sendBuf, sendBufLen, &to);
+
+    // Start periodic timer to check for messages on the socket 
+    eloop_register_timeout (1, 0, eap_wsc_registrar_if_read, NULL, NULL);
+    return 0;
+}
+
+// Function eap_wsc_registrar_if_deinit closes socket based 
+// interface with WPS application and frees last sent message 
+void eap_wsc_registrar_if_deinit(struct hostapd_data *hapd)
+{
+    wpa_printf(MSG_DEBUG,"EAP-WSC: Closing socket for EAP WSC Registrar interface");
+    udp_close(eap_wsc_registrar_fd);
+
+    // Stop periodic timer
+    eloop_cancel_timeout (eap_wsc_registrar_if_read, NULL, NULL);
+
+    if (last_eap_wsc_registrar_req != NULL)
+        free(last_eap_wsc_registrar_req);
+
+    return;
+}
+
+// Function eap_wsc_registrar_if_read implements timer callback function; 
+// handles reading packets from WPS application and re-starting the timer 
+static void eap_wsc_registrar_if_read(void *eloop_ctx, void *timeout_ctx)
+{
+    u8 recvBuf[WSC_RECVBUF_SIZE];
+    u8 *req = NULL;
+    struct sockaddr_in from;
+    WSC_NOTIFY_DATA *recvNotify;
+    struct sta_info *sta;
+
+    if (udp_read_timed (eap_wsc_registrar_fd, 
+            (char *)recvBuf, WSC_RECVBUF_SIZE, &from, 0) < 0)
+    {
+        // Restart timer to check for messages on the socket 
+        eloop_register_timeout (1, 0, eap_wsc_registrar_if_read, NULL, NULL);
+        return;
+    }
+    recvNotify = (WSC_NOTIFY_DATA *)recvBuf;
+    wpa_printf(MSG_DEBUG,"\nEAP-WSC: received message for registrar, looking for station %x.%x.%x.%x.%x.%x\n", 
+        recvNotify->addr[0],
+        recvNotify->addr[1],
+        recvNotify->addr[2],
+        recvNotify->addr[3],
+        recvNotify->addr[4],
+        recvNotify->addr[5]);
+
+    // Search for registrar in associated stations database
+    sta = ap_get_sta(local_copy_of_hapd, recvNotify->addr);
+    if (sta == NULL) // Destination sta not found - drop the packet
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC-REGISTRAR: STA not found\n");
+        eloop_register_timeout (1, 0, eap_wsc_registrar_if_read, NULL, NULL);
+        return;
+    }
+
+    wpa_auth_sta_set_isreg(sta->wpa_sm, TRUE);
+
+    // Transfer the EAP packet to registrar STA
+    req = (u8 *) malloc(recvNotify->length);
+    if (!req)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC-REGISTRAR read: Memory allocation failed\n");
+            eloop_register_timeout (1, 0, eap_wsc_registrar_if_read, NULL, NULL);
+            return;
+    }
+    if (last_eap_wsc_registrar_req != NULL)
+        free(last_eap_wsc_registrar_req);
+    last_eap_wsc_registrar_req = req;
+    memcpy(req, recvNotify + 1, recvNotify->length);
+
+    ieee802_1x_send(local_copy_of_hapd, sta, IEEE802_1X_TYPE_EAP_PACKET, req, recvNotify->length);
+    eloop_register_timeout (1, 0, eap_wsc_registrar_if_read, NULL, NULL);
+    return;
+}
+
+// Function eap_wsc_registrar_if_write implements writing packets to WPS application
+void eap_wsc_registrar_if_write(struct hostapd_data *hapd, struct sta_info *sta, char *data, int len)
+{
+    u8 sendBuf[WSC_RECVBUF_SIZE];
+    int sendBufLen;
+    WSC_NOTIFY_DATA *notifyData;
+    struct sockaddr_in to;
+
+    notifyData = (WSC_NOTIFY_DATA *)sendBuf;
+    memcpy(notifyData->addr, sta->addr, 6);
+
+    wpa_printf(MSG_DEBUG,"\nEAP-WSC: message from registrar %x.%x.%x.%x.%x.%x\n", 
+        notifyData->addr[0],
+        notifyData->addr[1],
+        notifyData->addr[2],
+        notifyData->addr[3],
+        notifyData->addr[4],
+        notifyData->addr[5]);
+
+    to.sin_addr.s_addr = inet_addr(WSC_EAP_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_EAP_REGISTRAR_UDP_PORT);
+
+    memcpy(sendBuf + sizeof(WSC_NOTIFY_DATA), data, len);
+    sendBufLen = sizeof(WSC_NOTIFY_DATA) + len;
+
+    udp_write(eap_wsc_registrar_fd, (char *)sendBuf, sendBufLen, &to);
+}
+
+
+static u8 * eap_wsc_com_buildReq(struct eap_sm *sm, struct eap_wsc_data *data,
+                                int id, size_t *reqDataLen, int msg_type)
+{
+    struct sockaddr_in to;
+    WSC_NOTIFY_DATA notifyData;
+
+    if (data->gotReqLen != 0)
+    {
+        WSC_EAP_HEADER *wscEapHdr;
+
+        //There is request waiting for us
+        *reqDataLen = data->gotReqLen;
+        data->gotReqLen = 0;
+        wscEapHdr = (WSC_EAP_HEADER *)data->gotReqBuf;
+        wscEapHdr->id = id;
+        return data->gotReqBuf;
+    }
+
+    notifyData.type = msg_type; //BUILD_REQUEST for ENROLLEE or REGISTRAR
+    notifyData.u.bldReq.id = id;
+    notifyData.u.bldReq.state = data->state;
+    notifyData.length = 0;
+    memcpy(notifyData.addr, data->addr, 6);
+
+    to.sin_addr.s_addr = inet_addr(WSC_EAP_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_EAP_UDP_PORT);
+
+    if (udp_write(data->udpFdEap, (char *) &notifyData, 
+            sizeof(WSC_NOTIFY_DATA), &to) < sizeof(WSC_NOTIFY_DATA))
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Sending Eap message to "
+                "upper Layer failed\n");
+        data->state = FAILURE;
+        return NULL;
+    }
+
+    if (eap_wsc_check_for_result(data, reqDataLen) != NULL)
+    {
+        //Request was received, gotReqLen is set to packet len - reset it
+        data->gotReqLen = 0;
+    }
+    return data->gotReqBuf;
+}
+
+
+static int eap_wsc_com_process(struct eap_sm *sm, struct eap_wsc_data *data,
+                        u8 * respData, unsigned int respDataLen)
+{
+    size_t recvBytes = -1;
+    int iter_count;
+    unsigned int fromlen = 0;
+    struct sockaddr_in to;
+    u8 * sendBuf;
+    u32 sendBufLen;
+    WSC_NOTIFY_DATA notifyData;
+    struct timeval tv;
+    fd_set fdvar;
+
+    notifyData.type = WSC_NOTIFY_TYPE_PROCESS_RESP;
+    notifyData.length = respDataLen;
+    notifyData.u.process.state = data->state;
+    memcpy(notifyData.addr, data->addr, 6);
+
+    sendBuf = (u8 *) malloc(sizeof(WSC_NOTIFY_DATA) + respDataLen);
+    if ( ! sendBuf)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Memory allocation "
+                "for the sendBuf failed\n");
+        data->state = FAILURE;
+        return -1;
+    }
+
+    memcpy(sendBuf, &notifyData, sizeof(WSC_NOTIFY_DATA));
+    memcpy(sendBuf + sizeof(WSC_NOTIFY_DATA), respData, respDataLen);
+    sendBufLen = sizeof(WSC_NOTIFY_DATA) + respDataLen;
+
+    to.sin_addr.s_addr = inet_addr(WSC_EAP_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_EAP_UDP_PORT);
+
+    if (udp_write(data->udpFdEap, (char *) sendBuf, 
+            sendBufLen, &to) < sendBufLen)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Sending Eap message to "
+                "upper Layer failed\n");
+        data->state = FAILURE;
+        free(sendBuf);
+        return -1;
+    }
+
+    free(sendBuf);
+
+    iter_count = 2;
+    while (iter_count)
+    {
+        // Wait on EAP and EAP REG sockets; read from both
+        // untill at least one packet to EAP socket is received
+        FD_ZERO(&fdvar);
+        FD_SET(data->udpFdEap, &fdvar);            // read from EAP socket
+        FD_SET(eap_wsc_registrar_fd, &fdvar);    // read from EAP REG socket
+        // Wait for 5 seconds, then if received packet only for EAP REG, 
+        // wait for 5 more seconds
+        tv.tv_sec = 5; 
+        tv.tv_usec = 0;
+        if (select(32, &fdvar, (fd_set *)0, (fd_set *)0, &tv) > 0)
+        {
+            // Check if received message from EAP REG socket
+            if (FD_ISSET(eap_wsc_registrar_fd, &fdvar))
+            {
+                eloop_cancel_timeout (eap_wsc_registrar_if_read, NULL, NULL);
+                eap_wsc_registrar_if_read (NULL, NULL);
+                recvBytes = 0;
+            }
+            // Check if received message from EAP socket
+            if (FD_ISSET(data->udpFdEap, &fdvar))
+            {
+                fromlen = sizeof (struct sockaddr_in);
+                recvBytes = -1;
+                eap_wsc_check_for_result (data, &recvBytes);
+                break;
+            }
+            iter_count--; //Keep waiting for EAP message 
+            continue;
+        }
+        else
+            break;
+    }
+
+    if (recvBytes < 0) //select or readfrom failed or timed out
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Reading EAP message "
+                "from upper layer failed\n");
+        data->state = FAILURE;
+        return -1;
+    }
+
+    if (recvBytes == 0) 
+    {
+        if (!memcmp("WFA-SimpleConfig-Registrar-1-0", sm->identity, sm->identity_len))
+        {
+            // no EAP response was received, but at least
+            // packet was sent to remote registrar - continue
+            data->state = WAIT_FOR_REGISTRAR;
+        }
+        else
+        {
+            wpa_printf(MSG_INFO, "EAP-WSC: Reading EAP message "
+                "from upper layer - tiemout\n");
+            data->state = FAILURE;
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static u8 *eap_wsc_check_for_result(struct eap_wsc_data *data, size_t *reqDataLen)
+{
+    int recvBytes;
+    WSC_NOTIFY_DATA *recvNotify;
+    struct sockaddr_in from;
+    static int fail_count = 0;
+    
+    data->gotReqBuf = NULL;
+    recvBytes = udp_read_timed(data->udpFdEap, (char *) data->recvBuf, 
+            WSC_RECVBUF_SIZE, &from, 5);
+
+    if (recvBytes < 0)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC get_eap_resp: Reading EAP message "
+                "from upper layer failed or timed out\n");
+        if (data->state == WAIT_FOR_REGISTRAR)
+        {
+            fail_count++;
+            if (fail_count > 5)
+            {
+                fail_count = 0;
+                data->state = FAILURE;
+            }
+        }
+        else
+        {
+            data->state = FAILURE;
+        }
+        return NULL;
+    }
+    // Succeeded to read from EAP socket, reset failure count
+    fail_count = 0;
+
+    //Analyze received packet
+    recvNotify = (WSC_NOTIFY_DATA *) data->recvBuf;
+    printf("EAP-WSC get_eap_resp: type = %d, length = %d, result = %d\n",
+        recvNotify->type,
+        recvNotify->length,
+        recvNotify->u.processResult.result);
+    //Check packet type; in case of request check length and result
+    if (((recvNotify->type != WSC_NOTIFY_TYPE_PROCESS_RESULT) &&
+         (recvNotify->type != WSC_NOTIFY_TYPE_BUILDREQ_RESULT)) ||
+        ((recvNotify->type != WSC_NOTIFY_TYPE_BUILDREQ_RESULT) && 
+         ((recvNotify->u.processResult.result != WSC_NOTIFY_RESULT_SUCCESS) ||
+          (recvNotify->length == 0))))
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC check_for_result: Process Message/Build Request failed somewhere\n");
+        data->state = FAILURE;
+        return NULL;
+    }
+
+    if (recvNotify->type == WSC_NOTIFY_TYPE_BUILDREQ_RESULT)
+    {
+        data->gotReqBuf = (u8 *) malloc(recvNotify->length);
+        if (!data->gotReqBuf)
+        {
+            wpa_printf(MSG_INFO, "EAP-WSC: Memory allocation "
+                    "for the request failed\n");
+            data->state = FAILURE;
+            return NULL;
+        }
+    
+        memcpy(data->gotReqBuf, recvNotify + 1, recvNotify->length);
+        data->gotReqLen = *reqDataLen = recvNotify->length;
+        data->state = CONTINUE;
+    }
+
+    return data->gotReqBuf;
+}
+
+
+static void * eap_wsc_init(struct eap_sm *sm)
+{
+    struct eap_wsc_data *data;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_init *#@*#@*#@");
+
+    printf("sizeof(WSC_NOTIFY_DATA) = %d\n", sizeof(WSC_NOTIFY_DATA));
+    data = malloc(sizeof(*data));
+    if (data == NULL)
+        return data;
+    memset(data, 0, sizeof(*data));
+    data->state = START;
+    data->gotReqLen = 0;
+    //Store sta mac 
+    memcpy (data->addr, ((struct eapol_state_machine *)(sm->eapol_ctx))->addr, 6);
+    printf("WPS method init: sta addr %x.%x.%x.%x.%x.%x\n", data->addr[0], data->addr[1], data->addr[2], data->addr[3], data->addr[4], data->addr[5]);
+
+    data->udpFdEap = udp_open();
+
+    sm->eap_method_priv = data;
+
+    return data;
+}
+
+
+static void eap_wsc_reset(struct eap_sm *sm, void *priv)
+{
+    struct eap_wsc_data *data = (struct eap_wsc_data *)priv;
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_reset *#@*#@*#@");
+
+    if (data == NULL)
+        return;
+
+    if (data->udpFdEap != -1)
+    {
+        udp_close(data->udpFdEap);
+        data->udpFdEap = -1;
+    }
+
+    free(data);
+}
+
+static u8 * eap_wsc_buildReq(struct eap_sm *sm, void *priv, int id,
+                 size_t *reqDataLen)
+{
+    struct eap_wsc_data *data = priv;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_buildReq*#@*#@*#@");
+    switch (data->state) {
+    case START:
+    case CONTINUE:
+    case WAIT_FOR_REGISTRAR:
+        if (!memcmp("WFA-SimpleConfig-Registrar-1-0", sm->identity, sm->identity_len))
+        {
+            return eap_wsc_com_buildReq(sm, data, id, 
+                    reqDataLen, WSC_NOTIFY_TYPE_BUILDREQ_FROM_REG);
+        }
+        else
+        {
+            return eap_wsc_com_buildReq(sm, data, id, 
+                    reqDataLen, WSC_NOTIFY_TYPE_BUILDREQ);
+        }
+    default:
+        wpa_printf(MSG_DEBUG, "EAP-WSC: %s - unexpected state %d",
+               __func__, data->state);
+        return NULL;
+    }
+    return NULL;
+}
+
+
+static Boolean eap_wsc_check(struct eap_sm *sm, void *priv,
+                 u8 *respData, size_t respDataLen)
+{
+    struct eap_hdr *resp;
+    size_t len;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_check *#@*#@*#@");
+    resp = (struct eap_hdr *) respData;
+    if ((respDataLen < sizeof(*resp) + 2) || 
+        (len = ntohs(resp->length)) > respDataLen) 
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC : Invalid frame");
+        return TRUE;
+    }
+    return FALSE;
+}
+
+
+static void eap_wsc_process(struct eap_sm *sm, void *priv,
+                u8 *respData, size_t respDataLen)
+{
+    struct eap_wsc_data *data = priv;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_process *#@*#@*#@");
+
+    wpa_printf(MSG_DEBUG, "EAP-WSC : Received packet(len=%lu) ",
+               (unsigned long) respDataLen);
+
+    if (eap_wsc_com_process(sm, data, respData, respDataLen) < 0) 
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC : WSC  processing failed");
+        data->state = FAILURE;
+        return;
+    }
+}
+
+
+static Boolean eap_wsc_isDone(struct eap_sm *sm, void *priv)
+{
+    struct eap_wsc_data *data = priv;
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_isDone *#@*#@*#@");
+    return data->state == SUCCESS || data->state == FAILURE;
+}
+
+
+static Boolean eap_wsc_isSuccess(struct eap_sm *sm, void *priv)
+{
+    struct eap_wsc_data *data = priv;
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_isSuccess *#@*#@*#@");
+    return data->state == SUCCESS;
+}
+
+
+int eap_server_wsc_register(void)
+{
+    struct eap_method *eap;
+    int ret;
+
+    eap = eap_server_method_alloc(EAP_SERVER_METHOD_INTERFACE_VERSION,
+                      EAP_VENDOR_IETF, EAP_TYPE_WSC, "WSC");
+
+    if (eap == NULL)
+        return -1;
+
+    eap->init = eap_wsc_init;
+    eap->reset = eap_wsc_reset;
+    eap->buildReq = eap_wsc_buildReq;
+    eap->check = eap_wsc_check;
+    eap->process = eap_wsc_process;
+    eap->isDone = eap_wsc_isDone;
+    eap->getKey = NULL;
+    eap->isSuccess = eap_wsc_isSuccess;
+
+    ret = eap_server_method_register(eap);
+    if (ret)
+        eap_server_method_free(eap);
+    return ret;
+}
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/eap_wsc.h hostapd-0.5.11/eap_wsc.h
--- hostapd-0.5.11.ORIG/eap_wsc.h	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/eap_wsc.h	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,100 @@
+/* $Id: eap_wsc.h 1668 2007-09-19 08:20:05Z assafh $ */
+
+#ifndef EAP_WSC_H
+#define EAP_WSC_H
+
+/*#pragma pack(push, 1)*/
+
+#define WSC_RECVBUF_SIZE    2048
+
+typedef enum
+{
+    WSC_Start = 1,
+    WSC_ACK,
+    WSC_NACK,
+    WSC_MSG,
+    WSC_Done
+}opCode;
+
+struct eap_wsc_data {
+    enum { START, CONTINUE, SUCCESS, FAILURE, WAIT_FOR_REGISTRAR } state;
+    u8 addr[6]; //MAC ADDR of the peer station
+    int udpFdEap;
+    int udpFdCom;
+    int gotReqLen;
+    u8 *gotReqBuf;
+    u8 recvBuf[WSC_RECVBUF_SIZE];
+} __attribute__ ((packed));
+
+#define WSC_NOTIFY_TYPE_BUILDREQ              1
+#define WSC_NOTIFY_TYPE_BUILDREQ_RESULT       2
+#define WSC_NOTIFY_TYPE_PROCESS_REQ           3
+#define WSC_NOTIFY_TYPE_PROCESS_RESP          4
+#define WSC_NOTIFY_TYPE_PROCESS_RESULT        5
+#define WSC_NOTIFY_TYPE_BUILDREQ_FROM_REG     6
+
+#define WSC_NOTIFY_RESULT_SUCCESS          0x00
+#define WSC_NOTIFY_RESULT_FAILURE          0xFF
+
+typedef struct wsc_notify_buildreq_tag {
+    u32    id;
+    u32 state;
+}__attribute__((packed)) WSC_NOTIFY_BUILDREQ;
+
+typedef struct wsc_notify_process_buildreq_result_tag {
+    u8 result;
+}__attribute__((packed)) WSC_NOTIFY_BUILDREQ_RESULT;
+
+typedef struct wsc_notify_process_tag {
+    u32 state;
+}__attribute__((packed)) WSC_NOTIFY_PROCESS;
+
+typedef struct wsc_notify_process_result_tag {
+    u8 result;
+    u8 done;
+}__attribute__((packed)) WSC_NOTIFY_PROCESS_RESULT;
+
+typedef struct wsc_notify_data_tag {
+    u8 type;
+    u8 addr[6]; //MAC ADDR of the peer station
+    union {
+        WSC_NOTIFY_BUILDREQ bldReq;
+        WSC_NOTIFY_BUILDREQ_RESULT bldReqResult;
+        WSC_NOTIFY_PROCESS process;
+        WSC_NOTIFY_PROCESS_RESULT processResult;
+    } u;
+    u32 length; // length of the data that follows
+}__attribute__((packed)) WSC_NOTIFY_DATA;
+
+
+/*
+
+#define WSC_CTYPE_NEW_SETTINGS      1
+#define WSC_CTYPE_MAX               2
+
+#define WSC_MAX_SSID_LEN            32
+#define WSC_MAX_PSK_LEN             32
+
+typedef struct wsc_new_settings_tag {
+    u16 ssidLen;
+    char ssid[WSC_MAX_SSID_LEN];
+    u16 pskLen;
+    u8 psk[WSC_MAX_PSK_LEN];
+} WSC_NEW_SETTINGS;
+
+typedef struct wsc_command_data_tag {
+    u8 type;
+    union {
+        WSC_NEW_SETTINGS newSet;
+    } u;
+} WSC_COMMAND_DATA;
+*/
+
+int eap_wsc_registrar_if_init(struct hostapd_data *hapd);
+void eap_wsc_registrar_if_deinit(struct hostapd_data *hapd);
+void eap_wsc_registrar_if_write(struct hostapd_data *hapd, struct sta_info *sta, char *data, int len);
+
+/*#pragma pack(pop)*/
+
+#endif /*EAP_WSC_H*/
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/hostapd.c hostapd-0.5.11/hostapd.c
--- hostapd-0.5.11.ORIG/hostapd.c	2008-11-28 15:48:53.000000000 +0200
+++ hostapd-0.5.11/hostapd.c	2010-06-28 10:18:58.000000000 +0300
@@ -34,6 +34,9 @@
 #include "radius_client.h"
 #include "radius_server.h"
 #include "wpa.h"
+#ifdef WSC_NEW_IE
+#include "wsc_ie.h"
+#endif
 #include "preauth.h"
 #include "wme.h"
 #include "vlan_init.h"
@@ -337,6 +340,7 @@
 	wconf->wpa_group_rekey = conf->wpa_group_rekey;
 	wconf->wpa_strict_rekey = conf->wpa_strict_rekey;
 	wconf->wpa_gmk_rekey = conf->wpa_gmk_rekey;
+	wconf->rsn_pairwise = conf->rsn_pairwise;
 	wconf->rsn_preauth = conf->rsn_preauth;
 	wconf->eapol_version = conf->eapol_version;
 	wconf->peerkey = conf->peerkey;
@@ -595,6 +599,9 @@
 				   hapd->conf->iface);
 		}
 	}
+#ifdef WSC_NEW_IE
+	wsc_ie_deinit(hapd);
+#endif
 	ieee802_1x_deinit(hapd);
 	vlan_deinit(hapd);
 	hostapd_acl_deinit(hapd);
@@ -1177,6 +1184,14 @@
 			return -1;
 		}
 	}
+ 
+#ifdef WSC_NEW_IE
+	if (wsc_ie_init(hapd) < 0)
+	{
+		printf("WSC IE initialization failed.\n");
+		return -1;
+	}
+#endif
 
 	if (accounting_init(hapd)) {
 		printf("Accounting initialization failed.\n");
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/hostapd.conf hostapd-0.5.11/hostapd.conf
--- hostapd-0.5.11.ORIG/hostapd.conf	2008-08-22 11:44:51.000000000 +0300
+++ hostapd-0.5.11/hostapd.conf	2010-06-28 10:18:58.000000000 +0300
@@ -612,6 +612,8 @@
 # TKIP will be used as the group cipher.
 # (dot11RSNAConfigPairwiseCiphersTable)
 #wpa_pairwise=TKIP CCMP
+# Pairwise cipher for RSN/WPA2 (default: use wpa_pairwise value)
+#rsn_pairwise=CCMP
 
 # Time interval for rekeying GTK (broadcast/multicast encryption keys) in
 # seconds. (dot11RSNAConfigGroupRekeyTime)
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/hostapd.eap_user hostapd-0.5.11/hostapd.eap_user
--- hostapd-0.5.11.ORIG/hostapd.eap_user	2007-02-17 19:00:32.000000000 +0200
+++ hostapd-0.5.11/hostapd.eap_user	2010-06-28 10:18:58.000000000 +0300
@@ -42,6 +42,8 @@
 # based on the first PEAP packet from the supplicant.
 
 # Phase 1 users
+"WFA-SimpleConfig-Registrar-1-0"        WSC
+"WFA-SimpleConfig-Enrollee-1-0"         WSC
 "user"		MD5	"password"
 "test user"	MD5	"secret"
 "example user"	TLS
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/ieee802_1x.c hostapd-0.5.11/ieee802_1x.c
--- hostapd-0.5.11.ORIG/ieee802_1x.c	2008-11-28 16:19:36.000000000 +0200
+++ hostapd-0.5.11/ieee802_1x.c	2010-06-28 10:18:58.000000000 +0300
@@ -31,13 +31,15 @@
 #include "driver.h"
 #include "hw_features.h"
 #include "eap.h"
+#include "eap_wsc.h"
+#include "ieee802_11.h"
 
 
 static void ieee802_1x_new_auth_session(struct hostapd_data *hapd,
 					struct sta_info *sta);
 
 
-static void ieee802_1x_send(struct hostapd_data *hapd, struct sta_info *sta,
+void ieee802_1x_send(struct hostapd_data *hapd, struct sta_info *sta,
 			    u8 type, u8 *data, size_t datalen)
 {
 	u8 *buf;
@@ -870,6 +872,16 @@
 		return;
 	}
 
+#ifdef EAP_WSC
+	// Handle EAP-WPS messages (simple config request to registrar)
+	if ((hdr->type == IEEE802_1X_TYPE_EAP_PACKET) &&
+		(wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_PSK) &&
+		( wpa_auth_sta_get_isreg(sta->wpa_sm) ) )
+	{
+		eap_wsc_registrar_if_write(hapd, sta, (char *)(hdr+1), datalen);
+	}
+#endif
+
 	if (!hapd->conf->ieee802_1x ||
 	    wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_PSK)
 		return;
@@ -952,6 +964,11 @@
 	struct rsn_pmksa_cache_entry *pmksa;
 	int reassoc = 1;
 
+#ifdef EAP_WSC
+	// For any new station by default assume this is not EAP registrar
+	// Upon first WPS EAP packet this flag will be updated 	
+	wpa_auth_sta_set_isreg(sta->wpa_sm, FALSE);
+#endif
 	if (!hapd->conf->ieee802_1x ||
 	    wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_PSK)
 		return;
@@ -1332,7 +1349,6 @@
 	struct sta_info *sta;
 	u32 session_timeout = 0, termination_action, acct_interim_interval;
 	int session_timeout_set, old_vlanid = 0;
-	int eap_timeout;
 	struct eapol_state_machine *sm;
 	int override_eapReq = 0;
 
@@ -1459,18 +1475,22 @@
 	case RADIUS_CODE_ACCESS_CHALLENGE:
 		if (session_timeout_set) {
 			/* RFC 2869, Ch. 2.3.2; RFC 3580, Ch. 3.17 */
-			eap_timeout = session_timeout;
-		} else
-			eap_timeout = 30;
-		hostapd_logger(hapd, sm->addr, HOSTAPD_MODULE_IEEE8021X,
-			       HOSTAPD_LEVEL_DEBUG,
-			       "using EAP timeout of %d seconds%s",
-			       eap_timeout,
-			       session_timeout_set ? " (from RADIUS)" : "");
-		eloop_cancel_timeout(ieee802_1x_eap_timeout, sta, NULL);
-		eloop_register_timeout(eap_timeout, 0, ieee802_1x_eap_timeout,
-				       sta, NULL);
-		sm->eapTimeout = FALSE;
+			hostapd_logger(hapd, sm->addr,
+				       HOSTAPD_MODULE_IEEE8021X,
+				       HOSTAPD_LEVEL_DEBUG,
+				       "using EAP timeout of %d seconds "
+							"(from RADIUS)",
+				       session_timeout);
+			eloop_cancel_timeout(ieee802_1x_eap_timeout, sta, NULL);
+			eloop_register_timeout(session_timeout, 0,
+					ieee802_1x_eap_timeout, sta, NULL);
+			sm->eapTimeout = FALSE;
+		} else {
+			/*
+			 * Use dynamic retransmission behavior per EAP
+			 * specification.
+			 */
+		}
 		break;
 	}
 
@@ -1523,6 +1543,30 @@
 	free(sm->last_eap_radius);
 	sm->last_eap_radius = NULL;
 	sm->last_eap_radius_len = 0;
+
+	if (sm->eapTimeout && hapd->conf->wpa) {
+                /*
+                * Disconnect the STA since it did not reply to the last EAP
+                * request and we cannot continue EAP processing (EAP-Failure
+                * could only be sent if the EAP peer actually replied).
+                *
+                *
+                * Don't disconnect STAs that don't send EAPOL if we are not WPA-enabled.
+                * The latter is needed if we are configured as 802.1x-enabled and no WPA - 
+                * the case when we are launched by WPS which is configured as non-WPA.
+                * In this case we should serve manual connection attempts (no EAPOLs will arrive) as well
+                * as WPS connections (EAPOL originated by clinet's WPS will arrive).
+                */
+
+		sm->portEnabled = FALSE;
+		hostapd_sta_deauth(hapd, sta->addr,
+				   WLAN_REASON_PREV_AUTH_NOT_VALID);
+		sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC |
+				WLAN_STA_AUTHORIZED);
+		eloop_cancel_timeout(ap_handle_timer, hapd, sta);
+		eloop_register_timeout(0, 0, ap_handle_timer, hapd, sta);
+		sta->timeout_next = STA_REMOVE;
+	}
 }
 
 
@@ -1651,7 +1695,11 @@
 {
 	int i;
 
-	if ((hapd->conf->ieee802_1x || hapd->conf->wpa) &&
+#ifdef EAP_WSC
+	if (eap_wsc_registrar_if_init(hapd))
+		return -1;
+#endif
+ 	if ((hapd->conf->ieee802_1x || hapd->conf->wpa) &&
 	    hostapd_set_ieee8021x(hapd->conf->iface, hapd, 1))
 		return -1;
 
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/ieee802_1x.h hostapd-0.5.11/ieee802_1x.h
--- hostapd-0.5.11.ORIG/ieee802_1x.h	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/ieee802_1x.h	2010-06-28 10:18:58.000000000 +0300
@@ -40,6 +40,8 @@
 } __attribute__ ((packed));
 
 
+void ieee802_1x_send(struct hostapd_data *hapd, struct sta_info *sta, u8 type,
+			u8 *data, size_t datalen);
 void ieee802_1x_receive(struct hostapd_data *hapd, const u8 *sa, const u8 *buf,
 			size_t len);
 void ieee802_1x_new_station(struct hostapd_data *hapd, struct sta_info *sta);
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile hostapd-0.5.11/Makefile
--- hostapd-0.5.11.ORIG/Makefile	2008-11-28 18:21:32.000000000 +0200
+++ hostapd-0.5.11/Makefile	2010-06-28 10:18:58.000000000 +0300
@@ -1,4 +1,6 @@
-CC=gcc
+#$Id: Makefile 2890 2008-07-29 08:17:30Z andreit $
+#CC=gcc
+#DIR_WPA_SUPPLICANT=.
 DIR_WPA_SUPPLICANT=.
 
 ifndef CFLAGS
@@ -10,7 +12,7 @@
 CFLAGS += -DHOSTAPD_DUMP_STATE
 
 # Include directories for CVS version
-CFLAGS += -I. -I../utils -I$(DIR_WPA_SUPPLICANT)
+#CFLAGS += -I. -I../utils -I$(DIR_WPA_SUPPLICANT)
 
 # Uncomment following line and set the path to your kernel tree include
 # directory if your C library does not include all header files.
@@ -99,6 +101,11 @@
 CONFIG_L2_FREEBSD=y
 endif
 
+ifdef CONFIG_DRIVER_MTLK
+CFLAGS += -DCONFIG_DRIVER_MTLK
+OBJS += driver_mtlk.o
+endif
+
 ifdef CONFIG_DRIVER_TEST
 CFLAGS += -DCONFIG_DRIVER_TEST
 OBJS += driver_test.o
@@ -319,6 +326,17 @@
 CFLAGS += -DCONFIG_FULL_DYNAMIC_VLAN
 endif
 
+ifdef CONFIG_EAP_WSC   
+CFLAGS += -DEAP_WSC -DWSC_AKM_NO_1X
+OBJS += eap_wsc.o UdpLib.o
+LIBS += -lssl -lcrypto  
+endif
+
+ifdef CONFIG_WSC_IE
+CFLAGS += -DWSC_NEW_IE    
+OBJS += wsc_ie.o
+endif
+
 ALL=hostapd hostapd_cli
 
 all: verify_config $(ALL)
@@ -337,6 +355,7 @@
 
 hostapd: $(OBJS)
 	$(CC) -o hostapd $(OBJS) $(LIBS)
+	if [ "$(STRIP)" ]; then cp hostapd hostapd_debug && $(STRIP) hostapd; fi
 
 driver_conf.c: Makefile .config
 	rm -f driver_conf.c
@@ -354,6 +373,9 @@
 ifdef CONFIG_DRIVER_MADWIFI
 	echo "void madwifi_driver_register(void);"	>> driver_conf.c
 endif
+ifdef CONFIG_DRIVER_MTLK
+	echo "void mtlk_driver_register(void);"		>> driver_conf.c
+endif
 ifdef CONFIG_DRIVER_PRISM54
 	echo "void prism54_driver_register(void);"	>> driver_conf.c
 endif
@@ -376,6 +398,9 @@
 ifdef CONFIG_DRIVER_MADWIFI
 	echo "madwifi_driver_register();"		>> driver_conf.c
 endif
+ifdef CONFIG_DRIVER_MTLK
+	echo "mtlk_driver_register();"			>> driver_conf.c
+endif
 ifdef CONFIG_DRIVER_PRISM54
 	echo "prism54_driver_register();"		>> driver_conf.c
 endif
@@ -392,18 +417,7 @@
 
 hostapd_cli: hostapd_cli.o $(DIR_WPA_SUPPLICANT)/wpa_ctrl.o
 	$(CC) -o hostapd_cli hostapd_cli.o $(DIR_WPA_SUPPLICANT)/wpa_ctrl.o
-
-NOBJS = nt_password_hash.o $(DIR_WPA_SUPPLICANT)/ms_funcs.o sha1.o rc4.o md5.o
-NOBJS += $(DIR_WPA_SUPPLICANT)/crypto.o os_$(CONFIG_OS).o
-ifdef TLS_FUNCS
-LIBS_n += -lcrypto
-endif
-
-nt_password_hash: $(NOBJS)
-	$(CC) -o nt_password_hash $(NOBJS) $(LIBS_n)
-
-hlr_auc_gw: $(HOBJS)
-	$(CC) -o hlr_auc_gw $(HOBJS) $(LIBS_h)
+	if [ "$(STRIP)" ]; then cp hostapd_cli hostapd_cli_debug && $(STRIP) hostapd_cli; fi
 
 clean:
 	rm -f core *~ *.o hostapd hostapd_cli nt_password_hash hlr_auc_gw
@@ -437,4 +451,7 @@
 	./test-milenage
 	rm test-milenage
 
+romfs:
+	echo "stub"
+
 -include $(OBJS:%.o=%.d)
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.440epx hostapd-0.5.11/Makefile.440epx
--- hostapd-0.5.11.ORIG/Makefile.440epx	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.440epx	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.440epx
+#
+# @brief   This file for AMCC PPC440EPx to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/amcc/toolchain/usr/bin/ppc_4xxFP-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.5vt1310 hostapd-0.5.11/Makefile.5vt1310
--- hostapd-0.5.11.ORIG/Makefile.5vt1310	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.5vt1310	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.5vt1310
+#
+# @brief   This file for ZCOM 5VT1310 to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/crosstool/uClibc/bin/arm-linux-uclibc-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.amazon hostapd-0.5.11/Makefile.amazon
--- hostapd-0.5.11.ORIG/Makefile.amazon	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.amazon	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.amazon
+#
+# @brief   This file for Infineon Amazon_S to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/infineon/toolchain/compiler/mips-linux-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=/opt/uclibc-toolchain/ifx-lxdb26-1.0.2/gcc-3.4.4/toolchain-mips/bin/mips-linux-strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.cavium hostapd-0.5.11/Makefile.cavium
--- hostapd-0.5.11.ORIG/Makefile.cavium	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.cavium	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,21 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.cavium
+#
+# @brief   This file for CAVIUM to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/cavium/Nitrox-SOHO-2.8.3/uClinux/brecis/tools/mipsisa32-brecis-uclinux/bin/mips-
+CFLAGS=-mips32 -mtune=4kc -EB
+CC=${CROSS_COMPILE}gcc
+export CC CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.comcerto hostapd-0.5.11/Makefile.comcerto
--- hostapd-0.5.11.ORIG/Makefile.comcerto	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.comcerto	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,23 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.comcerto
+#
+# @brief   This file for Mindspeed Comcerto to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/mindspeed/toolchain/staging_dir_arm/bin/arm-linux-uclibc-
+CFLAGS=-Os -pipe -funit-at-a-time -fomit-frame-pointer -Wall -I/opt/toolchains/mindspeed/toolchain/staging_dir_arm/usr/include
+LIBS=-L/opt/toolchains/mindspeed/toolchain/staging_dir_arm/usr/lib
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.dma hostapd-0.5.11/Makefile.dma
--- hostapd-0.5.11.ORIG/Makefile.dma	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.dma	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.dma
+#
+# @brief   This file for Sigma 8621 to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8621_dma/toolchain/toolchain/bin/arm-elf-
+CFLAGS=-Os -march=armv4 -mtune=arm7tdmi -mshort-load-bytes -msoft-float
+LIBS=-Wl,-elf2flt="-s32768" 
+CC=${CROSS_COMPILE}gcc
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.dtv hostapd-0.5.11/Makefile.dtv
--- hostapd-0.5.11.ORIG/Makefile.dtv	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.dtv	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.dtv
+#
+# @brief   This file for Sigma 8624 to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8624_dtv/toolchain/toolchain/bin/arm-elf-
+CFLAGS=-Os -march=armv4 -mtune=arm7tdmi -mshort-load-bytes -msoft-float
+LIBS=-Wl,-elf2flt="-s32768" 
+CC=${CROSS_COMPILE}gcc
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.MTLK hostapd-0.5.11/Makefile.MTLK
--- hostapd-0.5.11.ORIG/Makefile.MTLK	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.MTLK	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,41 @@
+######### Metalink (c) #####################
+######### Standard header begin ############
+
+## TOPDIR may be set. It points to the top directory where all the E_* variables are in Makefiles.MTLK.vars
+
+ifdef E_TOPDIR
+include $(E_TOPDIR)/scripts/Makefile.MTLK.vars
+else
+$(error "E_TOPDIR doesn't defined")
+endif
+
+######### Standard header end ##############
+
+
+#CROSS_COMPILE=/opt/star/tools/arm-uclibc-3.4.6/bin/arm-linux-uclibc-
+CC=$(E_CC)
+CFLAGS=-MMD -g -Os -I/$(E_TOPDIR)/l/openssl/include/
+LIBS=-L$(E_TOPDIR)/l/openssl 
+STRIP=$(E_STRIP)
+export CC CFLAGS LIBS STRIP
+
+
+
+CONF:
+	echo "No configure needed "
+COMP:
+	make -f Makefile
+
+CLEAN:
+	make -f Makefile clean
+
+INSTALL: FORCE
+	#nstall -d 755 $(E_DEST)/rootfs-star_/root/mtlk/etc
+	install -m 666 -D template.conf $(E_DEST)/root/mtlk/etc/template.conf
+	install -m 755 -D hostapd $(E_DEST)/root/mtlk/etc/hostapd
+	install -m 755 -D hostapd_cli $(E_DEST)/root/mtlk/etc/hostapd_cli
+
+STRIP: FORCE
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/hostapd
+
+FORCE:
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.pika hostapd-0.5.11/Makefile.pika
--- hostapd-0.5.11.ORIG/Makefile.pika	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.pika	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.pika
+#
+# @brief   This file for Sigma 8622 to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8622_pika/toolchain/toolchain/bin/arm-elf-
+CFLAGS=-Os -march=armv4 -mtune=arm7tdmi -mshort-load-bytes -msoft-float
+LIBS=-Wl,-elf2flt="-s32768" 
+CC=${CROSS_COMPILE}gcc
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.STAR hostapd-0.5.11/Makefile.STAR
--- hostapd-0.5.11.ORIG/Makefile.STAR	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.STAR	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.str9102
+#
+# @brief   This file for STAR 9102 Dorado to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/star/tools/arm-uclibc-3.4.6/bin/arm-linux-uclibc-
+CFLAGS=-Os -I/opt/apps-rootfs/openssl-0.9.8a/include
+CC=${CROSS_COMPILE}gcc
+LIBS=-L/opt/apps-rootfs/openssl-0.9.8a 
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.str9102 hostapd-0.5.11/Makefile.str9102
--- hostapd-0.5.11.ORIG/Makefile.str9102	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.str9102	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.str9102
+#
+# @brief   This file for STAR 9102 Dorado to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/star/toolchain/tools/arm-uclibc-3.4.6/bin/arm-linux-uclibc-
+CFLAGS=-Os
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.vantage hostapd-0.5.11/Makefile.vantage
--- hostapd-0.5.11.ORIG/Makefile.vantage	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.vantage	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.vantage
+#
+# @brief   This file for Sigma 8634 to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8634_jabil/toolchain/toolchain/build_mipsel_nofpu/staging_dir/bin/mipsel-linux-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/Makefile.vantage26 hostapd-0.5.11/Makefile.vantage26
--- hostapd-0.5.11.ORIG/Makefile.vantage26	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/Makefile.vantage26	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.vantage26
+#
+# @brief   This file for Sigma 8634 (linux-2.6) to build the hostapd utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8634_jabil/toolchain26/toolchain/build_mipsel_nofpu/staging_dir/bin/mipsel-linux-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/mkdistr.sh hostapd-0.5.11/mkdistr.sh
--- hostapd-0.5.11.ORIG/mkdistr.sh	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/mkdistr.sh	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,59 @@
+#!/bin/bash
+
+################################################################################
+# This script aimed to create fully functional distribution src tarball.       #
+# Call it from hostapd-0.4.10, and give to it name of distribution.            #
+################################################################################
+
+HOSTAPD_DIR=hostapd
+HOSTAPD_VERSION=0.4.10
+
+# List of dirs to process
+# We do not process dirs recursively
+# If you wont to add some dir - just put it here
+DIRS="\
+  .\
+"
+BASEDIR=`pwd`
+
+# Types of required src files
+FILETYPES="\
+  *.c\
+  *.h\
+  *.conf\
+"
+
+# List of exceptions
+# Warning: all directores must exist
+EXCEPTIONS="\
+	./.config\
+	./Makefile\
+	./Makefile.vantage26\
+	./Makefile.pika\
+"
+
+# Handle all specified dirs
+for i in $DIRS;
+do
+  mkdir -p $HOSTAPD_DIR-$HOSTAPD_VERSION/$i/
+  cd $i/;
+  for j in `ls $FILETYPES 2>/dev/null`;
+  do
+    link ./$j $BASEDIR/$HOSTAPD_DIR-$HOSTAPD_VERSION/$i/$j 2>/dev/null;
+  done;
+  cd $BASEDIR;
+done;
+
+# Handle all exceptions
+for i in $EXCEPTIONS;
+do
+  link ./$i $BASEDIR/$HOSTAPD_DIR-$HOSTAPD_VERSION/$i 2>/dev/null;
+done 
+
+# Create tarball
+cd $BASEDIR
+tar -cvjf $HOSTAPD_DIR-$HOSTAPD_VERSION-metalink.tar.bz2 $HOSTAPD_DIR-$HOSTAPD_VERSION 
+rm -rf $HOSTAPD_DIR-$HOSTAPD_VERSION 
+
+# Cleanup
+rm -rf $HOSTAPD_DIR-$HOSTAPD_VERSION
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/template.conf hostapd-0.5.11/template.conf
--- hostapd-0.5.11.ORIG/template.conf	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/template.conf	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,26 @@
+interface=ath0
+#
+logger_syslog=-1
+logger_syslog_level=2
+logger_stdout=-1
+logger_stdout_level=2
+
+# Debugging: 0 = no, 1 = minimal, 2 = verbose, 3 = msg dumps, 4 = excessive
+debug=2
+
+# Dump file for state information (on SIGUSR1)
+dump_file=/tmp/hostapd.dump
+
+ctrl_interface=/var/run/hostapd
+ctrl_interface_group=0
+
+macaddr_acl=0
+auth_algs=3
+ieee8021x=1
+eap_server=1
+eap_user_file=hostapd.eap_user
+eap_message=hello
+eapol_key_index_workaround=0
+own_ip_addr=192.168.1.1
+wpa=3
+wpa_pairwise=TKIP CCMP
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/UdpLib.c hostapd-0.5.11/UdpLib.c
--- hostapd-0.5.11.ORIG/UdpLib.c	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/UdpLib.c	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,285 @@
+/*
+ * hostapd / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WSC and COPYING for more details.
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <errno.h>
+#include "UdpLib.h"
+
+// Comment out the next line if debug strings are not needed
+#define U_DEBUG
+
+void DEBUGF(char *, ...);
+
+
+/******************************************************************************
+ * udp_open()
+ *
+ * This function opens a UDP socket and returns the socket to the calling 
+ * application. The application will use this socket in any subsequent calls.
+ * 
+ * Returns socket handle on success or -1 if there is an error.
+ ****************************************************************************/
+int udp_open()
+{
+    int        new_sock;     // temporary socket handle
+    int n = 1;
+#ifdef _WIN32_REAL
+    int           retval; 
+    WSADATA       wsa_data;
+#endif // _WIN32_REAL
+
+    DEBUGF("Entered udp_open\n");
+
+#ifdef _WIN32_REAL
+    retval = WSAStartup(MAKEWORD(2, 0), &wsa_data);
+    if (retval != 0)
+    {
+        DEBUGF("WSAStartup call failed.\n");
+        return -1;
+    }
+#endif // _WIN32_REAL
+
+    // create INTERNET, udp datagram socket
+    new_sock = (int) socket(AF_INET, SOCK_DGRAM, 0); 
+
+    if ( new_sock < 0 ) {
+        DEBUGF("socket call failed.\n");
+        return -1;
+    }
+
+    setsockopt(new_sock, SOL_SOCKET, SO_REUSEADDR, (char *) &n, sizeof(n));
+
+    DEBUGF("Socket open successful, sd: %d\n", new_sock);
+
+    return new_sock;
+}
+
+
+/******************************************************************************
+ * udp_bind(int fd, int portno)
+ *
+ * This call is used typically by the server application to establish a
+ * well known port. 
+ * 
+ * Returns 1 if succeeds and returns -1 in case of an error.
+ ****************************************************************************/
+int udp_bind(int fd, int portno)
+{
+    struct sockaddr_in binder;
+
+    DEBUGF("Entered udp_bind\n");
+
+    binder.sin_family = AF_INET;
+    binder.sin_addr.s_addr = INADDR_ANY;
+    binder.sin_port = htons(portno);
+
+    // bind protocol to socket
+    if (bind(fd, (struct sockaddr *)&binder, sizeof(binder)))
+    {
+        DEBUGF("bind call for socket [%d] failed.\n", fd);
+        return -1;
+    }
+
+    DEBUGF("Binding successful for socket [%d]\n", fd);
+
+    return 1;
+}
+
+
+/******************************************************************************
+ * udp_close(int fd)
+ *
+ * Closes a UDP session. Closes the socket and returns.
+ ****************************************************************************/
+void udp_close(int fd)
+{
+    DEBUGF("Entered udp_close\n");
+
+#ifdef _WIN32_REAL
+    WSACleanup();
+    closesocket(fd);
+#endif // _WIN32_REAL
+
+#ifdef __linux__
+    close(fd);
+#endif // __linux__
+
+    return;
+}
+
+
+/******************************************************************************
+ * udp_write(int fd, char * buf, int len, struct sockaddr_in * to)
+ * 
+ * This function is called by the application to send data.
+ * fd - socket handle
+ * buf - data buffer
+ * len - byte count of data in buf
+ * to - socket address structure that contains remote ip address and port
+ *      where the data is to be sent
+ * 
+ * Returns bytesSent if succeeded. If there is an error -1 is returned
+ ****************************************************************************/
+int udp_write(int fd, char * buf, int len, struct sockaddr_in * to)
+{
+    int            bytes_sent;
+
+    DEBUGF("Entered udp_write: len %d\n", len);
+    bytes_sent = sendto(fd, buf, len, 0, 
+           (struct sockaddr *) to, 
+           sizeof(struct sockaddr_in));
+    if (bytes_sent < 0)
+    {
+        DEBUGF("sendto on socket %d failed\n", fd);
+        return -1;
+    }
+    return bytes_sent;
+}
+
+
+/******************************************************************************
+ * udp_read(int fd, char * buf, int len, struct sockaddr_in * from)
+ * 
+ * This function is called by the application to receive data. 
+ * fd - socket handle
+ * buf - data buffer in which the received data will be put
+ * len - size of buf in bytes
+ * from - socket address structure that contains remote ip address and port
+ *        from where the data is received
+ * 
+ * Returns bytes received if succeeded. If there is an error -1 is returned
+ ****************************************************************************/
+int udp_read(int fd, char * buf, int len, struct sockaddr_in * from)
+{
+    int bytes_recd = 0;
+    unsigned int fromlen = 0;
+    fd_set        fdvar;
+    int            sel_ret;
+
+    DEBUGF("Entered udp_read\n");
+
+    FD_ZERO(&fdvar);
+    // we have to wait for only one descriptor
+    FD_SET(fd, &fdvar);
+    
+    sel_ret = select(32, &fdvar, (fd_set *) 0, (fd_set *) 0, NULL);
+    
+    // if select returns negative value, system error
+    if (sel_ret < 0)
+    {
+        DEBUGF("select call failed; system error\n");
+        return -1;
+    }
+
+    // Otherwise Read notification might has come, since we are
+    // waiting for only one fd we need not check the bit. Go ahead
+    // and read the packet
+    fromlen = sizeof (struct sockaddr_in);
+    bytes_recd = recvfrom(fd, buf, len, 0,
+                (struct sockaddr *)from, &fromlen);
+    if (bytes_recd < 0)
+    {
+        DEBUGF("recvfrom on socket %d failed\n", fd);
+        return -1;
+    }
+
+    DEBUGF("Read %d bytes\n", bytes_recd);
+
+    return bytes_recd;
+}
+
+/******************************************************************************
+ * udp_read_timed(int fd, char * buf, int len, 
+ *                  struct sockaddr_in * from, int timeout)
+ * 
+ * This function is called by the application to receive data. 
+ * fd - socket handle
+ * buf - data buffer in which the received data will be put
+ * len - size of buf in bytes
+ * from - socket address structure that contains remote ip address and port
+ *        from where the data is received
+ * timeout - wait time in seconds
+ * 
+ * Returns bytes received if succeeded. If there is an error -1 is returned
+ ****************************************************************************/
+int udp_read_timed(int fd, char * buf, int len, 
+            struct sockaddr_in * from, int timeout)
+{
+    int bytes_recd = 0;
+    unsigned int fromlen = 0;
+    fd_set        fdvar;
+    int            sel_ret;
+    struct timeval tv;
+
+    //DEBUGF("Entered udp_read\n");
+
+    tv.tv_sec = timeout;
+    tv.tv_usec = 0;
+
+    FD_ZERO(&fdvar);
+    // we have to wait for only one descriptor
+    FD_SET(fd, &fdvar);
+    
+    sel_ret = select(32, &fdvar, (fd_set *) 0, (fd_set *) 0, &tv);
+    
+    // if select returns negative value, system error
+    if (sel_ret < 0)
+    {
+        DEBUGF("select call failed; system error\n");
+        return -1;
+    }
+    else if (sel_ret == 0)
+    {
+        //DEBUGF("select call timed out\n");
+        return -2;
+    }
+
+    // Otherwise Read notification might has come, since we are
+    // waiting for only one fd we need not check the bit. Go ahead
+    // and read the packet
+    fromlen = sizeof (struct sockaddr_in);
+    bytes_recd = recvfrom(fd, buf, len, 0,
+                (struct sockaddr *)from, &fromlen);
+    if (bytes_recd < 0)
+    {
+        DEBUGF("recvfrom on socket %d failed\n", fd);
+        return -1;
+    }
+
+    DEBUGF("Read %d bytes\n", bytes_recd);
+
+    return bytes_recd;
+}
+
+void DEBUGF(char * strFormat, ...)
+{
+#ifdef U_DEBUG
+    char     szTraceMsg[1000];
+    va_list  lpArgv;
+
+    va_start(lpArgv, strFormat);
+    vsprintf(szTraceMsg, strFormat, lpArgv);
+    va_end(lpArgv); 
+
+    fprintf(stdout, "UdpLib: %s", szTraceMsg);
+#endif
+}
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/UdpLib.h hostapd-0.5.11/UdpLib.h
--- hostapd-0.5.11.ORIG/UdpLib.h	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/UdpLib.h	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,13 @@
+#ifndef _UDPLIB_
+#define _UDPLIB_
+
+int udp_open();
+int udp_bind(int fd, int portno);
+void udp_close(int fd);
+int udp_write(int fd, char * buf, int len, struct sockaddr_in * to);
+int udp_read(int fd, char * buf, int len, struct sockaddr_in * from);
+int udp_read_timed(int fd, char * buf, int len, 
+        struct sockaddr_in * from, int timeout);
+ 
+#endif // _UDPLIB_
+
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/version.h hostapd-0.5.11/version.h
--- hostapd-0.5.11.ORIG/version.h	2008-11-28 18:21:32.000000000 +0200
+++ hostapd-0.5.11/version.h	2010-06-28 10:18:58.000000000 +0300
@@ -1,6 +1,6 @@
 #ifndef VERSION_H
 #define VERSION_H
 
-#define VERSION_STR "0.5.11"
+#define VERSION_STR "0.5.11_mtlk-1.2.6"
 
 #endif /* VERSION_H */
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/wpa.c hostapd-0.5.11/wpa.c
--- hostapd-0.5.11.ORIG/wpa.c	2008-10-26 16:52:45.000000000 +0200
+++ hostapd-0.5.11/wpa.c	2010-06-28 10:18:58.000000000 +0300
@@ -125,6 +125,11 @@
 
 	u32 dot11RSNAStatsTKIPLocalMICFailures;
 	u32 dot11RSNAStatsTKIPRemoteMICFailures;
+
+#ifdef EAP_WSC
+	u32 rsnssn_present;
+	u8 is_registrar;
+#endif
 };
 
 
@@ -202,8 +207,8 @@
 
 /* Default timeouts are 100 ms, but this seems to be a bit too fast for most
  * WPA Supplicants, so use a bit longer timeout. */
-static const u32 dot11RSNAConfigGroupUpdateTimeOut = 1000; /* ms */
-static const u32 dot11RSNAConfigGroupUpdateCount = 3;
+static const u32 dot11RSNAConfigGroupUpdateTimeOut = 3000; /* ms */
+static const u32 dot11RSNAConfigGroupUpdateCount = 30;
 static const u32 dot11RSNAConfigPairwiseUpdateTimeOut = 1000; /* ms */
 static const u32 dot11RSNAConfigPairwiseUpdateCount = 3;
 
@@ -604,17 +609,17 @@
 	count = pos;
 	pos += 2;
 
-	if (conf->wpa_pairwise & WPA_CIPHER_CCMP) {
+	if (conf->rsn_pairwise & WPA_CIPHER_CCMP) {
 		memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_pairwise & WPA_CIPHER_TKIP) {
+	if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
 		memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_pairwise & WPA_CIPHER_NONE) {
+	if (conf->rsn_pairwise & WPA_CIPHER_NONE) {
 		memcpy(pos, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
@@ -622,7 +627,7 @@
 
 	if (num_suites == 0) {
 		wpa_printf(MSG_DEBUG, "Invalid pairwise cipher (%d).",
-			   conf->wpa_pairwise);
+			   conf->rsn_pairwise);
 		return -1;
 	}
 	*count++ = num_suites & 0xff;
@@ -1345,7 +1350,11 @@
 	else
 		sm->wpa_key_mgmt = WPA_KEY_MGMT_PSK;
 
-	ciphers = data.pairwise_cipher & wpa_auth->conf.wpa_pairwise;
+	
+	if (version == HOSTAPD_WPA_VERSION_WPA2)
+		ciphers = data.pairwise_cipher & wpa_auth->conf.rsn_pairwise;
+	else
+		ciphers = data.pairwise_cipher & wpa_auth->conf.wpa_pairwise;
 	if (!ciphers) {
 		wpa_printf(MSG_DEBUG, "Invalid WPA pairwise cipher (0x%x) "
 			   "from " MACSTR,
@@ -3675,6 +3684,26 @@
 }
 
 
+#ifdef EAP_WSC
+int wpa_auth_sta_set_isreg(struct wpa_state_machine *sm, u8 val)
+{
+	if (sm == NULL)
+		return -1;
+
+	sm->is_registrar = val;
+	return 0;
+}
+
+
+int wpa_auth_sta_get_isreg(struct wpa_state_machine *sm)
+{
+	if (sm == NULL)
+		return 0;
+	return sm->is_registrar;
+}
+#endif
+
+
 int wpa_auth_sta_wpa_version(struct wpa_state_machine *sm)
 {
 	if (sm == NULL)
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/wpa.h hostapd-0.5.11/wpa.h
--- hostapd-0.5.11.ORIG/wpa.h	2007-03-25 04:09:43.000000000 +0200
+++ hostapd-0.5.11/wpa.h	2010-06-28 10:18:58.000000000 +0300
@@ -86,6 +86,7 @@
 	int wpa_group_rekey;
 	int wpa_strict_rekey;
 	int wpa_gmk_rekey;
+	int rsn_pairwise;
 	int rsn_preauth;
 	int eapol_version;
 	int peerkey;
@@ -167,6 +168,8 @@
 void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth);
 int wpa_auth_pairwise_set(struct wpa_state_machine *sm);
 int wpa_auth_sta_key_mgmt(struct wpa_state_machine *sm);
+int wpa_auth_sta_set_isreg(struct wpa_state_machine *sm, u8 val);
+int wpa_auth_sta_get_isreg(struct wpa_state_machine *sm);
 int wpa_auth_sta_wpa_version(struct wpa_state_machine *sm);
 int wpa_auth_sta_clear_pmksa(struct wpa_state_machine *sm,
 			     struct rsn_pmksa_cache_entry *entry);
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/wsc_ie.c hostapd-0.5.11/wsc_ie.c
--- hostapd-0.5.11.ORIG/wsc_ie.c	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/wsc_ie.c	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,146 @@
+/*
+ * hostapd / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WSC and COPYING for more details.
+ *
+ * $Id: wsc_ie.c 2702 2008-06-02 16:10:02Z mykytaz $
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <time.h>
+
+#include "eloop.h"
+#include "hostapd.h"
+#include "ieee802_11.h"
+#include "radius.h"
+#include "radius_client.h"
+#include "ieee802_11_auth.h"
+#include "sta_info.h"
+#include "eapol_sm.h"
+#include "rc4.h"
+#include "ieee802_1x.h"
+#include "wpa.h"
+#include "accounting.h"
+#include "driver.h"
+#include "hostap_common.h"
+#include "UdpLib.h"
+#include "wsc_ie.h"
+
+// Comment out the next line if debug strings are not needed
+#define U_DEBUG
+
+void DEBUGF(char *, ...);
+
+static WSC_IE_DATA * g_wsc_ie_data;
+
+
+static void wsc_ie_read_callback(int sock, void *eloop_ctx, void *sock_ctx)
+{
+    WSC_IE_DATA * data = eloop_ctx;
+    WSC_IE_COMMAND_DATA * cmdData;
+    char readBuf[WSC_WLAN_DATA_MAX_LENGTH];
+    int recvBytes;
+    struct sockaddr_in from;
+    u8 * bufPtr;
+
+    wpa_printf(MSG_INFO, "WSC_IE: Entered wsc_ie_read_callback. "
+            "sock = %d", sock);
+
+    recvBytes = udp_read(data->udpFdCom, readBuf,
+            WSC_WLAN_DATA_MAX_LENGTH, &from);
+
+    if (recvBytes == -1)
+    {
+        wpa_printf(MSG_ERROR, "WSC_IE: Reading Command message "
+                "from upper layer failed");
+        return;
+    }
+
+    cmdData = (WSC_IE_COMMAND_DATA *) readBuf;
+
+    if (cmdData->type == WSC_IE_TYPE_SET_BEACON_IE)
+    {
+        wpa_printf(MSG_INFO, "WSC_IE: SET_BEACON_IE from upper layer");
+        bufPtr = (u8 *) &(cmdData->data[0]);
+        hostapd_set_wsc_beacon_ie(data->hapd, bufPtr, cmdData->length);
+    }
+    else if (cmdData->type == WSC_IE_TYPE_SET_PROBE_RESPONSE_IE)
+    {
+        wpa_printf(MSG_INFO, "WSC_IE: SET_PR_RESP_IE from upper layer");
+        bufPtr = (u8 *) &(cmdData->data[0]);
+        hostapd_set_wsc_probe_resp_ie(data->hapd, bufPtr, cmdData->length);
+    }
+    else
+    {
+        wpa_printf(MSG_ERROR, "WSC_IE: Wrong command type from upper layer");
+        return;
+    }
+    return;
+}
+
+
+int wsc_ie_init(struct hostapd_data *hapd)
+{
+    struct sockaddr_in to;
+    char sendBuf[5];
+
+    wpa_printf(MSG_INFO, "WSC_IE: In wsc_ie_init");
+    
+    g_wsc_ie_data = malloc(sizeof(WSC_IE_DATA));
+    
+    if (g_wsc_ie_data == NULL)
+    {
+        return -1;
+    }
+
+    memset(g_wsc_ie_data, 0, sizeof(WSC_IE_DATA));
+
+    g_wsc_ie_data->hapd = hapd;
+    g_wsc_ie_data->udpFdCom = udp_open();
+
+    eloop_register_read_sock(g_wsc_ie_data->udpFdCom, wsc_ie_read_callback,
+                 g_wsc_ie_data, NULL);
+    /* Send a start packet */
+    strcpy(sendBuf, "PORT");
+    to.sin_addr.s_addr = inet_addr(WSC_WLAN_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_WLAN_UDP_PORT);
+
+    if (udp_write(g_wsc_ie_data->udpFdCom, sendBuf, 5, &to) < 5)
+    {
+        wpa_printf(MSG_ERROR, "WSC_IE: Sending Port message to "
+                "upper Layer failed");
+        return -1;
+    }
+
+    return 0;
+}
+
+int wsc_ie_deinit(struct hostapd_data *hapd)
+{
+    if (g_wsc_ie_data) {
+        if (g_wsc_ie_data->udpFdCom != -1) {
+            eloop_unregister_read_sock(g_wsc_ie_data->udpFdCom);
+            udp_close(g_wsc_ie_data->udpFdCom);
+        }
+        free(g_wsc_ie_data);
+        g_wsc_ie_data = NULL;
+    }
+
+    return 0;
+}
diff -Naur -x '\.svn' hostapd-0.5.11.ORIG/wsc_ie.h hostapd-0.5.11/wsc_ie.h
--- hostapd-0.5.11.ORIG/wsc_ie.h	1970-01-01 02:00:00.000000000 +0200
+++ hostapd-0.5.11/wsc_ie.h	2010-06-28 10:18:58.000000000 +0300
@@ -0,0 +1,42 @@
+/* $Id: wsc_ie.h 2466 2008-04-02 08:25:35Z andreit $ */
+
+#ifndef _WSC_IE_H_
+#define _WSC_IE_H_
+
+/*#pragma pack(push, 1)*/
+
+typedef struct wsc_ie_data {
+    struct hostapd_data * hapd;
+    int udpFdCom;
+}__attribute__((packed)) WSC_IE_DATA;
+
+#define WSC_WLAN_UDP_PORT       38000
+#define WSC_WLAN_UDP_ADDR       "127.0.0.1"
+
+#define WSC_WLAN_DATA_MAX_LENGTH         1024
+
+#define WSC_IE_TYPE_SET_BEACON_IE                1
+#define WSC_IE_TYPE_SET_PROBE_REQUEST_IE         2
+#define WSC_IE_TYPE_SET_PROBE_RESPONSE_IE        3
+#define WSC_IE_TYPE_BEACON_IE_DATA               4
+#define WSC_IE_TYPE_PROBE_REQUEST_IE_DATA        5
+#define WSC_IE_TYPE_PROBE_RESPONSE_IE_DATA       6
+#define WSC_IE_TYPE_SEND_BEACONS_UP              7
+#define WSC_IE_TYPE_SEND_PR_RESPS_UP             8
+#define WSC_IE_TYPE_SEND_PROBE_REQUEST           9
+#define WSC_IE_TYPE_MAX                         10
+
+typedef struct wsc_ie_command_data {
+    u8  type;
+    u32 length;
+    u8  data[0];
+}__attribute__((packed)) WSC_IE_COMMAND_DATA;
+
+
+int wsc_ie_init(struct hostapd_data * hapd);
+int wsc_ie_deinit(struct hostapd_data * hapd);
+ 
+/*#pragma pack(pop)*/
+
+#endif // _WSC_IE_H_
+
