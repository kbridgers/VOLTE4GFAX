diff -Nur hostap-06-d23bf71/build_release hostap06/build_release
--- hostap-06-d23bf71/build_release	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/build_release	2009-03-23 14:17:09.000000000 +0200
@@ -31,13 +31,13 @@
 mkdir $TMP
 mkdir -p $RELDIR
 
-git archive --format=tar --prefix=wpa-$VER/ HEAD \
+git-archive --format=tar --prefix=wpa-$VER/ HEAD \
 	README COPYING patches src wpa_supplicant hostapd |
 	gzip > $RELDIR/wpa-$VER.tar.gz
-git archive --format=tar --prefix=hostapd-$VER/ HEAD \
+git-archive --format=tar --prefix=hostapd-$VER/ HEAD \
 	README COPYING patches src hostapd |
 	gzip > $RELDIR/hostapd-$VER.tar.gz
-git archive --format=tar --prefix=wpa_supplicant-$VER/ HEAD \
+git-archive --format=tar --prefix=wpa_supplicant-$VER/ HEAD \
 	README COPYING patches src wpa_supplicant |
 	tar --directory=$TMP -xf -
 
diff -Nur hostap-06-d23bf71/eap_example/.gitignore hostap06/eap_example/.gitignore
--- hostap-06-d23bf71/eap_example/.gitignore	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/eap_example/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -1,4 +1,3 @@
 *.d
 eap_example
 libeap.so
-libeap.a
diff -Nur hostap-06-d23bf71/eap_example/Makefile hostap06/eap_example/Makefile
--- hostap-06-d23bf71/eap_example/Makefile	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/eap_example/Makefile	2009-03-23 14:17:09.000000000 +0200
@@ -21,6 +21,10 @@
 CFLAGS += -I../src/utils
 CFLAGS += -I../src/common
 
+# at least for now, need to include config_ssid.h and config_blob.h from
+# wpa_supplicant directory
+CFLAGS += -I../wpa_supplicant
+
 
 OBJS_both += ../src/utils/common.o
 OBJS_both += ../src/utils/os_unix.o
diff -Nur hostap-06-d23bf71/.gitignore hostap06/.gitignore
--- hostap-06-d23bf71/.gitignore	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,3 +0,0 @@
-*.o
-*.d
-*~
diff -Nur hostap-06-d23bf71/hostapd/ap.h hostap06/hostapd/ap.h
--- hostap-06-d23bf71/hostapd/ap.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/ap.h	2009-03-23 14:17:09.000000000 +0200
@@ -30,7 +30,7 @@
 #define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
 #define WLAN_STA_SHORT_PREAMBLE BIT(7)
 #define WLAN_STA_PREAUTH BIT(8)
-#define WLAN_STA_WMM BIT(9)
+#define WLAN_STA_WME BIT(9)
 #define WLAN_STA_MFP BIT(10)
 #define WLAN_STA_HT BIT(11)
 #define WLAN_STA_WPS BIT(12)
diff -Nur hostap-06-d23bf71/hostapd/beacon.c hostap06/hostapd/beacon.c
--- hostap-06-d23bf71/hostapd/beacon.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/beacon.c	2009-03-23 14:17:09.000000000 +0200
@@ -298,8 +298,8 @@
 
 	pos = hostapd_eid_wpa(hapd, pos, epos - pos, sta);
 
-	/* Wi-Fi Alliance WMM */
-	pos = hostapd_eid_wmm(hapd, pos);
+	/* Wi-Fi Wireless Multimedia Extensions */
+	pos = hostapd_eid_wme(hapd, pos);
 
 	pos = hostapd_eid_ht_capabilities_info(hapd, pos);
 	pos = hostapd_eid_ht_operation(hapd, pos);
@@ -395,8 +395,8 @@
 	tailpos = hostapd_eid_wpa(hapd, tailpos, tail + BEACON_TAIL_BUF_SIZE -
 				  tailpos, NULL);
 
-	/* Wi-Fi Alliance WMM */
-	tailpos = hostapd_eid_wmm(hapd, tailpos);
+	/* Wi-Fi Wireless Multimedia Extensions */
+	tailpos = hostapd_eid_wme(hapd, tailpos);
 
 #ifdef CONFIG_IEEE80211N
 	if (hapd->iconf->ieee80211n) {
diff -Nur hostap-06-d23bf71/hostapd/ChangeLog hostap06/hostapd/ChangeLog
--- hostap-06-d23bf71/hostapd/ChangeLog	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/ChangeLog	2009-05-22 14:31:10.000000000 +0300
@@ -1,26 +1,9 @@
 ChangeLog for hostapd
 
-2010-01-12 - v0.6.10
+????-??-?? - v0.6.10
 	* fixed SHA-256 based key derivation function to match with the
 	  standard when using CCMP (for IEEE 802.11r and IEEE 802.11w)
 	  (note: this breaks interoperability with previous version) [Bug 307]
-	* fixed WPS selected registrar expiration for internal PIN registrar
-	* disable PMTU discovery for RADIUS packets
-	* fixed WPS UPnP SSDP on 32-bit targets
-	* fixed WPS AP reconfiguration with drivers that do not use hostapd
-	  MLME
-	* fixed RSN parameter setting for multi-BSS case
-	* added WPS workarounds for known interoperability issues with broken,
-	  deployed implementation
-	* update IEEE 802.11w implementation to match with the published
-	  standard
-	* fixed OpCode when proxying WSC_ACK or WSC_NACK from WPS ER
-	* fixed proxying of WSC_NACK to WPS ER
-	* fixed compilation with newer GnuTLS versions
-	* added support for defining timeout for WPS PINs
-	* fixed WPS Probe Request processing to handle missing required
-	  attribute
-	* fixed PKCS#12 use with OpenSSL 1.0.0
 
 2009-03-23 - v0.6.9
 	* driver_nl80211: fixed STA accounting data collection (TX/RX bytes
diff -Nur hostap-06-d23bf71/hostapd/.config hostap06/hostapd/.config
--- hostap-06-d23bf71/hostapd/.config	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/hostapd/.config	2009-06-02 16:51:40.000000000 +0300
@@ -0,0 +1,150 @@
+# Example hostapd build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cass, these lines should use += in order not
+# to override previous values of the variables.
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for wired authenticator
+#CONFIG_DRIVER_WIRED=y
+
+# Driver interface for madwifi driver
+#CONFIG_DRIVER_MADWIFI=y
+#CFLAGS += -I../../madwifi # change to the madwifi source directory
+
+# Driver interface for Prism54 driver
+#CONFIG_DRIVER_PRISM54=y
+
+# Driver interface for drivers using the nl80211 kernel interface
+#CONFIG_DRIVER_NL80211=y
+# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
+# shipped with your distribution yet. If that is the case, you need to build
+# newer libnl version and point the hostapd build to use it.
+#LIBNL=/usr/src/libnl
+#CFLAGS += -I$(LIBNL)/include
+#LIBS += -L$(LIBNL)/lib
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+
+# Driver interface for Metalink WLANPlus driver
+CONFIG_DRIVER_MTLK=y
+
+# Driver interface for no driver (e.g., RADIUS server only)
+#CONFIG_DRIVER_NONE=y
+
+# IEEE 802.11F/IAPP
+CONFIG_IAPP=y
+
+# WPA2/IEEE 802.11i RSN pre-authentication
+CONFIG_RSN_PREAUTH=y
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Integrated EAP server
+CONFIG_EAP=y
+
+# EAP-MD5 for the integrated EAP server
+CONFIG_EAP_MD5=y
+
+# EAP-TLS for the integrated EAP server
+CONFIG_EAP_TLS=y
+CONFIG_TLS=internal
+CONFIG_INTERNAL_LIBTOMMATH=y
+CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# EAP-MSCHAPv2 for the integrated EAP server
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-PEAP for the integrated EAP server
+CONFIG_EAP_PEAP=y
+
+# EAP-GTC for the integrated EAP server
+CONFIG_EAP_GTC=y
+
+# EAP-TTLS for the integrated EAP server
+CONFIG_EAP_TTLS=y
+
+# EAP-SIM for the integrated EAP server
+#CONFIG_EAP_SIM=y
+
+# EAP-AKA for the integrated EAP server
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' for the integrated EAP server
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# EAP-PAX for the integrated EAP server
+#CONFIG_EAP_PAX=y
+
+# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-SAKE for the integrated EAP server
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK for the integrated EAP server
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-FAST for the integrated EAP server
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+# Enable UPnP support for external WPS Registrars
+CONFIG_WPS_UPNP=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# Trusted Network Connect (EAP-TNC)
+#CONFIG_EAP_TNC=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# RADIUS authentication server. This provides access to the integrated EAP
+# server from external hosts using RADIUS.
+#CONFIG_RADIUS_SERVER=y
+
+# Build IPv6 support for RADIUS operations
+CONFIG_IPV6=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Use the hostapd's IEEE 802.11 authentication (ACL), but without
+# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
+#CONFIG_DRIVER_RADIUS_ACL=y
+
+# IEEE 802.11n (High Throughput) support
+#CONFIG_IEEE80211N=y
+
+# Remove debugging code that is printing out debug messages to stdout.
+# This can be used to reduce the size of the hostapd considerably if debugging
+# code is not needed.
+#CONFIG_NO_STDOUT_DEBUG=y
diff -Nur hostap-06-d23bf71/hostapd/config.c hostap06/hostapd/config.c
--- hostap-06-d23bf71/hostapd/config.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/config.c	2009-05-22 14:31:10.000000000 +0300
@@ -201,15 +201,15 @@
 	struct hostapd_config *conf;
 	struct hostapd_bss_config *bss;
 	int i;
-	const int aCWmin = 4, aCWmax = 10;
-	const struct hostapd_wmm_ac_params ac_bk =
+	const int aCWmin = 15, aCWmax = 1024;
+	const struct hostapd_wme_ac_params ac_bk =
 		{ aCWmin, aCWmax, 7, 0, 0 }; /* background traffic */
-	const struct hostapd_wmm_ac_params ac_be =
+	const struct hostapd_wme_ac_params ac_be =
 		{ aCWmin, aCWmax, 3, 0, 0 }; /* best effort traffic */
-	const struct hostapd_wmm_ac_params ac_vi = /* video traffic */
-		{ aCWmin - 1, aCWmin, 2, 3000 / 32, 1 };
-	const struct hostapd_wmm_ac_params ac_vo = /* voice traffic */
-		{ aCWmin - 2, aCWmin - 1, 2, 1500 / 32, 1 };
+	const struct hostapd_wme_ac_params ac_vi = /* video traffic */
+		{ aCWmin >> 1, aCWmin, 2, 3000 / 32, 1 };
+	const struct hostapd_wme_ac_params ac_vo = /* voice traffic */
+		{ aCWmin >> 2, aCWmin >> 1, 2, 1500 / 32, 1 };
 
 	conf = os_zalloc(sizeof(*conf));
 	bss = os_zalloc(sizeof(*bss));
@@ -251,10 +251,10 @@
 	for (i = 0; i < NUM_TX_QUEUES; i++)
 		conf->tx_queue[i].aifs = -1; /* use hw default */
 
-	conf->wmm_ac_params[0] = ac_be;
-	conf->wmm_ac_params[1] = ac_bk;
-	conf->wmm_ac_params[2] = ac_vi;
-	conf->wmm_ac_params[3] = ac_vo;
+	conf->wme_ac_params[0] = ac_be;
+	conf->wme_ac_params[1] = ac_bk;
+	conf->wme_ac_params[2] = ac_vi;
+	conf->wme_ac_params[3] = ac_vo;
 
 #ifdef CONFIG_IEEE80211N
 	conf->ht_capab = HT_CAP_INFO_SMPS_DISABLED;
@@ -1166,14 +1166,14 @@
 }
 
 
-static int hostapd_config_wmm_ac(struct hostapd_config *conf, char *name,
-				 char *val)
+static int hostapd_config_wme_ac(struct hostapd_config *conf, char *name,
+				   char *val)
 {
 	int num, v;
 	char *pos;
-	struct hostapd_wmm_ac_params *ac;
+	struct hostapd_wme_ac_params *ac;
 
-	/* skip 'wme_ac_' or 'wmm_ac_' prefix */
+	/* skip 'wme_ac_' prefix */
 	pos = name + 7;
 	if (os_strncmp(pos, "be_", 3) == 0) {
 		num = 0;
@@ -1188,11 +1188,11 @@
 		num = 3;
 		pos += 3;
 	} else {
-		wpa_printf(MSG_ERROR, "Unknown WMM name '%s'", pos);
+		wpa_printf(MSG_ERROR, "Unknown wme name '%s'", pos);
 		return -1;
 	}
 
-	ac = &conf->wmm_ac_params[num];
+	ac = &conf->wme_ac_params[num];
 
 	if (os_strcmp(pos, "aifs") == 0) {
 		v = atoi(val);
@@ -1221,7 +1221,7 @@
 			wpa_printf(MSG_ERROR, "Invalid txop value %d", v);
 			return -1;
 		}
-		ac->txop_limit = v;
+		ac->txopLimit = v;
 	} else if (os_strcmp(pos, "acm") == 0) {
 		v = atoi(val);
 		if (v < 0 || v > 1) {
@@ -1230,7 +1230,7 @@
 		}
 		ac->admission_control_mandatory = v;
 	} else {
-		wpa_printf(MSG_ERROR, "Unknown wmm_ac_ field '%s'", pos);
+		wpa_printf(MSG_ERROR, "Unknown wme_ac_ field '%s'", pos);
 		return -1;
 	}
 
@@ -2070,13 +2070,11 @@
 					   "queue item", line);
 				errors++;
 			}
-		} else if (os_strcmp(buf, "wme_enabled") == 0 ||
-			   os_strcmp(buf, "wmm_enabled") == 0) {
-			bss->wmm_enabled = atoi(pos);
-		} else if (os_strncmp(buf, "wme_ac_", 7) == 0 ||
-			   os_strncmp(buf, "wmm_ac_", 7) == 0) {
-			if (hostapd_config_wmm_ac(conf, buf, pos)) {
-				wpa_printf(MSG_ERROR, "Line %d: invalid WMM "
+		} else if (os_strcmp(buf, "wme_enabled") == 0) {
+			bss->wme_enabled = atoi(pos);
+		} else if (os_strncmp(buf, "wme_ac_", 7) == 0) {
+			if (hostapd_config_wme_ac(conf, buf, pos)) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid wme "
 					   "ac item", line);
 				errors++;
 			}
@@ -2479,8 +2477,6 @@
 	for (i = 0; i < conf->num_bss; i++)
 		hostapd_config_free_bss(&conf->bss[i]);
 	os_free(conf->bss);
-	os_free(conf->supported_rates);
-	os_free(conf->basic_rates);
 
 	os_free(conf);
 }
diff -Nur hostap-06-d23bf71/hostapd/config.h hostap06/hostapd/config.h
--- hostap-06-d23bf71/hostapd/config.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/config.h	2009-03-23 14:17:09.000000000 +0200
@@ -135,11 +135,11 @@
 	int configured;
 };
 
-struct hostapd_wmm_ac_params {
+struct hostapd_wme_ac_params {
 	int cwmin;
 	int cwmax;
 	int aifs;
-	int txop_limit; /* in units of 32us */
+	int txopLimit; /* in units of 32us */
 	int admission_control_mandatory;
 };
 
@@ -271,7 +271,7 @@
 	int ap_max_inactivity;
 	int ignore_broadcast_ssid;
 
-	int wmm_enabled;
+	int wme_enabled;
 
 	struct hostapd_vlan *vlan, *vlan_tail;
 
@@ -371,13 +371,13 @@
 	struct hostapd_tx_queue_params tx_queue[NUM_TX_QUEUES];
 
 	/*
-	 * WMM AC parameters, in same order as 802.1D, i.e.
+	 * WME AC parameters, in same order as 802.1D, i.e.
 	 * 0 = BE (best effort)
 	 * 1 = BK (background)
 	 * 2 = VI (video)
 	 * 3 = VO (voice)
 	 */
-	struct hostapd_wmm_ac_params wmm_ac_params[4];
+	struct hostapd_wme_ac_params wme_ac_params[4];
 
 	enum {
 		INTERNAL_BRIDGE_DO_NOT_CONTROL = -1,
diff -Nur hostap-06-d23bf71/hostapd/ctrl_iface.c hostap06/hostapd/ctrl_iface.c
--- hostap-06-d23bf71/hostapd/ctrl_iface.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/ctrl_iface.c	2009-03-23 14:17:09.000000000 +0200
@@ -253,21 +253,10 @@
 static int hostapd_ctrl_iface_wps_pin(struct hostapd_data *hapd, char *txt)
 {
 	char *pin = os_strchr(txt, ' ');
-	char *timeout_txt;
-	int timeout;
-
 	if (pin == NULL)
 		return -1;
 	*pin++ = '\0';
-
-	timeout_txt = os_strchr(pin, ' ');
-	if (timeout_txt) {
-		*timeout_txt++ = '\0';
-		timeout = atoi(timeout_txt);
-	} else
-		timeout = 0;
-
-	return hostapd_wps_add_pin(hapd, txt, pin, timeout);
+	return hostapd_wps_add_pin(hapd, txt, pin);
 }
 #endif /* CONFIG_WPS */
 
@@ -461,35 +450,8 @@
 		goto fail;
 	os_strlcpy(addr.sun_path, fname, sizeof(addr.sun_path));
 	if (bind(s, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		wpa_printf(MSG_DEBUG, "ctrl_iface bind(PF_UNIX) failed: %s",
-			   strerror(errno));
-		if (connect(s, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-			wpa_printf(MSG_DEBUG, "ctrl_iface exists, but does not"
-				   " allow connections - assuming it was left"
-				   "over from forced program termination");
-			if (unlink(fname) < 0) {
-				perror("unlink[ctrl_iface]");
-				wpa_printf(MSG_ERROR, "Could not unlink "
-					   "existing ctrl_iface socket '%s'",
-					   fname);
-				goto fail;
-			}
-			if (bind(s, (struct sockaddr *) &addr, sizeof(addr)) <
-			    0) {
-				perror("bind(PF_UNIX)");
-				goto fail;
-			}
-			wpa_printf(MSG_DEBUG, "Successfully replaced leftover "
-				   "ctrl_iface socket '%s'", fname);
-		} else {
-			wpa_printf(MSG_INFO, "ctrl_iface exists and seems to "
-				   "be in use - cannot override it");
-			wpa_printf(MSG_INFO, "Delete '%s' manually if it is "
-				   "not used anymore", fname);
-			os_free(fname);
-			fname = NULL;
-			goto fail;
-		}
+		perror("bind(PF_UNIX)");
+		goto fail;
 	}
 
 	if (hapd->conf->ctrl_interface_gid_set &&
diff -Nur hostap-06-d23bf71/hostapd/defconfig hostap06/hostapd/defconfig
--- hostap-06-d23bf71/hostapd/defconfig	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/defconfig	2009-03-23 14:24:51.000000000 +0200
@@ -36,6 +36,9 @@
 #CFLAGS += -I/usr/local/include
 #LIBS += -L/usr/local/lib
 
+# Driver interface for Metalink WLANPlus driver
+#CONFIG_DRIVER_MTLK=y
+
 # Driver interface for no driver (e.g., RADIUS server only)
 #CONFIG_DRIVER_NONE=y
 
diff -Nur hostap-06-d23bf71/hostapd/driver_mtlk.c hostap06/hostapd/driver_mtlk.c
--- hostap-06-d23bf71/hostapd/driver_mtlk.c	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/hostapd/driver_mtlk.c	2009-09-10 16:03:43.000000000 +0300
@@ -0,0 +1,998 @@
+/*
+ * hostapd / Driver interaction with Metalink WLANPlus 802.11n driver
+ * Copyright (c) 2006-2008 Metalink Broadband (Israel)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <net/if_arp.h>
+#include "wireless_copy.h"
+
+#include <netinet/in.h>
+#include <netpacket/packet.h>
+
+#include "hostapd.h"
+#include "driver.h"
+#include "ieee802_1x.h"
+#include "eloop.h"
+#include "priv_netlink.h"
+#include "sta_info.h"
+#include "l2_packet/l2_packet.h"
+#include "hostap_common.h"
+
+#include "eapol_sm.h"
+#include "wpa.h"
+#include "radius/radius.h"
+#include "ieee802_11.h"
+#include "accounting.h"
+#include "common.h"
+
+enum ietypes {
+	IE_WSC_BEACON     = 0,
+	IE_WSC_PROBE_REQ  = 1,
+	IE_WSC_PROBE_RESP = 2
+};
+
+struct mtlk_driver_data {
+	struct hostapd_data *hapd;		/* back pointer */
+
+	char	iface[IFNAMSIZ + 1];
+	int     ifindex;
+	struct l2_packet_data *sock_xmit;	/* raw packet xmit socket */
+	struct l2_packet_data *sock_recv;	/* raw packet recv socket */
+	int	ioctl_sock;			/* socket for ioctl() use */
+	int	wext_sock;			/* socket for wireless events */
+	int	we_version;
+	u8	acct_mac[ETH_ALEN];
+	struct hostap_sta_driver_data acct_data;
+};
+
+static const char *
+ether_sprintf(const u8 *addr)
+{
+	static char buf[sizeof(MACSTR)];
+
+	if (addr != NULL)
+		snprintf(buf, sizeof(buf), MACSTR, MAC2STR(addr));
+	else
+		snprintf(buf, sizeof(buf), MACSTR, 0,0,0,0,0,0);
+	return buf;
+}
+
+static int
+mtlk_set_iface_flags(void *priv, int dev_up)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct ifreq ifr;
+
+	wpa_printf(MSG_DEBUG, "%s: dev_up=%d", __func__, dev_up);
+
+	if (drv->ioctl_sock < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	snprintf(ifr.ifr_name, IFNAMSIZ, "%s", drv->iface);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, &ifr) != 0) {
+		perror("ioctl[SIOCGIFFLAGS]");
+		return -1;
+	}
+
+	if (dev_up)
+		ifr.ifr_flags |= IFF_UP;
+	else
+		ifr.ifr_flags &= ~IFF_UP;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIFFLAGS, &ifr) != 0) {
+		perror("ioctl[SIOCSIFFLAGS]");
+		return -1;
+	}
+
+	if (dev_up) {
+		memset(&ifr, 0, sizeof(ifr));
+		snprintf(ifr.ifr_name, IFNAMSIZ, "%s", drv->iface);
+		ifr.ifr_mtu = HOSTAPD_MTU;
+		if (ioctl(drv->ioctl_sock, SIOCSIFMTU, &ifr) != 0) {
+			perror("ioctl[SIOCSIFMTU]");
+			printf("Setting MTU failed - trying to survive with "
+			       "current value\n");
+		}
+	}
+
+	return 0;
+}
+
+static int
+mtlk_set_encryption(const char *ifname, void *priv, const char *alg,
+	     const u8 *addr, int key_idx,
+	     const u8 *key, size_t key_len, int txkey)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	struct iw_encode_ext *ext;
+	int ret=0;
+
+	wpa_printf(MSG_DEBUG,
+		"%s: alg=%s addr=%s key_idx=%d txkey=%d",
+		__func__, alg, ether_sprintf(addr), key_idx, txkey);
+
+	ext = malloc(sizeof(*ext) + key_len);
+	if (ext == NULL)
+		return -1;
+	memset(ext, 0, sizeof(*ext) + key_len);
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.encoding.flags = key_idx + 1;
+	iwr.u.encoding.pointer = (caddr_t) ext;
+	iwr.u.encoding.length = sizeof(*ext) + key_len;
+
+	if (addr == NULL ||
+	    memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
+		ext->ext_flags |= IW_ENCODE_EXT_GROUP_KEY;
+	if (txkey)
+		ext->ext_flags |= IW_ENCODE_EXT_SET_TX_KEY;
+	
+	ext->addr.sa_family = ARPHRD_ETHER;
+	if (addr)
+		memcpy(ext->addr.sa_data, addr, ETH_ALEN);
+	else
+		memset(ext->addr.sa_data, 0xff, ETH_ALEN);
+	if (key && key_len) {
+		memcpy(ext + 1, key, key_len);
+		ext->key_len = key_len;
+	}
+
+	if (strcmp(alg, "none") == 0)
+		ext->alg = IW_ENCODE_ALG_NONE;
+	else if (strcmp(alg, "WEP") == 0)
+		ext->alg = IW_ENCODE_ALG_WEP;
+	else if (strcmp(alg, "TKIP") == 0)
+		ext->alg = IW_ENCODE_ALG_TKIP;
+	else if (strcmp(alg, "CCMP") == 0)
+		ext->alg = IW_ENCODE_ALG_CCMP;
+	else {
+		printf("%s: unknown/unsupported algorithm %s\n",
+			__func__, alg);
+		return -1;
+	}
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWENCODEEXT, &iwr) < 0) {
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+		perror("ioctl[SIOCSIWENCODEEXT]");
+	}
+
+	free(ext);
+	return ret;
+}
+
+
+static int
+mtlk_get_seqnum(const char *ifname, void *priv, const u8 *addr, int idx, u8 *seq)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	struct iw_encode_ext *ext;
+	int ret=0;
+
+	wpa_printf(MSG_DEBUG,
+		"%s: addr=%s idx=%d", __func__, ether_sprintf(addr), idx);
+
+	ext = malloc(sizeof(*ext));
+	if (ext == NULL)
+		return -1;
+	memset(ext, 0, sizeof(*ext));
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.encoding.pointer = (caddr_t) ext;
+	iwr.u.encoding.length = sizeof(*ext);
+
+	if (addr == NULL ||
+	    memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
+		iwr.u.encoding.flags |= IW_ENCODE_EXT_GROUP_KEY;
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWENCODEEXT, &iwr) < 0) {
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+		perror("ioctl[SIOCGIWENCODEEXT]");
+		goto err;
+	}
+
+	memcpy(seq, ext->rx_seq, 6);
+err:
+	free(ext);
+	return ret;
+}
+
+
+static int 
+mtlk_flush(void *priv)
+{
+	return 0;		/* XXX */
+}
+
+
+
+static int
+mtlk_sta_clear_stats(void *priv, const u8 *addr)
+{
+	return 0; /* FIX */
+}
+
+
+static int
+mtlk_set_generic_elem(const char *ifname, void *priv, const u8 *ie, size_t ie_len)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) ie;
+	iwr.u.data.length = ie_len;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int
+mtlk_mlme(struct mtlk_driver_data *drv,
+	const u8 *addr, int cmd, int reason_code)
+{
+	struct iwreq iwr;
+	struct iw_mlme mlme;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	memset(&mlme, 0, sizeof(mlme));
+	mlme.cmd = cmd;
+	mlme.reason_code = reason_code;
+	mlme.addr.sa_family = ARPHRD_ETHER;
+	memcpy(mlme.addr.sa_data, addr, ETH_ALEN);
+	iwr.u.data.pointer = (caddr_t) &mlme;
+	iwr.u.data.length = sizeof(mlme);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMLME, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMLME]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int
+mtlk_sta_deauth(void *priv, const u8 *addr, int reason_code)
+{
+	struct mtlk_driver_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return mtlk_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
+}
+
+static int
+mtlk_sta_disassoc(void *priv, const u8 *addr, int reason_code)
+{
+	struct mtlk_driver_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return mtlk_mlme(drv, addr, IW_MLME_DISASSOC, reason_code);
+}
+
+static int
+mtlk_del_sta(struct mtlk_driver_data *drv, u8 *addr)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	struct sta_info *sta;
+
+	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
+		HOSTAPD_LEVEL_INFO, "disassociated");
+
+	sta = ap_get_sta(hapd, addr);
+	if (sta != NULL) {
+		sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+		//wpa_sm_event(hapd, sta, WPA_DISASSOC);
+        wpa_auth_sm_event(sta->wpa_sm, WPA_DISASSOC);
+		sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+		ap_free_sta(hapd, sta);
+	}
+	return 0;
+}
+
+static int
+mtlk_process_wpa_ie(struct mtlk_driver_data *drv, struct sta_info *sta,
+			u8 *rsnie)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	int ielen, res;
+
+	ielen = rsnie[1] +2;
+
+	if (sta->wpa_sm == NULL)
+		sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth, sta->addr);
+	if (sta->wpa_sm == NULL) {
+		printf("Failed to initialize WPA state machine\n");
+		return -1;
+	}
+
+	res = wpa_validate_wpa_ie(hapd->wpa_auth, sta->wpa_sm, rsnie, ielen,
+					NULL, 0);
+	if (res != WPA_IE_OK) {
+		printf("WPA/RSN information element rejected? (res %u)\n", res);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+mtlk_new_sta(struct mtlk_driver_data *drv, u8 *addr, u8 *rsnie)
+{
+	struct hostapd_data *hapd = drv->hapd;
+	struct sta_info *sta;
+	int new_assoc;
+
+	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
+		HOSTAPD_LEVEL_INFO, "associated");
+
+	sta = ap_get_sta(hapd, addr);
+	if (sta) {
+		accounting_sta_stop(hapd, sta);
+	} else {
+		sta = ap_sta_add(hapd, addr);
+		if (sta == NULL)
+			return -1;
+	}
+
+	if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
+		/* Cached accounting data is not valid anymore. */
+		memset(drv->acct_mac, 0, ETH_ALEN);
+		memset(&drv->acct_data, 0, sizeof(drv->acct_data));
+	}
+
+	if (hapd->conf->wpa && rsnie) {
+		if (mtlk_process_wpa_ie(drv, sta, rsnie))
+			return -1;
+	}
+
+#ifdef CONFIG_WPS
+	if (hapd->conf->wps_state && !rsnie) {
+		wpa_printf(MSG_DEBUG, "STA did not include WPA/RSN IE "
+			   "in (Re)Association Request - possible WPS use");
+		sta->flags |= WLAN_STA_MAYBE_WPS;
+	}
+#endif /* CONFIG_WPS */
+
+
+	/*
+	 * Now that the internal station state is setup
+	 * kick the authenticator into action.
+	 */
+	new_assoc = (sta->flags & WLAN_STA_ASSOC) == 0;
+	sta->flags |= WLAN_STA_AUTH | WLAN_STA_ASSOC;
+	wpa_auth_sm_event(sta->wpa_sm, WPA_ASSOC);
+	hostapd_new_assoc_sta(hapd, sta, !new_assoc);
+	ieee802_1x_notify_port_enabled(sta->eapol_sm, 1);
+	return 0;
+}
+
+static int
+mtlk_wireless_michaelmicfailure(struct mtlk_driver_data *drv,
+				const char *ev, int len)
+{
+	const struct iw_michaelmicfailure *mic;
+	u8 *addr;
+
+	if (len < sizeof(*mic)) {
+		wpa_printf(MSG_DEBUG,
+			"Invalid MIC Failure data from driver");
+		return -1;
+	}
+
+	mic = (const struct iw_michaelmicfailure *) ev;
+
+	addr = (u8*) mic->src_addr.sa_data;
+	wpa_printf(MSG_DEBUG,
+		"Michael MIC failure wireless event: "
+		"flags=0x%x src_addr=" MACSTR, mic->flags, MAC2STR(addr));
+
+	ieee80211_michael_mic_failure(drv->hapd, addr, 1);
+
+	return 0;
+}
+
+static void
+mtlk_wireless_event_wireless_custom(struct mtlk_driver_data *drv,
+				       char *custom)
+{
+	const char newsta_tag[] = "NEWSTA ";
+	const char rsnie_tag[]  = "RSNIE_LEN ";
+
+	wpa_printf(MSG_DEBUG, "Custom wireless event: '%s'",
+		      custom);
+
+	if (strncmp(custom, newsta_tag, strlen(newsta_tag)) == 0) {
+		char *pos = custom;
+		u8 addr[ETH_ALEN];
+		u8 *rsnie, ielen;
+		pos += strlen(newsta_tag);
+		if (hwaddr_aton(pos, addr) != 0) {
+			wpa_printf(MSG_DEBUG,
+				"NEWSTA with invalid MAC address");
+			return;
+		}
+		pos = strstr(pos, rsnie_tag);
+		pos += strlen(rsnie_tag);
+		ielen = atoi(pos);
+		if (!ielen) {
+			wpa_printf(MSG_DEBUG,
+				"NEWSTA with zero RSNIE length?");
+			return;
+		}
+		rsnie = malloc(ielen);
+		if (!rsnie) {
+			printf("ERROR: can't allocate buffer "
+				"of %i bytes for RSNIE", ielen);
+			return;
+		}
+		pos = strstr(pos, " : ");
+		pos += 3;
+		hexstr2bin(pos, rsnie, ielen);
+		mtlk_new_sta(drv, addr, rsnie);
+		free(rsnie);
+	} else
+	if (strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
+		char *pos;
+		u8 addr[ETH_ALEN];
+		pos = strstr(custom, "addr=");
+		if (pos == NULL) {
+			wpa_printf(MSG_DEBUG,
+				      "MLME-MICHAELMICFAILURE.indication "
+				      "without sender address ignored");
+			return;
+		}
+		pos += 5;
+		if (hwaddr_aton(pos, addr) == 0) {
+			ieee80211_michael_mic_failure(drv->hapd, addr, 1);
+		} else {
+			wpa_printf(MSG_DEBUG,
+				      "MLME-MICHAELMICFAILURE.indication "
+				      "with invalid MAC address");
+		}
+	} else if (strncmp(custom, "STA-TRAFFIC-STAT", 16) == 0) {
+		char *key, *value;
+		u32 val;
+		key = custom;
+		while ((key = strchr(key, '\n')) != NULL) {
+			key++;
+			value = strchr(key, '=');
+			if (value == NULL)
+				continue;
+			*value++ = '\0';
+			val = strtoul(value, NULL, 10);
+			if (strcmp(key, "mac") == 0)
+				hwaddr_aton(value, drv->acct_mac);
+			else if (strcmp(key, "rx_packets") == 0)
+				drv->acct_data.rx_packets = val;
+			else if (strcmp(key, "tx_packets") == 0)
+				drv->acct_data.tx_packets = val;
+			else if (strcmp(key, "rx_bytes") == 0)
+				drv->acct_data.rx_bytes = val;
+			else if (strcmp(key, "tx_bytes") == 0)
+				drv->acct_data.tx_bytes = val;
+			key = value;
+		}
+	}
+}
+
+static void
+mtlk_wireless_event_wireless(struct mtlk_driver_data *drv,
+					    char *data, int len)
+{
+	struct iw_event iwe_buf, *iwe = &iwe_buf;
+	char *pos, *end, *custom, *buf;
+
+	pos = data;
+	end = data + len;
+
+	while (pos + IW_EV_LCP_LEN <= end) {
+		/* Event data may be unaligned, so make a local, aligned copy
+		 * before processing. */
+		memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
+		wpa_printf(MSG_DEBUG, "Wireless event: "
+			      "cmd=0x%x len=%d", iwe->cmd, iwe->len);
+		if (iwe->len <= IW_EV_LCP_LEN)
+			return;
+
+		custom = pos + IW_EV_POINT_LEN;
+		iwe->u.data.pointer = custom;
+		if (drv->we_version > 18 &&
+		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
+		     iwe->cmd == IWEVCUSTOM)) {
+			/* WE-19 removed the pointer from struct iw_point */
+			char *dpos = (char *) &iwe_buf.u.data.length;
+			int dlen = dpos - (char *) &iwe_buf;
+			memcpy(dpos, pos + IW_EV_LCP_LEN,
+			       sizeof(struct iw_event) - dlen);
+		} else {
+			memcpy(&iwe_buf, pos, sizeof(struct iw_event));
+			custom += IW_EV_POINT_OFF;
+		}
+
+		switch (iwe->cmd) {
+		case IWEVEXPIRED:
+			mtlk_del_sta(drv, (u8 *) iwe->u.addr.sa_data);
+			break;
+		case IWEVREGISTERED:
+			mtlk_new_sta(drv, (u8 *) iwe->u.addr.sa_data, NULL);
+			break;
+		case IWEVMICHAELMICFAILURE:
+			mtlk_wireless_michaelmicfailure(drv, custom,
+							iwe->u.data.length);
+			break;
+		case IWEVCUSTOM:
+			if (custom + iwe->u.data.length > end)
+				return;
+			buf = malloc(iwe->u.data.length + 1);
+			if (buf == NULL)
+				return;		/* XXX */
+			memcpy(buf, custom, iwe->u.data.length);
+			buf[iwe->u.data.length] = '\0';
+			mtlk_wireless_event_wireless_custom(drv, buf);
+			free(buf);
+			break;
+		}
+
+		pos += iwe->len;
+	}
+}
+
+
+static void
+mtlk_wireless_event_rtm_newlink(struct mtlk_driver_data *drv,
+					       struct nlmsghdr *h, int len)
+{
+	struct ifinfomsg *ifi;
+	int attrlen, nlmsg_len, rta_len;
+	struct rtattr * attr;
+
+	if (len < sizeof(*ifi))
+		return;
+
+	ifi = NLMSG_DATA(h);
+
+	if (ifi->ifi_index != drv->ifindex)
+		return;
+
+	nlmsg_len = NLMSG_ALIGN(sizeof(struct ifinfomsg));
+
+	attrlen = h->nlmsg_len - nlmsg_len;
+	if (attrlen < 0)
+		return;
+
+	attr = (struct rtattr *) (((char *) ifi) + nlmsg_len);
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_WIRELESS) {
+			mtlk_wireless_event_wireless(
+				drv, ((char *) attr) + rta_len,
+				attr->rta_len - rta_len);
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+}
+
+
+static void
+mtlk_wireless_event_receive(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	char buf[256];
+	int left;
+	struct sockaddr_nl from;
+	socklen_t fromlen;
+	struct nlmsghdr *h;
+	struct mtlk_driver_data *drv = eloop_ctx;
+
+	fromlen = sizeof(from);
+	left = recvfrom(sock, buf, sizeof(buf), MSG_DONTWAIT,
+			(struct sockaddr *) &from, &fromlen);
+	if (left < 0) {
+		if (errno != EINTR && errno != EAGAIN)
+			perror("recvfrom(netlink)");
+		return;
+	}
+
+	h = (struct nlmsghdr *) buf;
+	while (left >= sizeof(*h)) {
+		int len, plen;
+
+		len = h->nlmsg_len;
+		plen = len - sizeof(*h);
+		if (len > left || plen < 0) {
+			printf("Malformed netlink message: "
+			       "len=%d left=%d plen=%d\n",
+			       len, left, plen);
+			break;
+		}
+
+		switch (h->nlmsg_type) {
+		case RTM_NEWLINK:
+			mtlk_wireless_event_rtm_newlink(drv, h, plen);
+			break;
+		}
+
+		len = NLMSG_ALIGN(len);
+		left -= len;
+		h = (struct nlmsghdr *) ((char *) h + len);
+	}
+
+	if (left > 0) {
+		printf("%d extra bytes in the end of netlink message\n", left);
+	}
+}
+
+
+static int
+mtlk_get_we_version(struct mtlk_driver_data *drv)
+{
+	struct iw_range *range;
+	struct iwreq iwr;
+	int minlen;
+	size_t buflen;
+
+	drv->we_version = 0;
+
+	/*
+	 * Use larger buffer than struct iw_range in order to allow the
+	 * structure to grow in the future.
+	 */
+	buflen = sizeof(struct iw_range) + 500;
+	range = malloc(buflen);
+	if (range == NULL)
+		return -1;
+	memset(range, 0, buflen);
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) range;
+	iwr.u.data.length = buflen;
+
+	minlen = ((char *) &range->enc_capa) - (char *) range +
+		sizeof(range->enc_capa);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWRANGE]");
+		free(range);
+		return -1;
+	} else if (iwr.u.data.length >= minlen &&
+		   range->we_version_compiled >= 18) {
+		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
+			   "WE(source)=%d enc_capa=0x%x",
+			   range->we_version_compiled,
+			   range->we_version_source,
+			   range->enc_capa);
+		drv->we_version = range->we_version_compiled;
+	}
+
+	free(range);
+	return 0;
+}
+
+
+static int
+mtlk_wireless_event_init(void *priv)
+{
+	struct mtlk_driver_data *drv = priv;
+	int s;
+	struct sockaddr_nl local;
+
+	mtlk_get_we_version(drv);
+
+	drv->wext_sock = -1;
+
+	s = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+	if (s < 0) {
+		perror("socket(PF_NETLINK,SOCK_RAW,NETLINK_ROUTE)");
+		return -1;
+	}
+
+	memset(&local, 0, sizeof(local));
+	local.nl_family = AF_NETLINK;
+	local.nl_groups = RTMGRP_LINK;
+	if (bind(s, (struct sockaddr *) &local, sizeof(local)) < 0) {
+		perror("bind(netlink)");
+		close(s);
+		return -1;
+	}
+
+	eloop_register_read_sock(s, mtlk_wireless_event_receive, drv, NULL);
+	drv->wext_sock = s;
+
+	return 0;
+}
+
+
+static void
+mtlk_wireless_event_deinit(void *priv)
+{
+	struct mtlk_driver_data *drv = priv;
+
+	if (drv != NULL) {
+		if (drv->wext_sock < 0)
+			return;
+		eloop_unregister_read_sock(drv->wext_sock);
+		close(drv->wext_sock);
+	}
+}
+
+
+static int
+mtlk_send_eapol(void *priv, const u8 *addr, const u8 *data, size_t data_len,
+        int encrypt, const u8 *own_addr)
+{
+	struct mtlk_driver_data *drv = priv;
+	unsigned char buf[3000];
+	unsigned char *bp = buf;
+	struct l2_ethhdr *eth;
+	size_t len;
+	int status;
+
+	/*
+	 * Prepend the Ethernet header.  If the caller left us
+	 * space at the front we could just insert it but since
+	 * we don't know we copy to a local buffer.  Given the frequency
+	 * and size of frames this probably doesn't matter.
+	 */
+	len = data_len + sizeof(struct l2_ethhdr);
+	if (len > sizeof(buf)) {
+		bp = malloc(len);
+		if (bp == NULL) {
+			printf("EAPOL frame discarded, cannot malloc temp "
+			       "buffer of size %lu!\n", (unsigned long) len);
+			return -1;
+		}
+	}
+	eth = (struct l2_ethhdr *) bp;
+	memcpy(eth->h_dest, addr, ETH_ALEN);
+	memcpy(eth->h_source, drv->hapd->own_addr, ETH_ALEN);
+	eth->h_proto = htons(ETH_P_EAPOL);
+	memcpy(eth+1, data, data_len);
+
+	status = l2_packet_send(drv->sock_xmit, addr, ETH_P_EAPOL, bp, len);
+
+	if (bp != buf)
+		free(bp);
+	return status;
+}
+
+static void
+handle_read(void *ctx, const u8 *src_addr, const u8 *buf, size_t len)
+{
+	struct mtlk_driver_data *drv = ctx;
+	struct hostapd_data *hapd = drv->hapd;
+	struct sta_info *sta;
+
+	sta = ap_get_sta(hapd, src_addr);
+	if (!sta || !(sta->flags & WLAN_STA_ASSOC)) {
+		printf("Data frame from not associated STA %s\n",
+		       ether_sprintf(src_addr));
+		/* XXX cannot happen */
+		return;
+	}
+	ieee802_1x_receive(hapd, src_addr, buf + sizeof(struct l2_ethhdr),
+			   len - sizeof(struct l2_ethhdr));
+}
+
+static void *
+mtlk_init(struct hostapd_data *hapd)
+{
+	struct mtlk_driver_data *drv;
+	struct ifreq ifr;
+	struct iwreq iwr;
+
+	drv = os_zalloc(sizeof(struct mtlk_driver_data));
+	if (drv == NULL) {
+		printf("Could not allocate memory for mtlk driver data\n");
+		goto bad;
+	}
+
+	drv->hapd = hapd;
+	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (drv->ioctl_sock < 0) {
+		perror("socket[PF_INET,SOCK_DGRAM]");
+		goto bad;
+	}
+	memcpy(drv->iface, hapd->conf->iface, sizeof(drv->iface));
+
+	memset(&ifr, 0, sizeof(ifr));
+	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", drv->iface);
+	if (ioctl(drv->ioctl_sock, SIOCGIFINDEX, &ifr) != 0) {
+		perror("ioctl(SIOCGIFINDEX)");
+		goto bad;
+	}
+	drv->ifindex = ifr.ifr_ifindex;
+
+	drv->sock_xmit = l2_packet_init(drv->iface, NULL, ETH_P_EAPOL,
+					handle_read, drv, 1);
+	if (drv->sock_xmit == NULL)
+		goto bad;
+	if (l2_packet_get_own_addr(drv->sock_xmit, hapd->own_addr))
+		goto bad;
+	if (hapd->conf->bridge[0] != '\0') {
+		wpa_printf(MSG_DEBUG,
+			"Configure bridge %s for EAPOL traffic.",
+			hapd->conf->bridge);
+		drv->sock_recv = l2_packet_init(hapd->conf->bridge, NULL,
+						ETH_P_EAPOL, handle_read, drv,
+						1);
+		if (drv->sock_recv == NULL)
+			goto bad;
+	} else
+		drv->sock_recv = drv->sock_xmit;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+
+	iwr.u.mode = IW_MODE_MASTER;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMODE]");
+		printf("Could not set interface to master mode!\n");
+		goto bad;
+	}
+
+	mtlk_set_iface_flags(drv, 0);	/* mark down during setup */
+
+	return drv;
+bad:
+	if (drv->sock_xmit != NULL)
+		l2_packet_deinit(drv->sock_xmit);
+	if (drv->ioctl_sock >= 0)
+		close(drv->ioctl_sock);
+	if (drv != NULL)
+		free(drv);
+	return NULL;
+}
+
+
+static void
+mtlk_deinit(void *priv)
+{
+	struct mtlk_driver_data *drv = priv;
+
+	drv->hapd->driver = NULL;
+
+	(void) mtlk_set_iface_flags(drv, 0);
+	if (drv->ioctl_sock >= 0)
+		close(drv->ioctl_sock);
+	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
+		l2_packet_deinit(drv->sock_recv);
+	if (drv->sock_xmit != NULL)
+		l2_packet_deinit(drv->sock_xmit);
+	free(drv);
+}
+
+static int
+mtlk_set_ssid(const char *ifname, void *priv, const u8 *buf, int len)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.essid.flags = 1; /* SSID active */
+	iwr.u.essid.pointer = (caddr_t) buf;
+	iwr.u.essid.length = len + 1;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCSIWESSID]");
+		printf("len=%d\n", len);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+mtlk_get_ssid(const char *ifname, void *priv, u8 *buf, int len)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.essid.pointer = (caddr_t) buf;
+	iwr.u.essid.length = len;
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCGIWESSID]");
+		ret = -1;
+	} else
+		ret = iwr.u.essid.length;
+
+	return ret;
+}
+
+static int
+mtlk_commit(void *priv)
+{
+	return mtlk_set_iface_flags(priv, 1);
+}
+
+#ifdef CONFIG_WPS
+static int
+mtlk_set_wps_ie(void *priv, const u8 *ie, size_t ie_len, u16 ie_type)
+{
+	struct mtlk_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) ie;
+	iwr.u.data.length = ie_len;
+	iwr.u.data.flags = ie_type;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int
+mtlk_set_wps_beacon_ie(const char *ifname, void *priv, const u8 *iebuf,
+			size_t iebuflen)
+{
+	return mtlk_set_wps_ie(priv, iebuf, iebuflen, IE_WSC_BEACON);
+}
+
+static int
+mtlk_set_wps_probe_resp_ie(const char *ifname, void *priv, const u8 *iebuf,
+				size_t iebuflen)
+{
+	return mtlk_set_wps_ie(priv, iebuf, iebuflen, IE_WSC_PROBE_RESP);
+}
+#endif
+
+const struct wpa_driver_ops wpa_driver_mtlk_ops = {
+	.name			= "mtlk",
+	.init			= mtlk_init,
+	.deinit			= mtlk_deinit,
+	.set_encryption		= mtlk_set_encryption,
+	.get_seqnum		= mtlk_get_seqnum,
+	.flush			= mtlk_flush,
+	.set_generic_elem	= mtlk_set_generic_elem,
+	.wireless_event_init	= mtlk_wireless_event_init,
+	.wireless_event_deinit	= mtlk_wireless_event_deinit,
+	.send_eapol		= mtlk_send_eapol,
+	.sta_disassoc		= mtlk_sta_disassoc,
+	.sta_deauth		= mtlk_sta_deauth,
+	.set_ssid		= mtlk_set_ssid,
+	.get_ssid		= mtlk_get_ssid,
+	.sta_clear_stats        = mtlk_sta_clear_stats,
+	.commit			= mtlk_commit,
+#ifdef CONFIG_WPS
+	.set_wps_beacon_ie      = mtlk_set_wps_beacon_ie,
+	.set_wps_probe_resp_ie  = mtlk_set_wps_probe_resp_ie,
+#endif
+};
diff -Nur hostap-06-d23bf71/hostapd/driver_nl80211.c hostap06/hostapd/driver_nl80211.c
--- hostap-06-d23bf71/hostapd/driver_nl80211.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/driver_nl80211.c	2009-05-22 14:31:10.000000000 +0300
@@ -908,7 +908,7 @@
 	if (total_flags & WLAN_STA_AUTHORIZED || !drv->ieee802_1x_active)
 		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_AUTHORIZED);
 
-	if (total_flags & WLAN_STA_WMM)
+	if (total_flags & WLAN_STA_WME)
 		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_WME);
 
 	if (total_flags & WLAN_STA_SHORT_PREAMBLE)
diff -Nur hostap-06-d23bf71/hostapd/drivers.c hostap06/hostapd/drivers.c
--- hostap-06-d23bf71/hostapd/drivers.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/drivers.c	2009-03-23 14:24:51.000000000 +0200
@@ -36,6 +36,9 @@
 #ifdef CONFIG_DRIVER_WIRED
 extern struct wpa_driver_ops wpa_driver_wired_ops; /* driver_wired.c */
 #endif /* CONFIG_DRIVER_WIRED */
+#ifdef CONFIG_DRIVER_MTLK
+extern struct wpa_driver_ops wpa_driver_mtlk_ops; /* driver_mtlk.c */
+#endif /* CONFIG_DRIVER_MTLK */
 #ifdef CONFIG_DRIVER_TEST
 extern struct wpa_driver_ops wpa_driver_test_ops; /* driver_test.c */
 #endif /* CONFIG_DRIVER_TEST */
@@ -67,6 +70,9 @@
 #ifdef CONFIG_DRIVER_WIRED
 	&wpa_driver_wired_ops,
 #endif /* CONFIG_DRIVER_WIRED */
+#ifdef CONFIG_DRIVER_MTLK
+	&wpa_driver_mtlk_ops,
+#endif /* CONFIG_DRIVER_MTLK */
 #ifdef CONFIG_DRIVER_TEST
 	&wpa_driver_test_ops,
 #endif /* CONFIG_DRIVER_TEST */
diff -Nur hostap-06-d23bf71/hostapd/hostapd.c hostap06/hostapd/hostapd.c
--- hostap-06-d23bf71/hostapd/hostapd.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/hostapd.c	2009-05-22 14:31:10.000000000 +0300
@@ -249,7 +249,7 @@
 	if (!hapd->conf->ieee802_1x && !hapd->conf->wpa)
 		accounting_sta_start(hapd, sta);
 
-	hostapd_wmm_sta_config(hapd, sta);
+	hostapd_wme_sta_config(hapd, sta);
 
 	/* Start IEEE 802.1X authentication process for new stations */
 	ieee802_1x_new_station(hapd, sta);
@@ -306,7 +306,7 @@
 	wconf->rsn_preauth = conf->rsn_preauth;
 	wconf->eapol_version = conf->eapol_version;
 	wconf->peerkey = conf->peerkey;
-	wconf->wmm_enabled = conf->wmm_enabled;
+	wconf->wme_enabled = conf->wme_enabled;
 	wconf->okc = conf->okc;
 #ifdef CONFIG_IEEE80211W
 	wconf->ieee80211w = conf->ieee80211w;
@@ -477,7 +477,7 @@
 			(sta->flags & WLAN_STA_SHORT_PREAMBLE ?
 			 "[SHORT_PREAMBLE]" : ""),
 			(sta->flags & WLAN_STA_PREAUTH ? "[PREAUTH]" : ""),
-			(sta->flags & WLAN_STA_WMM ? "[WMM]" : ""),
+			(sta->flags & WLAN_STA_WME ? "[WME]" : ""),
 			(sta->flags & WLAN_STA_MFP ? "[MFP]" : ""),
 			(sta->flags & WLAN_STA_WPS ? "[WPS]" : ""),
 			(sta->flags & WLAN_STA_MAYBE_WPS ? "[MAYBE_WPS]" : ""),
@@ -1877,7 +1877,7 @@
 	int ret = 1, k;
 	size_t i, j;
 	int c, debug = 0, daemonize = 0, tnc = 0;
-	char *pid_file = NULL;
+	const char *pid_file = NULL;
 
 	hostapd_logger_register_cb(hostapd_logger_cb);
 
@@ -1901,8 +1901,7 @@
 			wpa_debug_show_keys++;
 			break;
 		case 'P':
-			os_free(pid_file);
-			pid_file = os_rel2abs_path(optarg);
+			pid_file = optarg;
 			break;
 		case 't':
 			wpa_debug_timestamp++;
@@ -2033,7 +2032,6 @@
 	eap_server_unregister_methods();
 
 	os_daemonize_terminate(pid_file);
-	os_free(pid_file);
 
 	return ret;
 }
diff -Nur hostap-06-d23bf71/hostapd/hostapd_cli.c hostap06/hostapd/hostapd_cli.c
--- hostap-06-d23bf71/hostapd/hostapd_cli.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/hostapd_cli.c	2009-03-23 14:17:09.000000000 +0200
@@ -87,7 +87,7 @@
 "   sa_query <addr>      send SA Query to a station\n"
 #endif /* CONFIG_IEEE80211W */
 #ifdef CONFIG_WPS
-"   wps_pin <uuid> <pin> [timeout]  add WPS Enrollee PIN (Device Password)\n"
+"   wps_pin <uuid> <pin> add WPS Enrollee PIN (Device Password)\n"
 "   wps_pbc              indicate button pushed to initiate PBC\n"
 #endif /* CONFIG_WPS */
 "   help                 show this usage help\n"
@@ -260,16 +260,12 @@
 				   char *argv[])
 {
 	char buf[64];
-	if (argc < 2) {
-		printf("Invalid 'wps_pin' command - at least two arguments, "
+	if (argc != 2) {
+		printf("Invalid 'wps_pin' command - exactly two arguments, "
 		       "UUID and PIN, are required.\n");
 		return -1;
 	}
-	if (argc > 2)
-		snprintf(buf, sizeof(buf), "WPS_PIN %s %s %s",
-			 argv[0], argv[1], argv[2]);
-	else
-		snprintf(buf, sizeof(buf), "WPS_PIN %s %s", argv[0], argv[1]);
+	snprintf(buf, sizeof(buf), "WPS_PIN %s %s", argv[0], argv[1]);
 	return wpa_ctrl_command(ctrl, buf);
 }
 
diff -Nur hostap-06-d23bf71/hostapd/hostapd.conf hostap06/hostapd/hostapd.conf
--- hostap-06-d23bf71/hostapd/hostapd.conf	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/hostapd.conf	2009-03-23 14:17:09.000000000 +0200
@@ -273,38 +273,38 @@
 # note - here cwMin and cmMax are in exponent form. the actual cw value used
 # will be (2^n)-1 where n is the value given here
 #
-wmm_enabled=1
+wme_enabled=1
 #
 # Low priority / AC_BK = background
-wmm_ac_bk_cwmin=4
-wmm_ac_bk_cwmax=10
-wmm_ac_bk_aifs=7
-wmm_ac_bk_txop_limit=0
-wmm_ac_bk_acm=0
+wme_ac_bk_cwmin=4
+wme_ac_bk_cwmax=10
+wme_ac_bk_aifs=7
+wme_ac_bk_txop_limit=0
+wme_ac_bk_acm=0
 # Note: for IEEE 802.11b mode: cWmin=5 cWmax=10
 #
 # Normal priority / AC_BE = best effort
-wmm_ac_be_aifs=3
-wmm_ac_be_cwmin=4
-wmm_ac_be_cwmax=10
-wmm_ac_be_txop_limit=0
-wmm_ac_be_acm=0
+wme_ac_be_aifs=3
+wme_ac_be_cwmin=4
+wme_ac_be_cwmax=10
+wme_ac_be_txop_limit=0
+wme_ac_be_acm=0
 # Note: for IEEE 802.11b mode: cWmin=5 cWmax=7
 #
 # High priority / AC_VI = video
-wmm_ac_vi_aifs=2
-wmm_ac_vi_cwmin=3
-wmm_ac_vi_cwmax=4
-wmm_ac_vi_txop_limit=94
-wmm_ac_vi_acm=0
+wme_ac_vi_aifs=2
+wme_ac_vi_cwmin=3
+wme_ac_vi_cwmax=4
+wme_ac_vi_txop_limit=94
+wme_ac_vi_acm=0
 # Note: for IEEE 802.11b mode: cWmin=4 cWmax=5 txop_limit=188
 #
 # Highest priority / AC_VO = voice
-wmm_ac_vo_aifs=2
-wmm_ac_vo_cwmin=2
-wmm_ac_vo_cwmax=3
-wmm_ac_vo_txop_limit=47
-wmm_ac_vo_acm=0
+wme_ac_vo_aifs=2
+wme_ac_vo_cwmin=2
+wme_ac_vo_cwmax=3
+wme_ac_vo_txop_limit=47
+wme_ac_vo_acm=0
 # Note: for IEEE 802.11b mode: cWmin=3 cWmax=4 burst=102
 
 # Static WEP key configuration
@@ -375,7 +375,6 @@
 # ieee80211n: Whether IEEE 802.11n (HT) is enabled
 # 0 = disabled (default)
 # 1 = enabled
-# Note: You will also need to enable WMM for full HT functionality.
 #ieee80211n=1
 
 # ht_capab: HT capabilities (list of flags)
diff -Nur hostap-06-d23bf71/hostapd/hw_features.c hostap06/hostapd/hw_features.c
--- hostap-06-d23bf71/hostapd/hw_features.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/hw_features.c	2009-03-23 14:17:09.000000000 +0200
@@ -382,13 +382,6 @@
 			break;
 		}
 	}
-	if (iface->conf->channel == 0) {
-		/* TODO: could request a scan of neighboring BSSes and select
-		 * the channel automatically */
-		wpa_printf(MSG_ERROR, "Channel not configured "
-			   "(hw_mode/channel in hostapd.conf)");
-		return -1;
-	}
 	if (ok == 0 && iface->conf->channel != 0) {
 		hostapd_logger(iface->bss[0], NULL,
 			       HOSTAPD_MODULE_IEEE80211,
diff -Nur hostap-06-d23bf71/hostapd/ieee802_11.c hostap06/hostapd/ieee802_11.c
--- hostap-06-d23bf71/hostapd/ieee802_11.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/ieee802_11.c	2009-03-23 14:17:09.000000000 +0200
@@ -384,8 +384,8 @@
 			r = random();
 			os_memcpy(key, &now, 4);
 			os_memcpy(key + 4, &r, 4);
-			rc4_skip(key, sizeof(key), 0,
-				 sta->challenge, WLAN_AUTH_CHALLENGE_LEN);
+			rc4(sta->challenge, WLAN_AUTH_CHALLENGE_LEN,
+			    key, sizeof(key));
 		}
 		return 0;
 	}
@@ -585,7 +585,7 @@
 
 	if (vlan_id > 0) {
 		if (hostapd_get_vlan_id_ifname(hapd->conf->vlan,
-					       vlan_id) == NULL) {
+					       sta->vlan_id) == NULL) {
 			hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_RADIUS,
 				       HOSTAPD_LEVEL_INFO, "Invalid VLAN ID "
 				       "%d received from RADIUS server",
@@ -766,16 +766,16 @@
 		goto fail;
 	}
 
-	sta->flags &= ~WLAN_STA_WMM;
-	if (elems.wmm && hapd->conf->wmm_enabled) {
-		if (hostapd_eid_wmm_valid(hapd, elems.wmm, elems.wmm_len))
+	sta->flags &= ~WLAN_STA_WME;
+	if (elems.wme && hapd->conf->wme_enabled) {
+		if (hostapd_eid_wme_valid(hapd, elems.wme, elems.wme_len))
 			hostapd_logger(hapd, sta->addr,
 				       HOSTAPD_MODULE_WPA,
 				       HOSTAPD_LEVEL_DEBUG,
-				       "invalid WMM element in association "
+				       "invalid WME element in association "
 				       "request");
 		else
-			sta->flags |= WLAN_STA_WMM;
+			sta->flags |= WLAN_STA_WME;
 	}
 
 	if (!elems.supp_rates) {
@@ -1124,8 +1124,8 @@
 		p = hostapd_eid_supp_rates(hapd, reply->u.assoc_resp.variable);
 		/* Extended supported rates */
 		p = hostapd_eid_ext_supp_rates(hapd, p);
-		if (sta->flags & WLAN_STA_WMM)
-			p = hostapd_eid_wmm(hapd, p);
+		if (sta->flags & WLAN_STA_WME)
+			p = hostapd_eid_wme(hapd, p);
 
 		p = hostapd_eid_ht_capabilities_info(hapd, p);
 		p = hostapd_eid_ht_operation(hapd, p);
@@ -1265,11 +1265,6 @@
 	struct ieee80211_mgmt mgmt;
 	u8 *end;
 
-	wpa_printf(MSG_DEBUG, "IEEE 802.11: Sending SA Query Request to "
-		   MACSTR, MAC2STR(addr));
-	wpa_hexdump(MSG_DEBUG, "IEEE 802.11: SA Query Transaction ID",
-		    trans_id, WLAN_SA_QUERY_TR_ID_LEN);
-
 	os_memset(&mgmt, 0, sizeof(mgmt));
 	mgmt.frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
 					  WLAN_FC_STYPE_ACTION);
@@ -1307,12 +1302,6 @@
 		return;
 	}
 
-	wpa_printf(MSG_DEBUG, "IEEE 802.11: Received SA Query Response from "
-		   MACSTR, MAC2STR(mgmt->sa));
-	wpa_hexdump(MSG_DEBUG, "IEEE 802.11: SA Query Transaction ID",
-		    mgmt->u.action.u.sa_query_resp.trans_id,
-		    WLAN_SA_QUERY_TR_ID_LEN);
-
 	/* MLME-SAQuery.confirm */
 
 	sta = ap_get_sta(hapd, mgmt->sa);
@@ -1341,21 +1330,12 @@
 		       "Reply to pending SA Query received");
 	ap_sta_stop_sa_query(hapd, sta);
 }
-
-
-static int robust_action_frame(u8 category)
-{
-	return category != WLAN_ACTION_PUBLIC &&
-		category != WLAN_ACTION_HT;
-}
 #endif /* CONFIG_IEEE80211W */
 
 
 static void handle_action(struct hostapd_data *hapd,
 			  struct ieee80211_mgmt *mgmt, size_t len)
 {
-	struct sta_info *sta;
-
 	if (len < IEEE80211_HDRLEN + 1) {
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_DEBUG,
@@ -1364,23 +1344,13 @@
 		return;
 	}
 
-	sta = ap_get_sta(hapd, mgmt->sa);
-#ifdef CONFIG_IEEE80211W
-	if (sta && (sta->flags & WLAN_STA_MFP) &&
-	    !(mgmt->frame_control & host_to_le16(WLAN_FC_ISWEP) &&
-	      robust_action_frame(mgmt->u.action.category))) {
-		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
-			       HOSTAPD_LEVEL_DEBUG,
-			       "Dropped unprotected Robust Action frame from "
-			       "an MFP STA");
-		return;
-	}
-#endif /* CONFIG_IEEE80211W */
-
 	switch (mgmt->u.action.category) {
 #ifdef CONFIG_IEEE80211R
 	case WLAN_ACTION_FT:
 	{
+		struct sta_info *sta;
+
+		sta = ap_get_sta(hapd, mgmt->sa);
 		if (sta == NULL || !(sta->flags & WLAN_STA_ASSOC)) {
 			wpa_printf(MSG_DEBUG, "IEEE 802.11: Ignored FT Action "
 				   "frame from unassociated STA " MACSTR,
@@ -1396,7 +1366,7 @@
 	}
 #endif /* CONFIG_IEEE80211R */
 	case WLAN_ACTION_WMM:
-		hostapd_wmm_action(hapd, mgmt, len);
+		hostapd_wme_action(hapd, mgmt, len);
 		return;
 #ifdef CONFIG_IEEE80211W
 	case WLAN_ACTION_SA_QUERY:
@@ -1563,16 +1533,24 @@
 		     struct ht_cap_ie *ht_cap_ie,
 		     struct ht_cap_ie *neg_ht_cap_ie)
 {
-	u16 cap;
 
 	os_memcpy(neg_ht_cap_ie, ht_cap_ie, sizeof(struct ht_cap_ie));
-	cap = le_to_host16(neg_ht_cap_ie->data.capabilities_info);
-	cap &= hapd->iconf->ht_capab;
-	cap |= (hapd->iconf->ht_capab & HT_CAP_INFO_SMPS_DISABLED);
+	neg_ht_cap_ie->data.capabilities_info =
+		ht_cap_ie->data.capabilities_info & hapd->iconf->ht_capab;
+
+	neg_ht_cap_ie->data.capabilities_info &= ~HT_CAP_INFO_SMPS_DISABLED;
+	if ((ht_cap_ie->data.capabilities_info & HT_CAP_INFO_SMPS_DISABLED) ==
+	    (hapd->iconf->ht_capab & HT_CAP_INFO_SMPS_DISABLED))
+		neg_ht_cap_ie->data.capabilities_info |=
+			hapd->iconf->ht_capab & HT_CAP_INFO_SMPS_DISABLED;
+	else
+		neg_ht_cap_ie->data.capabilities_info |=
+			HT_CAP_INFO_SMPS_DISABLED;
 
 	/* FIXME: Rx STBC needs to be handled specially */
-	cap |= (hapd->iconf->ht_capab & HT_CAP_INFO_RX_STBC_MASK);
-	neg_ht_cap_ie->data.capabilities_info = host_to_le16(cap);
+	neg_ht_cap_ie->data.capabilities_info &= ~HT_CAP_INFO_RX_STBC_MASK;
+	neg_ht_cap_ie->data.capabilities_info |=
+		hapd->iconf->ht_capab & HT_CAP_INFO_RX_STBC_MASK;
 }
 #endif /* CONFIG_IEEE80211N */
 
@@ -1588,7 +1566,6 @@
 	struct ht_cap_ie ht_cap;
 #endif /* CONFIG_IEEE80211N */
 	struct ht_cap_ie *ht_cap_ptr = NULL;
-	int set_flags, flags_and, flags_or;
 
 	if (!ok) {
 		hostapd_logger(hapd, mgmt->da, HOSTAPD_MODULE_IEEE80211,
@@ -1648,13 +1625,6 @@
 	sta->sa_query_timed_out = 0;
 #endif /* CONFIG_IEEE80211W */
 
-	/*
-	 * Remove the STA entry in order to make sure the STA PS state gets
-	 * cleared and configuration gets updated in case of reassociation back
-	 * to the same AP.
-	 */
-	hostapd_sta_remove(hapd, sta->addr);
-
 	if (hostapd_sta_add(hapd->conf->iface, hapd, sta->addr, sta->aid,
 			    sta->capability, sta->supported_rates,
 			    sta->supported_rates_len, 0, sta->listen_interval,
@@ -1676,15 +1646,13 @@
 		/* VLAN ID already set (e.g., by PMKSA caching), so bind STA */
 		ap_sta_bind_vlan(hapd, sta, 0);
 	}
-
-	set_flags = WLAN_STA_SHORT_PREAMBLE | WLAN_STA_WMM | WLAN_STA_MFP;
-	if (!hapd->conf->ieee802_1x && !hapd->conf->wpa &&
-	    sta->flags & WLAN_STA_AUTHORIZED)
-		set_flags |= WLAN_STA_AUTHORIZED;
-	flags_or = sta->flags & set_flags;
-	flags_and = sta->flags | ~set_flags;
-	hostapd_sta_set_flags(hapd, sta->addr, sta->flags,
-			      flags_or, flags_and);
+	if (sta->flags & WLAN_STA_SHORT_PREAMBLE) {
+		hostapd_sta_set_flags(hapd, sta->addr, sta->flags,
+				      WLAN_STA_SHORT_PREAMBLE, ~0);
+	} else {
+		hostapd_sta_set_flags(hapd, sta->addr, sta->flags,
+				      0, ~WLAN_STA_SHORT_PREAMBLE);
+	}
 
 	if (sta->auth_alg == WLAN_AUTH_FT)
 		wpa_auth_sm_event(sta->wpa_sm, WPA_ASSOC_FT);
diff -Nur hostap-06-d23bf71/hostapd/ieee802_1x.c hostap06/hostapd/ieee802_1x.c
--- hostap-06-d23bf71/hostapd/ieee802_1x.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/ieee802_1x.c	2009-03-23 14:17:09.000000000 +0200
@@ -164,7 +164,7 @@
 	}
 	os_memcpy(ekey, key->key_iv, sizeof(key->key_iv));
 	os_memcpy(ekey + sizeof(key->key_iv), sm->eap_if->eapKeyData, 32);
-	rc4_skip(ekey, ekey_len, 0, (u8 *) (key + 1), key_len);
+	rc4((u8 *) (key + 1), key_len, ekey, ekey_len);
 	os_free(ekey);
 
 	/* This header is needed here for HMAC-MD5, but it will be regenerated
diff -Nur hostap-06-d23bf71/hostapd/Makefile hostap06/hostapd/Makefile
--- hostap-06-d23bf71/hostapd/Makefile	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/Makefile	2009-08-12 12:18:17.000000000 +0300
@@ -145,6 +145,11 @@
 CONFIG_L2_FREEBSD=y
 endif
 
+ifdef CONFIG_DRIVER_MTLK
+CFLAGS += -DCONFIG_DRIVER_MTLK
+OBJS += driver_mtlk.o
+endif
+
 ifdef CONFIG_DRIVER_TEST
 CFLAGS += -DCONFIG_DRIVER_TEST
 OBJS += driver_test.o
@@ -220,7 +225,6 @@
 CFLAGS += -DEAP_AKA
 OBJS += ../src/eap_server/eap_aka.o
 CONFIG_EAP_SIM_COMMON=y
-NEED_SHA256=y
 endif
 
 ifdef CONFIG_EAP_AKA_PRIME
@@ -307,7 +311,6 @@
 OBJS += ../src/eap_server/eap_ikev2.o ../src/eap_server/ikev2.o
 OBJS += ../src/eap_common/eap_ikev2_common.o ../src/eap_common/ikev2_common.o
 NEED_DH_GROUPS=y
-NEED_DH_GROUPS_ALL=y
 endif
 
 ifdef CONFIG_EAP_TNC
@@ -382,6 +385,9 @@
 ifeq ($(CONFIG_CRYPTO), internal)
 ifdef CONFIG_INTERNAL_LIBTOMMATH
 CFLAGS += -DCONFIG_INTERNAL_LIBTOMMATH
+ifdef CONFIG_INTERNAL_LIBTOMMATH_FAST
+CFLAGS += -DLTM_FAST
+endif
 else
 LIBS += -ltommath
 LIBS_p += -ltommath
@@ -500,9 +506,6 @@
 
 ifdef NEED_DH_GROUPS
 OBJS += ../src/crypto/dh_groups.o
-ifdef NEED_DH_GROUPS_ALL
-CFLAGS += -DALL_DH_GROUPS
-endif
 endif
 
 ifndef NEED_FIPS186_2_PRF
@@ -556,17 +559,6 @@
 
 all: verify_config $(ALL)
 
-Q=@
-E=echo
-ifeq ($(V), 1)
-Q=
-E=true
-endif
-
-%.o: %.c
-	$(Q)$(CC) -c -o $@ $(CFLAGS) $<
-	@$(E) "  CC " $<
-
 verify_config:
 	@if [ ! -r .config ]; then \
 		echo 'Building hostapd requires a configuration file'; \
diff -Nur hostap-06-d23bf71/hostapd/Makefile.MTLK hostap06/hostapd/Makefile.MTLK
--- hostap-06-d23bf71/hostapd/Makefile.MTLK	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/hostapd/Makefile.MTLK	2009-06-09 11:30:39.000000000 +0300
@@ -0,0 +1,41 @@
+######### Metalink (c) #####################
+######### Standard header begin ############
+
+## TOPDIR may be set. It points to the top directory where all the E_* variables are in Makefiles.MTLK.vars
+
+ifdef E_TOPDIR
+include $(E_TOPDIR)/scripts/Makefile.MTLK.vars
+else
+$(error "E_TOPDIR doesn't defined")
+endif
+
+######### Standard header end ##############
+
+
+#CROSS_COMPILE=/opt/star/tools/arm-uclibc-3.4.6/bin/arm-linux-uclibc-
+CC=$(E_CC)
+CFLAGS=-Os -I/$(E_TOPDIR)/l/openssl/include/
+LIBS=-L$(E_TOPDIR)/l/openssl 
+STRIP=$(E_STRIP)
+export CC CFLAGS LIBS STRIP
+
+
+
+CONF:
+	echo "No configure needed "
+COMP:
+	make -f Makefile
+
+CLEAN:
+	make -f Makefile clean
+
+INSTALL: FORCE
+	#nstall -d 755 $(E_DEST)/rootfs-star_/root/mtlk/etc
+	install -m 666 -D template.conf $(E_DEST)/root/mtlk/etc/template.conf
+	install -m 755 -D hostapd $(E_DEST)/root/mtlk/etc/hostapd
+	install -m 755 -D hostapd_cli $(E_DEST)/root/mtlk/etc/hostapd_cli
+
+STRIP: FORCE
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/hostapd
+
+FORCE:
diff -Nur hostap-06-d23bf71/hostapd/preauth.c hostap06/hostapd/preauth.c
--- hostap-06-d23bf71/hostapd/preauth.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/preauth.c	2009-03-23 14:17:09.000000000 +0200
@@ -171,7 +171,6 @@
 
 		if (rsn_preauth_iface_add(hapd, start)) {
 			rsn_preauth_iface_deinit(hapd);
-			os_free(tmp);
 			return -1;
 		}
 
diff -Nur hostap-06-d23bf71/hostapd/README-WPS hostap06/hostapd/README-WPS
--- hostap-06-d23bf71/hostapd/README-WPS	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/README-WPS	2009-03-23 14:17:09.000000000 +0200
@@ -165,17 +165,10 @@
 hostapd_cli wps_pin 53b63a98-d29e-4457-a2ed-094d7e6a669c 12345670
 
 If the UUID-E is not available (e.g., Enrollee waits for the Registrar
-to be selected before connecting), wildcard UUID may be used to allow
-the PIN to be used once with any UUID:
+to be selected before connecting), wildcard UUID may be used to allow the PIN to be used once with any UUID:
 
 hostapd_cli wps_pin any 12345670
 
-To reduce likelihood of PIN being used with other devices or of
-forgetting an active PIN available for potential attackers, expiration
-time can be set for the new PIN:
-
-hostapd_cli wps_pin any 12345670 300
-
 
 After this, the Enrollee can connect to the AP again and complete WPS
 negotiation. At that point, a new, random WPA PSK is generated for the
diff -Nur hostap-06-d23bf71/hostapd/wme.c hostap06/hostapd/wme.c
--- hostap-06-d23bf71/hostapd/wme.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wme.c	2009-03-23 14:17:09.000000000 +0200
@@ -24,63 +24,47 @@
 
 /* TODO: maintain separate sequence and fragment numbers for each AC
  * TODO: IGMP snooping to track which multicasts to forward - and use QOS-DATA
- * if only WMM stations are receiving a certain group */
+ * if only WME stations are receiving a certain group */
 
 
-static inline u8 wmm_aci_aifsn(int aifsn, int acm, int aci)
-{
-	u8 ret;
-	ret = (aifsn << WMM_AC_AIFNS_SHIFT) & WMM_AC_AIFSN_MASK;
-	if (acm)
-		ret |= WMM_AC_ACM;
-	ret |= (aci << WMM_AC_ACI_SHIFT) & WMM_AC_ACI_MASK;
-	return ret;
-}
+static u8 wme_oui[3] = { 0x00, 0x50, 0xf2 };
 
 
-static inline u8 wmm_ecw(int ecwmin, int ecwmax)
-{
-	return ((ecwmin << WMM_AC_ECWMIN_SHIFT) & WMM_AC_ECWMIN_MASK) |
-		((ecwmax << WMM_AC_ECWMAX_SHIFT) & WMM_AC_ECWMAX_MASK);
-}
-
-
-/*
- * Add WMM Parameter Element to Beacon, Probe Response, and (Re)Association
- * Response frames.
- */
-u8 * hostapd_eid_wmm(struct hostapd_data *hapd, u8 *eid)
+/* Add WME Parameter Element to Beacon and Probe Response frames. */
+u8 * hostapd_eid_wme(struct hostapd_data *hapd, u8 *eid)
 {
 	u8 *pos = eid;
-	struct wmm_parameter_element *wmm =
-		(struct wmm_parameter_element *) (pos + 2);
+	struct wme_parameter_element *wme =
+		(struct wme_parameter_element *) (pos + 2);
 	int e;
 
-	if (!hapd->conf->wmm_enabled)
+	if (!hapd->conf->wme_enabled)
 		return eid;
 	eid[0] = WLAN_EID_VENDOR_SPECIFIC;
-	wmm->oui[0] = 0x00;
-	wmm->oui[1] = 0x50;
-	wmm->oui[2] = 0xf2;
-	wmm->oui_type = WMM_OUI_TYPE;
-	wmm->oui_subtype = WMM_OUI_SUBTYPE_PARAMETER_ELEMENT;
-	wmm->version = WMM_VERSION;
-	wmm->qos_info = hapd->parameter_set_count & 0xf;
+	wme->oui[0] = 0x00;
+	wme->oui[1] = 0x50;
+	wme->oui[2] = 0xf2;
+	wme->oui_type = WME_OUI_TYPE;
+	wme->oui_subtype = WME_OUI_SUBTYPE_PARAMETER_ELEMENT;
+	wme->version = WME_VERSION;
+	wme->acInfo = hapd->parameter_set_count & 0xf;
 
 	/* fill in a parameter set record for each AC */
 	for (e = 0; e < 4; e++) {
-		struct wmm_ac_parameter *ac = &wmm->ac[e];
-		struct hostapd_wmm_ac_params *acp =
-			&hapd->iconf->wmm_ac_params[e];
-
-		ac->aci_aifsn = wmm_aci_aifsn(acp->aifs,
-					      acp->admission_control_mandatory,
-					      e);
-		ac->cw = wmm_ecw(acp->cwmin, acp->cwmax);
-		ac->txop_limit = host_to_le16(acp->txop_limit);
+		struct wme_ac_parameter *ac = &wme->ac[e];
+		struct hostapd_wme_ac_params *acp =
+			&hapd->iconf->wme_ac_params[e];
+
+		ac->aifsn = acp->aifs;
+		ac->acm = acp->admission_control_mandatory;
+		ac->aci = e;
+		ac->reserved = 0;
+		ac->eCWmin = acp->cwmin;
+		ac->eCWmax = acp->cwmax;
+		ac->txopLimit = host_to_le16(acp->txopLimit);
 	}
 
-	pos = (u8 *) (wmm + 1);
+	pos = (u8 *) (wme + 1);
 	eid[1] = pos - eid - 2; /* element length */
 
 	return pos;
@@ -88,28 +72,31 @@
 
 
 /* This function is called when a station sends an association request with
- * WMM info element. The function returns zero on success or non-zero on any
- * error in WMM element. eid does not include Element ID and Length octets. */
-int hostapd_eid_wmm_valid(struct hostapd_data *hapd, u8 *eid, size_t len)
+ * WME info element. The function returns zero on success or non-zero on any
+ * error in WME element. eid does not include Element ID and Length octets. */
+int hostapd_eid_wme_valid(struct hostapd_data *hapd, u8 *eid, size_t len)
 {
-	struct wmm_information_element *wmm;
+	struct wme_information_element *wme;
 
-	wpa_hexdump(MSG_MSGDUMP, "WMM IE", eid, len);
+	wpa_hexdump(MSG_MSGDUMP, "WME IE", eid, len);
 
-	if (len < sizeof(struct wmm_information_element)) {
-		wpa_printf(MSG_DEBUG, "Too short WMM IE (len=%lu)",
+	if (len < sizeof(struct wme_information_element)) {
+		wpa_printf(MSG_DEBUG, "Too short WME IE (len=%lu)",
 			   (unsigned long) len);
 		return -1;
 	}
 
-	wmm = (struct wmm_information_element *) eid;
-	wpa_printf(MSG_DEBUG, "Validating WMM IE: OUI %02x:%02x:%02x  "
-		   "OUI type %d  OUI sub-type %d  version %d  QoS info 0x%x",
-		   wmm->oui[0], wmm->oui[1], wmm->oui[2], wmm->oui_type,
-		   wmm->oui_subtype, wmm->version, wmm->qos_info);
-	if (wmm->oui_subtype != WMM_OUI_SUBTYPE_INFORMATION_ELEMENT ||
-	    wmm->version != WMM_VERSION) {
-		wpa_printf(MSG_DEBUG, "Unsupported WMM IE Subtype/Version");
+	wme = (struct wme_information_element *) eid;
+	wpa_printf(MSG_DEBUG, "Validating WME IE: OUI %02x:%02x:%02x  "
+		   "OUI type %d  OUI sub-type %d  version %d",
+		   wme->oui[0], wme->oui[1], wme->oui[2], wme->oui_type,
+		   wme->oui_subtype, wme->version);
+	if (os_memcmp(wme->oui, wme_oui, sizeof(wme_oui)) != 0 ||
+	    wme->oui_type != WME_OUI_TYPE ||
+	    wme->oui_subtype != WME_OUI_SUBTYPE_INFORMATION_ELEMENT ||
+	    wme->version != WME_VERSION) {
+		wpa_printf(MSG_DEBUG, "Unsupported WME IE OUI/Type/Subtype/"
+			   "Version");
 		return -1;
 	}
 
@@ -118,30 +105,31 @@
 
 
 /* This function is called when a station sends an ACK frame for an AssocResp
- * frame (status=success) and the matching AssocReq contained a WMM element.
+ * frame (status=success) and the matching AssocReq contained a WME element.
  */
-int hostapd_wmm_sta_config(struct hostapd_data *hapd, struct sta_info *sta)
+int hostapd_wme_sta_config(struct hostapd_data *hapd, struct sta_info *sta)
 {
-	/* update kernel STA data for WMM related items (WLAN_STA_WPA flag) */
-	if (sta->flags & WLAN_STA_WMM)
+	/* update kernel STA data for WME related items (WLAN_STA_WPA flag) */
+	if (sta->flags & WLAN_STA_WME)
 		hostapd_sta_set_flags(hapd, sta->addr, sta->flags,
-				      WLAN_STA_WMM, ~0);
+				      WLAN_STA_WME, ~0);
 	else
 		hostapd_sta_set_flags(hapd, sta->addr, sta->flags,
-				      0, ~WLAN_STA_WMM);
+				      0, ~WLAN_STA_WME);
 
 	return 0;
 }
 
 
-static void wmm_send_action(struct hostapd_data *hapd, const u8 *addr,
-			    const struct wmm_tspec_element *tspec,
+static void wme_send_action(struct hostapd_data *hapd, const u8 *addr,
+			    const struct wme_tspec_info_element *tspec,
 			    u8 action_code, u8 dialogue_token, u8 status_code)
 {
 	u8 buf[256];
 	struct ieee80211_mgmt *m = (struct ieee80211_mgmt *) buf;
-	struct wmm_tspec_element *t = (struct wmm_tspec_element *)
-		m->u.action.u.wmm_action.variable;
+	struct wme_tspec_info_element *t =
+		(struct wme_tspec_info_element *)
+		m->u.action.u.wme_action.variable;
 	int len;
 
 	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
@@ -154,20 +142,20 @@
 	os_memcpy(m->sa, hapd->own_addr, ETH_ALEN);
 	os_memcpy(m->bssid, hapd->own_addr, ETH_ALEN);
 	m->u.action.category = WLAN_ACTION_WMM;
-	m->u.action.u.wmm_action.action_code = action_code;
-	m->u.action.u.wmm_action.dialog_token = dialogue_token;
-	m->u.action.u.wmm_action.status_code = status_code;
-	os_memcpy(t, tspec, sizeof(struct wmm_tspec_element));
+	m->u.action.u.wme_action.action_code = action_code;
+	m->u.action.u.wme_action.dialog_token = dialogue_token;
+	m->u.action.u.wme_action.status_code = status_code;
+	os_memcpy(t, tspec, sizeof(struct wme_tspec_info_element));
 	len = ((u8 *) (t + 1)) - buf;
 
 	if (hostapd_send_mgmt_frame(hapd, m, len, 0) < 0)
-		perror("wmm_send_action: send");
+		perror("wme_send_action: send");
 }
 
 
-static void wmm_addts_req(struct hostapd_data *hapd,
-			  struct ieee80211_mgmt *mgmt,
-			  struct wmm_tspec_element *tspec, size_t len)
+static void wme_setup_request(struct hostapd_data *hapd,
+			      struct ieee80211_mgmt *mgmt,
+			      struct wme_tspec_info_element *tspec, size_t len)
 {
 	u8 *end = ((u8 *) mgmt) + len;
 	int medium_time, pps, duration;
@@ -181,7 +169,7 @@
 
 	wpa_printf(MSG_DEBUG, "WMM: ADDTS Request (Dialog Token %d) for TSPEC "
 		   "from " MACSTR,
-		   mgmt->u.action.u.wmm_action.dialog_token,
+		   mgmt->u.action.u.wme_action.dialog_token,
 		   MAC2STR(mgmt->sa));
 
 	up = (tspec->ts_info[1] >> 3) & 0x07;
@@ -241,30 +229,30 @@
 	if (medium_time > 750000) {
 		wpa_printf(MSG_DEBUG, "WMM: Refuse TSPEC request for over "
 			   "75%% of available bandwidth");
-		wmm_send_action(hapd, mgmt->sa, tspec,
-				WMM_ACTION_CODE_ADDTS_RESP,
-				mgmt->u.action.u.wmm_action.dialog_token,
-				WMM_ADDTS_STATUS_REFUSED);
+		wme_send_action(hapd, mgmt->sa, tspec,
+				WME_ACTION_CODE_SETUP_RESPONSE,
+				mgmt->u.action.u.wme_action.dialog_token,
+				WME_SETUP_RESPONSE_STATUS_REFUSED);
 		return;
 	}
 
 	/* Convert to 32 microseconds per second unit */
 	tspec->medium_time = host_to_le16(medium_time / 32);
 
-	wmm_send_action(hapd, mgmt->sa, tspec, WMM_ACTION_CODE_ADDTS_RESP,
-			mgmt->u.action.u.wmm_action.dialog_token,
-			WMM_ADDTS_STATUS_ADMISSION_ACCEPTED);
+	wme_send_action(hapd, mgmt->sa, tspec, WME_ACTION_CODE_SETUP_RESPONSE,
+			mgmt->u.action.u.wme_action.dialog_token,
+			WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED);
 	return;
 
 invalid:
-	wmm_send_action(hapd, mgmt->sa, tspec,
-			WMM_ACTION_CODE_ADDTS_RESP,
-			mgmt->u.action.u.wmm_action.dialog_token,
-			WMM_ADDTS_STATUS_INVALID_PARAMETERS);
+	wme_send_action(hapd, mgmt->sa, tspec,
+			WME_ACTION_CODE_SETUP_RESPONSE,
+			mgmt->u.action.u.wme_action.dialog_token,
+			WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS);
 }
 
 
-void hostapd_wmm_action(struct hostapd_data *hapd, struct ieee80211_mgmt *mgmt,
+void hostapd_wme_action(struct hostapd_data *hapd, struct ieee80211_mgmt *mgmt,
 			size_t len)
 {
 	int action_code;
@@ -275,11 +263,11 @@
 
 	/* check that the request comes from a valid station */
 	if (!sta ||
-	    (sta->flags & (WLAN_STA_ASSOC | WLAN_STA_WMM)) !=
-	    (WLAN_STA_ASSOC | WLAN_STA_WMM)) {
+	    (sta->flags & (WLAN_STA_ASSOC | WLAN_STA_WME)) !=
+	    (WLAN_STA_ASSOC | WLAN_STA_WME)) {
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_DEBUG,
-			       "wmm action received is not from associated wmm"
+			       "wme action received is not from associated wme"
 			       " station");
 		/* TODO: respond with action frame refused status code */
 		return;
@@ -289,18 +277,19 @@
 	if (ieee802_11_parse_elems(pos, left, &elems, 1) == ParseFailed) {
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_DEBUG,
-			       "hostapd_wmm_action - could not parse wmm "
+			       "hostapd_wme_action - could not parse wme "
 			       "action");
 		/* TODO: respond with action frame invalid parameters status
 		 * code */
 		return;
 	}
 
-	if (!elems.wmm_tspec ||
-	    elems.wmm_tspec_len != (sizeof(struct wmm_tspec_element) - 2)) {
+	if (!elems.wme_tspec ||
+	    elems.wme_tspec_len != (sizeof(struct wme_tspec_info_element) - 2))
+	{
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_DEBUG,
-			       "hostapd_wmm_action - missing or wrong length "
+			       "hostapd_wme_action - missing or wrong length "
 			       "tspec");
 		/* TODO: respond with action frame invalid parameters status
 		 * code */
@@ -310,26 +299,26 @@
 	/* TODO: check the request is for an AC with ACM set, if not, refuse
 	 * request */
 
-	action_code = mgmt->u.action.u.wmm_action.action_code;
+	action_code = mgmt->u.action.u.wme_action.action_code;
 	switch (action_code) {
-	case WMM_ACTION_CODE_ADDTS_REQ:
-		wmm_addts_req(hapd, mgmt, (struct wmm_tspec_element *)
-			      (elems.wmm_tspec - 2), len);
+	case WME_ACTION_CODE_SETUP_REQUEST:
+		wme_setup_request(hapd, mgmt, (struct wme_tspec_info_element *)
+				  elems.wme_tspec, len);
 		return;
 #if 0
 	/* TODO: needed for client implementation */
-	case WMM_ACTION_CODE_ADDTS_RESP:
-		wmm_setup_request(hapd, mgmt, len);
+	case WME_ACTION_CODE_SETUP_RESPONSE:
+		wme_setup_request(hapd, mgmt, len);
 		return;
 	/* TODO: handle station teardown requests */
-	case WMM_ACTION_CODE_DELTS:
-		wmm_teardown(hapd, mgmt, len);
+	case WME_ACTION_CODE_TEARDOWN:
+		wme_teardown(hapd, mgmt, len);
 		return;
 #endif
 	}
 
 	hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 		       HOSTAPD_LEVEL_DEBUG,
-		       "hostapd_wmm_action - unknown action code %d",
+		       "hostapd_wme_action - unknown action code %d",
 		       action_code);
 }
diff -Nur hostap-06-d23bf71/hostapd/wme.h hostap06/hostapd/wme.h
--- hostap-06-d23bf71/hostapd/wme.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wme.h	2009-03-23 14:17:09.000000000 +0200
@@ -16,57 +16,76 @@
 #ifndef WME_H
 #define WME_H
 
-/*
- * WMM Information Element (used in (Re)Association Request frames; may also be
- * used in Beacon frames)
- */
-struct wmm_information_element {
-	/* Element ID: 221 (0xdd); Length: 7 */
-	/* required fields for WMM version 1 */
-	u8 oui[3]; /* 00:50:f2 */
-	u8 oui_type; /* 2 */
-	u8 oui_subtype; /* 0 */
-	u8 version; /* 1 for WMM version 1.0 */
-	u8 qos_info; /* AP/STA specific QoS info */
+#ifdef __linux__
+#include <endian.h>
+#endif /* __linux__ */
+
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)
+#include <sys/types.h>
+#include <sys/endian.h>
+#endif /* defined(__FreeBSD__) || defined(__NetBSD__) ||
+	* defined(__DragonFly__) */
+
+
+extern inline u16 tsinfo(int tag1d, int contention_based, int direction)
+{
+	return (tag1d << 11) | (contention_based << 7) | (direction << 5) |
+	  (tag1d << 1);
+}
+
+
+struct wme_information_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
 
 } __attribute__ ((packed));
 
-#define WMM_AC_AIFSN_MASK 0x0f
-#define WMM_AC_AIFNS_SHIFT 0
-#define WMM_AC_ACM 0x10
-#define WMM_AC_ACI_MASK 0x60
-#define WMM_AC_ACI_SHIFT 5
-
-#define WMM_AC_ECWMIN_MASK 0x0f
-#define WMM_AC_ECWMIN_SHIFT 0
-#define WMM_AC_ECWMAX_MASK 0xf0
-#define WMM_AC_ECWMAX_SHIFT 4
-
-struct wmm_ac_parameter {
-	u8 aci_aifsn; /* AIFSN, ACM, ACI */
-	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
-	le16 txop_limit;
+struct wme_ac_parameter {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	/* byte 1 */
+	u8 	aifsn:4,
+		acm:1,
+	 	aci:2,
+	 	reserved:1;
+
+	/* byte 2 */
+	u8 	eCWmin:4,
+	 	eCWmax:4;
+#elif __BYTE_ORDER == __BIG_ENDIAN
+	/* byte 1 */
+	u8 	reserved:1,
+	 	aci:2,
+	 	acm:1,
+	 	aifsn:4;
+
+	/* byte 2 */
+	u8 	eCWmax:4,
+	 	eCWmin:4;
+#else
+#error	"Please fix <endian.h>"
+#endif
+
+	/* bytes 3 & 4 */
+	le16 txopLimit;
 } __attribute__ ((packed));
 
-/*
- * WMM Parameter Element (used in Beacon, Probe Response, and (Re)Association
- * Response frmaes)
- */
-struct wmm_parameter_element {
-	/* Element ID: 221 (0xdd); Length: 24 */
-	/* required fields for WMM version 1 */
-	u8 oui[3]; /* 00:50:f2 */
-	u8 oui_type; /* 2 */
-	u8 oui_subtype; /* 1 */
-	u8 version; /* 1 for WMM version 1.0 */
-	u8 qos_info; /* AP/STA specif QoS info */
-	u8 reserved; /* 0 */
-	struct wmm_ac_parameter ac[4]; /* AC_BE, AC_BK, AC_VI, AC_VO */
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
+	u8 reserved;
+	struct wme_ac_parameter ac[4];
 
 } __attribute__ ((packed));
 
-/* WMM TSPEC Element */
-struct wmm_tspec_element {
+struct wme_tspec_info_element {
 	u8 eid; /* 221 = 0xdd */
 	u8 length; /* 6 + 55 = 61 */
 	u8 oui[3]; /* 00:50:f2 */
@@ -93,20 +112,20 @@
 } __attribute__ ((packed));
 
 
-/* Access Categories / ACI to AC coding */
+/* Access Categories */
 enum {
-	WMM_AC_BE = 0 /* Best Effort */,
-	WMM_AC_BK = 1 /* Background */,
-	WMM_AC_VI = 2 /* Video */,
-	WMM_AC_VO = 3 /* Voice */
+	WME_AC_BK = 1,
+	WME_AC_BE = 0,
+	WME_AC_VI = 2,
+	WME_AC_VO = 3
 };
 
 struct ieee80211_mgmt;
 
-u8 * hostapd_eid_wmm(struct hostapd_data *hapd, u8 *eid);
-int hostapd_eid_wmm_valid(struct hostapd_data *hapd, u8 *eid, size_t len);
-int hostapd_wmm_sta_config(struct hostapd_data *hapd, struct sta_info *sta);
-void hostapd_wmm_action(struct hostapd_data *hapd, struct ieee80211_mgmt *mgmt,
+u8 * hostapd_eid_wme(struct hostapd_data *hapd, u8 *eid);
+int hostapd_eid_wme_valid(struct hostapd_data *hapd, u8 *eid, size_t len);
+int hostapd_wme_sta_config(struct hostapd_data *hapd, struct sta_info *sta);
+void hostapd_wme_action(struct hostapd_data *hapd, struct ieee80211_mgmt *mgmt,
 			size_t len);
 
 #endif /* WME_H */
diff -Nur hostap-06-d23bf71/hostapd/wpa_auth_ie.c hostap06/hostapd/wpa_auth_ie.c
--- hostap-06-d23bf71/hostapd/wpa_auth_ie.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wpa_auth_ie.c	2009-03-23 14:17:09.000000000 +0200
@@ -215,8 +215,8 @@
 		capab |= WPA_CAPABILITY_PREAUTH;
 	if (conf->peerkey)
 		capab |= WPA_CAPABILITY_PEERKEY_ENABLED;
-	if (conf->wmm_enabled) {
-		/* 4 PTKSA replay counters when using WMM */
+	if (conf->wme_enabled) {
+		/* 4 PTKSA replay counters when using WME */
 		capab |= (RSN_NUM_REPLAY_COUNTERS_16 << 2);
 	}
 #ifdef CONFIG_IEEE80211W
diff -Nur hostap-06-d23bf71/hostapd/wpa.c hostap06/hostapd/wpa.c
--- hostap-06-d23bf71/hostapd/wpa.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wpa.c	2009-05-22 14:31:10.000000000 +0300
@@ -1,6 +1,6 @@
 /*
  * hostapd - IEEE 802.11i-2004 / WPA Authenticator
- * Copyright (c) 2004-2009, Jouni Malinen <j@w1.fi>
+ * Copyright (c) 2004-2008, Jouni Malinen <j@w1.fi>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -44,8 +44,6 @@
 static void wpa_group_sm_step(struct wpa_authenticator *wpa_auth,
 			      struct wpa_group *group);
 static void wpa_request_new_ptk(struct wpa_state_machine *sm);
-static int wpa_gtk_update(struct wpa_authenticator *wpa_auth,
-			  struct wpa_group *group);
 
 static const u32 dot11RSNAConfigGroupUpdateCount = 4;
 static const u32 dot11RSNAConfigPairwiseUpdateCount = 4;
@@ -288,25 +286,6 @@
 }
 
 
-static void wpa_group_set_key_len(struct wpa_group *group, int cipher)
-{
-	switch (cipher) {
-	case WPA_CIPHER_CCMP:
-		group->GTK_len = 16;
-		break;
-	case WPA_CIPHER_TKIP:
-		group->GTK_len = 32;
-		break;
-	case WPA_CIPHER_WEP104:
-		group->GTK_len = 13;
-		break;
-	case WPA_CIPHER_WEP40:
-		group->GTK_len = 5;
-		break;
-	}
-}
-
-
 static struct wpa_group * wpa_group_init(struct wpa_authenticator *wpa_auth,
 					 int vlan_id)
 {
@@ -321,7 +300,20 @@
 	group->GTKAuthenticator = TRUE;
 	group->vlan_id = vlan_id;
 
-	wpa_group_set_key_len(group, wpa_auth->conf.wpa_group);
+	switch (wpa_auth->conf.wpa_group) {
+	case WPA_CIPHER_CCMP:
+		group->GTK_len = 16;
+		break;
+	case WPA_CIPHER_TKIP:
+		group->GTK_len = 32;
+		break;
+	case WPA_CIPHER_WEP104:
+		group->GTK_len = 13;
+		break;
+	case WPA_CIPHER_WEP40:
+		group->GTK_len = 5;
+		break;
+	}
 
 	/* Counter = PRF-256(Random number, "Init Counter",
 	 *                   Local MAC Address || Time)
@@ -459,7 +451,6 @@
 int wpa_reconfig(struct wpa_authenticator *wpa_auth,
 		 struct wpa_auth_config *conf)
 {
-	struct wpa_group *group;
 	if (wpa_auth == NULL)
 		return 0;
 
@@ -469,17 +460,6 @@
 		return -1;
 	}
 
-	/*
-	 * Reinitialize GTK to make sure it is suitable for the new
-	 * configuration.
-	 */
-	group = wpa_auth->group;
-	wpa_group_set_key_len(group, wpa_auth->conf.wpa_group);
-	group->GInit = TRUE;
-	wpa_group_sm_step(wpa_auth, group);
-	group->GInit = FALSE;
-	wpa_group_sm_step(wpa_auth, group);
-
 	return 0;
 }
 
@@ -639,22 +619,6 @@
 		return;
 	}
 
-	if (sm->wpa == WPA_VERSION_WPA2) {
-		if (key->type != EAPOL_KEY_TYPE_RSN) {
-			wpa_printf(MSG_DEBUG, "Ignore EAPOL-Key with "
-				   "unexpected type %d in RSN mode",
-				   key->type);
-			return;
-		}
-	} else {
-		if (key->type != EAPOL_KEY_TYPE_WPA) {
-			wpa_printf(MSG_DEBUG, "Ignore EAPOL-Key with "
-				   "unexpected type %d in WPA mode",
-				   key->type);
-			return;
-		}
-	}
-
 	/* FIX: verify that the EAPOL-Key frame was encrypted if pairwise keys
 	 * are set */
 
diff -Nur hostap-06-d23bf71/hostapd/wpa.h hostap06/hostapd/wpa.h
--- hostap-06-d23bf71/hostapd/wpa.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wpa.h	2009-03-23 14:17:09.000000000 +0200
@@ -141,7 +141,7 @@
 	int rsn_preauth;
 	int eapol_version;
 	int peerkey;
-	int wmm_enabled;
+	int wme_enabled;
 	int okc;
 #ifdef CONFIG_IEEE80211W
 	enum {
diff -Nur hostap-06-d23bf71/hostapd/wps_hostapd.c hostap06/hostapd/wps_hostapd.c
--- hostap-06-d23bf71/hostapd/wps_hostapd.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wps_hostapd.c	2009-08-12 12:53:29.000000000 +0300
@@ -210,9 +210,9 @@
 	wpa_printf(MSG_DEBUG, "WPS: Authentication Type 0x%x",
 		   cred->auth_type);
 	wpa_printf(MSG_DEBUG, "WPS: Encryption Type 0x%x", cred->encr_type);
-	wpa_printf(MSG_DEBUG, "WPS: Network Key Index %d", cred->key_idx);
+	wpa_printf(MSG_DEBUG, "WPS: Network Keys %d", cred->keys_num);
 	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key",
-			cred->key, cred->key_len);
+			cred->key[0], cred->key_len[0]);
 	wpa_printf(MSG_DEBUG, "WPS: MAC Address " MACSTR,
 		   MAC2STR(cred->mac_addr));
 
@@ -237,21 +237,21 @@
 	hapd->wps->ssid_len = cred->ssid_len;
 	hapd->wps->encr_types = cred->encr_type;
 	hapd->wps->auth_types = cred->auth_type;
-	if (cred->key_len == 0) {
+	if (cred->key[0] == NULL) {
 		os_free(hapd->wps->network_key);
 		hapd->wps->network_key = NULL;
 		hapd->wps->network_key_len = 0;
 	} else {
 		if (hapd->wps->network_key == NULL ||
-		    hapd->wps->network_key_len < cred->key_len) {
+		    hapd->wps->network_key_len < cred->key_len[0]) {
 			hapd->wps->network_key_len = 0;
 			os_free(hapd->wps->network_key);
-			hapd->wps->network_key = os_malloc(cred->key_len);
+			hapd->wps->network_key = os_malloc(cred->key_len[0]);
 			if (hapd->wps->network_key == NULL)
 				return -1;
 		}
-		hapd->wps->network_key_len = cred->key_len;
-		os_memcpy(hapd->wps->network_key, cred->key, cred->key_len);
+		hapd->wps->network_key_len = cred->key_len[0];
+		os_memcpy(hapd->wps->network_key, cred->key[0], cred->key_len[0]);
 	}
 	hapd->wps->wps_state = WPS_STATE_CONFIGURED;
 
@@ -322,20 +322,20 @@
 		}
 		fprintf(nconf, "\n");
 
-		if (cred->key_len >= 8 && cred->key_len < 64) {
+		if (cred->key_len[0] >= 8 && cred->key_len[0] < 64) {
 			fprintf(nconf, "wpa_passphrase=");
-			for (i = 0; i < cred->key_len; i++)
-				fputc(cred->key[i], nconf);
+			for (i = 0; i < cred->key_len[0]; i++)
+				fputc(cred->key[0][i], nconf);
 			fprintf(nconf, "\n");
-		} else if (cred->key_len == 64) {
+		} else if (cred->key_len[0] == 64) {
 			fprintf(nconf, "wpa_psk=");
-			for (i = 0; i < cred->key_len; i++)
-				fputc(cred->key[i], nconf);
+			for (i = 0; i < cred->key_len[0]; i++)
+				fputc(cred->key[0][i], nconf);
 			fprintf(nconf, "\n");
 		} else {
-			wpa_printf(MSG_WARNING, "WPS: Invalid key length %lu "
+			wpa_printf(MSG_WARNING, "WPS: Invalid key[0] length %lu "
 				   "for WPA/WPA2",
-				   (unsigned long) cred->key_len);
+				   (unsigned long) cred->key_len[0]);
 		}
 
 		fprintf(nconf, "auth_algs=1\n");
@@ -348,22 +348,22 @@
 		else
 			fprintf(nconf, "auth_algs=1\n");
 
-		if (cred->encr_type & WPS_ENCR_WEP && cred->key_idx <= 4) {
-			int key_idx = cred->key_idx;
-			if (key_idx)
-				key_idx--;
-			fprintf(nconf, "wep_default_key=%d\n", key_idx);
-			fprintf(nconf, "wep_key%d=", key_idx);
-			if (cred->key_len == 10 || cred->key_len == 26) {
-				/* WEP key as a hex string */
-				for (i = 0; i < cred->key_len; i++)
-					fputc(cred->key[i], nconf);
-			} else {
-				/* Raw WEP key; convert to hex */
-				for (i = 0; i < cred->key_len; i++)
-					fprintf(nconf, "%02x", cred->key[i]);
+		if (cred->encr_type & WPS_ENCR_WEP && cred->keys_num <= NUM_WEP_KEYS) {
+			u8 j;
+			for (i = 0; i < cred->keys_num; i++) {
+				int len = cred->key_len[i];
+				fprintf(nconf, "wep_key%d=", i);
+				if (len == 10 || len == 26) {
+					/* WEP key[0] as a hex string */
+					for (j = 0; j < len; j++)
+						fputc(cred->key[i][j], nconf);
+				} else {
+					/* Raw WEP key[0]; convert to hex */
+					for (j = 0; j < len; j++)
+						fprintf(nconf, "%02x", cred->key[i][j]);
+				}
+				fprintf(nconf, "\n");
 			}
-			fprintf(nconf, "\n");
 		}
 	}
 
@@ -699,7 +699,7 @@
 
 
 int hostapd_wps_add_pin(struct hostapd_data *hapd, const char *uuid,
-			const char *pin, int timeout)
+			const char *pin)
 {
 	u8 u[UUID_LEN];
 	int any = 0;
@@ -711,8 +711,7 @@
 	else if (uuid_str2bin(uuid, u))
 		return -1;
 	return wps_registrar_add_pin(hapd->wps->registrar, any ? NULL : u,
-				     (const u8 *) pin, os_strlen(pin),
-				     timeout);
+				     (const u8 *) pin, os_strlen(pin));
 }
 
 
@@ -895,8 +894,8 @@
 
 	wpa_printf(MSG_DEBUG, "WPS UPnP: PutWLANResponse ev_type=%d mac_addr="
 		   MACSTR, ev_type, MAC2STR(mac_addr));
-	wpa_hexdump(MSG_MSGDUMP, "WPS UPnP: PutWLANResponse NewMessage",
-		    wpabuf_head(msg), wpabuf_len(msg));
+	wpa_hexdump_ascii(MSG_MSGDUMP, "WPS UPnP: PutWLANResponse NewMessage",
+			  wpabuf_head(msg), wpabuf_len(msg));
 	if (ev_type != UPNP_WPS_WLANEVENT_TYPE_EAP) {
 		wpa_printf(MSG_DEBUG, "WPS UPnP: Ignored unexpected "
 			   "PutWLANResponse WLANEventType %d", ev_type);
diff -Nur hostap-06-d23bf71/hostapd/wps_hostapd.h hostap06/hostapd/wps_hostapd.h
--- hostap-06-d23bf71/hostapd/wps_hostapd.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/hostapd/wps_hostapd.h	2009-03-23 14:17:09.000000000 +0200
@@ -21,7 +21,7 @@
 		     struct hostapd_bss_config *conf);
 void hostapd_deinit_wps(struct hostapd_data *hapd);
 int hostapd_wps_add_pin(struct hostapd_data *hapd, const char *uuid,
-			const char *pin, int timeout);
+			const char *pin);
 int hostapd_wps_button_pushed(struct hostapd_data *hapd);
 void hostapd_wps_probe_req_rx(struct hostapd_data *hapd, const u8 *addr,
 			      const u8 *ie, size_t ie_len);
diff -Nur hostap-06-d23bf71/mac80211_hwsim/mac80211_hwsim.c hostap06/mac80211_hwsim/mac80211_hwsim.c
--- hostap-06-d23bf71/mac80211_hwsim/mac80211_hwsim.c	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/mac80211_hwsim/mac80211_hwsim.c	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1,539 @@
+/*
+ * mac80211_hwsim - software simulator of 802.11 radio(s) for mac80211
+ * Copyright (c) 2008, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * TODO:
+ * - IBSS mode simulation (Beacon transmission with competition for "air time")
+ * - IEEE 802.11a and 802.11n modes
+ */
+
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/etherdevice.h>
+
+MODULE_AUTHOR("Jouni Malinen");
+MODULE_DESCRIPTION("Software simulator of 802.11 radio(s) for mac80211");
+MODULE_LICENSE("GPL");
+
+static int radios = 2;
+module_param(radios, int, 0444);
+MODULE_PARM_DESC(radios, "Number of simulated radios");
+
+
+static struct class *hwsim_class;
+
+static struct ieee80211_hw **hwsim_radios;
+static int hwsim_radio_count;
+static struct net_device *hwsim_mon; /* global monitor netdev */
+
+
+static const struct ieee80211_channel hwsim_channels[] = {
+	{ .chan = 1, .freq = 2412, .val = 1 },
+	{ .chan = 2, .freq = 2417, .val = 2 },
+	{ .chan = 3, .freq = 2422, .val = 3 },
+	{ .chan = 4, .freq = 2427, .val = 4 },
+	{ .chan = 5, .freq = 2432, .val = 5 },
+	{ .chan = 6, .freq = 2437, .val = 6 },
+	{ .chan = 7, .freq = 2442, .val = 7 },
+	{ .chan = 8, .freq = 2447, .val = 8 },
+	{ .chan = 9, .freq = 2452, .val = 9 },
+	{ .chan = 10, .freq = 2457, .val = 10 },
+	{ .chan = 11, .freq = 2462, .val = 11 },
+	{ .chan = 12, .freq = 2467, .val = 12 },
+	{ .chan = 13, .freq = 2472, .val = 13 },
+	{ .chan = 14, .freq = 2484, .val = 14 },
+};
+
+static const struct ieee80211_rate hwsim_rates[] = {
+	{ .rate = 10, .val = 10, .flags = IEEE80211_RATE_CCK },
+	{ .rate = 20, .val = 20, .val2 = 21, .flags = IEEE80211_RATE_CCK_2 },
+	{ .rate = 55, .val = 55, .val2 = 56, .flags = IEEE80211_RATE_CCK_2 },
+	{ .rate = 110, .val = 110, .val2 = 111,
+	  .flags = IEEE80211_RATE_CCK_2 },
+	{ .rate = 60, .val = 60, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 90, .val = 90, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 120, .val = 120, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 180, .val = 180, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 240, .val = 240, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 360, .val = 360, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 480, .val = 480, .flags = IEEE80211_RATE_OFDM },
+	{ .rate = 540, .val = 540, .flags = IEEE80211_RATE_OFDM }
+};
+
+struct mac80211_hwsim_data {
+	struct device *dev;
+	struct ieee80211_hw_mode modes[1];
+	struct ieee80211_channel channels[ARRAY_SIZE(hwsim_channels)];
+	struct ieee80211_rate rates[ARRAY_SIZE(hwsim_rates)];
+
+	int freq;
+	int channel;
+	enum ieee80211_phymode phymode;
+	int radio_enabled;
+	unsigned long beacon_int; /* in jiffies unit */
+	unsigned int rx_filter;
+	int started;
+	struct timer_list beacon_timer;
+};
+
+
+struct hwsim_radiotap_hdr {
+	struct ieee80211_radiotap_header hdr;
+	u8 rt_flags;
+	u8 rt_rate;
+	__le16 rt_channel;
+	__le16 rt_chbitmask;
+} __attribute__ ((packed));
+
+
+static int hwsim_mon_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	/* TODO: allow packet injection */
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+
+static void mac80211_hwsim_monitor_rx(struct mac80211_hwsim_data *data,
+				      struct sk_buff *tx_skb,
+				      struct ieee80211_tx_control *control)
+{
+	struct sk_buff *skb;
+	struct hwsim_radiotap_hdr *hdr;
+	u16 flags;
+
+	if (!netif_running(hwsim_mon))
+		return;
+
+	skb = skb_copy_expand(tx_skb, sizeof(*hdr), 0, GFP_ATOMIC);
+	if (skb == NULL)
+		return;
+
+	hdr = (struct hwsim_radiotap_hdr *) skb_push(skb, sizeof(*hdr));
+	hdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+	hdr->hdr.it_pad = 0;
+	hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+	hdr->hdr.it_present = __constant_cpu_to_le32(
+	     (1 << IEEE80211_RADIOTAP_FLAGS) |
+	     (1 << IEEE80211_RADIOTAP_RATE) |
+	     (1 << IEEE80211_RADIOTAP_CHANNEL));
+	hdr->rt_flags = 0;
+	hdr->rt_rate = control->tx_rate / 5;
+	hdr->rt_channel = data->freq;
+	flags = IEEE80211_CHAN_2GHZ;
+	if (control->rate->flags & IEEE80211_RATE_OFDM)
+		flags |= IEEE80211_CHAN_OFDM;
+	if (control->rate->flags & IEEE80211_RATE_CCK)
+		flags |= IEEE80211_CHAN_CCK;
+	hdr->rt_chbitmask = cpu_to_le16(flags);
+
+	skb->dev = hwsim_mon;
+	skb_set_mac_header(skb, 0);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = __constant_htons(ETH_P_802_2);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	netif_rx(skb);
+}
+
+
+static int mac80211_hwsim_tx(struct ieee80211_hw *hw, struct sk_buff *skb,
+			     struct ieee80211_tx_control *control)
+{
+	struct mac80211_hwsim_data *data = hw->priv;
+	struct ieee80211_tx_status tx_status;
+	struct ieee80211_rx_status rx_status;
+	int i, ack = 0;
+	struct ieee80211_hdr *hdr;
+
+	mac80211_hwsim_monitor_rx(data, skb, control);
+
+	if (skb->len < 10) {
+		/* Should not happen; just a sanity check for addr1 use */
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	if (!data->radio_enabled) {
+		printk(KERN_DEBUG "%s: dropped TX frame since radio "
+		       "disabled\n", wiphy_name(hw->wiphy));
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	if (is_multicast_ether_addr(hdr->addr1))
+		ack = 1;
+
+	memset(&rx_status, 0, sizeof(rx_status));
+	/* TODO: set mactime */
+	rx_status.freq = data->freq;
+	rx_status.channel = data->channel;
+	rx_status.phymode = data->phymode;
+	rx_status.rate = control->tx_rate;
+	/* TODO: simulate signal strength (and optional packet drop) */
+
+	/* Copy skb to all enabled radios that are on the current frequency */
+	for (i = 0; i < hwsim_radio_count; i++) {
+		struct mac80211_hwsim_data *data2;
+		struct sk_buff *nskb;
+
+		if (hwsim_radios[i] == NULL || hwsim_radios[i] == hw)
+			continue;
+		data2 = hwsim_radios[i]->priv;
+		if (!data2->started || !data2->radio_enabled ||
+		    data->freq != data2->freq)
+			continue;
+
+		nskb = skb_copy(skb, GFP_ATOMIC);
+		if (nskb == NULL)
+			continue;
+
+		if (memcmp(hdr->addr1, hwsim_radios[i]->wiphy->perm_addr,
+			   ETH_ALEN) == 0)
+			ack = 1;
+		ieee80211_rx_irqsafe(hwsim_radios[i], nskb, &rx_status);
+	}
+
+	memset(&tx_status, 0, sizeof(tx_status));
+	memcpy(&tx_status.control, control, sizeof(*control));
+	tx_status.flags = ack ? IEEE80211_TX_STATUS_ACK : 0;
+	ieee80211_tx_status_irqsafe(hw, skb, &tx_status);
+	return NETDEV_TX_OK;
+}
+
+
+static int mac80211_hwsim_start(struct ieee80211_hw *hw)
+{
+	struct mac80211_hwsim_data *data = hw->priv;
+	printk(KERN_DEBUG "%s:%s\n", wiphy_name(hw->wiphy), __func__);
+	data->started = 1;
+	return 0;
+}
+
+
+static void mac80211_hwsim_stop(struct ieee80211_hw *hw)
+{
+	struct mac80211_hwsim_data *data = hw->priv;
+	data->started = 0;
+	printk(KERN_DEBUG "%s:%s\n", wiphy_name(hw->wiphy), __func__);
+}
+
+
+static int mac80211_hwsim_add_interface(struct ieee80211_hw *hw,
+					struct ieee80211_if_init_conf *conf)
+{
+	DECLARE_MAC_BUF(mac);
+	printk(KERN_DEBUG "%s:%s (type=%d mac_addr=%s)\n",
+	       wiphy_name(hw->wiphy), __func__, conf->type,
+	       print_mac(mac, conf->mac_addr));
+	return 0;
+}
+
+
+static void mac80211_hwsim_remove_interface(
+	struct ieee80211_hw *hw, struct ieee80211_if_init_conf *conf)
+{
+	DECLARE_MAC_BUF(mac);
+	printk(KERN_DEBUG "%s:%s (type=%d mac_addr=%s)\n",
+	       wiphy_name(hw->wiphy), __func__, conf->type,
+	       print_mac(mac, conf->mac_addr));
+}
+
+
+static void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,
+				     struct ieee80211_vif *vif)
+{
+	struct ieee80211_hw *hw = arg;
+	struct mac80211_hwsim_data *data = hw->priv;
+	struct ieee80211_tx_control control;
+	struct sk_buff *skb;
+	struct ieee80211_rx_status rx_status;
+	int i;
+
+	if (vif->type != IEEE80211_IF_TYPE_AP)
+		return;
+
+	skb = ieee80211_beacon_get(hw, vif, &control);
+	if (skb == NULL)
+		return;
+
+	mac80211_hwsim_monitor_rx(data, skb, &control);
+
+	memset(&rx_status, 0, sizeof(rx_status));
+	/* TODO: set mactime */
+	rx_status.freq = data->freq;
+	rx_status.channel = data->channel;
+	rx_status.phymode = data->phymode;
+	rx_status.rate = control.tx_rate;
+	/* TODO: simulate signal strength (and optional packet drop) */
+
+	/* Copy skb to all enabled radios that are on the current frequency */
+	for (i = 0; i < hwsim_radio_count; i++) {
+		struct mac80211_hwsim_data *data2;
+		struct sk_buff *nskb;
+
+		if (hwsim_radios[i] == NULL || hwsim_radios[i] == hw)
+			continue;
+		data2 = hwsim_radios[i]->priv;
+		if (!data2->started || !data2->radio_enabled ||
+		    data->freq != data2->freq)
+			continue;
+
+		nskb = skb_copy(skb, GFP_ATOMIC);
+		if (nskb == NULL)
+			continue;
+
+		ieee80211_rx_irqsafe(hwsim_radios[i], nskb, &rx_status);
+	}
+
+	dev_kfree_skb(skb);
+}
+
+
+static void mac80211_hwsim_beacon(unsigned long arg)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *) arg;
+	struct mac80211_hwsim_data *data = hw->priv;
+
+	if (!data->started || !data->radio_enabled)
+		return;
+
+	ieee80211_iterate_active_interfaces(hw, mac80211_hwsim_beacon_tx, hw);
+
+	data->beacon_timer.expires = jiffies + data->beacon_int;
+	add_timer(&data->beacon_timer);
+}
+
+
+static int mac80211_hwsim_config(struct ieee80211_hw *hw,
+				 struct ieee80211_conf *conf)
+{
+	struct mac80211_hwsim_data *data = hw->priv;
+
+	printk(KERN_DEBUG "%s:%s (freq=%d radio_enabled=%d beacon_int=%d)\n",
+	       wiphy_name(hw->wiphy), __func__,
+	       conf->freq, conf->radio_enabled, conf->beacon_int);
+
+	data->freq = conf->freq;
+	data->channel = conf->channel;
+	data->phymode = conf->phymode;
+	data->radio_enabled = conf->radio_enabled;
+	data->beacon_int = 1024 * conf->beacon_int / 1000 * HZ / 1000;
+	if (data->beacon_int < 1)
+		data->beacon_int = 1;
+
+	if (!data->started || !data->radio_enabled)
+		del_timer(&data->beacon_timer);
+	else
+		mod_timer(&data->beacon_timer, jiffies + data->beacon_int);
+
+	return 0;
+}
+
+
+static void mac80211_hwsim_configure_filter(struct ieee80211_hw *hw,
+					    unsigned int changed_flags,
+					    unsigned int *total_flags,
+					    int mc_count,
+					    struct dev_addr_list *mc_list)
+{
+	struct mac80211_hwsim_data *data = hw->priv;
+
+	printk(KERN_DEBUG "%s:%s\n", wiphy_name(hw->wiphy), __func__);
+
+	data->rx_filter = 0;
+	if (*total_flags & FIF_PROMISC_IN_BSS)
+		data->rx_filter |= FIF_PROMISC_IN_BSS;
+	if (*total_flags & FIF_ALLMULTI)
+		data->rx_filter |= FIF_ALLMULTI;
+
+	*total_flags = data->rx_filter;
+}
+
+
+
+static const struct ieee80211_ops mac80211_hwsim_ops =
+{
+	.tx = mac80211_hwsim_tx,
+	.start = mac80211_hwsim_start,
+	.stop = mac80211_hwsim_stop,
+	.add_interface = mac80211_hwsim_add_interface,
+	.remove_interface = mac80211_hwsim_remove_interface,
+	.config = mac80211_hwsim_config,
+	.configure_filter = mac80211_hwsim_configure_filter,
+};
+
+
+static void mac80211_hwsim_free(void)
+{
+	int i;
+
+	for (i = 0; i < hwsim_radio_count; i++) {
+		if (hwsim_radios[i]) {
+			struct mac80211_hwsim_data *data;
+			data = hwsim_radios[i]->priv;
+			ieee80211_unregister_hw(hwsim_radios[i]);
+			if (!IS_ERR(data->dev))
+				device_unregister(data->dev);
+			ieee80211_free_hw(hwsim_radios[i]);
+		}
+	}
+	kfree(hwsim_radios);
+	class_destroy(hwsim_class);
+}
+
+
+static struct device_driver mac80211_hwsim_driver = {
+	.name = "mac80211_hwsim"
+};
+
+
+static void hwsim_mon_setup(struct net_device *dev)
+{
+	dev->hard_start_xmit = hwsim_mon_xmit;
+	dev->destructor = free_netdev;
+	ether_setup(dev);
+	dev->tx_queue_len = 0;
+	dev->type = ARPHRD_IEEE80211_RADIOTAP;
+	memset(dev->dev_addr, 0, ETH_ALEN);
+	dev->dev_addr[0] = 0x12;
+}
+
+
+static int __init init_mac80211_hwsim(void)
+{
+	int i, err = 0;
+	u8 addr[ETH_ALEN];
+	struct mac80211_hwsim_data *data;
+	struct ieee80211_hw *hw;
+	DECLARE_MAC_BUF(mac);
+
+	if (radios < 1 || radios > 65535)
+		return -EINVAL;
+
+	hwsim_radio_count = radios;
+	hwsim_radios = kcalloc(hwsim_radio_count,
+			       sizeof(struct ieee80211_hw *), GFP_KERNEL);
+	if (hwsim_radios == NULL)
+		return -ENOMEM;
+
+	hwsim_class = class_create(THIS_MODULE, "mac80211_hwsim");
+	if (IS_ERR(hwsim_class)) {
+		kfree(hwsim_radios);
+		return PTR_ERR(hwsim_class);
+	}
+
+	memset(addr, 0, ETH_ALEN);
+	addr[0] = 0x02;
+
+	for (i = 0; i < hwsim_radio_count; i++) {
+		printk(KERN_DEBUG "mac80211_hwsim: Initializing radio %d\n",
+		       i);
+		hw = ieee80211_alloc_hw(sizeof(*data), &mac80211_hwsim_ops);
+		if (hw == NULL) {
+			printk(KERN_DEBUG "mac80211_hwsim: ieee80211_alloc_hw "
+			       "failed\n");
+			err = -ENOMEM;
+			goto failed;
+		}
+		hwsim_radios[i] = hw;
+
+		data = hw->priv;
+		data->dev = device_create(hwsim_class, NULL, 0, "hwsim%d", i);
+		if (IS_ERR(data->dev)) {
+			printk(KERN_DEBUG "mac80211_hwsim: device_create "
+			       "failed (%ld)\n", PTR_ERR(data->dev));
+			err = -ENOMEM;
+			goto failed;
+		}
+		data->dev->driver = &mac80211_hwsim_driver;
+		dev_set_drvdata(data->dev, hw);
+
+		SET_IEEE80211_DEV(hw, data->dev);
+		addr[3] = i >> 8;
+		addr[4] = i;
+		SET_IEEE80211_PERM_ADDR(hw, addr);
+
+		hw->channel_change_time = 1;
+		hw->queues = 1;
+
+		memcpy(data->channels, hwsim_channels, sizeof(hwsim_channels));
+		memcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));
+		data->modes[0].channels = data->channels;
+		data->modes[0].rates = data->rates;
+		data->modes[0].mode = MODE_IEEE80211G;
+		data->modes[0].num_channels = ARRAY_SIZE(hwsim_channels);
+		data->modes[0].num_rates = ARRAY_SIZE(hwsim_rates);
+
+		err = ieee80211_register_hwmode(hw, data->modes);
+		if (err < 0) {
+			printk(KERN_DEBUG "mac80211_hwsim: "
+			       "ieee80211_register_hwmode failed (%d)\n", err);
+			goto failed;
+		}
+
+		err = ieee80211_register_hw(hw);
+		if (err < 0) {
+			printk(KERN_DEBUG "mac80211_hwsim: "
+			       "ieee80211_register_hw failed (%d)\n", err);
+			goto failed;
+		}
+
+		printk(KERN_DEBUG "%s: hwaddr %s registered\n",
+		       wiphy_name(hw->wiphy),
+		       print_mac(mac, hw->wiphy->perm_addr));
+
+		setup_timer(&data->beacon_timer, mac80211_hwsim_beacon,
+			    (unsigned long) hw);
+	}
+
+	hwsim_mon = alloc_netdev(0, "hwsim%d", hwsim_mon_setup);
+	if (hwsim_mon == NULL)
+		goto failed;
+
+	rtnl_lock();
+
+	err = dev_alloc_name(hwsim_mon, hwsim_mon->name);
+	if (err < 0) {
+		goto failed_mon;
+	}
+
+	err = register_netdevice(hwsim_mon);
+	if (err < 0)
+		goto failed_mon;
+
+	rtnl_unlock();
+
+	return 0;
+
+failed_mon:
+	rtnl_unlock();
+	free_netdev(hwsim_mon);
+
+failed:
+	mac80211_hwsim_free();
+	return err;
+}
+
+
+static void __exit exit_mac80211_hwsim(void)
+{
+	printk(KERN_DEBUG "mac80211_hwsim: unregister %d radios\n",
+	       hwsim_radio_count);
+
+	unregister_netdev(hwsim_mon);
+	mac80211_hwsim_free();
+}
+
+
+module_init(init_mac80211_hwsim);
+module_exit(exit_mac80211_hwsim);
diff -Nur hostap-06-d23bf71/mac80211_hwsim/Makefile hostap06/mac80211_hwsim/Makefile
--- hostap-06-d23bf71/mac80211_hwsim/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/mac80211_hwsim/Makefile	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1,12 @@
+# Determine path to the root directory of the Linux kernel source for the
+# currently running kernel. Version can be hardcoded with environment variable:
+# KVERS=2.6.25-foo make
+# Kernel path can be overrided with KERNEL_PATH argument to make:
+# make KERNEL_PATH=/usr/src/linux
+KVERS ?= $(shell uname -r)
+KERNEL_PATH ?= /lib/modules/$(KVERS)/build
+
+hwsim:
+	$(MAKE) -C $(KERNEL_PATH) SUBDIRS=$(PWD) modules
+
+obj-m += mac80211_hwsim.o
diff -Nur hostap-06-d23bf71/mac80211_hwsim/README hostap06/mac80211_hwsim/README
--- hostap-06-d23bf71/mac80211_hwsim/README	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/mac80211_hwsim/README	2009-03-23 14:17:09.000000000 +0200
@@ -51,8 +51,16 @@
 care of WPA2-PSK authentication. In addition, hostapd is also
 processing access point side of association.
 
-# Load the module (needs to be built into your kernel)
-modprobe mac80211_hwsim
+Please note that the currently released Linux kernel (2.6.25) does not
+enable AP mode, so a simple patch is needed to enable AP mode selection:
+http://johannes.sipsolutions.net/patches/kernel/all/LATEST/006-allow-ap-vlan-modes.patch
+
+
+# Build mac80211_hwsim:
+make
+
+# Load the module
+insmod ./mac80211_hwsim.ko
 
 # Run hostapd (AP) for wlan0
 hostapd hostapd.conf
diff -Nur hostap-06-d23bf71/Makefile hostap06/Makefile
--- hostap-06-d23bf71/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/Makefile	2009-08-12 13:04:26.000000000 +0300
@@ -0,0 +1,13 @@
+all: 
+	rm -f src/crypto/tls_internal.o
+	$(MAKE) -C wpa_supplicant
+	rm -f src/crypto/tls_internal.o
+	$(MAKE) -C hostapd
+
+clean:
+	$(MAKE) -C wpa_supplicant clean
+	$(MAKE) -C hostapd clean
+
+romfs:
+	$(MAKE) -C wpa_supplicant romfs
+	$(MAKE) -C hostapd romfs
diff -Nur hostap-06-d23bf71/radius_example/radius_example.c hostap06/radius_example/radius_example.c
--- hostap-06-d23bf71/radius_example/radius_example.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/radius_example/radius_example.c	2009-03-23 14:17:09.000000000 +0200
@@ -39,8 +39,7 @@
 /* Process the RADIUS frames from Authentication Server */
 static RadiusRxResult receive_auth(struct radius_msg *msg,
 				   struct radius_msg *req,
-				   const u8 *shared_secret,
-				   size_t shared_secret_len,
+				   u8 *shared_secret, size_t shared_secret_len,
 				   void *data)
 {
 	/* struct radius_ctx *ctx = data; */
@@ -154,7 +153,6 @@
 
 	radius_client_deinit(ctx.radius);
 	os_free(srv->shared_secret);
-	os_free(srv);
 
 	eloop_destroy();
 	os_program_deinit();
diff -Nur hostap-06-d23bf71/src/common/.gitignore hostap06/src/common/.gitignore
--- hostap-06-d23bf71/src/common/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/common/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/common/ieee802_11_common.c hostap06/src/common/ieee802_11_common.c
--- hostap-06-d23bf71/src/common/ieee802_11_common.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/common/ieee802_11_common.c	2009-03-23 14:17:09.000000000 +0200
@@ -49,33 +49,26 @@
 			elems->wpa_ie = pos;
 			elems->wpa_ie_len = elen;
 			break;
-		case WMM_OUI_TYPE:
-			/* WMM information element */
+		case WME_OUI_TYPE: /* this is a Wi-Fi WME info. element */
 			if (elen < 5) {
-				wpa_printf(MSG_MSGDUMP, "short WMM "
+				wpa_printf(MSG_MSGDUMP, "short WME "
 					   "information element ignored "
 					   "(len=%lu)",
 					   (unsigned long) elen);
 				return -1;
 			}
 			switch (pos[4]) {
-			case WMM_OUI_SUBTYPE_INFORMATION_ELEMENT:
-			case WMM_OUI_SUBTYPE_PARAMETER_ELEMENT:
-				/*
-				 * Share same pointer since only one of these
-				 * is used and they start with same data.
-				 * Length field can be used to distinguish the
-				 * IEs.
-				 */
-				elems->wmm = pos;
-				elems->wmm_len = elen;
+			case WME_OUI_SUBTYPE_INFORMATION_ELEMENT:
+			case WME_OUI_SUBTYPE_PARAMETER_ELEMENT:
+				elems->wme = pos;
+				elems->wme_len = elen;
 				break;
-			case WMM_OUI_SUBTYPE_TSPEC_ELEMENT:
-				elems->wmm_tspec = pos;
-				elems->wmm_tspec_len = elen;
+			case WME_OUI_SUBTYPE_TSPEC_ELEMENT:
+				elems->wme_tspec = pos;
+				elems->wme_tspec_len = elen;
 				break;
 			default:
-				wpa_printf(MSG_MSGDUMP, "unknown WMM "
+				wpa_printf(MSG_MSGDUMP, "unknown WME "
 					   "information element ignored "
 					   "(subtype=%d len=%lu)",
 					   pos[4], (unsigned long) elen);
diff -Nur hostap-06-d23bf71/src/common/ieee802_11_common.h hostap06/src/common/ieee802_11_common.h
--- hostap-06-d23bf71/src/common/ieee802_11_common.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/common/ieee802_11_common.h	2009-03-23 14:17:09.000000000 +0200
@@ -41,10 +41,10 @@
 	u8 wpa_ie_len;
 	u8 *rsn_ie;
 	u8 rsn_ie_len;
-	u8 *wmm; /* WMM Information or Parameter Element */
-	u8 wmm_len; /* 7 = WMM Information; 24 = WMM Parameter */
-	u8 *wmm_tspec;
-	u8 wmm_tspec_len;
+	u8 *wme;
+	u8 wme_len;
+	u8 *wme_tspec;
+	u8 wme_tspec_len;
 	u8 *wps_ie;
 	u8 wps_ie_len;
 	u8 *power_cap;
diff -Nur hostap-06-d23bf71/src/common/ieee802_11_defs.h hostap06/src/common/ieee802_11_defs.h
--- hostap-06-d23bf71/src/common/ieee802_11_defs.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/common/ieee802_11_defs.h	2009-03-23 14:17:09.000000000 +0200
@@ -210,18 +210,16 @@
 #define WLAN_ACTION_QOS 1
 #define WLAN_ACTION_DLS 2
 #define WLAN_ACTION_BLOCK_ACK 3
-#define WLAN_ACTION_PUBLIC 4
 #define WLAN_ACTION_RADIO_MEASUREMENT 5
 #define WLAN_ACTION_FT 6
-#define WLAN_ACTION_HT 7
 #define WLAN_ACTION_SA_QUERY 8
-#define WLAN_ACTION_WMM 17 /* WMM Specification 1.1 */
+#define WLAN_ACTION_WMM 17
 
-/* SA Query Action frame (IEEE 802.11w/D8.0, 7.4.9) */
+/* SA Query Action frame (IEEE 802.11w/D7.0, 7.4.9) */
 #define WLAN_SA_QUERY_REQUEST 0
 #define WLAN_SA_QUERY_RESPONSE 1
 
-#define WLAN_SA_QUERY_TR_ID_LEN 2
+#define WLAN_SA_QUERY_TR_ID_LEN 16
 
 /* Timeout Interval Type */
 #define WLAN_TIMEOUT_REASSOC_DEADLINE 1
@@ -302,7 +300,7 @@
 					u8 dialog_token;
 					u8 status_code;
 					u8 variable[0];
-				} STRUCT_PACKED wmm_action;
+				} STRUCT_PACKED wme_action;
 				struct{
 					u8 action_code;
 					u8 element_id;
@@ -563,27 +561,23 @@
 #define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
 				* 00:50:F2 */
 
-#define WMM_OUI_TYPE 2
-#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
-#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
-#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
-#define WMM_VERSION 1
-
-#define WMM_ACTION_CODE_ADDTS_REQ 0
-#define WMM_ACTION_CODE_ADDTS_RESP 1
-#define WMM_ACTION_CODE_DELTS 2
-
-#define WMM_ADDTS_STATUS_ADMISSION_ACCEPTED 0
-#define WMM_ADDTS_STATUS_INVALID_PARAMETERS 1
-/* 2 - Reserved */
-#define WMM_ADDTS_STATUS_REFUSED 3
-/* 4-255 - Reserved */
-
-/* WMM TSPEC Direction Field Values */
-#define WMM_TSPEC_DIRECTION_UPLINK 0
-#define WMM_TSPEC_DIRECTION_DOWNLINK 1
-/* 2 - Reserved */
-#define WMM_TSPEC_DIRECTION_BI_DIRECTIONAL 3
+#define WME_OUI_TYPE 2
+#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WME_VERSION 1
+
+#define WME_ACTION_CODE_SETUP_REQUEST 0
+#define WME_ACTION_CODE_SETUP_RESPONSE 1
+#define WME_ACTION_CODE_TEARDOWN 2
+
+#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
+#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
+#define WME_SETUP_RESPONSE_STATUS_REFUSED 3
+
+#define WME_TSPEC_DIRECTION_UPLINK 0
+#define WME_TSPEC_DIRECTION_DOWNLINK 1
+#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3
 
 
 #define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
diff -Nur hostap-06-d23bf71/src/common/nl80211_copy.h hostap06/src/common/nl80211_copy.h
--- hostap-06-d23bf71/src/common/nl80211_copy.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/common/nl80211_copy.h	2009-03-23 14:17:09.000000000 +0200
@@ -7,7 +7,7 @@
  * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
  * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
  * Copyright 2008 Michael Buesch <mb@bu3sch.de>
- * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
+ * Copyright 2008 Luis R. Rodriguez <lrodriguez@atheros.com>
  * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
  * Copyright 2008 Colin McCabe <colin@cozybit.com>
  *
@@ -25,8 +25,6 @@
  *
  */
 
-#include <linux/types.h>
-
 /**
  * DOC: Station handling
  *
@@ -48,10 +46,8 @@
  *	to get a list of all present wiphys.
  * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
  *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
- *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,
- *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE, %NL80211_ATTR_WIPHY_RETRY_SHORT,
- *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
- *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ, and/or
+ *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE.
  * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
  *	or rename notification. Has attributes %NL80211_ATTR_WIPHY and
  *	%NL80211_ATTR_WIPHY_NAME.
@@ -79,8 +75,8 @@
  * @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,
  *	%NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD.
  * @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,
- *	%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,
- *	and %NL80211_ATTR_KEY_SEQ attributes.
+ *	%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC and %NL80211_ATTR_KEY_CIPHER
+ *	attributes.
  * @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX
  *	or %NL80211_ATTR_MAC.
  *
@@ -146,12 +142,6 @@
  *	%NL80211_ATTR_IE. If the command succeeds, the requested data will be
  *	added to all specified management frames generated by
  *	kernel/firmware/driver.
- *	Note: This command has been removed and it is only reserved at this
- *	point to avoid re-using existing command number. The functionality this
- *	command was planned for has been provided with cleaner design with the
- *	option to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,
- *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,
- *	NL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE.
  *
  * @NL80211_CMD_GET_SCAN: get scan results
  * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
@@ -160,116 +150,6 @@
  * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
  *	partial scan results may be available
  *
- * @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation
- *      or noise level
- * @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to
- *	NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
- *
- * @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain
- * 	has been changed and provides details of the request information
- * 	that caused the change such as who initiated the regulatory request
- * 	(%NL80211_ATTR_REG_INITIATOR), the wiphy_idx
- * 	(%NL80211_ATTR_REG_ALPHA2) on which the request was made from if
- * 	the initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or
- * 	%NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain
- * 	set (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is
- * 	%NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on
- * 	to (%NL80211_ATTR_REG_ALPHA2).
- * @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon
- * 	has been found while world roaming thus enabling active scan or
- * 	any mode of operation that initiates TX (beacons) on a channel
- * 	where we would not have been able to do either before. As an example
- * 	if you are world roaming (regulatory domain set to world or if your
- * 	driver is using a custom world roaming regulatory domain) and while
- * 	doing a passive scan on the 5 GHz band you find an AP there (if not
- * 	on a DFS channel) you will now be able to actively scan for that AP
- * 	or use AP mode on your card on that same channel. Note that this will
- * 	never be used for channels 1-11 on the 2 GHz band as they are always
- * 	enabled world wide. This beacon hint is only sent if your device had
- * 	either disabled active scanning or beaconing on a channel. We send to
- * 	userspace the wiphy on which we removed a restriction from
- * 	(%NL80211_ATTR_WIPHY) and the channel on which this occurred
- * 	before (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)
- * 	the beacon hint was processed.
- *
- * @NL80211_CMD_AUTHENTICATE: authentication request and notification.
- *	This command is used both as a command (request to authenticate) and
- *	as an event on the "mlme" multicast group indicating completion of the
- *	authentication process.
- *	When used as a command, %NL80211_ATTR_IFINDEX is used to identify the
- *	interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
- *	BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
- *	the SSID (mainly for association, but is included in authentication
- *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
- *	to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
- *	is used to specify the authentication type. %NL80211_ATTR_IE is used to
- *	define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
- *	to be added to the frame.
- *	When used as an event, this reports reception of an Authentication
- *	frame in station and IBSS modes when the local MLME processed the
- *	frame, i.e., it was for the local STA and was received in correct
- *	state. This is similar to MLME-AUTHENTICATE.confirm primitive in the
- *	MLME SAP interface (kernel providing MLME, userspace SME). The
- *	included %NL80211_ATTR_FRAME attribute contains the management frame
- *	(including both the header and frame body, but not FCS). This event is
- *	also used to indicate if the authentication attempt timed out. In that
- *	case the %NL80211_ATTR_FRAME attribute is replaced with a
- *	%NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which
- *	pending authentication timed out).
- * @NL80211_CMD_ASSOCIATE: association request and notification; like
- *	NL80211_CMD_AUTHENTICATE but for Association and Reassociation
- *	(similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,
- *	MLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives).
- * @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like
- *	NL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to
- *	MLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication
- *	primitives).
- * @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like
- *	NL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to
- *	MLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives).
- *
- * @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael
- *	MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
- *	event includes %NL80211_ATTR_MAC to describe the source MAC address of
- *	the frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key
- *	type, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and
- *	%NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this
- *	event matches with MLME-MICHAELMICFAILURE.indication() primitive
- *
- * @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a
- *	FREQ attribute (for the initial frequency if no peer can be found)
- *	and optionally a MAC (as BSSID) and FREQ_FIXED attribute if those
- *	should be fixed rather than automatically determined. Can only be
- *	executed on a network interface that is UP, and fixed BSSID/FREQ
- *	may be rejected. Another optional parameter is the beacon interval,
- *	given in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not
- *	given defaults to 100 TU (102.4ms).
- * @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is
- *	determined by the network interface.
- *
- * @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute
- *	to identify the device, and the TESTDATA blob attribute to pass through
- *	to the driver.
- *
- * @NL80211_CMD_CONNECT: connection request and notification; this command
- *	requests to connect to a specified network but without separating
- *	auth and assoc steps. For this, you need to specify the SSID in a
- *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
- *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_MAC,
- *	%NL80211_ATTR_WIPHY_FREQ and %NL80211_ATTR_CONTROL_PORT.
- *	It is also sent as an event, with the BSSID and response IEs when the
- *	connection is established or failed to be established. This can be
- *	determined by the STATUS_CODE attribute.
- * @NL80211_CMD_ROAM: request that the card roam (currently not implemented),
- *	sent as an event when the card/driver roamed by itself.
- * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
- *	userspace that a connection was dropped by the AP or due to other
- *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
- *	%NL80211_ATTR_REASON_CODE attributes are used.
- *
- * @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices
- *	associated with this wiphy must be down and will follow.
- *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -315,7 +195,7 @@
 	NL80211_CMD_GET_MESH_PARAMS,
 	NL80211_CMD_SET_MESH_PARAMS,
 
-	NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
+	NL80211_CMD_SET_MGMT_EXTRA_IE,
 
 	NL80211_CMD_GET_REG,
 
@@ -324,31 +204,6 @@
 	NL80211_CMD_NEW_SCAN_RESULTS,
 	NL80211_CMD_SCAN_ABORTED,
 
-	NL80211_CMD_REG_CHANGE,
-
-	NL80211_CMD_AUTHENTICATE,
-	NL80211_CMD_ASSOCIATE,
-	NL80211_CMD_DEAUTHENTICATE,
-	NL80211_CMD_DISASSOCIATE,
-
-	NL80211_CMD_MICHAEL_MIC_FAILURE,
-
-	NL80211_CMD_REG_BEACON_HINT,
-
-	NL80211_CMD_JOIN_IBSS,
-	NL80211_CMD_LEAVE_IBSS,
-
-	NL80211_CMD_TESTMODE,
-
-	NL80211_CMD_CONNECT,
-	NL80211_CMD_ROAM,
-	NL80211_CMD_DISCONNECT,
-
-	NL80211_CMD_SET_WIPHY_NETNS,
-
-	NL80211_CMD_GET_SURVEY,
-	NL80211_CMD_NEW_SURVEY_RESULTS,
-
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -362,12 +217,6 @@
  */
 #define NL80211_CMD_SET_BSS NL80211_CMD_SET_BSS
 #define NL80211_CMD_SET_MGMT_EXTRA_IE NL80211_CMD_SET_MGMT_EXTRA_IE
-#define NL80211_CMD_REG_CHANGE NL80211_CMD_REG_CHANGE
-#define NL80211_CMD_AUTHENTICATE NL80211_CMD_AUTHENTICATE
-#define NL80211_CMD_ASSOCIATE NL80211_CMD_ASSOCIATE
-#define NL80211_CMD_DEAUTHENTICATE NL80211_CMD_DEAUTHENTICATE
-#define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
-#define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
 
 /**
  * enum nl80211_attrs - nl80211 netlink attributes
@@ -386,18 +235,6 @@
  *	NL80211_CHAN_HT20 = HT20 only
  *	NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
  *	NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
- * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
- *	less than or equal to the RTS threshold; allowed range: 1..255;
- *	dot11ShortRetryLimit; u8
- * @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is
- *	greater than the RTS threshold; allowed range: 1..255;
- *	dot11ShortLongLimit; u8
- * @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum
- *	length in octets for frames; allowed range: 256..8000, disable
- *	fragmentation with (u32)-1; dot11FragmentationThreshold; u32
- * @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length
- *	larger than or equal to this use RTS/CTS handshake); allowed range:
- *	0..65536, disable with (u32)-1; dot11RTSThreshold; u32
  *
  * @NL80211_ATTR_IFINDEX: network interface index of the device to operate on
  * @NL80211_ATTR_IFNAME: network interface name
@@ -421,7 +258,7 @@
  *
  * @NL80211_ATTR_STA_AID: Association ID for the station (u16)
  * @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of
- *	&enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)
+ *	&enum nl80211_sta_flags.
  * @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by
  *	IEEE 802.11 7.3.1.6 (u16).
  * @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported
@@ -482,122 +319,16 @@
  *
  * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
  *	a single scan request, a wiphy attribute.
- * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
- *	that can be added to a scan request
  *
  * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
  * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
  *	scanning and include a zero-length SSID (wildcard) for wildcard scan
+ * @NL80211_ATTR_SCAN_GENERATION: the scan generation increases whenever the
+ *	scan result list changes (BSS expired or added) so that applications
+ *	can verify that they got a single, consistent snapshot (when all dump
+ *	messages carried the same generation number)
  * @NL80211_ATTR_BSS: scan result BSS
  *
- * @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain
- * 	currently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*
- * @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently
- * 	set. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)
- *
- * @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies
- *	an array of command numbers (i.e. a mapping index to command number)
- *	that the driver for the given wiphy supports.
- *
- * @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header
- *	and body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and
- *	NL80211_CMD_ASSOCIATE events
- * @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)
- * @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,
- *	represented as a u32
- * @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and
- *	%NL80211_CMD_DISASSOCIATE, u16
- *
- * @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as
- *	a u32
- *
- * @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change
- * 	due to considerations from a beacon hint. This attribute reflects
- * 	the state of the channel _before_ the beacon hint processing. This
- * 	attributes consists of a nested attribute containing
- * 	NL80211_FREQUENCY_ATTR_*
- * @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change
- * 	due to considerations from a beacon hint. This attribute reflects
- * 	the state of the channel _after_ the beacon hint processing. This
- * 	attributes consists of a nested attribute containing
- * 	NL80211_FREQUENCY_ATTR_*
- *
- * @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported
- *	cipher suites
- *
- * @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look
- *	for other networks on different channels
- *
- * @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this
- *	is used, e.g., with %NL80211_CMD_AUTHENTICATE event
- *
- * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
- *	used for the association (&enum nl80211_mfp, represented as a u32);
- *	this attribute can be used
- *	with %NL80211_CMD_ASSOCIATE request
- *
- * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
- *	&struct nl80211_sta_flag_update.
- *
- * @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls
- *	IEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in
- *	station mode. If the flag is included in %NL80211_CMD_ASSOCIATE
- *	request, the driver will assume that the port is unauthorized until
- *	authorized by user space. Otherwise, port is marked authorized by
- *	default in station mode.
- *
- * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
- *	We recommend using nested, driver-specific attributes within this.
- *
- * @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT
- *	event was due to the AP disconnecting the station, and not due to
- *	a local disconnect request.
- * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
- *	event (u16)
- * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
- *	that protected APs should be used.
- *
- * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT and ASSOCIATE to
- *	indicate which unicast key ciphers will be used with the connection
- *	(an array of u32).
- * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT and ASSOCIATE to indicate
- *	which group key cipher will be used with the connection (a u32).
- * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT and ASSOCIATE to indicate
- *	which WPA version(s) the AP we want to associate with is using
- *	(a u32 with flags from &enum nl80211_wpa_versions).
- * @NL80211_ATTR_AKM_SUITES: Used with CONNECT and ASSOCIATE to indicate
- *	which key management algorithm(s) to use (an array of u32).
- *
- * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
- *	sent out by the card, for ROAM and successful CONNECT events.
- * @NL80211_ATTR_RESP_IE: (Re)association response information elements as
- *	sent by peer, for ROAM and successful CONNECT events.
- *
- * @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used by in ASSOCIATE
- *	commands to specify using a reassociate frame
- *
- * @NL80211_ATTR_KEY: key information in a nested attribute with
- *	%NL80211_KEY_* sub-attributes
- * @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()
- *	and join_ibss(), key information is in a nested attribute each
- *	with %NL80211_KEY_* sub-attributes
- *
- * @NL80211_ATTR_PID: Process ID of a network namespace.
- *
- * @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for
- *	dumps. This number increases whenever the object list being
- *	dumped changes, and as such userspace can verify that it has
- *	obtained a complete and consistent snapshot by verifying that
- *	all dump messages contain the same generation number. If it
- *	changed then the list changed and the dump should be repeated
- *	completely from scratch.
- *
- * @NL80211_ATTR_4ADDR: Use 4-address frames on a virtual interface
- *
- * @NL80211_ATTR_SURVEY_INFO: survey information about a channel, part of
- *      the survey response for %NL80211_CMD_GET_SURVEY, nested attribute
- *      containing info as possible, see &enum survey_info.
- *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
@@ -669,83 +400,19 @@
 
 	NL80211_ATTR_SCAN_FREQUENCIES,
 	NL80211_ATTR_SCAN_SSIDS,
-	NL80211_ATTR_GENERATION, /* replaces old SCAN_GENERATION */
+	NL80211_ATTR_SCAN_GENERATION,
 	NL80211_ATTR_BSS,
 
-	NL80211_ATTR_REG_INITIATOR,
-	NL80211_ATTR_REG_TYPE,
-
-	NL80211_ATTR_SUPPORTED_COMMANDS,
-
-	NL80211_ATTR_FRAME,
-	NL80211_ATTR_SSID,
-	NL80211_ATTR_AUTH_TYPE,
-	NL80211_ATTR_REASON_CODE,
-
-	NL80211_ATTR_KEY_TYPE,
-
-	NL80211_ATTR_MAX_SCAN_IE_LEN,
-	NL80211_ATTR_CIPHER_SUITES,
-
-	NL80211_ATTR_FREQ_BEFORE,
-	NL80211_ATTR_FREQ_AFTER,
-
-	NL80211_ATTR_FREQ_FIXED,
-
-
-	NL80211_ATTR_WIPHY_RETRY_SHORT,
-	NL80211_ATTR_WIPHY_RETRY_LONG,
-	NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
-	NL80211_ATTR_WIPHY_RTS_THRESHOLD,
-
-	NL80211_ATTR_TIMED_OUT,
-
-	NL80211_ATTR_USE_MFP,
-
-	NL80211_ATTR_STA_FLAGS2,
-
-	NL80211_ATTR_CONTROL_PORT,
-
-	NL80211_ATTR_TESTDATA,
-
-	NL80211_ATTR_PRIVACY,
-
-	NL80211_ATTR_DISCONNECTED_BY_AP,
-	NL80211_ATTR_STATUS_CODE,
-
-	NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
-	NL80211_ATTR_CIPHER_SUITE_GROUP,
-	NL80211_ATTR_WPA_VERSIONS,
-	NL80211_ATTR_AKM_SUITES,
-
-	NL80211_ATTR_REQ_IE,
-	NL80211_ATTR_RESP_IE,
-
-	NL80211_ATTR_PREV_BSSID,
-
-	NL80211_ATTR_KEY,
-	NL80211_ATTR_KEYS,
-
-	NL80211_ATTR_PID,
-
-	NL80211_ATTR_4ADDR,
-
-	NL80211_ATTR_SURVEY_INFO,
-
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
 	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
 };
 
-/* source-level API compatibility */
-#define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
-
 /*
  * Allow user space programs to use #ifdef on new attributes by defining them
  * here
  */
-#define NL80211_CMD_CONNECT NL80211_CMD_CONNECT
 #define NL80211_ATTR_HT_CAPABILITY NL80211_ATTR_HT_CAPABILITY
 #define NL80211_ATTR_BSS_BASIC_RATES NL80211_ATTR_BSS_BASIC_RATES
 #define NL80211_ATTR_WIPHY_TXQ_PARAMS NL80211_ATTR_WIPHY_TXQ_PARAMS
@@ -753,18 +420,6 @@
 #define NL80211_ATTR_WIPHY_CHANNEL_TYPE NL80211_ATTR_WIPHY_CHANNEL_TYPE
 #define NL80211_ATTR_MGMT_SUBTYPE NL80211_ATTR_MGMT_SUBTYPE
 #define NL80211_ATTR_IE NL80211_ATTR_IE
-#define NL80211_ATTR_REG_INITIATOR NL80211_ATTR_REG_INITIATOR
-#define NL80211_ATTR_REG_TYPE NL80211_ATTR_REG_TYPE
-#define NL80211_ATTR_FRAME NL80211_ATTR_FRAME
-#define NL80211_ATTR_SSID NL80211_ATTR_SSID
-#define NL80211_ATTR_AUTH_TYPE NL80211_ATTR_AUTH_TYPE
-#define NL80211_ATTR_REASON_CODE NL80211_ATTR_REASON_CODE
-#define NL80211_ATTR_CIPHER_SUITES_PAIRWISE NL80211_ATTR_CIPHER_SUITES_PAIRWISE
-#define NL80211_ATTR_CIPHER_SUITE_GROUP NL80211_ATTR_CIPHER_SUITE_GROUP
-#define NL80211_ATTR_WPA_VERSIONS NL80211_ATTR_WPA_VERSIONS
-#define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
-#define NL80211_ATTR_KEY NL80211_ATTR_KEY
-#define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
 
 #define NL80211_MAX_SUPP_RATES			32
 #define NL80211_MAX_SUPP_REG_RULES		32
@@ -773,9 +428,6 @@
 #define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY	24
 #define NL80211_HT_CAPABILITY_LEN		26
 
-#define NL80211_MAX_NR_CIPHER_SUITES		5
-#define NL80211_MAX_NR_AKM_SUITES		2
-
 /**
  * enum nl80211_iftype - (virtual) interface types
  *
@@ -834,18 +486,6 @@
 };
 
 /**
- * struct nl80211_sta_flag_update - station flags mask/set
- * @mask: mask of station flags to set
- * @set: which values to set them to
- *
- * Both mask and set contain bits as per &enum nl80211_sta_flags.
- */
-struct nl80211_sta_flag_update {
-	__u32 mask;
-	__u32 set;
-} __attribute__((packed));
-
-/**
  * enum nl80211_rate_info - bitrate information
  *
  * These attribute types are used with %NL80211_STA_INFO_TXRATE
@@ -913,14 +553,14 @@
  *
  * @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active
  * @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running
- * @NL80211_MPATH_FLAG_SN_VALID: the mesh path contains a valid SN
+ * @NL80211_MPATH_FLAG_DSN_VALID: the mesh path contains a valid DSN
  * @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set
  * @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded
  */
 enum nl80211_mpath_flags {
 	NL80211_MPATH_FLAG_ACTIVE =	1<<0,
 	NL80211_MPATH_FLAG_RESOLVING =	1<<1,
-	NL80211_MPATH_FLAG_SN_VALID =	1<<2,
+	NL80211_MPATH_FLAG_DSN_VALID =	1<<2,
 	NL80211_MPATH_FLAG_FIXED =	1<<3,
 	NL80211_MPATH_FLAG_RESOLVED =	1<<4,
 };
@@ -933,7 +573,7 @@
  *
  * @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved
  * @NL80211_ATTR_MPATH_FRAME_QLEN: number of queued frames for this destination
- * @NL80211_ATTR_MPATH_SN: destination sequence number
+ * @NL80211_ATTR_MPATH_DSN: destination sequence number
  * @NL80211_ATTR_MPATH_METRIC: metric (cost) of this mesh path
  * @NL80211_ATTR_MPATH_EXPTIME: expiration time for the path, in msec from now
  * @NL80211_ATTR_MPATH_FLAGS: mesh path flags, enumerated in
@@ -944,7 +584,7 @@
 enum nl80211_mpath_info {
 	__NL80211_MPATH_INFO_INVALID,
 	NL80211_MPATH_INFO_FRAME_QLEN,
-	NL80211_MPATH_INFO_SN,
+	NL80211_MPATH_INFO_DSN,
 	NL80211_MPATH_INFO_METRIC,
 	NL80211_MPATH_INFO_EXPTIME,
 	NL80211_MPATH_INFO_FLAGS,
@@ -1033,48 +673,6 @@
 };
 
 /**
- * enum nl80211_initiator - Indicates the initiator of a reg domain request
- * @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world
- * 	regulatory domain.
- * @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the
- * 	regulatory domain.
- * @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the
- * 	wireless core it thinks its knows the regulatory domain we should be in.
- * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
- * 	802.11 country information element with regulatory information it
- * 	thinks we should consider.
- */
-enum nl80211_reg_initiator {
-	NL80211_REGDOM_SET_BY_CORE,
-	NL80211_REGDOM_SET_BY_USER,
-	NL80211_REGDOM_SET_BY_DRIVER,
-	NL80211_REGDOM_SET_BY_COUNTRY_IE,
-};
-
-/**
- * enum nl80211_reg_type - specifies the type of regulatory domain
- * @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains
- *	to a specific country. When this is set you can count on the
- *	ISO / IEC 3166 alpha2 country code being valid.
- * @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory
- * 	domain.
- * @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom
- * 	driver specific world regulatory domain. These do not apply system-wide
- * 	and are only applicable to the individual devices which have requested
- * 	them to be applied.
- * @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product
- *	of an intersection between two regulatory domains -- the previously
- *	set regulatory domain on the system and the last accepted regulatory
- *	domain request to be processed.
- */
-enum nl80211_reg_type {
-	NL80211_REGDOM_TYPE_COUNTRY,
-	NL80211_REGDOM_TYPE_WORLD,
-	NL80211_REGDOM_TYPE_CUSTOM_WORLD,
-	NL80211_REGDOM_TYPE_INTERSECTION,
-};
-
-/**
  * enum nl80211_reg_rule_attr - regulatory rule attributes
  * @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional
  * 	considerations for a given frequency range. These are the
@@ -1135,26 +733,6 @@
 };
 
 /**
- * enum nl80211_survey_info - survey information
- *
- * These attribute types are used with %NL80211_ATTR_SURVEY_INFO
- * when getting information about a survey.
- *
- * @__NL80211_SURVEY_INFO_INVALID: attribute number 0 is reserved
- * @NL80211_SURVEY_INFO_FREQUENCY: center frequency of channel
- * @NL80211_SURVEY_INFO_NOISE: noise level of channel (u8, dBm)
- */
-enum nl80211_survey_info {
-	__NL80211_SURVEY_INFO_INVALID,
-	NL80211_SURVEY_INFO_FREQUENCY,
-	NL80211_SURVEY_INFO_NOISE,
-
-	/* keep last */
-	__NL80211_SURVEY_INFO_AFTER_LAST,
-	NL80211_SURVEY_INFO_MAX = __NL80211_SURVEY_INFO_AFTER_LAST - 1
-};
-
-/**
  * enum nl80211_mntr_flags - monitor configuration flags
  *
  * Monitor configuration flags.
@@ -1234,8 +812,6 @@
  * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
  * that it takes for an HWMP information element to propagate across the mesh
  *
- * @NL80211_MESHCONF_ROOTMODE: whether root mode is enabled or not
- *
  * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
  *
  * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
@@ -1255,7 +831,6 @@
 	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
 	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
 	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
-	NL80211_MESHCONF_HWMP_ROOTMODE,
 
 	/* keep last */
 	__NL80211_MESHCONF_ATTR_AFTER_LAST,
@@ -1317,8 +892,6 @@
  *	in mBm (100 * dBm) (s32)
  * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
  *	in unspecified units, scaled to 0..100 (u8)
- * @NL80211_BSS_STATUS: status, if this BSS is "used"
- * @NL80211_BSS_SEEN_MS_AGO: age of this BSS entry in ms
  * @__NL80211_BSS_AFTER_LAST: internal
  * @NL80211_BSS_MAX: highest BSS attribute
  */
@@ -1332,103 +905,10 @@
 	NL80211_BSS_INFORMATION_ELEMENTS,
 	NL80211_BSS_SIGNAL_MBM,
 	NL80211_BSS_SIGNAL_UNSPEC,
-	NL80211_BSS_STATUS,
-	NL80211_BSS_SEEN_MS_AGO,
 
 	/* keep last */
 	__NL80211_BSS_AFTER_LAST,
 	NL80211_BSS_MAX = __NL80211_BSS_AFTER_LAST - 1
 };
 
-/**
- * enum nl80211_bss_status - BSS "status"
- */
-enum nl80211_bss_status {
-	NL80211_BSS_STATUS_AUTHENTICATED,
-	NL80211_BSS_STATUS_ASSOCIATED,
-	NL80211_BSS_STATUS_IBSS_JOINED,
-};
-
-/**
- * enum nl80211_auth_type - AuthenticationType
- *
- * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
- * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
- * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
- * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
- * @__NL80211_AUTHTYPE_NUM: internal
- * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
- * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
- *	trying multiple times); this is invalid in netlink -- leave out
- *	the attribute for this on CONNECT commands.
- */
-enum nl80211_auth_type {
-	NL80211_AUTHTYPE_OPEN_SYSTEM,
-	NL80211_AUTHTYPE_SHARED_KEY,
-	NL80211_AUTHTYPE_FT,
-	NL80211_AUTHTYPE_NETWORK_EAP,
-
-	/* keep last */
-	__NL80211_AUTHTYPE_NUM,
-	NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
-	NL80211_AUTHTYPE_AUTOMATIC
-};
-
-/**
- * enum nl80211_key_type - Key Type
- * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
- * @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key
- * @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)
- */
-enum nl80211_key_type {
-	NL80211_KEYTYPE_GROUP,
-	NL80211_KEYTYPE_PAIRWISE,
-	NL80211_KEYTYPE_PEERKEY,
-};
-
-/**
- * enum nl80211_mfp - Management frame protection state
- * @NL80211_MFP_NO: Management frame protection not used
- * @NL80211_MFP_REQUIRED: Management frame protection required
- */
-enum nl80211_mfp {
-	NL80211_MFP_NO,
-	NL80211_MFP_REQUIRED,
-};
-
-enum nl80211_wpa_versions {
-	NL80211_WPA_VERSION_1 = 1 << 0,
-	NL80211_WPA_VERSION_2 = 1 << 1,
-};
-
-/**
- * enum nl80211_key_attributes - key attributes
- * @__NL80211_KEY_INVALID: invalid
- * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
- *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
- *	keys
- * @NL80211_KEY_IDX: key ID (u8, 0-3)
- * @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
- *	section 7.3.2.25.1, e.g. 0x000FAC04)
- * @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
- *	CCMP keys, each six bytes in little endian
- * @NL80211_KEY_DEFAULT: flag indicating default key
- * @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key
- * @__NL80211_KEY_AFTER_LAST: internal
- * @NL80211_KEY_MAX: highest key attribute
- */
-enum nl80211_key_attributes {
-	__NL80211_KEY_INVALID,
-	NL80211_KEY_DATA,
-	NL80211_KEY_IDX,
-	NL80211_KEY_CIPHER,
-	NL80211_KEY_SEQ,
-	NL80211_KEY_DEFAULT,
-	NL80211_KEY_DEFAULT_MGMT,
-
-	/* keep last */
-	__NL80211_KEY_AFTER_LAST,
-	NL80211_KEY_MAX = __NL80211_KEY_AFTER_LAST - 1
-};
-
 #endif /* __LINUX_NL80211_H */
diff -Nur hostap-06-d23bf71/src/common/version.h hostap06/src/common/version.h
--- hostap-06-d23bf71/src/common/version.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/common/version.h	2009-08-12 15:35:19.000000000 +0300
@@ -1,6 +1,6 @@
 #ifndef VERSION_H
 #define VERSION_H
 
-#define VERSION_STR "0.6.10"
+#define VERSION_STR "0.6.9-mtlk02"
 
 #endif /* VERSION_H */
diff -Nur hostap-06-d23bf71/src/crypto/crypto_cryptoapi.c hostap06/src/crypto/crypto_cryptoapi.c
--- hostap-06-d23bf71/src/crypto/crypto_cryptoapi.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/crypto_cryptoapi.c	2009-03-23 14:17:09.000000000 +0200
@@ -1,6 +1,6 @@
 /*
- * Crypto wrapper for Microsoft CryptoAPI
- * Copyright (c) 2005-2009, Jouni Malinen <j@w1.fi>
+ * WPA Supplicant / Crypto wrapper for Microsoft CryptoAPI
+ * Copyright (c) 2005-2006, Jouni Malinen <j@w1.fi>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -40,6 +40,12 @@
  * define here whatever extra is needed.
  */
 
+static PCCERT_CONTEXT WINAPI
+(*CertCreateCertificateContext)(DWORD dwCertEncodingType,
+				const BYTE *pbCertEncoded,
+				DWORD cbCertEncoded)
+= NULL; /* to be loaded from crypt32.dll */
+
 static BOOL WINAPI
 (*CryptImportPublicKeyInfo)(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType,
 			    PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
@@ -53,7 +59,7 @@
 	/* MinGW does not yet have full CryptoAPI support, so load the needed
 	 * function here. */
 
-	if (CryptImportPublicKeyInfo)
+	if (CertCreateCertificateContext)
 		return 0;
 
 	dll = LoadLibrary("crypt32");
@@ -63,6 +69,15 @@
 		return -1;
 	}
 
+	CertCreateCertificateContext = (void *) GetProcAddress(
+		dll, "CertCreateCertificateContext");
+	if (CertCreateCertificateContext == NULL) {
+		wpa_printf(MSG_DEBUG, "CryptoAPI: Could not get "
+			   "CertCreateCertificateContext() address from "
+			   "crypt32 library");
+		return -1;
+	}
+
 	CryptImportPublicKeyInfo = GetProcAddress(
 		dll, "CryptImportPublicKeyInfo");
 	if (CryptImportPublicKeyInfo == NULL) {
diff -Nur hostap-06-d23bf71/src/crypto/dh_groups.c hostap06/src/crypto/dh_groups.c
--- hostap-06-d23bf71/src/crypto/dh_groups.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/dh_groups.c	2009-03-23 14:17:09.000000000 +0200
@@ -19,8 +19,6 @@
 #include "dh_groups.h"
 
 
-#ifdef ALL_DH_GROUPS
-
 /* RFC 4306, B.1. Group 1 - 768 Bit MODP
  * Generator: 2
  * Prime: 2^768 - 2 ^704 - 1 + 2^64 * { [2^638 pi] + 149686 }
@@ -65,8 +63,6 @@
 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 };
 
-#endif /* ALL_DH_GROUPS */
-
 /* RFC 3526, 2. Group 5 - 1536 Bit MODP
  * Generator: 2
  * Prime: 2^1536 - 2^1472 - 1 + 2^64 * { [2^1406 pi] + 741804 }
@@ -99,8 +95,6 @@
 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 };
 
-#ifdef ALL_DH_GROUPS
-
 /* RFC 3526, 3. Group 14 - 2048 Bit MODP
  * Generator: 2
  * Prime: 2^2048 - 2^1984 - 1 + 2^64 * { [2^1918 pi] + 124476 }
@@ -509,8 +503,6 @@
 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 };
 
-#endif /* ALL_DH_GROUPS */
-
 
 #define DH_GROUP(id) \
 { id, dh_group ## id ## _generator, sizeof(dh_group ## id ## _generator), \
@@ -518,16 +510,14 @@
 		
 
 static struct dh_group dh_groups[] = {
-	DH_GROUP(5),
-#ifdef ALL_DH_GROUPS
 	DH_GROUP(1),
 	DH_GROUP(2),
+	DH_GROUP(5),
 	DH_GROUP(14),
 	DH_GROUP(15),
 	DH_GROUP(16),
 	DH_GROUP(17),
 	DH_GROUP(18)
-#endif /* ALL_DH_GROUPS */
 };
 
 #define NUM_DH_GROUPS (sizeof(dh_groups) / sizeof(dh_groups[0]))
diff -Nur hostap-06-d23bf71/src/crypto/.gitignore hostap06/src/crypto/.gitignore
--- hostap-06-d23bf71/src/crypto/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/crypto/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/crypto/ms_funcs.c hostap06/src/crypto/ms_funcs.c
--- hostap-06-d23bf71/src/crypto/ms_funcs.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/ms_funcs.c	2009-03-23 14:17:09.000000000 +0200
@@ -379,7 +379,7 @@
 	 */
 	pos = &pw_block[2 * 256];
 	WPA_PUT_LE16(pos, password_len * 2);
-	rc4_skip(password_hash, 16, 0, pw_block, PWBLOCK_LEN);
+	rc4(pw_block, PWBLOCK_LEN, password_hash, 16);
 	return 0;
 }
 
diff -Nur hostap-06-d23bf71/src/crypto/rc4.c hostap06/src/crypto/rc4.c
--- hostap-06-d23bf71/src/crypto/rc4.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/rc4.c	2009-03-23 14:17:09.000000000 +0200
@@ -68,3 +68,19 @@
 		*pos++ ^= S[(S[i] + S[j]) & 0xff];
 	}
 }
+
+
+/**
+ * rc4 - XOR RC4 stream to given data
+ * @buf: data to be XOR'ed with RC4 stream
+ * @len: buf length
+ * @key: RC4 key
+ * @key_len: RC4 key length
+ *
+ * Generate RC4 pseudo random stream for the given key and XOR this with the
+ * data buffer to perform RC4 encryption/decryption.
+ */
+void rc4(u8 *buf, size_t len, const u8 *key, size_t key_len)
+{
+	rc4_skip(key, key_len, 0, buf, len);
+}
diff -Nur hostap-06-d23bf71/src/crypto/rc4.h hostap06/src/crypto/rc4.h
--- hostap-06-d23bf71/src/crypto/rc4.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/rc4.h	2009-03-23 14:17:09.000000000 +0200
@@ -17,5 +17,6 @@
 
 void rc4_skip(const u8 *key, size_t keylen, size_t skip,
 	      u8 *data, size_t data_len);
+void rc4(u8 *buf, size_t len, const u8 *key, size_t key_len);
 
 #endif /* RC4_H */
diff -Nur hostap-06-d23bf71/src/crypto/sha1.c hostap06/src/crypto/sha1.c
--- hostap-06-d23bf71/src/crypto/sha1.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/sha1.c	2009-03-23 14:17:09.000000000 +0200
@@ -606,8 +606,8 @@
 	} CHAR64LONG16;
 	CHAR64LONG16* block;
 #ifdef SHA1HANDSOFF
-	CHAR64LONG16 workspace;
-	block = &workspace;
+	u32 workspace[16];
+	block = (CHAR64LONG16 *) workspace;
 	os_memcpy(block, buffer, 64);
 #else
 	block = (CHAR64LONG16 *) buffer;
diff -Nur hostap-06-d23bf71/src/crypto/tls_gnutls.c hostap06/src/crypto/tls_gnutls.c
--- hostap-06-d23bf71/src/crypto/tls_gnutls.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/tls_gnutls.c	2009-03-23 14:17:09.000000000 +0200
@@ -35,12 +35,8 @@
 #include "tls.h"
 
 
-#ifndef TLS_RANDOM_SIZE
 #define TLS_RANDOM_SIZE 32
-#endif
-#ifndef TLS_MASTER_SIZE
 #define TLS_MASTER_SIZE 48
-#endif
 
 
 #if LIBGNUTLS_VERSION_NUMBER < 0x010302
@@ -595,17 +591,6 @@
 				return -1;
 			}
 		}
-
-		if (params->flags & TLS_CONN_ALLOW_SIGN_RSA_MD5) {
-			gnutls_certificate_set_verify_flags(
-				conn->xcred, GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5);
-		}
-
-		if (params->flags & TLS_CONN_DISABLE_TIME_CHECKS) {
-			gnutls_certificate_set_verify_flags(
-				conn->xcred,
-				GNUTLS_VERIFY_DISABLE_TIME_CHECKS);
-		}
 	}
 
 	if (params->client_cert && params->private_key) {
@@ -726,18 +711,6 @@
 				goto fail;
 			}
 		}
-
-		if (params->flags & TLS_CONN_ALLOW_SIGN_RSA_MD5) {
-			gnutls_certificate_set_verify_flags(
-				global->xcred,
-				GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5);
-		}
-
-		if (params->flags & TLS_CONN_DISABLE_TIME_CHECKS) {
-			gnutls_certificate_set_verify_flags(
-				global->xcred,
-				GNUTLS_VERIFY_DISABLE_TIME_CHECKS);
-		}
 	}
 
 	if (params->client_cert && params->private_key) {
@@ -870,8 +843,7 @@
 }
 
 
-static int tls_connection_verify_peer(struct tls_connection *conn,
-				      gnutls_alert_description_t *err)
+static int tls_connection_verify_peer(struct tls_connection *conn)
 {
 	unsigned int status, num_certs, i;
 	struct os_time now;
@@ -881,39 +853,22 @@
 	if (gnutls_certificate_verify_peers2(conn->session, &status) < 0) {
 		wpa_printf(MSG_INFO, "TLS: Failed to verify peer "
 			   "certificate chain");
-		*err = GNUTLS_A_INTERNAL_ERROR;
 		return -1;
 	}
 
 	if (conn->verify_peer && (status & GNUTLS_CERT_INVALID)) {
 		wpa_printf(MSG_INFO, "TLS: Peer certificate not trusted");
-		if (status & GNUTLS_CERT_INSECURE_ALGORITHM) {
-			wpa_printf(MSG_INFO, "TLS: Certificate uses insecure "
-				   "algorithm");
-			*err = GNUTLS_A_INSUFFICIENT_SECURITY;
-		}
-		if (status & GNUTLS_CERT_NOT_ACTIVATED) {
-			wpa_printf(MSG_INFO, "TLS: Certificate not yet "
-				   "activated");
-			*err = GNUTLS_A_CERTIFICATE_EXPIRED;
-		}
-		if (status & GNUTLS_CERT_EXPIRED) {
-			wpa_printf(MSG_INFO, "TLS: Certificate expired");
-			*err = GNUTLS_A_CERTIFICATE_EXPIRED;
-		}
 		return -1;
 	}
 
 	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
 		wpa_printf(MSG_INFO, "TLS: Peer certificate does not have a "
 			   "known issuer");
-		*err = GNUTLS_A_UNKNOWN_CA;
 		return -1;
 	}
 
 	if (status & GNUTLS_CERT_REVOKED) {
 		wpa_printf(MSG_INFO, "TLS: Peer certificate has been revoked");
-		*err = GNUTLS_A_CERTIFICATE_REVOKED;
 		return -1;
 	}
 
@@ -923,7 +878,6 @@
 	if (certs == NULL) {
 		wpa_printf(MSG_INFO, "TLS: No peer certificate chain "
 			   "received");
-		*err = GNUTLS_A_UNKNOWN_CA;
 		return -1;
 	}
 
@@ -933,7 +887,6 @@
 		if (gnutls_x509_crt_init(&cert) < 0) {
 			wpa_printf(MSG_INFO, "TLS: Certificate initialization "
 				   "failed");
-			*err = GNUTLS_A_BAD_CERTIFICATE;
 			return -1;
 		}
 
@@ -942,7 +895,6 @@
 			wpa_printf(MSG_INFO, "TLS: Could not parse peer "
 				   "certificate %d/%d", i + 1, num_certs);
 			gnutls_x509_crt_deinit(cert);
-			*err = GNUTLS_A_BAD_CERTIFICATE;
 			return -1;
 		}
 
@@ -968,7 +920,6 @@
 				   "not valid at this time",
 				   i + 1, num_certs);
 			gnutls_x509_crt_deinit(cert);
-			*err = GNUTLS_A_CERTIFICATE_EXPIRED;
 			return -1;
 		}
 
@@ -1030,15 +981,12 @@
 		}
 	} else {
 		size_t size;
-		gnutls_alert_description_t err;
 
-		if (conn->verify_peer &&
-		    tls_connection_verify_peer(conn, &err)) {
+		if (conn->verify_peer && tls_connection_verify_peer(conn)) {
 			wpa_printf(MSG_INFO, "TLS: Peer certificate chain "
 				   "failed validation");
 			conn->failed++;
-			gnutls_alert_send(conn->session, GNUTLS_AL_FATAL, err);
-			goto out;
+			return NULL;
 		}
 
 #ifdef CONFIG_GNUTLS_EXTRA
@@ -1075,7 +1023,6 @@
 		}
 	}
 
-out:
 	out_data = conn->push_buf;
 	*out_len = conn->push_buf_len;
 	conn->push_buf = NULL;
diff -Nur hostap-06-d23bf71/src/crypto/tls.h hostap06/src/crypto/tls.h
--- hostap-06-d23bf71/src/crypto/tls.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/tls.h	2009-03-23 14:17:09.000000000 +0200
@@ -34,9 +34,6 @@
 	const char *pkcs11_module_path;
 };
 
-#define TLS_CONN_ALLOW_SIGN_RSA_MD5 BIT(0)
-#define TLS_CONN_DISABLE_TIME_CHECKS BIT(1)
-
 /**
  * struct tls_connection_params - Parameters for TLS connection
  * @ca_cert: File or reference name for CA X.509 certificate in PEM or DER
@@ -71,7 +68,6 @@
  * @cert_id: the certificate's id when using engine
  * @ca_cert_id: the CA certificate's id when using engine
  * @tls_ia: Whether to enable TLS/IA (for EAP-TTLSv1)
- * @flags: Parameter options (TLS_CONN_*)
  *
  * TLS connection parameters to be configured with tls_connection_set_params()
  * and tls_global_set_params().
@@ -107,8 +103,6 @@
 	const char *key_id;
 	const char *cert_id;
 	const char *ca_cert_id;
-
-	unsigned int flags;
 };
 
 
diff -Nur hostap-06-d23bf71/src/crypto/tls_openssl.c hostap06/src/crypto/tls_openssl.c
--- hostap-06-d23bf71/src/crypto/tls_openssl.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/crypto/tls_openssl.c	2009-03-23 14:17:09.000000000 +0200
@@ -108,9 +108,71 @@
  * MinGW does not yet include all the needed definitions for CryptoAPI, so
  * define here whatever extra is needed.
  */
+#define CALG_SSL3_SHAMD5 (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5)
 #define CERT_SYSTEM_STORE_CURRENT_USER (1 << 16)
 #define CERT_STORE_READONLY_FLAG 0x00008000
 #define CERT_STORE_OPEN_EXISTING_FLAG 0x00004000
+#define CRYPT_ACQUIRE_COMPARE_KEY_FLAG 0x00000004
+
+static BOOL WINAPI
+(*CryptAcquireCertificatePrivateKey)(PCCERT_CONTEXT pCert, DWORD dwFlags,
+				     void *pvReserved, HCRYPTPROV *phCryptProv,
+				     DWORD *pdwKeySpec, BOOL *pfCallerFreeProv)
+= NULL; /* to be loaded from crypt32.dll */
+
+#ifdef CONFIG_MINGW32_LOAD_CERTENUM
+static PCCERT_CONTEXT WINAPI
+(*CertEnumCertificatesInStore)(HCERTSTORE hCertStore,
+			       PCCERT_CONTEXT pPrevCertContext)
+= NULL; /* to be loaded from crypt32.dll */
+#endif /* CONFIG_MINGW32_LOAD_CERTENUM */
+
+static int mingw_load_crypto_func(void)
+{
+	HINSTANCE dll;
+
+	/* MinGW does not yet have full CryptoAPI support, so load the needed
+	 * function here. */
+
+	if (CryptAcquireCertificatePrivateKey)
+		return 0;
+
+	dll = LoadLibrary("crypt32");
+	if (dll == NULL) {
+		wpa_printf(MSG_DEBUG, "CryptoAPI: Could not load crypt32 "
+			   "library");
+		return -1;
+	}
+
+	CryptAcquireCertificatePrivateKey = GetProcAddress(
+		dll, "CryptAcquireCertificatePrivateKey");
+	if (CryptAcquireCertificatePrivateKey == NULL) {
+		wpa_printf(MSG_DEBUG, "CryptoAPI: Could not get "
+			   "CryptAcquireCertificatePrivateKey() address from "
+			   "crypt32 library");
+		return -1;
+	}
+
+#ifdef CONFIG_MINGW32_LOAD_CERTENUM
+	CertEnumCertificatesInStore = (void *) GetProcAddress(
+		dll, "CertEnumCertificatesInStore");
+	if (CertEnumCertificatesInStore == NULL) {
+		wpa_printf(MSG_DEBUG, "CryptoAPI: Could not get "
+			   "CertEnumCertificatesInStore() address from "
+			   "crypt32 library");
+		return -1;
+	}
+#endif /* CONFIG_MINGW32_LOAD_CERTENUM */
+
+	return 0;
+}
+
+#else /* __MINGW32_VERSION */
+
+static int mingw_load_crypto_func(void)
+{
+	return 0;
+}
 
 #endif /* __MINGW32_VERSION */
 
@@ -341,6 +403,9 @@
 		goto err;
 	}
 
+	if (mingw_load_crypto_func())
+		goto err;
+
 	if (!CryptAcquireCertificatePrivateKey(priv->cert,
 					       CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
 					       NULL, &priv->crypt_prov,
@@ -411,6 +476,9 @@
 	WCHAR *wstore;
 #endif /* UNICODE */
 
+	if (mingw_load_crypto_func())
+		return -1;
+
 	if (name == NULL || strncmp(name, "cert_store://", 13) != 0)
 		return -1;
 
@@ -667,23 +735,11 @@
 	if (tls_openssl_ref_count == 0) {
 		SSL_load_error_strings();
 		SSL_library_init();
-#ifndef OPENSSL_NO_SHA256
-		EVP_add_digest(EVP_sha256());
-#endif /* OPENSSL_NO_SHA256 */
 		/* TODO: if /dev/urandom is available, PRNG is seeded
 		 * automatically. If this is not the case, random data should
 		 * be added here. */
 
 #ifdef PKCS12_FUNCS
-#ifndef OPENSSL_NO_RC2
-		/*
-		 * 40-bit RC2 is commonly used in PKCS#12 files, so enable it.
-		 * This is enabled by PKCS12_PBE_add() in OpenSSL 0.9.8
-		 * versions, but it looks like OpenSSL 1.0.0 does not do that
-		 * anymore.
-		 */
-		EVP_add_cipher(EVP_rc2_40_cbc());
-#endif /* OPENSSL_NO_RC2 */
 		PKCS12_PBE_add();
 #endif  /* PKCS12_FUNCS */
 	}
@@ -2049,18 +2105,9 @@
 		if (*appl_data) {
 			res = SSL_read(conn->ssl, *appl_data, in_len);
 			if (res < 0) {
-				int err = SSL_get_error(conn->ssl, res);
-				if (err == SSL_ERROR_WANT_READ ||
-				    err == SSL_ERROR_WANT_WRITE) {
-					wpa_printf(MSG_DEBUG,
-						   "SSL: No Application Data "
-						   "included");
-				} else {
-					tls_show_errors(MSG_INFO, __func__,
-							"Failed to read "
-							"possible "
-							"Application Data");
-				}
+				tls_show_errors(MSG_INFO, __func__,
+						"Failed to read possible "
+						"Application Data");
 				os_free(*appl_data);
 				*appl_data = NULL;
 			} else {
diff -Nur hostap-06-d23bf71/src/drivers/driver_bsd.c hostap06/src/drivers/driver_bsd.c
--- hostap-06-d23bf71/src/drivers/driver_bsd.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_bsd.c	2009-03-23 14:17:09.000000000 +0200
@@ -386,6 +386,10 @@
 	/* XXX error handling is wrong but unclear what to do... */
 	if (wpa_driver_bsd_set_wpa_ie(drv, params->wpa_ie, params->wpa_ie_len) < 0)
 		return -1;
+#ifndef NEW_FREEBSD_MLME_ASSOC
+	if (wpa_driver_bsd_set_ssid(drv, params->ssid, params->ssid_len) < 0)
+		return -1;
+#endif
 
 	privacy = !(params->pairwise_suite == CIPHER_NONE &&
 	    params->group_suite == CIPHER_NONE &&
@@ -403,9 +407,11 @@
 
 	os_memset(&mlme, 0, sizeof(mlme));
 	mlme.im_op = IEEE80211_MLME_ASSOC;
+#ifdef NEW_FREEBSD_MLME_ASSOC
 	if (params->ssid != NULL)
 		os_memcpy(mlme.im_ssid, params->ssid, params->ssid_len);
 	mlme.im_ssid_len = params->ssid_len;
+#endif
 	if (params->bssid != NULL)
 		os_memcpy(mlme.im_macaddr, params->bssid, IEEE80211_ADDR_LEN);
 	if (set80211var(drv, IEEE80211_IOC_MLME, &mlme, sizeof(mlme)) < 0)
diff -Nur hostap-06-d23bf71/src/drivers/driver.h hostap06/src/drivers/driver.h
--- hostap-06-d23bf71/src/drivers/driver.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver.h	2009-05-22 14:31:10.000000000 +0300
@@ -131,7 +131,7 @@
  * @ifname: Interface name that can be used with init() or init2()
  * @desc: Human readable adapter description (e.g., vendor/model) or NULL if
  *	not available
- * @drv_name: struct wpa_driver_ops::name (note: unlike other strings, this one
+ * @drv_bame: struct wpa_driver_ops::name (note: unlike other strings, this one
  *	is not an allocated copy, i.e., get_interfaces() caller will not free
  *	this)
  */
diff -Nur hostap-06-d23bf71/src/drivers/driver_madwifi.c hostap06/src/drivers/driver_madwifi.c
--- hostap-06-d23bf71/src/drivers/driver_madwifi.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_madwifi.c	2009-03-23 14:17:09.000000000 +0200
@@ -11,10 +11,6 @@
  * license.
  *
  * See README and COPYING for more details.
- *
- * Please note that madwifi supports WPA configuration via Linux wireless
- * extensions and if the kernel includes support for this, driver_wext.c should
- * be used instead of this driver wrapper.
  */
 
 #include "includes.h"
diff -Nur hostap-06-d23bf71/src/drivers/driver_ndiswrapper.c hostap06/src/drivers/driver_ndiswrapper.c
--- hostap-06-d23bf71/src/drivers/driver_ndiswrapper.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_ndiswrapper.c	2009-03-23 14:17:09.000000000 +0200
@@ -11,10 +11,6 @@
  * license.
  *
  * See README and COPYING for more details.
- *
- * Please note that ndiswrapper supports WPA configuration via Linux wireless
- * extensions and if the kernel includes support for this, driver_wext.c should
- * be used instead of this driver wrapper.
  */
 
 #include "includes.h"
@@ -349,7 +345,7 @@
 
 const struct wpa_driver_ops wpa_driver_ndiswrapper_ops = {
 	.name = "ndiswrapper",
-	.desc = "Linux ndiswrapper (deprecated; use wext)",
+	.desc = "Linux ndiswrapper",
 	.set_wpa = wpa_ndiswrapper_set_wpa,
 	.set_key = wpa_ndiswrapper_set_key,
 	.set_countermeasures = wpa_ndiswrapper_set_countermeasures,
diff -Nur hostap-06-d23bf71/src/drivers/driver_nl80211.c hostap06/src/drivers/driver_nl80211.c
--- hostap-06-d23bf71/src/drivers/driver_nl80211.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_nl80211.c	2009-05-22 14:31:10.000000000 +0300
@@ -241,9 +241,8 @@
 	req.ifinfo.ifi_change = 0;
 
 	if (linkmode != -1) {
-		rta = aliasing_hide_typecast(
-			((char *) &req + NLMSG_ALIGN(req.hdr.nlmsg_len)),
-			struct rtattr);
+		rta = (struct rtattr *)
+			((char *) &req + NLMSG_ALIGN(req.hdr.nlmsg_len));
 		rta->rta_type = IFLA_LINKMODE;
 		rta->rta_len = RTA_LENGTH(sizeof(char));
 		*((char *) RTA_DATA(rta)) = linkmode;
@@ -982,9 +981,6 @@
 	}
 
 	switch (gnlh->cmd) {
-	case NL80211_CMD_TRIGGER_SCAN:
-		wpa_printf(MSG_DEBUG, "nl80211: Scan trigger");
-		break;
 	case NL80211_CMD_NEW_SCAN_RESULTS:
 		wpa_printf(MSG_DEBUG, "nl80211: New scan results available");
 		drv->scan_complete_events = 1;
@@ -1848,9 +1844,6 @@
 			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_TKIP;
 		if (range->enc_capa & IW_ENC_CAPA_CIPHER_CCMP)
 			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_CCMP;
-		drv->capa.auth = WPA_DRIVER_AUTH_OPEN |
-			WPA_DRIVER_AUTH_SHARED |
-			WPA_DRIVER_AUTH_LEAP;
 		wpa_printf(MSG_DEBUG, "  capabilities: key_mgmt 0x%x enc 0x%x",
 			   drv->capa.key_mgmt, drv->capa.enc);
 	} else {
diff -Nur hostap-06-d23bf71/src/drivers/driver_roboswitch.c hostap06/src/drivers/driver_roboswitch.c
--- hostap-06-d23bf71/src/drivers/driver_roboswitch.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_roboswitch.c	2009-03-23 14:17:09.000000000 +0200
@@ -16,18 +16,12 @@
 #include <sys/ioctl.h>
 #include <linux/if.h>
 #include <linux/sockios.h>
-#include <linux/if_ether.h>
 #include <linux/mii.h>
 
 #include "common.h"
 #include "driver.h"
-#include "l2_packet/l2_packet.h"
 
-#ifndef ETH_P_EAPOL
-#define ETH_P_EAPOL		0x888e
-#endif
-
-#define ROBO_PHY_ADDR		0x1e	/* RoboSwitch PHY address */
+#define ROBO_PHY_ADDR		0x1E	/* RoboSwitch PHY address */
 
 /* MII access registers */
 #define ROBO_MII_PAGE		0x10	/* MII page register */
@@ -52,10 +46,10 @@
 #define ROBO_ARLCTRL_VEC_2	0x26	/* Multiport vector 2 */
 
 /* VLAN page registers */
-#define ROBO_VLAN_ACCESS	0x08	/* VLAN table access register */
-#define ROBO_VLAN_ACCESS_5350	0x06	/* VLAN table access register (5350) */
-#define ROBO_VLAN_READ		0x0c	/* VLAN read register */
-#define ROBO_VLAN_MAX		0xff	/* Maximum number of VLANs */
+#define ROBO_VLAN_ACCESS	0x06	/* VLAN table Access register */
+#define ROBO_VLAN_ACCESS_5365	0x08	/* VLAN table Access register (5365) */
+#define ROBO_VLAN_READ		0x0C	/* VLAN read register */
+#define ROBO_VLAN_MAX		0xFF	/* Maximum number of VLANs */
 
 
 static const u8 pae_group_addr[ETH_ALEN] =
@@ -64,11 +58,9 @@
 
 struct wpa_driver_roboswitch_data {
 	void *ctx;
-	struct l2_packet_data *l2;
 	char ifname[IFNAMSIZ + 1];
-	u8 own_addr[ETH_ALEN];
 	struct ifreq ifr;
-	int fd, is_5350;
+	int fd;
 	u16 ports;
 };
 
@@ -80,18 +72,6 @@
 }
 
 
-/*
- * RoboSwitch uses 16-bit Big Endian addresses.
- * The ordering of the words is reversed in the MII registers.
- */
-static void wpa_driver_roboswitch_addr_be16(const u8 addr[ETH_ALEN], u16 *be)
-{
-	int i;
-	for (i = 0; i < ETH_ALEN; i += 2)
-		be[(ETH_ALEN - i) / 2 - 1] = WPA_GET_BE16(addr + i);
-}
-
-
 static u16 wpa_driver_roboswitch_mdio_read(
 	struct wpa_driver_roboswitch_data *drv, u8 reg)
 {
@@ -177,19 +157,6 @@
 }
 
 
-static void wpa_driver_roboswitch_receive(void *priv, const u8 *src_addr,
-					  const u8 *buf, size_t len)
-{
-	struct wpa_driver_roboswitch_data *drv = priv;
-
-	if (len > 14 && WPA_GET_BE16(buf + 12) == ETH_P_EAPOL &&
-	    os_memcmp(buf, drv->own_addr, ETH_ALEN) == 0) {
-		wpa_supplicant_rx_eapol(drv->ctx, src_addr, buf + 14,
-					len - 14);
-	}
-}
-
-
 static int wpa_driver_roboswitch_get_ssid(void *priv, u8 *ssid)
 {
 	ssid[0] = 0;
@@ -205,32 +172,6 @@
 }
 
 
-static int wpa_driver_roboswitch_set_param(void *priv, const char *param)
-{
-	struct wpa_driver_roboswitch_data *drv = priv;
-	char *sep;
-
-	if (param == NULL || os_strstr(param, "multicast_only=1") == NULL) {
-		sep = drv->ifname + os_strlen(drv->ifname);
-		*sep = '.';
-		drv->l2 = l2_packet_init(drv->ifname, NULL, ETH_P_ALL,
-					 wpa_driver_roboswitch_receive, drv,
-					 1);
-		if (drv->l2 == NULL) {
-			wpa_printf(MSG_INFO, "%s: Unable to listen on %s",
-				   __func__, drv->ifname);
-			return -1;
-		}
-		*sep = '\0';
-		l2_packet_get_own_addr(drv->l2, drv->own_addr);
-	} else {
-		wpa_printf(MSG_DEBUG, "%s: Ignoring unicast frames", __func__);
-		drv->l2 = NULL;
-	}
-	return 0;
-}
-
-
 static const char * wpa_driver_roboswitch_get_ifname(void *priv)
 {
 	struct wpa_driver_roboswitch_data *drv = priv;
@@ -239,109 +180,137 @@
 
 
 static int wpa_driver_roboswitch_join(struct wpa_driver_roboswitch_data *drv,
-				      u16 ports, const u8 *addr)
+				      const u8 *addr)
 {
-	u16 read1[3], read2[3], addr_be16[3];
-
-	wpa_driver_roboswitch_addr_be16(addr, addr_be16);
+	int i;
+	u16 _read, zero = 0;
+	/* For reasons of simplicity we assume ETH_ALEN is even. */
+	u16 addr_word[ETH_ALEN / 2];
+	/* RoboSwitch uses 16-bit Big Endian addresses.			*/
+	/* The ordering of the words is reversed in the MII registers.	*/
+	for (i = 0; i < ETH_ALEN; i += 2)
+		addr_word[(ETH_ALEN - i) / 2 - 1] = WPA_GET_BE16(addr + i);
 
+	/* check if multiport addresses are not yet enabled */
 	if (wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-				       ROBO_ARLCTRL_CONF, read1, 1) < 0)
+				       ROBO_ARLCTRL_CONF, &_read, 1) < 0)
 		return -1;
-	if (!(read1[0] & (1 << 4))) {
-		/* multiport addresses are not yet enabled */
-		read1[0] |= 1 << 4;
+
+	if (!(_read & (1 << 4))) {
+		_read |= 1 << 4;
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_ADDR_1, addr_be16, 3);
+					    ROBO_ARLCTRL_ADDR_1, addr_word, 3);
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_VEC_1, &ports, 1);
+					    ROBO_ARLCTRL_VEC_1, &drv->ports,
+					    1);
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_ADDR_2, addr_be16, 3);
+					    ROBO_ARLCTRL_VEC_2, &zero, 1);
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_VEC_2, &ports, 1);
+					    ROBO_ARLCTRL_CONF, &_read, 1);
+		return 0;
+	}
+
+	/* check if multiport address 1 is free */
+	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE, ROBO_ARLCTRL_VEC_1,
+				   &_read, 1);
+	if (_read == 0) {
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_CONF, read1, 1);
-	} else {
-		/* if both multiport addresses are the same we can add */
-		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_ADDR_1, read1, 3);
-		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_ADDR_2, read2, 3);
-		if (os_memcmp(read1, read2, 6) != 0)
-			return -1;
-		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_VEC_1, read1, 1);
-		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_VEC_2, read2, 1);
-		if (read1[0] != read2[0])
-			return -1;
+					    ROBO_ARLCTRL_ADDR_1, addr_word, 3);
+		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
+					    ROBO_ARLCTRL_VEC_1, &drv->ports,
+					    1);
+		return 0;
+	}
+	/* check if multiport address 2 is free */
+	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE, ROBO_ARLCTRL_VEC_2,
+				   &_read, 1);
+	if (_read == 0) {
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_ADDR_1, addr_be16, 3);
+					    ROBO_ARLCTRL_ADDR_2, addr_word, 3);
 		wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-					    ROBO_ARLCTRL_VEC_1, &ports, 1);
+					    ROBO_ARLCTRL_VEC_2, &drv->ports,
+					    1);
+		return 0;
 	}
-	return 0;
+
+	/* out of free multiport addresses */
+	return -1;
 }
 
 
 static int wpa_driver_roboswitch_leave(struct wpa_driver_roboswitch_data *drv,
-				       u16 ports, const u8 *addr)
+				       const u8 *addr)
 {
-	u16 _read, addr_be16[3], addr_read[3], ports_read;
-
-	wpa_driver_roboswitch_addr_be16(addr, addr_be16);
+	int i;
+	u16 _read[3], zero = 0;
+	u16 addr_word[ETH_ALEN / 2]; /* same as at join */
 
-	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE, ROBO_ARLCTRL_CONF,
-				   &_read, 1);
-	/* If ARL control is disabled, there is nothing to leave. */
-	if (!(_read & (1 << 4))) return -1;
+	for (i = 0; i < ETH_ALEN; i += 2)
+		addr_word[(ETH_ALEN - i) / 2 - 1] = WPA_GET_BE16(addr + i);
 
-	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-				   ROBO_ARLCTRL_ADDR_1, addr_read, 3);
+	/* check if multiport address 1 was used */
 	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE, ROBO_ARLCTRL_VEC_1,
-				   &ports_read, 1);
-	/* check if we occupy multiport address 1 */
-	if (os_memcmp(addr_read, addr_be16, 6) == 0 && ports_read == ports) {
+				   _read, 1);
+	if (_read[0] == drv->ports) {
 		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_ADDR_2, addr_read, 3);
+					   ROBO_ARLCTRL_ADDR_1, _read, 3);
+		if (os_memcmp(_read, addr_word, 6) == 0) {
+			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
+						    ROBO_ARLCTRL_VEC_1, &zero,
+						    1);
+			goto clean_up;
+		}
+	}
+
+	/* check if multiport address 2 was used */
+	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE, ROBO_ARLCTRL_VEC_2,
+				   _read, 1);
+	if (_read[0] == drv->ports) {
 		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_VEC_2, &ports_read, 1);
-		/* and multiport address 2 */
-		if (os_memcmp(addr_read, addr_be16, 6) == 0 &&
-		    ports_read == ports) {
-			_read &= ~(1 << 4);
+					   ROBO_ARLCTRL_ADDR_2, _read, 3);
+		if (os_memcmp(_read, addr_word, 6) == 0) {
 			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-						    ROBO_ARLCTRL_CONF, &_read,
+						    ROBO_ARLCTRL_VEC_2, &zero,
+						    1);
+			goto clean_up;
+		}
+	}
+
+	/* used multiport address not found */
+	return -1;
+
+clean_up:
+	/* leave the multiport registers in a sane state */
+	wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE, ROBO_ARLCTRL_VEC_1,
+				   _read, 1);
+	if (_read[0] == 0) {
+		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
+					   ROBO_ARLCTRL_VEC_2, _read, 1);
+		if (_read[0] == 0) {
+			wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
+						   ROBO_ARLCTRL_CONF, _read,
+						   1);
+			_read[0] &= ~(1 << 4);
+			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
+						    ROBO_ARLCTRL_CONF, _read,
 						    1);
 		} else {
 			wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-						   ROBO_ARLCTRL_ADDR_1,
-						   addr_read, 3);
+						   ROBO_ARLCTRL_ADDR_2, _read,
+						   3);
+			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
+						    ROBO_ARLCTRL_ADDR_1, _read,
+						    3);
 			wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-						   ROBO_ARLCTRL_VEC_1,
-						   &ports_read, 1);
+						   ROBO_ARLCTRL_VEC_2, _read,
+						   1);
 			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-						    ROBO_ARLCTRL_ADDR_2,
-						    addr_read, 3);
+						    ROBO_ARLCTRL_VEC_1, _read,
+						    1);
 			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-						    ROBO_ARLCTRL_VEC_2,
-						    &ports_read, 1);
+						    ROBO_ARLCTRL_VEC_2, &zero,
+						    1);
 		}
-	} else {
-		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_ADDR_2, addr_read, 3);
-		wpa_driver_roboswitch_read(drv, ROBO_ARLCTRL_PAGE,
-					   ROBO_ARLCTRL_VEC_2, &ports_read, 1);
-		/* or multiport address 2 */
-		if (os_memcmp(addr_read, addr_be16, 6) == 0 &&
-		    ports_read == ports) {
-			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-						    ROBO_ARLCTRL_ADDR_1,
-						    addr_read, 3);
-			wpa_driver_roboswitch_write(drv, ROBO_ARLCTRL_PAGE,
-						    ROBO_ARLCTRL_VEC_1,
-						    &ports_read, 1);
-		} else return -1;
 	}
 	return 0;
 }
@@ -350,35 +319,40 @@
 static void * wpa_driver_roboswitch_init(void *ctx, const char *ifname)
 {
 	struct wpa_driver_roboswitch_data *drv;
-	char *sep;
-	u16 vlan = 0, _read[2];
+	int len = -1, sep = -1;
+	u16 vlan_max = ROBO_VLAN_MAX, vlan = 0, vlan_read[2];
 
 	drv = os_zalloc(sizeof(*drv));
 	if (drv == NULL) return NULL;
 	drv->ctx = ctx;
-	drv->own_addr[0] = '\0';
 
-	/* copy ifname and take a pointer to the second to last character */
-	sep = drv->ifname +
-	      os_strlcpy(drv->ifname, ifname, sizeof(drv->ifname)) - 2;
-	/* find the '.' seperating <interface> and <vlan> */
-	while (sep > drv->ifname && *sep != '.') sep--;
-	if (sep <= drv->ifname) {
+	while (ifname[++len]) {
+		if (ifname[len] == '.')
+			sep = len;
+	}
+	if (sep < 0 || sep >= len - 1) {
 		wpa_printf(MSG_INFO, "%s: No <interface>.<vlan> pair in "
-			   "interface name %s", __func__, drv->ifname);
+			   "interface name %s", __func__, ifname);
+		os_free(drv);
+		return NULL;
+	}
+	if (sep > IFNAMSIZ) {
+		wpa_printf(MSG_INFO, "%s: Interface name %s is too long",
+			   __func__, ifname);
 		os_free(drv);
 		return NULL;
 	}
-	*sep = '\0';
-	while (*++sep) {
-		if (*sep < '0' || *sep > '9') {
+	os_memcpy(drv->ifname, ifname, sep);
+	drv->ifname[sep] = '\0';
+	while (++sep < len) {
+		if (ifname[sep] < '0' || ifname[sep] > '9') {
 			wpa_printf(MSG_INFO, "%s: Invalid vlan specification "
 				   "in interface name %s", __func__, ifname);
 			os_free(drv);
 			return NULL;
 		}
 		vlan *= 10;
-		vlan += *sep - '0';
+		vlan += ifname[sep] - '0';
 		if (vlan > ROBO_VLAN_MAX) {
 			wpa_printf(MSG_INFO, "%s: VLAN out of range in "
 				   "interface name %s", __func__, ifname);
@@ -408,32 +382,31 @@
 		return NULL;
 	}
 
-	/* set and read back to see if the register can be used */
-	_read[0] = ROBO_VLAN_MAX;
-	wpa_driver_roboswitch_write(drv, ROBO_VLAN_PAGE, ROBO_VLAN_ACCESS_5350,
-				    _read, 1);
-	wpa_driver_roboswitch_read(drv, ROBO_VLAN_PAGE, ROBO_VLAN_ACCESS_5350,
-				   _read + 1, 1);
-	drv->is_5350 = _read[0] == _read[1];
-
 	/* set the read bit */
 	vlan |= 1 << 13;
-	wpa_driver_roboswitch_write(drv, ROBO_VLAN_PAGE,
-				    drv->is_5350 ? ROBO_VLAN_ACCESS_5350
-						 : ROBO_VLAN_ACCESS,
-				    &vlan, 1);
-	wpa_driver_roboswitch_read(drv, ROBO_VLAN_PAGE, ROBO_VLAN_READ, _read,
-				   drv->is_5350 ? 2 : 1);
-	if (!(drv->is_5350 ? _read[1] & (1 << 4) : _read[0] & (1 << 14))) {
+	/* set and read back to see if the register can be used */
+	wpa_driver_roboswitch_write(drv, ROBO_VLAN_PAGE, ROBO_VLAN_ACCESS,
+				    &vlan_max, 1);
+	wpa_driver_roboswitch_read(drv, ROBO_VLAN_PAGE, ROBO_VLAN_ACCESS,
+				   &vlan_max, 1);
+	if (vlan_max == ROBO_VLAN_MAX) /* pre-5365 */
+		wpa_driver_roboswitch_write(drv, ROBO_VLAN_PAGE,
+					    ROBO_VLAN_ACCESS, &vlan, 1);
+	else /* 5365 uses a different register */
+		wpa_driver_roboswitch_write(drv, ROBO_VLAN_PAGE,
+					    ROBO_VLAN_ACCESS_5365, &vlan, 1);
+	wpa_driver_roboswitch_read(drv, ROBO_VLAN_PAGE, ROBO_VLAN_READ,
+				   vlan_read, 2);
+	if (!(vlan_read[1] & (1 << 4))) {
 		wpa_printf(MSG_INFO, "%s: Could not get port information for "
 				     "VLAN %d", __func__, vlan & ~(1 << 13));
 		os_free(drv);
 		return NULL;
 	}
-	drv->ports = _read[0] & 0x001F;
+	drv->ports = vlan_read[0] & 0x001F;
 	/* add the MII port */
 	drv->ports |= 1 << 8;
-	if (wpa_driver_roboswitch_join(drv, drv->ports, pae_group_addr) < 0) {
+	if (wpa_driver_roboswitch_join(drv, pae_group_addr) < 0) {
 		wpa_printf(MSG_INFO, "%s: Unable to join PAE group", __func__);
 		os_free(drv);
 		return NULL;
@@ -450,11 +423,7 @@
 {
 	struct wpa_driver_roboswitch_data *drv = priv;
 
-	if (drv->l2) {
-		l2_packet_deinit(drv->l2);
-		drv->l2 = NULL;
-	}
-	if (wpa_driver_roboswitch_leave(drv, drv->ports, pae_group_addr) < 0) {
+	if (wpa_driver_roboswitch_leave(drv, pae_group_addr) < 0) {
 		wpa_printf(MSG_DEBUG, "%s: Unable to leave PAE group",
 			   __func__);
 	}
@@ -471,6 +440,5 @@
 	.get_bssid = wpa_driver_roboswitch_get_bssid,
 	.init = wpa_driver_roboswitch_init,
 	.deinit = wpa_driver_roboswitch_deinit,
-	.set_param = wpa_driver_roboswitch_set_param,
 	.get_ifname = wpa_driver_roboswitch_get_ifname,
 };
diff -Nur hostap-06-d23bf71/src/drivers/driver_wext.c hostap06/src/drivers/driver_wext.c
--- hostap-06-d23bf71/src/drivers/driver_wext.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_wext.c	2009-03-23 14:17:09.000000000 +0200
@@ -35,7 +35,6 @@
 static int wpa_driver_wext_flush_pmkid(void *priv);
 static int wpa_driver_wext_get_range(void *priv);
 static void wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv);
-static void wpa_driver_wext_disconnect(struct wpa_driver_wext_data *drv);
 
 
 static int wpa_driver_wext_send_oper_ifla(struct wpa_driver_wext_data *drv,
@@ -65,9 +64,8 @@
 	req.ifinfo.ifi_change = 0;
 
 	if (linkmode != -1) {
-		rta = aliasing_hide_typecast(
-			((char *) &req + NLMSG_ALIGN(req.hdr.nlmsg_len)),
-			struct rtattr);
+		rta = (struct rtattr *)
+			((char *) &req + NLMSG_ALIGN(req.hdr.nlmsg_len));
 		rta->rta_type = IFLA_LINKMODE;
 		rta->rta_len = RTA_LENGTH(sizeof(char));
 		*((char *) RTA_DATA(rta)) = linkmode;
@@ -984,13 +982,6 @@
 
 	wpa_driver_wext_get_range(drv);
 
-	/*
-	 * Unlock the driver's BSSID and force to a random SSID to clear any
-	 * previous association the driver might have when the supplicant
-	 * starts up.
-	 */
-	wpa_driver_wext_disconnect(drv);
-
 	drv->ifindex = if_nametoindex(drv->ifname);
 
 	if (os_strncmp(drv->ifname, "wlan", 4) == 0) {
@@ -1030,7 +1021,8 @@
 	 * Clear possibly configured driver parameters in order to make it
 	 * easier to use the driver after wpa_supplicant has been terminated.
 	 */
-	wpa_driver_wext_disconnect(drv);
+	(void) wpa_driver_wext_set_bssid(drv,
+					 (u8 *) "\x00\x00\x00\x00\x00\x00");
 
 	wpa_driver_wext_send_oper_ifla(priv, 0, IF_OPER_UP);
 
@@ -1616,9 +1608,6 @@
 			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_CCMP;
 		if (range->enc_capa & IW_ENC_CAPA_4WAY_HANDSHAKE)
 			drv->capa.flags |= WPA_DRIVER_FLAGS_4WAY_HANDSHAKE;
-		drv->capa.auth = WPA_DRIVER_AUTH_OPEN |
-			WPA_DRIVER_AUTH_SHARED |
-			WPA_DRIVER_AUTH_LEAP;
 
 		wpa_printf(MSG_DEBUG, "  capabilities: key_mgmt 0x%x enc 0x%x "
 			   "flags 0x%x",
@@ -1911,36 +1900,21 @@
 
 static void wpa_driver_wext_disconnect(struct wpa_driver_wext_data *drv)
 {
-	struct iwreq iwr;
 	const u8 null_bssid[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
 	u8 ssid[32];
 	int i;
 
 	/*
-	 * Only force-disconnect when the card is in infrastructure mode,
-	 * otherwise the driver might interpret the cleared BSSID and random
-	 * SSID as an attempt to create a new ad-hoc network.
+	 * Clear the BSSID selection and set a random SSID to make sure the
+	 * driver will not be trying to associate with something even if it
+	 * does not understand SIOCSIWMLME commands (or tries to associate
+	 * automatically after deauth/disassoc).
 	 */
-	os_memset(&iwr, 0, sizeof(iwr));
-	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
-	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
-		perror("ioctl[SIOCGIWMODE]");
-		iwr.u.mode = IW_MODE_INFRA;
-	}
+	wpa_driver_wext_set_bssid(drv, null_bssid);
 
-	if (iwr.u.mode == IW_MODE_INFRA) {
-		/*
-		 * Clear the BSSID selection and set a random SSID to make sure
-		 * the driver will not be trying to associate with something
-		 * even if it does not understand SIOCSIWMLME commands (or
-		 * tries to associate automatically after deauth/disassoc).
-		 */
-		wpa_driver_wext_set_bssid(drv, null_bssid);
-
-		for (i = 0; i < 32; i++)
-			ssid[i] = rand() & 0xFF;
-		wpa_driver_wext_set_ssid(drv, ssid, 32);
-	}
+	for (i = 0; i < 32; i++)
+		ssid[i] = rand() & 0xFF;
+	wpa_driver_wext_set_ssid(drv, ssid, 32);
 }
 
 
@@ -1950,8 +1924,8 @@
 	struct wpa_driver_wext_data *drv = priv;
 	int ret;
 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
-	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
 	wpa_driver_wext_disconnect(drv);
+	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
 	return ret;
 }
 
diff -Nur hostap-06-d23bf71/src/drivers/driver_wired.c hostap06/src/drivers/driver_wired.c
--- hostap-06-d23bf71/src/drivers/driver_wired.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/drivers/driver_wired.c	2009-03-23 14:17:09.000000000 +0200
@@ -18,9 +18,9 @@
 #ifdef __linux__
 #include <netpacket/packet.h>
 #endif /* __linux__ */
-#if defined(__FreeBSD__) || defined(__DragonFly__)
+#ifdef __FreeBSD__
 #include <net/if_dl.h>
-#endif /* defined(__FreeBSD__) || defined(__DragonFly__) */
+#endif /* __FreeBSD__ */
 
 #include "common.h"
 #include "driver.h"
@@ -118,7 +118,7 @@
 	ifr.ifr_hwaddr.sa_family = AF_UNSPEC;
 	os_memcpy(ifr.ifr_hwaddr.sa_data, addr, ETH_ALEN);
 #endif /* __linux__ */
-#if defined(__FreeBSD__) || defined(__DragonFly__)
+#ifdef __FreeBSD__
 	{
 		struct sockaddr_dl *dlp;
 		dlp = (struct sockaddr_dl *) &ifr.ifr_addr;
@@ -130,16 +130,7 @@
 		dlp->sdl_slen = 0;
 		os_memcpy(LLADDR(dlp), addr, ETH_ALEN); 
 	}
-#endif /* defined(__FreeBSD__) || defined(__DragonFly__) */
-#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
-	{
-		struct sockaddr *sap;
-		sap = (struct sockaddr *) &ifr.ifr_addr;
-		sap->sa_len = sizeof(struct sockaddr);
-		sap->sa_family = AF_UNSPEC;
-		os_memcpy(sap->sa_data, addr, ETH_ALEN);
-	}
-#endif /* defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__) */
+#endif /* __FreeBSD__ */
 
 	if (ioctl(s, add ? SIOCADDMULTI : SIOCDELMULTI, (caddr_t) &ifr) < 0) {
 		perror("ioctl[SIOC{ADD/DEL}MULTI]");
diff -Nur hostap-06-d23bf71/src/drivers/.gitignore hostap06/src/drivers/.gitignore
--- hostap-06-d23bf71/src/drivers/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/drivers/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/eap_common/.gitignore hostap06/src/eap_common/.gitignore
--- hostap-06-d23bf71/src/eap_common/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/eap_common/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/eapol_supp/eapol_supp_sm.c hostap06/src/eapol_supp/eapol_supp_sm.c
--- hostap-06-d23bf71/src/eapol_supp/eapol_supp_sm.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eapol_supp/eapol_supp_sm.c	2009-03-23 14:17:09.000000000 +0200
@@ -742,8 +742,8 @@
 		os_memcpy(ekey + IEEE8021X_KEY_IV_LEN, keydata.encr_key,
 			  encr_key_len);
 		os_memcpy(datakey, key + 1, key_len);
-		rc4_skip(ekey, IEEE8021X_KEY_IV_LEN + encr_key_len, 0,
-			 datakey, key_len);
+		rc4(datakey, key_len, ekey,
+		    IEEE8021X_KEY_IV_LEN + encr_key_len);
 		wpa_hexdump_key(MSG_DEBUG, "EAPOL: Decrypted(RC4) key",
 				datakey, key_len);
 	} else if (key_len == 0) {
diff -Nur hostap-06-d23bf71/src/eapol_supp/.gitignore hostap06/src/eapol_supp/.gitignore
--- hostap-06-d23bf71/src/eapol_supp/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/eapol_supp/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/eap_peer/eap_methods.h hostap06/src/eap_peer/eap_methods.h
--- hostap-06-d23bf71/src/eap_peer/eap_methods.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_peer/eap_methods.h	2009-03-23 14:17:09.000000000 +0200
@@ -62,11 +62,6 @@
 {
 }
 
-static inline char ** eap_get_names_as_string_array(size_t *num)
-{
-	return NULL;
-}
-
 #endif /* IEEE8021X_EAPOL */
 
 
diff -Nur hostap-06-d23bf71/src/eap_peer/eap_sim.c hostap06/src/eap_peer/eap_sim.c
--- hostap-06-d23bf71/src/eap_peer/eap_sim.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_peer/eap_sim.c	2009-03-23 14:17:09.000000000 +0200
@@ -468,6 +468,8 @@
 	wpa_printf(MSG_DEBUG, "Generating EAP-SIM Notification (id=%d)", id);
 	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id,
 			       EAP_TYPE_SIM, EAP_SIM_SUBTYPE_NOTIFICATION);
+	wpa_printf(MSG_DEBUG, "   AT_NOTIFICATION");
+	eap_sim_msg_add(msg, EAP_SIM_AT_NOTIFICATION, notification, NULL, 0);
 	if (k_aut && data->reauth) {
 		wpa_printf(MSG_DEBUG, "   AT_IV");
 		wpa_printf(MSG_DEBUG, "   AT_ENCR_DATA");
diff -Nur hostap-06-d23bf71/src/eap_peer/eap_tls_common.c hostap06/src/eap_peer/eap_tls_common.c
--- hostap-06-d23bf71/src/eap_peer/eap_tls_common.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_peer/eap_tls_common.c	2009-03-23 14:17:09.000000000 +0200
@@ -45,18 +45,6 @@
 }
 
 
-static void eap_tls_params_flags(struct tls_connection_params *params,
-				 const char *txt)
-{
-	if (txt == NULL)
-		return;
-	if (os_strstr(txt, "tls_allow_md5=1"))
-		params->flags |= TLS_CONN_ALLOW_SIGN_RSA_MD5;
-	if (os_strstr(txt, "tls_disable_time_checks=1"))
-		params->flags |= TLS_CONN_DISABLE_TIME_CHECKS;
-}
-
-
 static void eap_tls_params_from_conf1(struct tls_connection_params *params,
 				      struct eap_peer_config *config)
 {
@@ -74,7 +62,6 @@
 	params->key_id = config->key_id;
 	params->cert_id = config->cert_id;
 	params->ca_cert_id = config->ca_cert_id;
-	eap_tls_params_flags(params, config->phase1);
 }
 
 
@@ -95,7 +82,6 @@
 	params->key_id = config->key2_id;
 	params->cert_id = config->cert2_id;
 	params->ca_cert_id = config->ca_cert2_id;
-	eap_tls_params_flags(params, config->phase2);
 }
 
 
diff -Nur hostap-06-d23bf71/src/eap_peer/eap_ttls.c hostap06/src/eap_peer/eap_ttls.c
--- hostap-06-d23bf71/src/eap_peer/eap_ttls.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_peer/eap_ttls.c	2009-03-23 14:17:09.000000000 +0200
@@ -842,7 +842,7 @@
 	/* User-Password; in RADIUS, this is encrypted, but EAP-TTLS encrypts
 	 * the data, so no separate encryption is used in the AVP itself.
 	 * However, the password is padded to obfuscate its length. */
-	pad = password_len == 0 ? 16 : (16 - (password_len & 15)) & 15;
+	pad = (16 - (password_len & 15)) & 15;
 	pos = eap_ttls_avp_hdr(pos, RADIUS_ATTR_USER_PASSWORD, 0, 1,
 			       password_len + pad);
 	os_memcpy(pos, password, password_len);
diff -Nur hostap-06-d23bf71/src/eap_peer/eap_wsc.c hostap06/src/eap_peer/eap_wsc.c
--- hostap-06-d23bf71/src/eap_peer/eap_wsc.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_peer/eap_wsc.c	2009-03-23 14:17:09.000000000 +0200
@@ -144,7 +144,7 @@
 
 	if (registrar && cfg.pin) {
 		wps_registrar_add_pin(data->wps_ctx->registrar, NULL,
-				      cfg.pin, cfg.pin_len, 0);
+				      cfg.pin, cfg.pin_len);
 	}
 
 	return data;
diff -Nur hostap-06-d23bf71/src/eap_peer/.gitignore hostap06/src/eap_peer/.gitignore
--- hostap-06-d23bf71/src/eap_peer/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/eap_peer/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/eap_peer/tncc.c hostap06/src/eap_peer/tncc.c
--- hostap-06-d23bf71/src/eap_peer/tncc.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_peer/tncc.c	2009-03-23 14:17:09.000000000 +0200
@@ -1106,7 +1106,6 @@
 	if (pos >= end || *pos != ' ') {
 		wpa_printf(MSG_ERROR, "TNC: Ignoring invalid IMC line '%s' "
 			   "(no space after name)", start);
-		os_free(imc->name);
 		os_free(imc);
 		return NULL;
 	}
diff -Nur hostap-06-d23bf71/src/eap_server/eap.c hostap06/src/eap_server/eap.c
--- hostap-06-d23bf71/src/eap_server/eap.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_server/eap.c	2009-03-23 14:17:09.000000000 +0200
@@ -1261,7 +1261,7 @@
 		sm->m->reset(sm, sm->eap_method_priv);
 	wpabuf_free(sm->eap_if.eapReqData);
 	os_free(sm->eap_if.eapKeyData);
-	wpabuf_free(sm->lastReqData);
+	os_free(sm->lastReqData);
 	wpabuf_free(sm->eap_if.eapRespData);
 	os_free(sm->identity);
 	os_free(sm->pac_opaque_encr_key);
diff -Nur hostap-06-d23bf71/src/eap_server/eap_fast.c hostap06/src/eap_server/eap_fast.c
--- hostap-06-d23bf71/src/eap_server/eap_fast.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_server/eap_fast.c	2009-03-23 14:17:09.000000000 +0200
@@ -73,10 +73,6 @@
 };
 
 
-static int eap_fast_process_phase2_start(struct eap_sm *sm,
-					 struct eap_fast_data *data);
-
-
 static const char * eap_fast_state_txt(int state)
 {
 	switch (state) {
@@ -808,48 +804,11 @@
 }
 
 
-static int eap_fast_encrypt_phase2(struct eap_sm *sm,
-				   struct eap_fast_data *data,
-				   struct wpabuf *plain, int piggyback)
-{
-	struct wpabuf *encr;
-
-	wpa_hexdump_buf_key(MSG_DEBUG, "EAP-FAST: Encrypting Phase 2 TLVs",
-			    plain);
-	encr = eap_server_tls_encrypt(sm, &data->ssl, wpabuf_mhead(plain),
-				      wpabuf_len(plain));
-	wpabuf_free(plain);
-
-	if (data->ssl.out_buf && piggyback) {
-		wpa_printf(MSG_DEBUG, "EAP-FAST: Piggyback Phase 2 data "
-			   "(len=%d) with last Phase 1 Message (len=%d "
-			   "used=%d)",
-			   (int) wpabuf_len(encr),
-			   (int) wpabuf_len(data->ssl.out_buf),
-			   (int) data->ssl.out_used);
-		if (wpabuf_resize(&data->ssl.out_buf, wpabuf_len(encr)) < 0) {
-			wpa_printf(MSG_WARNING, "EAP-FAST: Failed to resize "
-				   "output buffer");
-			wpabuf_free(encr);
-			return -1;
-		}
-		wpabuf_put_buf(data->ssl.out_buf, encr);
-		wpabuf_free(encr);
-	} else {
-		wpabuf_free(data->ssl.out_buf);
-		data->ssl.out_used = 0;
-		data->ssl.out_buf = encr;
-	}
-
-	return 0;
-}
-
-
 static struct wpabuf * eap_fast_buildReq(struct eap_sm *sm, void *priv, u8 id)
 {
 	struct eap_fast_data *data = priv;
 	struct wpabuf *req = NULL;
-	int piggyback = 0;
+	struct wpabuf *encr;
 
 	if (data->ssl.state == FRAG_ACK) {
 		return eap_server_tls_build_ack(id, EAP_TYPE_FAST,
@@ -868,19 +827,6 @@
 		if (tls_connection_established(sm->ssl_ctx, data->ssl.conn)) {
 			if (eap_fast_phase1_done(sm, data) < 0)
 				return NULL;
-			if (data->state == PHASE2_START) {
-				/*
-				 * Try to generate Phase 2 data to piggyback
-				 * with the end of Phase 1 to avoid extra
-				 * roundtrip.
-				 */
-				wpa_printf(MSG_DEBUG, "EAP-FAST: Try to start "
-					   "Phase 2");
-				if (eap_fast_process_phase2_start(sm, data))
-					break;
-				req = eap_fast_build_phase2_req(sm, data, id);
-				piggyback = 1;
-			}
 		}
 		break;
 	case PHASE2_ID:
@@ -910,9 +856,18 @@
 		return NULL;
 	}
 
-	if (req &&
-	    eap_fast_encrypt_phase2(sm, data, req, piggyback) < 0)
-		return NULL;
+	if (req) {
+		wpa_hexdump_buf_key(MSG_DEBUG, "EAP-FAST: Encrypting Phase 2 "
+				    "TLVs", req);
+		encr = eap_server_tls_encrypt(sm, &data->ssl,
+					      wpabuf_mhead(req),
+					      wpabuf_len(req));
+		wpabuf_free(req);
+
+		wpabuf_free(data->ssl.out_buf);
+		data->ssl.out_used = 0;
+		data->ssl.out_buf = encr;
+	}
 
 	return eap_server_tls_build_msg(&data->ssl, EAP_TYPE_FAST,
 					data->fast_version, id);
@@ -1488,8 +1443,8 @@
 }
 
 
-static int eap_fast_process_phase2_start(struct eap_sm *sm,
-					 struct eap_fast_data *data)
+static void eap_fast_process_phase2_start(struct eap_sm *sm,
+					  struct eap_fast_data *data)
 {
 	u8 next_type;
 
@@ -1519,7 +1474,7 @@
 		next_type = EAP_TYPE_IDENTITY;
 	}
 
-	return eap_fast_phase2_init(sm, data, next_type);
+	eap_fast_phase2_init(sm, data, next_type);
 }
 
 
diff -Nur hostap-06-d23bf71/src/eap_server/eap_tls_common.c hostap06/src/eap_server/eap_tls_common.c
--- hostap-06-d23bf71/src/eap_server/eap_tls_common.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/eap_server/eap_tls_common.c	2009-03-23 14:17:09.000000000 +0200
@@ -344,7 +344,7 @@
 	size_t buf_len;
 
 	/* reserve some extra room for encryption overhead */
-	buf_len = plain_len + 300;
+	buf_len = plain_len + 200;
 	buf = wpabuf_alloc(buf_len);
 	if (buf == NULL)
 		return NULL;
diff -Nur hostap-06-d23bf71/src/eap_server/.gitignore hostap06/src/eap_server/.gitignore
--- hostap-06-d23bf71/src/eap_server/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/eap_server/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/hlr_auc_gw/.gitignore hostap06/src/hlr_auc_gw/.gitignore
--- hostap-06-d23bf71/src/hlr_auc_gw/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/hlr_auc_gw/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/hlr_auc_gw/hlr_auc_gw.c hostap06/src/hlr_auc_gw/hlr_auc_gw.c
--- hostap-06-d23bf71/src/hlr_auc_gw/hlr_auc_gw.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/hlr_auc_gw/hlr_auc_gw.c	2009-03-23 14:17:09.000000000 +0200
@@ -532,7 +532,7 @@
 static void aka_auts(int s, struct sockaddr_un *from, socklen_t fromlen,
 		     char *imsi)
 {
-	char *auts, *__rand;
+	char *auts, *rand;
 	u8 _auts[EAP_AKA_AUTS_LEN], _rand[EAP_AKA_RAND_LEN], sqn[6];
 	struct milenage_parameters *m;
 
@@ -543,14 +543,14 @@
 		return;
 	*auts++ = '\0';
 
-	__rand = strchr(auts, ' ');
-	if (__rand == NULL)
+	rand = strchr(auts, ' ');
+	if (rand == NULL)
 		return;
-	*__rand++ = '\0';
+	*rand++ = '\0';
 
-	printf("AKA-AUTS: IMSI=%s AUTS=%s RAND=%s\n", imsi, auts, __rand);
+	printf("AKA-AUTS: IMSI=%s AUTS=%s RAND=%s\n", imsi, auts, rand);
 	if (hexstr2bin(auts, _auts, EAP_AKA_AUTS_LEN) ||
-	    hexstr2bin(__rand, _rand, EAP_AKA_RAND_LEN)) {
+	    hexstr2bin(rand, _rand, EAP_AKA_RAND_LEN)) {
 		printf("Could not parse AUTS/RAND\n");
 		return;
 	}
diff -Nur hostap-06-d23bf71/src/l2_packet/.gitignore hostap06/src/l2_packet/.gitignore
--- hostap-06-d23bf71/src/l2_packet/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/l2_packet/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/l2_packet/l2_packet_linux.c hostap06/src/l2_packet/l2_packet_linux.c
--- hostap-06-d23bf71/src/l2_packet/l2_packet_linux.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/l2_packet/l2_packet_linux.c	2009-03-23 14:17:09.000000000 +0200
@@ -185,7 +185,7 @@
 		return -1;
 	}
 	close(s);
-	saddr = aliasing_hide_typecast(&ifr.ifr_addr, struct sockaddr_in);
+	saddr = (struct sockaddr_in *) &ifr.ifr_addr;
 	if (saddr->sin_family != AF_INET)
 		return -1;
 	res = os_strlcpy(buf, inet_ntoa(saddr->sin_addr), len);
diff -Nur hostap-06-d23bf71/src/radius/.gitignore hostap06/src/radius/.gitignore
--- hostap-06-d23bf71/src/radius/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/radius/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/radius/radius_client.c hostap06/src/radius/radius_client.c
--- hostap-06-d23bf71/src/radius/radius_client.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/radius/radius_client.c	2009-03-23 14:17:09.000000000 +0200
@@ -917,22 +917,6 @@
 }
 
 
-static int radius_client_disable_pmtu_discovery(int s)
-{
-	int r = -1;
-#if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
-	/* Turn off Path MTU discovery on IPv4/UDP sockets. */
-	int action = IP_PMTUDISC_DONT;
-	r = setsockopt(s, IPPROTO_IP, IP_MTU_DISCOVER, &action,
-		       sizeof(action));
-	if (r == -1)
-		wpa_printf(MSG_ERROR, "Failed to set IP_MTU_DISCOVER: "
-			   "%s", strerror(errno));
-#endif
-	return r;
-}
-
-
 static int radius_client_init_auth(struct radius_client_data *radius)
 {
 	struct hostapd_radius_servers *conf = radius->conf;
@@ -941,10 +925,8 @@
 	radius->auth_serv_sock = socket(PF_INET, SOCK_DGRAM, 0);
 	if (radius->auth_serv_sock < 0)
 		perror("socket[PF_INET,SOCK_DGRAM]");
-	else {
-		radius_client_disable_pmtu_discovery(radius->auth_serv_sock);
+	else
 		ok++;
-	}
 
 #ifdef CONFIG_IPV6
 	radius->auth_serv_sock6 = socket(PF_INET6, SOCK_DGRAM, 0);
@@ -993,10 +975,8 @@
 	radius->acct_serv_sock = socket(PF_INET, SOCK_DGRAM, 0);
 	if (radius->acct_serv_sock < 0)
 		perror("socket[PF_INET,SOCK_DGRAM]");
-	else {
-		radius_client_disable_pmtu_discovery(radius->acct_serv_sock);
+	else
 		ok++;
-	}
 
 #ifdef CONFIG_IPV6
 	radius->acct_serv_sock6 = socket(PF_INET6, SOCK_DGRAM, 0);
@@ -1080,12 +1060,6 @@
 		eloop_unregister_read_sock(radius->auth_serv_sock);
 	if (radius->acct_serv_sock >= 0)
 		eloop_unregister_read_sock(radius->acct_serv_sock);
-#ifdef CONFIG_IPV6
-	if (radius->auth_serv_sock6 >= 0)
-		eloop_unregister_read_sock(radius->auth_serv_sock6);
-	if (radius->acct_serv_sock6 >= 0)
-		eloop_unregister_read_sock(radius->acct_serv_sock6);
-#endif /* CONFIG_IPV6 */
 
 	eloop_cancel_timeout(radius_retry_primary_timer, radius, NULL);
 
diff -Nur hostap-06-d23bf71/src/radius/radius_server.c hostap06/src/radius/radius_server.c
--- hostap-06-d23bf71/src/radius/radius_server.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/radius/radius_server.c	2009-03-23 14:17:09.000000000 +0200
@@ -117,8 +117,7 @@
 
 
 static void radius_server_session_timeout(void *eloop_ctx, void *timeout_ctx);
-static void radius_server_session_remove_timeout(void *eloop_ctx,
-						 void *timeout_ctx);
+
 
 
 static struct radius_client *
@@ -180,7 +179,6 @@
 				       struct radius_session *sess)
 {
 	eloop_cancel_timeout(radius_server_session_timeout, data, sess);
-	eloop_cancel_timeout(radius_server_session_remove_timeout, data, sess);
 	eap_server_sm_deinit(sess->eap);
 	if (sess->last_msg) {
 		radius_msg_free(sess->last_msg);
@@ -196,6 +194,9 @@
 }
 
 
+static void radius_server_session_remove_timeout(void *eloop_ctx,
+						 void *timeout_ctx);
+
 static void radius_server_session_remove(struct radius_server_data *data,
 					 struct radius_session *sess)
 {
@@ -492,7 +493,6 @@
 	unsigned int state;
 	struct radius_session *sess;
 	struct radius_msg *reply;
-	int is_complete = 0;
 
 	if (force_sess)
 		sess = force_sess;
@@ -603,9 +603,6 @@
 		return -1;
 	}
 
-	if (sess->eap_if->eapSuccess || sess->eap_if->eapFail)
-		is_complete = 1;
-
 	reply = radius_server_encapsulate_eap(data, client, sess, msg);
 
 	if (reply) {
@@ -647,7 +644,7 @@
 		client->counters.packets_dropped++;
 	}
 
-	if (is_complete) {
+	if (sess->eap_if->eapSuccess || sess->eap_if->eapFail) {
 		RADIUS_DEBUG("Removing completed session 0x%x after timeout",
 			     sess->sess_id);
 		eloop_cancel_timeout(radius_server_session_remove_timeout,
@@ -666,13 +663,7 @@
 {
 	struct radius_server_data *data = eloop_ctx;
 	u8 *buf = NULL;
-	union {
-		struct sockaddr_storage ss;
-		struct sockaddr_in sin;
-#ifdef CONFIG_IPV6
-		struct sockaddr_in6 sin6;
-#endif /* CONFIG_IPV6 */
-	} from;
+	struct sockaddr_storage from;
 	socklen_t fromlen;
 	int len;
 	struct radius_client *client = NULL;
@@ -687,7 +678,7 @@
 
 	fromlen = sizeof(from);
 	len = recvfrom(sock, buf, RADIUS_MAX_MSG_LEN, 0,
-		       (struct sockaddr *) &from.ss, &fromlen);
+		       (struct sockaddr *) &from, &fromlen);
 	if (len < 0) {
 		perror("recvfrom[radius_server]");
 		goto fail;
@@ -695,26 +686,28 @@
 
 #ifdef CONFIG_IPV6
 	if (data->ipv6) {
-		if (inet_ntop(AF_INET6, &from.sin6.sin6_addr, abuf,
-			      sizeof(abuf)) == NULL)
+		struct sockaddr_in6 *from6 = (struct sockaddr_in6 *) &from;
+		if (inet_ntop(AF_INET6, &from6->sin6_addr, abuf, sizeof(abuf))
+		    == NULL)
 			abuf[0] = '\0';
-		from_port = ntohs(from.sin6.sin6_port);
+		from_port = ntohs(from6->sin6_port);
 		RADIUS_DEBUG("Received %d bytes from %s:%d",
 			     len, abuf, from_port);
 
 		client = radius_server_get_client(data,
 						  (struct in_addr *)
-						  &from.sin6.sin6_addr, 1);
+						  &from6->sin6_addr, 1);
 	}
 #endif /* CONFIG_IPV6 */
 
 	if (!data->ipv6) {
-		os_strlcpy(abuf, inet_ntoa(from.sin.sin_addr), sizeof(abuf));
-		from_port = ntohs(from.sin.sin_port);
+		struct sockaddr_in *from4 = (struct sockaddr_in *) &from;
+		os_strlcpy(abuf, inet_ntoa(from4->sin_addr), sizeof(abuf));
+		from_port = ntohs(from4->sin_port);
 		RADIUS_DEBUG("Received %d bytes from %s:%d",
 			     len, abuf, from_port);
 
-		client = radius_server_get_client(data, &from.sin.sin_addr, 0);
+		client = radius_server_get_client(data, &from4->sin_addr, 0);
 	}
 
 	RADIUS_DUMP("Received data", buf, len);
@@ -772,22 +765,6 @@
 }
 
 
-static int radius_server_disable_pmtu_discovery(int s)
-{
-	int r = -1;
-#if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
-	/* Turn off Path MTU discovery on IPv4/UDP sockets. */
-	int action = IP_PMTUDISC_DONT;
-	r = setsockopt(s, IPPROTO_IP, IP_MTU_DISCOVER, &action,
-		       sizeof(action));
-	if (r == -1)
-		wpa_printf(MSG_ERROR, "Failed to set IP_MTU_DISCOVER: "
-			   "%s", strerror(errno));
-#endif
-	return r;
-}
-
-
 static int radius_server_open_socket(int port)
 {
 	int s;
@@ -799,8 +776,6 @@
 		return -1;
 	}
 
-	radius_server_disable_pmtu_discovery(s);
-
 	os_memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
 	addr.sin_port = htons(port);
diff -Nur hostap-06-d23bf71/src/rsn_supp/.gitignore hostap06/src/rsn_supp/.gitignore
--- hostap-06-d23bf71/src/rsn_supp/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/rsn_supp/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/tls/.gitignore hostap06/src/tls/.gitignore
--- hostap-06-d23bf71/src/tls/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/tls/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/tls/tlsv1_client.c hostap06/src/tls/tlsv1_client.c
--- hostap-06-d23bf71/src/tls/tlsv1_client.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/tls/tlsv1_client.c	2009-03-23 14:17:09.000000000 +0200
@@ -627,7 +627,7 @@
 		 * list and seem to require that the last entry in the list is
 		 * the one that it wants to use. However, TLS specification
 		 * requires the list to be in the client preference order. As a
-		 * workaround, add anon-DH AES-128-SHA1 again at the end of the
+		 * workaround, ass anon-DH AES-128-SHA1 again at the end of the
 		 * list to allow the Cisco code to find it.
 		 */
 		suites[count++] = TLS_DH_anon_WITH_AES_128_CBC_SHA;
diff -Nur hostap-06-d23bf71/src/tls/tlsv1_server_read.c hostap06/src/tls/tlsv1_server_read.c
--- hostap-06-d23bf71/src/tls/tlsv1_server_read.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/tls/tlsv1_server_read.c	2009-03-23 14:17:09.000000000 +0200
@@ -40,7 +40,6 @@
 	u16 cipher_suite;
 	u16 num_suites;
 	int compr_null_found;
-	u16 ext_type, ext_len;
 
 	if (ct != TLS_CONTENT_TYPE_HANDSHAKE) {
 		wpa_printf(MSG_DEBUG, "TLSv1: Expected Handshake; "
@@ -184,7 +183,10 @@
 	}
 
 	if (end - pos >= 2) {
+		u16 ext_len;
+
 		/* Extension client_hello_extension_list<0..2^16-1> */
+
 		ext_len = WPA_GET_BE16(pos);
 		pos += 2;
 
@@ -193,7 +195,7 @@
 		if (end - pos != ext_len) {
 			wpa_printf(MSG_DEBUG, "TLSv1: Invalid ClientHello "
 				   "extension list length %u (expected %u)",
-				   ext_len, (unsigned int) (end - pos));
+				   ext_len, end - pos);
 			goto decode_error;
 		}
 
@@ -205,6 +207,8 @@
 		 */
 
 		while (pos < end) {
+			u16 ext_type, ext_len;
+
 			if (end - pos < 2) {
 				wpa_printf(MSG_DEBUG, "TLSv1: Invalid "
 					   "extension_type field");
@@ -516,7 +520,7 @@
 						 out, &outlen) < 0) {
 		wpa_printf(MSG_DEBUG, "TLSv1: Failed to decrypt "
 			   "PreMasterSecret (encr_len=%d outlen=%lu)",
-			   (int) (end - pos), (unsigned long) outlen);
+			   end - pos, (unsigned long) outlen);
 		use_random = 1;
 	}
 
diff -Nur hostap-06-d23bf71/src/utils/base64.c hostap06/src/utils/base64.c
--- hostap-06-d23bf71/src/utils/base64.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/base64.c	2009-03-23 14:17:09.000000000 +0200
@@ -43,8 +43,6 @@
 	olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
 	olen += olen / 72; /* line feeds */
 	olen++; /* nul termination */
-	if (olen < len)
-		return NULL; /* integer overflow */
 	out = os_malloc(olen);
 	if (out == NULL)
 		return NULL;
diff -Nur hostap-06-d23bf71/src/utils/common.c hostap06/src/utils/common.c
--- hostap-06-d23bf71/src/utils/common.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/common.c	2009-03-23 14:17:09.000000000 +0200
@@ -325,9 +325,3 @@
 	}
 	return ssid_txt;
 }
-
-
-void * __hide_aliasing_typecast(void *foo)
-{
-	return foo;
-}
diff -Nur hostap-06-d23bf71/src/utils/common.h hostap06/src/utils/common.h
--- hostap-06-d23bf71/src/utils/common.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/common.h	2009-03-23 14:17:09.000000000 +0200
@@ -22,24 +22,17 @@
 #include <byteswap.h>
 #endif /* __linux__ */
 
-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || \
-    defined(__OpenBSD__)
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)
 #include <sys/types.h>
 #include <sys/endian.h>
 #define __BYTE_ORDER	_BYTE_ORDER
 #define	__LITTLE_ENDIAN	_LITTLE_ENDIAN
 #define	__BIG_ENDIAN	_BIG_ENDIAN
-#ifdef __OpenBSD__
-#define bswap_16 swap16
-#define bswap_32 swap32
-#define bswap_64 swap64
-#else /* __OpenBSD__ */
 #define bswap_16 bswap16
 #define bswap_32 bswap32
 #define bswap_64 bswap64
-#endif /* __OpenBSD__ */
 #endif /* defined(__FreeBSD__) || defined(__NetBSD__) ||
-	* defined(__DragonFly__) || defined(__OpenBSD__) */
+	* defined(__DragonFly__) */
 
 #ifdef __APPLE__
 #include <sys/types.h>
@@ -442,17 +435,4 @@
 
 #include "wpa_debug.h"
 
-
-/*
- * gcc 4.4 ends up generating strict-aliasing warnings about some very common
- * networking socket uses that do not really result in a real problem and
- * cannot be easily avoided with union-based type-punning due to struct
- * definitions including another struct in system header files. To avoid having
- * to fully disable strict-aliasing warnings, provide a mechanism to hide the
- * typecast from aliasing for now. A cleaner solution will hopefully be found
- * in the future to handle these cases.
- */
-void * __hide_aliasing_typecast(void *foo);
-#define aliasing_hide_typecast(a,t) (t *) __hide_aliasing_typecast((a))
-
 #endif /* COMMON_H */
diff -Nur hostap-06-d23bf71/src/utils/.gitignore hostap06/src/utils/.gitignore
--- hostap-06-d23bf71/src/utils/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/utils/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/utils/os_unix.c hostap06/src/utils/os_unix.c
--- hostap-06-d23bf71/src/utils/os_unix.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/os_unix.c	2009-03-23 14:17:09.000000000 +0200
@@ -227,8 +227,7 @@
 
 int os_unsetenv(const char *name)
 {
-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__APPLE__) || \
-    defined(__OpenBSD__)
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__APPLE__)
 	unsetenv(name);
 	return 0;
 #else
diff -Nur hostap-06-d23bf71/src/utils/wpabuf.c hostap06/src/utils/wpabuf.c
--- hostap-06-d23bf71/src/utils/wpabuf.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/wpabuf.c	2009-03-23 14:17:09.000000000 +0200
@@ -29,10 +29,6 @@
 int wpabuf_resize(struct wpabuf **_buf, size_t add_len)
 {
 	struct wpabuf *buf = *_buf;
-	if (buf == NULL) {
-		*_buf = wpabuf_alloc(add_len);
-		return *_buf == NULL ? -1 : 0;
-	}
 	if (buf->used + add_len > buf->size) {
 		unsigned char *nbuf;
 		if (buf->ext_data) {
diff -Nur hostap-06-d23bf71/src/utils/wpa_debug.c hostap06/src/utils/wpa_debug.c
--- hostap-06-d23bf71/src/utils/wpa_debug.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/wpa_debug.c	2009-03-23 14:17:09.000000000 +0200
@@ -56,7 +56,7 @@
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_printf(int level, const char *fmt, ...)
+void wpa_printf(int level, char *fmt, ...)
 {
 	va_list ap;
 
@@ -267,7 +267,7 @@
 }
 
 
-void wpa_msg(void *ctx, int level, const char *fmt, ...)
+void wpa_msg(void *ctx, int level, char *fmt, ...)
 {
 	va_list ap;
 	char *buf;
@@ -288,30 +288,6 @@
 		wpa_msg_cb(ctx, level, buf, len);
 	os_free(buf);
 }
-
-
-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-{
-	va_list ap;
-	char *buf;
-	const int buflen = 2048;
-	int len;
-
-	if (!wpa_msg_cb)
-		return;
-
-	buf = os_malloc(buflen);
-	if (buf == NULL) {
-		wpa_printf(MSG_ERROR, "wpa_msg_ctrl: Failed to allocate "
-			   "message buffer");
-		return;
-	}
-	va_start(ap, fmt);
-	len = vsnprintf(buf, buflen, fmt, ap);
-	va_end(ap);
-	wpa_msg_cb(ctx, level, buf, len);
-	os_free(buf);
-}
 #endif /* CONFIG_NO_WPA_MSG */
 
 
diff -Nur hostap-06-d23bf71/src/utils/wpa_debug.h hostap06/src/utils/wpa_debug.h
--- hostap-06-d23bf71/src/utils/wpa_debug.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/utils/wpa_debug.h	2009-03-23 14:17:09.000000000 +0200
@@ -60,7 +60,7 @@
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_printf(int level, const char *fmt, ...)
+void wpa_printf(int level, char *fmt, ...)
 PRINTF_FORMAT(2, 3);
 
 /**
@@ -141,7 +141,6 @@
 
 #ifdef CONFIG_NO_WPA_MSG
 #define wpa_msg(args...) do { } while (0)
-#define wpa_msg_ctrl(args...) do { } while (0)
 #define wpa_msg_register_cb(f) do { } while (0)
 #else /* CONFIG_NO_WPA_MSG */
 /**
@@ -158,22 +157,7 @@
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-
-/**
- * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
- * @ctx: Pointer to context data; this is the ctx variable registered
- *	with struct wpa_driver_ops::init()
- * @level: priority level (MSG_*) of the message
- * @fmt: printf format string, followed by optional arguments
- *
- * This function is used to print conditional debugging and error messages.
- * This function is like wpa_msg(), but it sends the output only to the
- * attached ctrl_iface monitors. In other words, it can be used for frequent
- * events that do not need to be sent to syslog.
- */
-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-PRINTF_FORMAT(3, 4);
+void wpa_msg(void *ctx, int level, char *fmt, ...) PRINTF_FORMAT(3, 4);
 
 typedef void (*wpa_msg_cb_func)(void *ctx, int level, const char *txt,
 				size_t len);
diff -Nur hostap-06-d23bf71/src/wps/.gitignore hostap06/src/wps/.gitignore
--- hostap-06-d23bf71/src/wps/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/src/wps/.gitignore	2009-03-23 14:17:09.000000000 +0200
@@ -0,0 +1 @@
+*.d
diff -Nur hostap-06-d23bf71/src/wps/wps_attr_parse.c hostap06/src/wps/wps_attr_parse.c
--- hostap-06-d23bf71/src/wps/wps_attr_parse.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_attr_parse.c	2009-08-12 15:10:58.000000000 +0300
@@ -370,9 +370,20 @@
 		attr->ssid_len = len;
 		break;
 	case ATTR_NETWORK_KEY:
-		attr->network_key = pos;
-		attr->network_key_len = len;
+	{
+		u8 i = 1;
+		if (attr->network_key_idx)
+			i = *attr->network_key_idx;
+		if (i > MAX_NW_KEYS) {
+			wpa_printf(MSG_DEBUG, "WPS: Skipped Network Key "
+				   "attribute (max %d keys)",
+				   MAX_NW_KEYS);
+			break;
+		}
+		attr->network_key[i-1] = pos;
+		attr->network_key_len[i-1] = len;
 		break;
+	}
 	case ATTR_EAP_TYPE:
 		attr->eap_type = pos;
 		attr->eap_type_len = len;
@@ -381,14 +392,6 @@
 		attr->eap_identity = pos;
 		attr->eap_identity_len = len;
 		break;
-	case ATTR_AP_SETUP_LOCKED:
-		if (len != 1) {
-			wpa_printf(MSG_DEBUG, "WPS: Invalid AP Setup Locked "
-				   "length %u", len);
-			return -1;
-		}
-		attr->ap_setup_locked = pos;
-		break;
 	default:
 		wpa_printf(MSG_DEBUG, "WPS: Unsupported attribute type 0x%x "
 			   "len=%u", type, len);
diff -Nur hostap-06-d23bf71/src/wps/wps_attr_process.c hostap06/src/wps/wps_attr_process.c
--- hostap-06-d23bf71/src/wps/wps_attr_process.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_attr_process.c	2009-08-12 15:15:33.000000000 +0300
@@ -161,29 +161,31 @@
 static int wps_process_cred_network_key_idx(struct wps_credential *cred,
 					    const u8 *key_idx)
 {
+	cred->keys_num = 1; /* assume at least one key is present */
+
 	if (key_idx == NULL)
 		return 0; /* optional attribute */
 
-	wpa_printf(MSG_DEBUG, "WPS: Network Key Index: %d", *key_idx);
-	cred->key_idx = *key_idx;
+	wpa_printf(MSG_DEBUG, "WPS: Network Keys: %d", *key_idx);
+	cred->keys_num = *key_idx;
 
 	return 0;
 }
 
 
-static int wps_process_cred_network_key(struct wps_credential *cred,
-					const u8 *key, size_t key_len)
+static int wps_process_cred_network_key(int i, struct wps_credential *cred,
+					const u8 *key[], size_t key_len[])
 {
-	if (key == NULL) {
+	if (key[i] == NULL) {
 		wpa_printf(MSG_DEBUG, "WPS: Credential did not include "
-			   "Network Key");
+			   "Network Key %d", i);
 		return -1;
 	}
 
-	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key", key, key_len);
-	if (key_len <= sizeof(cred->key)) {
-		os_memcpy(cred->key, key, key_len);
-		cred->key_len = key_len;
+	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key", key[i], key_len[i]);
+	if (key_len[i] <= sizeof(cred->key[i])) {
+		os_memcpy(cred->key[i], key[i], key_len[i]);
+		cred->key_len[i] = key_len[i];
 	}
 
 	return 0;
@@ -259,17 +261,23 @@
 
 static void wps_workaround_cred_key(struct wps_credential *cred)
 {
-	if (cred->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK) &&
-	    cred->key_len > 8 && cred->key_len < 64 &&
-	    cred->key[cred->key_len - 1] == 0) {
-		/*
-		 * A deployed external registrar is known to encode ASCII
-		 * passphrases incorrectly. Remove the extra NULL termination
-		 * to fix the encoding.
-		 */
-		wpa_printf(MSG_DEBUG, "WPS: Workaround - remove NULL "
-			   "termination from ASCII passphrase");
-		cred->key_len--;
+	int i;
+
+	if ((cred->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK)) == 0)
+		return;
+
+	/*
+	 * A deployed external registrar is known to encode ASCII
+	 * passphrases incorrectly. Remove the extra NULL termination
+	 * to fix the encoding.
+	 */
+	for (i = 0; i < cred->keys_num; i++) {
+		int len = cred->key_len[i];
+		if (len > 8 && len < 64 && cred->key[len - 1] == 0) {
+			wpa_printf(MSG_DEBUG, "WPS: Workaround - remove NULL "
+				   "termination from ASCII passphrase");
+			cred->key_len[i]--;
+		}
 	}
 }
 
@@ -277,16 +285,15 @@
 int wps_process_cred(struct wps_parse_attr *attr,
 		     struct wps_credential *cred)
 {
+	int i;
+
 	wpa_printf(MSG_DEBUG, "WPS: Process Credential");
 
-	/* TODO: support multiple Network Keys */
 	if (wps_process_cred_network_idx(cred, attr->network_idx) ||
 	    wps_process_cred_ssid(cred, attr->ssid, attr->ssid_len) ||
 	    wps_process_cred_auth_type(cred, attr->auth_type) ||
 	    wps_process_cred_encr_type(cred, attr->encr_type) ||
 	    wps_process_cred_network_key_idx(cred, attr->network_key_idx) ||
-	    wps_process_cred_network_key(cred, attr->network_key,
-					 attr->network_key_len) ||
 	    wps_process_cred_mac_addr(cred, attr->mac_addr) ||
 	    wps_process_cred_eap_type(cred, attr->eap_type,
 				      attr->eap_type_len) ||
@@ -296,6 +303,11 @@
 	    wps_process_cred_802_1x_enabled(cred, attr->dot1x_enabled))
 		return -1;
 
+	for (i = 0; i < cred->keys_num; i++)
+		if (wps_process_cred_network_key(i, cred, attr->network_key,
+					 attr->network_key_len))
+			return -1;
+
 	wps_workaround_cred_key(cred);
 
 	return 0;
@@ -312,7 +324,7 @@
 	    wps_process_cred_auth_type(cred, attr->auth_type) ||
 	    wps_process_cred_encr_type(cred, attr->encr_type) ||
 	    wps_process_cred_network_key_idx(cred, attr->network_key_idx) ||
-	    wps_process_cred_network_key(cred, attr->network_key,
+	    wps_process_cred_network_key(0, cred, attr->network_key,
 					 attr->network_key_len) ||
 	    wps_process_cred_mac_addr(cred, attr->mac_addr))
 		return -1;
diff -Nur hostap-06-d23bf71/src/wps/wps_common.c hostap06/src/wps/wps_common.c
--- hostap-06-d23bf71/src/wps/wps_common.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_common.c	2009-03-23 14:17:09.000000000 +0200
@@ -128,6 +128,56 @@
 }
 
 
+int wps_derive_mgmt_keys(struct wps_data *wps)
+{
+	u8 nonces[2 * WPS_NONCE_LEN];
+	u8 keys[WPS_MGMTAUTHKEY_LEN + WPS_MGMTENCKEY_LEN];
+	u8 hash[SHA256_MAC_LEN];
+	const u8 *addr[2];
+	size_t len[2];
+	const char *auth_label = "WFA-WLAN-Management-MgmtAuthKey";
+	const char *enc_label = "WFA-WLAN-Management-MgmtEncKey";
+
+	/* MgmtAuthKey || MgmtEncKey =
+	 * kdf(EMSK, N1 || N2 || "WFA-WLAN-Management-Keys", 384) */
+	os_memcpy(nonces, wps->nonce_e, WPS_NONCE_LEN);
+	os_memcpy(nonces + WPS_NONCE_LEN, wps->nonce_r, WPS_NONCE_LEN);
+	wps_kdf(wps->emsk, nonces, sizeof(nonces), "WFA-WLAN-Management-Keys",
+		keys, sizeof(keys));
+	os_memcpy(wps->mgmt_auth_key, keys, WPS_MGMTAUTHKEY_LEN);
+	os_memcpy(wps->mgmt_enc_key, keys + WPS_MGMTAUTHKEY_LEN,
+		  WPS_MGMTENCKEY_LEN);
+
+	addr[0] = nonces;
+	len[0] = sizeof(nonces);
+
+	/* MgmtEncKeyID = first 128 bits of
+	 * SHA-256(N1 || N2 || "WFA-WLAN-Management-MgmtAuthKey") */
+	addr[1] = (const u8 *) auth_label;
+	len[1] = os_strlen(auth_label);
+	sha256_vector(2, addr, len, hash);
+	os_memcpy(wps->mgmt_auth_key_id, hash, WPS_MGMT_KEY_ID_LEN);
+
+	/* MgmtEncKeyID = first 128 bits of
+	 * SHA-256(N1 || N2 || "WFA-WLAN-Management-MgmtEncKey") */
+	addr[1] = (const u8 *) enc_label;
+	len[1] = os_strlen(enc_label);
+	sha256_vector(2, addr, len, hash);
+	os_memcpy(wps->mgmt_enc_key_id, hash, WPS_MGMT_KEY_ID_LEN);
+
+	wpa_hexdump_key(MSG_DEBUG, "WPS: MgmtAuthKey",
+			wps->mgmt_auth_key, WPS_MGMTAUTHKEY_LEN);
+	wpa_hexdump(MSG_DEBUG, "WPS: MgmtAuthKeyID",
+		    wps->mgmt_auth_key_id, WPS_MGMT_KEY_ID_LEN);
+	wpa_hexdump_key(MSG_DEBUG, "WPS: MgmtEncKey",
+			wps->mgmt_enc_key, WPS_MGMTENCKEY_LEN);
+	wpa_hexdump(MSG_DEBUG, "WPS: MgmtEncKeyID",
+		    wps->mgmt_enc_key_id, WPS_MGMT_KEY_ID_LEN);
+
+	return 0;
+}
+
+
 void wps_derive_psk(struct wps_data *wps, const u8 *dev_passwd,
 		    size_t dev_passwd_len)
 {
@@ -285,21 +335,3 @@
 	data.pwd_auth_fail.part = part;
 	wps->event_cb(wps->cb_ctx, WPS_EV_PWD_AUTH_FAIL, &data);
 }
-
-
-void wps_pbc_overlap_event(struct wps_context *wps)
-{
-	if (wps->event_cb == NULL)
-		return;
-
-	wps->event_cb(wps->cb_ctx, WPS_EV_PBC_OVERLAP, NULL);
-}
-
-
-void wps_pbc_timeout_event(struct wps_context *wps)
-{
-	if (wps->event_cb == NULL)
-		return;
-
-	wps->event_cb(wps->cb_ctx, WPS_EV_PBC_TIMEOUT, NULL);
-}
diff -Nur hostap-06-d23bf71/src/wps/wps_enrollee.c hostap06/src/wps/wps_enrollee.c
--- hostap-06-d23bf71/src/wps/wps_enrollee.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_enrollee.c	2009-03-23 14:17:09.000000000 +0200
@@ -521,6 +521,10 @@
 	if (wps_derive_keys(wps) < 0)
 		return -1;
 
+	if (wps->request_type == WPS_REQ_WLAN_MANAGER_REGISTRAR &&
+	    wps_derive_mgmt_keys(wps) < 0)
+		return -1;
+
 	return 0;
 }
 
@@ -646,21 +650,6 @@
 	    wps_process_cred(&attr, &wps->cred))
 		return -1;
 
-	if (os_memcmp(wps->cred.mac_addr, wps->wps->dev.mac_addr, ETH_ALEN) !=
-	    0) {
-		wpa_printf(MSG_DEBUG, "WPS: MAC Address in the Credential ("
-			   MACSTR ") does not match with own address (" MACSTR
-			   ")", MAC2STR(wps->cred.mac_addr),
-			   MAC2STR(wps->wps->dev.mac_addr));
-		/*
-		 * In theory, this could be consider fatal error, but there are
-		 * number of deployed implementations using other address here
-		 * due to unclarity in the specification. For interoperability
-		 * reasons, allow this to be processed since we do not really
-		 * use the MAC Address information for anything.
-		 */
-	}
-
 	if (wps->wps->cred_cb) {
 		wps->cred.cred_attr = cred - 4;
 		wps->cred.cred_attr_len = cred_len + 4;
@@ -711,21 +700,6 @@
 	wpa_printf(MSG_INFO, "WPS: Received new AP configuration from "
 		   "Registrar");
 
-	if (os_memcmp(cred.mac_addr, wps->wps->dev.mac_addr, ETH_ALEN) !=
-	    0) {
-		wpa_printf(MSG_DEBUG, "WPS: MAC Address in the AP Settings ("
-			   MACSTR ") does not match with own address (" MACSTR
-			   ")", MAC2STR(cred.mac_addr),
-			   MAC2STR(wps->wps->dev.mac_addr));
-		/*
-		 * In theory, this could be consider fatal error, but there are
-		 * number of deployed implementations using other address here
-		 * due to unclarity in the specification. For interoperability
-		 * reasons, allow this to be processed since we do not really
-		 * use the MAC Address information for anything.
-		 */
-	}
-
 	if (wps->wps->cred_cb) {
 		cred.cred_attr = wpabuf_head(attrs);
 		cred.cred_attr_len = wpabuf_len(attrs);
@@ -1185,17 +1159,6 @@
 		   "op_code=%d)",
 		   (unsigned long) wpabuf_len(msg), op_code);
 
-	if (op_code == WSC_UPnP) {
-		/* Determine the OpCode based on message type attribute */
-		struct wps_parse_attr attr;
-		if (wps_parse_msg(msg, &attr) == 0 && attr.msg_type) {
-			if (*attr.msg_type == WPS_WSC_ACK)
-				op_code = WSC_ACK;
-			else if (*attr.msg_type == WPS_WSC_NACK)
-				op_code = WSC_NACK;
-		}
-	}
-
 	switch (op_code) {
 	case WSC_MSG:
 	case WSC_UPnP:
diff -Nur hostap-06-d23bf71/src/wps/wps.h hostap06/src/wps/wps.h
--- hostap-06-d23bf71/src/wps/wps.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps.h	2009-08-12 12:53:29.000000000 +0300
@@ -33,6 +33,8 @@
 struct wps_registrar;
 struct upnp_wps_device_sm;
 
+#define MAX_NW_KEYS 4
+
 /**
  * struct wps_credential - WPS Credential
  * @ssid: SSID
@@ -42,7 +44,7 @@
  * @key_idx: Key index
  * @key: Key
  * @key_len: Key length in octets
- * @mac_addr: MAC address of the Credential receiver
+ * @mac_addr: MAC address of the peer
  * @cred_attr: Unparsed Credential attribute data (used only in cred_cb());
  *	this may be %NULL, if not used
  * @cred_attr_len: Length of cred_attr in octets
@@ -52,9 +54,9 @@
 	size_t ssid_len;
 	u16 auth_type;
 	u16 encr_type;
-	u8 key_idx;
-	u8 key[64];
-	size_t key_len;
+	u8 keys_num;
+	u8 key[MAX_NW_KEYS][64];
+	size_t key_len[MAX_NW_KEYS];
 	u8 mac_addr[ETH_ALEN];
 	const u8 *cred_attr;
 	size_t cred_attr_len;
@@ -296,17 +298,7 @@
 	/**
 	 * WPS_EV_PWD_AUTH_FAIL - Password authentication failed
 	 */
-	WPS_EV_PWD_AUTH_FAIL,
-
-	/**
-	 * WPS_EV_PBC_OVERLAP - PBC session overlap detected
-	 */
-	WPS_EV_PBC_OVERLAP,
-
-	/**
-	 * WPS_EV_PBC_TIMEOUT - PBC walktime expired before protocol run start
-	 */
-	WPS_EV_PBC_TIMEOUT
+	WPS_EV_PWD_AUTH_FAIL
 };
 
 /**
@@ -515,7 +507,7 @@
 		   const struct wps_registrar_config *cfg);
 void wps_registrar_deinit(struct wps_registrar *reg);
 int wps_registrar_add_pin(struct wps_registrar *reg, const u8 *uuid,
-			  const u8 *pin, size_t pin_len, int timeout);
+			  const u8 *pin, size_t pin_len);
 int wps_registrar_invalidate_pin(struct wps_registrar *reg, const u8 *uuid);
 int wps_registrar_unlock_pin(struct wps_registrar *reg, const u8 *uuid);
 int wps_registrar_button_pushed(struct wps_registrar *reg);
diff -Nur hostap-06-d23bf71/src/wps/wps_i.h hostap06/src/wps/wps_i.h
--- hostap-06-d23bf71/src/wps/wps_i.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_i.h	2009-08-12 12:53:29.000000000 +0300
@@ -62,6 +62,10 @@
 	u8 authkey[WPS_AUTHKEY_LEN];
 	u8 keywrapkey[WPS_KEYWRAPKEY_LEN];
 	u8 emsk[WPS_EMSK_LEN];
+	u8 mgmt_auth_key[WPS_MGMTAUTHKEY_LEN];
+	u8 mgmt_auth_key_id[WPS_MGMT_KEY_ID_LEN];
+	u8 mgmt_enc_key[WPS_MGMTENCKEY_LEN];
+	u8 mgmt_enc_key_id[WPS_MGMT_KEY_ID_LEN];
 
 	struct wpabuf *last_msg;
 
@@ -142,7 +146,6 @@
 	const u8 *selected_registrar; /* 1 octet (Bool) */
 	const u8 *request_type; /* 1 octet */
 	const u8 *response_type; /* 1 octet */
-	const u8 *ap_setup_locked; /* 1 octet */
 
 	/* variable length fields */
 	const u8 *manufacturer;
@@ -161,8 +164,9 @@
 	size_t encr_settings_len;
 	const u8 *ssid; /* <= 32 octets */
 	size_t ssid_len;
-	const u8 *network_key; /* <= 64 octets */
-	size_t network_key_len;
+	const u8 *network_key[MAX_NW_KEYS]; /* <= 64 octets */
+	size_t network_key_len[MAX_NW_KEYS];
+	size_t num_nw_key;
 	const u8 *eap_type; /* <= 8 octets */
 	size_t eap_type_len;
 	const u8 *eap_identity; /* <= 64 octets */
@@ -179,6 +183,7 @@
 void wps_kdf(const u8 *key, const u8 *label_prefix, size_t label_prefix_len,
 	     const char *label, u8 *res, size_t res_len);
 int wps_derive_keys(struct wps_data *wps);
+int wps_derive_mgmt_keys(struct wps_data *wps);
 void wps_derive_psk(struct wps_data *wps, const u8 *dev_passwd,
 		    size_t dev_passwd_len);
 struct wpabuf * wps_decrypt_encr_settings(struct wps_data *wps, const u8 *encr,
@@ -186,8 +191,6 @@
 void wps_fail_event(struct wps_context *wps, enum wps_msg_type msg);
 void wps_success_event(struct wps_context *wps);
 void wps_pwd_auth_fail_event(struct wps_context *wps, int enrollee, int part);
-void wps_pbc_overlap_event(struct wps_context *wps);
-void wps_pbc_timeout_event(struct wps_context *wps);
 
 /* wps_attr_parse.c */
 int wps_parse_msg(const struct wpabuf *msg, struct wps_parse_attr *attr);
diff -Nur hostap-06-d23bf71/src/wps/wps_registrar.c hostap06/src/wps/wps_registrar.c
--- hostap-06-d23bf71/src/wps/wps_registrar.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_registrar.c	2009-11-02 15:53:01.000000000 +0200
@@ -23,7 +23,6 @@
 #include "wps_dev_attr.h"
 #include "wps_upnp.h"
 
-#define WPS_WORKAROUNDS
 
 struct wps_uuid_pin {
 	struct wps_uuid_pin *next;
@@ -31,10 +30,7 @@
 	int wildcard_uuid;
 	u8 *pin;
 	size_t pin_len;
-#define PIN_LOCKED BIT(0)
-#define PIN_EXPIRES BIT(1)
-	int flags;
-	struct os_time expiration;
+	int locked;
 };
 
 
@@ -103,8 +99,6 @@
 	int sel_reg_dev_password_id_override;
 	int sel_reg_config_methods_override;
 	int static_wep_only;
-
-	int force_pbc_overlap;
 };
 
 
@@ -417,11 +411,10 @@
  * @uuid: UUID-E or %NULL for wildcard (any UUID)
  * @pin: PIN (Device Password)
  * @pin_len: Length of pin in octets
- * @timeout: Time (in seconds) when the PIN will be invalidated; 0 = no timeout
  * Returns: 0 on success, -1 on failure
  */
 int wps_registrar_add_pin(struct wps_registrar *reg, const u8 *uuid,
-			  const u8 *pin, size_t pin_len, int timeout)
+			  const u8 *pin, size_t pin_len)
 {
 	struct wps_uuid_pin *p;
 
@@ -440,17 +433,10 @@
 	os_memcpy(p->pin, pin, pin_len);
 	p->pin_len = pin_len;
 
-	if (timeout) {
-		p->flags |= PIN_EXPIRES;
-		os_get_time(&p->expiration);
-		p->expiration.sec += timeout;
-	}
-
 	p->next = reg->pins;
 	reg->pins = p;
 
-	wpa_printf(MSG_DEBUG, "WPS: A new PIN configured (timeout=%d)",
-		   timeout);
+	wpa_printf(MSG_DEBUG, "WPS: A new PIN configured");
 	wpa_hexdump(MSG_DEBUG, "WPS: UUID", uuid, WPS_UUID_LEN);
 	wpa_hexdump_ascii_key(MSG_DEBUG, "WPS: PIN", pin, pin_len);
 	reg->selected_registrar = 1;
@@ -465,34 +451,6 @@
 }
 
 
-static void wps_registrar_expire_pins(struct wps_registrar *reg)
-{
-	struct wps_uuid_pin *pin, *prev, *del;
-	struct os_time now;
-
-	os_get_time(&now);
-	prev = NULL;
-	pin = reg->pins;
-	while (pin) {
-		if ((pin->flags & PIN_EXPIRES) &&
-		    os_time_before(&pin->expiration, &now)) {
-			if (prev == NULL)
-				reg->pins = pin->next;
-			else
-				prev->next = pin->next;
-			del = pin;
-			pin = pin->next;
-			wpa_hexdump(MSG_DEBUG, "WPS: Expired PIN for UUID",
-				    del->uuid, WPS_UUID_LEN);
-			wps_free_pin(del);
-			continue;
-		}
-		prev = pin;
-		pin = pin->next;
-	}
-}
-
-
 /**
  * wps_registrar_invalidate_pin - Invalidate a PIN for a specific UUID-E
  * @reg: Registrar data from wps_registrar_init()
@@ -529,8 +487,6 @@
 {
 	struct wps_uuid_pin *pin;
 
-	wps_registrar_expire_pins(reg);
-
 	pin = reg->pins;
 	while (pin) {
 		if (!pin->wildcard_uuid &&
@@ -562,13 +518,13 @@
 	 * Lock the PIN to avoid attacks based on concurrent re-use of the PIN
 	 * that could otherwise avoid PIN invalidations.
 	 */
-	if (pin->flags & PIN_LOCKED) {
+	if (pin->locked) {
 		wpa_printf(MSG_DEBUG, "WPS: Selected PIN locked - do not "
 			   "allow concurrent re-use");
 		return NULL;
 	}
 	*pin_len = pin->pin_len;
-	pin->flags |= PIN_LOCKED;
+	pin->locked = 1;
 	return pin->pin;
 }
 
@@ -595,7 +551,7 @@
 					   "wildcard PIN");
 				return wps_registrar_invalidate_pin(reg, uuid);
 			}
-			pin->flags &= ~PIN_LOCKED;
+			pin->locked = 0;
 			return 0;
 		}
 		pin = pin->next;
@@ -618,7 +574,6 @@
 	struct wps_registrar *reg = eloop_ctx;
 
 	wpa_printf(MSG_DEBUG, "WPS: PBC timed out - disable PBC mode");
-	wps_pbc_timeout_event(reg->wps);
 	wps_registrar_stop_pbc(reg);
 }
 
@@ -637,11 +592,9 @@
 	if (wps_registrar_pbc_overlap(reg, NULL, NULL)) {
 		wpa_printf(MSG_DEBUG, "WPS: PBC overlap - do not start PBC "
 			   "mode");
-		wps_pbc_overlap_event(reg->wps);
 		return -1;
 	}
 	wpa_printf(MSG_DEBUG, "WPS: Button pushed - PBC mode started");
-	reg->force_pbc_overlap = 0;
 	reg->selected_registrar = 1;
 	reg->pbc = 1;
 	wps_set_ie(reg);
@@ -709,18 +662,8 @@
 
 	wpa_printf(MSG_DEBUG, "WPS: Probe Request for PBC received from "
 		   MACSTR, MAC2STR(addr));
-	if (attr.uuid_e == NULL) {
-		wpa_printf(MSG_DEBUG, "WPS: Invalid Probe Request WPS IE: No "
-			   "UUID-E included");
-		return;
-	}
 
 	wps_registrar_add_pbc_session(reg, addr, attr.uuid_e);
-	if (wps_registrar_pbc_overlap(reg, addr, attr.uuid_e)) {
-		wpa_printf(MSG_DEBUG, "WPS: PBC session overlap detected");
-		reg->force_pbc_overlap = 1;
-		wps_pbc_overlap_event(reg->wps);
-	}
 }
 
 
@@ -1042,8 +985,8 @@
 {
 	wpa_printf(MSG_DEBUG, "WPS:  * Network Key");
 	wpabuf_put_be16(msg, ATTR_NETWORK_KEY);
-	wpabuf_put_be16(msg, cred->key_len);
-	wpabuf_put_data(msg, cred->key, cred->key_len);
+	wpabuf_put_be16(msg, cred->key_len[0]);
+	wpabuf_put_data(msg, cred->key[0], cred->key_len[0]);
 	return 0;
 }
 
@@ -1126,10 +1069,8 @@
 		}
 	}
 	wps->cred.encr_type = wps->encr_type;
-	/*
-	 * Set MAC address in the Credential to be the Enrollee's MAC address
-	 */
-	os_memcpy(wps->cred.mac_addr, wps->mac_addr_e, ETH_ALEN);
+	/* Set MAC address in the Credential to be the AP's address (BSSID) */
+	os_memcpy(wps->cred.mac_addr, wps->wps->dev.mac_addr, ETH_ALEN);
 
 	if (wps->wps->wps_state == WPS_STATE_NOT_CONFIGURED && wps->wps->ap &&
 	    !wps->wps->registrar->disable_auto_conf) {
@@ -1148,11 +1089,11 @@
 		wpa_hexdump_ascii_key(MSG_DEBUG, "WPS: Generated passphrase",
 				      wps->new_psk, wps->new_psk_len);
 		os_memcpy(wps->cred.key, wps->new_psk, wps->new_psk_len);
-		wps->cred.key_len = wps->new_psk_len;
+		wps->cred.key_len[0] = wps->new_psk_len;
 	} else if (wps->wps->network_key) {
 		os_memcpy(wps->cred.key, wps->wps->network_key,
 			  wps->wps->network_key_len);
-		wps->cred.key_len = wps->wps->network_key_len;
+		wps->cred.key_len[0] = wps->wps->network_key_len;
 	} else if (wps->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK)) {
 		char hex[65];
 		/* Generate a random per-device PSK */
@@ -1171,7 +1112,7 @@
 		wpa_snprintf_hex(hex, sizeof(hex), wps->new_psk,
 				 wps->new_psk_len);
 		os_memcpy(wps->cred.key, hex, wps->new_psk_len * 2);
-		wps->cred.key_len = wps->new_psk_len * 2;
+		wps->cred.key_len[0] = wps->new_psk_len * 2;
 	}
 
 	cred = wpabuf_alloc(200);
@@ -1254,15 +1195,14 @@
 static struct wpabuf * wps_build_m2d(struct wps_data *wps)
 {
 	struct wpabuf *msg;
-	u16 err = wps->config_error;
+	u16 err = WPS_CFG_NO_ERROR;
 
 	wpa_printf(MSG_DEBUG, "WPS: Building Message M2D");
 	msg = wpabuf_alloc(1000);
 	if (msg == NULL)
 		return NULL;
 
-	if (wps->wps->ap && wps->wps->ap_setup_locked &&
-	    err == WPS_CFG_NO_ERROR)
+	if (wps->wps->ap && wps->wps->ap_setup_locked)
 		err = WPS_CFG_SETUP_LOCKED;
 
 	if (wps_build_version(msg) ||
@@ -1464,18 +1404,8 @@
 			else
 				wps->wps->upnp_msgs = NULL;
 			msg = p->msg;
-			switch (p->type) {
-			case WPS_WSC_ACK:
-				*op_code = WSC_ACK;
-				break;
-			case WPS_WSC_NACK:
-				*op_code = WSC_NACK;
-				break;
-			default:
-				*op_code = WSC_MSG;
-				break;
-			}
 			os_free(p);
+			*op_code = WSC_MSG;
 			if (wps->ext_reg == 0)
 				wps->ext_reg = 1;
 			return msg;
@@ -1760,21 +1690,7 @@
 		wpa_printf(MSG_DEBUG, "WPS: No match in supported "
 			   "authentication types (own 0x%x Enrollee 0x%x)",
 			   wps->wps->auth_types, auth_types);
-#ifdef WPS_WORKAROUNDS
-		/*
-		 * Some deployed implementations seem to advertise incorrect
-		 * information in this attribute. For example, Linksys WRT350N
-		 * seems to have a byteorder bug that breaks this negotiation.
-		 * In order to interoperate with existing implementations,
-		 * assume that the Enrollee supports everything we do.
-		 */
-		wpa_printf(MSG_DEBUG, "WPS: Workaround - assume Enrollee "
-			   "does not advertise supported authentication types "
-			   "correctly");
-		wps->auth_type = wps->wps->auth_types;
-#else /* WPS_WORKAROUNDS */
 		return -1;
-#endif /* WPS_WORKAROUNDS */
 	}
 
 	return 0;
@@ -1798,23 +1714,8 @@
 	wps->encr_type = wps->wps->encr_types & encr_types;
 	if (wps->encr_type == 0) {
 		wpa_printf(MSG_DEBUG, "WPS: No match in supported "
-			   "encryption types (own 0x%x Enrollee 0x%x)",
-			   wps->wps->encr_types, encr_types);
-#ifdef WPS_WORKAROUNDS
-		/*
-		 * Some deployed implementations seem to advertise incorrect
-		 * information in this attribute. For example, Linksys WRT350N
-		 * seems to have a byteorder bug that breaks this negotiation.
-		 * In order to interoperate with existing implementations,
-		 * assume that the Enrollee supports everything we do.
-		 */
-		wpa_printf(MSG_DEBUG, "WPS: Workaround - assume Enrollee "
-			   "does not advertise supported encryption types "
-			   "correctly");
-		wps->encr_type = wps->wps->encr_types;
-#else /* WPS_WORKAROUNDS */
+			   "encryption types");
 		return -1;
-#endif /* WPS_WORKAROUNDS */
 	}
 
 	return 0;
@@ -1941,15 +1842,11 @@
 	}
 
 	if (wps->dev_pw_id == DEV_PW_PUSHBUTTON) {
-		if (wps->wps->registrar->force_pbc_overlap ||
-		    wps_registrar_pbc_overlap(wps->wps->registrar,
+		if (wps_registrar_pbc_overlap(wps->wps->registrar,
 					      wps->mac_addr_e, wps->uuid_e)) {
 			wpa_printf(MSG_DEBUG, "WPS: PBC overlap - deny PBC "
 				   "negotiation");
 			wps->state = SEND_M2D;
-			wps->config_error = WPS_CFG_MULTIPLE_PBC_DETECTED;
-			wps_pbc_overlap_event(wps->wps);
-			wps->wps->registrar->force_pbc_overlap = 1;
 			return WPS_CONTINUE;
 		}
 		wps_registrar_add_pbc_session(wps->wps->registrar,
@@ -1975,14 +1872,6 @@
 		return WPS_CONTINUE;
 	}
 
-	if (wps->pbc && wps->wps->registrar->force_pbc_overlap) {
-		wpa_printf(MSG_DEBUG, "WPS: Reject negotiation due to PBC "
-			   "session overlap");
-		wps->state = SEND_WSC_NACK;
-		wps->config_error = WPS_CFG_MULTIPLE_PBC_DETECTED;
-		return WPS_CONTINUE;
-	}
-
 	if (wps_process_registrar_nonce(wps, attr->registrar_nonce) ||
 	    wps_process_authenticator(wps, attr->authenticator, msg) ||
 	    wps_process_e_hash1(wps, attr->e_hash1) ||
@@ -2012,14 +1901,6 @@
 		return WPS_CONTINUE;
 	}
 
-	if (wps->pbc && wps->wps->registrar->force_pbc_overlap) {
-		wpa_printf(MSG_DEBUG, "WPS: Reject negotiation due to PBC "
-			   "session overlap");
-		wps->state = SEND_WSC_NACK;
-		wps->config_error = WPS_CFG_MULTIPLE_PBC_DETECTED;
-		return WPS_CONTINUE;
-	}
-
 	if (wps_process_registrar_nonce(wps, attr->registrar_nonce) ||
 	    wps_process_authenticator(wps, attr->authenticator, msg)) {
 		wps->state = SEND_WSC_NACK;
@@ -2051,28 +1932,6 @@
 }
 
 
-static void wps_sta_cred_cb(struct wps_data *wps)
-{
-	/*
-	 * Update credential to only include a single authentication and
-	 * encryption type in case the AP configuration includes more than one
-	 * option.
-	 */
-	if (wps->cred.auth_type & WPS_AUTH_WPA2PSK)
-		wps->cred.auth_type = WPS_AUTH_WPA2PSK;
-	else if (wps->cred.auth_type & WPS_AUTH_WPAPSK)
-		wps->cred.auth_type = WPS_AUTH_WPAPSK;
-	if (wps->cred.encr_type & WPS_ENCR_AES)
-		wps->cred.encr_type = WPS_ENCR_AES;
-	else if (wps->cred.encr_type & WPS_ENCR_TKIP)
-		wps->cred.encr_type = WPS_ENCR_TKIP;
-	wpa_printf(MSG_DEBUG, "WPS: Update local configuration based on the "
-		   "AP configuration");
-	if (wps->wps->cred_cb)
-		wps->wps->cred_cb(wps->wps->cb_ctx, &wps->cred);
-}
-
-
 static int wps_process_ap_settings_r(struct wps_data *wps,
 				     struct wps_parse_attr *attr)
 {
@@ -2085,21 +1944,12 @@
 
 	wpa_printf(MSG_INFO, "WPS: Received old AP configuration from AP");
 
-#if 0
 	/*
 	 * TODO: Provide access to AP settings and allow changes before sending
 	 * out M8. For now, just copy the settings unchanged into M8.
 	 */
 
 	return 0;
-#else
-	/*
-	 * For now, use the AP PIN only to receive the current AP settings,
-	 * not to reconfigure the AP.
-	 */
-	wps_sta_cred_cb(wps);
-	return 1;
-#endif
 }
 
 
@@ -2119,14 +1969,6 @@
 		return WPS_CONTINUE;
 	}
 
-	if (wps->pbc && wps->wps->registrar->force_pbc_overlap) {
-		wpa_printf(MSG_DEBUG, "WPS: Reject negotiation due to PBC "
-			   "session overlap");
-		wps->state = SEND_WSC_NACK;
-		wps->config_error = WPS_CFG_MULTIPLE_PBC_DETECTED;
-		return WPS_CONTINUE;
-	}
-
 	if (wps_process_registrar_nonce(wps, attr->registrar_nonce) ||
 	    wps_process_authenticator(wps, attr->authenticator, msg)) {
 		wps->state = SEND_WSC_NACK;
@@ -2462,7 +2304,7 @@
 		cred.auth_type = WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK;
 		cred.encr_type = WPS_ENCR_TKIP | WPS_ENCR_AES;
 		os_memcpy(cred.key, wps->new_psk, wps->new_psk_len);
-		cred.key_len = wps->new_psk_len;
+		cred.key_len[0] = wps->new_psk_len;
 
 		wps->wps->wps_state = WPS_STATE_CONFIGURED;
 		wpa_hexdump_ascii_key(MSG_DEBUG,
@@ -2475,8 +2317,25 @@
 		wps->new_psk = NULL;
 	}
 
-	if (!wps->wps->ap)
-		wps_sta_cred_cb(wps);
+	if (!wps->wps->ap) {
+		/*
+		 * Update credential to only include a single authentication
+		 * and encryption type in case the AP configuration includes
+		 * more than one option.
+		 */
+		if (wps->cred.auth_type & WPS_AUTH_WPA2PSK)
+			wps->cred.auth_type = WPS_AUTH_WPA2PSK;
+		else if (wps->cred.auth_type & WPS_AUTH_WPAPSK)
+			wps->cred.auth_type = WPS_AUTH_WPAPSK;
+		if (wps->cred.encr_type & WPS_ENCR_AES)
+			wps->cred.encr_type = WPS_ENCR_AES;
+		else if (wps->cred.encr_type & WPS_ENCR_TKIP)
+			wps->cred.encr_type = WPS_ENCR_TKIP;
+		wpa_printf(MSG_DEBUG, "WPS: Update local configuration based "
+			   "on the modified AP configuration");
+		if (wps->wps->cred_cb)
+			wps->wps->cred_cb(wps->wps->cb_ctx, &wps->cred);
+	}
 
 	if (wps->new_psk) {
 		if (wps_cb_new_psk(wps->wps->registrar, wps->mac_addr_e,
@@ -2525,8 +2384,7 @@
 		wps_registrar_free_pending_m2(wps->wps);
 	if (wps->wps->wps_upnp && wps->ext_reg &&
 	    wps->wps->upnp_msgs == NULL &&
-	    (op_code == WSC_MSG || op_code == WSC_Done || op_code == WSC_NACK))
-	{
+	    (op_code == WSC_MSG || op_code == WSC_Done)) {
 		struct wps_parse_attr attr;
 		int type;
 		if (wps_parse_msg(msg, &attr) < 0 || attr.msg_type == NULL)
diff -Nur hostap-06-d23bf71/src/wps/wps_upnp.c hostap06/src/wps/wps_upnp.c
--- hostap-06-d23bf71/src/wps/wps_upnp.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_upnp.c	2009-03-23 14:17:09.000000000 +0200
@@ -47,6 +47,9 @@
  * -- Needs renaming with module prefix to avoid polluting the debugger
  * namespace and causing possible collisions with other static fncs
  * and structure declarations when using the debugger.
+ * -- Just what should be in the first event message sent after subscription
+ * for the WLANEvent field? If i pass it empty, Vista replies with OK
+ * but apparently barfs on the message.
  * -- The http error code generation is pretty bogus, hopefully noone cares.
  *
  * Author: Ted Merrill, Atheros Communications, based upon earlier work
@@ -638,27 +641,6 @@
 }
 
 
-static struct wpabuf * build_fake_wsc_ack(void)
-{
-	struct wpabuf *msg = wpabuf_alloc(100);
-	if (msg == NULL)
-		return NULL;
-	wpabuf_put_u8(msg, UPNP_WPS_WLANEVENT_TYPE_EAP);
-	wpabuf_put_str(msg, "00:00:00:00:00:00");
-	wps_build_version(msg);
-	wps_build_msg_type(msg, WPS_WSC_ACK);
-	/* Enrollee Nonce */
-	wpabuf_put_be16(msg, ATTR_ENROLLEE_NONCE);
-	wpabuf_put_be16(msg, WPS_NONCE_LEN);
-	wpabuf_put(msg, WPS_NONCE_LEN);
-	/* Registrar Nonce */
-	wpabuf_put_be16(msg, ATTR_REGISTRAR_NONCE);
-	wpabuf_put_be16(msg, WPS_NONCE_LEN);
-	wpabuf_put(msg, WPS_NONCE_LEN);
-	return msg;
-}
-
-
 /* subscription_first_event -- send format/queue event that is automatically
  * sent on a new subscription.
  */
@@ -683,28 +665,6 @@
 	const char *tail = "</e:propertyset>\n";
 	char txt[10];
 
-	if (s->sm->wlanevent == NULL) {
-		/*
-		 * There has been no events before the subscription. However,
-		 * UPnP device architecture specification requires all the
-		 * evented variables to be included, so generate a dummy event
-		 * for this particular case using a WSC_ACK and all-zeros
-		 * nonces. The ER (UPnP control point) will ignore this, but at
-		 * least it will learn that WLANEvent variable will be used in
-		 * event notifications in the future.
-		 */
-		struct wpabuf *msg;
-		wpa_printf(MSG_DEBUG, "WPS UPnP: Use a fake WSC_ACK as the "
-			   "initial WLANEvent");
-		msg = build_fake_wsc_ack();
-		if (msg) {
-			s->sm->wlanevent = (char *)
-				base64_encode(wpabuf_head(msg),
-					      wpabuf_len(msg), NULL);
-			wpabuf_free(msg);
-		}
-	}
-
 	wlan_event = s->sm->wlanevent;
 	if (wlan_event == NULL || *wlan_event == '\0') {
 		wpa_printf(MSG_DEBUG, "WPS UPnP: WLANEvent not known for "
@@ -734,13 +694,13 @@
 
 
 /**
- * subscription_start - Remember a UPnP control point to send events to.
+ * subscription_start - Rremember a UPnP control point to send events to.
  * @sm: WPS UPnP state machine from upnp_wps_device_init()
- * @callback_urls: Callback URLs
+ * @callback_urls: malloc' mem given to the subscription
  * Returns: %NULL on error, or pointer to new subscription structure.
  */
 struct subscription * subscription_start(struct upnp_wps_device_sm *sm,
-					 const char *callback_urls)
+					 char *callback_urls)
 {
 	struct subscription *s;
 	time_t now = time(NULL);
@@ -780,6 +740,7 @@
 	}
 	wpa_printf(MSG_DEBUG, "WPS UPnP: Subscription %p started with %s",
 		   s, callback_urls);
+	os_free(callback_urls);
 	/* Schedule sending this */
 	event_send_all_later(sm);
 	return s;
@@ -1006,7 +967,8 @@
 		subscription_destroy(s);
 	}
 
-	advertisement_state_machine_stop(sm, 1);
+	advertisement_state_machine_stop(sm);
+	/* TODO: send byebye notifications */
 
 	event_send_stop_all(sm);
 	os_free(sm->wlanevent);
diff -Nur hostap-06-d23bf71/src/wps/wps_upnp_event.c hostap06/src/wps/wps_upnp_event.c
--- hostap-06-d23bf71/src/wps/wps_upnp_event.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_upnp_event.c	2009-03-23 14:17:09.000000000 +0200
@@ -89,7 +89,7 @@
 /* event_delete -- delete single unqueued event
  * (be sure to dequeue first if need be)
  */
-static void event_delete(struct wps_event_ *e)
+void event_delete(struct wps_event_ *e)
 {
 	event_clean(e);
 	wpabuf_free(e->data);
@@ -432,7 +432,7 @@
 
 
 /* event_send_all_later_handler -- actually send events as needed */
-static void event_send_all_later_handler(void *eloop_data, void *user_ctx)
+void event_send_all_later_handler(void *eloop_data, void *user_ctx)
 {
 	struct upnp_wps_device_sm *sm = user_ctx;
 	struct subscription *s;
diff -Nur hostap-06-d23bf71/src/wps/wps_upnp_i.h hostap06/src/wps/wps_upnp_i.h
--- hostap-06-d23bf71/src/wps/wps_upnp_i.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_upnp_i.h	2009-03-23 14:17:09.000000000 +0200
@@ -160,7 +160,7 @@
 /* wps_upnp.c */
 void format_date(struct wpabuf *buf);
 struct subscription * subscription_start(struct upnp_wps_device_sm *sm,
-					 const char *callback_urls);
+					 char *callback_urls);
 struct subscription * subscription_renew(struct upnp_wps_device_sm *sm,
 					 const u8 uuid[UUID_LEN]);
 void subscription_unlink(struct subscription *s);
@@ -172,8 +172,7 @@
 /* wps_upnp_ssdp.c */
 void msearchreply_state_machine_stop(struct advertisement_state_machine *a);
 int advertisement_state_machine_start(struct upnp_wps_device_sm *sm);
-void advertisement_state_machine_stop(struct upnp_wps_device_sm *sm,
-				      int send_byebye);
+void advertisement_state_machine_stop(struct upnp_wps_device_sm *sm);
 void ssdp_listener_stop(struct upnp_wps_device_sm *sm);
 int ssdp_listener_start(struct upnp_wps_device_sm *sm);
 int add_ssdp_network(char *net_if);
@@ -186,6 +185,7 @@
 
 /* wps_upnp_event.c */
 int event_add(struct subscription *s, const struct wpabuf *data);
+void event_delete(struct wps_event_ *e);
 void event_delete_all(struct subscription *s);
 void event_send_all_later(struct upnp_wps_device_sm *sm);
 void event_send_stop_all(struct upnp_wps_device_sm *sm);
diff -Nur hostap-06-d23bf71/src/wps/wps_upnp_ssdp.c hostap06/src/wps/wps_upnp_ssdp.c
--- hostap-06-d23bf71/src/wps/wps_upnp_ssdp.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_upnp_ssdp.c	2009-05-22 14:31:10.000000000 +0300
@@ -229,41 +229,10 @@
 /**
  * advertisement_state_machine_stop - Stop SSDP advertisements
  * @sm: WPS UPnP state machine from upnp_wps_device_init()
- * @send_byebye: Send byebye advertisement messages immediately
  */
-void advertisement_state_machine_stop(struct upnp_wps_device_sm *sm,
-				      int send_byebye)
+void advertisement_state_machine_stop(struct upnp_wps_device_sm *sm)
 {
-	struct advertisement_state_machine *a = &sm->advertisement;
-	int islast = 0;
-	struct wpabuf *msg;
-	struct sockaddr_in dest;
-
 	eloop_cancel_timeout(advertisement_state_machine_handler, NULL, sm);
-	if (!send_byebye || sm->multicast_sd < 0)
-		return;
-
-	a->type = ADVERTISE_DOWN;
-	a->state = 0;
-	a->sm = sm;
-
-	os_memset(&dest, 0, sizeof(dest));
-	dest.sin_family = AF_INET;
-	dest.sin_addr.s_addr = inet_addr(UPNP_MULTICAST_ADDRESS);
-	dest.sin_port = htons(UPNP_MULTICAST_PORT);
-
-	while (!islast) {
-		msg = next_advertisement(a, &islast);
-		if (msg == NULL)
-			break;
-		if (sendto(sm->multicast_sd, wpabuf_head(msg), wpabuf_len(msg),
-			   0, (struct sockaddr *) &dest, sizeof(dest)) < 0) {
-			wpa_printf(MSG_INFO, "WPS UPnP: Advertisement sendto "
-				   "failed: %d (%s)", errno, strerror(errno));
-		}
-		wpabuf_free(msg);
-		a->state++;
-	}
 }
 
 
@@ -349,7 +318,7 @@
 	struct advertisement_state_machine *a = &sm->advertisement;
 	int next_timeout_msec;
 
-	advertisement_state_machine_stop(sm, 0);
+	advertisement_state_machine_stop(sm);
 
 	/*
 	 * Start out advertising down, this automatically switches
@@ -830,11 +799,11 @@
 		goto fail;
 
 	rt.rt_dev = net_if;
-	sin = aliasing_hide_typecast(&rt.rt_dst, struct sockaddr_in);
+	sin = (struct sockaddr_in *) &rt.rt_dst;
 	sin->sin_family = AF_INET;
 	sin->sin_port = 0;
 	sin->sin_addr.s_addr = inet_addr(SSDP_TARGET);
-	sin = aliasing_hide_typecast(&rt.rt_genmask, struct sockaddr_in);
+	sin = (struct sockaddr_in *) &rt.rt_genmask;
 	sin->sin_family = AF_INET;
 	sin->sin_port = 0;
 	sin->sin_addr.s_addr = inet_addr(SSDP_NETMASK);
diff -Nur hostap-06-d23bf71/src/wps/wps_upnp_web.c hostap06/src/wps/wps_upnp_web.c
--- hostap-06-d23bf71/src/wps/wps_upnp_web.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/src/wps/wps_upnp_web.c	2009-03-23 14:17:09.000000000 +0200
@@ -1578,6 +1578,7 @@
 			ret = HTTP_INTERNAL_SERVER_ERROR;
 			goto error;
 		}
+		callback_urls = NULL;   /* is now owned by subscription */
 	} else {
 		ret = HTTP_PRECONDITION_FAILED;
 		goto error;
@@ -1629,7 +1630,6 @@
 	http_put_empty(buf, ret);
 	send_wpabuf(c->sd, buf);
 	wpabuf_free(buf);
-	os_free(callback_urls);
 }
 
 
diff -Nur hostap-06-d23bf71/wpa_supplicant/ChangeLog hostap06/wpa_supplicant/ChangeLog
--- hostap-06-d23bf71/wpa_supplicant/ChangeLog	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/ChangeLog	2009-05-22 14:31:10.000000000 +0300
@@ -1,21 +1,9 @@
 ChangeLog for wpa_supplicant
 
-2010-01-12 - v0.6.10
+????-??-?? - v0.6.10
 	* fixed SHA-256 based key derivation function to match with the
 	  standard when using CCMP (for IEEE 802.11r and IEEE 802.11w)
 	  (note: this breaks interoperability with previous version) [Bug 307]
-	* changed driver_wext to disconnect at init/deinit to clear state
-	* added explicit disconnect on 4-way handshake failures
-	* added WPS workarounds for known interoperability issues with broken,
-	  deployed implementation
-	* update IEEE 802.11w implementation to match with the published
-	  standard
-	* do not send WPS M8 message when learning current AP configuration as
-	  an external Registrar
-	* added a workaround for race condition between receive EAPOL frames
-	  and association events
-	* fixed compilation with newer GnuTLS versions
-	* fixed PKCS#12 use with OpenSSL 1.0.0
 
 2009-03-23 - v0.6.9
 	* driver_ndis: add PAE group address to the multicast address list to
diff -Nur hostap-06-d23bf71/wpa_supplicant/.config hostap06/wpa_supplicant/.config
--- hostap-06-d23bf71/wpa_supplicant/.config	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/wpa_supplicant/.config	2009-06-02 16:51:40.000000000 +0300
@@ -0,0 +1,383 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+#CONFIG_DRIVER_MADWIFI=y
+# Set include directory to the madwifi source tree
+#CFLAGS += -I../../madwifi
+
+# Driver interface for Prism54 driver
+# (Note: Prism54 is not yet supported, i.e., this will not work as-is and is
+# for developers only)
+#CONFIG_DRIVER_PRISM54=y
+
+# Driver interface for ndiswrapper
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for old Broadcom driver
+# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
+# Linux wireless extensions and does not need (or even work) with the old
+# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for Ralink driver
+#CONFIG_DRIVER_RALINK=y
+
+# Driver interface for generic Linux wireless extensions
+CONFIG_DRIVER_WEXT=y
+
+# Driver interface for Linux drivers using the nl80211 kernel interface
+#CONFIG_DRIVER_NL80211=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Driver interface for wired Ethernet drivers
+CONFIG_DRIVER_WIRED=y
+
+# Driver interface for the Broadcom RoboSwitch family
+#CONFIG_DRIVER_ROBOSWITCH=y
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+CONFIG_EAP_GTC=y
+
+# EAP-OTP
+CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+#CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# Enable USIM simulator (Milenage) for EAP-AKA
+#CONFIG_USIM_SIMULATOR=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-TNC and related Trusted Network Connect support (experimental)
+#CONFIG_EAP_TNC=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM)
+# Enable this if EAP-SIM or EAP-AKA is included
+#CONFIG_PCSC=y
+
+# Development testing
+#CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=y
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+# save about 1 kB in code size when building only WPA-Personal (no EAP support)
+# or 6 kB if building for WPA-Enterprise.
+#CONFIG_NO_WPA2=y
+
+# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
+# This option can be used to reduce code size by removing support for
+# converting ASCII passphrases into PSK. If this functionality is removed, the
+# PSK can only be configured as the 64-octet hexstring (e.g., from
+# wpa_passphrase). This saves about 0.5 kB in code size.
+#CONFIG_NO_WPA_PASSPHRASE=y
+
+# Remove AES extra functions. This can be used to reduce code size by about
+# 1.5 kB by removing extra AES modes that are not needed for commonly used
+# client configurations (they are needed for some EAP types).
+#CONFIG_NO_AES_EXTRAS=y
+
+# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
+# This can be used if ap_scan=1 mode is never enabled.
+#CONFIG_NO_SCAN_PROCESSING=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+#CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+#CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+#CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+#CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+#CONFIG_ELOOP=eloop
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+#CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+#CONFIG_TLS=openssl
+CONFIG_TLS=internal
+
+# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
+# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
+# even though the core GnuTLS library is released under LGPL, this extra
+# library uses GPL and as such, the terms of GPL apply to the combination
+# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
+# apply for distribution of the resulting binary.
+#CONFIG_GNUTLS_EXTRA=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for DBus control interface
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# Include client MLME (management frame processing).
+# This can be used to move MLME processing of Linux mac80211 stack into user
+# space. Please note that this is currently only available with
+# driver_nl80211.c and only with a modified version of Linux kernel and
+# wpa_supplicant.
+#CONFIG_CLIENT_MLME=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+#CONFIG_DEBUG_FILE=y
+
+# Enable privilege separation (see README 'Privilege separation' for details)
+#CONFIG_PRIVSEP=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
diff -Nur hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus.c hostap06/wpa_supplicant/ctrl_iface_dbus.c
--- hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/ctrl_iface_dbus.c	2009-03-23 14:17:09.000000000 +0200
@@ -540,8 +540,6 @@
 								      wpa_s);
 		else if (!strcmp(method, "state"))
 			reply = wpas_dbus_iface_get_state(message, wpa_s);
-		else if (!strcmp(method, "scanning"))
-			reply = wpas_dbus_iface_get_scanning(message, wpa_s);
 		else if (!strcmp(method, "setBlobs"))
 			reply = wpas_dbus_iface_set_blobs(message, wpa_s);
 		else if (!strcmp(method, "removeBlobs"))
@@ -605,9 +603,6 @@
 		} else if (!strcmp(method, "getInterface")) {
 			reply = wpas_dbus_global_get_interface(
 				message, ctrl_iface->global);
-		} else if (!strcmp(method, "setDebugParams")) {
-			reply = wpas_dbus_global_set_debugparams(
-				message, ctrl_iface->global);
 		}
 	}
 
@@ -746,58 +741,6 @@
 }
 
 
-/**
- * wpa_supplicant_dbus_notify_scanning - send scanning status
- * @wpa_s: %wpa_supplicant network interface data
- * Returns: 0 on success, -1 on failure
- *
- * Notify listeners of interface scanning state changes
- */
-void wpa_supplicant_dbus_notify_scanning(struct wpa_supplicant *wpa_s)
-{
-	struct ctrl_iface_dbus_priv *iface = wpa_s->global->dbus_ctrl_iface;
-	DBusMessage *_signal;
-	const char *path;
-	dbus_bool_t scanning = wpa_s->scanning ? TRUE : FALSE;
-
-	/* Do nothing if the control interface is not turned on */
-	if (iface == NULL)
-		return;
-
-	path = wpa_supplicant_get_dbus_path(wpa_s);
-	if (path == NULL) {
-		perror("wpa_supplicant_dbus_notify_scanning[dbus]: interface "
-		       "didn't have a dbus path");
-		wpa_printf(MSG_ERROR,
-		           "%s[dbus]: interface didn't have a dbus path; "
-			   "can't send scanning signal.", __FUNCTION__);
-		return;
-	}
-	_signal = dbus_message_new_signal(path, WPAS_DBUS_IFACE_INTERFACE,
-					  "Scanning");
-	if (_signal == NULL) {
-		perror("wpa_supplicant_dbus_notify_scanning[dbus]: couldn't "
-		       "create dbus signal; likely out of memory");
-		wpa_printf(MSG_ERROR, "%s[dbus]: dbus control interface: not "
-		           "enough memory to send scan results signal.",
-		           __FUNCTION__);
-		return;
-	}
-
-	if (dbus_message_append_args(_signal,
-	                             DBUS_TYPE_BOOLEAN, &scanning,
-	                             DBUS_TYPE_INVALID)) {
-		dbus_connection_send(iface->con, _signal, NULL);
-	} else {
-		perror("wpa_supplicant_dbus_notify_scanning[dbus]: not enough "
-		       "memory to construct signal.");
-		wpa_printf(MSG_ERROR, "%s[dbus]: not enough memory to "
-			   "construct signal.", __FUNCTION__);
-	}
-	dbus_message_unref(_signal);
-}
-
-
 #ifdef CONFIG_WPS
 void wpa_supplicant_dbus_notify_wps_cred(struct wpa_supplicant *wpa_s,
 					 const struct wps_credential *cred)
@@ -852,11 +795,6 @@
 out:
 	dbus_message_unref(_signal);
 }
-#else /* CONFIG_WPS */
-void wpa_supplicant_dbus_notify_wps_cred(struct wpa_supplicant *wpa_s,
-					 const struct wps_credential *cred)
-{
-}
 #endif /* CONFIG_WPS */
 
 
diff -Nur hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus.h hostap06/wpa_supplicant/ctrl_iface_dbus.h
--- hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/ctrl_iface_dbus.h	2009-03-23 14:17:09.000000000 +0200
@@ -83,7 +83,6 @@
 wpa_supplicant_dbus_ctrl_iface_init(struct wpa_global *global);
 void wpa_supplicant_dbus_ctrl_iface_deinit(struct ctrl_iface_dbus_priv *iface);
 void wpa_supplicant_dbus_notify_scan_results(struct wpa_supplicant *wpa_s);
-void wpa_supplicant_dbus_notify_scanning(struct wpa_supplicant *wpa_s);
 void wpa_supplicant_dbus_notify_state_change(struct wpa_supplicant *wpa_s,
 					     wpa_states new_state,
 					     wpa_states old_state);
@@ -128,11 +127,6 @@
 }
 
 static inline void
-wpa_supplicant_dbus_notify_scanning(struct wpa_supplicant *wpa_s)
-{
-}
-
-static inline void
 wpa_supplicant_dbus_notify_state_change(struct wpa_supplicant *wpa_s,
 					wpa_states new_state,
 					wpa_states old_state)
diff -Nur hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus_handlers.c hostap06/wpa_supplicant/ctrl_iface_dbus_handlers.c
--- hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus_handlers.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/ctrl_iface_dbus_handlers.c	2009-03-23 14:17:09.000000000 +0200
@@ -24,11 +24,7 @@
 #include "ieee802_11_defs.h"
 #include "wpas_glue.h"
 #include "eapol_supp/eapol_supp_sm.h"
-#include "wpa.h"
 
-extern int wpa_debug_level;
-extern int wpa_debug_show_keys;
-extern int wpa_debug_timestamp;
 
 /**
  * wpas_dbus_new_invalid_opts_error - Return a new invalid options error message
@@ -281,51 +277,6 @@
 	return reply;
 }
 
-/**
- * wpas_dbus_global_set_debugparams- Set the debug params
- * @message: Pointer to incoming dbus message
- * @global: %wpa_supplicant global data structure
- * Returns: a dbus message containing a UINT32 indicating success (1) or
- *          failure (0), or returns a dbus error message with more information
- *
- * Handler function for "setDebugParams" method call. Handles requests
- * by dbus clients for the object path of an specific network interface.
- */
-DBusMessage * wpas_dbus_global_set_debugparams(DBusMessage *message,
-					       struct wpa_global *global)
-{
-	DBusMessage *reply = NULL;
-	int debug_level;
-	dbus_bool_t debug_timestamp;
-	dbus_bool_t debug_show_keys;
-
-	if (!dbus_message_get_args(message, NULL,
-	                           DBUS_TYPE_INT32, &debug_level,
-	                           DBUS_TYPE_BOOLEAN, &debug_timestamp,
-	                           DBUS_TYPE_BOOLEAN, &debug_show_keys,
-	                           DBUS_TYPE_INVALID)) {
-		reply = wpas_dbus_new_invalid_opts_error(message, NULL);
-		goto out;
-	}
-
-	/* check for allowed debuglevels */
-	if (debug_level != MSG_MSGDUMP &&
-	    debug_level != MSG_DEBUG &&
-	    debug_level != MSG_INFO &&
-	    debug_level != MSG_WARNING &&
-	    debug_level != MSG_ERROR) {
-		reply = wpas_dbus_new_invalid_opts_error(message, NULL);
-		goto out;
-	}
-
-	wpa_debug_level = debug_level;
-	wpa_debug_timestamp = debug_timestamp ? 1 : 0;
-	wpa_debug_show_keys = debug_show_keys ? 1 : 0;
-	reply = wpas_dbus_new_success_reply(message);
-
-out:
-	return reply;
-}
 
 /**
  * wpas_dbus_iface_scan - Request a wireless scan on an interface
@@ -1295,11 +1246,8 @@
 	wpa_s->conf->pkcs11_module_path = pkcs11_module_path;
 #endif /* EAP_TLS_OPENSSL */
 
-	wpa_sm_set_eapol(wpa_s->wpa, NULL);
 	eapol_sm_deinit(wpa_s->eapol);
-	wpa_s->eapol = NULL;
 	wpa_supplicant_init_eapol(wpa_s);
-	wpa_sm_set_eapol(wpa_s->wpa, wpa_s->eapol);
 
 	return wpas_dbus_new_success_reply(message);
 
@@ -1337,35 +1285,6 @@
 
 
 /**
- * wpas_dbus_iface_get_scanning - Get interface scanning state
- * @message: Pointer to incoming dbus message
- * @wpa_s: wpa_supplicant structure for a network interface
- * Returns: A dbus message containing whether the interface is scanning
- *
- * Handler function for "scanning" method call.
- */
-DBusMessage * wpas_dbus_iface_get_scanning(DBusMessage *message,
-					   struct wpa_supplicant *wpa_s)
-{
-	DBusMessage *reply = NULL;
-	dbus_bool_t scanning = wpa_s->scanning ? TRUE : FALSE;
-
-	reply = dbus_message_new_method_return(message);
-	if (reply != NULL) {
-		dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &scanning,
-					 DBUS_TYPE_INVALID);
-	} else {
-		perror("wpas_dbus_iface_get_scanning[dbus]: out of "
-		       "memory.");
-		wpa_printf(MSG_ERROR, "dbus control interface: not enough "
-			   "memory to return scanning state.");
-	}
-
-	return reply;
-}
-
-
-/**
  * wpas_dbus_iface_set_blobs - Store named binary blobs (ie, for certificates)
  * @message: Pointer to incoming dbus message
  * @wpa_s: %wpa_supplicant data structure
diff -Nur hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus_handlers.h hostap06/wpa_supplicant/ctrl_iface_dbus_handlers.h
--- hostap-06-d23bf71/wpa_supplicant/ctrl_iface_dbus_handlers.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/ctrl_iface_dbus_handlers.h	2009-03-23 14:17:09.000000000 +0200
@@ -28,9 +28,6 @@
 DBusMessage * wpas_dbus_global_get_interface(DBusMessage *message,
 					     struct wpa_global *global);
 
-DBusMessage * wpas_dbus_global_set_debugparams(DBusMessage *message,
-					       struct wpa_global *global);
-
 DBusMessage * wpas_dbus_iface_scan(DBusMessage *message,
 				   struct wpa_supplicant *wpa_s);
 
@@ -77,9 +74,6 @@
 DBusMessage * wpas_dbus_iface_get_state(DBusMessage *message,
 					struct wpa_supplicant *wpa_s);
 
-DBusMessage * wpas_dbus_iface_get_scanning(DBusMessage *message,
-					   struct wpa_supplicant *wpa_s);
-
 DBusMessage * wpas_dbus_iface_set_blobs(DBusMessage *message,
 				        struct wpa_supplicant *wpa_s);
 
diff -Nur hostap-06-d23bf71/wpa_supplicant/ctrl_iface_unix.c hostap06/wpa_supplicant/ctrl_iface_unix.c
--- hostap-06-d23bf71/wpa_supplicant/ctrl_iface_unix.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/ctrl_iface_unix.c	2009-03-23 14:17:09.000000000 +0200
@@ -332,14 +332,6 @@
 		goto fail;
 	}
 
-	/* Make sure the group can enter and read the directory */
-	if (gid_set &&
-	    chmod(dir, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP) < 0) {
-		wpa_printf(MSG_ERROR, "CTRL: chmod[ctrl_interface]: %s",
-			   strerror(errno));
-		goto fail;
-	}
-
 	if (os_strlen(dir) + 1 + os_strlen(wpa_s->ifname) >=
 	    sizeof(addr.sun_path)) {
 		wpa_printf(MSG_ERROR, "ctrl_iface path limit exceeded");
diff -Nur hostap-06-d23bf71/wpa_supplicant/defconfig hostap06/wpa_supplicant/defconfig
--- hostap-06-d23bf71/wpa_supplicant/defconfig	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/defconfig	2009-03-23 14:17:09.000000000 +0200
@@ -50,7 +50,6 @@
 #CFLAGS += -I../../include/wireless
 
 # Driver interface for madwifi driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
 #CONFIG_DRIVER_MADWIFI=y
 # Set include directory to the madwifi source tree
 #CFLAGS += -I../../madwifi
@@ -61,7 +60,6 @@
 #CONFIG_DRIVER_PRISM54=y
 
 # Driver interface for ndiswrapper
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
 #CONFIG_DRIVER_NDISWRAPPER=y
 
 # Driver interface for Atmel driver
@@ -76,7 +74,6 @@
 #CFLAGS += -I/opt/WRT54GS/release/src/include
 
 # Driver interface for Intel ipw2100/2200 driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
 #CONFIG_DRIVER_IPW=y
 
 # Driver interface for Ralink driver
diff -Nur hostap-06-d23bf71/wpa_supplicant/doc/porting.doxygen hostap06/wpa_supplicant/doc/porting.doxygen
--- hostap-06-d23bf71/wpa_supplicant/doc/porting.doxygen	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/doc/porting.doxygen	2009-03-23 14:17:09.000000000 +0200
@@ -5,9 +5,9 @@
 hardware (board, CPU) and software (OS, drivers) targets. It is
 already used with number of operating systems and numerous wireless
 card models and drivers. The main %wpa_supplicant repository includes
-support for Linux, FreeBSD, and Windows. In addition, the code has been
-ported to number of other operating systems like VxWorks, PalmOS,
-Windows CE, and Windows Mobile. On the hardware
+support for Linux, FreeBSD, and Windows. In addition, at least VxWorks,
+PalmOS, Windows CE, and Windows Mobile are supported in separate
+repositories. On the hardware
 side, %wpa_supplicant is used on various systems: desktops, laptops,
 PDAs, and embedded devices with CPUs including x86, PowerPC,
 arm/xscale, and MIPS. Both big and little endian configurations are
diff -Nur hostap-06-d23bf71/wpa_supplicant/events.c hostap06/wpa_supplicant/events.c
--- hostap-06-d23bf71/wpa_supplicant/events.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/events.c	2009-08-12 15:34:30.000000000 +0300
@@ -415,11 +415,6 @@
 			continue;
 		}
 
-		if (ssid_len == 0) {
-			wpa_printf(MSG_DEBUG, "   skip - SSID not known");
-			continue;
-		}
-
 		if (wpa_ie_len == 0 && rsn_ie_len == 0) {
 			wpa_printf(MSG_DEBUG, "   skip - no WPA/RSN IE");
 			continue;
@@ -510,11 +505,6 @@
 			continue;
 		}
 
-		if (ssid_len == 0) {
-			wpa_printf(MSG_DEBUG, "   skip - SSID not known");
-			continue;
-		}
-
 		for (ssid = group; ssid; ssid = ssid->pnext) {
 			int check_ssid = ssid->ssid_len != 0;
 
@@ -551,7 +541,7 @@
 					   "BSSID mismatch");
 				continue;
 			}
-
+			
 			if (!(ssid->key_mgmt & WPA_KEY_MGMT_NONE) &&
 			    !(ssid->key_mgmt & WPA_KEY_MGMT_WPS) &&
 			    !(ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA))
@@ -561,7 +551,7 @@
 				continue;
 			}
 
-			if ((ssid->key_mgmt &
+			if ((ssid->key_mgmt & 
 			     (WPA_KEY_MGMT_IEEE8021X | WPA_KEY_MGMT_PSK |
 			      WPA_KEY_MGMT_FT_IEEE8021X | WPA_KEY_MGMT_FT_PSK |
 			      WPA_KEY_MGMT_IEEE8021X_SHA256 |
@@ -583,7 +573,11 @@
 					   "IBSS (adhoc) network");
 				continue;
 			}
-
+#ifdef CONFIG_WPS
+			if ((ssid->key_mgmt & WPA_KEY_MGMT_WPS) &&
+			    wpas_wps_ssid_bss_match(wpa_s, ssid, bss) <= 0)
+				continue;
+#endif
 			wpa_printf(MSG_DEBUG, "   selected non-WPA AP "
 				   MACSTR " ssid='%s'",
 				   MAC2STR(bss->bssid),
@@ -623,8 +617,6 @@
 	struct wpa_scan_res *selected = NULL;
 	struct wpa_ssid *ssid = NULL;
 
-	wpa_supplicant_notify_scanning(wpa_s, 0);
-
 	if (wpa_supplicant_get_scan_results(wpa_s) < 0) {
 		if (wpa_s->conf->ap_scan == 2)
 			return;
@@ -643,20 +635,15 @@
 		wpa_msg(wpa_s, MSG_DEBUG, "Cached scan results are "
 			"empty - not posting");
 	} else {
-		wpa_printf(MSG_DEBUG, "New scan results available");
-		wpa_msg_ctrl(wpa_s, MSG_INFO, WPA_EVENT_SCAN_RESULTS);
+		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_SCAN_RESULTS);
 		wpa_supplicant_dbus_notify_scan_results(wpa_s);
 		wpas_wps_notify_scan_results(wpa_s);
 	}
 
-	if ((wpa_s->conf->ap_scan == 2 && !wpas_wps_searching(wpa_s)))
+	if ((wpa_s->conf->ap_scan == 2 && !wpas_wps_searching(wpa_s)) ||
+	    wpa_s->disconnected)
 		return;
 
-	if (wpa_s->disconnected) {
-		wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
-		return;
-	}
-
 	while (selected == NULL) {
 		for (prio = 0; prio < wpa_s->conf->num_prio; prio++) {
 			selected = wpa_supplicant_select_bss(
@@ -718,14 +705,6 @@
 		 */
 		wpa_s->scan_res_tried++;
 		timeout = 0;
-	} else if (!wpa_supplicant_enabled_networks(wpa_s->conf)) {
-		/*
-		 * No networks are enabled; short-circuit request so
-		 * we don't wait timeout seconds before transitioning
-		 * to INACTIVE state.
-		 */
-		wpa_supplicant_set_state(wpa_s, WPA_INACTIVE);
-		return;
 	}
 	wpa_supplicant_req_scan(wpa_s, timeout, 0);
 }
@@ -894,25 +873,6 @@
 		eapol_sm_notify_portValid(wpa_s->eapol, TRUE);
 		eapol_sm_notify_eap_success(wpa_s->eapol, TRUE);
 	}
-
-	if (wpa_s->pending_eapol_rx) {
-		struct os_time now, age;
-		os_get_time(&now);
-		os_time_sub(&now, &wpa_s->pending_eapol_rx_time, &age);
-		if (age.sec == 0 && age.usec < 100000 &&
-		    os_memcmp(wpa_s->pending_eapol_rx_src, bssid, ETH_ALEN) ==
-		    0) {
-			wpa_printf(MSG_DEBUG, "Process pending EAPOL frame "
-				   "that was received just before association "
-				   "notification");
-			wpa_supplicant_rx_eapol(
-				wpa_s, wpa_s->pending_eapol_rx_src,
-				wpabuf_head(wpa_s->pending_eapol_rx),
-				wpabuf_len(wpa_s->pending_eapol_rx));
-		}
-		wpabuf_free(wpa_s->pending_eapol_rx);
-		wpa_s->pending_eapol_rx = NULL;
-	}
 }
 
 
diff -Nur hostap-06-d23bf71/wpa_supplicant/Makefile hostap06/wpa_supplicant/Makefile
--- hostap-06-d23bf71/wpa_supplicant/Makefile	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/Makefile	2009-03-23 14:17:09.000000000 +0200
@@ -35,6 +35,7 @@
 	fi
 	echo CONFIG_DRIVER_HOSTAP=y >> .config
 	echo CONFIG_DRIVER_WEXT=y >> .config
+	echo CONFIG_WIRELESS_EXTENSION=y >> .config
 
 install: all
 	mkdir -p $(DESTDIR)$(BINDIR)
@@ -527,7 +528,6 @@
 NEED_SHA256=y
 NEED_BASE64=y
 NEED_CRYPTO=y
-NEED_80211_COMMON=y
 
 ifdef CONFIG_WPS_UPNP
 CFLAGS += -DCONFIG_WPS_UPNP
@@ -555,7 +555,6 @@
 endif
 CONFIG_IEEE8021X_EAPOL=y
 NEED_DH_GROUPS=y
-NEED_DH_GROUPS_ALL=y
 endif
 
 ifdef CONFIG_EAP_VENDOR_TEST
@@ -859,6 +858,7 @@
 endif
 
 ifdef CONFIG_WIRELESS_EXTENSION
+CFLAGS += -DCONFIG_WIRELESS_EXTENSION
 OBJS_d += ../src/drivers/driver_wext.o
 endif
 
@@ -977,9 +977,6 @@
 
 ifdef NEED_DH_GROUPS
 OBJS += ../src/crypto/dh_groups.o
-ifdef NEED_DH_GROUPS_ALL
-CFLAGS += -DALL_DH_GROUPS
-endif
 endif
 
 ifndef NEED_FIPS186_2_PRF
@@ -1007,10 +1004,6 @@
 CONFIG_MAIN=main
 endif
 
-ifdef CONFIG_DEBUG_SYSLOG
-CFLAGS += -DCONFIG_DEBUG_SYSLOG
-endif
-
 ifdef CONFIG_DEBUG_FILE
 CFLAGS += -DCONFIG_DEBUG_FILE
 endif
@@ -1152,16 +1145,6 @@
 	$(CC) -o $@ $(CFLAGS) -shared -rdynamic -fPIC $< \
 		-D$(*F:eap_%=eap_peer_%)_register=eap_peer_method_dynamic_init
 
-Q=@
-E=echo
-ifeq ($(V), 1)
-Q=
-E=true
-endif
-
-%.o: %.c
-	$(Q)$(CC) -c -o $@ $(CFLAGS) $<
-	@$(E) "  CC " $<
 
 wpa_supplicant.exe: wpa_supplicant
 	mv -f $< $@
@@ -1241,8 +1224,7 @@
 
 clean:
 	$(MAKE) -C ../src clean
-	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL) eapol_test preauth_test
-	rm -f wpa_priv
+	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL)
 
 %.eps: %.fig
 	fig2dev -L eps $*.fig $*.eps
diff -Nur hostap-06-d23bf71/wpa_supplicant/Makefile.MTLK hostap06/wpa_supplicant/Makefile.MTLK
--- hostap-06-d23bf71/wpa_supplicant/Makefile.MTLK	1970-01-01 02:00:00.000000000 +0200
+++ hostap06/wpa_supplicant/Makefile.MTLK	2009-06-09 11:30:39.000000000 +0300
@@ -0,0 +1,39 @@
+######### Metalink (c) #####################
+######### Standard header begin ############
+
+## TOPDIR may be set. It points to the top directory where all the E_* variables are in Makefiles.MTLK.vars
+ifdef E_TOPDIR
+include $(E_TOPDIR)/scripts/Makefile.MTLK.vars
+else
+$(error "E_TOPDIR doesn't defined")
+endif
+
+######### Standard header end ##############
+
+CFLAGS=-Os -I$(E_TOPDIR)/l/openssl/include 
+CC=$(E_CC)
+LIBS=-L$(E_TOPDIR)/l/openssl
+LIBS_p=-L$(E_TOPDIR)/l/openssl
+STRIP=$(E_STRIP)
+export CC CFLAGS LIBS LIBS_p STRIP
+
+CONF:
+	echo No configuration here
+COMP:
+	make all
+
+CLEAN:
+	make clean
+
+INSTALL: FORCE
+	install -D -m 755 wpa_supplicant $(E_DEST)/root/mtlk/etc/wpa_supplicant
+	install -D -m 755 wpa_passphrase $(E_DEST)/root/mtlk/etc/wpa_passphrase
+	install -D -m 755 wpa_cli $(E_DEST)/root/mtlk/etc/wpa_cli
+STRIP:
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/wpa_supplicant
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/wpa_passphrase
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/wpa_cli
+
+FORCE:
+
+	
diff -Nur hostap-06-d23bf71/wpa_supplicant/mlme.c hostap06/wpa_supplicant/mlme.c
--- hostap-06-d23bf71/wpa_supplicant/mlme.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/mlme.c	2009-03-23 14:17:09.000000000 +0200
@@ -459,9 +459,9 @@
 		*pos++ = 0x00; /* Microsoft OUI 00:50:F2 */
 		*pos++ = 0x50;
 		*pos++ = 0xf2;
-		*pos++ = 2; /* WMM */
-		*pos++ = 0; /* WMM info */
-		*pos++ = 1; /* WMM ver */
+		*pos++ = 2; /* WME */
+		*pos++ = 0; /* WME info */
+		*pos++ = 1; /* WME ver */
 		*pos++ = 0;
 	}
 
@@ -1175,9 +1175,9 @@
 #if 0 /* FIX? */
 	sta->assoc_ap = 1;
 
-	if (elems.wmm && wpa_s->mlme.wmm_enabled) {
-		sta->flags |= WLAN_STA_WMM;
-		ieee80211_sta_wmm_params(wpa_s, elems.wmm, elems.wmm_len);
+	if (elems.wme && wpa_s->mlme.wmm_enabled) {
+		sta->flags |= WLAN_STA_WME;
+		ieee80211_sta_wmm_params(wpa_s, elems.wme, elems.wme_len);
 	}
 #endif
 
@@ -1488,18 +1488,18 @@
 		bss->rsn_ie_len = 0;
 	}
 
-	if (elems.wmm &&
-	    (bss->wmm_ie == NULL || bss->wmm_ie_len != elems.wmm_len ||
-	     os_memcmp(bss->wmm_ie, elems.wmm, elems.wmm_len))) {
+	if (elems.wme &&
+	    (bss->wmm_ie == NULL || bss->wmm_ie_len != elems.wme_len ||
+	     os_memcmp(bss->wmm_ie, elems.wme, elems.wme_len))) {
 		os_free(bss->wmm_ie);
-		bss->wmm_ie = os_malloc(elems.wmm_len + 2);
+		bss->wmm_ie = os_malloc(elems.wme_len + 2);
 		if (bss->wmm_ie) {
-			os_memcpy(bss->wmm_ie, elems.wmm - 2,
-				  elems.wmm_len + 2);
-			bss->wmm_ie_len = elems.wmm_len + 2;
+			os_memcpy(bss->wmm_ie, elems.wme - 2,
+				  elems.wme_len + 2);
+			bss->wmm_ie_len = elems.wme_len + 2;
 		} else
 			bss->wmm_ie_len = 0;
-	} else if (!elems.wmm && bss->wmm_ie) {
+	} else if (!elems.wme && bss->wmm_ie) {
 		os_free(bss->wmm_ie);
 		bss->wmm_ie = NULL;
 		bss->wmm_ie_len = 0;
@@ -1595,9 +1595,9 @@
 		wpa_s->mlme.cts_protect_erp_frames = use_protection;
 	}
 
-	if (elems.wmm && wpa_s->mlme.wmm_enabled) {
-		ieee80211_sta_wmm_params(wpa_s, elems.wmm,
-					 elems.wmm_len);
+	if (elems.wme && wpa_s->mlme.wmm_enabled) {
+		ieee80211_sta_wmm_params(wpa_s, elems.wme,
+					 elems.wme_len);
 	}
 }
 
@@ -1709,6 +1709,7 @@
 		wpa_printf(MSG_DEBUG, "MLME: Foreign STA Address " MACSTR
 			   " in FT Action Response", MAC2STR(sta_addr));
 		return;
+			   
 	}
 
 	if (status) {
diff -Nur hostap-06-d23bf71/wpa_supplicant/README hostap06/wpa_supplicant/README
--- hostap-06-d23bf71/wpa_supplicant/README	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/README	2009-03-23 14:17:09.000000000 +0200
@@ -397,8 +397,10 @@
 
 Following options can be added to .config to select which driver
 interfaces are included. Hermes driver interface needs to be downloaded
-from Agere (see above).
+from Agere (see above). CONFIG_WIRELESS_EXTENSION will be used
+automatically if any of the selected drivers need it.
 
+CONFIG_WIRELESS_EXTENSION=y
 CONFIG_DRIVER_HOSTAP=y
 CONFIG_DRIVER_HERMES=y
 CONFIG_DRIVER_MADWIFI=y
@@ -424,6 +426,7 @@
 CONFIG_DRIVER_IPW=y
 CONFIG_DRIVER_BSD=y
 CONFIG_DRIVER_NDIS=y
+CONFIG_WIRELESS_EXTENSION=y
 CONFIG_IEEE8021X_EAPOL=y
 CONFIG_EAP_MD5=y
 CONFIG_EAP_MSCHAPV2=y
@@ -517,11 +520,11 @@
   hostap = Host AP driver (Intersil Prism2/2.5/3) [default]
 	(this can also be used with Linuxant DriverLoader)
   hermes = Agere Systems Inc. driver (Hermes-I/Hermes-II)
-  madwifi = MADWIFI 802.11 support (Atheros, etc.) (deprecated; use wext)
+  madwifi = MADWIFI 802.11 support (Atheros, etc.)
   atmel = ATMEL AT76C5XXx (USB, PCMCIA)
   wext = Linux wireless extensions (generic)
   ralink = Ralink Client driver
-  ndiswrapper = Linux ndiswrapper (deprecated; use wext)
+  ndiswrapper = Linux ndiswrapper
   broadcom = Broadcom wl.o driver
   ipw = Intel ipw2100/2200 driver (old; use wext with Linux 2.6.13 or newer)
   wired = wpa_supplicant wired Ethernet driver
diff -Nur hostap-06-d23bf71/wpa_supplicant/README-WPS hostap06/wpa_supplicant/README-WPS
--- hostap-06-d23bf71/wpa_supplicant/README-WPS	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/README-WPS	2009-03-23 14:17:09.000000000 +0200
@@ -131,18 +131,13 @@
 PIN method described above.
 
 
-If the client wants to operate in the Registrar role to configure an
+If the client wants to operation in the Registrar role to configure an
 AP, wpa_supplicant is notified over the control interface, e.g., with
 wpa_cli:
 
 wpa_cli wps_reg <AP BSSID> <AP PIN>
 (example: wpa_cli wps_reg 02:34:56:78:9a:bc 12345670)
 
-This is currently only used to fetch the current AP settings instead
-of actually changing them. The main difference with the wps_pin
-command is that wps_reg uses the AP PIN (e.g., from a label on the AP)
-instead of a PIN generated at the client.
-
 
 Scanning
 --------
diff -Nur hostap-06-d23bf71/wpa_supplicant/scan.c hostap06/wpa_supplicant/scan.c
--- hostap-06-d23bf71/wpa_supplicant/scan.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/scan.c	2009-03-23 14:17:09.000000000 +0200
@@ -20,7 +20,6 @@
 #include "wpa_supplicant_i.h"
 #include "mlme.h"
 #include "wps_supplicant.h"
-#include "ctrl_iface_dbus.h"
 
 
 static void wpa_supplicant_gen_assoc_event(struct wpa_supplicant *wpa_s)
@@ -66,24 +65,11 @@
 }
 #endif /* CONFIG_WPS */
 
-
-int wpa_supplicant_enabled_networks(struct wpa_config *conf)
-{
-	struct wpa_ssid *ssid = conf->ssid;
-	while (ssid) {
-		if (!ssid->disabled)
-			return 1;
-		ssid = ssid->next;
-	}
-	return 0;
-}
-
-
 static void wpa_supplicant_scan(void *eloop_ctx, void *timeout_ctx)
 {
 	struct wpa_supplicant *wpa_s = eloop_ctx;
 	struct wpa_ssid *ssid;
-	int scan_req = 0, ret;
+	int enabled, scan_req = 0, ret;
 	struct wpabuf *wps_ie = NULL;
 	const u8 *extra_ie = NULL;
 	size_t extra_ie_len = 0;
@@ -92,13 +78,19 @@
 	enum wps_request_type req_type = WPS_REQ_ENROLLEE_INFO;
 #endif /* CONFIG_WPS */
 
-	if (wpa_s->disconnected && !wpa_s->scan_req) {
-		wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
+	if (wpa_s->disconnected && !wpa_s->scan_req)
 		return;
-	}
 
-	if (!wpa_supplicant_enabled_networks(wpa_s->conf) &&
-	    !wpa_s->scan_req) {
+	enabled = 0;
+	ssid = wpa_s->conf->ssid;
+	while (ssid) {
+		if (!ssid->disabled) {
+			enabled++;
+			break;
+		}
+		ssid = ssid->next;
+	}
+	if (!enabled && !wpa_s->scan_req) {
 		wpa_printf(MSG_DEBUG, "No enabled networks - do not scan");
 		wpa_supplicant_set_state(wpa_s, WPA_INACTIVE);
 		return;
@@ -197,8 +189,6 @@
 	}
 #endif /* CONFIG_WPS */
 
-	wpa_supplicant_notify_scanning(wpa_s, 1);
-
 	if (wpa_s->use_client_mlme) {
 		ieee80211_sta_set_probe_req_ie(wpa_s, extra_ie, extra_ie_len);
 		ret = ieee80211_sta_req_scan(wpa_s, ssid ? ssid->ssid : NULL,
@@ -213,7 +203,6 @@
 
 	if (ret) {
 		wpa_printf(MSG_WARNING, "Failed to initiate AP scan.");
-		wpa_supplicant_notify_scanning(wpa_s, 0);
 		wpa_supplicant_req_scan(wpa_s, 10, 0);
 	} else
 		wpa_s->scan_runs++;
@@ -272,14 +261,3 @@
 	wpa_msg(wpa_s, MSG_DEBUG, "Cancelling scan request");
 	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
 }
-
-
-void wpa_supplicant_notify_scanning(struct wpa_supplicant *wpa_s,
-				    int scanning)
-{
-	if (wpa_s->scanning != scanning) {
-		wpa_s->scanning = scanning;
-		wpa_supplicant_dbus_notify_scanning(wpa_s);
-	}
-}
-
diff -Nur hostap-06-d23bf71/wpa_supplicant/wpa_gui-qt4/main.cpp hostap06/wpa_supplicant/wpa_gui-qt4/main.cpp
--- hostap-06-d23bf71/wpa_supplicant/wpa_gui-qt4/main.cpp	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wpa_gui-qt4/main.cpp	2009-03-23 14:17:09.000000000 +0200
@@ -24,9 +24,7 @@
 public:
 	WpaGuiApp(int &argc, char **argv);
 
-#ifndef QT_NO_SESSIONMANAGER
 	virtual void saveState(QSessionManager &manager);
-#endif
 
 	WpaGui *w;
 };
@@ -35,13 +33,11 @@
 {
 }
 
-#ifndef QT_NO_SESSIONMANAGER
 void WpaGuiApp::saveState(QSessionManager &manager)
 {
 	QApplication::saveState(manager);
 	w->saveState();
 }
-#endif
 
 
 int main(int argc, char *argv[])
diff -Nur hostap-06-d23bf71/wpa_supplicant/wpa_gui-qt4/wpagui.cpp hostap06/wpa_supplicant/wpa_gui-qt4/wpagui.cpp
--- hostap-06-d23bf71/wpa_supplicant/wpa_gui-qt4/wpagui.cpp	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wpa_gui-qt4/wpagui.cpp	2009-03-23 14:17:09.000000000 +0200
@@ -145,7 +145,6 @@
 
 	parse_argv();
 
-#ifndef QT_NO_SESSIONMANAGER
 	if (app->isSessionRestored()) {
 		QSettings settings("wpa_supplicant", "wpa_gui");
 		settings.beginGroup("state");
@@ -154,7 +153,6 @@
 			startInTray = settings.value("in_tray").toBool();
 		settings.endGroup();
 	}
-#endif
 
 	if (QSystemTrayIcon::isSystemTrayAvailable())
 		createTrayIcon(startInTray);
@@ -859,9 +857,7 @@
 				"Wi-Fi Protected Setup (WPS) AP\n"
 				"in active PBC mode found.");
 		wpsStatusText->setText("WPS AP in active PBC mode found");
-		if (textStatus->text() == "INACTIVE" ||
-		    textStatus->text() == "DISCONNECTED")
-			wpaguiTab->setCurrentWidget(wpsTab);
+		wpaguiTab->setCurrentWidget(wpsTab);
 		wpsInstructions->setText("Press the PBC button on the screen "
 					 "to start registration");
 	} else if (str_match(pos, WPS_EVENT_AP_AVAILABLE_PIN)) {
@@ -870,14 +866,13 @@
 				" in active PIN mode found.");
 		wpsStatusText->setText("WPS AP with recently selected "
 				       "registrar");
-		if (textStatus->text() == "INACTIVE" ||
-		    textStatus->text() == "DISCONNECTED")
-			wpaguiTab->setCurrentWidget(wpsTab);
+		wpaguiTab->setCurrentWidget(wpsTab);
 	} else if (str_match(pos, WPS_EVENT_AP_AVAILABLE)) {
 		showTrayMessage(QSystemTrayIcon::Information, 3,
 				"Wi-Fi Protected Setup (WPS)\n"
 				"AP detected.");
 		wpsStatusText->setText("WPS AP detected");
+		wpaguiTab->setCurrentWidget(wpsTab);
 	} else if (str_match(pos, WPS_EVENT_OVERLAP)) {
 		showTrayMessage(QSystemTrayIcon::Information, 3,
 				"Wi-Fi Protected Setup (WPS)\n"
@@ -1694,7 +1689,6 @@
 }
 
 
-#ifndef QT_NO_SESSIONMANAGER
 void WpaGui::saveState()
 {
 	QSettings settings("wpa_supplicant", "wpa_gui");
@@ -1703,4 +1697,3 @@
 	settings.setValue("in_tray", inTray);
 	settings.endGroup();
 }
-#endif
diff -Nur hostap-06-d23bf71/wpa_supplicant/wpa_gui-qt4/wpagui.h hostap06/wpa_supplicant/wpa_gui-qt4/wpagui.h
--- hostap-06-d23bf71/wpa_supplicant/wpa_gui-qt4/wpagui.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wpa_gui-qt4/wpagui.h	2009-03-23 14:17:09.000000000 +0200
@@ -40,9 +40,7 @@
 	virtual void disableNetwork(const QString &sel);
 	virtual int getNetworkDisabled(const QString &sel);
 	void setBssFromScan(const QString &bssid);
-#ifndef QT_NO_SESSIONMANAGER
 	void saveState();
-#endif
 
 public slots:
 	virtual void parse_argv();
diff -Nur hostap-06-d23bf71/wpa_supplicant/wpa_priv.c hostap06/wpa_supplicant/wpa_priv.c
--- hostap-06-d23bf71/wpa_supplicant/wpa_priv.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wpa_priv.c	2009-03-23 14:17:09.000000000 +0200
@@ -172,12 +172,12 @@
 	       sizeof(*from));
 
 	os_free(buf);
-	wpa_scan_results_free(res);
+	os_free(res);
 	return;
 
 fail:
 	os_free(buf);
-	wpa_scan_results_free(res);
+	os_free(res);
 	sendto(iface->fd, "", 0, 0, (struct sockaddr *) from, sizeof(*from));
 }
 
diff -Nur hostap-06-d23bf71/wpa_supplicant/wpa_supplicant.c hostap06/wpa_supplicant/wpa_supplicant.c
--- hostap-06-d23bf71/wpa_supplicant/wpa_supplicant.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wpa_supplicant.c	2009-05-22 14:31:10.000000000 +0300
@@ -385,9 +385,6 @@
 	ieee80211_sta_deinit(wpa_s);
 
 	wpas_wps_deinit(wpa_s);
-
-	wpabuf_free(wpa_s->pending_eapol_rx);
-	wpa_s->pending_eapol_rx = NULL;
 }
 
 
@@ -421,10 +418,6 @@
 	wpa_drv_set_key(wpa_s, WPA_ALG_NONE, bcast, 1, 0, NULL, 0, NULL, 0);
 	wpa_drv_set_key(wpa_s, WPA_ALG_NONE, bcast, 2, 0, NULL, 0, NULL, 0);
 	wpa_drv_set_key(wpa_s, WPA_ALG_NONE, bcast, 3, 0, NULL, 0, NULL, 0);
-#ifdef CONFIG_IEEE80211W
-	wpa_drv_set_key(wpa_s, WPA_ALG_NONE, bcast, 4, 0, NULL, 0, NULL, 0);
-	wpa_drv_set_key(wpa_s, WPA_ALG_NONE, bcast, 5, 0, NULL, 0, NULL, 0);
-#endif /* CONFIG_IEEE80211W */
 	if (addr) {
 		wpa_drv_set_key(wpa_s, WPA_ALG_NONE, addr, 0, 0, NULL, 0, NULL,
 				0);
@@ -482,9 +475,6 @@
 		   wpa_supplicant_state_txt(wpa_s->wpa_state),
 		   wpa_supplicant_state_txt(state));
 
-	if (state != WPA_SCANNING)
-		wpa_supplicant_notify_scanning(wpa_s, 0);
-
 	wpa_supplicant_dbus_notify_state_change(wpa_s, state,
 						wpa_s->wpa_state);
 
@@ -1479,14 +1469,12 @@
 	if (name == NULL) {
 		/* default to first driver in the list */
 		wpa_s->driver = wpa_supplicant_drivers[0];
-		wpa_s->global_drv_priv = wpa_s->global->drv_priv[0];
 		return 0;
 	}
 
 	for (i = 0; wpa_supplicant_drivers[i]; i++) {
 		if (os_strcmp(name, wpa_supplicant_drivers[i]->name) == 0) {
 			wpa_s->driver = wpa_supplicant_drivers[i];
-			wpa_s->global_drv_priv = wpa_s->global->drv_priv[i];
 			return 0;
 		}
 	}
@@ -1504,27 +1492,6 @@
 	wpa_printf(MSG_DEBUG, "RX EAPOL from " MACSTR, MAC2STR(src_addr));
 	wpa_hexdump(MSG_MSGDUMP, "RX EAPOL", buf, len);
 
-	if (wpa_s->wpa_state < WPA_ASSOCIATED) {
-		/*
-		 * There is possible race condition between receiving the
-		 * association event and the EAPOL frame since they are coming
-		 * through different paths from the driver. In order to avoid
-		 * issues in trying to process the EAPOL frame before receiving
-		 * association information, lets queue it for processing until
-		 * the association event is received.
-		 */
-		wpa_printf(MSG_DEBUG, "Not associated - Delay processing of "
-			   "received EAPOL frame");
-		wpabuf_free(wpa_s->pending_eapol_rx);
-		wpa_s->pending_eapol_rx = wpabuf_alloc_copy(buf, len);
-		if (wpa_s->pending_eapol_rx) {
-			os_get_time(&wpa_s->pending_eapol_rx_time);
-			os_memcpy(wpa_s->pending_eapol_rx_src, src_addr,
-				  ETH_ALEN);
-		}
-		return;
-	}
-
 	if (wpa_s->key_mgmt == WPA_KEY_MGMT_NONE) {
 		wpa_printf(MSG_DEBUG, "Ignored received EAPOL frame since "
 			   "no key management is configured");
@@ -1946,8 +1913,6 @@
 	if (wpa_s == NULL)
 		return NULL;
 
-	wpa_s->global = global;
-
 	if (wpa_supplicant_init_iface(wpa_s, iface) ||
 	    wpa_supplicant_init_iface2(wpa_s)) {
 		wpa_printf(MSG_DEBUG, "Failed to add interface %s",
@@ -1957,13 +1922,15 @@
 		return NULL;
 	}
 
+	wpa_s->global = global;
+
 	/* Register the interface with the dbus control interface */
 	if (wpas_dbus_register_iface(wpa_s)) {
 		wpa_supplicant_deinit_iface(wpa_s);
 		os_free(wpa_s);
 		return NULL;
 	}
-
+		
 	wpa_s->next = global->ifaces;
 	global->ifaces = wpa_s;
 
diff -Nur hostap-06-d23bf71/wpa_supplicant/wpa_supplicant_i.h hostap06/wpa_supplicant/wpa_supplicant_i.h
--- hostap-06-d23bf71/wpa_supplicant/wpa_supplicant_i.h	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wpa_supplicant_i.h	2009-03-23 14:17:09.000000000 +0200
@@ -305,7 +305,6 @@
 	int mgmt_group_cipher;
 
 	void *drv_priv; /* private data used by driver_ops */
-	void *global_drv_priv;
 
 	struct wpa_ssid *prev_scan_ssid; /* previously scanned SSID;
 					  * NULL = not yet initialized (start
@@ -326,7 +325,6 @@
 	struct ctrl_iface_priv *ctrl_iface;
 
 	wpa_states wpa_state;
-	int scanning;
 	int new_connection;
 	int reassociated_connection;
 
@@ -360,10 +358,6 @@
 	struct wps_context *wps;
 	int wps_success; /* WPS success event received */
 	int blacklist_cleared;
-
-	struct wpabuf *pending_eapol_rx;
-	struct os_time pending_eapol_rx_time;
-	u8 pending_eapol_rx_src[ETH_ALEN];
 };
 
 
@@ -410,11 +404,8 @@
 			      struct wpa_ssid *ssid);
 
 /* scan.c */
-int wpa_supplicant_enabled_networks(struct wpa_config *conf);
 void wpa_supplicant_req_scan(struct wpa_supplicant *wpa_s, int sec, int usec);
 void wpa_supplicant_cancel_scan(struct wpa_supplicant *wpa_s);
-void wpa_supplicant_notify_scanning(struct wpa_supplicant *wpa_s,
-				    int scanning);
 
 /* events.c */
 void wpa_supplicant_mark_disassoc(struct wpa_supplicant *wpa_s);
@@ -424,8 +415,7 @@
 				  const char *ifname)
 {
 	if (wpa_s->driver->init2)
-		return wpa_s->driver->init2(wpa_s, ifname,
-					    wpa_s->global_drv_priv);
+		return wpa_s->driver->init2(wpa_s, ifname, wpa_s->global);
 	if (wpa_s->driver->init) {
 		return wpa_s->driver->init(wpa_s, ifname);
 	}
diff -Nur hostap-06-d23bf71/wpa_supplicant/wps_supplicant.c hostap06/wpa_supplicant/wps_supplicant.c
--- hostap-06-d23bf71/wpa_supplicant/wps_supplicant.c	2010-01-12 16:55:02.000000000 +0200
+++ hostap06/wpa_supplicant/wps_supplicant.c	2009-08-12 12:53:29.000000000 +0300
@@ -29,7 +29,6 @@
 #include "wpa.h"
 #include "wps_supplicant.h"
 
-
 #define WPS_PIN_SCAN_IGNORE_SEL_REG 3
 
 static void wpas_wps_timeout(void *eloop_ctx, void *timeout_ctx);
@@ -186,8 +185,7 @@
 {
 	struct wpa_supplicant *wpa_s = ctx;
 	struct wpa_ssid *ssid = wpa_s->current_ssid;
-	u8 key_idx = 0;
-	u16 auth_type;
+	u8 i;
 
 	if ((wpa_s->conf->wps_cred_processing == 1 ||
 	     wpa_s->conf->wps_cred_processing == 2) && cred->cred_attr) {
@@ -214,26 +212,20 @@
 	wpa_printf(MSG_DEBUG, "WPS: Authentication Type 0x%x",
 		   cred->auth_type);
 	wpa_printf(MSG_DEBUG, "WPS: Encryption Type 0x%x", cred->encr_type);
-	wpa_printf(MSG_DEBUG, "WPS: Network Key Index %d", cred->key_idx);
-	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key",
-			cred->key, cred->key_len);
+	wpa_printf(MSG_DEBUG, "WPS: Network Keys %d", cred->keys_num);
+	for (i = 0; i < cred->keys_num; i++)
+		wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key",
+				cred->key[i], cred->key_len[i]);
 	wpa_printf(MSG_DEBUG, "WPS: MAC Address " MACSTR,
 		   MAC2STR(cred->mac_addr));
 
-	auth_type = cred->auth_type;
-	if (auth_type == (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK)) {
-		wpa_printf(MSG_DEBUG, "WPS: Workaround - convert mixed-mode "
-			   "auth_type into WPA2PSK");
-		auth_type = WPS_AUTH_WPA2PSK;
-	}
-
-	if (auth_type != WPS_AUTH_OPEN &&
-	    auth_type != WPS_AUTH_SHARED &&
-	    auth_type != WPS_AUTH_WPAPSK &&
-	    auth_type != WPS_AUTH_WPA2PSK) {
+	if (cred->auth_type != WPS_AUTH_OPEN &&
+	    cred->auth_type != WPS_AUTH_SHARED &&
+	    cred->auth_type != WPS_AUTH_WPAPSK &&
+	    cred->auth_type != WPS_AUTH_WPA2PSK) {
 		wpa_printf(MSG_DEBUG, "WPS: Ignored credentials for "
-			   "unsupported authentication type 0x%x",
-			   auth_type);
+			   "unsupported authentication type %d",
+			   cred->auth_type);
 		return 0;
 	}
 
@@ -268,36 +260,35 @@
 	case WPS_ENCR_NONE:
 		break;
 	case WPS_ENCR_WEP:
-		if (cred->key_len <= 0)
-			break;
-		if (cred->key_len != 5 && cred->key_len != 13 &&
-		    cred->key_len != 10 && cred->key_len != 26) {
-			wpa_printf(MSG_ERROR, "WPS: Invalid WEP Key length "
-				   "%lu", (unsigned long) cred->key_len);
+		if (cred->keys_num > NUM_WEP_KEYS) {
+			wpa_printf(MSG_ERROR, "WPS: Invalid WEP Keys number %d",
+				   cred->keys_num);
 			return -1;
 		}
-		if (cred->key_idx > NUM_WEP_KEYS) {
-			wpa_printf(MSG_ERROR, "WPS: Invalid WEP Key index %d",
-				   cred->key_idx);
-			return -1;
-		}
-		if (cred->key_idx)
-			key_idx = cred->key_idx - 1;
-		if (cred->key_len == 10 || cred->key_len == 26) {
-			if (hexstr2bin((char *) cred->key,
-				       ssid->wep_key[key_idx],
-				       cred->key_len / 2) < 0) {
-				wpa_printf(MSG_ERROR, "WPS: Invalid WEP Key "
-					   "%d", key_idx);
+		for (i = 0; i < cred->keys_num; i++) {
+			int len = cred->key_len[i];
+			if (len <= 0)
+				break;
+			if (len != 5 && len != 13 && len != 10 && len != 26) {
+				wpa_printf(MSG_ERROR, "WPS: Invalid WEP Key[%d] length "
+					   "%lu", i, (unsigned long) cred->key_len[i]);
 				return -1;
 			}
-			ssid->wep_key_len[key_idx] = cred->key_len / 2;
-		} else {
-			os_memcpy(ssid->wep_key[key_idx], cred->key,
-				  cred->key_len);
-			ssid->wep_key_len[key_idx] = cred->key_len;
+			if (len == 10 || len == 26) {
+				if (hexstr2bin((char *) cred->key[i],
+					       ssid->wep_key[i],
+					       cred->key_len[i] / 2) < 0) {
+					wpa_printf(MSG_ERROR, "WPS: Invalid WEP Key "
+						   "%d", i);
+					return -1;
+				}
+				ssid->wep_key_len[i] = cred->key_len[i] / 2;
+			} else {
+				os_memcpy(ssid->wep_key[i], cred->key[i],
+					  cred->key_len[i]);
+				ssid->wep_key_len[i] = cred->key_len[i];
+			}
 		}
-		ssid->wep_tx_keyidx = key_idx;
 		break;
 	case WPS_ENCR_TKIP:
 		ssid->pairwise_cipher = WPA_CIPHER_TKIP;
@@ -307,7 +298,7 @@
 		break;
 	}
 
-	switch (auth_type) {
+	switch (cred->auth_type) {
 	case WPS_AUTH_OPEN:
 		ssid->auth_alg = WPA_AUTH_ALG_OPEN;
 		ssid->key_mgmt = WPA_KEY_MGMT_NONE;
@@ -341,26 +332,26 @@
 	}
 
 	if (ssid->key_mgmt == WPA_KEY_MGMT_PSK) {
-		if (cred->key_len == 2 * PMK_LEN) {
-			if (hexstr2bin((const char *) cred->key, ssid->psk,
+		if (cred->key_len[0] == 2 * PMK_LEN) {
+			if (hexstr2bin((const char *) cred->key[0], ssid->psk,
 				       PMK_LEN)) {
 				wpa_printf(MSG_ERROR, "WPS: Invalid Network "
 					   "Key");
 				return -1;
 			}
 			ssid->psk_set = 1;
-		} else if (cred->key_len >= 8 && cred->key_len < 2 * PMK_LEN) {
+		} else if (cred->key_len[0] >= 8 && cred->key_len[0] < 2 * PMK_LEN) {
 			os_free(ssid->passphrase);
-			ssid->passphrase = os_malloc(cred->key_len + 1);
+			ssid->passphrase = os_malloc(cred->key_len[0] + 1);
 			if (ssid->passphrase == NULL)
 				return -1;
-			os_memcpy(ssid->passphrase, cred->key, cred->key_len);
-			ssid->passphrase[cred->key_len] = '\0';
+			os_memcpy(ssid->passphrase, cred->key[0], cred->key_len[0]);
+			ssid->passphrase[cred->key_len[0]] = '\0';
 			wpa_config_update_psk(ssid);
 		} else {
 			wpa_printf(MSG_ERROR, "WPS: Invalid Network Key "
 				   "length %lu",
-				   (unsigned long) cred->key_len);
+				   (unsigned long) cred->key_len[0]);
 			return -1;
 		}
 	}
@@ -419,10 +410,6 @@
 		break;
 	case WPS_EV_PWD_AUTH_FAIL:
 		break;
-	case WPS_EV_PBC_OVERLAP:
-		break;
-	case WPS_EV_PBC_TIMEOUT:
-		break;
 	}
 }
 
@@ -489,7 +476,7 @@
 
 	if (bssid) {
 		size_t i;
-		int count = 0;
+		struct wpa_scan_res *res;
 
 		os_memcpy(ssid->bssid, bssid, ETH_ALEN);
 		ssid->bssid_set = 1;
@@ -501,7 +488,6 @@
 
 		for (i = 0; i < wpa_s->scan_res->num; i++) {
 			const u8 *ie;
-			struct wpa_scan_res *res;
 
 			res = wpa_s->scan_res->res[i];
 			if (os_memcmp(bssid, res->bssid, ETH_ALEN) != 0)
@@ -516,18 +502,7 @@
 				break;
 			os_memcpy(ssid->ssid, ie + 2, ie[1]);
 			ssid->ssid_len = ie[1];
-			wpa_hexdump_ascii(MSG_DEBUG, "WPS: Picked SSID from "
-					  "scan results",
-					  ssid->ssid, ssid->ssid_len);
-			count++;
-		}
-
-		if (count > 1) {
-			wpa_printf(MSG_DEBUG, "WPS: More than one SSID found "
-				   "for the AP; use wildcard");
-			os_free(ssid->ssid);
-			ssid->ssid = NULL;
-			ssid->ssid_len = 0;
+			break;
 		}
 	}
 
