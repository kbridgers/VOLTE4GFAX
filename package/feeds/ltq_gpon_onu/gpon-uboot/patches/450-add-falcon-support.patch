add Falcon SoC support

diff --git a/arch/mips/cpu/mips32/falcon/Makefile b/arch/mips/cpu/mips32/falcon/Makefile
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/Makefile
@@ -0,0 +1,55 @@
+#########################################################################
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y += dcdc_init.o
+COBJS-y += ddr_init.o
+COBJS-y += gpio.o
+COBJS-y += misc.o
+COBJS-y += speed.o
+COBJS-y += sysctrl.o
+COBJS-$(CONFIG_SPI_FLASH) += ebu_spi.o
+COBJS-$(CONFIG_NAND) += ebu_nand.o
+COBJS-$(CONFIG_FLASH_CFI_DRIVER) += ebu_nor.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/falcon/config.mk b/arch/mips/cpu/mips32/falcon/config.mk
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/config.mk
@@ -0,0 +1,196 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Falcon SoC with MIPS 34Kc CPU core
+#
+
+################################################################################
+# Code to create simple BootROM images (only using download and start tags)
+################################################################################
+
+
+# only active in topdir
+ifeq ($(subst $(SRCTREE),,$(CURDIR)),)
+
+ALL-y += $(obj)u-boot.dis
+
+# only for target not using eXecute In Place (XIP)
+ifneq ($(CONFIG_SYS_TEXT_BASE),0xB0000000)
+
+# add to all target
+ALL-y += $(obj)u-boot.bri
+
+# TAGs with FLAG_SDBG set:
+#TAG_DWNLD := 0x5508AAF7
+#TAG_START := 0x770888F7
+#TAG_REGCFG := 0x2208DDF7
+#TAG_IFCFG := 0x660899F7
+
+# TAGs without flags set:
+TAG_DWNLD := 0x5500AAFF
+TAG_START := 0x770088FF
+TAG_REGCFG := 0x2200DDFF
+TAG_IFCFG := 0x660099FF
+
+define add_val_as_le_bytes
+	perl -e 'printf("%c%c%c%c", ($(1))&0xFF, (($(1))>>8)&0xFF, (($(1))>>16)&0xFF, (($(1))>>24)&0xFF)'
+endef
+
+define pad_if_less_avail
+	# $(1) blocksize
+	# $(2) req. room to be free
+	# $(3) file
+	perl -e 'my $$f="$(3)"; my $$size = -s $$f; $$rest=$(1)-($$size%$(1));if($$rest<$(2)){open(F,">>$$f");for($$i=0;$$i<$$rest;$$i++){print F chr(0);};close(F)}'
+endef
+
+define add_padding
+	# $(1) blocksize
+	# $(2) file
+	perl -e 'my $$f="$(2)"; \
+		my $$bs=$(1); \
+		my $$b; \
+		if ($$bs =~/0x/) \
+		{$$b=int(hex($$bs))} \
+		else \
+		{$$b=int($$bs)}; \
+		my $$size = -s $$f; \
+		$$rest=$$b-($$size%$$b); \
+		open(F,">>$$f"); \
+		for($$i=0;$$i<$$rest;$$i++) \
+		{print F chr(0);}; \
+		close(F)'
+endef
+
+# tweak some ebu registers to optimize performance for booting from flash
+ifneq ($(CONFIG_FLASH_CFI_DRIVER),)
+define add_ebu_setup
+	echo "Add TAG_REGCFG for NOR timing"
+	# TAG_REGCFG()
+	$(call add_val_as_le_bytes,$(TAG_REGCFG)) >> $1
+	# length
+	$(call add_val_as_le_bytes,16) >> $1
+	# Reg BUSRP0
+	$(call add_val_as_le_bytes,0xB8000014) >> $1
+	$(call add_val_as_le_bytes,0x22252122) >> $1
+	# Reg BUSWP0
+	$(call add_val_as_le_bytes,0xB800001C) >> $1
+	$(call add_val_as_le_bytes,0x22252122) >> $1
+endef
+endif
+
+ifneq ($(CONFIG_NAND),)
+define add_ebu_setup_nand_reg_
+	# FIXME: currently unused, need valid register values!
+	echo "Add TAG_REGCFG for NAND timing"
+	# TAG_REGCFG()
+	$(call add_val_as_le_bytes,$(TAG_REGCFG)) >> $1
+	# length
+	$(call add_val_as_le_bytes,16) >> $1
+	# Reg BUSRP0
+	$(call add_val_as_le_bytes,0xB8000014) >> $1
+	$(call add_val_as_le_bytes,0x00000000) >> $1
+	# Reg BUSWP0
+	$(call add_val_as_le_bytes,0xB800001C) >> $1
+	$(call add_val_as_le_bytes,0x00000000) >> $1
+endef
+
+ifneq ($(CONFIG_SYS_NAND_PAGESIZE),)
+ifneq ($(CONFIG_SYS_NAND_BYTES_PER_COLADDR),)
+define add_ebu_setup_nand_ifcfg
+	#echo "Add TAG_IFCFG for large NAND"
+	# TAG_IFCFG()
+	$(call add_val_as_le_bytes,$(TAG_IFCFG)) >> $1
+	# length
+	$(call add_val_as_le_bytes,8) >> $1
+	$(call add_val_as_le_bytes,$(shell echo $(CONFIG_SYS_NAND_PAGESIZE))) >> $1
+	$(call add_val_as_le_bytes,$(shell echo $(CONFIG_SYS_NAND_BYTES_PER_COLADDR))) >> $1
+	# pad to start of next page
+	#$ ( call add_padding,$(CONFIG_SYS_NAND_PAGESIZE),$1)
+	$(call add_padding,0x80,$1)
+endef
+endif
+endif
+
+define add_ebu_setup
+	$(call add_ebu_setup_nand_reg,$1)
+	# FIXME: we need a valid tag at each 128byte block (small XMODEM blocks)
+	# TODO: add some loop code, which depends on CONFIG_SYS_NAND_PAGESIZE
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+	$(call add_ebu_setup_nand_ifcfg,$1)
+endef
+endif
+
+ifneq ($(CONFIG_SPI_FLASH),)
+define add_ebu_setup
+	echo "Add TAG_REGCFG for Serial Flash timing"
+	# TAG_REGCFG()
+	$(call add_val_as_le_bytes,$(TAG_REGCFG)) >> $1
+	# length
+	$(call add_val_as_le_bytes,8) >> $1
+	# Reg SFTIME
+	$(call add_val_as_le_bytes,0xB8000084) >> $1
+	$(call add_val_as_le_bytes,0xFF000204) >> $1
+endef
+endif
+
+$(obj)u-boot.bri:	$(obj)u-boot.bin
+	rm -f $@
+	$(call add_ebu_setup,$@)
+	# make sure, the following elements are not crossing the border of a block
+	$(call pad_if_less_avail,128,12,$@)
+	# TAG_DWNLD()
+	$(call add_val_as_le_bytes,$(TAG_DWNLD)) >> $@
+	# length (address + file)
+	$(call add_val_as_le_bytes,$(shell stat -c %s $<)+4) >> $@
+	# load address
+	$(call add_val_as_le_bytes,$(CONFIG_SYS_TEXT_BASE)) >> $@
+	# image data
+	dd status=noxfer if=$< >> $@ 2>/dev/null
+	# make sure, the following elements are not crossing the border of a block
+	# (12 bytes would be enough, but with 16 we are sure to not have
+	# multiples of 512 as image size, which might be a problem for tftp boot)
+	$(call pad_if_less_avail,128,16,$@)
+	# TAG_START()
+	$(call add_val_as_le_bytes,$(TAG_START)) >> $@
+	# length (address)
+	$(call add_val_as_le_bytes,4) >> $@
+	# start address
+	$(call add_val_as_le_bytes,$(CONFIG_SYS_TEXT_BASE)) >> $@
+
+endif
+endif
diff --git a/arch/mips/cpu/mips32/falcon/dcdc_init.c b/arch/mips/cpu/mips32/falcon/dcdc_init.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/dcdc_init.c
@@ -0,0 +1,309 @@
+/*
+ * (C) Copyright 2011
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+#define DEBUG
+#define DEBUG_GPIO
+*/
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/sysctrl.h>
+#include <asm/arch/dcdc_reg.h>
+
+#define DCDC_V1_0_SELECTION	3
+
+static struct gpon_reg_dcdc * const dcdc_core = (struct gpon_reg_dcdc *)GPON_DCDC_CORE_BASE;
+static struct gpon_reg_dcdc * const dcdc_ddr = (struct gpon_reg_dcdc *)GPON_DCDC_DDR_BASE;
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef DEBUG_GPIO
+#include <asm/gpio.h>
+#define DEBUG_GPIO_NR	1
+static void setup_debug_gpio(int value)
+{
+	gpio_request(DEBUG_GPIO_NR, "dcdc debug");
+	gpio_direction_output(DEBUG_GPIO_NR, value);
+}
+static void cleanup_debug_gpio(void)
+{
+	gpio_direction_input(DEBUG_GPIO_NR);
+	gpio_free(DEBUG_GPIO_NR);
+}
+static void set_debug_gpio(int value)
+{
+	gpio_set_value(DEBUG_GPIO_NR, value);
+}
+#else
+static void setup_debug_gpio(int value) {}
+static void cleanup_debug_gpio(void) {}
+static void set_debug_gpio(int value ) {}
+#endif
+
+/**
+ * Calculate coefficients for dcdc controller
+ * @param[in]	L	Inductance in nH
+ * @param[in]	C	Capacity in uF
+ * @param[in]	fsw	frequency in kHz
+ * @param	b0	returns b0 coefficient
+ * @param	b1	returns b1 coefficient
+ * @param	b2	returns b2 coefficient
+ * @return
+ * 	0	on success
+ * 	-1	on error
+ */
+static int calc_dcdc_coeff(int L, int C, uint fsw,
+	uint16_t *b0, uint16_t *b1, uint16_t *b2)
+{
+	/** \todo calculate these coefficients */
+	if ((L==4700) && (C==22) && (fsw==977)) {
+		/* L=4.7uH, C=22uF, fsw=0.977MHz */
+		*b0 = 0x0181;
+		*b1 = 0xFCEA;
+		*b2 = 0x0198;
+	} else if ((L==1500) && (C==166) && (fsw==977)) {
+		/* L=1.5uH,C=166uF, fsw=0.977MHz */
+		*b0 = 0x0256;
+		*b1 = 0xFB41;
+		*b2 = 0x026C;
+	} else {
+		printf("No DCDC coefficients for L=%d.%03duH, C=%duF, "
+			"fsw=%d.%03dMHz\n",
+			L/1000, L%1000, C, fsw/1000, fsw%1000);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * update voltage reference (dig_ref)
+ *
+ * @param voltage	target voltage in mV
+ * @return none
+ */
+void falcon_dcdc_core_set_voltage(unsigned int voltage)
+{
+	uint8_t dig_ref, offset_fuse;
+	int8_t offset;
+
+	offset_fuse = (status_r32(fuse1) & STATUS_FUSE1_OFFSET1V0DCDC_MASK)
+		>> STATUS_FUSE1_OFFSET1V0DCDC_OFFSET;
+	/* let the cpu convert the 5bit signed value */
+	offset = (int8_t)(offset_fuse<<3) / 8;
+
+	dig_ref = (((voltage * 512) - 3000) / 4000) + offset;
+	debug("dcdc_core: dig_ref=0x%02X, voltage=%d, offset=%d\n",
+		dig_ref, voltage, offset);
+
+	dcdc_core_w8(dig_ref, pdi_dig_ref);
+}
+
+static void wait_and_print_dcdc_err(uint32_t m_sec, const char *txt)
+{
+	debug("%s: error_read %d\n",
+		txt, (int8_t)dcdc_core_r8(pdi_error_read));
+	if (m_sec) {
+		/* wait X ms for stabilisation */
+		udelay(m_sec*1000);
+		debug("after %d ms: error_read %d\n",
+			m_sec, (int8_t)dcdc_core_r8(pdi_error_read));
+	}
+}
+
+/**
+ * Init the core dcdc with new coefficients
+ *
+ * @param voltage	target voltage in mV
+ * @return status
+ */
+int falcon_dcdc_core_init(unsigned int voltage)
+{
+	const uint32_t DUTY_CYCLE_TIMES = 100;
+	int coeff_valid;
+	uint16_t b0, b1, b2;
+	uint32_t duty_cycle_av, i;
+	uint32_t duty_cycle_diff[3];
+	uint8_t duty_cycle_curr, duty_cycle_min, duty_cycle_max;
+	int8_t error_read;
+
+	gd->have_console = 1;
+	coeff_valid = (calc_dcdc_coeff(1500, 166, 977, &b0, &b1, &b2) == 0);
+
+	sys1_hw_activate(ACTS_DCDC1V0);
+
+	setup_debug_gpio(1);
+
+	duty_cycle_diff[0] = 0;
+	duty_cycle_diff[1] = 0;
+	duty_cycle_diff[2] = 0;
+	do {
+		duty_cycle_av = 0;
+		duty_cycle_min = 0xFF;
+		duty_cycle_max = 0;
+		for (i=0; i<DUTY_CYCLE_TIMES; i++) {
+			duty_cycle_curr = dcdc_core_r8(pdi_duty_cycle);
+			duty_cycle_av += duty_cycle_curr;
+			if (duty_cycle_curr < duty_cycle_min)
+				duty_cycle_min = duty_cycle_curr;
+			if (duty_cycle_curr > duty_cycle_max)
+				duty_cycle_max = duty_cycle_curr;
+			udelay(10);
+		}
+
+		duty_cycle_av = duty_cycle_av / DUTY_CYCLE_TIMES;
+		debug("duty_cycle_average = %d, min = %d, max = %d\n",
+			duty_cycle_av, duty_cycle_min, duty_cycle_max);
+
+		/* copy to history */
+		duty_cycle_diff[2] = duty_cycle_diff[1];
+		duty_cycle_diff[1] = duty_cycle_diff[0];
+		duty_cycle_diff[0] = duty_cycle_max - duty_cycle_min;
+		debug("duty_cycle_diff[0/1/2] = %d, %d, %d\n",
+			duty_cycle_diff[0], duty_cycle_diff[1], duty_cycle_diff[2]);
+
+		if (duty_cycle_diff[0] <= duty_cycle_diff[1] &&
+		    duty_cycle_diff[0] <= duty_cycle_diff[2])
+			break;
+	} while (1);
+
+	set_debug_gpio(0);
+	/* restrict duty cycle range around average */
+	dcdc_core_w8(duty_cycle_av+10, pdi_duty_cycle_max_sat);
+	dcdc_core_w8(duty_cycle_av-10, pdi_duty_cycle_min_sat);
+
+	/* force static duty cycle value during coefficient programming */
+	dcdc_core_w8(duty_cycle_av, pdi_pwm1);
+
+	set_debug_gpio(1);
+	dcdc_core_w8_mask(0, DCDC_CONF_TEST_DIG_SOFT_PRESET_PID |
+			     DCDC_CONF_TEST_DIG_FREEZE_PID, 
+			     pdi_conf_test_dig);
+
+	if (coeff_valid) {
+		dcdc_core_w8(b0>>8, pdi_pid_hi_b0);
+		dcdc_core_w8(b0, pdi_pid_lo_b0);
+		dcdc_core_w8(b1>>8, pdi_pid_hi_b1);
+		dcdc_core_w8(b1, pdi_pid_lo_b1);
+		dcdc_core_w8(b2>>8, pdi_pid_hi_b2);
+		dcdc_core_w8(b2, pdi_pid_lo_b2);
+	}
+	error_read = (int8_t)dcdc_core_r8(pdi_error_read);
+	dcdc_core_w8_mask(DCDC_CONF_TEST_DIG_SOFT_PRESET_PID |
+			  DCDC_CONF_TEST_DIG_FREEZE_PID,
+			  0, pdi_conf_test_dig);
+	debug("before unfreeze: error_read %d\n", error_read);
+	wait_and_print_dcdc_err(1, "unfreeze");
+
+	set_debug_gpio(0);
+	/* for chip-ver < A12: meaning of DCDC_CLK_SET0_CLK_SEL_PWM is inverted! */
+	if (is_falcon_chip_a1x() && ((status_r32(config) & STATUS_CONFIG_SUBVERS_MASK) == 0))
+		dcdc_core_w8_mask(0, DCDC_CLK_SET0_CLK_SEL_PWM, pdi_clk_set0);
+	/* set to 249 leads to a switching frequency of 250MHz/250 = 1MHz */
+	dcdc_core_w8(249, pdi_pwm0);
+	wait_and_print_dcdc_err(1, "switch freq");
+
+	set_debug_gpio(1);
+	/* set wider limitation for normal operation */
+	dcdc_core_w8(duty_cycle_av+40, pdi_duty_cycle_max_sat);
+	dcdc_core_w8(duty_cycle_av-30, pdi_duty_cycle_min_sat);
+	/* set alarm ranges */
+	dcdc_core_w8(duty_cycle_av+30, pdi_duty_cycle_max);
+	dcdc_core_w8(duty_cycle_av-20, pdi_duty_cycle_min);
+	wait_and_print_dcdc_err(1, "normal duty");
+
+	set_debug_gpio(0);
+	falcon_dcdc_core_set_voltage(voltage);
+	wait_and_print_dcdc_err(1, "switch voltage");
+
+	cleanup_debug_gpio();
+	gd->have_console = 0;
+
+	return 0;
+}
+
+/**
+ * Init the ddr dcdc with coefficients
+ *
+ * @param voltage	target voltage in mV
+ * @return status
+ */
+int falcon_dcdc_ddr_init(unsigned int voltage)
+{
+	int ret;
+	uint16_t b0, b1, b2;
+	uint8_t dig_ref;
+
+	sys1_hw_activate(ACTS_DCDCDDR);
+
+	dig_ref = ((( (((voltage/10) + 100)*64 - 75) *
+		      (320 ) ) / 32000 ) );
+
+	/* disable */
+	dcdc_ddr_w8(0x78, pdi_conf_test_ana_noauto);
+	dcdc_ddr_w8(0x00, pdi_conf_test_dig_noauto);
+
+	ret = calc_dcdc_coeff(4700, 22, 977, &b0, &b1, &b2);
+
+	if (ret == 0) {
+		dcdc_ddr_w8(b0>>8, pdi_pid_hi_b0);
+		dcdc_ddr_w8(b0, pdi_pid_lo_b0);
+		dcdc_ddr_w8(b1>>8, pdi_pid_hi_b1);
+		dcdc_ddr_w8(b1, pdi_pid_lo_b1);
+		dcdc_ddr_w8(b2>>8, pdi_pid_hi_b2);
+		dcdc_ddr_w8(b2, pdi_pid_lo_b2);
+	}
+
+	/* divide output clock by 2 and leave default multiplication factor */
+	dcdc_ddr_w8_mask(0, DCDC_CLK_SET0_CLK_SEL_PWM, pdi_clk_set0);
+	dcdc_ddr_w8((1<<DCDC_CLK_SET1_MDLL_RES_OFFSET), pdi_clk_set1);
+	/* set to 249 leads to a switching frequency of 250MHz/250 = 1MHz */
+	dcdc_ddr_w8(249, pdi_pwm0);
+	dcdc_ddr_w8(0x00, pdi_pwm1);
+	dcdc_ddr_w8(DCDC_BIAS_VREG_VREG_SEL_NOMINAL, pdi_bias_vreg);
+	dcdc_ddr_w8(dig_ref, pdi_dig_ref);
+	dcdc_ddr_w8(DCDC_GENERAL_OS_EN | DCDC_GENERAL_RESERVED0 |
+		DCDC_GENERAL_SET_LSB_DIGREF, pdi_general);
+	dcdc_ddr_w8(0x62, pdi_adc0); /* reset value */
+	dcdc_ddr_w8(0x12, pdi_adc1); /* reset value */
+	dcdc_ddr_w8(0x77, pdi_adc2); /* reset value */
+	dcdc_ddr_w8(0x00, pdi_duty_cycle);
+	dcdc_ddr_w8(0x47, pdi_non_ov_delay);
+	dcdc_ddr_w8(DCDC_ANALOG_GAIN_ATTENUATE_ANA, pdi_analog_gain);
+	dcdc_ddr_w8(0xA0, pdi_duty_cycle_max_sat);
+	dcdc_ddr_w8(0x07, pdi_duty_cycle_min_sat);
+	dcdc_ddr_w8(0x7E, pdi_duty_cycle_max);	/** \todo calculate value */
+	dcdc_ddr_w8(0xAC, pdi_duty_cycle_min);	/** \todo calculate value */
+	dcdc_ddr_w8(0x40, pdi_error_max);
+	dcdc_ddr_w8(15 << DCDC_DELAY_DEGLITCH_ALARM_DEGLITCH_OFFSET |
+		     0 << DCDC_DELAY_DEGLITCH_RAMP_DELAY_OFFSET,
+		     pdi_delay_deglitch);
+	dcdc_ddr_w8(0x51, pdi_latch_control_noauto);
+	dcdc_ddr_w8(0x80, pdi_cap_clk_cnt);
+	dcdc_ddr_w8(0x00, pdi_mdll_divider);
+
+	/* enable */
+	dcdc_ddr_w8(0x07, pdi_conf_test_ana_noauto);
+	dcdc_ddr_w8(0x03, pdi_conf_test_dig_noauto);
+
+	return 0;
+}
diff --git a/arch/mips/cpu/mips32/falcon/ddr_init.c b/arch/mips/cpu/mips32/falcon/ddr_init.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/ddr_init.c
@@ -0,0 +1,901 @@
+/*
+ * (C) Copyright 2012
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#ifndef CONFIG_SYS_NO_DDR_INIT
+
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/falcon.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/sysctrl.h>
+#include <asm/arch/ddrdb_reg.h>
+
+typedef struct
+{
+	u32 reg;
+	u32 res[3];
+} ddrdb_t;
+
+static ddrdb_t * const pDDRDB = (ddrdb_t *)GPON_DDRDB_BASE;
+
+/* Register access macros */
+#define ddrdb_readl(idx)	\
+	reg_r32(&(pDDRDB+idx)->reg)
+#define ddrdb_writel_mask(idx,clear,set)	\
+	reg_w32_mask(clear, set, &(pDDRDB+idx)->reg)
+#if 1
+#define ddrdb_writel(idx,value)	\
+	reg_w32(value, &(pDDRDB+idx)->reg)
+#else
+static inline void ddrdb_writel(u32 idx, u32 val)
+{
+	debug("%2d < 0x%08X\n", idx, val);
+	writel(val, &(pDDRDB+idx)->reg);
+}
+#endif
+
+/* some fixed values for Falcon */
+#define DDR_CLOCK		200			/* in MHz */
+#define DDR_CLK_PERIOD		(1000/DDR_CLOCK)	/* in ns */
+#define DDR_CHIP_NUM		1			/* only one CS available */
+
+/* calculation of intermediate values from settings */
+#ifdef DDR_CHIP_TYPE
+#if (DDR_CHIP_TYPE != 2)
+#error "Only DDR2 (DDR_CHIP_TYPE=2) supported!"
+#endif
+#else
+#error "Please define DDR_CHIP_TYPE"
+#endif
+#if (DDR_CHIP_CAS_LATENCY<2)
+#error "Invalid/unsupported value for DDR_CHIP_CAS_LATENCY"
+#endif
+
+#define DEFAULT_LOWPOWER_POWER_DOWN_CNT		100
+#define DEFAULT_LOWPOWER_SELF_REFRESH_CNT	256
+
+#define LOWPOWER_MODE2BITS(mode)	(1<<(5-mode))
+
+struct sdram_conf_s {
+	ulong size;
+	int rows;
+	int banks;
+};
+
+struct sdram_conf_s sdram_conf[] = {
+	{(128 << 20), 13, 8}, /* 128MByte: 1x1GBit,  13x10, 8 banks */
+	{(64 << 20),  13, 4}, /* 64MByte: 1x512MBit, 13x10, 4 banks */
+	{(32 << 20),  12, 4}, /* 32MByte: 1x256MBit, 12x10, 4 banks */
+};
+
+/* Return the bit position of the most significant 1 bit in a word */
+static inline int ilog2(unsigned int x)
+{
+	extern int __builtin_clz (unsigned int x);
+	return 31 - __builtin_clz(x);
+}
+
+static int ddrstatus(void);
+
+static void ddr_init_exec(void)
+{
+	u32 start_time;
+
+	/* activate memory controller */
+	ddrdb_writel(7, ddrdb_readl(7) | CTL7_START);
+
+	/* Wait for init complete status */
+	debug("\nWait for init complete: ");
+	start_time = get_timer(0);
+	for (;;) {
+		u32 ctl_22 = ddrdb_readl(22);
+		if (get_timer(start_time) > 100)
+			printf("\r\t( %lu: ctl_22 0x%08X, dll-lock %d)\t",
+				get_timer(start_time), ctl_22, ddrdb_readl(47) & 1);
+		if ((ctl_22 & 0x04000000) != 0x04000000)
+			udelay(100);
+		else {
+			debug("Initialized (ctl_22: 0x%08X)", ctl_22);
+			break;
+		}
+	}
+
+	/* Wait for DLLs lock */
+	debug("\nWait for DLLs lock: ");
+	for (;;) {
+		if ((ddrdb_readl(47) & ddrdb_readl(48) & CTL_47_DLL_LOCK) != CTL_47_DLL_LOCK) {
+			udelay(1);
+		}
+		else {
+			debug("Locked\n");
+			break;
+		}
+	}
+
+	/* Add delay of >200ns before any external access */
+	udelay(1);
+
+#ifdef DEBUG
+	debug("DDR_GSR0: 0x%08X\n", xbar_r32(ddr_gsr0));
+	//ddrstatus();
+#endif
+	xbar_w32_mask(XBAR_DDR_PRIO_TI_DISABLE_DMC2PAD_RX_ENABLE, 0,
+		ddr_prio_ti);
+}
+
+static void setup_geometry(ulong size, int rows, int banks)
+{
+	int total_addr_lines;
+	int ba_lines;
+	int columns;
+	u32 col_size;
+	u32 addr_pins = 14 - rows;
+
+	total_addr_lines = ilog2(size) - 1; /* 16bit datawidth */
+	ba_lines = ilog2(banks);
+
+	columns = total_addr_lines - rows - ba_lines;
+	col_size = 12 - columns;
+
+	debug("setup_geometry:\n\tsize: %ld\n", size);
+	debug("\taddr per 16-bit: %d\n", total_addr_lines);
+
+	debug("\tcols: %d\n", columns);
+	debug("\trows: %d\n", rows);
+	debug("\tbanks: %d (%d lines)\n", banks, ba_lines);
+
+	ddrdb_writel_mask( 3,
+		CTL3_EIGHT_BANK_MODE,
+		(banks==8) ? CTL3_EIGHT_BANK_MODE_EIGHT_BANKS:0);
+
+	ddrdb_writel_mask(11,
+		CTL_11_COLUMN_SIZE_MASK | CTL_11_ADDR_PINS_MASK,
+		(((col_size << CTL_11_COLUMN_SIZE_OFFSET) & CTL_11_COLUMN_SIZE_MASK) |
+		((addr_pins << CTL_11_ADDR_PINS_OFFSET) & CTL_11_ADDR_PINS_MASK)) );
+
+}
+
+static void setup_ddr_params(unsigned int cl)
+{
+	if (cl < 2)
+		cl = DDR_CHIP_CAS_LATENCY;
+
+	/* ctl_00 */
+	u32 arefresh = 0;
+	u32 ap = 0;		/* auto precharge */
+	u32 addr_cmp_en = 1;
+	u32 active_aging = 1;
+
+	/* ctl_01 */
+	u32 concurrentap = 1;
+	u32 big_endian_en = 0;
+	u32 bank_split_en = 1;
+	u32 auto_refresh_mode = 0;
+
+	/* ctl_02 */
+	u32 drive_dq_dqs = 1;
+	u32 dqs_n_en = 1;
+	u32 dll_bypass_mode = 0;
+
+	/* ctl_03 */
+	u32 intrptapburst = 0;
+	u32 fast_write = 0; /* 1 not working */
+	u32 enable_quick_srefresh = 1;
+	u32 eight_bank_mode = 0; /* as default, will change during probing */
+
+	/* ctl_04 */
+	u32 odt_add_turn_clk_en = 1; //(DDR_CHIP_NUM>1);
+	u32 no_cmd_init = 0;
+	u32 intrptwritea = 0;
+	u32 intrptreada = 0;
+
+	/* ctl_05 */
+	u32 priority_en = 1;
+	u32 power_down = 0;	/* power-down(1) does not work */
+	u32 placement_en = 1;
+	u32 odt_alt_en = 0;
+
+	/* ctl_06 */
+	u32 rw_same_en = 1;
+	u32 reg_dimm_enable = 0;
+	u32 reduc = 1;
+	u32 pwrup_srefresh_exit = 0;
+
+	/* ctl_07 */
+	u32 tras_lockout = 1;
+	u32 swap_en = 1;
+	u32 srefresh = 0;
+
+	/* ctl_08 */
+	u32 cs_map = (1 << DDR_CHIP_NUM)-1;
+	u32 writeinterp = 1;
+	u32 tref_enable = 1;
+
+	/* ctl_09 */
+	u32 odt_rd_map_cs0 = (DDR_CHIP_NUM>1) ? 2 : 0;
+	/*u32 max_cs_reg = 0; Read-Only */
+	u32 lowpower_refresh_enable =
+		CTL9_LOWPOWER_REFRESH_ENABLE_LPREF>>CTL9_LOWPOWER_REFRESH_ENABLE_OFFSET;
+	u32 dram_clk_disable = (DDR_CHIP_NUM>1) ? 0 : 2;
+
+	/* ctl_10 */
+	u32 rtt_0 = (DDR_CHIP_NUM>1) ?
+		CTL_10_RTT_0_OHM_75>>CTL_10_RTT_0_OFFSET :
+		CTL_10_RTT_0_OHM_150>>CTL_10_RTT_0_OFFSET;
+	u32 odt_wr_map_cs1 = (DDR_CHIP_NUM>1) ? 1 : 0;
+	u32 odt_wr_map_cs0 = (DDR_CHIP_NUM>1) ? 2 : 0;
+	u32 odt_rd_map_cs1 = (DDR_CHIP_NUM>1) ? 1 : 0;
+
+	/* ctl_11 */
+	u32 col_size = 0;
+	u32 cke_delay = 0;
+	u32 cas_lat = cl;
+	u32 addr_pins = 0;
+
+	/* ctl_12 */
+	u32 tdfi_dram_clk_disable = 0;
+	u32 tcke = DDR_DEVICE_T_CKE;
+	u32 q_fullness = 0;
+
+	/* ctl_13 */
+	u32 w2r_samecs_dly = 0;
+	u32 w2r_diffcs_dly = 0;
+	u32 trtp = DIV_ROUND_UP(DDR_DEVICE_T_RTP,DDR_CLK_PERIOD);
+	u32 trrd = DIV_ROUND_UP(DDR_DEVICE_T_RRD,DDR_CLK_PERIOD);
+
+	/* ctl_14 */
+	u32 caslat_lin_gate = (cas_lat*2)-1;
+	u32 caslat_lin = cas_lat*2;
+	u32 aprebit = DDR_DEVICE_APREBIT;
+	u32 age_count = 15;
+
+	/* ctl_15 */
+	/* u32 max_col_reg Read-Only */
+	u32 initaref = DDR_DEVICE_INITAREF;
+	u32 dram_class = ((DDR_CHIP_TYPE==2) ? CTL_15_DRAM_CLASS_DDR2 :
+		CTL_15_DRAM_CLASS_DDR1) >> CTL_15_DRAM_CLASS_OFFSET;
+	u32 command_age_count = 15;
+
+	/* ctl_16 */
+	u32 rdlat_adj = cas_lat;
+	/* other fields Read-Only */
+
+	/* ctl_17 */
+	/*u32 tdfi_phy_wrlat Read-Only */
+	u32 tdfi_phy_rdlat = cas_lat;
+	u32 tdfi_dram_clk_enable = 1;
+	u32 tdfi_ctrl_delay = 2;
+
+	/* ctl_18 */
+	u32 trp = DIV_ROUND_UP(DDR_DEVICE_T_RP,DDR_CLK_PERIOD);
+	u32 tdfi_rddata_en_base = 2; /* ??? */
+	/*u32 tdfi_rddata_en Read-Only */
+	u32 tdfi_phy_wrlat_base = 2;
+
+	/* ctl_19 */
+	u32 lowpower_auto_enable = LOWPOWER_MODE2BITS(1)
+				 | LOWPOWER_MODE2BITS(3)
+				 | LOWPOWER_MODE2BITS(4);
+	u32 wrlat_adj = cas_lat-1;
+	u32 wrlat = cas_lat-1;
+	u32 twtr = DIV_ROUND_UP(DDR_DEVICE_T_WTR,DDR_CLK_PERIOD);
+
+	/* ctl_20 */
+	u32 tdal = DIV_ROUND_UP(DDR_DEVICE_T_RP+DDR_DEVICE_T_WR,DDR_CLK_PERIOD);
+	u32 ocd_adjust_pup_cs0 = 0;
+	u32 ocd_adjust_pdn_cs0 = 7;
+	u32 lowpower_control = LOWPOWER_MODE2BITS(1) | LOWPOWER_MODE2BITS(4);
+
+	/* ctl_21 */
+	u32 twr_int = DIV_ROUND_UP(DDR_DEVICE_T_WR,DDR_CLK_PERIOD);
+	u32 trc = DIV_ROUND_UP(DDR_DEVICE_T_RC,DDR_CLK_PERIOD);
+	u32 tmrd = DDR_DEVICE_T_MRD;
+	u32 tfaw = DIV_ROUND_UP(DDR_DEVICE_T_FAW,DDR_CLK_PERIOD);
+
+	/* ctl_23 */
+	u32 tras_min = DIV_ROUND_UP(DDR_DEVICE_T_RAS_MIN,DDR_CLK_PERIOD);
+	u32 tmod = DIV_ROUND_UP(DDR_DEVICE_T_MOD,DDR_CLK_PERIOD);
+	u32 dll_rst_adj_dly = 0;
+	/* u32 dll_lock Read-Only */
+
+	/* ctl_24 */
+	u32 trfc = DIV_ROUND_UP(DDR_DEVICE_T_RFC,DDR_CLK_PERIOD);
+	u32 trcd_int = DIV_ROUND_UP(DDR_DEVICE_T_RCD,DDR_CLK_PERIOD);
+
+	/* mode register */
+	u32 mrs_burst_length_type = 2; /* bl=4: 2, bl=8: 3 */
+	u32 mrs_write_recovery = 4;
+	u32 mrs_powerdown = 0;
+	u32 mrs = mrs_burst_length_type |
+			(cas_lat << 4) |
+			((mrs_write_recovery-1) << 9) |
+			(mrs_powerdown << 12);
+
+	/* extended mode register 1 */
+	u32 emrs1_out_drive_strength = 0;
+	u32 emrs1_rtt_mask = /* currently only 75 or 150 Ohm */
+		(rtt_0 == CTL_10_RTT_0_OHM_75>>CTL_10_RTT_0_OFFSET) ? 0x04 : 0x40;
+	/* AL (Additive Latency): only 0 supported */
+	u32 emrs1 = (emrs1_out_drive_strength << 1) |
+		emrs1_rtt_mask |
+		((dqs_n_en ? 0 : 1) << 10);
+
+	/* extended mode register 2 */
+	u32 emrs2 = 0;
+	/* extended mode register 3 */
+	u32 emrs3 = 0;
+
+	/* registers up to ctl_28 containing the mode registers */
+
+	/* ctl_30 */
+	u32 dll_rst_delay = 0;
+	u32 tref = DIV_ROUND_UP(DDR_DEVICE_T_REF*1000,DDR_CLK_PERIOD);
+
+	/* ctl_31 */
+	u32 lowpower_external_cnt = DEFAULT_LOWPOWER_SELF_REFRESH_CNT;
+	u32 lowpower_internal_cnt = DEFAULT_LOWPOWER_SELF_REFRESH_CNT;
+
+	/* ctl_32 */
+	u32 lowpower_refresh_hold = 0;
+	/* number of idle cycles before memory power-down low power mode */
+	u32 lowpower_power_down_cnt = DEFAULT_LOWPOWER_POWER_DOWN_CNT;
+
+	/* ctl_33 */
+	u32 tcpd = 80;
+	/* number of cycles to the next memory self-refresh low power mode */
+	u32 lowpower_self_refresh_cnt = DEFAULT_LOWPOWER_SELF_REFRESH_CNT;
+
+	/* ctl_34 */
+	/* DRAM TPDEX parameter in cycles */
+	u32 tpdex = 2;
+	/* DRAM TDLL parameter in cycles */
+	u32 tdll = 200;
+
+	/* ctl_35 */
+	/* DRAM TXSNR parameter in cycles */
+	u32 txsnr = 0x1C;
+	/* DRAM TRAS_MAX parameter in cycles */
+	u32 tras_max = 13990; /* 0x36A6 */
+
+	/* ctl_36 */
+	/* u32 version Read-Only */
+	u32 txsr = 200;
+
+	/* ctl_37 */
+	u32 tinit = DIV_ROUND_UP(200*1000,DDR_CLK_PERIOD); /* 200us */
+
+	/* ctl_38 */
+	/* PHY testing mode */
+	u32 dft_ctrl_reg = 0;
+
+	/* ctl_39 - ctl_42 */
+	/* DLL Bypass Control */
+	u32 dll_byp_ctrl = 0;
+	/* Bypass Mode DQS Delay */
+	u32 dllb_dqs_del = 0x1A;
+	/* Normal Mode DQS Delay */
+	u32 dlln_dqs_del = 0x1C;
+	/* DLL Start Point Control */
+	u32 dllspc = 0x20;
+	u32 dll_ctrl_reg_0_X = (dll_byp_ctrl ? CTL_39_DLL_BYP_CTRL_DLLB : 0) |
+		((dllb_dqs_del << CTL_39_DLLB_DQS_DEL_OFFSET) & CTL_39_DLLB_DQS_DEL_MASK) |
+		((dlln_dqs_del << CTL_39_DLLN_DQS_DEL_OFFSET) & CTL_39_DLLN_DQS_DEL_MASK) |
+		((dllspc << CTL_39_DLLSPC_OFFSET) & CTL_39_DLLSPC_MASK);
+
+	/* ctl_43 - ctl_46 */
+	/* Bypass Mode CLK_WR Setting */
+	u32 dllb_clk_wr = 0x55;
+	/* Normal Mode CLK_WR Setting */
+	u32 dlln_clk_wr = 0x5F;
+	/* DLL Increment Value */
+	u32 dllincval = 0x04;
+	u32 dll_ctrl_reg_1_X =
+		((dllb_clk_wr << CTL_43_DLLB_CLK_WR_OFFSET) & CTL_43_DLLB_CLK_WR_MASK) |
+		((dlln_clk_wr << CTL_43_DLLN_CLK_WR_OFFSET) & CTL_43_DLLN_CLK_WR_MASK) |
+		((dllincval << CTL_43_DLLINCVAL_OFFSET) & CTL_43_DLLINCVAL_MASK);
+
+	/* ctl_52 */
+	u32 pad_ctrl_reg_0 = CTL_52_PADIMP_PAD150 |
+		((DDR_CHIP_TYPE==2) ? CTL_52_PADTYPE_PADDDR2 : 0) |
+		CTL_52_IDDQ_RX_SIG_INIDDQ | CTL_52_IDDQ_TX_SIG_OUTIDDQ |
+		CTL_52_IDDQ_RX_CLK_INIDDQ | CTL_52_IDDQ_TX_CLK_OUTIDDQ;
+
+	/* ctl_53 - ctl_56 */
+	/* Read Data Delay */
+	u32 rdd = 3;
+	/* Adjust Starting Point of DQS Output Enable Window */
+	u32 dqs_start_oe = 4;
+	/* Adjust Ending Point of DQS Output Enable Window */
+	u32 dqs_end_oe = 3;
+	/* Adjust Starting Point of DQ Output Enable Window */
+	u32 dq_start_oe = 2;
+	/* Adjust Ending Point of DQ Output Enable Window */
+	u32 dq_end_oe = 7;
+	u32 phy_ctrl_reg_0_X =
+		CTL_53_ODT_DM_EN_EN | 0x40000000 | CTL_53_ODT_DM_DIS | CTL_53_EGC_CRT |
+		((rdd << CTL_53_RDD_OFFSET) & CTL_53_RDD_MASK) |
+		CTL_53_ENGTADJ_EN |
+		((dqs_start_oe << CTL_53_DQS_START_OE_OFFSET) & CTL_53_DQS_START_OE_MASK) |
+		0x00000800 |
+		((dqs_end_oe << CTL_53_DQS_END_OE_OFFSET) & CTL_53_DQS_END_OE_MASK) |
+		((dq_start_oe << CTL_53_DQ_START_OE_OFFSET) & CTL_53_DQ_START_OE_MASK) |
+		((dq_end_oe << CTL_53_DQ_END_OE_OFFSET) & CTL_53_DQ_END_OE_MASK);
+
+	/* ctl_57 - ctl_60 */
+	/* Dynamic On-Die Termination Enable Time */
+	u32 odt_ent = 0;
+	/* Dynamic On-Die Termination Disable Time */
+	u32 odt_dist = 7;
+	/* Dynamic On-Die Termination Enable */
+	u32 odt_en = 1;
+	/* Dynamic On-Die Termination Polarity of TSEL */
+	u32 odt_ptsel = 0;
+	/* Loopback LFSR to Error Checking Logic Delay */
+	u32 lpbklfsrecld = 0;
+	/* Read DQS Gate Close Configuration */
+	u32 dqs_gate_close_cfg = 0;
+	/* Stretch Trailing Edge of DFI Read Data Enable */
+	u32 strtregt = 3;
+	/* Read DQS Gate Opening */
+	u32 dqs_gate_open = 1;
+	u32 phy_ctrl_reg_1_X =
+		((odt_ent << CTL_57_ODT_ENT_OFFSET) & CTL_57_ODT_ENT_MASK) |
+		((odt_dist << CTL_57_ODT_DIST_OFFSET) & CTL_57_ODT_DIST_MASK) |
+		(odt_en ? CTL_57_ODT_EN_EN : 0) |
+		(odt_ptsel ? CTL_57_ODT_PTSEL_POS : 0) |
+		((lpbklfsrecld << CTL_57_LPBKLFSRECLD_OFFSET) & CTL_57_LPBKLFSRECLD_MASK) |
+		(dqs_gate_close_cfg ? CTL_57_DQS_GATE_CLOSE_CFG : 0) |
+		((strtregt << CTL_57_STRTREGT_OFFSET) & CTL_57_STRTREGT_MASK) |
+		((dqs_gate_open << CTL_57_DQS_GATE_OPEN_OFFSET) & CTL_57_DQS_GATE_OPEN_MASK);
+
+	/* ctl_61 */
+	/* DFI Read Data Valid to Enable Delay */
+	u32 dfirdvedly = 4;
+	u32 phy_ctrl_reg_2 =
+		((dfirdvedly << CTL_61_DFIRDVEDLY_OFFSET) & CTL_61_DFIRDVEDLY_MASK);
+
+
+	/* write values to the registers */
+	ddrdb_writel( 0,
+		(arefresh ? CTL0_AREFRESH : 0) |
+		(ap ? CTL0_AP : 0) |
+		(addr_cmp_en ? CTL0_ADDR_CMP_EN : 0) |
+		(active_aging ? CTL0_ACTIVE_AGING : 0) );
+
+	ddrdb_writel( 1,
+		(concurrentap ? CTL1_CONCURRENTAP : 0) |
+		(big_endian_en ? CTL1_BIG_ENDIAN_EN : 0) |
+		(bank_split_en ? CTL1_BANK_SPLIT_EN : 0) |
+		(auto_refresh_mode ? CTL1_AUTO_REFRESH_MODE : 0) );
+
+	ddrdb_writel( 2,
+		(drive_dq_dqs ? CTL2_DRIVE_DQ_DQS : 0) |
+		(dqs_n_en ? CTL2_DQS_N_EN : 0) |
+		(dll_bypass_mode ? CTL2_DLL_BYPASS_MODE : 0) );
+
+	ddrdb_writel( 3,
+		(intrptapburst ? CTL3_INTRPTAPBURST : 0) |
+		(fast_write ? CTL3_FAST_WRITE : 0) |
+		(enable_quick_srefresh ? CTL3_ENABLE_QUICK_SREFRESH : 0) |
+		(eight_bank_mode ? CTL3_EIGHT_BANK_MODE : 0) );
+
+	ddrdb_writel( 4,
+		(odt_add_turn_clk_en ? CTL4_ODT_ADD_TURN_CLK_EN : 0) |
+		(no_cmd_init ? CTL4_NO_CMD_INIT : 0) |
+		(intrptwritea ? CTL4_INTRPTWRITEA : 0) |
+		(intrptreada ? CTL4_INTRPTREADA : 0) );
+
+	ddrdb_writel( 5,
+		(priority_en ? CTL5_PRIORITY_EN : 0) |
+		(power_down ? CTL5_POWER_DOWN : 0) |
+		(placement_en ? CTL5_PLACEMENT_EN : 0) |
+		(odt_alt_en ? CTL5_ODT_ALT_EN : 0) );
+
+	ddrdb_writel( 6,
+		(rw_same_en ? CTL6_RW_SAME_EN : 0) |
+		(reg_dimm_enable ? CTL6_REG_DIMM_ENABLE : 0) |
+		(reduc ? CTL6_REDUC : 0) |
+		(pwrup_srefresh_exit ? CTL6_PWRUP_SREFRESH_EXIT : 0) );
+
+	ddrdb_writel( 7,
+		(tras_lockout ? CTL7_TRAS_LOCKOUT : 0) |
+		(swap_en ? CTL7_SWAP_EN : 0) |
+		(srefresh ? CTL7_SREFRESH : 0) );
+
+	ddrdb_writel( 8,
+		(((cs_map << CTL8_CS_MAP_OFFSET) & CTL8_CS_MAP_MASK) |
+		(writeinterp ? CTL8_WRITEINTERP : 0) |
+		(tref_enable ? CTL8_TREF_ENABLE : 0)) );
+
+	ddrdb_writel( 9,
+		((odt_rd_map_cs0 << CTL9_ODT_RD_MAP_CS0_OFFSET) & CTL9_ODT_RD_MAP_CS0_MASK) |
+		((lowpower_refresh_enable << CTL9_LOWPOWER_REFRESH_ENABLE_OFFSET) & CTL9_LOWPOWER_REFRESH_ENABLE_MASK) |
+		((dram_clk_disable << CTL9_DRAM_CLK_DISABLE_OFFSET) & CTL9_DRAM_CLK_DISABLE_MASK) );
+
+	ddrdb_writel(10,
+		(((rtt_0 << CTL_10_RTT_0_OFFSET) & CTL_10_RTT_0_MASK) |
+		((odt_wr_map_cs1 << CTL_10_ODT_WR_MAP_CS1_OFFSET) & CTL_10_ODT_WR_MAP_CS1_MASK) |
+		((odt_wr_map_cs0 << CTL_10_ODT_WR_MAP_CS0_OFFSET) & CTL_10_ODT_WR_MAP_CS0_MASK) |
+		((odt_rd_map_cs1 << CTL_10_ODT_RD_MAP_CS1_OFFSET) & CTL_10_ODT_RD_MAP_CS1_MASK)) );
+
+	ddrdb_writel(11,
+		(((col_size << CTL_11_COLUMN_SIZE_OFFSET) & CTL_11_COLUMN_SIZE_MASK) |
+		((cke_delay << CTL_11_CKE_DELAY_OFFSET) & CTL_11_CKE_DELAY_MASK) |
+		((cas_lat << CTL_11_CASLAT_OFFSET) & CTL_11_CASLAT_MASK) |
+		((addr_pins << CTL_11_ADDR_PINS_OFFSET) & CTL_11_ADDR_PINS_MASK)) );
+
+	ddrdb_writel(12,
+		(((tdfi_dram_clk_disable << CTL_12_TDFI_DRAM_CLK_DISABLE_OFFSET) & CTL_12_TDFI_DRAM_CLK_DISABLE_MASK) |
+		((tcke << CTL_12_TCKE_OFFSET) & CTL_12_TCKE_MASK) |
+		((q_fullness << CTL_12_Q_FULLNESS_OFFSET) & CTL_12_Q_FULLNESS_MASK)) );
+
+	ddrdb_writel(13,
+		(((w2r_samecs_dly << CTL_13_W2R_SAMECS_DLY_OFFSET) & CTL_13_W2R_SAMECS_DLY_MASK) |
+		((w2r_diffcs_dly << CTL_13_W2R_DIFFCS_DLY_OFFSET) & CTL_13_W2R_DIFFCS_DLY_MASK) |
+		((trtp << CTL_13_TRTP_OFFSET) & CTL_13_TRTP_MASK) |
+		((trrd << CTL_13_TRRD_OFFSET) & CTL_13_TRRD_MASK)) );
+
+	ddrdb_writel(14,
+		(((caslat_lin_gate << CTL_14_CASLAT_LIN_GATE_OFFSET) & CTL_14_CASLAT_LIN_GATE_MASK) |
+		((caslat_lin << CTL_14_CASLAT_LIN_OFFSET) & CTL_14_CASLAT_LIN_MASK) |
+		((aprebit << CTL_14_APREBIT_OFFSET) & CTL_14_APREBIT_MASK) |
+		((age_count << CTL_14_AGE_COUNT_OFFSET) & CTL_14_AGE_COUNT_MASK)) );
+
+	ddrdb_writel(15,
+		(((initaref << CTL_15_INITAREF_OFFSET) & CTL_15_INITAREF_MASK) |
+		((dram_class << CTL_15_DRAM_CLASS_OFFSET) & CTL_15_DRAM_CLASS_MASK) |
+		((command_age_count << CTL_15_COMMAND_AGE_COUNT_OFFSET) & CTL_15_COMMAND_AGE_COUNT_MASK)) );
+
+	ddrdb_writel(16,
+		(rdlat_adj << CTL_16_RDLAT_ADJ_OFFSET) & CTL_16_RDLAT_ADJ_MASK);
+
+	ddrdb_writel(17,
+		(((tdfi_phy_rdlat << CTL_17_TDFI_PHY_RDLAT_OFFSET) & CTL_17_TDFI_PHY_RDLAT_MASK) |
+		((tdfi_dram_clk_enable << CTL_17_TDFI_DRAM_CLK_ENABLE_OFFSET) & CTL_17_TDFI_DRAM_CLK_ENABLE_MASK) |
+		((tdfi_ctrl_delay << CTL_17_TDFI_CTRL_DELAY_OFFSET) & CTL_17_TDFI_CTRL_DELAY_MASK)) );
+
+	ddrdb_writel(18,
+		(((trp << CTL_18_TRP_OFFSET) & CTL_18_TRP_MASK) |
+		((tdfi_rddata_en_base << CTL_18_TDFI_RDDATA_EN_BASE_OFFSET) & CTL_18_TDFI_RDDATA_EN_BASE_MASK) |
+		((tdfi_phy_wrlat_base << CTL_18_TDFI_PHY_WRLAT_BASE_OFFSET) & CTL_18_TDFI_PHY_WRLAT_BASE_MASK)) );
+
+	ddrdb_writel(19,
+		(((lowpower_auto_enable << CTL_19_LOWPOWER_AUTO_ENABLE_OFFSET) & CTL_19_LOWPOWER_AUTO_ENABLE_MASK) |
+		((wrlat_adj << CTL_19_WRLAT_ADJ_OFFSET) & CTL_19_WRLAT_ADJ_MASK) |
+		((wrlat << CTL_19_WRLAT_OFFSET) & CTL_19_WRLAT_MASK) |
+		((twtr << CTL_19_TWTR_OFFSET) & CTL_19_TWTR_MASK)) );
+
+	ddrdb_writel(20,
+		(((tdal << CTL_20_TDAL_OFFSET) & CTL_20_TDAL_MASK) |
+		((ocd_adjust_pup_cs0 << CTL_20_OCD_ADJUST_PUP_CS_0_OFFSET) & CTL_20_OCD_ADJUST_PUP_CS_0_MASK) |
+		((ocd_adjust_pdn_cs0 << CTL_20_OCD_ADJUST_PDN_CS_0_OFFSET) & CTL_20_OCD_ADJUST_PDN_CS_0_MASK) |
+		((lowpower_control << CTL_20_LOWPOWER_CONTROL_OFFSET) & CTL_20_LOWPOWER_CONTROL_MASK)) );
+
+	ddrdb_writel(21,
+		(((twr_int << CTL_21_TWR_INT_OFFSET) & CTL_21_TWR_INT_MASK) |
+		((trc << CTL_21_TRC_OFFSET) & CTL_21_TRC_MASK) |
+		((tmrd << CTL_21_TMRD_OFFSET) & CTL_21_TMRD_MASK) |
+		((tfaw << CTL_21_TFAW_OFFSET) & CTL_21_TFAW_MASK)) );
+
+	ddrdb_writel(22, CTL_22_INT_ACK_MASK); /* reset status (int_mask and int_ack) */
+
+	ddrdb_writel(23,
+		(((tras_min <<CTL_23_TRAS_MIN_OFFSET) & CTL_23_TRAS_MIN_MASK) |
+		((tmod << CTL_23_TMOD_OFFSET) & CTL_23_TMOD_MASK) |
+		((dll_rst_adj_dly << CTL_23_DLL_RST_ADJ_DLY_OFFSET) & CTL_23_DLL_RST_ADJ_DLY_MASK)) );
+
+	ddrdb_writel(24,
+		(((emrs1 << CTL_24_EMRS1_DATA_0_OFFSET) & CTL_24_EMRS1_DATA_0_MASK) |
+		((trfc << CTL_24_TRFC_OFFSET) & CTL_24_TRFC_MASK) |
+		((trcd_int << CTL_24_TRCD_INT_OFFSET) & CTL_24_TRCD_INT_MASK)) );
+	ddrdb_writel(25,
+		(((emrs2 << CTL_25_EMRS2_DATA_0_OFFSET) & CTL_25_EMRS2_DATA_0_MASK) |
+		((emrs1 << CTL_25_EMRS1_DATA_1_OFFSET) & CTL_25_EMRS1_DATA_1_MASK)) );
+	ddrdb_writel(26,
+		(((emrs3 << CTL_26_EMRS3_DATA_0_OFFSET) & CTL_26_EMRS3_DATA_0_MASK) |
+		((emrs2 << CTL_26_EMRS2_DATA_1_OFFSET) & CTL_26_EMRS2_DATA_1_MASK)) );
+	ddrdb_writel(27,
+		(((mrs << CTL_27_MRS_DATA_0_OFFSET) & CTL_27_MRS_DATA_0_MASK) |
+		((emrs3 << CTL_27_EMRS3_DATA_1_OFFSET) & CTL_27_EMRS3_DATA_1_MASK)) );
+	ddrdb_writel(28,
+		((mrs << CTL_28_MRS_DATA_1_OFFSET) & CTL_28_MRS_DATA_1_MASK) );
+
+	/* readonly register: CTL_29 */
+
+	ddrdb_writel(30,
+		(((dll_rst_delay << CTL_30_DLL_RST_DELAY_OFFSET) & CTL_30_DLL_RST_DELAY_MASK) |
+		((tref << CTL_30_TREF_OFFSET) & CTL_30_TREF_MASK)) );
+	ddrdb_writel(31,
+		(((lowpower_internal_cnt << CTL_31_LOWPOWER_INTERNAL_CNT_OFFSET) & CTL_31_LOWPOWER_INTERNAL_CNT_MASK) |
+		((lowpower_external_cnt << CTL_31_LOWPOWER_EXTERNAL_CNT_OFFSET) & CTL_31_LOWPOWER_EXTERNAL_CNT_MASK)) );
+	ddrdb_writel(32,
+		(((lowpower_refresh_hold << CTL_32_LOWPOWER_REFRESH_HOLD_OFFSET) & CTL_32_LOWPOWER_REFRESH_HOLD_MASK) |
+		((lowpower_power_down_cnt << CTL_32_LOWPOWER_POWER_DOWN_CNT_OFFSET) & CTL_32_LOWPOWER_POWER_DOWN_CNT_MASK)) );
+	ddrdb_writel(33,
+		(((tcpd << CTL_33_TCPD_OFFSET) & CTL_33_TCPD_MASK) |
+		((lowpower_self_refresh_cnt << CTL_33_LOWPOWER_SELF_REFRESH_CNT_OFFSET) & CTL_33_LOWPOWER_SELF_REFRESH_CNT_MASK)) );
+	ddrdb_writel(34,
+		(((tpdex << CTL_34_TPDEX_OFFSET) & CTL_34_TPDEX_MASK) |
+		((tdll << CTL_34_TDLL_OFFSET) & CTL_34_TDLL_MASK)) );
+	ddrdb_writel(35,
+		(((txsnr << CTL_35_TXSNR_OFFSET) & CTL_35_TXSNR_MASK) |
+		((tras_max << CTL_35_TRAS_MAX_OFFSET) & CTL_35_TRAS_MAX_MASK)) );
+	ddrdb_writel(36,
+		((txsr << CTL_36_TXSR_OFFSET) & CTL_36_TXSR_MASK) );
+
+	ddrdb_writel(37, tinit);
+	ddrdb_writel(38, dft_ctrl_reg);
+	ddrdb_writel(39, dll_ctrl_reg_0_X);
+
+	ddrdb_writel(40, dll_ctrl_reg_0_X);
+	ddrdb_writel(41, dll_ctrl_reg_0_X);
+	ddrdb_writel(42, dll_ctrl_reg_0_X);
+	ddrdb_writel(43, dll_ctrl_reg_1_X);
+	ddrdb_writel(44, dll_ctrl_reg_1_X);
+	ddrdb_writel(45, dll_ctrl_reg_1_X);
+	ddrdb_writel(46, dll_ctrl_reg_1_X);
+
+	/* readonly registers: CTL_47 - CTL_51 */
+
+	ddrdb_writel(52, pad_ctrl_reg_0);
+	ddrdb_writel(53, phy_ctrl_reg_0_X);
+	ddrdb_writel(54, phy_ctrl_reg_0_X);
+	ddrdb_writel(55, phy_ctrl_reg_0_X);
+	ddrdb_writel(56, phy_ctrl_reg_0_X);
+	ddrdb_writel(57, phy_ctrl_reg_1_X);
+	ddrdb_writel(58, phy_ctrl_reg_1_X);
+	ddrdb_writel(59, phy_ctrl_reg_1_X);
+	ddrdb_writel(60, phy_ctrl_reg_1_X);
+
+	ddrdb_writel(61, phy_ctrl_reg_2);
+
+	/* readonly registers: CTL_62 and up */
+}
+
+phys_size_t falcon_ddr_init(void)
+{
+	u32 version;
+	phys_size_t size;
+	int n;
+
+	falcon_dcdc_ddr_init(1800);
+
+	/* need long delay after dcdc setup
+	   FIXME: check DCDC status?
+	*/
+	udelay(100000);
+	sys1_hw_activate_or_reboot(RBT_DDR);
+
+	version = ((ddrdb_readl(36) & CTL_36_VERSION_MASK) >>CTL_36_VERSION_OFFSET);
+	if (version != 0x2042) {
+		printf("ERROR: Unknown Denali-Controller version (0x%04X)\n", version);
+		return -1;
+	}
+
+	/* deactivate memory controller */
+	ddrdb_writel(7, 0);
+
+	setup_ddr_params(0);
+	ddr_init_exec();
+
+	/* go through supported memory configurations */
+	for (n = 0; n < ARRAY_SIZE(sdram_conf); n++) {
+		setup_geometry(sdram_conf[n].size, sdram_conf[n].rows,
+			sdram_conf[n].banks);
+
+		size = get_ram_size((long *)KSEG1ADDR(CONFIG_SYS_DDR_BASE), 
+				CONFIG_SYS_MAX_RAM);
+#ifdef DEBUG
+		puts("expected size:");
+		print_size (sdram_conf[n].size, "\n");
+
+		puts("found size:");
+		print_size (size, "\n");
+#endif
+		if (sdram_conf[n].size == size)
+			return size;
+	}
+	return 0;
+}
+
+static int ddrstatus(void)
+{
+	u32 reg, i;
+
+	puts("DDR Status:\n");
+
+	reg = ddrdb_readl(22);
+	ddrdb_writel(22, CTL_22_INT_ACK_MASK); /* reset status (int_mask and int_ack) */
+	if (reg & (0x40 << CTL_22_INT_STATUS_OFFSET)) {
+		puts("Interrupts:\n");
+		if (reg & (0x01 << CTL_22_INT_STATUS_OFFSET))
+			puts(" single access outside mem space\n");
+		if (reg & (0x02 << CTL_22_INT_STATUS_OFFSET))
+			puts(" multiple accesses outside mem space\n");
+		if (reg & (0x04 << CTL_22_INT_STATUS_OFFSET))
+			puts(" init complete\n");
+		if (reg & (0x08 << CTL_22_INT_STATUS_OFFSET))
+			puts(" CL3 with ODT detected (not supported!)\n");
+		if (reg & (0x10 << CTL_22_INT_STATUS_OFFSET))
+			puts(" read DQS gate error\n");
+		if (reg & (0x20 << CTL_22_INT_STATUS_OFFSET))
+			puts(" DLL unlock condition detected\n");
+	}
+
+#ifdef DEBUG
+#define MAX_SLICE	4
+#else
+#define MAX_SLICE	2
+#endif
+	for (i=0; i<MAX_SLICE; i++) {
+		reg = ddrdb_readl(47+i);
+		printf("Slice%d: DLL %slocked\n", i, (reg & 1) ? "" : "not ");
+	}
+
+	for (i=1; i<=5; i++) {
+		if (((ddrdb_readl(20) & CTL_20_LOWPOWER_CONTROL_MASK)
+		    >> CTL_20_LOWPOWER_CONTROL_OFFSET) & LOWPOWER_MODE2BITS(i)) {
+			reg = 0;
+			switch(i) {
+			case 1:
+			case 2:
+				reg = ((ddrdb_readl(32) & CTL_32_LOWPOWER_POWER_DOWN_CNT_MASK)
+					>> CTL_32_LOWPOWER_POWER_DOWN_CNT_OFFSET);
+				break;
+			case 3:
+				reg = ((ddrdb_readl(33) & CTL_33_LOWPOWER_SELF_REFRESH_CNT_MASK)
+					>> CTL_33_LOWPOWER_SELF_REFRESH_CNT_OFFSET);
+				break;
+			case 4:
+				reg = ((ddrdb_readl(31) & CTL_31_LOWPOWER_EXTERNAL_CNT_MASK)
+					>> CTL_31_LOWPOWER_EXTERNAL_CNT_OFFSET);
+				break;
+			}
+			printf("LowPower Mode %d active, enabled after %d clocks idle\n",
+				i, reg);
+		}
+	}
+	return 0;
+}
+
+
+static int do_ddrstatus( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ddrstatus();
+	return 0;
+}
+
+U_BOOT_CMD(
+	ddrstatus,	1,	0,	do_ddrstatus,
+	"show DDR Controller status",
+	""
+);
+
+static int do_ddrlp( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 mode, count, control_mask, lowpower_auto_enable;
+
+	/* need at least one arguments */
+	if (argc < 2)
+		goto usage;
+
+	mode = simple_strtoul(argv[1], NULL, 10);
+	control_mask = (1<<(5-mode));
+	lowpower_auto_enable = (ddrdb_readl(19) & CTL_19_LOWPOWER_AUTO_ENABLE_MASK)
+				>> CTL_19_LOWPOWER_AUTO_ENABLE_OFFSET;
+	if ((lowpower_auto_enable & control_mask) == 0)
+		goto usage;
+
+	if (argc > 2)
+		count = simple_strtoul(argv[2], NULL, 10);
+	else {
+		switch (mode) {
+		case 1:
+			count = DEFAULT_LOWPOWER_POWER_DOWN_CNT;
+			break;
+		case 3:
+		case 4:
+		default:
+			count = DEFAULT_LOWPOWER_SELF_REFRESH_CNT;
+			break;
+		}
+	}
+
+	if (count) {
+		switch (mode) {
+		case 1:
+			ddrdb_writel_mask(32,
+				CTL_32_LOWPOWER_POWER_DOWN_CNT_MASK,
+				((count << CTL_32_LOWPOWER_POWER_DOWN_CNT_OFFSET)
+					& CTL_32_LOWPOWER_POWER_DOWN_CNT_MASK));
+			break;
+		case 3:
+			ddrdb_writel_mask(33,
+				CTL_33_LOWPOWER_SELF_REFRESH_CNT_MASK,
+				((count << CTL_33_LOWPOWER_SELF_REFRESH_CNT_OFFSET)
+					& CTL_33_LOWPOWER_SELF_REFRESH_CNT_MASK));
+			break;
+		case 4:
+			ddrdb_writel_mask(31,
+				CTL_31_LOWPOWER_EXTERNAL_CNT_MASK,
+				((count << CTL_31_LOWPOWER_EXTERNAL_CNT_OFFSET)
+					& CTL_31_LOWPOWER_EXTERNAL_CNT_MASK));
+			break;
+		default:
+			break;
+		}
+		ddrdb_writel_mask(20, 0,
+			control_mask<<CTL_20_LOWPOWER_CONTROL_OFFSET);
+	} else {
+		ddrdb_writel_mask(20,
+			control_mask<<CTL_20_LOWPOWER_CONTROL_OFFSET, 0);
+	}
+	return 0;
+
+usage:
+	return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(
+	ddrlp,	3,	0,	do_ddrlp,
+	"config DDR LowPower",
+	"mode [count]\n"
+	"    mode = LowPower Mode (1 or 3)\n"
+	"    count = ticks from idle (count is decimal!!!)\n"
+	"            nothing for default value or 0 to switch mode off\n"
+);
+
+
+#if defined(DEBUG)
+static int do_ddrdump( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 i, start=0, end=61;
+
+	if (argc > 1) {
+		start = simple_strtoul(argv[1], NULL, 10);
+		end = start;
+	}
+
+	if (argc > 2)
+		end = simple_strtoul(argv[2], NULL, 10);
+
+	puts("DDR Register Dump:\n");
+	for (i=start; i<=end; i++) {
+#ifdef CONFIG_EMULATION
+		printf("CTL_%02d = 0x%08X\n", i, ddrdb_readl(i));
+#else
+		printf("CTL_%02d (@%08X) = 0x%08X\n",
+			i, (u32)(&(pDDRDB+i)->reg), ddrdb_readl(i));
+#endif
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	ddrdump,	3,	0,	do_ddrdump,
+	"dump DDR Controller registers",
+	"[start [end]]\n"
+);
+#endif
+
+#endif /* CONFIG_SYS_NO_DDR_INIT */
diff --git a/arch/mips/cpu/mips32/falcon/ebu_nand.c b/arch/mips/cpu/mips32/falcon/ebu_nand.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/ebu_nand.c
@@ -0,0 +1,134 @@
+/*
+ * (C) Copyright 2011
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+/* Register access macros */
+#define ebu_readl(reg)				\
+	readl(&ebu->reg)
+#define ebu_writel(reg,value)			\
+	writel((value), &ebu->reg)
+
+/* address lines used for NAND control signals */
+#define NAND_ADDR_ALE		(1<<16)
+#define NAND_ADDR_CLE		(1<<17)
+
+/*
+ *	hardware specific access to control-lines
+ */
+static void falcon_hwcontrol(struct mtd_info *mtd,
+				int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(NAND_ADDR_ALE | NAND_ADDR_CLE);
+
+		if (ctrl & NAND_CLE)
+			IO_ADDR_W |= NAND_ADDR_CLE;
+		if (ctrl & NAND_ALE)
+			IO_ADDR_W |= NAND_ADDR_ALE;
+
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+static int falcon_nand_ready(struct mtd_info *mtd)
+{
+	return (((ebu_readl(modcon) & (MODCON_STS|MODCON_STSEDGE)) ==
+		(MODCON_STS|MODCON_STSEDGE)));
+}
+
+int falcon_nand_init(struct nand_chip *nand)
+{
+	/* set EBU (cs 0) to NAND mode */
+	ebu_writel(busrcon0,
+		BUSRCON0_AGEN_NAND_FLASH |
+		BUSRCON0_PORTW_8_BIT_MUX |
+		BUSRCON1_NANDAMAP_NAND_A17_16);
+	ebu_writel(buswcon0,
+		BUSWCON0_AGEN_NAND_FLASH |
+		BUSWCON1_NANDAMAP_NAND_A17_16);
+
+	/* set EBU clock to 100 MHz */
+	sys1_w32_mask(0, EBUCC_EBUDIV_SELF100, ebucc);
+	/* FIXME: optimize these timings: */
+/*	const u32
+		addrc = 7,
+		adholc = 7,
+		cmddelay = 7,
+		extdata = (BUSRP0_EXTDATA_FOUR >> BUSRP0_EXTDATA_OFFSET),
+		extclock = (BUSRP0_EXTCLOCK_ONE_TO_THREE >> BUSRP0_EXTCLOCK_OFFSET),
+		datac = 7,
+		waitrdc = 7,
+		waitwdc = 7,
+		recovc = 3,
+		dtacs = 7;
+
+	ebu_writel(busrp0,
+		((addrc << BUSRP0_ADDRC_OFFSET) & BUSRP0_ADDRC_MASK) |
+		((adholc << BUSRP0_ADHOLC_OFFSET) & BUSRP0_ADHOLC_MASK) |
+		((cmddelay << BUSRP0_CMDDELAY_OFFSET) & BUSRP0_CMDDELAY_MASK) |
+		((extdata << BUSRP0_EXTDATA_OFFSET) & BUSRP0_EXTDATA_MASK) |
+		((extclock << BUSRP0_EXTCLOCK_OFFSET) & BUSRP0_EXTCLOCK_MASK) |
+		((datac << BUSRP0_DATAC_OFFSET) & BUSRP0_DATAC_MASK) |
+		((waitrdc << BUSRP0_WAITRDC_OFFSET) & BUSRP0_WAITRDC_MASK) |
+		((recovc << BUSRP0_RECOVC_OFFSET) & BUSRP0_RECOVC_MASK) |
+		((dtacs << BUSRP0_DTACS_OFFSET) & BUSRP0_DTACS_MASK) );
+	ebu_writel(buswp0,
+		((addrc << BUSWP0_ADDRC_OFFSET) & BUSWP0_ADDRC_MASK) |
+		((adholc << BUSWP0_ADHOLC_OFFSET) & BUSWP0_ADHOLC_MASK) |
+		((cmddelay << BUSWP0_CMDDELAY_OFFSET) & BUSWP0_CMDDELAY_MASK) |
+		((extdata << BUSWP0_EXTDATA_OFFSET) & BUSWP0_EXTDATA_MASK) |
+		((extclock << BUSWP0_EXTCLOCK_OFFSET) & BUSWP0_EXTCLOCK_MASK) |
+		((datac << BUSWP0_DATAC_OFFSET) & BUSWP0_DATAC_MASK) |
+		((waitwdc << BUSWP0_WAITWDC_OFFSET) & BUSWP0_WAITWDC_MASK) |
+		((recovc << BUSWP0_RECOVC_OFFSET) & BUSWP0_RECOVC_MASK) |
+		((dtacs << BUSWP0_DTACS_OFFSET) & BUSWP0_DTACS_MASK) );
+*/
+	/* Set address of hardware control function */
+	nand->cmd_ctrl = falcon_hwcontrol;
+	nand->dev_ready = falcon_nand_ready;
+	nand->options = NAND_USE_FLASH_BBT;
+	nand->ecc.mode = NAND_ECC_SOFT;
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * Main initialization routine
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	return falcon_nand_init(nand);
+}
diff --git a/arch/mips/cpu/mips32/falcon/ebu_nor.c b/arch/mips/cpu/mips32/falcon/ebu_nor.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/ebu_nor.c
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2011
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+
+#include <asm/io.h>
+
+static inline void *flash_fixup_addr(void *addr)
+{
+	void *fix_addr = ((void *)((ulong) (addr) ^ 2));
+	return fix_addr;
+}
+
+/*
+ * Accessor functions replacing the "weak" functions in
+ * drivers/mtd/cfi_flash.c
+ */
+void flash_write8(u8 value, void *addr)
+{
+	__raw_writeb(value, flash_fixup_addr(addr));
+}
+void flash_write8_data(u8 value, void *addr)
+{
+	__raw_writeb(value, addr);
+}
+void flash_write16(u16 value, void *addr)
+{
+	__raw_writew(value, flash_fixup_addr(addr));
+}
+void flash_write16_data(u16 value, void *addr)
+{
+	__raw_writew(value, addr);
+}
+u8 flash_read8(void *addr)
+{
+	return __raw_readb(flash_fixup_addr(addr));
+}
+u8 flash_read8_data(void *addr)
+{
+	return __raw_readb(addr);
+}
+u16 flash_read16(void *addr)
+{
+	return __raw_readw(flash_fixup_addr(addr));
+}
+u16 flash_read16_data(void *addr)
+{
+	return __raw_readw(addr);
+}
diff --git a/arch/mips/cpu/mips32/falcon/ebu_spi.c b/arch/mips/cpu/mips32/falcon/ebu_spi.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/ebu_spi.c
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2011
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+/* Register access macros */
+
+#if 1
+#define ebu_readl(reg)				\
+	readl(&ebu->reg)
+#define ebu_writel(reg,value)			\
+	writel((value), &ebu->reg)
+#else
+static inline u32 ebu_readreg(const char* name, u32 *addr)
+{
+	u32 val;
+	debug("%s > ", name);
+	val = readl(addr);
+	debug("0x%08X\n", val);
+	return val;
+}
+#define ebu_readl(reg)				\
+	ebu_readreg(#reg, &ebu->reg)
+static inline void ebu_writereg(const char* name, u32 val, u32 *addr)
+{
+	debug("%s < 0x%08X\n", name, val);
+	writel(val, addr);
+}
+#define ebu_writel(reg,value)			\
+	ebu_writereg(#reg, (value), &ebu->reg)
+#endif
+#define ebu_maskl(reg,clear,set) ebu_writel(reg,(ebu_readl(reg)& ~(clear))|(set))
+
+struct ebu_spi_slave {
+	struct spi_slave slave;	/* must be first!!! */
+	u32 sfcmd;	/* for caching of opcode, direction, ... */
+};
+#define to_ebu_spi_slave(s) container_of(s, struct ebu_spi_slave, slave)
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct ebu_spi_slave *ebuspi;
+	const u32 ebuclk = 100*1000*1000;
+	unsigned int i;
+
+	debug("spi_setup_slave: slave %u:%u max_hz %d mode %d\n",
+		bus, cs, max_hz, mode);
+
+	if ((bus>0) || (cs>0))
+		return NULL;
+
+	ebuspi = malloc(sizeof(struct ebu_spi_slave));
+	if (!ebuspi)
+		return NULL;
+
+	ebuspi->slave.bus = bus;
+	ebuspi->slave.cs = cs;
+
+	if (ebuclk < max_hz) {
+		/* set EBU clock to 100 MHz */
+		sys1_w32_mask(0, EBUCC_EBUDIV_SELF100, ebucc);
+		i = 1; /* divider */
+	} else {
+		/* set EBU clock to 50 MHz */
+		sys1_w32_mask(EBUCC_EBUDIV_SELF100, 0, ebucc);
+
+		/* search for suitable divider */
+		for (i=1; i<7; i++) {
+			if (ebuclk/i <= max_hz)
+				break;
+		}
+	}
+	/* setup period of serial clock */
+	ebu_maskl(sftime,
+		SFTIME_SCKF_POS_MASK | SFTIME_SCKR_POS_MASK | SFTIME_SCK_PER_MASK,
+		(i<<SFTIME_SCKR_POS_OFFSET) | (i<<(SFTIME_SCK_PER_OFFSET+1)));
+
+	/* set some bits of unused_wd, to not trigger HOLD/WP signals on non QUAD flashes */
+	ebu_writel(sfio, (SFIO_UNUSED_WD_MASK & (0x8|0x4)));
+
+	return &ebuspi->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	free(slave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct ebu_spi_slave *ebuspi = to_ebu_spi_slave(slave);
+	ebu_writel(busrcon0, BUSRCON0_AGEN_SERIAL_FLASH | BUSRCON0_PORTW_8_BIT_MUX);
+	ebu_writel(buswcon0, BUSWCON0_AGEN_SERIAL_FLASH);
+	/* set address wrap around to maximum for 24-bit addresses */
+	ebu_maskl(sfcon,
+		SFCON_DEV_SIZE_MASK,
+		SFCON_DEV_SIZE_A23_0);
+	ebuspi->sfcmd = 0;
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+}
+
+enum states_e {
+	state_init,
+	state_command_prepare,
+	state_write,
+	state_read,
+	state_disable_cs,
+	state_end
+};
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct ebu_spi_slave *ebuspi = to_ebu_spi_slave(slave);
+	const u8 *txp = dout;
+	u8 *rxp = din;
+	unsigned int bytelen = ((bitlen + 7) / 8);
+	unsigned int len, alen, dumlen;
+	u32 val;
+	enum states_e state = state_init;
+
+#if 0
+	debug("spi_xfer: slave %u:%u dout %p din %p bytelen %d/0x%X %s%s\n",
+		ebuspi->slave.bus, ebuspi->slave.cs, dout, din, bytelen, bytelen,
+		(flags & SPI_XFER_BEGIN)?" BEGIN":"", (flags & SPI_XFER_END)?" END":"");
+#endif
+
+	do {
+		switch (state) {
+		case state_init: /* detect phase of upper layer sequence */
+		{
+			/* initial write ? */
+			if (flags & SPI_XFER_BEGIN) {
+				if (!txp) {
+					printf("SPI Error: BEGIN without tx data!\n");
+					return -1;
+				}
+				/*
+				 * Prepare the parts of the sfcmd register, which should not
+				 * change during a sequence!
+				 * Only exception are the length fields, especially alen and dumlen.
+				 */
+				ebuspi->sfcmd = ((ebuspi->slave.cs << SFCMD_CS_OFFSET) & SFCMD_CS_MASK);
+				ebuspi->sfcmd |= SFCMD_KEEP_CS_KEEP_SELECTED;
+				ebuspi->sfcmd |= *txp;
+				txp++;
+				bytelen--;
+				if (bytelen) {
+					/* more data: maybe address and/or dummy */
+					state = state_command_prepare;
+					break;
+				} else {
+					debug("SPI: write cmd %02X\n",
+						ebuspi->sfcmd & SFCMD_OPC_MASK);
+				}
+			}
+			/* continued write ? */
+			if (txp && bytelen) {
+				state = state_write;
+				break;
+			}
+			/* read data? */
+			if (rxp && bytelen) {
+				state = state_read;
+				break;
+			}
+			/* end of sequence? */
+			if (flags & SPI_XFER_END)
+				state = state_disable_cs;
+			else
+				state = state_end;
+			break;
+		}
+		case state_command_prepare: /* collect tx data for address and dummy phase */
+		{
+			/* txp is valid, already checked */
+			val = 0;
+			alen = 0;
+			dumlen = 0;
+			while (bytelen > 0) {
+				if (alen < 3) {
+					val = (val<<8)|(*txp++);
+					alen++;
+				} else if ((dumlen < 15) && (*txp == 0)) {
+					/*
+					 * assume dummy bytes are set to 0
+					 * from upper layer
+					 */
+					dumlen++;
+					txp++;
+				} else
+					break;
+				bytelen--;
+			}
+			ebuspi->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);
+			ebuspi->sfcmd |= (alen << SFCMD_ALEN_OFFSET) |
+					 (dumlen << SFCMD_DUMLEN_OFFSET);
+			if (alen > 0)
+				ebu_writel(sfaddr, val);
+			debug("SPI: write cmd %02X, alen=%d (addr=%06X) dumlen=%d\n",
+				ebuspi->sfcmd & SFCMD_OPC_MASK, alen, val, dumlen);
+			if (bytelen > 0) {
+				/* continue with write */
+				state = state_write;
+			} else if (flags & SPI_XFER_END) {
+				/* end of sequence? */
+				state = state_disable_cs;
+			} else {
+				/* go to end and expect another call (read or write) */
+				state = state_end;
+			}
+			break;
+		}
+		case state_write:
+		{
+			/* txp still valid */
+			ebuspi->sfcmd |= SFCMD_DIR_WRITE;
+			len = 0;
+			val = 0;
+			do {
+				if (bytelen--)
+					val |= (*txp++)<<(8*len++);
+				if ((flags & SPI_XFER_END) && (bytelen==0)) {
+					//debug("disable CS\n");
+					ebuspi->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;
+				}
+				if ((len==4) || (bytelen==0)) {
+					ebu_writel(sfdata, val);
+					ebu_writel(sfcmd, ebuspi->sfcmd | (len<<SFCMD_DLEN_OFFSET));
+					len = 0;
+					val = 0;
+					ebuspi->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);
+				}
+			} while (bytelen);
+			state = state_end;
+			break;
+		}
+		case state_read:
+		{
+			/* read data */
+			ebuspi->sfcmd &= ~SFCMD_DIR_WRITE;
+			do {
+				if ((flags & SPI_XFER_END) && (bytelen<=4)) {
+					//debug("disable CS\n");
+					ebuspi->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;
+				}
+				len = (bytelen>4) ? 4 : bytelen;
+				bytelen -= len;
+				ebu_writel(sfcmd, ebuspi->sfcmd | (len<<SFCMD_DLEN_OFFSET));
+				ebuspi->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);
+				do {
+					val = ebu_readl(sfstat);
+					if (val & SFSTAT_CMD_ERR) {
+						/* reset error status */
+						debug("SFSTAT: CMD_ERR (%x)\n", val);
+						ebu_writel(sfstat, SFSTAT_CMD_ERR);
+						return -1;
+					}
+				} while (val & SFSTAT_CMD_PEND);
+				val = ebu_readl(sfdata);
+				do {
+					*rxp = (val & 0xFF);
+					rxp++;
+					val >>= 8;
+					len--;
+				} while (len);
+			} while (bytelen);
+			state = state_end;
+			break;
+		}
+		case state_disable_cs:
+		{
+			//debug("disable CS\n");
+			ebuspi->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;
+			ebu_writel(sfcmd, ebuspi->sfcmd | (0<<SFCMD_DLEN_OFFSET));
+			val = ebu_readl(sfstat);
+			if (val & SFSTAT_CMD_ERR) {
+				/* reset error status */
+				printf("SFSTAT: CMD_ERR (%x)\n", val);
+				ebu_writel(sfstat, SFSTAT_CMD_ERR);
+				return -1;
+			}
+			state = state_end;
+			break;
+		}
+		case state_end:
+			break;
+		}
+	} while (state != state_end);
+
+	return 0;
+}
diff --git a/arch/mips/cpu/mips32/falcon/gpio.c b/arch/mips/cpu/mips32/falcon/gpio.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/gpio.c
@@ -0,0 +1,206 @@
+/*
+ * (C) Copyright 2011
+ * Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch-falcon/sysctrl.h>
+
+#define gpio_r32(reg)			__raw_readl(reg)
+#define gpio_w32(val, reg)		__raw_writel(val, reg)
+#define gpio_w32_mask(clear, set, reg)	gpio_w32((gpio_r32(reg) & ~(clear)) | (set), reg)
+
+/** register structure for padctrl
+    (mainly needed for mux control) */
+struct gpon_padctrl
+{
+	/** Multiplexer Control Register
+	    The value 0 (the reset-value) is always the default function corresponding to the pad's name. The value 1 selects always the GPIO functionality (if available). */
+	unsigned int muxc[32];
+	/** Pull Up Enable Register */
+	unsigned int puen; /* 0x00000080 */
+	/** Pull Down Enable Register */
+	unsigned int pden; /* 0x00000084 */
+	/** Slew Rate Control Register */
+	unsigned int src; /* 0x00000088 */
+	/** Drive Current Control Register */
+	unsigned int dcc; /* 0x0000008C */
+	/** Reserved */
+	unsigned int res_0[24]; /* 0x00000090 */
+	/** Pad Control Availability Register */
+	unsigned int avail; /* 0x000000F0 */
+};
+
+/** register structure for gpio port */
+struct gpon_port
+{
+	/** Data Output Register
+	    Via this register the output values of the different bits can be set if they are switched as outputs. */
+	unsigned int out; /* 0x00000000 */
+	/** Data Input Register
+	    Via this register the input values of the different bits can be observed. */
+	unsigned int in; /* 0x00000004 */
+	/** Direction Register
+	    Via this register the input direction of the different bits can be determined. */
+	unsigned int dir; /* 0x00000008 */
+	/** Reserved */
+	unsigned int res_0[3]; /* 0x0000000C */
+	/** External Interrupt Control Register 0 */
+	unsigned int exintcr0; /* 0x00000018 */
+	/** External Interrupt Control Register 1 */
+	unsigned int exintcr1; /* 0x0000001C */
+	/** IRN Capture Register
+	    This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+	unsigned int irncr; /* 0x00000020 */
+	/** IRN Interrupt Control Register
+	    A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+	unsigned int irnicr; /* 0x00000024 */
+	/** IRN Interrupt Enable Register
+	    This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+	unsigned int irnen; /* 0x00000028 */
+	/** IRN Interrupt Configuration Register
+	    Configures the interrupts bitwise to be edge-senstivie or level-sensitive. */
+	unsigned int irncfg; /* 0x0000002C */
+	/** IRN Interrupt Enable Set Register
+	    The corresponding bit in the IRNEN register can be set with an atomic access. */
+	unsigned int irnenset; /* 0x00000030 */
+	/** IRN Interrupt Enable Clear Register
+	    The corresponding bit in the IRNEN register can be cleared with an atomic access. */
+	unsigned int irnenclr; /* 0x00000034 */
+	/** Reserved */
+	unsigned int res_1[2]; /* 0x00000038 */
+	/** Output Set Register
+	    This register can be used to set certain bits within the OUT register without touching the other bits. */
+	unsigned int outset; /* 0x00000040 */
+	/** Output Clear Register
+	    This register can be used to clear certain bits within the OUT register without touching the other bits. */
+	unsigned int outclr; /* 0x00000044 */
+	/** Direction Set Register
+	    This register can be used to set certain bits within the DIR register without touching the other bits. */
+	unsigned int dirset; /* 0x00000048 */
+	/** Direction Clear Register
+	    This register can be used to clear certain bits within the DIR register without touching the other bits. */
+	unsigned int dirclr; /* 0x0000004C */
+};
+
+struct falcon_gpio_port {
+	struct gpon_padctrl *pad;
+	struct gpon_port *port;
+};
+
+static const struct falcon_gpio_port gpio_ports[] = {
+	{ (struct gpon_padctrl *)GPON_PADCTRL0_BASE,
+	  (struct gpon_port *)GPON_GPIO0_BASE },
+	{ (struct gpon_padctrl *)GPON_PADCTRL1_BASE,
+	  (struct gpon_port *)GPON_GPIO1_BASE },
+	{ (struct gpon_padctrl *)GPON_PADCTRL2_BASE,
+	  (struct gpon_port *)GPON_GPIO2_BASE },
+};
+
+static void gpio_init(unsigned int gpio)
+{
+	switch (gpio/100)
+	{
+	case 0:
+		sys_eth_hw_activate(SYS_ETH_ACTS_PADCTRL0 | SYS_ETH_ACTS_P0);
+		break;
+	case 1:
+		sys1_hw_activate(ACTS_PADCTRL1 | ACTS_P1);
+		break;
+	case 2:
+		sys_eth_hw_activate(SYS_ETH_ACTS_PADCTRL2 | SYS_ETH_ACTS_P2);
+		break;
+	default:
+		return;
+	}
+}
+
+static inline const struct falcon_gpio_port *to_falcon_gpio_port(unsigned int gpio)
+{
+	return &gpio_ports[gpio/100];
+}
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	const struct falcon_gpio_port *gpio_port = to_falcon_gpio_port(gpio);
+	int offset = gpio % 100;
+
+	(void)label;
+
+	if ( ((gpio%100) >= 32) || (gpio/100)>= ARRAY_SIZE(gpio_ports))
+		return -1;
+
+	/* call init everytime (no side effect and only little overhead) */
+	gpio_init(gpio);
+
+	if ((gpio_r32(&gpio_port->pad->avail) >> offset) & 1) {
+		if (gpio_r32(&gpio_port->pad->muxc[offset]) > 1)
+			return -1;
+		/* switch on gpio function */
+		gpio_w32(1, &gpio_port->pad->muxc[offset]);
+		debug("gpio_request %d for %s: SUCCESS!\n", gpio, label);
+		return 0;
+	}
+
+	return -2;
+}
+
+void gpio_free(unsigned gpio)
+{
+}
+
+int gpio_direction_input(unsigned int gpio)
+{
+	const struct falcon_gpio_port *gpio_port = to_falcon_gpio_port(gpio);
+	int offset = gpio % 100;
+
+	gpio_w32(1<<offset, &gpio_port->port->dirclr);
+	return 0;
+}
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	const struct falcon_gpio_port *gpio_port = to_falcon_gpio_port(gpio);
+	int offset = gpio % 100;
+
+	gpio_set_value(gpio, value);
+	gpio_w32(1<<offset, &gpio_port->port->dirset);
+	return 0;
+}
+
+int gpio_get_value(unsigned int gpio)
+{
+	const struct falcon_gpio_port *gpio_port = to_falcon_gpio_port(gpio);
+	int offset = gpio % 100;
+
+	return (gpio_r32(&gpio_port->port->in) >> offset) & 1;
+}
+
+void gpio_set_value(unsigned int gpio, int value)
+{
+	const struct falcon_gpio_port *gpio_port = to_falcon_gpio_port(gpio);
+	int offset = gpio % 100;
+
+	if (value)
+		gpio_w32(1<<offset, &gpio_port->port->outset);
+	else
+		gpio_w32(1<<offset, &gpio_port->port->outclr);
+}
diff --git a/arch/mips/cpu/mips32/falcon/misc.c b/arch/mips/cpu/mips32/falcon/misc.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/misc.c
@@ -0,0 +1,321 @@
+/*
+ * (C) Copyright 2011
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * based on board/tqc/tqm8xx/load_sernum_ethaddr.c
+ * (C) Copyright 2000, 2001, 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*#define DEBUG*/
+#include <common.h>
+#include <net.h>
+#include <asm/io.h>
+#include <asm/falcon.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/sysctrl.h>
+#include <asm/gpio.h>
+
+#define DEFAULT_MAC { 0xAC, 0x9A, 0x96, 0xFF, 0xFF, 0xFF }
+
+void load_default_ethaddr(void)
+{
+	u8 ethaddr[6] = DEFAULT_MAC;
+	u32 chiploc;
+
+	/* set ethaddr if not yet defined */
+	if (getenv("ethaddr") == NULL) {
+		chiploc = status_r32(chiploc);
+		ethaddr[3] = chiploc>>16 & 0xFF;
+		ethaddr[4] = chiploc>>8 & 0xFF;
+		ethaddr[5] = chiploc>>0 & 0xFF;
+
+		eth_setenv_enetaddr("ethaddr", ethaddr);
+	}
+}
+
+void print_chip_info(void)
+{
+	char buf[32];
+	u32 chipid, chipid_partnr, chipid_version;
+	u32 config, config_subvers;
+	u32 fuse0_f0;
+	u32 bootmode = sys1_r32(bmc) & BMC_BM_MASK;
+	u32 cause;
+
+	chipid = status_r32(chipid);
+	if ((chipid & STATUS_CHIPID_CONST1) != STATUS_CHIPID_CONST1)
+		printf("ChipID invalid??? val=0x%08X\n", chipid);
+	else {
+		chipid_partnr = (chipid & STATUS_CHIPID_PARTNR_MASK)
+			>> STATUS_CHIPID_PARTNR_OFFSET;
+		chipid_version = (chipid & STATUS_CHIPID_VERSION_MASK)
+			>> STATUS_CHIPID_VERSION_OFFSET;
+		config = status_r32(config);
+		config_subvers = (config & STATUS_CONFIG_SUBVERS_MASK)
+			>> STATUS_CONFIG_SUBVERS_OFFSET;
+		fuse0_f0 = status_r32(fuse0) & STATUS_FUSE0_F0_MASK;
+
+		puts("Chip:  ");
+		if (chipid_partnr != 0x01B8) {
+			printf("UNKNOWN Chipid 0x%08X", chipid);
+		} else {
+			char *type = &buf[0];
+			if (is_falcon_d())
+				type = "D";
+			else if (is_falcon_v())
+				type = "V";
+			else if (is_falcon_m())
+				type = "M";
+			else if (is_falcon_s())
+				type = "S";
+			else
+				sprintf(buf, "?(f0=%X)",
+					fuse0_f0 >> STATUS_FUSE0_F0_OFFSET);
+
+			printf("FALCON-%s (%c%d%d)\n",
+				type, 'A'+(config_subvers>>2),
+				chipid_version, (config_subvers & 3)+1);
+		}
+	}
+	printf("Bootmode: 0x%02X\n", bootmode);
+
+	if (is_falcon_chip_a1x())
+		cause = sys1_r32(cpu0rs) & 0x03;
+	else
+		cause = sys1_r32(cpu0rs) & CPU0RS_HWRS_MASK;
+	puts("Reset cause: ");
+	switch (cause) {
+	case CPU0RS_HWRS_POR:
+		puts("Power-On Reset\n");
+		break;
+	case CPU0RS_HWRS_RST:
+		puts("RST Pin\n");
+		break;
+	case CPU0RS_HWRS_WDT:
+		if ((boot_reg->magic0 == 0x4C545100) && 
+		    (boot_reg->magic1 == 0x0051544C)) {
+			puts("Software\n");
+		} else
+			puts("Watchdog\n");
+		break;
+	case CPU0RS_HWRS_OLT:
+		puts("PLOAM message\n");
+		break;
+	case CPU0RS_HWRS_SYS1:
+		puts("Software via SYS1\n");
+		break;
+	default:
+		puts("Unknown!\n");
+		break;
+	}
+	/* reset magics and reset/nmi/ejtag vectors */
+	boot_reg->magic0 = 0;
+	boot_reg->magic1 = 0;
+	boot_reg->rvec = 0;
+	boot_reg->nvec = 0;
+	boot_reg->evec = 0;
+
+	printf("CPU Clock: %s MHz\n", strmhz(buf, get_cpuclk()));
+}
+
+#define DEFAULT_TEMPMM		0
+#define DEFAULT_TBGP		4
+#define DEFAULT_VBGP		4
+#define DEFAULT_IREFBGP		8
+#define DEFAULT_GAINDRIVEDAC	8
+#define DEFAULT_GAINBIASDAC	8
+
+#define PRINT_FUSE(f) debug("status %7s 0x%08X\n", #f, f)
+
+/* check and initialize some fuse status registers */
+static void falcon_fuse_init(void)
+{
+	u32 fuse0, fuse1, analog, config, chiploc;
+	u32 format;
+
+	/* disable "soft fuse control" (SFC) to read real fuse values */
+	status_w32_mask(STATUS_FUSE0_SFC_SEL, 0, fuse0);
+
+	fuse0 = status_r32(fuse0);
+	fuse1 = status_r32(fuse1);
+	analog = status_r32(analog);
+	config = status_r32(config);
+	chiploc = status_r32(chiploc);
+
+	format = ((analog & STATUS_ANALOG_FS_MASK) >> STATUS_ANALOG_FS_OFFSET);
+
+	debug("fuse format %d\n", format);
+	PRINT_FUSE(fuse0);
+	PRINT_FUSE(fuse1);
+	PRINT_FUSE(analog);
+	PRINT_FUSE(config);
+	PRINT_FUSE(chiploc);
+
+	/* activate SFC */
+	fuse0 |= STATUS_FUSE0_SFC_SEL;
+	if ((fuse0 & STATUS_FUSE0_RCALMM_MASK) == 0)
+		fuse0 |= 0x80;
+	if ((fuse0 & STATUS_FUSE0_VCALMM400_MASK) == 0)
+		fuse0 |= (0x20 << STATUS_FUSE0_VCALMM400_OFFSET);
+	if ((fuse0 & STATUS_FUSE0_VCALMM100_MASK) == 0)
+		fuse0 |= (0x20 << STATUS_FUSE0_VCALMM100_OFFSET);
+	if ((fuse0 & STATUS_FUSE0_VCALMM20_MASK) == 0)
+		fuse0 |= (0x20 << STATUS_FUSE0_VCALMM20_OFFSET);
+
+	if ((fuse1 & ~STATUS_FUSE1_F1_MASK) == 0)
+		fuse1 |= 0x00000020;
+
+	switch (format) {
+	case 0:
+		/* no valid values for format "0", set defaults and format "1"*/
+		analog = STATUS_ANALOG_FS_FS1;
+		analog |= (DEFAULT_GAINBIASDAC <<
+					STATUS_ANALOG_GAINBIASDAC_OFFSET);
+		analog |= (DEFAULT_GAINDRIVEDAC <<
+					STATUS_ANALOG_GAINDRIVEDAC_OFFSET);
+		analog |= (DEFAULT_IREFBGP << STATUS_ANALOG_IREFBGP_OFFSET);
+		analog |= (DEFAULT_VBGP << STATUS_ANALOG_VBGP_OFFSET);
+		analog |= (DEFAULT_TBGP << STATUS_ANALOG_TBGP_OFFSET);
+		analog |= (DEFAULT_TEMPMM << STATUS_ANALOG_TEMPMM_OFFSET);
+		fuse0 = (fuse0 & ~STATUS_FUSE0_F0_MASK) | 0x04000000;
+		break;
+	case 1: 
+		{
+			uint8_t offset_fuse;
+			int8_t offset;
+
+			offset_fuse = (fuse1 & STATUS_FUSE1_OFFSET1V0DCDC_MASK)
+				>> STATUS_FUSE1_OFFSET1V0DCDC_OFFSET;
+			/* let the cpu convert the 5bit signed value */
+			offset = (int8_t)(offset_fuse<<3) / 8;
+
+			/* ignore all negative values, set to 0 */
+			if (offset < 0)
+				fuse1 &= ~STATUS_FUSE1_OFFSET1V0DCDC_MASK;
+		}
+		break;
+	default:
+		break;
+	}
+
+	debug("\nupdated fuses\n");
+	PRINT_FUSE(fuse0);
+	PRINT_FUSE(fuse1);
+	PRINT_FUSE(analog);
+	PRINT_FUSE(config);
+	PRINT_FUSE(chiploc);
+
+	status_w32(fuse0, fuse0);
+	status_w32(fuse1, fuse1);
+	status_w32(analog, analog);
+	/*
+	 * we also need to write the following registers, even if not modified,
+	 * otherwise they have wrong contents with SFC activated (SHA1EN and
+	 * AESEN cannot be written, so we will not see the real status here
+	 * with SFC, but these hw-blocks are directly connected to the fuses)
+	 */
+	status_w32(config, config);
+	status_w32(chiploc, chiploc);
+}
+
+void falcon_early_init_f(void)
+{
+#ifdef CONFIG_USE_ASC0
+	#define ACTS_ASC ACTS_ASC0
+#else
+	#define ACTS_ASC ACTS_ASC1
+#endif
+	/* activate some basic hardware modules */
+	sys1_hw_activate(ACTS_ASC | ACTS_STATUS | ACTS_EBU);
+	falcon_fuse_init();
+	if (is_falcon_chip_a1x())
+		falcon_dcdc_core_init(1050);
+	else
+		falcon_dcdc_core_init(1000);
+	/*
+	 * clear unconditional all pending NMIs,
+	 * otherwise the cpu reset will not work
+	 */
+	sys1_w32(sys1_r32(nmis), nmiclr);
+}
+
+void falcon_misc_init_r(void)
+{
+	long m, n;
+	char *s = getenv("dcdc_core_voltage");
+	if (s) {
+		long voltage = simple_strtoul(s, NULL, 10);
+		n = DIV_ROUND(voltage, 1000);
+		m = voltage-n*1000L;
+		if ((voltage <= 950) || (voltage > 1150)) {
+			printf("Invalid value for core voltage %ld.%03ldV\n",
+				n, m);
+		} else {
+			printf("Change core voltage to %ld.%03ldV\n",
+				n, m);
+			falcon_dcdc_core_set_voltage(voltage);
+		}
+	}
+}
+
+void falcon_extphy_enable(int enable)
+{
+	gpio_request(3, "phy reset");
+
+	if (enable) {
+		gpio_direction_output(3, 0);
+		/* enable 25 MHz clock for external Phys */
+		sys_eth_w32_mask(SYS_ETH_EXTPHYC_CLKSEL_MASK,
+			SYS_ETH_EXTPHYC_CLKEN_EN | SYS_ETH_EXTPHYC_CLKSEL_F25,
+			extphyc);
+		udelay(10);
+
+		/* remove reset to external Phy module */
+		gpio_set_value(3, 1);
+	} else {
+		/* disable clock output */
+		sys_eth_w32_mask(SYS_ETH_EXTPHYC_CLKEN_EN, 0, extphyc);
+
+		/* activate reset to external Phy module */
+		gpio_direction_output(3, 0);
+	}
+}
+
+static int do_extphy( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1],"en") >= 0x0) {
+		printf("Enable external phy clock, remove reset\n");
+		falcon_extphy_enable(1);
+	} else if (strcmp(argv[1],"dis") >= 0x0) {
+		printf("Disable external phy clock, activate reset\n");
+		falcon_extphy_enable(0);
+	} else {
+		return cmd_usage(cmdtp);
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	extphy,	2,	0,	do_extphy,
+	"external PHY enable (clock and reset)",
+	"en[able]/dis[able]"
+);
diff --git a/arch/mips/cpu/mips32/falcon/speed.c b/arch/mips/cpu/mips32/falcon/speed.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/speed.c
@@ -0,0 +1,62 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Copyright (C) 2011 Thomas Langer, Lantiq Deutschland
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+#ifdef CONFIG_EMULATION
+/* some variables used during emulation for external configuration */
+static u32 * const _emu_on  = (u32*)0xBF017FF0;
+static u32 * const _emu_spd = (u32*)0xBF017FF4;
+#endif
+
+ulong get_cpuclk(void)
+{
+#ifdef CONFIG_EMULATION
+#warning "include emulation support"
+	if (*_emu_on != 0) {
+		return *_emu_spd;
+	} else
+#endif
+	{
+		if ((sys1_r32(cpu0cc) & CPU0CC_CPUDIV) == CPU0CC_CPUDIV_SELFHALF)
+			return 200000000; /* 200 MHz */
+		else
+			return 400000000; /* 400 MHz */
+	}
+}
+
+ulong get_bus_freq(ulong dummy)
+{
+#ifdef CONFIG_EMULATION
+	if (*_emu_on != 0) {
+		return *_emu_spd/4;
+	}
+	else
+#endif
+	{
+		/* FPI bus clock is fixed to 100 MHz */
+		return 100000000;
+	}
+}
+
diff --git a/arch/mips/cpu/mips32/falcon/sysctrl.c b/arch/mips/cpu/mips32/falcon/sysctrl.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/falcon/sysctrl.c
@@ -0,0 +1,356 @@
+/*
+ * (C) Copyright 2011
+ * Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/sysctrl.h>
+
+#define WDT_PW1			0x00BE0000
+#define WDT_PW2			0x00DC0000
+#define WDT_REG_BASE		(KSEG1 | 0x1F8803F0)
+
+/**
+ * Trigger the Soft-Reset of the CPU
+ */
+void _machine_restart(void)
+{
+	/* write magic to signal a valid restart */
+	writel(0x4C545100, &boot_reg->magic0); /* 'LTQ\0' */
+	writel(0x0051544C, &boot_reg->magic1); /* '\0QTL' */
+	writel(0, &boot_reg->rvec); /* reset Bootreg RVEC */
+
+	/* reset via watchdog timer, to ensure reset of all hardware components */
+	writel(WDT_PW1, WDT_REG_BASE);
+	writel(WDT_PW2 |
+		(0x3 << 26) | /* PWL */
+		(0x1 << 24) | /* CLKDIV */
+		(0x1 << 31) | /* enable */
+		(1), /* reload */
+		WDT_REG_BASE);
+	for(;;)
+		__asm__ volatile ("nop");
+}
+
+/**
+ * Activate the selected module(s)
+ * Enables the clock of the module and activates the module itself.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS1.ACT
+ * \return void
+ */
+void sys1_hw_activate(u32 mask)
+{
+	sys1_w32(mask, clken);
+	sys1_w32(mask, act);
+
+	while ( (sys1_r32(acts) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Deactivate the selected module(s)
+ * Disables the clock of the module and deactivates the module itself.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS1.DEACT
+ * \return void
+ */
+void sys1_hw_deactivate(u32 mask)
+{
+	sys1_w32(mask, clkclr);
+	sys1_w32(mask, deact);
+
+	while ( (sys1_r32(acts) & mask) != 0) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Clock enable for the selected module(s)
+ * Enables the clock of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS1.CLKEN
+ * \return void
+ */
+void sys1_hw_clk_enable(u32 mask)
+{
+	sys1_w32(mask, clken);
+
+	while ( (sys1_r32(clks) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Clock disable for the selected module(s)
+ * disables the clock of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS1.CLKCLR
+ * \return void
+ */
+void sys1_hw_clk_disable(u32 mask)
+{
+	sys1_w32(mask, clkclr);
+
+	while ( (sys1_r32(clks) & mask) != 0) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Reboots the selected module(s)
+ * Triggers the reboot of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS1.RBT
+ * \return void
+ */
+void sys1_hw_activate_or_reboot(u32 mask)
+{
+	u32 acts = sys1_r32(acts);
+	/* is not already active? */
+	if ((~acts & mask) != 0)
+		sys1_hw_activate(~acts & mask);
+	sys1_w32(acts & mask, rbt);
+	while ( (sys1_r32(acts) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Activate the selected module(s)
+ * Enables the clock of the module and activates the module itself.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_ETH.ACT
+ * \return void
+ */
+void sys_eth_hw_activate(u32 mask)
+{
+	sys_eth_w32(mask, clken);
+	sys_eth_w32(mask, act);
+
+	while ( (sys_eth_r32(acts) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Deactivate the selected module(s)
+ * Disables the clock of the module and deactivates the module itself.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_ETH.DEACT
+ * \return void
+ */
+void sys_eth_hw_deactivate(u32 mask)
+{
+	sys_eth_w32(mask, clkclr);
+	sys_eth_w32(mask, deact);
+
+	while ( (sys_eth_r32(acts) & mask) != 0) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Clock enable for the selected module(s)
+ * Enables the clock of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_ETH.CLKEN
+ * \return void
+ */
+void sys_eth_hw_clk_enable(u32 mask)
+{
+	sys_eth_w32(mask, clken);
+
+	while ( (sys_eth_r32(clks) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Clock disable for the selected module(s)
+ * disables the clock of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_ETH.CLKCLR
+ * \return void
+ */
+void sys_eth_hw_clk_disable(u32 mask)
+{
+	sys_eth_w32(mask, clkclr);
+
+	while ( (sys_eth_r32(clks) & mask) != 0) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Reboots the selected module(s)
+ * Triggers the reboot of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_ETH.RBT
+ * \return void
+ */
+void sys_eth_hw_activate_or_reboot(u32 mask)
+{
+	u32 acts = sys_eth_r32(acts);
+	/* is not already active? */
+	if ((~acts & mask) != 0)
+		sys_eth_hw_activate(~acts & mask);
+	sys_eth_w32(acts & mask, rbt);
+	while ( (sys_eth_r32(acts) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+static int gpe_clk_is_enabled(void)
+{
+	u32 rd_data;
+
+	rd_data = sys1_r32(infrac);
+	if (rd_data & (1<<(INFRAC_GP_OFFSET+1)))
+		/* clock already active, no need to change here*/
+		return 1;
+	return 0;
+}
+
+static void enable_gpe_clk(void)
+{
+	u32 aeFreq;
+	u32 rd_data;
+	u32 rd_data_to_keep;
+	int i;
+
+	if (gpe_clk_is_enabled())
+		/* clock already active, no need to change here */
+		return;
+
+	aeFreq = (status_r32(config) & STATUS_CONFIG_GPEFREQ_MASK) >> STATUS_CONFIG_GPEFREQ_OFFSET;
+	if (aeFreq == 0)
+		aeFreq = 1; /* use 625MHz on invalid value 0 */
+	rd_data = sys1_r32(infrac);
+	/* clear gpe-fsel and enable bits */
+	rd_data_to_keep = rd_data & ~(7<<(INFRAC_GP_OFFSET+1));
+
+	/* set new fsel */
+	sys1_w32(rd_data_to_keep | (aeFreq<<(INFRAC_GP_OFFSET+2)), infrac);
+
+	for (i = 0; i <10; i++) /* wait 10 cycles */
+		{}
+
+	/* keep new fsel and enable */
+	sys1_w32(rd_data_to_keep | (aeFreq<<(INFRAC_GP_OFFSET+2)) |
+		(1<<(INFRAC_GP_OFFSET+1)), infrac);
+	for (i = 0; i <100; i++) /* wait 100 cycles */
+		{}
+}
+
+/**
+ * Activate the selected module(s)
+ * Enables the clock of the module and activates the module itself.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_GPE.ACT
+ * \return void
+ */
+void sys_gpe_hw_activate(u32 mask)
+{
+	enable_gpe_clk();
+	sys_gpe_w32(mask, clken);
+	sys_gpe_w32(mask, act);
+
+	while ( (sys_gpe_r32(acts) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Deactivate the selected module(s)
+ * Disables the clock of the module and deactivates the module itself.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_GPE.DEACT
+ * \return void
+ */
+void sys_gpe_hw_deactivate(u32 mask)
+{
+	enable_gpe_clk();
+	sys_gpe_w32(mask, clkclr);
+	sys_gpe_w32(mask, deact);
+
+	while ( (sys_gpe_r32(acts) & mask) != 0) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Clock enable for the selected module(s)
+ * Enables the clock of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_GPE.CLKEN
+ * \return void
+ */
+void sys_gpe_hw_clk_enable(u32 mask)
+{
+	enable_gpe_clk();
+	sys_gpe_w32(mask, clken);
+
+	while ( (sys_gpe_r32(clks) & mask) != mask) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Clock disable for the selected module(s)
+ * disables the clock of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_GPE.CLKCLR
+ * \return void
+ */
+void sys_gpe_hw_clk_disable(u32 mask)
+{
+	enable_gpe_clk();
+	sys_gpe_w32(mask, clkclr);
+
+	while ( (sys_gpe_r32(clks) & mask) != 0) {
+		/*NOP;*/
+	};
+}
+
+/**
+ * Reboots the selected module(s)
+ * Triggers the reboot of the module.
+ *
+ * \param[in]   mask    bitmask of module(s), as for registers SYS_GPE.RBT
+ * \return void
+ */
+void sys_gpe_hw_activate_or_reboot(u32 mask)
+{
+	u32 acts;
+	enable_gpe_clk();
+	acts = sys_gpe_r32(acts);
+	/* is not already active? */
+	if ((~acts & mask) != 0)
+		sys_gpe_hw_activate(~acts & mask);
+	sys_gpe_w32(acts & mask, rbt);
+	while ( (sys_gpe_r32(acts) & mask) != mask) {
+		/*NOP;*/
+	};
+}
diff --git a/arch/mips/include/asm/arch-falcon/dcdc_reg.h b/arch/mips/include/asm/arch-falcon/dcdc_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/dcdc_reg.h
@@ -0,0 +1,717 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _dcdc_reg_h
+#define _dcdc_reg_h
+
+/** \addtogroup DCDC_REGISTER
+   @{
+*/
+/* access macros */
+#define dcdc_core_r8(reg) (reg_r32(&dcdc_core->reg) & 0xFF)
+#define dcdc_core_w8(val, reg) reg_w32((val) & 0xFF, &dcdc_core->reg)
+#define dcdc_core_w8_mask(clear, set, reg) reg_w32_mask((clear) & 0xFF, (set) & 0xFF, &dcdc_core->reg)
+#define dcdc_core_r8_table(reg, idx) (reg_r32_table(dcdc_core->reg, idx) & 0xFF)
+#define dcdc_core_w8_table(val, reg, idx) reg_w32_table((val) & 0xFF, dcdc_core->reg, idx)
+#define dcdc_core_w8_table_mask(clear, set, reg, idx) reg_w32_table_mask((clear) & 0xFF, (set) & 0xFF, dcdc_core->reg, idx)
+#define dcdc_core_adr_table(reg, idx) adr_table(dcdc_core->reg, idx)
+
+#define dcdc_ddr_r8(reg) (reg_r32(&dcdc_ddr->reg) & 0xFF)
+#define dcdc_ddr_w8(val, reg) reg_w32((val) & 0xFF, &dcdc_ddr->reg)
+#define dcdc_ddr_w8_mask(clear, set, reg) reg_w32_mask((clear) & 0xFF, (set) & 0xFF, &dcdc_ddr->reg)
+#define dcdc_ddr_r8_table(reg, idx) (reg_r32_table(dcdc_ddr->reg, idx) & 0xFF)
+#define dcdc_ddr_w8_table(val, reg, idx) reg_w32_table((val) & 0xFF, dcdc_ddr->reg, idx)
+#define dcdc_ddr_w8_table_mask(clear, set, reg, idx) reg_w32_table_mask((clear) & 0xFF, (set) & 0xFF, dcdc_ddr->reg, idx)
+#define dcdc_ddr_adr_table(reg, idx) adr_table(dcdc_ddr->reg, idx)
+
+#define dcdc_apd_r8(reg) (reg_r32(&dcdc_apd->reg) & 0xFF)
+#define dcdc_apd_w8(val, reg) reg_w32((val) & 0xFF, &dcdc_apd->reg)
+#define dcdc_apd_w8_mask(clear, set, reg) reg_w32_mask((clear) & 0xFF, (set) & 0xFF, &dcdc_apd->reg)
+#define dcdc_apd_r8_table(reg, idx) (reg_r32_table(dcdc_apd->reg, idx) & 0xFF)
+#define dcdc_apd_w8_table(val, reg, idx) reg_w32_table((val) & 0xFF, dcdc_apd->reg, idx)
+#define dcdc_apd_w8_table_mask(clear, set, reg, idx) reg_w32_table_mask((clear) & 0xFF, (set) & 0xFF, dcdc_apd->reg, idx)
+#define dcdc_apd_adr_table(reg, idx) adr_table(dcdc_apd->reg, idx)
+
+
+/** DCDC register structure */
+struct gpon_reg_dcdc
+{
+   /** DCDC_PDI: DCDC Submodule Register File */
+   /** Hi Byte of coefficient b0 */
+   unsigned int pdi_pid_hi_b0; /* 0x00000000 */
+   /** Lo Byte of coefficient b0 */
+   unsigned int pdi_pid_lo_b0; /* 0x00000004 */
+   /** Hi Byte of coefficient b1 */
+   unsigned int pdi_pid_hi_b1; /* 0x00000008 */
+   /** Lo Byte of coefficient b1 */
+   unsigned int pdi_pid_lo_b1; /* 0x0000000C */
+   /** Hi Byte of coefficient b2 */
+   unsigned int pdi_pid_hi_b2; /* 0x00000010 */
+   /** Lo Byte of coefficient b2 */
+   unsigned int pdi_pid_lo_b2; /* 0x00000014 */
+   /** Set up clocks */
+   unsigned int pdi_clk_set0; /* 0x00000018 */
+   /** Set up clocks */
+   unsigned int pdi_clk_set1; /* 0x0000001C */
+   /** PWM Settings 0 */
+   unsigned int pdi_pwm0; /* 0x00000020 */
+   /** PWM Settings 1 */
+   unsigned int pdi_pwm1; /* 0x00000024 */
+   /** Set up BIAS and voltage regulator */
+   unsigned int pdi_bias_vreg; /* 0x00000028 */
+   /** Sets digital reference of DCDC converter */
+   unsigned int pdi_dig_ref; /* 0x0000002C */
+   /** General settings */
+   unsigned int pdi_general; /* 0x00000030 */
+   /** ADC conf0 */
+   unsigned int pdi_adc0; /* 0x00000034 */
+   /** ADC conf1 */
+   unsigned int pdi_adc1; /* 0x00000038 */
+   /** ADC conf2 */
+   unsigned int pdi_adc2; /* 0x0000003C */
+   /** Analog Test Configuration for Autostart Mode */
+   unsigned int pdi_conf_test_ana; /* 0x00000040 */
+   /** Digital Test Configuration for Autostart Mode */
+   unsigned int pdi_conf_test_dig; /* 0x00000044 */
+   /** Analog Test Configuration for Non-Autostart Mode */
+   unsigned int pdi_conf_test_ana_noauto; /* 0x00000048 */
+   /** Digital Test Configuration for Non-Autostart Mode */
+   unsigned int pdi_conf_test_dig_noauto; /* 0x0000004C */
+   /** DCDC_STATUS */
+   unsigned int pdi_dcdc_status; /* 0x00000050 */
+   /** PID_STATUS */
+   unsigned int pdi_pid_status; /* 0x00000054 */
+   /** DUTY_CYCLE */
+   unsigned int pdi_duty_cycle; /* 0x00000058 */
+   /** NON_OV_DELAY */
+   unsigned int pdi_non_ov_delay; /* 0x0000005C */
+   /** ANALOG_GAIN */
+   unsigned int pdi_analog_gain; /* 0x00000060 */
+   /** DUTY_CYCLE_MAX_SAT */
+   unsigned int pdi_duty_cycle_max_sat; /* 0x00000064 */
+   /** DUTY_CYCLE_MIN_SAT */
+   unsigned int pdi_duty_cycle_min_sat; /* 0x00000068 */
+   /** DUTY_CYCLE_MAX */
+   unsigned int pdi_duty_cycle_max; /* 0x0000006C */
+   /** DUTY_CYCLE_MIN */
+   unsigned int pdi_duty_cycle_min; /* 0x00000070 */
+   /** ERROR_MAX */
+   unsigned int pdi_error_max; /* 0x00000074 */
+   /** ERROR_READ */
+   unsigned int pdi_error_read; /* 0x00000078 */
+   /** DELAY_DEGLITCH */
+   unsigned int pdi_delay_deglitch; /* 0x0000007C */
+   /** LATCH_CONTROL */
+   unsigned int pdi_latch_control; /* 0x00000080 */
+   /** LATCH_CONTROL_NOAUTO */
+   unsigned int pdi_latch_control_noauto; /* 0x00000084 */
+   /** CAP_CLK_CNT */
+   unsigned int pdi_cap_clk_cnt; /* 0x00000088 */
+   /** MDLL_DIVIDER */
+   unsigned int pdi_mdll_divider; /* 0x0000008C */
+   /** Reserved */
+   unsigned int pdi_res_0[220]; /* 0x00000090 */
+   /** OSC_PDI: OSC Submodule Register File */
+   /** OSC Configuration Register */
+   unsigned int osc_pdi_osc_conf; /* 0x00000400 */
+   /** OSC_STATUS */
+   unsigned int osc_pdi_osc_status; /* 0x00000404 */
+   /** Reserved */
+   unsigned int osc_pdi_res_1; /* 0x00000408 */
+};
+
+
+/* Fields of "Hi Byte of coefficient b0" */
+/** Hi Byte of coefficient b0 */
+#define DCDC_PID_HI_B0_B_MASK 0xFF
+/** field offset */
+#define DCDC_PID_HI_B0_B_OFFSET 0
+/** Kp = 1/Ks */
+#define DCDC_PID_HI_B0_B_KP_1 0x02
+/** Kp = 3/Ks */
+#define DCDC_PID_HI_B0_B_KP_3 0x08
+/** Kp = 5/Ks */
+#define DCDC_PID_HI_B0_B_KP_5 0x0E
+/** Kp = 7.5/Ks */
+#define DCDC_PID_HI_B0_B_KP_7P5 0x15
+/** Kp = 10/Ks */
+#define DCDC_PID_HI_B0_B_KP_10 0x1C
+/** Kp = 12.5/Ks */
+#define DCDC_PID_HI_B0_B_KP_12P5 0x23
+/** Kp = 15/Ks */
+#define DCDC_PID_HI_B0_B_KP_15 0x2A
+/** Kp = 17.5/Ks */
+#define DCDC_PID_HI_B0_B_KP_17P5 0x31
+
+/* Fields of "Lo Byte of coefficient b0" */
+/** Lo Byte of coefficient b0 */
+#define DCDC_PID_LO_B0_B_MASK 0xFF
+/** field offset */
+#define DCDC_PID_LO_B0_B_OFFSET 0
+/** Kp = 5/Ks */
+#define DCDC_PID_LO_B0_B_KP_5 0x20
+/** Kp = 7.5/Ks */
+#define DCDC_PID_LO_B0_B_KP_7P5 0x31
+/** Kp = 10/Ks */
+#define DCDC_PID_LO_B0_B_KP_10 0x41
+/** Kp = 12.5/Ks */
+#define DCDC_PID_LO_B0_B_KP_12P5 0x51
+/** Kp = 15/Ks */
+#define DCDC_PID_LO_B0_B_KP_15 0x61
+/** Kp = 17.5/Ks */
+#define DCDC_PID_LO_B0_B_KP_17P5 0x72
+/** Kp = 3/Ks */
+#define DCDC_PID_LO_B0_B_KP_3 0x7A
+/** Kp = 1/Ks */
+#define DCDC_PID_LO_B0_B_KP_1 0xD3
+
+/* Fields of "Hi Byte of coefficient b1" */
+/** Hi Byte of coefficient b1 */
+#define DCDC_PID_HI_B1_B_MASK 0xFF
+/** field offset */
+#define DCDC_PID_HI_B1_B_OFFSET 0
+/** Kp = 17.5/Ks */
+#define DCDC_PID_HI_B1_B_KP_17P5 0x9B
+/** Kp = 15/Ks */
+#define DCDC_PID_HI_B1_B_KP_15 0xAA
+/** Kp = 12.5/Ks */
+#define DCDC_PID_HI_B1_B_KP_12P5 0xB8
+/** Kp = 10/Ks */
+#define DCDC_PID_HI_B1_B_KP_10 0xC6
+/** Kp = 7.5/Ks */
+#define DCDC_PID_HI_B1_B_KP_7P5 0xD5
+/** Kp = 5/Ks */
+#define DCDC_PID_HI_B1_B_KP_5 0xE3
+/** Kp = 3/Ks */
+#define DCDC_PID_HI_B1_B_KP_3 0xEE
+/** Kp = 1/Ks */
+#define DCDC_PID_HI_B1_B_KP_1 0xFA
+
+/* Fields of "Lo Byte of coefficient b1" */
+/** Lo Byte of coefficient b1 */
+#define DCDC_PID_LO_B1_B_MASK 0xFF
+/** field offset */
+#define DCDC_PID_LO_B1_B_OFFSET 0
+/** Kp = 7.5/Ks */
+#define DCDC_PID_LO_B1_B_KP_7P5 0x22
+/** Kp = 15/Ks */
+#define DCDC_PID_LO_B1_B_KP_15 0x45
+/** Kp = 1/Ks */
+#define DCDC_PID_LO_B1_B_KP_1 0x49
+/** Kp = 5/Ks */
+#define DCDC_PID_LO_B1_B_KP_5 0x6C
+/** Kp = 12.5/Ks */
+#define DCDC_PID_LO_B1_B_KP_12P5 0x8E
+/** Kp = 10/Ks */
+#define DCDC_PID_LO_B1_B_KP_10 0xD8
+/** Kp = 3/Ks */
+#define DCDC_PID_LO_B1_B_KP_3 0xDB
+/** Kp = 17.5/Ks */
+#define DCDC_PID_LO_B1_B_KP_17P5 0xFB
+
+/* Fields of "Hi Byte of coefficient b2" */
+/** Hi Byte of coefficient b2 */
+#define DCDC_PID_HI_B2_B_MASK 0xFF
+/** field offset */
+#define DCDC_PID_HI_B2_B_OFFSET 0
+/** Kp = 1/Ks */
+#define DCDC_PID_HI_B2_B_KP_1 0x02
+/** Kp = 3/Ks */
+#define DCDC_PID_HI_B2_B_KP_3 0x08
+/** Kp = 5/Ks */
+#define DCDC_PID_HI_B2_B_KP_5 0x0E
+/** Kp = 7.5/Ks */
+#define DCDC_PID_HI_B2_B_KP_7P5 0x15
+/** Kp = 10/Ks */
+#define DCDC_PID_HI_B2_B_KP_10 0x1C
+/** Kp = 12.5/Ks */
+#define DCDC_PID_HI_B2_B_KP_12P5 0x24
+/** Kp = 15/Ks */
+#define DCDC_PID_HI_B2_B_KP_15 0x2B
+/** Kp = 17.5/Ks */
+#define DCDC_PID_HI_B2_B_KP_17P5 0x32
+
+/* Fields of "Lo Byte of coefficient b2" */
+/** Lo Byte of coefficient b2 */
+#define DCDC_PID_LO_B2_B_MASK 0xFF
+/** field offset */
+#define DCDC_PID_LO_B2_B_OFFSET 0
+/** Kp = 12.5/Ks */
+#define DCDC_PID_LO_B2_B_KP_12P5 0x38
+/** Kp = 15/Ks */
+#define DCDC_PID_LO_B2_B_KP_15 0x76
+/** Kp = 5/Ks */
+#define DCDC_PID_LO_B2_B_KP_5 0x7D
+/** Kp = 3/Ks */
+#define DCDC_PID_LO_B2_B_KP_3 0xB1
+/** Kp = 17.5/Ks */
+#define DCDC_PID_LO_B2_B_KP_17P5 0xB4
+/** Kp = 7.5/Ks */
+#define DCDC_PID_LO_B2_B_KP_7P5 0xBB
+/** Kp = 1/Ks */
+#define DCDC_PID_LO_B2_B_KP_1 0xE6
+/** Kp = 10/Ks */
+#define DCDC_PID_LO_B2_B_KP_10 0xF9
+
+/* Fields of "Set up clocks" */
+/** MDLL multiplication factor
+    Integer by which input frequency is multiplied */
+#define DCDC_CLK_SET0_MDLL_MUL_MASK 0x3F
+/** field offset */
+#define DCDC_CLK_SET0_MDLL_MUL_OFFSET 0
+/** Sets PWM frequency to 720 MHz in VDSL-mode/to 500 MHz in non-VDSL-mode */
+#define DCDC_CLK_SET0_MDLL_MUL_PWM500 0x12
+/** Sets PWM frequency to 1440 MHz in VDSL-mode/to 1000 MHZ in non-VDSL-mode */
+#define DCDC_CLK_SET0_MDLL_MUL_PWM1000 0x26
+/** Set divider between MDLL and PWM
+    0 => MDLL output goes straight to PWM */
+#define DCDC_CLK_SET0_CLK_SEL_PWM 0x40
+/** Bypass MDLL
+    Input clock (36MHz in VDSL-mode, 25MHz in non-VDSL-mode) goes straight to PWM, bypassing the MDLL */
+#define DCDC_CLK_SET0_MDLL_BYP 0x80
+
+/* Fields of "Set up clocks" */
+/** MDLL bias resistance
+    0,1,2,3,7 Higher number for higher frequency */
+#define DCDC_CLK_SET1_MDLL_RES_MASK 0x07
+/** field offset */
+#define DCDC_CLK_SET1_MDLL_RES_OFFSET 0
+/** Increase current step size in MDLL
+    Setting this bit will double the step size */
+#define DCDC_CLK_SET1_MDLL_IX2 0x08
+/** Double the frequency of ADC clocks
+    When the PWM clock is halved to 250MHz, this can be used to ensure that the ADC is still clocked with 250MHz iteration frequency. This also means that the PID controller gets double the clock frequency */
+#define DCDC_CLK_SET1_ADC_CLK_MODE 0x10
+/** reserved */
+#define DCDC_CLK_SET1_RESERVED_MASK 0xE0
+/** field offset */
+#define DCDC_CLK_SET1_RESERVED_OFFSET 5
+
+/* Fields of "PWM Settings 0" */
+/** Counter pre-load
+    Sets factor between switching frequncy and PWM input clock. In order to work in VDSL-mode with 720MHz cpload has to be */
+#define DCDC_PWM0_CPLOAD_MASK 0xFF
+/** field offset */
+#define DCDC_PWM0_CPLOAD_OFFSET 0
+
+/* Fields of "PWM Settings 1" */
+/** Static Duty Cycle Value
+    Sets duty cycle in case of PFM mode, or if force_static_dc is set. Also using the soft_preset_pid signal, the PID controller is set to this value, meaning that the integrator doesn't need to be charged up. dc = dc_static/cpload => thus nominal 80/256 = 30%, which is roughly what is needed for 3.3 V operation */
+#define DCDC_PWM1_DC_STATIC_MASK 0xFF
+/** field offset */
+#define DCDC_PWM1_DC_STATIC_OFFSET 0
+
+/* Fields of "Set up BIAS and voltage regulator" */
+/** Trimming of the reference voltage */
+#define DCDC_BIAS_VREG_VREF_MASK 0x07
+/** field offset */
+#define DCDC_BIAS_VREG_VREF_OFFSET 0
+/** nominal value */
+#define DCDC_BIAS_VREG_VREF_NOMINAL 0x00
+/** -1.25% */
+#define DCDC_BIAS_VREG_VREF_M125 0x01
+/** -2.50% */
+#define DCDC_BIAS_VREG_VREF_M250 0x02
+/** -3.75% */
+#define DCDC_BIAS_VREG_VREF_M375 0x03
+/** +1.25% */
+#define DCDC_BIAS_VREG_VREF_P125 0x04
+/** +2.50% */
+#define DCDC_BIAS_VREG_VREF_P250 0x05
+/** +3.75% */
+#define DCDC_BIAS_VREG_VREF_P375 0x06
+/** +5.00% */
+#define DCDC_BIAS_VREG_VREF_P500 0x07
+/** Set voltage of internal regulator
+    Trimming of the internal voltage regulator */
+#define DCDC_BIAS_VREG_VREG_SEL_MASK 0x18
+/** field offset */
+#define DCDC_BIAS_VREG_VREG_SEL_OFFSET 3
+/** 0.93V */
+#define DCDC_BIAS_VREG_VREG_SEL_M120 0x00
+/** 1.0V */
+#define DCDC_BIAS_VREG_VREG_SEL_M50 0x08
+/** nominal value 1.05V */
+#define DCDC_BIAS_VREG_VREG_SEL_NOMINAL 0x10
+/** 1.175 */
+#define DCDC_BIAS_VREG_VREG_SEL_P70 0x18
+/** Reduce bias current for voltage regulator
+    Useful if load is low to gain more stability */
+#define DCDC_BIAS_VREG_I_RED 0x20
+/** Increase current load for internal regulator
+    Increase stability and performance by drawing 1mA of current through a resistor */
+#define DCDC_BIAS_VREG_I_LOADINC 0x40
+/** reserved */
+#define DCDC_BIAS_VREG_RESERVED 0x80
+
+/* Fields of "Sets digital reference of DCDC converter" */
+/** Sets digital reference of DCDC converter
+    Sets up Most Significant Bits of target voltage */
+#define DCDC_DIG_REF_V_MASK 0xFF
+/** field offset */
+#define DCDC_DIG_REF_V_OFFSET 0
+/** minus 100mV = 0.90 */
+#define DCDC_DIG_REF_V_M100 0x72
+/** minus 50mV = 0.95 */
+#define DCDC_DIG_REF_V_M50 0x78
+/** nominal value 1.0V */
+#define DCDC_DIG_REF_V_NOMINAL 0x7F
+/** plus 50mV = 1.05 */
+#define DCDC_DIG_REF_V_P50 0x86
+/** plus 100mV = 1.10 */
+#define DCDC_DIG_REF_V_P100 0x8C
+
+/* Fields of "General settings" */
+/** Causes fixed duty cycle
+    Value is taken from dc_static */
+#define DCDC_GENERAL_FORCE_STATIC_DC 0x01
+/** Switch on PFM mode
+    Similar to force_static_dc, except that additionally the Output Stage is enabled and disabled depending on the output of the PFM comparator, which compares the core voltage to 1.0V and 1.05V */
+#define DCDC_GENERAL_PFM_MODE 0x02
+/** enable output stage
+    Providing that the powerup signal has been received and pfm_mode isn't active, this signal enables the output stage, or makes it high ohmic */
+#define DCDC_GENERAL_OS_EN 0x04
+/** reserved */
+#define DCDC_GENERAL_RESERVED0 0x08
+/** invert PWM output signal
+    Invert the output of the PWM for external power devices */
+#define DCDC_GENERAL_OUT_INV 0x10
+/** reserved */
+#define DCDC_GENERAL_RESERVED1_MASK 0x60
+/** field offset */
+#define DCDC_GENERAL_RESERVED1_OFFSET 5
+/** set half LSB of digital reference
+    This is used to ensure that the control loop never reaches the dead region where it thinks the error is exactly 0 and makes no change to its output. Set at 1, the smallest error value can be + or - 0.5 LSB */
+#define DCDC_GENERAL_SET_LSB_DIGREF 0x80
+
+/* Fields of "ADC conf0" */
+/** set comparator-to-arith clock delay
+    set comparator-to-arith clock delay 0:1:3 */
+#define DCDC_ADC0_SET_COMP2ARITH_MASK 0x07
+/** field offset */
+#define DCDC_ADC0_SET_COMP2ARITH_OFFSET 0
+/** set comparator-to-array clock delay
+    set comparator-to-array clock delay 0:1:7 */
+#define DCDC_ADC0_SET_COMP2ARRAY_MASK 0x38
+/** field offset */
+#define DCDC_ADC0_SET_COMP2ARRAY_OFFSET 3
+/** choose rom bank */
+#define DCDC_ADC0_SET_ROM_SEL_MASK 0xC0
+/** field offset */
+#define DCDC_ADC0_SET_ROM_SEL_OFFSET 6
+
+/* Fields of "ADC conf1" */
+/** set reset arithunit
+    0: start from last sample */
+#define DCDC_ADC1_SET_RESETARITH 0x01
+/** enable comparator offset calibration
+    1: enable comparator offset calibration */
+#define DCDC_ADC1_SET_OFFSET_CAL_EN 0x02
+/** set comparator bias current
+    set comparator bias current to 12.5uA x 2:1:6 */
+#define DCDC_ADC1_SET_COMP_CURR_MASK 0x1C
+/** field offset */
+#define DCDC_ADC1_SET_COMP_CURR_OFFSET 2
+/** set scrambling state
+    set scrambling state 0:1:3 */
+#define DCDC_ADC1_SET_SCR_STATE_MASK 0x60
+/** field offset */
+#define DCDC_ADC1_SET_SCR_STATE_OFFSET 5
+/** reserved */
+#define DCDC_ADC1_RESERVED 0x80
+
+/* Fields of "ADC conf2" */
+/** highest rom address while iterating
+    highest rom address while iterating 0:1:11 */
+#define DCDC_ADC2_SET_ROM_START_MASK 0x0F
+/** field offset */
+#define DCDC_ADC2_SET_ROM_START_OFFSET 0
+/** number of cycles per conversion minus one
+    number of cycles per conversion minus one 0:1:11 */
+#define DCDC_ADC2_SET_START_MASK 0xF0
+/** field offset */
+#define DCDC_ADC2_SET_START_OFFSET 4
+
+/* Fields of "Analog Test Configuration for Autostart Mode" */
+/** Reset ADC */
+#define DCDC_CONF_TEST_ANA_SOFT_RES_ADC_N 0x01
+/** Reset MDLL */
+#define DCDC_CONF_TEST_ANA_SOFT_RES_MDLL_N 0x02
+/** Reset DPWM
+    The PWM generator is disabled. */
+#define DCDC_CONF_TEST_ANA_SOFT_RES_DPWM_N 0x04
+/** Power Down ADC */
+#define DCDC_CONF_TEST_ANA_PD_ADC 0x08
+/** reserved */
+#define DCDC_CONF_TEST_ANA_RESERVED0 0x10
+/** Power Down of PFM comparator */
+#define DCDC_CONF_TEST_ANA_PD_PFMCOMP 0x20
+/** Bypass Digital PWM generator
+    This passes the startup clk (25MHz/32) to the output of the DPWM block, allowing the DPWM to be put in reset. This feature is particularly interesting in PFM mode. */
+#define DCDC_CONF_TEST_ANA_DPWM_BYP 0x40
+/** Oscillator max suppression
+    This switches on the max suppression filter in the oscillator. */
+#define DCDC_CONF_TEST_ANA_OSC_MAX_SUPPR 0x80
+
+/* Fields of "Digital Test Configuration for Autostart Mode" */
+/** Reset PID Controller */
+#define DCDC_CONF_TEST_DIG_SOFT_RES_PID_N 0x01
+/** Reset Rampup Generator
+    Causes the digital reference to start at zero and ramp to the value in its register */
+#define DCDC_CONF_TEST_DIG_SOFT_RES_RAMPUP_N 0x02
+/** Bypass PID control
+    Bypass PID control - Data from ADC accumulator are passed straight to DPWM */
+#define DCDC_CONF_TEST_DIG_TEST_ADC2DUTY 0x04
+/** Bypass of ADC accumulator
+    Bypass ADC accumulator - Data from ADC are passed straight to output of accumulator */
+#define DCDC_CONF_TEST_DIG_TEST_ACCUM_BYP 0x08
+/** Freeze PID controller
+    This is used to reset the sequencer which controls the pid filter. Should be set while changing any of the coefficients */
+#define DCDC_CONF_TEST_DIG_FREEZE_PID 0x10
+/** Soft preset of PID controller
+    This is used to preset the PID integrator, and output with the value of the static_dc register, and other registers to zero. Can be used to bring the system back under control */
+#define DCDC_CONF_TEST_DIG_SOFT_PRESET_PID 0x20
+/** reserved */
+#define DCDC_CONF_TEST_DIG_RESERVED_MASK 0xC0
+/** field offset */
+#define DCDC_CONF_TEST_DIG_RESERVED_OFFSET 6
+
+/* Fields of "Analog Test Configuration for Non-Autostart Mode" */
+/** Reset ADC */
+#define DCDC_CONF_TEST_ANA_NOAUTO_SOFT_RES_ADC_N 0x01
+/** Reset MDLL */
+#define DCDC_CONF_TEST_ANA_NOAUTO_SOFT_RES_MDLL_N 0x02
+/** Reset DPWM */
+#define DCDC_CONF_TEST_ANA_NOAUTO_SOFT_RES_DPWM_N 0x04
+/** Power Down ADC */
+#define DCDC_CONF_TEST_ANA_NOAUTO_PD_ADC 0x08
+/** reserved */
+#define DCDC_CONF_TEST_ANA_NOAUTO_RESERVED0 0x10
+/** Power Down of PFM comparator */
+#define DCDC_CONF_TEST_ANA_NOAUTO_PD_PFMCOMP 0x20
+/** Bypass Digital PWM generator
+    This passes the startup clk (25MHz/32) to the output of the DPWM block, allowing the DPWM to be put in reset. This feature is particularly interesting in PFM mode. */
+#define DCDC_CONF_TEST_ANA_NOAUTO_DPWM_BYP 0x40
+/** Oscillator max suppression
+    This switches on the max suppression filter in the oscillator. */
+#define DCDC_CONF_TEST_ANA_NOAUTO_OSC_MAX_SUPPR 0x80
+
+/* Fields of "Digital Test Configuration for Non-Autostart Mode" */
+/** Reset PID Controller */
+#define DCDC_CONF_TEST_DIG_NOAUTO_SOFT_RES_PID_N 0x01
+/** Reset Rampup Generator
+    Causes the digital reference to start at zero and ramp to the value in its register */
+#define DCDC_CONF_TEST_DIG_NOAUTO_SOFT_RES_RAMPUP_N 0x02
+/** Bypass PID control
+    Bypass PID control - Data from ADC accumulator are passed straight to DPWM */
+#define DCDC_CONF_TEST_DIG_NOAUTO_TEST_ADC2DUTY 0x04
+/** Bypass of ADC accumulator
+    Bypass ADC accumulator - Data from ADC are passed straight to output of accumulator */
+#define DCDC_CONF_TEST_DIG_NOAUTO_TEST_ACCUM_BYP 0x08
+/** Freeze PID controller
+    This is used to reset the sequencer which controls the pid filter. Should be set while changing any of the coefficients */
+#define DCDC_CONF_TEST_DIG_NOAUTO_FREEZE_PID 0x10
+/** Soft preset of PID controller
+    This is used to preset the PID integrator, and output with the value of the static_dc register, and other registers to zero. Can be used to bring the system back under control */
+#define DCDC_CONF_TEST_DIG_NOAUTO_SOFT_PRESET_PID 0x20
+/** reserved */
+#define DCDC_CONF_TEST_DIG_NOAUTO_RESERVED_MASK 0xC0
+/** field offset */
+#define DCDC_CONF_TEST_DIG_NOAUTO_RESERVED_OFFSET 6
+
+/* Fields of "DCDC_STATUS" */
+/** powerup dcdc signal detected just after reset */
+#define DCDC_DCDC_STATUS_POWERUP_DCDC 0x01
+/** Output current higher than 1A for more than 8 cycles */
+#define DCDC_DCDC_STATUS_IMAX_REACHED 0x02
+/** mdll locked signal */
+#define DCDC_DCDC_STATUS_MDLL_LOCKED 0x04
+/** inverted version of mdll locked signal - used to detect whether the MDLL wwas continually in locked. If set, then it was at least temporarily out of lock */
+#define DCDC_DCDC_STATUS_MDLL_LOCKED_N 0x08
+
+/* Fields of "PID_STATUS" */
+/** duty cycle positive saturation (240/255) */
+#define DCDC_PID_STATUS_DUTY_SAT_HI 0x01
+/** duty cycle negative saturation (7/255) */
+#define DCDC_PID_STATUS_DUTY_SAT_LO 0x02
+/** error positive saturation (2^8-1) */
+#define DCDC_PID_STATUS_ERR_SAT_HI 0x04
+/** error negative saturation (-2^8) */
+#define DCDC_PID_STATUS_ERR_SAT_LO 0x08
+/** multiplier positive saturation (2^20-1) */
+#define DCDC_PID_STATUS_MUL_SAT_HI 0x10
+/** multiplier negative saturation (-2^20) */
+#define DCDC_PID_STATUS_MUL_SAT_LO 0x20
+/** PID controller has detected an error of > +/- 120mV for 7 cycles in a row! DANGER! */
+#define DCDC_PID_STATUS_REG_FAIL 0x40
+/** reserved */
+#define DCDC_PID_STATUS_RESERVED 0x80
+
+/* Fields of "DUTY_CYCLE" */
+/** Contains the data going from PID to DPWM */
+#define DCDC_DUTY_CYCLE_DC_WISH_MASK 0xFF
+/** field offset */
+#define DCDC_DUTY_CYCLE_DC_WISH_OFFSET 0
+
+/* Fields of "NON_OV_DELAY" */
+/** non-overlap-time for PMOS turn off
+    time between PMOS turn-off and NMOS turn-on */
+#define DCDC_NON_OV_DELAY_DEL_N_MASK 0x0F
+/** field offset */
+#define DCDC_NON_OV_DELAY_DEL_N_OFFSET 0
+/** non-overlap-time for PMOS turn on
+    time between NMOS turn-off and PMOS turn-on */
+#define DCDC_NON_OV_DELAY_DEL_P_MASK 0xF0
+/** field offset */
+#define DCDC_NON_OV_DELAY_DEL_P_OFFSET 4
+
+/* Fields of "ANALOG_GAIN" */
+/** attenuation after subtraction of the analog reference. Used for DCDC that senses 1.8V or 2.5V, in case of DDR1 or DDR2 supply, together with the changed reference voltage (see vref_ana bit): */
+#define DCDC_ANALOG_GAIN_ATTENUATE_ANA 0x01
+/** gain in front ADC (after subtraction of the analog reference) */
+#define DCDC_ANALOG_GAIN_GAIN_ANA_MASK 0x06
+/** field offset */
+#define DCDC_ANALOG_GAIN_GAIN_ANA_OFFSET 1
+/** reference voltage for single to diff SC input buffer: */
+#define DCDC_ANALOG_GAIN_VREF_ANA 0x08
+/** reserved */
+#define DCDC_ANALOG_GAIN_RESERVED_MASK 0xF0
+/** field offset */
+#define DCDC_ANALOG_GAIN_RESERVED_OFFSET 4
+
+/* Fields of "DUTY_CYCLE_MAX_SAT" */
+/** Contains the upper saturation value for the duty cycle */
+#define DCDC_DUTY_CYCLE_MAX_SAT_DUTY_MAX_SAT_MASK 0xFF
+/** field offset */
+#define DCDC_DUTY_CYCLE_MAX_SAT_DUTY_MAX_SAT_OFFSET 0
+
+/* Fields of "DUTY_CYCLE_MIN_SAT" */
+/** Contains the lower saturation value for the duty cycle */
+#define DCDC_DUTY_CYCLE_MIN_SAT_DUTY_MIN_SAT_MASK 0xFF
+/** field offset */
+#define DCDC_DUTY_CYCLE_MIN_SAT_DUTY_MIN_SAT_OFFSET 0
+
+/* Fields of "DUTY_CYCLE_MAX" */
+/** Contains the comparison value for the duty cycle. If the duty cycle is higher than this value => alarm that a overcurrent/short condition is happening */
+#define DCDC_DUTY_CYCLE_MAX_DUTY_MAX_MASK 0xFF
+/** field offset */
+#define DCDC_DUTY_CYCLE_MAX_DUTY_MAX_OFFSET 0
+
+/* Fields of "DUTY_CYCLE_MIN" */
+/** Contains the comparison value for the duty cycle. If the duty cycle is lower than this value => alarm that a pmos short etc. condition is happening */
+#define DCDC_DUTY_CYCLE_MIN_DUTY_MIN_MASK 0xFF
+/** field offset */
+#define DCDC_DUTY_CYCLE_MIN_DUTY_MIN_OFFSET 0
+
+/* Fields of "ERROR_MAX" */
+/** Contains the comparison value for the error. */
+#define DCDC_ERROR_MAX_ERROR_MAX_MASK 0xFF
+/** field offset */
+#define DCDC_ERROR_MAX_ERROR_MAX_OFFSET 0
+
+/* Fields of "ERROR_READ" */
+/** Contains the actual error that is fed to the PID */
+#define DCDC_ERROR_READ_ERROR_MASK 0xFF
+/** field offset */
+#define DCDC_ERROR_READ_ERROR_OFFSET 0
+
+/* Fields of "DELAY_DEGLITCH" */
+/** Deglitching counter for alarm. The alarm must be consistent active for the alarm_deglitch number of DCDC cycles, before the output is activated: */
+#define DCDC_DELAY_DEGLITCH_ALARM_DEGLITCH_MASK 0x0F
+/** field offset */
+#define DCDC_DELAY_DEGLITCH_ALARM_DEGLITCH_OFFSET 0
+/** Speed setting for soft start ramp: */
+#define DCDC_DELAY_DEGLITCH_RAMP_DELAY_MASK 0x70
+/** field offset */
+#define DCDC_DELAY_DEGLITCH_RAMP_DELAY_OFFSET 4
+/** reserved */
+#define DCDC_DELAY_DEGLITCH_RESERVED 0x80
+
+/* Fields of "LATCH_CONTROL" */
+/** Select the latch for synchronising the SC input buffer data with the ADC result. */
+#define DCDC_LATCH_CONTROL_CAP_CLK_MODE 0x01
+/** reserved */
+#define DCDC_LATCH_CONTROL_RESERVED1_MASK 0x06
+/** field offset */
+#define DCDC_LATCH_CONTROL_RESERVED1_OFFSET 1
+/** Force p-transistor to static value. */
+#define DCDC_LATCH_CONTROL_PFORCE_EN 0x08
+/** Static value for p-transistor when forced. */
+#define DCDC_LATCH_CONTROL_PFORCE_AT 0x10
+/** Force n-transistor to static value. */
+#define DCDC_LATCH_CONTROL_NFORCE_EN 0x20
+/** Static value for n-transistor when forced. */
+#define DCDC_LATCH_CONTROL_NFORCE_AT 0x40
+/** reserved */
+#define DCDC_LATCH_CONTROL_RESERVED2 0x80
+
+/* Fields of "LATCH_CONTROL_NOAUTO" */
+/** Select the latch for synchronising the SC input buffer data with the ADC result. */
+#define DCDC_LATCH_CONTROL_NOAUTO_CAP_CLK_MODE 0x01
+/** reserved */
+#define DCDC_LATCH_CONTROL_NOAUTO_RESERVED1_MASK 0x06
+/** field offset */
+#define DCDC_LATCH_CONTROL_NOAUTO_RESERVED1_OFFSET 1
+/** Force p-transistor to static value. */
+#define DCDC_LATCH_CONTROL_NOAUTO_PFORCE_EN 0x08
+/** Static value for p-transistor when forced. */
+#define DCDC_LATCH_CONTROL_NOAUTO_PFORCE_AT 0x10
+/** Force n-transistor to static value. */
+#define DCDC_LATCH_CONTROL_NOAUTO_NFORCE_EN 0x20
+/** Static value for n-transistor when forced. */
+#define DCDC_LATCH_CONTROL_NOAUTO_NFORCE_AT 0x40
+/** reserved */
+#define DCDC_LATCH_CONTROL_NOAUTO_RESERVED2 0x80
+
+/* Fields of "CAP_CLK_CNT" */
+/** Contains the value for the capture clock counter. The ouput frequency is calculated by the formula fcap_clk = fsample_clk/counter value. */
+#define DCDC_CAP_CLK_CNT_COUNTER_MASK 0xFF
+/** field offset */
+#define DCDC_CAP_CLK_CNT_COUNTER_OFFSET 0
+
+/* Fields of "MDLL_DIVIDER" */
+/** Select the post divider for MDLL clock. */
+#define DCDC_MDLL_DIVIDER_DIVIDER_MASK 0x03
+/** field offset */
+#define DCDC_MDLL_DIVIDER_DIVIDER_OFFSET 0
+/** Reserved bits for analog part of the DCDC converter. */
+#define DCDC_MDLL_DIVIDER_ANA_RES_MASK 0x0C
+/** field offset */
+#define DCDC_MDLL_DIVIDER_ANA_RES_OFFSET 2
+
+/* Fields of "OSC Configuration Register" */
+/** Disable amplitude regulation
+    Leads to increase of amplitude at XTAL1, */
+#define DCDC_OSC_CONF_REG_DIS 0x01
+/** Increase regulation capacitance
+    Leads to increase of amplitude at XTAL1, */
+#define DCDC_OSC_CONF_CAP_UP 0x02
+/** Bypass shaper */
+#define DCDC_OSC_CONF_SH_BYP_REG 0x04
+/** Overwrite frequency detection
+    Instead of automatically detecting incoming frequency, this can be overwritten using this bit. The value is taken from OWR_FDET_VAL */
+#define DCDC_OSC_CONF_OWR_FDET 0x08
+/** Value of frequency detection in overwrite mode
+    0 => Frequency at XTAL1 goes through */
+#define DCDC_OSC_CONF_OWR_FDET_VAL 0x10
+/** Power down of frequency detector */
+#define DCDC_OSC_CONF_PD_FDETECT 0x20
+/** Power down of clock shaper */
+#define DCDC_OSC_CONF_PD_SHAPER 0x40
+/** Power down of oscillator core */
+#define DCDC_OSC_CONF_PD_CORE 0x80
+
+/* Fields of "OSC_STATUS" */
+/** osc clk frequency detected */
+#define DCDC_OSC_STATUS_CLK_FREQ 0x01
+
+/*! @} */ /* DCDC_REGISTER */
+
+#endif /* _dcdc_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/ddrdb_reg.h b/arch/mips/include/asm/arch-falcon/ddrdb_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/ddrdb_reg.h
@@ -0,0 +1,3220 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _ddrdb_reg_h
+#define _ddrdb_reg_h
+
+/** \addtogroup DDRDB_REGISTER
+   @{
+*/
+/* access macros */
+#define ddrdb_r32(reg) reg_r32(&ddrdb->reg)
+#define ddrdb_w32(val, reg) reg_w32(val, &ddrdb->reg)
+#define ddrdb_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &ddrdb->reg)
+#define ddrdb_r32_table(reg, idx) reg_r32_table(ddrdb->reg, idx)
+#define ddrdb_w32_table(val, reg, idx) reg_w32_table(val, ddrdb->reg, idx)
+#define ddrdb_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, ddrdb->reg, idx)
+#define ddrdb_adr_table(reg, idx) adr_table(ddrdb->reg, idx)
+
+
+/** DDRDB register structure */
+struct gpon_reg_ddrdb
+{
+   /** Denali CTL_00 register */
+   unsigned int ctl0[4]; /* 0x00000000 */
+   /** Denali CTL_01 register */
+   unsigned int ctl1[4]; /* 0x00000010 */
+   /** Denali CTL_02 register */
+   unsigned int ctl2[4]; /* 0x00000020 */
+   /** Denali CTL_03 register */
+   unsigned int ctl3[4]; /* 0x00000030 */
+   /** Denali CTL_04 register */
+   unsigned int ctl4[4]; /* 0x00000040 */
+   /** Denali CTL_05 register */
+   unsigned int ctl5[4]; /* 0x00000050 */
+   /** Denali CTL_06 register */
+   unsigned int ctl6[4]; /* 0x00000060 */
+   /** Denali CTL_07 register */
+   unsigned int ctl7[4]; /* 0x00000070 */
+   /** Denali CTL_08 register */
+   unsigned int ctl8[4]; /* 0x00000080 */
+   /** Denali CTL_09 register */
+   unsigned int ctl9[4]; /* 0x00000090 */
+   /** Denali CTL_10 register */
+   unsigned int ctl_10; /* 0x000000A0 */
+   /** Reserved */
+   unsigned int res_10[3]; /* 0x000000A4 */
+   /** Denali CTL_11 register */
+   unsigned int ctl_11; /* 0x000000B0 */
+   /** Reserved */
+   unsigned int res_11[3]; /* 0x000000B4 */
+   /** Denali CTL_12 register */
+   unsigned int ctl_12; /* 0x000000C0 */
+   /** Reserved */
+   unsigned int res_12[3]; /* 0x000000C4 */
+   /** Denali CTL_13 register */
+   unsigned int ctl_13; /* 0x000000D0 */
+   /** Reserved */
+   unsigned int res_13[3]; /* 0x000000D4 */
+   /** Denali CTL_14 register */
+   unsigned int ctl_14; /* 0x000000E0 */
+   /** Reserved */
+   unsigned int res_14[3]; /* 0x000000E4 */
+   /** Denali CTL_15 register */
+   unsigned int ctl_15; /* 0x000000F0 */
+   /** Reserved */
+   unsigned int res_15[3]; /* 0x000000F4 */
+   /** Denali CTL_16 register */
+   unsigned int ctl_16; /* 0x00000100 */
+   /** Reserved */
+   unsigned int res_16[3]; /* 0x00000104 */
+   /** Denali CTL_17 register */
+   unsigned int ctl_17; /* 0x00000110 */
+   /** Reserved */
+   unsigned int res_17[3]; /* 0x00000114 */
+   /** Denali CTL_18 register */
+   unsigned int ctl_18; /* 0x00000120 */
+   /** Reserved */
+   unsigned int res_18[3]; /* 0x00000124 */
+   /** Denali CTL_19 register */
+   unsigned int ctl_19; /* 0x00000130 */
+   /** Reserved */
+   unsigned int res_19[3]; /* 0x00000134 */
+   /** Denali CTL_20 register */
+   unsigned int ctl_20; /* 0x00000140 */
+   /** Reserved */
+   unsigned int res_20[3]; /* 0x00000144 */
+   /** Denali CTL_21 register */
+   unsigned int ctl_21; /* 0x00000150 */
+   /** Reserved */
+   unsigned int res_21[3]; /* 0x00000154 */
+   /** Denali CTL_22 register */
+   unsigned int ctl_22; /* 0x00000160 */
+   /** Reserved */
+   unsigned int res_22[3]; /* 0x00000164 */
+   /** Denali CTL_23 register */
+   unsigned int ctl_23; /* 0x00000170 */
+   /** Reserved */
+   unsigned int res_23[3]; /* 0x00000174 */
+   /** Denali CTL_24 register */
+   unsigned int ctl_24; /* 0x00000180 */
+   /** Reserved */
+   unsigned int res_24[3]; /* 0x00000184 */
+   /** Denali CTL_25 register */
+   unsigned int ctl_25; /* 0x00000190 */
+   /** Reserved */
+   unsigned int res_25[3]; /* 0x00000194 */
+   /** Denali CTL_26 register */
+   unsigned int ctl_26; /* 0x000001A0 */
+   /** Reserved */
+   unsigned int res_26[3]; /* 0x000001A4 */
+   /** Denali CTL_27 register */
+   unsigned int ctl_27; /* 0x000001B0 */
+   /** Reserved */
+   unsigned int res_27[3]; /* 0x000001B4 */
+   /** Denali CTL_28 register */
+   unsigned int ctl_28; /* 0x000001C0 */
+   /** Reserved */
+   unsigned int res_28[3]; /* 0x000001C4 */
+   /** Denali CTL_29 register */
+   unsigned int ctl_29; /* 0x000001D0 */
+   /** Reserved */
+   unsigned int res_29[3]; /* 0x000001D4 */
+   /** Denali CTL_30 register */
+   unsigned int ctl_30; /* 0x000001E0 */
+   /** Reserved */
+   unsigned int res_30[3]; /* 0x000001E4 */
+   /** Denali CTL_31 register */
+   unsigned int ctl_31; /* 0x000001F0 */
+   /** Reserved */
+   unsigned int res_31[3]; /* 0x000001F4 */
+   /** Denali CTL_32 register */
+   unsigned int ctl_32; /* 0x00000200 */
+   /** Reserved */
+   unsigned int res_32[3]; /* 0x00000204 */
+   /** Denali CTL_33 register */
+   unsigned int ctl_33; /* 0x00000210 */
+   /** Reserved */
+   unsigned int res_33[3]; /* 0x00000214 */
+   /** Denali CTL_34 register */
+   unsigned int ctl_34; /* 0x00000220 */
+   /** Reserved */
+   unsigned int res_34[3]; /* 0x00000224 */
+   /** Denali CTL_35 register */
+   unsigned int ctl_35; /* 0x00000230 */
+   /** Reserved */
+   unsigned int res_35[3]; /* 0x00000234 */
+   /** Denali CTL_36 register */
+   unsigned int ctl_36; /* 0x00000240 */
+   /** Reserved */
+   unsigned int res_36[3]; /* 0x00000244 */
+   /** Denali CTL_37 register */
+   unsigned int ctl_37; /* 0x00000250 */
+   /** Reserved */
+   unsigned int res_37[3]; /* 0x00000254 */
+   /** Denali CTL_38 register */
+   unsigned int ctl_38; /* 0x00000260 */
+   /** Reserved */
+   unsigned int res_38[3]; /* 0x00000264 */
+   /** Denali CTL_39 register
+       Controls the DLL bypass logic, DLL start point and holds the read DQS delay settings for data slice 0. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_0_X. */
+   unsigned int ctl_39; /* 0x00000270 */
+   /** Reserved */
+   unsigned int res_39[3]; /* 0x00000274 */
+   /** Denali CTL_40 register
+       Controls the DLL bypass logic, DLL start point and holds the read DQS delay settings for data slice 1. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_0_X. */
+   unsigned int ctl_40; /* 0x00000280 */
+   /** Reserved */
+   unsigned int res_40[3]; /* 0x00000284 */
+   /** Denali CTL_41 register
+       Controls the DLL bypass logic, DLL start point and holds the read DQS delay settings for data slice 2. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_0_X. */
+   unsigned int ctl_41; /* 0x00000290 */
+   /** Reserved */
+   unsigned int res_41[3]; /* 0x00000294 */
+   /** Denali CTL_42 register
+       Controls the DLL bypass logic, DLL start point and holds the read DQS delay settings for data slice 3. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_0_X. */
+   unsigned int ctl_42; /* 0x000002A0 */
+   /** Reserved */
+   unsigned int res_42[3]; /* 0x000002A4 */
+   /** Denali CTL_43 register
+       Holds the clk_wr settings and the DLL increment value for data slice 0. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_1_X. */
+   unsigned int ctl_43; /* 0x000002B0 */
+   /** Reserved */
+   unsigned int res_43[3]; /* 0x000002B4 */
+   /** Denali CTL_44 register
+       Holds the clk_wr settings and the DLL increment value for data slice 1. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_1_X. */
+   unsigned int ctl_44; /* 0x000002C0 */
+   /** Reserved */
+   unsigned int res_44[3]; /* 0x000002C4 */
+   /** Denali CTL_45 register
+       Holds the clk_wr settings and the DLL increment value for data slice 2. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_1_X. */
+   unsigned int ctl_45; /* 0x000002D0 */
+   /** Reserved */
+   unsigned int res_45[3]; /* 0x000002D4 */
+   /** Denali CTL_46 register
+       Holds the clk_wr settings and the DLL increment value for data slice 3. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_ctrl_reg_1_X. */
+   unsigned int ctl_46; /* 0x000002E0 */
+   /** Reserved */
+   unsigned int res_46[3]; /* 0x000002E4 */
+   /** Denali CTL_47 register
+       Reports the lock status and the encoder value for data slice 0. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_obs_reg_0_X. */
+   unsigned int ctl_47; /* 0x000002F0 */
+   /** Reserved */
+   unsigned int res_47[3]; /* 0x000002F4 */
+   /** Denali CTL_48 register
+       Reports the lock status and the encoder value for data slice 1. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_obs_reg_0_X. */
+   unsigned int ctl_48; /* 0x00000300 */
+   /** Reserved */
+   unsigned int res_48[3]; /* 0x00000304 */
+   /** Denali CTL_49 register
+       Reports the lock status and the encoder value for data slice 2. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_obs_reg_0_X. */
+   unsigned int ctl_49; /* 0x00000310 */
+   /** Reserved */
+   unsigned int res_49[3]; /* 0x00000314 */
+   /** Denali CTL_50 register
+       Reports the lock status and the encoder value for data slice 3. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = dll_obs_reg_0_X. */
+   unsigned int ctl_50; /* 0x00000320 */
+   /** Reserved */
+   unsigned int res_50[3]; /* 0x00000324 */
+   /** Denali CTL_51 register */
+   unsigned int ctl_51; /* 0x00000330 */
+   /** Reserved */
+   unsigned int res_51[3]; /* 0x00000334 */
+   /** Denali CTL_52 register
+       These bit settings are specific to the pad models included with this PHY. The user should alter the programming relative to the particular pads being used in their design. Note: Denali provides a dynamic termination signal tsel that provides one bit per byte of memory data. The user must attach this signal to the pads dependent on pad requirements. Denali has not connected this signal to the pad model. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = pad_ctrl_reg_0. */
+   unsigned int ctl_52; /* 0x00000340 */
+   /** Reserved */
+   unsigned int res_52[3]; /* 0x00000344 */
+   /** Denali CTL_53 register
+       Controls pad output enable times and other PHY parameters for data slice 0. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_0_X. */
+   unsigned int ctl_53; /* 0x00000350 */
+   /** Reserved */
+   unsigned int res_53[3]; /* 0x00000354 */
+   /** Denali CTL_54 register
+       Controls pad output enable times and other PHY parameters for data slice 1. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_0_X. */
+   unsigned int ctl_54; /* 0x00000360 */
+   /** Reserved */
+   unsigned int res_54[3]; /* 0x00000364 */
+   /** Denali CTL_55 register
+       Controls pad output enable times and other PHY parameters for data slice 2. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_0_X. */
+   unsigned int ctl_55; /* 0x00000370 */
+   /** Reserved */
+   unsigned int res_55[3]; /* 0x00000374 */
+   /** Denali CTL_56 register
+       Controls pad output enable times and other PHY parameters for data slice 3. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_0_X. */
+   unsigned int ctl_56; /* 0x00000380 */
+   /** Reserved */
+   unsigned int res_56[3]; /* 0x00000384 */
+   /** Denali CTL_57 register
+       Controls pad termination and loopback for data slice 0. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_1_X. */
+   unsigned int ctl_57; /* 0x00000390 */
+   /** Reserved */
+   unsigned int res_57[3]; /* 0x00000394 */
+   /** Denali CTL_58 register
+       Controls pad termination and loopback for data slice 1. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_1_X. */
+   unsigned int ctl_58; /* 0x000003A0 */
+   /** Reserved */
+   unsigned int res_58[3]; /* 0x000003A4 */
+   /** Denali CTL_59 register
+       Controls pad termination and loopback for data slice 2. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_1_X. */
+   unsigned int ctl_59; /* 0x000003B0 */
+   /** Reserved */
+   unsigned int res_59[3]; /* 0x000003B4 */
+   /** Denali CTL_60 register
+       Controls pad termination and loopback for data slice 3. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_1_X. */
+   unsigned int ctl_60; /* 0x000003C0 */
+   /** Reserved */
+   unsigned int res_60[3]; /* 0x000003C4 */
+   /** Denali CTL_61 register
+       Selects normal or low latency PHY paths and the dfi_rddata_valid delay Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_ctrl_reg_2. */
+   unsigned int ctl_61; /* 0x000003D0 */
+   /** Reserved */
+   unsigned int res_61[3]; /* 0x000003D4 */
+   /** Denali CTL_62 register
+       Controls loopback status, data and masking info for data slic 0. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_obs_reg_0_X. */
+   unsigned int ctl_62; /* 0x000003E0 */
+   /** Reserved */
+   unsigned int res_62[3]; /* 0x000003E4 */
+   /** Denali CTL_63 register
+       Controls loopback status, data and masking info for data slic 1. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_obs_reg_0_X. */
+   unsigned int ctl_63; /* 0x000003F0 */
+   /** Reserved */
+   unsigned int res_63[3]; /* 0x000003F4 */
+   /** Denali CTL_64 register
+       Controls loopback status, data and masking info for data slic 2. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_obs_reg_0_X. */
+   unsigned int ctl_64; /* 0x00000400 */
+   /** Reserved */
+   unsigned int res_64[3]; /* 0x00000404 */
+   /** Denali CTL_65 register
+       Controls loopback status, data and masking info for data slic 3. There is a separate register for each of the slices of data sent on the DFI data bus. Note: The DENALI docu regarding this register is somehow inconsistent with the majority of other registers as the fields of this register are not specified as individual fields, but as one large field consisting of a table of bit-slices. When looking up the corresponding register documentation of the DENALI documents please refer to: DENALI-original-field-name = phy_obs_reg_0_X. */
+   unsigned int ctl_65; /* 0x00000410 */
+   /** Reserved */
+   unsigned int res_65[3]; /* 0x00000414 */
+   /** Denali CTL_66 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_66; /* 0x00000420 */
+   /** Reserved */
+   unsigned int res_66[3]; /* 0x00000424 */
+   /** Denali CTL_67 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_67; /* 0x00000430 */
+   /** Reserved */
+   unsigned int res_67[3]; /* 0x00000434 */
+   /** Denali CTL_68 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_68; /* 0x00000440 */
+   /** Reserved */
+   unsigned int res_68[3]; /* 0x00000444 */
+   /** Denali CTL_69 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_69; /* 0x00000450 */
+   /** Reserved */
+   unsigned int res_69[3]; /* 0x00000454 */
+   /** Denali CTL_70 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_70; /* 0x00000460 */
+   /** Reserved */
+   unsigned int res_70[3]; /* 0x00000464 */
+   /** Denali CTL_71 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_71; /* 0x00000470 */
+   /** Reserved */
+   unsigned int res_71[3]; /* 0x00000474 */
+   /** Denali CTL_72 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_72; /* 0x00000480 */
+   /** Reserved */
+   unsigned int res_72[3]; /* 0x00000484 */
+   /** Denali CTL_73 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_73; /* 0x00000490 */
+   /** Reserved */
+   unsigned int res_73[3]; /* 0x00000494 */
+   /** Denali CTL_74 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_74; /* 0x000004A0 */
+   /** Reserved */
+   unsigned int res_74[3]; /* 0x000004A4 */
+   /** Denali CTL_75 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_75; /* 0x000004B0 */
+   /** Reserved */
+   unsigned int res_75[3]; /* 0x000004B4 */
+   /** Denali CTL_76 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_76; /* 0x000004C0 */
+   /** Reserved */
+   unsigned int res_76[3]; /* 0x000004C4 */
+   /** Denali CTL_77 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_77; /* 0x000004D0 */
+   /** Reserved */
+   unsigned int res_77[3]; /* 0x000004D4 */
+   /** Denali CTL_78 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_78; /* 0x000004E0 */
+   /** Reserved */
+   unsigned int res_78[3]; /* 0x000004E4 */
+   /** Denali CTL_79 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_79; /* 0x000004F0 */
+   /** Reserved */
+   unsigned int res_79[3]; /* 0x000004F4 */
+   /** Denali CTL_80 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_80; /* 0x00000500 */
+   /** Reserved */
+   unsigned int res_80[3]; /* 0x00000504 */
+   /** Denali CTL_81 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_81; /* 0x00000510 */
+   /** Reserved */
+   unsigned int res_81[3]; /* 0x00000514 */
+   /** Denali CTL_82 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_82; /* 0x00000520 */
+   /** Reserved */
+   unsigned int res_82[3]; /* 0x00000524 */
+   /** Denali CTL_83 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_83; /* 0x00000530 */
+   /** Reserved */
+   unsigned int res_83[3]; /* 0x00000534 */
+   /** Denali CTL_84 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_84; /* 0x00000540 */
+   /** Reserved */
+   unsigned int res_84[3]; /* 0x00000544 */
+   /** Denali CTL_85 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_85; /* 0x00000550 */
+   /** Reserved */
+   unsigned int res_85[3]; /* 0x00000554 */
+   /** Denali CTL_86 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_86; /* 0x00000560 */
+   /** Reserved */
+   unsigned int res_86[3]; /* 0x00000564 */
+   /** Denali CTL_87 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_87; /* 0x00000570 */
+   /** Reserved */
+   unsigned int res_87[3]; /* 0x00000574 */
+   /** Denali CTL_88 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_88; /* 0x00000580 */
+   /** Reserved */
+   unsigned int res_88[3]; /* 0x00000584 */
+   /** Denali CTL_89 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_89; /* 0x00000590 */
+   /** Reserved */
+   unsigned int res_89[3]; /* 0x00000594 */
+   /** Denali CTL_90 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_90; /* 0x000005A0 */
+   /** Reserved */
+   unsigned int res_90[3]; /* 0x000005A4 */
+   /** Denali CTL_91 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_91; /* 0x000005B0 */
+   /** Reserved */
+   unsigned int res_91[3]; /* 0x000005B4 */
+   /** Denali CTL_92 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_92; /* 0x000005C0 */
+   /** Reserved */
+   unsigned int res_92[3]; /* 0x000005C4 */
+   /** Denali CTL_93 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_93; /* 0x000005D0 */
+   /** Reserved */
+   unsigned int res_93[3]; /* 0x000005D4 */
+   /** Denali CTL_94 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_94; /* 0x000005E0 */
+   /** Reserved */
+   unsigned int res_94[3]; /* 0x000005E4 */
+   /** Denali CTL_95 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_95; /* 0x000005F0 */
+   /** Reserved */
+   unsigned int res_95[3]; /* 0x000005F4 */
+   /** Denali CTL_96 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_96; /* 0x00000600 */
+   /** Reserved */
+   unsigned int res_96[3]; /* 0x00000604 */
+   /** Denali CTL_97 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_97; /* 0x00000610 */
+   /** Reserved */
+   unsigned int res_97[3]; /* 0x00000614 */
+   /** Denali CTL_98 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_98; /* 0x00000620 */
+   /** Reserved */
+   unsigned int res_98[3]; /* 0x00000624 */
+   /** Denali CTL_99 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_99; /* 0x00000630 */
+   /** Reserved */
+   unsigned int res_99[3]; /* 0x00000634 */
+   /** Denali CTL_100 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_100; /* 0x00000640 */
+   /** Reserved */
+   unsigned int res_100[3]; /* 0x00000644 */
+   /** Denali CTL_101 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_101; /* 0x00000650 */
+   /** Reserved */
+   unsigned int res_101[3]; /* 0x00000654 */
+   /** Denali CTL_102 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_102; /* 0x00000660 */
+   /** Reserved */
+   unsigned int res_102[3]; /* 0x00000664 */
+   /** Denali CTL_103 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_103; /* 0x00000670 */
+   /** Reserved */
+   unsigned int res_103[3]; /* 0x00000674 */
+   /** Denali CTL_104 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_104; /* 0x00000680 */
+   /** Reserved */
+   unsigned int res_104[3]; /* 0x00000684 */
+   /** Denali CTL_105 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_105; /* 0x00000690 */
+   /** Reserved */
+   unsigned int res_105[3]; /* 0x00000694 */
+   /** Denali CTL_106 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_106; /* 0x000006A0 */
+   /** Reserved */
+   unsigned int res_106[3]; /* 0x000006A4 */
+   /** Denali CTL_107 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_107; /* 0x000006B0 */
+   /** Reserved */
+   unsigned int res_107[3]; /* 0x000006B4 */
+   /** Denali CTL_108 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_108; /* 0x000006C0 */
+   /** Reserved */
+   unsigned int res_108[3]; /* 0x000006C4 */
+   /** Denali CTL_109 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_109; /* 0x000006D0 */
+   /** Reserved */
+   unsigned int res_109[3]; /* 0x000006D4 */
+   /** Denali CTL_110 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_110; /* 0x000006E0 */
+   /** Reserved */
+   unsigned int res_110[3]; /* 0x000006E4 */
+   /** Denali CTL_111 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_111; /* 0x000006F0 */
+   /** Reserved */
+   unsigned int res_111[3]; /* 0x000006F4 */
+   /** Denali CTL_112 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_112; /* 0x00000700 */
+   /** Reserved */
+   unsigned int res_112[3]; /* 0x00000704 */
+   /** Denali CTL_113 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_113; /* 0x00000710 */
+   /** Reserved */
+   unsigned int res_113[3]; /* 0x00000714 */
+   /** Denali CTL_114 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_114; /* 0x00000720 */
+   /** Reserved */
+   unsigned int res_114[3]; /* 0x00000724 */
+   /** Denali CTL_115 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_115; /* 0x00000730 */
+   /** Reserved */
+   unsigned int res_115[3]; /* 0x00000734 */
+   /** Denali CTL_116 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_116; /* 0x00000740 */
+   /** Reserved */
+   unsigned int res_116[3]; /* 0x00000744 */
+   /** Denali CTL_117 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_117; /* 0x00000750 */
+   /** Reserved */
+   unsigned int res_117[3]; /* 0x00000754 */
+   /** Denali CTL_118 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_118; /* 0x00000760 */
+   /** Reserved */
+   unsigned int res_118[3]; /* 0x00000764 */
+   /** Denali CTL_119 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_119; /* 0x00000770 */
+   /** Reserved */
+   unsigned int res_119[3]; /* 0x00000774 */
+   /** Denali CTL_120 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_120; /* 0x00000780 */
+   /** Reserved */
+   unsigned int res_120[3]; /* 0x00000784 */
+   /** Denali CTL_121 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_121; /* 0x00000790 */
+   /** Reserved */
+   unsigned int res_121[3]; /* 0x00000794 */
+   /** Denali CTL_122 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_122; /* 0x000007A0 */
+   /** Reserved */
+   unsigned int res_122[3]; /* 0x000007A4 */
+   /** Denali CTL_123 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_123; /* 0x000007B0 */
+   /** Reserved */
+   unsigned int res_123[3]; /* 0x000007B4 */
+   /** Denali CTL_124 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_124; /* 0x000007C0 */
+   /** Reserved */
+   unsigned int res_124[3]; /* 0x000007C4 */
+   /** Denali CTL_125 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_125; /* 0x000007D0 */
+   /** Reserved */
+   unsigned int res_125[3]; /* 0x000007D4 */
+   /** Denali CTL_126 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_126; /* 0x000007E0 */
+   /** Reserved */
+   unsigned int res_126[3]; /* 0x000007E4 */
+   /** Denali CTL_127 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_127; /* 0x000007F0 */
+   /** Reserved */
+   unsigned int res_127[3]; /* 0x000007F4 */
+   /** Denali CTL_128 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_128; /* 0x00000800 */
+   /** Reserved */
+   unsigned int res_128[3]; /* 0x00000804 */
+   /** Denali CTL_129 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_129; /* 0x00000810 */
+   /** Reserved */
+   unsigned int res_129[3]; /* 0x00000814 */
+   /** Denali CTL_130 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_130; /* 0x00000820 */
+   /** Reserved */
+   unsigned int res_130[3]; /* 0x00000824 */
+   /** Denali CTL_131 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_131; /* 0x00000830 */
+   /** Reserved */
+   unsigned int res_131[3]; /* 0x00000834 */
+   /** Denali CTL_132 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_132; /* 0x00000840 */
+   /** Reserved */
+   unsigned int res_132[3]; /* 0x00000844 */
+   /** Denali CTL_133 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_133; /* 0x00000850 */
+   /** Reserved */
+   unsigned int res_133[3]; /* 0x00000854 */
+   /** Denali CTL_134 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_134; /* 0x00000860 */
+   /** Reserved */
+   unsigned int res_134[3]; /* 0x00000864 */
+   /** Denali CTL_135 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_135; /* 0x00000870 */
+   /** Reserved */
+   unsigned int res_135[3]; /* 0x00000874 */
+   /** Denali CTL_136 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_136; /* 0x00000880 */
+   /** Reserved */
+   unsigned int res_136[3]; /* 0x00000884 */
+   /** Denali CTL_137 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_137; /* 0x00000890 */
+   /** Reserved */
+   unsigned int res_137[3]; /* 0x00000894 */
+   /** Denali CTL_138 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_138; /* 0x000008A0 */
+   /** Reserved */
+   unsigned int res_138[3]; /* 0x000008A4 */
+   /** Denali CTL_139 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_139; /* 0x000008B0 */
+   /** Reserved */
+   unsigned int res_139[3]; /* 0x000008B4 */
+   /** Denali CTL_140 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_140; /* 0x000008C0 */
+   /** Reserved */
+   unsigned int res_140[3]; /* 0x000008C4 */
+   /** Denali CTL_141 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_141; /* 0x000008D0 */
+   /** Reserved */
+   unsigned int res_141[3]; /* 0x000008D4 */
+   /** Denali CTL_142 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_142; /* 0x000008E0 */
+   /** Reserved */
+   unsigned int res_142[3]; /* 0x000008E4 */
+   /** Denali CTL_143 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_143; /* 0x000008F0 */
+   /** Reserved */
+   unsigned int res_143[3]; /* 0x000008F4 */
+   /** Denali CTL_144 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_144; /* 0x00000900 */
+   /** Reserved */
+   unsigned int res_144[3]; /* 0x00000904 */
+   /** Denali CTL_145 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_145; /* 0x00000910 */
+   /** Reserved */
+   unsigned int res_145[3]; /* 0x00000914 */
+   /** Denali CTL_146 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_146; /* 0x00000920 */
+   /** Reserved */
+   unsigned int res_146[3]; /* 0x00000924 */
+   /** Denali CTL_147 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_147; /* 0x00000930 */
+   /** Reserved */
+   unsigned int res_147[3]; /* 0x00000934 */
+   /** Denali CTL_148 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_148; /* 0x00000940 */
+   /** Reserved */
+   unsigned int res_148[3]; /* 0x00000944 */
+   /** Denali CTL_149 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_149; /* 0x00000950 */
+   /** Reserved */
+   unsigned int res_149[3]; /* 0x00000954 */
+   /** Denali CTL_150 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_150; /* 0x00000960 */
+   /** Reserved */
+   unsigned int res_150[3]; /* 0x00000964 */
+   /** Denali CTL_151 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_151; /* 0x00000970 */
+   /** Reserved */
+   unsigned int res_151[3]; /* 0x00000974 */
+   /** Denali CTL_152 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_152; /* 0x00000980 */
+   /** Reserved */
+   unsigned int res_152[3]; /* 0x00000984 */
+   /** Denali CTL_153 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_153; /* 0x00000990 */
+   /** Reserved */
+   unsigned int res_153[3]; /* 0x00000994 */
+   /** Denali CTL_154 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_154; /* 0x000009A0 */
+   /** Reserved */
+   unsigned int res_154[3]; /* 0x000009A4 */
+   /** Denali CTL_155 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_155; /* 0x000009B0 */
+   /** Reserved */
+   unsigned int res_155[3]; /* 0x000009B4 */
+   /** Denali CTL_156 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_156; /* 0x000009C0 */
+   /** Reserved */
+   unsigned int res_156[3]; /* 0x000009C4 */
+   /** Denali CTL_157 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_157; /* 0x000009D0 */
+   /** Reserved */
+   unsigned int res_157[3]; /* 0x000009D4 */
+   /** Denali CTL_158 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_158; /* 0x000009E0 */
+   /** Reserved */
+   unsigned int res_158[3]; /* 0x000009E4 */
+   /** Denali CTL_159 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_159; /* 0x000009F0 */
+   /** Reserved */
+   unsigned int res_159[3]; /* 0x000009F4 */
+   /** Denali CTL_160 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_160; /* 0x00000A00 */
+   /** Reserved */
+   unsigned int res_160[3]; /* 0x00000A04 */
+   /** Denali CTL_161 register
+       There is a separate set of registers for each of the slices of data sent on the DFI data bus. */
+   unsigned int ctl_161; /* 0x00000A10 */
+   /** Reserved */
+   unsigned int res_161[379]; /* 0x00000A14 */
+};
+
+
+/* Fields of "Denali CTL_00 register" */
+/** Trigger auto-refresh at boundary specified by AUTO_REFRESH_MODE
+    Initiates an automatic refresh to the DRAM devices based on the setting of the auto_refresh_mode parameter. If there are any open banks when this parameter is set, the Denali Databahn Memory Controller will automatically close these banks before issuing the auto-refresh command. This parameter will always read back '0'. */
+#define CTL0_AREFRESH 0x01000000
+/* No-Operation
+#define CTL0_AREFRESH_NOP 0x00000000 */
+/** Trigger */
+#define CTL0_AREFRESH_TRIG 0x01000000
+/** Enable auto precharge mode of controller.
+    Enables auto pre-charge mode for DRAM devices. Auto pre-charge mode enabled: All read and write transactions must be terminated by an auto pre-charge command. If a transaction consists of multiple read or write bursts, only the last command is issued with an auto pre-charge.Auto pre-charge mode disabled. Memory banks will stay open until another request requires this bank, the maximum open time (tras_max) has elapsed, or a refresh command closes all the banks. Note: This parameter may not be modified after the start parameter has been asserted. */
+#define CTL0_AP 0x00010000
+/* Disable
+#define CTL0_AP_DIS 0x00000000 */
+/** Enable */
+#define CTL0_AP_EN 0x00010000
+/** Enable address collision detection for cmd queue placement logic.
+    Enables address collision/data coherency detection as a condition when using the placement logic to fill the command queue. */
+#define CTL0_ADDR_CMP_EN 0x00000100
+/* Disable
+#define CTL0_ADDR_CMP_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL0_ADDR_CMP_EN_EN 0x00000100
+/** Enable command aging in the command queue.
+    Enables aging of commands in the command queue when using the placement logic to fill the command queue. The total number of cycles required to decrement the priority value on a command by one is the product of the values in the age_count and command_age_count parameters. */
+#define CTL0_ACTIVE_AGING 0x00000001
+/* Disable
+#define CTL0_ACTIVE_AGING_DIS 0x00000000 */
+/** Enable */
+#define CTL0_ACTIVE_AGING_EN 0x00000001
+
+/* Fields of "Denali CTL_01 register" */
+/** Allow controller to issue cmds to other banks while a bank is in auto pre-charge.
+    Enables concurrent auto pre-charge. Some DRAM devices do not allow one bank to be auto pre-charged while another bank is reading or writing. The JEDEC standard allows concurrent auto pre-charge. Set this parameter for the DRAM device being used. */
+#define CTL1_CONCURRENTAP 0x01000000
+/* Disable
+#define CTL1_CONCURRENTAP_DIS 0x00000000 */
+/** Enable */
+#define CTL1_CONCURRENTAP_EN 0x01000000
+/** Set byte ordering as little endian or big endian.
+    Selects the byte ordering for Denali Databahn Memory Controllers with programmable endian setting. */
+#define CTL1_BIG_ENDIAN_EN 0x00010000
+/* Little Endian
+#define CTL1_BIG_ENDIAN_EN_LITTLE_ENDIAN 0x00000000 */
+/** Big Endian */
+#define CTL1_BIG_ENDIAN_EN_BIG_ENDIAN 0x00010000
+/** Enable bank splitting for cmd queue placement logic.
+    Enables bank splitting as a condition when using the placement logic to fill the command queue. */
+#define CTL1_BANK_SPLIT_EN 0x00000100
+/* Disable
+#define CTL1_BANK_SPLIT_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL1_BANK_SPLIT_EN_EN 0x00000100
+/** Define auto-refresh to occur at next burst or next cmd boundary.
+    Sets the mode for when the automatic refresh will occur. If auto_refresh_mode is set and a refresh is required to memory, the memory controller will delay this refresh until the end of the current transaction (if the transaction is fully contained inside a single page), or until the current transaction hits the end of the current page. */
+#define CTL1_AUTO_REFRESH_MODE 0x00000001
+/* Issue refresh on the next DRAM burst boundary even if the current command is not complete.
+#define CTL1_AUTO_REFRESH_MODE_BURST_BOUNDARY 0x00000000 */
+/** Issue refresh on the next command boundary. */
+#define CTL1_AUTO_REFRESH_MODE_CMD_BOUNDARY 0x00000001
+
+/* Fields of "Denali CTL_02 register" */
+/** Sets DQ/DQS output enable behavior when controller is idle.
+    Selects if the DQ output enables and DQS output enables will be driven active when the memory controller is in an idle state. */
+#define CTL2_DRIVE_DQ_DQS 0x01000000
+/* Leave the output enables de-asserted when idle.
+#define CTL2_DRIVE_DQ_DQS_LEAVE 0x00000000 */
+/** Drive the output enables active when idle. */
+#define CTL2_DRIVE_DQ_DQS_DRIVE 0x01000000
+/** Set DQS pin as single-ended or differential.
+    Enables differential data strobe signals from the DRAM. */
+#define CTL2_DQS_N_EN 0x00010000
+/* Single-ended DQS signal from the DRAM.
+#define CTL2_DQS_N_EN_SINGLE_ENDED 0x00000000 */
+/** Differential DQS signal from the DRAM. */
+#define CTL2_DQS_N_EN_DIFFERENTIAL 0x00010000
+/** Enable the DLL bypass feature of the controller.
+    Defines the behavior of the DLL bypass logic and establishes which set of delay parameters will be used. */
+#define CTL2_DLL_BYPASS_MODE 0x00000100
+/* Normal operational mode.
+#define CTL2_DLL_BYPASS_MODE_NORMAL 0x00000000 */
+/** Bypass the DLL master delay line. */
+#define CTL2_DLL_BYPASS_MODE_BYPASS 0x00000100
+/** Status of DLL lock coming out of master delay.
+    Shows status of the DLL as locked or unlocked. */
+#define CTL2_DLLLOCKREG 0x00000001
+
+/* Fields of "Denali CTL_03 register" */
+/** Allow the controller to interrupt an auto pre-charge cmd with another cmd.
+    Enables interrupting an auto pre-charge command with another command for a different bank. If enabled, the current operation will be interrupted. However, the bank will be pre-charged as if the current operation were allowed to continue. */
+#define CTL3_INTRPTAPBURST 0x01000000
+/* Disable
+#define CTL3_INTRPTAPBURST_DIS 0x00000000 */
+/** Enable */
+#define CTL3_INTRPTAPBURST_EN 0x01000000
+/** Define when write cmds are issued to DRAM devices.
+    Controls when the write commands are issued to the DRAM devices. */
+#define CTL3_FAST_WRITE 0x00010000
+/* The memory controller will issue a write command to the DRAM devices when it has received enough data for one DRAM burst. In this mode, write data can be sent in any cycle relative to the write command. This mode also allows for multi-word write command data to arrive in non-sequential cycles.
+#define CTL3_FAST_WRITE_SLOW 0x00000000 */
+/** The memory controller will issue a write command to the DRAM devices after the first word of the write data is received by the memory controller. The first word can be sent at any time relative to the write command. In this mode, multi-word write command data must be available to the memory controller in sequential cycles. */
+#define CTL3_FAST_WRITE_FAST 0x00010000
+/** Allow user to interrupt memory initialization to enter self-refresh mode.
+    When this bit is set, the memory initialization sequence will be interrupted and self-refresh mode will be entered. This is used to place the memory devices into self-refresh mode when a power loss is detected during the initialization process. */
+#define CTL3_ENABLE_QUICK_SREFRESH 0x00000100
+/* Disable
+#define CTL3_ENABLE_QUICK_SREFRESH_DIS 0x00000000 */
+/** Enable */
+#define CTL3_ENABLE_QUICK_SREFRESH_EN 0x00000100
+/** Number of banks on the DRAM(s).
+    Indicates that the memory devices have eight banks. */
+#define CTL3_EIGHT_BANK_MODE 0x00000001
+/* Memory devices have 4 banks.
+#define CTL3_EIGHT_BANK_MODE_FOUR_BANKS 0x00000000 */
+/** Memory devices have 8 banks. */
+#define CTL3_EIGHT_BANK_MODE_EIGHT_BANKS 0x00000001
+
+/* Fields of "Denali CTL_04 register" */
+/** Enable extra turnaround clock between back-to-back reads/writes to different chip selects.
+    Adds a turn-around clock between back-to-back reads or back-to-back writes to different chip selects. The additional clock may be needed at higher clock frequencies. The turn off and turn on time of termination resistors are not scalable. At higher clock frequencies, it is possible that these times may overlap, resulting in two active resistors while the DQS line is still active. This could compromise the signal integrity of the DQS signal. The additional clock prevents this overlap. */
+#define CTL4_ODT_ADD_TURN_CLK_EN 0x01000000
+/* Disable
+#define CTL4_ODT_ADD_TURN_CLK_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL4_ODT_ADD_TURN_CLK_EN_EN 0x01000000
+/** Disable DRAM cmds until TDLL has expired during initialization.
+    Disables DRAM commands until DLL initialization is complete and tdll has expired. */
+#define CTL4_NO_CMD_INIT 0x00010000
+/* Issue only REF and PRE commands during DLL initialization of the DRAM devices. If PRE commands are issued before DLL initialization is complete, the command will be executed immediately, and then the DLL initialization will continue.
+#define CTL4_NO_CMD_INIT_REFPRE 0x00000000 */
+/** Do not issue any type of command during DLL initialization of the DRAM devices. If any other commands are issued during the initialization time, they will be held off until DLL initialization is complete. */
+#define CTL4_NO_CMD_INIT_NOCMD 0x00010000
+/** Allow the controller to interrupt a combined write cmd with auto pre-charge with another write cmd.
+    Enables interrupting of a combined write with auto precharge command with another read or write command to the same bank before the first write command is completed. */
+#define CTL4_INTRPTWRITEA 0x00000100
+/* Disable
+#define CTL4_INTRPTWRITEA_DIS 0x00000000 */
+/** Enable */
+#define CTL4_INTRPTWRITEA_EN 0x00000100
+/** Allow the controller to interrupt a combined read with auto pre-charge cmd with another read cmd.
+    Enables interrupting of a combined read with auto precharge command with another read command to the same bank before the first read command is completed. */
+#define CTL4_INTRPTREADA 0x00000001
+/* Disable
+#define CTL4_INTRPTREADA_DIS 0x00000000 */
+/** Enable */
+#define CTL4_INTRPTREADA_EN 0x00000001
+
+/* Fields of "Denali CTL_05 register" */
+/** Enable priority for cmd queue placement logic.
+    Enables priority as a condition when using the placement logic to fill the command queue. */
+#define CTL5_PRIORITY_EN 0x01000000
+/* Disable
+#define CTL5_PRIORITY_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL5_PRIORITY_EN_EN 0x01000000
+/** Disable clock enable and set DRAMs in power-down state.
+    When this parameter is written with a '1', the memory controller will complete processing of the current burst for the current transaction (if any), issue a pre-charge all command and then disable the clock enable signal to the DRAM devices. Any subsequent commands in the command queue will be suspended until this parameter is written with a '0'. */
+#define CTL5_POWER_DOWN 0x00010000
+/* Enable full power state.
+#define CTL5_POWER_DOWN_FPS 0x00000000 */
+/** Disable the clock enable and power down the memory controller. */
+#define CTL5_POWER_DOWN_PDS 0x00010000
+/** Enable placement logic for cmd queue.
+    Enables using the placement logic to fill the command queue. */
+#define CTL5_PLACEMENT_EN 0x00000100
+/* Placement logic is disabled. The command queue is a straight FIFO.
+#define CTL5_PLACEMENT_EN_FIFO 0x00000000 */
+/** Placement logic is enabled. The command queue will be filled according to the placement logic factors. */
+#define CTL5_PLACEMENT_EN_PL 0x00000100
+/** Enable use of non- DFI odt_alt signal.
+    Enables the use of the non-DFI compliant alternative ODT internal signal odt_alt, which is externally viewed as the signal reserved0. This signal is only required if the user intends to use a CAS latency of 3 with ODT support. The user will need to modify the dmc_asic.v file for this support. Refer to Section 11.3.4, On-Die Termination in the DDR PHY Interface (DFI) Chapter for more information. */
+#define CTL5_ODT_ALT_EN 0x00000001
+/* ODT support with CAS latency 3 is not supported.
+#define CTL5_ODT_ALT_EN_NODTLAT3 0x00000000 */
+/** ODT support with CAS latency 3 is supported but is not DFI compliant. This disables the interrupt bit for ODT-with-CAS3 and disables the OVL error. */
+#define CTL5_ODT_ALT_EN_ODTLAT3 0x00000001
+
+/* Fields of "Denali CTL_06 register" */
+/** Enable read/write grouping for cmd queue placement logic.
+    Enables read/write grouping as a condition when using the placement logic to fill the command queue. */
+#define CTL6_RW_SAME_EN 0x01000000
+/* Disable
+#define CTL6_RW_SAME_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL6_RW_SAME_EN_EN 0x01000000
+/** Enable registered DIMM operation of the controller.
+    Enables registered DIMM operations to control the address and command pipeline of the memory controller. */
+#define CTL6_REG_DIMM_ENABLE 0x00010000
+/* Disable
+#define CTL6_REG_DIMM_ENABLE_DIS 0x00000000 */
+/** Enable */
+#define CTL6_REG_DIMM_ENABLE_EN 0x00010000
+/** Enable the half datapath feature of the controller.
+    Controls the width of the memory datapath. When enabled, the upper half of the memory buses (DQ, DQS and DM) are unused and relevant data only exists in the lower half of the buses. This parameter expands the Denali Databahn Memory Controller for use with memory devices of the configured width or half of the configured width. Note: The entire user datapath is used regardless of this setting. When operating in half datapath mode, only bstlen values of 4 and 8 are supported. For more information on half datapath mode, refer to the Other Databahn Features Chapter. */
+#define CTL6_REDUC 0x00000100
+/* Disable
+#define CTL6_REDUC_DIS 0x00000000 */
+/** Enable */
+#define CTL6_REDUC_EN 0x00000100
+/** Allow powerup via self-refresh instead of full memory initialization.
+    Allows controller to exit power-down mode by executing a self-refresh exit instead of the full memory initialization. This parameter provides a means to skip full initialization when the DRAM devices are in a known self-refresh state. */
+#define CTL6_PWRUP_SREFRESH_EXIT 0x00000001
+/* Disable
+#define CTL6_PWRUP_SREFRESH_EXIT_DIS 0x00000000 */
+/** Enable */
+#define CTL6_PWRUP_SREFRESH_EXIT_EN 0x00000001
+
+/* Fields of "Denali CTL_07 register" */
+/** Allow the controller to execute auto precharge cmds before TRAS_MIN expires.
+    Defines the tRAS lockout setting for the DRAM device. tRAS lockout allows the memory controller to execute auto pre-charge commands before the tras_min parameter has expired. */
+#define CTL7_TRAS_LOCKOUT 0x01000000
+/* tRAS lockout not supported by memory device.
+#define CTL7_TRAS_LOCKOUT_NTRASL 0x00000000 */
+/** tRAS lockout supported by memory device. */
+#define CTL7_TRAS_LOCKOUT_TRASL 0x01000000
+/** Enable command swapping logic in execution unit.
+    Enables swapping of the active command for a new higher-priority command when using the placement logic. */
+#define CTL7_SWAP_EN 0x00010000
+/* Disable
+#define CTL7_SWAP_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL7_SWAP_EN_EN 0x00010000
+/** Initiate cmd processing in the controller.
+    With this parameter set to b0, the memory controller will not issue any commands to the DRAM devices or respond to any signal activity except for reading and writing parameters. Once this parameter is set to b1, the memory controller will respond to inputs from the ASIC. When set, the memory controller begins its initialization routine. Note: The user must wait for the initialization complete bit to be set in the int_status parameter and for the dfi_init_complete signal to be asserted from the PHY before submitting any transactions. */
+#define CTL7_START 0x00000100
+/* Controller is not in active mode.
+#define CTL7_START_NOACT 0x00000000 */
+/** Initiate active mode for the memory controller. */
+#define CTL7_START_IACT 0x00000100
+/** Place DRAMs in self-refresh mode.
+    When this parameter is written with a b1, the DRAM device(s) will be placed in self-refresh mode. For this, the current burst for the current transaction (if any) will complete, all banks will be closed, the self-refresh command will be issued to the DRAM, and the clock enable signal will be de-asserted. The system will remain in self-refresh mode until this parameter is written with a b0. The DRAM devices will return to normal operating mode after the self-refresh exit time (txsr) of the device and any DLL initialization time for the DRAM is reached. The memory controller will resume processing of the commands from the interruption point. This parameter will be updated with an assertion of the srefresh_enter pin, regardless of the behavior on the register interface. To disable self-refresh again after a srefresh_enter pin assertion, the user will need to clear the parameter to b0. */
+#define CTL7_SREFRESH 0x00000001
+/* Disable self-refresh mode.
+#define CTL7_SREFRESH_DISSR 0x00000000 */
+/** Initiate self-refresh of the DRAM devices. */
+#define CTL7_SREFRESH_INITSR 0x00000001
+
+/* Fields of "Denali CTL_08 register" */
+/** Defines which chip selects are active.
+    Sets the mask that determines which chip select pins are active, with each bit representing a different chip select. The user address chip select field will be mapped into the active chip selects indicated by this parameter in ascending order from lowest to highest. This allows the memory controller to map the entire contiguous user address into any group of chip selects. Bit [0] of this parameter corresponds to chip select [0], bit [1] corresponds to chip select [1], etc. The number of chip selects, the number of bits set to 1 in this parameter, must be a power of 2 (20, 21, 22, etc.) */
+#define CTL8_CS_MAP_MASK 0x03000000
+/** field offset */
+#define CTL8_CS_MAP_OFFSET 24
+/** Write mode register data to the DRAMs. WRITE-ONLY
+    Supplies the EMRS data for each chip select to allow individual chips to set masked refreshing. When this parameter is written with a b1, the mode parameter(s) [EMRS register] within the DRAM devices will be written. Each subsequent write_modereg setting will write the EMRS register of the next chip select. This parameter will always read back as b0. The mode registers are automatically written at initialization of the memory controller. There is no need to initiate a mode register write after setting the start parameter in the memory controller unless some value in these registers needs to be changed after initialization. Note: This parameter may not be changed when the memory is in power-down mode (when the CKE input is de-asserted). */
+#define CTL8_WRITE_MODEREG 0x00010000
+/** Allow controller to interrupt a write burst to the DRAMs with a read cmd.
+    Defines whether the memory controller can interrupt a write burst with a read command. Some memory devices do not allow this functionality. */
+#define CTL8_WRITEINTERP 0x00000100
+/* The device does not support read commands interrupting write commands.
+#define CTL8_WRITEINTERP_NRIWB 0x00000000 */
+/** The device does support read commands interrupting write commands. */
+#define CTL8_WRITEINTERP_RIWB 0x00000100
+/** Issue auto-refresh cmds to the DRAMs every TREF cycles.
+    Enables refresh commands. If command refresh mode is configured, then refresh commands will be automatically issued based on the internal tref counter and any refresh commands sent through the command interface or the register interface. */
+#define CTL8_TREF_ENABLE 0x00000001
+/* Disable
+#define CTL8_TREF_ENABLE_DIS 0x00000000 */
+/** Enable */
+#define CTL8_TREF_ENABLE_EN 0x00000001
+
+/* Fields of "Denali CTL_09 register" */
+/** Determines which chip(s) will have termination when a read occurs on chip 0.
+    Sets up which (if any) chip(s) will have their ODT termination active while a read occurs on chip select 0. Note: Only one chip select (and therefore 1 bit) may be set at any time. Example: If the system consists of 4 chip selects and odt_rd_map_cs0 is set to b0010, then when CS0 is performing a read, CS1 will have active ODT termination. And if odt_rd_map_cs0 was set to b1000, then instead CS3 would be active. Bit [3] = CS3 will have active ODT termination when chip select 0 is performing a read. Bit [2] = CS2 will have active ODT termination when chip select 0 is performing a read. Bit [1] = CS1 will have active ODT termination when chip select 0 is performing a read. Bit [0] = CS0 will have active ODT termination when chip select 0 is performing a read. Etc. */
+#define CTL9_ODT_RD_MAP_CS0_MASK 0x03000000
+/** field offset */
+#define CTL9_ODT_RD_MAP_CS0_OFFSET 24
+/** Maximum number of chip selects available. READONLY
+    Displays the maximum number of chip selects configured for this memory controller. This parameter is read-only. */
+#define CTL9_MAX_CS_REG_MASK 0x00030000
+/** field offset */
+#define CTL9_MAX_CS_REG_OFFSET 16
+/** Enable refreshes while in low power mode.
+    Sets whether refreshes will occur while the memory controller is in any of the low power modes. */
+#define CTL9_LOWPOWER_REFRESH_ENABLE_MASK 0x00000300
+/** field offset */
+#define CTL9_LOWPOWER_REFRESH_ENABLE_OFFSET 8
+/** Refreshes still occur */
+#define CTL9_LOWPOWER_REFRESH_ENABLE_LPREF 0x00000000
+/** Refreshes do not occur */
+#define CTL9_LOWPOWER_REFRESH_ENABLE_LPNREF 0x00000100
+/** Set value for dfi_dram_clk_disable.
+    Sets value for the DFI output signal dfi_dram_clk_disable. Bit [0] controls CS0, Bit [1] controls CS1. For each bit: */
+#define CTL9_DRAM_CLK_DISABLE_MASK 0x00000003
+/** field offset */
+#define CTL9_DRAM_CLK_DISABLE_OFFSET 0
+/** Memory clock/s should be active. */
+#define CTL9_DRAM_CLK_DISABLE_CLKACT 0x00000000
+/** Memory clock/s should be disabled. */
+#define CTL9_DRAM_CLK_DISABLE_CLKDIS 0x00000001
+
+/* Fields of "Denali CTL_10 register" */
+/** On-Die termination resistance setting for all DRAM devices.
+    Defines the On-Die termination resistance for all DRAM devices. The Denali Databahn Memory Controller can not be set for different termination values for each chip select. Note: The user must program the same values into the A6/A2 bits of emrs1_data_X and rtt_0. */
+#define CTL_10_RTT_0_MASK 0x03000000
+/** field offset */
+#define CTL_10_RTT_0_OFFSET 24
+/** Disable */
+#define CTL_10_RTT_0_DIS 0x00000000
+/** 75 Ohm */
+#define CTL_10_RTT_0_OHM_75 0x01000000
+/** 150 Ohm */
+#define CTL_10_RTT_0_OHM_150 0x02000000
+/** Determines which chip(s) will have termination when a write occurs on chip 1.
+    Sets up which (if any) chip(s) will have their ODT termination active while a write occurs on chip select 1. Note: Only one chip select (and therefore 1 bit) may be set at any time. Example: If the system consists of 4 chip selects and odt_wr_map_cs0 is set to b0010, then when CS0 is performing a write, CS1 will have active ODT termination. And if odt_wr_map_cs0 was set to b1000, then instead CS3 would be active. Bit [3] = CS3 will have active ODT termination when chip select 1 is performing a write. Bit [2] = CS2 will have active ODT termination when chip select 1 is performing a write. Bit [1] = CS1 will have active ODT termination when chip select 1 is performing a write. Bit [0] = CS0 will have active ODT termination when chip select 1 is performing a write. Etc. */
+#define CTL_10_ODT_WR_MAP_CS1_MASK 0x00030000
+/** field offset */
+#define CTL_10_ODT_WR_MAP_CS1_OFFSET 16
+/** Determines which chip(s) will have termination when a write occurs on chip 1.
+    Sets up which (if any) chip(s) will have their ODT termination active while a write occurs on chip select 0. Note: Only one chip select (and therefore 1 bit) may be set at any time. Example: If the system consists of 4 chip selects and odt_wr_map_cs0 is set to b0010, then when CS0 is performing a write, CS1 will have active ODT termination. And if odt_wr_map_cs0 was set to b1000, then instead CS3 would be active. Bit [3] = CS3 will have active ODT termination when chip select 0 is performing a write. Bit [2] = CS2 will have active ODT termination when chip select 0 is performing a write. Bit [1] = CS1 will have active ODT termination when chip select 0 is performing a write. Bit [0] = CS0 will have active ODT termination when chip select 0 is performing a write. Etc. */
+#define CTL_10_ODT_WR_MAP_CS0_MASK 0x00000300
+/** field offset */
+#define CTL_10_ODT_WR_MAP_CS0_OFFSET 8
+/** Determines which chip(s) will have termination when a read occurs on chip 1.
+    Sets up which (if any) chip(s) will have their ODT termination active while a read occurs on chip select 1. Note: Only one chip select (and therefore 1 bit) may be set at any time. Example: If the system consists of 4 chip selects and odt_rd_map_cs0 is set to b0010, then when CS0 is performing a read, CS1 will have active ODT termination. And if odt_rd_map_cs0 was set to b1000, then instead CS3 would be active. Bit [3] = CS3 will have active ODT termination when chip select 1 is performing a read. Bit [2] = CS2 will have active ODT termination when chip select 1 is performing a read. Bit [1] = CS1 will have active ODT termination when chip select 1 is performing a read. Bit [0] = CS0 will have active ODT termination when chip select 1 is performing a read. Etc. */
+#define CTL_10_ODT_RD_MAP_CS1_MASK 0x00000003
+/** field offset */
+#define CTL_10_ODT_RD_MAP_CS1_OFFSET 0
+
+/* Fields of "Denali CTL_11 register" */
+/** Difference between number of column pins available and number being used.
+    Shows the difference between the maximum column width available (12) and the actual number of column pins being used. The user address is automatically shifted so that the user address space is mapped contiguously into the memory map based on the value of this parameter. For details, refer to the Databahn Address Mapping Chapter. */
+#define CTL_11_COLUMN_SIZE_MASK 0x07000000
+/** field offset */
+#define CTL_11_COLUMN_SIZE_OFFSET 24
+/** Additional cycles to delay CKE for status reporting.
+    Sets the number of additional cycles of delay to include in the CKE signal cke_status for status reporting. The default delay is 0 cycles. */
+#define CTL_11_CKE_DELAY_MASK 0x00070000
+/** field offset */
+#define CTL_11_CKE_DELAY_OFFSET 16
+/** Encoded CAS latency sent to DRAMs during initialization.
+    Sets the CAS (Column Address Strobe) latency encoding that the memory uses. The binary value programmed into this parameter is dependent on the memory device, since the same caslat value may have different meanings to different memories. This will be programmed into the DRAM devices at initialization. The CAS encoding will be specified in the DRAM spec sheet, and should correspond to the caslat_lin parameter. Refer to the files in the regconfigs/ directory in the release for actual settings for each particular device. Note: For optimal synthesis behavior, the ODT path for a CAS latency of three is clocked at a 200 MHz clock regardless of configured maximum speed. */
+#define CTL_11_CASLAT_MASK 0x00000700
+/** field offset */
+#define CTL_11_CASLAT_OFFSET 8
+/** Difference between number of addr pins available and number being used.
+    Defines the difference between the maximum number of address pins configured (14) and the actual number of pins being used. The user address is automatically shifted so that the user address space is mapped contiguously into the memory map based on the value of this parameter. For details, refer to the Databahn Address Mapping Chapter. */
+#define CTL_11_ADDR_PINS_MASK 0x00000007
+/** field offset */
+#define CTL_11_ADDR_PINS_OFFSET 0
+
+/* Fields of "Denali CTL_12 register" */
+/** Delay from DFI clock disable to memory clock disable.
+    Holds the DFI tdram_clk_disable timing parameter. This parameter should be programmed with the number of cycles that the PHY requires to disable the clock after the dfi_dram_clk_disable signal is asserted. */
+#define CTL_12_TDFI_DRAM_CLK_DISABLE_MASK 0x07000000
+/** field offset */
+#define CTL_12_TDFI_DRAM_CLK_DISABLE_OFFSET 24
+/** Minimum CKE pulse width.
+    Defines the minimum CKE pulse width, in cycles. */
+#define CTL_12_TCKE_MASK 0x00070000
+/** field offset */
+#define CTL_12_TCKE_OFFSET 16
+/** Quantity that determines cmd queue full.
+    Defines quantity of data that will be considered full for the command queue. */
+#define CTL_12_Q_FULLNESS_MASK 0x00000700
+/** field offset */
+#define CTL_12_Q_FULLNESS_OFFSET 8
+/** Type of cmd that caused an Out-of- Range interrupt. READ-ONLY
+    Holds the type of command that caused an out-of-range interrupt request to the memory devices. This parameter is read-only. For more information on out-of-range address checking, refer to the Other Databahn Features Chapter. */
+#define CTL_12_OUT_OF_RANGE_TYPE_MASK 0x00000007
+/** field offset */
+#define CTL_12_OUT_OF_RANGE_TYPE_OFFSET 0
+
+/* Fields of "Denali CTL_13 register" */
+/** Additional clocks of delay to insert between writes and reads to the same chip select.
+    Defines the number of additional clocks of delay to insert between a write and a read to the same chip selects. The registers in the memory controller must be configured before the DRAM devices can be accessed. */
+#define CTL_13_W2R_SAMECS_DLY_MASK 0x07000000
+/** field offset */
+#define CTL_13_W2R_SAMECS_DLY_OFFSET 24
+/** Additional clocks of delay to insert between writes and reads to different chip selects.
+    Defines the number of additional clocks of delay to insert between a write and a read to the different chip select. */
+#define CTL_13_W2R_DIFFCS_DLY_MASK 0x00070000
+/** field offset */
+#define CTL_13_W2R_DIFFCS_DLY_OFFSET 16
+/** DRAM TRTP parameter in cycles.
+    Defines the DRAM tRTP (read to pre-charge time) parameter, in cycles. */
+#define CTL_13_TRTP_MASK 0x00000700
+/** field offset */
+#define CTL_13_TRTP_OFFSET 8
+/** DRAM TRRD parameter in cycles.
+    Defines the DRAM activate to activate delay for different banks, in cycles. */
+#define CTL_13_TRRD_MASK 0x00000007
+/** field offset */
+#define CTL_13_TRRD_OFFSET 0
+
+/* Fields of "Denali CTL_14 register" */
+/** Adjusts data capture gate open by half cycles.
+    Adjusts the data capture gate open time by 1/2 cycle increments. This parameter is programmed differently than caslat_lin when there are fixed offsets in the flight path between the memories and the memory controller for clock gating. When caslat_lin_gate is a larger value than caslat_lin, the data capture window will become shorter. A caslat_lin_gate value smaller than caslat_lin may have no effect on the data capture window, depending on the fixed offsets in the ASIC and the board. Note: For optimal synthesis behavior, the ODT path for a CAS latency of three is clocked at a 200 MHz clock regardless of configured maximum speed. b0000 - b0001 = Reserved */
+#define CTL_14_CASLAT_LIN_GATE_MASK 0x0F000000
+/** field offset */
+#define CTL_14_CASLAT_LIN_GATE_OFFSET 24
+/** 1 cycle */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_1 0x02000000
+/** 1.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_1_5 0x03000000
+/** 2 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_2 0x04000000
+/** 2.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_2_5 0x05000000
+/** 3 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_3 0x06000000
+/** 3.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_3_5 0x07000000
+/** 4 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_4 0x08000000
+/** 4.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_4_5 0x09000000
+/** 5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_5 0x0A000000
+/** 5.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_5_5 0x0B000000
+/** 6 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_6 0x0C000000
+/** 6.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_6_5 0x0D000000
+/** 7 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_7 0x0E000000
+/** 7.5 cycles */
+#define CTL_14_CASLAT_LIN_GATE_CYCLES_7_5 0x0F000000
+/** Sets latency from read cmd send to data receive from/to controller.
+    Sets the CAS latency linear value in 1/2 cycle increments. This sets an internal adjustment for the delay from when the read command is sent from the memory controller to when data will be received back. The window of time in which the data is captured is a fixed length. The caslat_lin parameter adjusts the start of this data capture window. Not all linear values will be supported for the memory devices being used. Refer to the specification for the memory devices being used. Note: For optimal synthesis behavior, the ODT path for a CAS latency of three is clocked at a 200 MHz clock regardless of configured maximum speed. */
+#define CTL_14_CASLAT_LIN_MASK 0x000F0000
+/** field offset */
+#define CTL_14_CASLAT_LIN_OFFSET 16
+/** 1 cycle */
+#define CTL_14_CASLAT_LIN_CYCLES_1 0x00020000
+/** 1.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_1_5 0x00030000
+/** 2 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_2 0x00040000
+/** 2.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_2_5 0x00050000
+/** 3 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_3 0x00060000
+/** 3.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_3_5 0x00070000
+/** 4 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_4 0x00080000
+/** 4.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_4_5 0x00090000
+/** 5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_5 0x000A0000
+/** 5.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_5_5 0x000B0000
+/** 6 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_6 0x000C0000
+/** 6.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_6_5 0x000D0000
+/** 7 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_7 0x000E0000
+/** 7.5 cycles */
+#define CTL_14_CASLAT_LIN_CYCLES_7_5 0x000F0000
+/** Location of the auto pre-charge bit in the DRAM address.
+    Defines the location of the auto pre-charge bit in the DRAM address in decimal encoding. */
+#define CTL_14_APREBIT_MASK 0x00000F00
+/** field offset */
+#define CTL_14_APREBIT_OFFSET 8
+/** Initial value of master aging-rate counter for cmd aging.
+    Holds the initial value of the master aging-rate counter. When using the placement logic to fill the command queue, the command aging counters will be decremented one each time the master aging-rate counter counts down age_count cycles. */
+#define CTL_14_AGE_COUNT_MASK 0x0000000F
+/** field offset */
+#define CTL_14_AGE_COUNT_OFFSET 0
+
+/* Fields of "Denali CTL_15 register" */
+/** Maximum width of column address in DRAMs. READONLY
+    Defines the maximum width of column address in the DRAM devices. This value can be used to set the column_size parameter. This parameter is read-only. column_size = max_col_reg - [number of column bits in memory device]. */
+#define CTL_15_MAX_COL_REG_MASK 0x0F000000
+/** field offset */
+#define CTL_15_MAX_COL_REG_OFFSET 24
+/** Number of autorefresh cmds to execute during DRAM initialization.
+    Defines the number of auto-refresh commands needed by the DRAM devices to satisfy the initialization sequence. */
+#define CTL_15_INITAREF_MASK 0x000F0000
+/** field offset */
+#define CTL_15_INITAREF_OFFSET 16
+/** Defines the mode of operation of the controller.
+    Selects the mode of operation for the Denali Databahn Memory Controller. All other settings reserved. */
+#define CTL_15_DRAM_CLASS_MASK 0x00000F00
+/** field offset */
+#define CTL_15_DRAM_CLASS_OFFSET 8
+/** DDR1 */
+#define CTL_15_DRAM_CLASS_DDR1 0x00000000
+/** DDR2 */
+#define CTL_15_DRAM_CLASS_DDR2 0x00000400
+/** Initial value of individual cmd aging counters for cmd aging.
+    Holds the initial value of the command aging counters associated with each command in the command queue. When using the placement logic to fill the command queue, the command aging counters decrement one each time the master aging-rate counter counts down age_count cycles. */
+#define CTL_15_COMMAND_AGE_COUNT_MASK 0x0000000F
+/** field offset */
+#define CTL_15_COMMAND_AGE_COUNT_OFFSET 0
+
+/* Fields of "Denali CTL_16 register" */
+/** Holds the DFI tCTRLUPD_MIN timing parameter. READ-ONLY
+    Holds the DFI tctrlupd_min timing parameter. This parameter is read-only. */
+#define CTL_16_TDFI_CTRLUPD_MIN_MASK 0x0F000000
+/** field offset */
+#define CTL_16_TDFI_CTRLUPD_MIN_OFFSET 24
+/** Adjustment value for PHY read timing.
+    Adjusts the relative timing between DFI read commands and the dfi_rddata_en signal to conform to PHY timing requirements. When this parameter is programmed to 0x0, dfi_rddata_en will assert one cycle after the dfi_address. */
+#define CTL_16_RDLAT_ADJ_MASK 0x000F0000
+/** field offset */
+#define CTL_16_RDLAT_ADJ_OFFSET 16
+/** Source ID of cmd that caused an Outof- Range interrupt. READ-ONLY
+    Holds the Source ID of the command that caused an outof- range interrupt request to the memory devices. This parameter is read-only. For more information on out-of-range address checking, refer to the Other Databahn Features Chapter. */
+#define CTL_16_OUT_OF_RANGE_SOURCE_ID_MASK 0x00000F00
+/** field offset */
+#define CTL_16_OUT_OF_RANGE_SOURCE_ID_OFFSET 8
+/** Maximum width of memory address bus. READ-ONLY
+    Defines the maximum width of the memory address bus (number of row bits) for the memory controller. This value can be used to set the addr_pins parameter. This parameter is read-only. addr_pins = max_row_reg - [number of row bits in memory device]. */
+#define CTL_16_MAX_ROW_REG_MASK 0x0000000F
+/** field offset */
+#define CTL_16_MAX_ROW_REG_OFFSET 0
+
+/* Fields of "Denali CTL_17 register" */
+/** Holds the calculated DFI tPHY_WRLAT timing parameter. READ-ONLY
+    Holds the calculated value of the tphy_wrlat timing parameter. This equation is dependent on the latency setting for the address / control path of the PHY as set in the phy_ctrl_reg_2 [25] parameter bit. If phy_ctrl_reg_2 [25] = 0: ..... If (tdfi_phy_wrlat_base + wrlat_adj) = 2: .......... tdfi_phy_wrlat = reg_dimm_enable;..... If (tdfi_phy_wrlat_base + wrlat_adj) 2: .......... tdfi_phy_wrlat = tdfi_phy_wrlat_base + wrlat_adj + reg_dimm_enable - WRLAT_WIDTH'h3 Note: Values of (tdfi_phy_wrlat_base + wrlat_adj) If phy_ctrl_reg_2 [25] = 1: ..... If (tdfi_phy_wrlat_base + wrlat_adj) .......... tdfi_phy_wrlat = reg_dimm_enable; ..... If (tdfi_phy_wrlat_base + wrlat_adj)= 4: .......... tdfi_phy_wrlat = tdfi_phy_wrlat_base + wrlat_adj + reg_dimm_enable - WRLAT_WIDTH'h4;This parameter is read-only. */
+#define CTL_17_TDFI_PHY_WRLAT_MASK 0x0F000000
+/** field offset */
+#define CTL_17_TDFI_PHY_WRLAT_OFFSET 24
+/** Holds the tPHY_RDLAT timing parameter.
+    Holds the tphy_rdlat timing parameter. */
+#define CTL_17_TDFI_PHY_RDLAT_MASK 0x000F0000
+/** field offset */
+#define CTL_17_TDFI_PHY_RDLAT_OFFSET 16
+/** Delay from DFI clock enable to memory clock enable.
+    Holds the DFI tdram_clk_enable timing parameter. This parameter is currently unused in the Denali Databahn Memory Controller. */
+#define CTL_17_TDFI_DRAM_CLK_ENABLE_MASK 0x00000F00
+/** field offset */
+#define CTL_17_TDFI_DRAM_CLK_ENABLE_OFFSET 8
+/** Delay from DFI command to memory command.
+    Holds the DFI tctrl_delay timing parameter. This parameter should be programmed with the number of cycles that the PHY requires to send a power-down or self-refresh command to the DRAM devices. */
+#define CTL_17_TDFI_CTRL_DELAY_MASK 0x0000000F
+/** field offset */
+#define CTL_17_TDFI_CTRL_DELAY_OFFSET 0
+
+/* Fields of "Denali CTL_18 register" */
+/** DRAM TRP parameter in cycles.
+    Defines the DRAM pre-charge command time, in cycles. */
+#define CTL_18_TRP_MASK 0x0F000000
+/** field offset */
+#define CTL_18_TRP_OFFSET 24
+/** Sets DFI base value for the tRDDATA_EN timing parameter.
+    Used to adjust the tdfi_rddata_en parameter if the PHY requires greater delay from read command to read data enable. */
+#define CTL_18_TDFI_RDDATA_EN_BASE_MASK 0x000F0000
+/** field offset */
+#define CTL_18_TDFI_RDDATA_EN_BASE_OFFSET 16
+/** Holds the calculated DFI tRDDATA_EN timing parameter. READ-ONLY
+    Holds the calculated value of the trddata_en timing parameter. This equation is dependent on the latency setting for the address / control path of the PHY as set in the phy_ctrl_reg_2 [25] parameter bit. If phy_ctrl_reg_2 [25] = 0: ..... If (tdfi_rddata_en_base + rdlat_adj) = 2: .......... tdfi_rddata_en = reg_dimm_enable; ..... If (tdfi_rddata_en_base + rdlat_adj) 2: .......... tdfi_rddata_en = tdfi_rddata_en_base + rdlat_adj + reg_dimm_enable - RDLAT_WIDTH'h3 Note: Values of (tdfi_rddata_en_base + rdlat_adj) If phy_ctrl_reg_2 [25] = 1:..... If (tdfi_rddata_en_base + rdlat_adj) .......... tdfi_rddata_en = reg_dimm_enable;..... If (tdfi_rddata_en_base + rdlat_adj) = 4: .......... tdfi_rddata_en = tdfi_rddata_en_base + rdlat_adj + reg_dimm_enable - RDLAT_WIDTH'h4This parameter is read-only. */
+#define CTL_18_TDFI_RDDATA_EN_MASK 0x00000F00
+/** field offset */
+#define CTL_18_TDFI_RDDATA_EN_OFFSET 8
+/** Sets DFI base value for the tPHY_WRLAT timing parameter.
+    Used to adjust the tdfi_phy_wrlat parameter if the PHY requires greater delay from write command to write data. */
+#define CTL_18_TDFI_PHY_WRLAT_BASE_MASK 0x0000000F
+/** field offset */
+#define CTL_18_TDFI_PHY_WRLAT_BASE_OFFSET 0
+
+/* Fields of "Denali CTL_19 register" */
+/** Enables automatic entry into the low power mode on idle.
+    Enables automatic entry into the low power modes of the memory controller. Bit [4] = Controls memory power-down mode (Mode 1). Bit [3] = Controls memory power-down with memory clock gating mode (Mode 2). Bit [2] = Controls memory self-refresh mode (Mode 3). Bit [1] = Controls memory self-refresh with memory clock gating mode (Mode 4). Bit [0] = Controls memory self-refresh with memory and controller clock gating mode (Mode 5). For all bits: */
+#define CTL_19_LOWPOWER_AUTO_ENABLE_MASK 0x1F000000
+/** field offset */
+#define CTL_19_LOWPOWER_AUTO_ENABLE_OFFSET 24
+/** Automatic entry into this mode is disabled. The user may enter this mode manually by setting the associated lowpower_control bit. */
+#define CTL_19_LOWPOWER_AUTO_ENABLE_AUTODIS 0x00000000
+/** Automatic entry into this mode is enabled. The mode will be entered automatically when the proper counters expire, and only if the associated lowpower_control bit is set. */
+#define CTL_19_LOWPOWER_AUTO_ENABLE_AUTOEN 0x01000000
+/** Adjustment value for PHY write timing.
+    Adjusts the relative timing between DFI write commands and the dfi_wrdata_en signal to conform to PHY timing requirements. When this parameter is programmed to 0x0, dfi_wrdata_en will assert on the same cycle as the dfi_address. */
+#define CTL_19_WRLAT_ADJ_MASK 0x000F0000
+/** field offset */
+#define CTL_19_WRLAT_ADJ_OFFSET 16
+/** DRAM WRLAT parameter in cycles.
+    Defines the write latency from when the write command is issued to the time the write data is presented to the DRAM devices, in cycles. Note: This parameter must be set to 0x1 when the Denali Databahn Memory Controller is used in DDR1 mode. */
+#define CTL_19_WRLAT_MASK 0x00000F00
+/** field offset */
+#define CTL_19_WRLAT_OFFSET 8
+/** DRAM TWTR parameter in cycles.
+    Sets the number of cycles needed to switch from a write to a read operation, as dictated by the DDR SDRAM specification. */
+#define CTL_19_TWTR_MASK 0x0000000F
+/** field offset */
+#define CTL_19_TWTR_OFFSET 0
+
+/* Fields of "Denali CTL_20 register" */
+/** DRAM TDAL parameter in cycles.
+    Defines the auto pre-charge write recovery time when auto pre-charge is enabled (ap is set), in cycles. This is defined internally as tRP (pre-charge time) + auto precharge write recovery time. Not all memories use this parameter. If tDAL is defined in the memory specification, then program this parameter to the specified value. If the memory does not specify a tDAL time, then program this parameter to tWR + tRP. DO NOT program this parameter with a value of 0x0 or the memory controller will not function properly when auto pre-charge is enabled. */
+#define CTL_20_TDAL_MASK 0x1F000000
+/** field offset */
+#define CTL_20_TDAL_OFFSET 24
+/** OCD pull-up adjust setting for DRAMs for chip select 0.
+    Sets the off-chip driver (OCD) pull-up adjustment settings for the DRAM devices. The memory controller will issue OCD adjust commands to the DRAM devices during power up. Bit [4] = Increment(1) or decrement(0) OCD settings. Bits [3:0] = Number of OCD adjust commands to issue. */
+#define CTL_20_OCD_ADJUST_PUP_CS_0_MASK 0x001F0000
+/** field offset */
+#define CTL_20_OCD_ADJUST_PUP_CS_0_OFFSET 16
+/** OCD pull-down adjust setting for DRAMs for chip select 0.
+    Sets the off-chip driver (OCD) pull-down adjustment settings for the DRAM devices. The memory controller will issue OCD adjust commands to the DRAM devices during power up. Bit [4] = Increment(1) or decrement(0) OCD settings. Bits [3:0] = Number of OCD adjust commands to issue. */
+#define CTL_20_OCD_ADJUST_PDN_CS_0_MASK 0x00001F00
+/** field offset */
+#define CTL_20_OCD_ADJUST_PDN_CS_0_OFFSET 8
+/** Controls entry into the low power modes.
+    Enables the individual low power modes of the device. Bit [4] = Controls memory power-down mode (Mode 1). Bit [3] = Controls memory power-down with memory clock gating mode (Mode 2). Bit [2] = Controls memory self-refresh mode (Mode 3). Bit [1] = Controls memory self-refresh with memory clock gating mode (Mode 4). Bit [0] = Controls memory self-refresh with memory and controller clock gating mode (Mode 5). For all bits: */
+#define CTL_20_LOWPOWER_CONTROL_MASK 0x0000001F
+/** field offset */
+#define CTL_20_LOWPOWER_CONTROL_OFFSET 0
+/** Disable */
+#define CTL_20_LOWPOWER_CONTROL_DIS 0x00000000
+/** Enable */
+#define CTL_20_LOWPOWER_CONTROL_EN 0x00000001
+
+/* Fields of "Denali CTL_21 register" */
+/** DRAM TWR parameter in cycles.
+    Defines the DRAM write recovery time, in cycles. */
+#define CTL_21_TWR_INT_MASK 0x1F000000
+/** field offset */
+#define CTL_21_TWR_INT_OFFSET 24
+/** DRAM TRC parameter in cycles.
+    Defines the DRAM period between active commands for the same bank, in cycles. */
+#define CTL_21_TRC_MASK 0x001F0000
+/** field offset */
+#define CTL_21_TRC_OFFSET 16
+/** DRAM TMRD parameter in cycles.
+    Defines the minimum number of cycles required between two mode register write commands. This is the time required to complete the write operation to the mode register. */
+#define CTL_21_TMRD_MASK 0x00001F00
+/** field offset */
+#define CTL_21_TMRD_OFFSET 8
+/** DRAM TFAW parameter in cycles.
+    Defines the DRAM tFAW parameter, in cycles. */
+#define CTL_21_TFAW_MASK 0x0000001F
+/** field offset */
+#define CTL_21_TFAW_OFFSET 0
+
+/* Fields of "Denali CTL_22 register" */
+/** Status of interrupt features in the controller. READONLY
+    Shows the status of all possible interrupts generated by the memory controller. The MSB is the result of a logical OR of all the lower bits. This parameter is read-only. Note: Backwards compatibility is available for register parameters across configurations. However, even with this compatibility, the individual bits, their meaning and the size of the int_status parameter may change. The int_status bits correspond to these interrupts: Bit [6] = Logical OR of all lower bits. Bit [5] = DLL unlock condition detected. Bit [4] = Indicates that a read DQS gate error occurred. Bit [3] = ODT enabled and CAS Latency 3 programmed error detected. This is an unsupported programming option. Bit [2] = DRAM initialization complete. Bit [1] = Multiple accesses outside the defined PHYSICAL memory space detected. Bit [0] = A single access outside the defined PHYSICAL memory space detected. */
+#define CTL_22_INT_STATUS_MASK 0x7F000000
+/** field offset */
+#define CTL_22_INT_STATUS_OFFSET 24
+/** Mask for controller_int signals from the INT_STATUS parameter.
+    Active-high mask bits that control the value of the memory controller_int signal on the ASIC interface. Unless the user has suppressed interrupt reporting (by setting bit [6] of this parameter to 'b1), bits [5:0] of the int_mask parameter will be inverted and logically AND'ed with bits [5:0] of the int_status parameter and the result is reported on the controller_int signal. */
+#define CTL_22_INT_MASK_MASK 0x007F0000
+/** field offset */
+#define CTL_22_INT_MASK_OFFSET 16
+/** Length of cmd that caused an Out-of- Range interrupt. READ-ONLY
+    Holds the length of the command that caused an out-of-range interrupt request to the memory devices. This parameter is read-only. For more information on out-of-range address checking, refer to the Other Databahn Features Chapter. */
+#define CTL_22_OUT_OF_RANGE_LENGTH_MASK 0x00003F00
+/** field offset */
+#define CTL_22_OUT_OF_RANGE_LENGTH_OFFSET 8
+/** Clear mask of the INT_STATUS parameter.
+    Controls the clearing of the int_status parameter. If any of the int_ack bits are set to a '1' the corresponding bit in the int_status parameter will be set to '0' Any int_ack bits written with a '0' will not alter the corresponding bit in the int_status parameter. This parameter will always read back as '0'. */
+#define CTL_22_INT_ACK_MASK 0x0000003F
+/** field offset */
+#define CTL_22_INT_ACK_OFFSET 0
+
+/* Fields of "Denali CTL_23 register" */
+/** DRAM TRAS_MIN parameter in cycles.
+    Defines the DRAM minimum row activate time, in cycles. */
+#define CTL_23_TRAS_MIN_MASK 0xFF000000
+/** field offset */
+#define CTL_23_TRAS_MIN_OFFSET 24
+/** Number of clock cycles after MRS command and before any other command.
+    Defines the number of cycles of wait time after a mode register write to any non-mode register write command. For write leveling, this is defined as the number of cycles of wait time after a MRS command to the ODT enable. */
+#define CTL_23_TMOD_MASK 0x00FF0000
+/** field offset */
+#define CTL_23_TMOD_OFFSET 16
+/** Minimum number of cycles after setting master delay in DLL until reset is released.
+    Specifies the minimum number of cycles after the master delay value is programmed before the DLL reset may be asserted. */
+#define CTL_23_DLL_RST_ADJ_DLY_MASK 0x0000FF00
+/** field offset */
+#define CTL_23_DLL_RST_ADJ_DLY_OFFSET 8
+/** Number of delay elements in master DLL lock.
+    Defines the actual number of delay elements used to capture one full clock cycle. This parameter is automatically updated every time a refresh operation is performed. This parameter is read-only. */
+#define CTL_23_DLL_LOCK_MASK 0x000000FF
+/** field offset */
+#define CTL_23_DLL_LOCK_OFFSET 0
+
+/* Fields of "Denali CTL_24 register" */
+/** Data to program into memory mode register 1 for chip select 0.
+    Holds the EMRS1 data written during memory initialization for chip select 0. The contents of this parameter will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. Note that the Denali Databahn Memory Controller does not support additive latency. Therefore, the user should ensure that the additive latency bits are cleared to b0. For DDR2 memories, these are bits A5:A3. Note: The user must program the same values into the A6/A2 bits of emrs1_data_0 and rtt_0. */
+#define CTL_24_EMRS1_DATA_0_MASK 0x3FFF0000
+/** field offset */
+#define CTL_24_EMRS1_DATA_0_OFFSET 16
+/** DRAM TRFC parameter in cycles.
+    Defines the DRAM refresh command time, in cycles. */
+#define CTL_24_TRFC_MASK 0x0000FF00
+/** field offset */
+#define CTL_24_TRFC_OFFSET 8
+/** DRAM TRCD parameter in cycles.
+    Defines the DRAM RAS to CAS delay, in cycles */
+#define CTL_24_TRCD_INT_MASK 0x000000FF
+/** field offset */
+#define CTL_24_TRCD_INT_OFFSET 0
+
+/* Fields of "Denali CTL_25 register" */
+/** Data to program into memory mode register 2 for chip select 0.
+    Holds the EMRS2 data written during memory initialization for chip select 0. The contents of this parameter will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. */
+#define CTL_25_EMRS2_DATA_0_MASK 0x3FFF0000
+/** field offset */
+#define CTL_25_EMRS2_DATA_0_OFFSET 16
+/** Data to program into memory mode register 1 for chip select 1.
+    Holds the EMRS1 data written during memory initialization for chip select 1. The contents of this parameter will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. Note that the Denali Databahn Memory Controller does not support additive latency. Therefore, the user should ensure that the additive latency bits are cleared to b0. For DDR2 memories, these are bits A5:A3. Note: The user must program the same values into the A6/A2 bits of emrs1_data_1 and rtt_0. */
+#define CTL_25_EMRS1_DATA_1_MASK 0x00003FFF
+/** field offset */
+#define CTL_25_EMRS1_DATA_1_OFFSET 0
+
+/* Fields of "Denali CTL_26 register" */
+/** Data to program into memory mode register 3 for chip select 0.
+    Holds the EMRS3 data written during memory initialization for chip select 0. The contents of this parameter will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. */
+#define CTL_26_EMRS3_DATA_0_MASK 0x3FFF0000
+/** field offset */
+#define CTL_26_EMRS3_DATA_0_OFFSET 16
+/** Data to program into memory mode register 2 for chip select 1.
+    Holds the EMRS2 data written during memory initialization for chip select 1. The contents of this parameter will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. */
+#define CTL_26_EMRS2_DATA_1_MASK 0x00003FFF
+/** field offset */
+#define CTL_26_EMRS2_DATA_1_OFFSET 0
+
+/* Fields of "Denali CTL_27 register" */
+/** MRS data to program to memory mode register 0 for chip select 0.
+    Holds the MRS data written during memory initialization. This mode parameter should contain the necessary MRS fields in the correct bit locations. The Denali Databahn Memory Controller ignores the programmed value of the DLL Reset bit in this parameter. An internal state machine controls this bit and only sets the DLL Reset bit during initialization. The Denali Databahn Memory Controller does not support Interleaved bursts or burst lengths other than 4. Therefore, the user should ensure that A3 is cleared to b0 and [A2:A0] are set to b010. The contents of this parameter, except the DLL Reset bit, will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. */
+#define CTL_27_MRS_DATA_0_MASK 0x3FFF0000
+/** field offset */
+#define CTL_27_MRS_DATA_0_OFFSET 16
+/** Data to program into memory mode register 3 for chip select 1.
+    Holds the EMRS3 data written during memory initialization for chip select 1. The contents of this parameter will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. */
+#define CTL_27_EMRS3_DATA_1_MASK 0x00003FFF
+/** field offset */
+#define CTL_27_EMRS3_DATA_1_OFFSET 0
+
+/* Fields of "Denali CTL_28 register" */
+/** Holds the DFI tCTRLUPD_MAX timing parameter. READ-ONLY
+    Holds the DFI tctrlupd_max timing parameter. This parameter is read-only. */
+#define CTL_28_TDFI_CTRLUPD_MAX_MASK 0x3FFF0000
+/** field offset */
+#define CTL_28_TDFI_CTRLUPD_MAX_OFFSET 16
+/** MRS data to program to memory mode register 0 for chip select 1.
+    Holds the MRS data written during memory initialization. This mode parameter should contain the necessary MRS fields in the correct bit locations. The Denali Databahn Memory Controller ignores the programmed value of the DLL Reset bit in this parameter. An internal state machine controls this bit and only sets the DLL Reset bit during initialization. The Denali Databahn Memory Controller does not support Interleaved bursts or burst lengths other than 4. Therefore, the user should ensure that A3 is cleared to b0 and [A2:A0] are set to b010. The contents of this parameter, except the DLL Reset bit, will be programmed into the DRAM at initialization or when the write_modereg parameter is written with a '1'. Consult the DRAM specification for the correct settings for this parameter. */
+#define CTL_28_MRS_DATA_1_MASK 0x00003FFF
+/** field offset */
+#define CTL_28_MRS_DATA_1_OFFSET 0
+
+/* Fields of "Denali CTL_29 register" */
+/** Holds the DFI tPHYUPD_TYPE0 timing parameter. READ-ONLY
+    Holds the DFI tphyupd_type0 timing parameter. This parameter is read-only. */
+#define CTL_29_TDFI_PHYUPD_TYPE0_MASK 0x3FFF0000
+/** field offset */
+#define CTL_29_TDFI_PHYUPD_TYPE0_OFFSET 16
+/** Holds the DFI tPHYUPD_RESP timing parameter. READ-ONLY
+    Holds the DFI tphyupd_resp timing parameter. This parameter is read-only. */
+#define CTL_29_TDFI_PHYUPD_RESP_MASK 0x00003FFF
+/** field offset */
+#define CTL_29_TDFI_PHYUPD_RESP_OFFSET 0
+
+/* Fields of "Denali CTL_30 register" */
+/** Minimum number of cycles required for DLL reset.
+    Sets the number of cycles that the reset must be held asserted for the DLL. */
+#define CTL_30_DLL_RST_DELAY_MASK 0xFFFF0000
+/** field offset */
+#define CTL_30_DLL_RST_DELAY_OFFSET 16
+/** DRAM TREF parameter in cycles.
+    Defines the DRAM cycles between refresh commands. */
+#define CTL_30_TREF_MASK 0x00003FFF
+/** field offset */
+#define CTL_30_TREF_OFFSET 0
+
+/* Fields of "Denali CTL_31 register" */
+/** Counts idle cycles to self-refresh with memory and controller clk gating.
+    Counts the number of idle cycles before memory selfrefresh with memory and controller clock gating low power mode. */
+#define CTL_31_LOWPOWER_INTERNAL_CNT_MASK 0xFFFF0000
+/** field offset */
+#define CTL_31_LOWPOWER_INTERNAL_CNT_OFFSET 16
+/** Counts idle cycles to self-refresh with memory clock gating.
+    Counts the number of idle cycles before memory selfrefresh with memory clock gating low power mode. */
+#define CTL_31_LOWPOWER_EXTERNAL_CNT_MASK 0x0000FFFF
+/** field offset */
+#define CTL_31_LOWPOWER_EXTERNAL_CNT_OFFSET 0
+
+/* Fields of "Denali CTL_32 register" */
+/** Re-Sync counter for DLL in Clock Gate Mode.
+    Sets the number of cycles that the Denali Databahn Memory Controller will wait before attempting to re-lock the DLL when using the controller clock gating mode low power mode. This counter will ONLY be used in this mode, the deepest low power mode. When this counter expires, the DLL will be un-gated for at least 16 cycles during which the DLL will attempt to re-lock. After 16 cycles have elapsed and the DLL has locked, then the DLL controller clock will be gated again and the counter will reset to this value. If the DLL requires more than 16 cycles to re-lock, then the un-gated time will be longer. */
+#define CTL_32_LOWPOWER_REFRESH_HOLD_MASK 0xFFFF0000
+/** field offset */
+#define CTL_32_LOWPOWER_REFRESH_HOLD_OFFSET 16
+/** Counts idle cycles to memory powerdown.
+    Counts the number of idle cycles before memory powerdown or power-down with memory clock gating low power mode. */
+#define CTL_32_LOWPOWER_POWER_DOWN_CNT_MASK 0x0000FFFF
+/** field offset */
+#define CTL_32_LOWPOWER_POWER_DOWN_CNT_OFFSET 0
+
+/* Fields of "Denali CTL_33 register" */
+/** DRAM TCPD parameter in cycles.
+    Defines the clock enable to pre-charge delay time for the DRAM devices, in cycles. */
+#define CTL_33_TCPD_MASK 0xFFFF0000
+/** field offset */
+#define CTL_33_TCPD_OFFSET 16
+/** Counts idle cycles to memory self-refresh.
+    Counts the number of cycles to the next memory selfrefresh low power mode. */
+#define CTL_33_LOWPOWER_SELF_REFRESH_CNT_MASK 0x0000FFFF
+/** field offset */
+#define CTL_33_LOWPOWER_SELF_REFRESH_CNT_OFFSET 0
+
+/* Fields of "Denali CTL_34 register" */
+/** DRAM TPDEX parameter in cycles.
+    Defines the DRAM power-down exit command period, in cycles. */
+#define CTL_34_TPDEX_MASK 0xFFFF0000
+/** field offset */
+#define CTL_34_TPDEX_OFFSET 16
+/** DRAM TDLL parameter in cycles.
+    Defines the DRAM DLL lock time, in cycles. */
+#define CTL_34_TDLL_MASK 0x0000FFFF
+/** field offset */
+#define CTL_34_TDLL_OFFSET 0
+
+/* Fields of "Denali CTL_35 register" */
+/** DRAM TXSNR parameter in cycles.
+    Defines the DRAM tXSNR parameter, in cycles. */
+#define CTL_35_TXSNR_MASK 0xFFFF0000
+/** field offset */
+#define CTL_35_TXSNR_OFFSET 16
+/** DRAM TRAS_MAX parameter in cycles.
+    Defines the DRAM maximum row active time, in cycles. */
+#define CTL_35_TRAS_MAX_MASK 0x0000FFFF
+/** field offset */
+#define CTL_35_TRAS_MAX_OFFSET 0
+
+/* Fields of "Denali CTL_36 register" */
+/** Controller version number. READONLY
+    Holds the Denali version number for this controller. This parameter is read-only. */
+#define CTL_36_VERSION_MASK 0xFFFF0000
+/** field offset */
+#define CTL_36_VERSION_OFFSET 16
+/** DRAM TXSR parameter in cycles.
+    Defines the DRAM self-refresh exit time, in cycles. */
+#define CTL_36_TXSR_MASK 0x0000FFFF
+/** field offset */
+#define CTL_36_TXSR_OFFSET 0
+
+/* Fields of "Denali CTL_37 register" */
+/** DRAM TINIT parameter in cycles.
+    Defines the DRAM initialization time, in cycles. */
+#define CTL_37_TINIT_MASK 0x00FFFFFF
+/** field offset */
+#define CTL_37_TINIT_OFFSET 0
+
+/* Fields of "Denali CTL_38 register" */
+/** Enables the PHY testing mode.
+    Enables the PHY testing mode. Bits [2:1] are used: Bits [2:1] = b10 = Normal Mode, Bits [2:1] = b01 = Scan Mode. Currently Not Functional */
+#define CTL_38_DFT_CTRL_REG_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_38_DFT_CTRL_REG_OFFSET 0
+
+/* Fields of "Denali CTL_39 register" */
+/** DLL Bypass Control */
+#define CTL_39_DLL_BYP_CTRL 0x10000000
+/* Normal operational mode. In this mode, the DLL uses CTL_39.DLLN_DQS_DEL for the read DQS and CTL_43.DLLN_CLK_WR for clk_wr.
+#define CTL_39_DLL_BYP_CTRL_DLLN 0x00000000 */
+/** Bypass Mode is on. In this mode, the DLL uses CTL_39.DLLB_DQS_DEL for the read DQS and CTL_43.DLLB_CLK_WR for clk_wr. */
+#define CTL_39_DLL_BYP_CTRL_DLLB 0x10000000
+/** Bypass Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). */
+#define CTL_39_DLLB_DQS_DEL_MASK 0x00FF0000
+/** field offset */
+#define CTL_39_DLLB_DQS_DEL_OFFSET 16
+/** Normal Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in normal mode (DLL_BYP_CTRL= b0). Typically, this value is 1/ 4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_39_DLLN_DQS_DEL_MASK 0x0000FF00
+/** field offset */
+#define CTL_39_DLLN_DQS_DEL_OFFSET 8
+/** DLL Start Point Control
+    This value is loaded into the DLL at initialization and is the value at which the DLL will begin searching for a lock. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_39_DLLSPC_MASK 0x000000FF
+/** field offset */
+#define CTL_39_DLLSPC_OFFSET 0
+
+/* Fields of "Denali CTL_40 register" */
+/** DLL Bypass Control */
+#define CTL_40_DLL_BYP_CTRL 0x10000000
+/* Normal operational mode. In this mode, the DLL uses CTL_40.DLLN_DQS_DEL for the read DQS and CTL_44.DLLN_CLK_WR for clk_wr.
+#define CTL_40_DLL_BYP_CTRL_DLLN 0x00000000 */
+/** Bypass Mode is on. In this mode, the DLL uses CTL_40.DLLB_DQS_DEL for the read DQS and CTL_44.DLLB_CLK_WR for clk_wr. */
+#define CTL_40_DLL_BYP_CTRL_DLLB 0x10000000
+/** Bypass Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). */
+#define CTL_40_DLLB_DQS_DEL_MASK 0x00FF0000
+/** field offset */
+#define CTL_40_DLLB_DQS_DEL_OFFSET 16
+/** Normal Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in normal mode (DLL_BYP_CTRL= b0). Typically, this value is 1/ 4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_40_DLLN_DQS_DEL_MASK 0x0000FF00
+/** field offset */
+#define CTL_40_DLLN_DQS_DEL_OFFSET 8
+/** DLL Start Point Control
+    This value is loaded into the DLL at initialization and is the value at which the DLL will begin searching for a lock. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_40_DLLSPC_MASK 0x000000FF
+/** field offset */
+#define CTL_40_DLLSPC_OFFSET 0
+
+/* Fields of "Denali CTL_41 register" */
+/** DLL Bypass Control */
+#define CTL_41_DLL_BYP_CTRL 0x10000000
+/* Normal operational mode. In this mode, the DLL uses CTL_41.DLLN_DQS_DEL for the read DQS and CTL_45.DLLN_CLK_WR for clk_wr.
+#define CTL_41_DLL_BYP_CTRL_DLLN 0x00000000 */
+/** Bypass Mode is on. In this mode, the DLL uses CTL_41.DLLB_DQS_DEL for the read DQS and CTL_45.DLLB_CLK_WR for clk_wr. */
+#define CTL_41_DLL_BYP_CTRL_DLLB 0x10000000
+/** Bypass Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). */
+#define CTL_41_DLLB_DQS_DEL_MASK 0x00FF0000
+/** field offset */
+#define CTL_41_DLLB_DQS_DEL_OFFSET 16
+/** Normal Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in normal mode (DLL_BYP_CTRL= b0). Typically, this value is 1/ 4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_41_DLLN_DQS_DEL_MASK 0x0000FF00
+/** field offset */
+#define CTL_41_DLLN_DQS_DEL_OFFSET 8
+/** DLL Start Point Control
+    This value is loaded into the DLL at initialization and is the value at which the DLL will begin searching for a lock. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_41_DLLSPC_MASK 0x000000FF
+/** field offset */
+#define CTL_41_DLLSPC_OFFSET 0
+
+/* Fields of "Denali CTL_42 register" */
+/** DLL Bypass Control */
+#define CTL_42_DLL_BYP_CTRL 0x10000000
+/* Normal operational mode. In this mode, the DLL uses CTL_42.DLLN_DQS_DEL for the read DQS and CTL_46.DLLN_CLK_WR for clk_wr.
+#define CTL_42_DLL_BYP_CTRL_DLLN 0x00000000 */
+/** Bypass Mode is on. In this mode, the DLL uses CTL_42.DLLB_DQS_DEL for the read DQS and CTL_46.DLLB_CLK_WR for clk_wr. */
+#define CTL_42_DLL_BYP_CTRL_DLLB 0x10000000
+/** Bypass Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). */
+#define CTL_42_DLLB_DQS_DEL_MASK 0x00FF0000
+/** field offset */
+#define CTL_42_DLLB_DQS_DEL_OFFSET 16
+/** Normal Mode DQS Delay
+    Holds the read DQS delay setting when the DLL is operating in normal mode (DLL_BYP_CTRL= b0). Typically, this value is 1/ 4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_42_DLLN_DQS_DEL_MASK 0x0000FF00
+/** field offset */
+#define CTL_42_DLLN_DQS_DEL_OFFSET 8
+/** DLL Start Point Control
+    This value is loaded into the DLL at initialization and is the value at which the DLL will begin searching for a lock. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_42_DLLSPC_MASK 0x000000FF
+/** field offset */
+#define CTL_42_DLLSPC_OFFSET 0
+
+/* Fields of "Denali CTL_43 register" */
+/** Bypass Mode CLK_WR Setting
+    Holds the clk_wr delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_43_DLLB_CLK_WR_MASK 0x00FF0000
+/** field offset */
+#define CTL_43_DLLB_CLK_WR_OFFSET 16
+/** Normal Mode CLK_WR Setting
+    Holds the clk_wr delay setting in normal mode (DLL_BYP_CTRL= b1). Typically, this value is 3/4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_43_DLLN_CLK_WR_MASK 0x0000FF00
+/** field offset */
+#define CTL_43_DLLN_CLK_WR_OFFSET 8
+/** DLL Increment Value
+    DLL Increment Value. This sets the increment used by the DLL when searching for a lock. Denali recommends keeping this field small (around 0x4) to keep the steps gradual. */
+#define CTL_43_DLLINCVAL_MASK 0x000000FF
+/** field offset */
+#define CTL_43_DLLINCVAL_OFFSET 0
+
+/* Fields of "Denali CTL_44 register" */
+/** Bypass Mode CLK_WR Setting
+    Holds the clk_wr delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_44_DLLB_CLK_WR_MASK 0x00FF0000
+/** field offset */
+#define CTL_44_DLLB_CLK_WR_OFFSET 16
+/** Normal Mode CLK_WR Setting
+    Holds the clk_wr delay setting in normal mode (DLL_BYP_CTRL= b1). Typically, this value is 3/4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_44_DLLN_CLK_WR_MASK 0x0000FF00
+/** field offset */
+#define CTL_44_DLLN_CLK_WR_OFFSET 8
+/** DLL Increment Value
+    DLL Increment Value. This sets the increment used by the DLL when searching for a lock. Denali recommends keeping this field small (around 0x4) to keep the steps gradual. */
+#define CTL_44_DLLINCVAL_MASK 0x000000FF
+/** field offset */
+#define CTL_44_DLLINCVAL_OFFSET 0
+
+/* Fields of "Denali CTL_45 register" */
+/** Bypass Mode CLK_WR Setting
+    Holds the clk_wr delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_45_DLLB_CLK_WR_MASK 0x00FF0000
+/** field offset */
+#define CTL_45_DLLB_CLK_WR_OFFSET 16
+/** Normal Mode CLK_WR Setting
+    Holds the clk_wr delay setting in normal mode (DLL_BYP_CTRL= b1). Typically, this value is 3/4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_45_DLLN_CLK_WR_MASK 0x0000FF00
+/** field offset */
+#define CTL_45_DLLN_CLK_WR_OFFSET 8
+/** DLL Increment Value
+    DLL Increment Value. This sets the increment used by the DLL when searching for a lock. Denali recommends keeping this field small (around 0x4) to keep the steps gradual. */
+#define CTL_45_DLLINCVAL_MASK 0x000000FF
+/** field offset */
+#define CTL_45_DLLINCVAL_OFFSET 0
+
+/* Fields of "Denali CTL_46 register" */
+/** Bypass Mode CLK_WR Setting
+    Holds the clk_wr delay setting when the DLL is operating in bypass mode (DLL_BYP_CTRL= b1). Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_46_DLLB_CLK_WR_MASK 0x00FF0000
+/** field offset */
+#define CTL_46_DLLB_CLK_WR_OFFSET 16
+/** Normal Mode CLK_WR Setting
+    Holds the clk_wr delay setting in normal mode (DLL_BYP_CTRL= b1). Typically, this value is 3/4 of a clock cycle. Each increment of this field represents 1/128th of a clock cycle. */
+#define CTL_46_DLLN_CLK_WR_MASK 0x0000FF00
+/** field offset */
+#define CTL_46_DLLN_CLK_WR_OFFSET 8
+/** DLL Increment Value
+    DLL Increment Value. This sets the increment used by the DLL when searching for a lock. Denali recommends keeping this field small (around 0x4) to keep the steps gradual. */
+#define CTL_46_DLLINCVAL_MASK 0x000000FF
+/** field offset */
+#define CTL_46_DLLINCVAL_OFFSET 0
+
+/* Fields of "Denali CTL_47 register" */
+/** DLL Encoder Value
+    Reports the DLL encoder value from the master DLL to the slave DLL's. The slaves use this value to set up their delays for the clk_wr and read DQS signals. */
+#define CTL_47_DLL_ENCVAL_MASK 0xFFFFFFFE
+/** field offset */
+#define CTL_47_DLL_ENCVAL_OFFSET 1
+/** DLL Lock Indicator */
+#define CTL_47_DLL_LOCK 0x00000001
+/* DLL has not locked.
+#define CTL_47_DLL_LOCK_NLOCK 0x00000000 */
+/** DLL is locked. */
+#define CTL_47_DLL_LOCK_LOCK 0x00000001
+
+/* Fields of "Denali CTL_48 register" */
+/** DLL Encoder Value
+    Reports the DLL encoder value from the master DLL to the slave DLL's. The slaves use this value to set up their delays for the clk_wr and read DQS signals. */
+#define CTL_48_DLL_ENCVAL_MASK 0xFFFFFFFE
+/** field offset */
+#define CTL_48_DLL_ENCVAL_OFFSET 1
+/** DLL Lock Indicator */
+#define CTL_48_DLL_LOCK 0x00000001
+/* DLL has not locked.
+#define CTL_48_DLL_LOCK_NLOCK 0x00000000 */
+/** DLL is locked. */
+#define CTL_48_DLL_LOCK_LOCK 0x00000001
+
+/* Fields of "Denali CTL_49 register" */
+/** DLL Encoder Value
+    Reports the DLL encoder value from the master DLL to the slave DLL's. The slaves use this value to set up their delays for the clk_wr and read DQS signals. */
+#define CTL_49_DLL_ENCVAL_MASK 0xFFFFFFFE
+/** field offset */
+#define CTL_49_DLL_ENCVAL_OFFSET 1
+/** DLL Lock Indicator */
+#define CTL_49_DLL_LOCK 0x00000001
+/* DLL has not locked.
+#define CTL_49_DLL_LOCK_NLOCK 0x00000000 */
+/** DLL is locked. */
+#define CTL_49_DLL_LOCK_LOCK 0x00000001
+
+/* Fields of "Denali CTL_50 register" */
+/** DLL Encoder Value
+    Reports the DLL encoder value from the master DLL to the slave DLL's. The slaves use this value to set up their delays for the clk_wr and read DQS signals. */
+#define CTL_50_DLL_ENCVAL_MASK 0xFFFFFFFE
+/** field offset */
+#define CTL_50_DLL_ENCVAL_OFFSET 1
+/** DLL Lock Indicator */
+#define CTL_50_DLL_LOCK 0x00000001
+/* DLL has not locked.
+#define CTL_50_DLL_LOCK_NLOCK 0x00000000 */
+/** DLL is locked. */
+#define CTL_50_DLL_LOCK_LOCK 0x00000001
+
+/* Fields of "Denali CTL_51 register" */
+/** Address of cmd that caused an Out-of- Range interrupt. READ-ONLY
+    Holds the address of the command that caused an out-of-range interrupt request to the memory devices. This parameter is read-only. For more information on out-of-range address checking, refer to the Other Databahn Features Chapter. */
+#define CTL_51_OUT_OF_RANGE_ADDR_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_51_OUT_OF_RANGE_ADDR_OFFSET 0
+
+/* Fields of "Denali CTL_52 register" */
+/** Pad Impedance
+    Defines the pad impedance if the parallel termination option is enabled. */
+#define CTL_52_PADIMP 0x00001000
+/* 75 Ohm
+#define CTL_52_PADIMP_PAD75 0x00000000 */
+/** 150 Ohm */
+#define CTL_52_PADIMP_PAD150 0x00001000
+/** Pad Type */
+#define CTL_52_PADTYPE 0x00000100
+/* 75 Ohm
+#define CTL_52_PADTYPE_PADDDR1 0x00000000 */
+/** 150 Ohm */
+#define CTL_52_PADTYPE_PADDDR2 0x00000100
+/** IDDQ_RX Select Signals
+    Defines the IDDQ_RX select for the signal pads. */
+#define CTL_52_IDDQ_RX_SIG 0x00000020
+/* Do not feed input into IDDQ
+#define CTL_52_IDDQ_RX_SIG_NINIDDQ 0x00000000 */
+/** Feed input into IDDQ */
+#define CTL_52_IDDQ_RX_SIG_INIDDQ 0x00000020
+/** IDDQ_TX Select Signals
+    Defines the IDDQ_TX select for the signal pads. */
+#define CTL_52_IDDQ_TX_SIG 0x00000010
+/* Do not feed output into IDDQ
+#define CTL_52_IDDQ_TX_SIG_NOUTIDDQ 0x00000000 */
+/** Feed output into IDDQ */
+#define CTL_52_IDDQ_TX_SIG_OUTIDDQ 0x00000010
+/** IDDQ_RX Select Clocks
+    Defines the IDDQ_RX select for the clock pads. */
+#define CTL_52_IDDQ_RX_CLK 0x00000002
+/* Do not feed input into IDDQ
+#define CTL_52_IDDQ_RX_CLK_NINIDDQ 0x00000000 */
+/** Feed input into IDDQ */
+#define CTL_52_IDDQ_RX_CLK_INIDDQ 0x00000002
+/** IDDQ_TX Select Clocks
+    Defines the IDDQ_TX select for the clock pads. */
+#define CTL_52_IDDQ_TX_CLK 0x00000001
+/* Do not feed output into IDDQ
+#define CTL_52_IDDQ_TX_CLK_NOUTIDDQ 0x00000000 */
+/** Feed output into IDDQ */
+#define CTL_52_IDDQ_TX_CLK_OUTIDDQ 0x00000001
+
+/* Fields of "Denali CTL_53 register" */
+/** Dynamic On-Die Termination DataMask Enable
+    Enables/disables dynamic on-die termination for the DataMask pads in the PHY. */
+#define CTL_53_ODT_DM_EN 0x80000000
+/* Disable
+#define CTL_53_ODT_DM_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_53_ODT_DM_EN_EN 0x80000000
+/** Dynamic On-Die Termination Data Mask Disable
+    Disables dynamic on-die termination for the DataMask pads in the PHY. Note: This control bit is set according to the DQ:DQS ratio. In case x8 organized DDR SDRAM devices are connected, this bit is set to 1B and causes the ODT feature to be disabled for date mask signals. This is independent of control bit ODT_DM_EN. */
+#define CTL_53_ODT_DM_DIS 0x20000000
+/* Enabled
+#define CTL_53_ODT_DM_DIS_ODT_DM_EN 0x00000000 */
+/** Echo Gate Control
+    Echo gate control for data slice 0 */
+#define CTL_53_EGC 0x10000000
+/* Uses the dfi_rddata_en signal to create a gate
+#define CTL_53_EGC_DFI 0x00000000 */
+/** Creates an echo gate signal. */
+#define CTL_53_EGC_CRT 0x10000000
+/** Gather FIFO Enable */
+#define CTL_53_GFEN 0x08000000
+/* Disable
+#define CTL_53_GFEN_DIS 0x00000000 */
+/** Enable */
+#define CTL_53_GFEN_EN 0x08000000
+/** Read Data Delay
+    Defines the read data delay. Holds the number of cycles to delay the dfi_rddata_en signal prior to enabling the read FIFO. After this delay, the read pointers begin incrementing the read FIFO. */
+#define CTL_53_RDD_MASK 0x07000000
+/** field offset */
+#define CTL_53_RDD_OFFSET 24
+/** DQS and DQ Pad Output Enable Polarity
+    Sets the pad output enable polarity for the data slices. */
+#define CTL_53_OEPOL 0x00100000
+/* OEN pad
+#define CTL_53_OEPOL_OEN 0x00000000 */
+/** OE pad */
+#define CTL_53_OEPOL_OE 0x00100000
+/** Adjust Read DQS Gate
+    Enables the adjustment of the read DQS gate by 1/2 cycle. */
+#define CTL_53_ENGTADJ 0x00010000
+/* Disable
+#define CTL_53_ENGTADJ_DIS 0x00000000 */
+/** Enable */
+#define CTL_53_ENGTADJ_EN 0x00010000
+/** Adjust Starting Point of DQS Output Enable Window
+    Adjusts the starting point of the DQS pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_53_DQS_START_OE_MASK 0x00007000
+/** field offset */
+#define CTL_53_DQS_START_OE_OFFSET 12
+/** Adjust Ending Point of DQS Output Enable Window
+    Adjusts the ending point of the DQS pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_53_DQS_END_OE_MASK 0x00000700
+/** field offset */
+#define CTL_53_DQS_END_OE_OFFSET 8
+/** Adjust Starting Point of DQ Output Enable Window
+    Adjusts the starting point of the DQ pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_53_DQ_START_OE_MASK 0x00000070
+/** field offset */
+#define CTL_53_DQ_START_OE_OFFSET 4
+/** Adjust Ending Point of DQ Output Enable Window
+    Adjusts the ending point of the DQ pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_53_DQ_END_OE_MASK 0x00000007
+/** field offset */
+#define CTL_53_DQ_END_OE_OFFSET 0
+
+/* Fields of "Denali CTL_54 register" */
+/** Dynamic On-Die Termination DataMask Enable
+    Enables/disables dynamic on-die termination for the DataMask pads in the PHY. */
+#define CTL_54_ODT_DM_EN 0x80000000
+/* Disable
+#define CTL_54_ODT_DM_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_54_ODT_DM_EN_EN 0x80000000
+/** Dynamic On-Die Termination Data Mask Disable
+    Disables dynamic on-die termination for the DataMask pads in the PHY. Note: This control bit is set according to the DQ:DQS ratio. In case x8 organized DDR SDRAM devices are connected, this bit is set to 1B and causes the ODT feature to be disabled for date mask signals. This is independent of control bit ODT_DM_EN. */
+#define CTL_54_ODT_DM_DIS 0x20000000
+/* Enabled
+#define CTL_54_ODT_DM_DIS_ODT_DM_EN 0x00000000 */
+/** Echo Gate Control
+    Echo gate control for data slice 1 */
+#define CTL_54_EGC 0x10000000
+/* Uses the dfi_rddata_en signal to create a gate
+#define CTL_54_EGC_DFI 0x00000000 */
+/** Creates an echo gate signal. */
+#define CTL_54_EGC_CRT 0x10000000
+/** Gather FIFO Enable */
+#define CTL_54_GFEN 0x08000000
+/* Disable
+#define CTL_54_GFEN_DIS 0x00000000 */
+/** Enable */
+#define CTL_54_GFEN_EN 0x08000000
+/** Read Data Delay
+    Defines the read data delay. Holds the number of cycles to delay the dfi_rddata_en signal prior to enabling the read FIFO. After this delay, the read pointers begin incrementing the read FIFO. */
+#define CTL_54_RDD_MASK 0x07000000
+/** field offset */
+#define CTL_54_RDD_OFFSET 24
+/** DQS and DQ Pad Output Enable Polarity
+    Sets the pad output enable polarity for the data slices. */
+#define CTL_54_OEPOL 0x00100000
+/* OEN pad
+#define CTL_54_OEPOL_OEN 0x00000000 */
+/** OE pad */
+#define CTL_54_OEPOL_OE 0x00100000
+/** Adjust Read DQS Gate
+    Enables the adjustment of the read DQS gate by 1/2 cycle. */
+#define CTL_54_ENGTADJ 0x00010000
+/* Disable
+#define CTL_54_ENGTADJ_DIS 0x00000000 */
+/** Enable */
+#define CTL_54_ENGTADJ_EN 0x00010000
+/** Adjust Starting Point of DQS Output Enable Window
+    Adjusts the starting point of the DQS pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_54_DQS_START_OE_MASK 0x00007000
+/** field offset */
+#define CTL_54_DQS_START_OE_OFFSET 12
+/** Adjust Ending Point of DQS Output Enable Window
+    Adjusts the ending point of the DQS pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_54_DQS_END_OE_MASK 0x00000700
+/** field offset */
+#define CTL_54_DQS_END_OE_OFFSET 8
+/** Adjust Starting Point of DQ Output Enable Window
+    Adjusts the starting point of the DQ pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_54_DQ_START_OE_MASK 0x00000070
+/** field offset */
+#define CTL_54_DQ_START_OE_OFFSET 4
+/** Adjust Ending Point of DQ Output Enable Window
+    Adjusts the ending point of the DQ pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_54_DQ_END_OE_MASK 0x00000007
+/** field offset */
+#define CTL_54_DQ_END_OE_OFFSET 0
+
+/* Fields of "Denali CTL_55 register" */
+/** Dynamic On-Die Termination DataMask Enable
+    Enables/disables dynamic on-die termination for the DataMask pads in the PHY. */
+#define CTL_55_ODT_DM_EN 0x80000000
+/* Disable
+#define CTL_55_ODT_DM_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_55_ODT_DM_EN_EN 0x80000000
+/** Dynamic On-Die Termination Data Mask Disable
+    Disables dynamic on-die termination for the DataMask pads in the PHY. Note: This control bit is set according to the DQ:DQS ratio. In case x8 organized DDR SDRAM devices are connected, this bit is set to 1B and causes the ODT feature to be disabled for date mask signals. This is independent of control bit ODT_DM_EN. */
+#define CTL_55_ODT_DM_DIS 0x20000000
+/* Enabled
+#define CTL_55_ODT_DM_DIS_ODT_DM_EN 0x00000000 */
+/** Echo Gate Control
+    Echo gate control for data slice 2 */
+#define CTL_55_EGC 0x10000000
+/* Uses the dfi_rddata_en signal to create a gate
+#define CTL_55_EGC_DFI 0x00000000 */
+/** Creates an echo gate signal. */
+#define CTL_55_EGC_CRT 0x10000000
+/** Gather FIFO Enable */
+#define CTL_55_GFEN 0x08000000
+/* Disable
+#define CTL_55_GFEN_DIS 0x00000000 */
+/** Enable */
+#define CTL_55_GFEN_EN 0x08000000
+/** Read Data Delay
+    Defines the read data delay. Holds the number of cycles to delay the dfi_rddata_en signal prior to enabling the read FIFO. After this delay, the read pointers begin incrementing the read FIFO. */
+#define CTL_55_RDD_MASK 0x07000000
+/** field offset */
+#define CTL_55_RDD_OFFSET 24
+/** DQS and DQ Pad Output Enable Polarity
+    Sets the pad output enable polarity for the data slices. */
+#define CTL_55_OEPOL 0x00100000
+/* OEN pad
+#define CTL_55_OEPOL_OEN 0x00000000 */
+/** OE pad */
+#define CTL_55_OEPOL_OE 0x00100000
+/** Adjust Read DQS Gate
+    Enables the adjustment of the read DQS gate by 1/2 cycle. */
+#define CTL_55_ENGTADJ 0x00010000
+/* Disable
+#define CTL_55_ENGTADJ_DIS 0x00000000 */
+/** Enable */
+#define CTL_55_ENGTADJ_EN 0x00010000
+/** Adjust Starting Point of DQS Output Enable Window
+    Adjusts the starting point of the DQS pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_55_DQS_START_OE_MASK 0x00007000
+/** field offset */
+#define CTL_55_DQS_START_OE_OFFSET 12
+/** Adjust Ending Point of DQS Output Enable Window
+    Adjusts the ending point of the DQS pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_55_DQS_END_OE_MASK 0x00000700
+/** field offset */
+#define CTL_55_DQS_END_OE_OFFSET 8
+/** Adjust Starting Point of DQ Output Enable Window
+    Adjusts the starting point of the DQ pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_55_DQ_START_OE_MASK 0x00000070
+/** field offset */
+#define CTL_55_DQ_START_OE_OFFSET 4
+/** Adjust Ending Point of DQ Output Enable Window
+    Adjusts the ending point of the DQ pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_55_DQ_END_OE_MASK 0x00000007
+/** field offset */
+#define CTL_55_DQ_END_OE_OFFSET 0
+
+/* Fields of "Denali CTL_56 register" */
+/** Dynamic On-Die Termination DataMask Enable
+    Enables/disables dynamic on-die termination for the DataMask pads in the PHY. */
+#define CTL_56_ODT_DM_EN 0x80000000
+/* Disable
+#define CTL_56_ODT_DM_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_56_ODT_DM_EN_EN 0x80000000
+/** Dynamic On-Die Termination Data Mask Disable
+    Disables dynamic on-die termination for the DataMask pads in the PHY. Note: This control bit is set according to the DQ:DQS ratio. In case x8 organized DDR SDRAM devices are connected, this bit is set to 1B and causes the ODT feature to be disabled for date mask signals. This is independent of control bit ODT_DM_EN. */
+#define CTL_56_ODT_DM_DIS 0x20000000
+/* Enabled
+#define CTL_56_ODT_DM_DIS_ODT_DM_EN 0x00000000 */
+/** Echo Gate Control
+    Echo gate control for data slice 3 */
+#define CTL_56_EGC 0x10000000
+/* Uses the dfi_rddata_en signal to create a gate
+#define CTL_56_EGC_DFI 0x00000000 */
+/** Creates an echo gate signal. */
+#define CTL_56_EGC_CRT 0x10000000
+/** Gather FIFO Enable */
+#define CTL_56_GFEN 0x08000000
+/* Disable
+#define CTL_56_GFEN_DIS 0x00000000 */
+/** Enable */
+#define CTL_56_GFEN_EN 0x08000000
+/** Read Data Delay
+    Defines the read data delay. Holds the number of cycles to delay the dfi_rddata_en signal prior to enabling the read FIFO. After this delay, the read pointers begin incrementing the read FIFO. */
+#define CTL_56_RDD_MASK 0x07000000
+/** field offset */
+#define CTL_56_RDD_OFFSET 24
+/** DQS and DQ Pad Output Enable Polarity
+    Sets the pad output enable polarity for the data slices. */
+#define CTL_56_OEPOL 0x00100000
+/* OEN pad
+#define CTL_56_OEPOL_OEN 0x00000000 */
+/** OE pad */
+#define CTL_56_OEPOL_OE 0x00100000
+/** Adjust Read DQS Gate
+    Enables the adjustment of the read DQS gate by 1/2 cycle. */
+#define CTL_56_ENGTADJ 0x00010000
+/* Disable
+#define CTL_56_ENGTADJ_DIS 0x00000000 */
+/** Enable */
+#define CTL_56_ENGTADJ_EN 0x00010000
+/** Adjust Starting Point of DQS Output Enable Window
+    Adjusts the starting point of the DQS pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_56_DQS_START_OE_MASK 0x00007000
+/** field offset */
+#define CTL_56_DQS_START_OE_OFFSET 12
+/** Adjust Ending Point of DQS Output Enable Window
+    Adjusts the ending point of the DQS pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_56_DQS_END_OE_MASK 0x00000700
+/** field offset */
+#define CTL_56_DQS_END_OE_OFFSET 8
+/** Adjust Starting Point of DQ Output Enable Window
+    Adjusts the starting point of the DQ pad output enable window. Lower numbers pull the rising edge earlier in time, and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_56_DQ_START_OE_MASK 0x00000070
+/** field offset */
+#define CTL_56_DQ_START_OE_OFFSET 4
+/** Adjust Ending Point of DQ Output Enable Window
+    Adjusts the ending point of the DQ pad output enable window. Lower numbers pull the falling edge earlier in time, and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/4 cycle resolution. */
+#define CTL_56_DQ_END_OE_MASK 0x00000007
+/** field offset */
+#define CTL_56_DQ_END_OE_OFFSET 0
+
+/* Fields of "Denali CTL_57 register" */
+/** Dynamic On-Die Termination Enable Time
+    Defines the dynamic on-die termination enable time. Larger values add greater delay to when signal tsel turns on. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_57_ODT_ENT_MASK 0xF0000000
+/** field offset */
+#define CTL_57_ODT_ENT_OFFSET 28
+/** Dynamic On-Die Termination Disable Time
+    Defines the dynamic on-die termination disable time. Larger values reduce the delay to when signal tsel turns off. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_57_ODT_DIST_MASK 0x0F000000
+/** field offset */
+#define CTL_57_ODT_DIST_OFFSET 24
+/** Dynamic On-Die Termination Enable
+    Enables/disables dynamic on-die termination in the PHY. This bit must be set to allow dynamic on-die termination options to be used. */
+#define CTL_57_ODT_EN 0x00800000
+/* Disable
+#define CTL_57_ODT_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_57_ODT_EN_EN 0x00800000
+/** Dynamic On-Die Termination Polarity of TSEL
+    Controls the polarity of signal tsel for the data bus, the strobe signals and the data mask signals in the PHY. */
+#define CTL_57_ODT_PTSEL 0x00400000
+/* Negative Polarity
+#define CTL_57_ODT_PTSEL_NEG 0x00000000 */
+/** Positive Polarity */
+#define CTL_57_ODT_PTSEL_POS 0x00400000
+/** Trigger Data Return
+    Triggers a data return (loopback data on the dfi_rddata signal) to the DDR SDRAM Controller. */
+#define CTL_57_TDR 0x00200000
+/* No-Operation
+#define CTL_57_TDR_NOP 0x00000000 */
+/** Trigger */
+#define CTL_57_TDR_TRIG 0x00200000
+/** Loopback Data Output Type
+    Selects data output type to either the actual data or expected data for bit field CTL_62.LPBKDATA */
+#define CTL_57_LPBKDOT 0x00100000
+/* Return the expected data
+#define CTL_57_LPBKDOT_LPBKEXP 0x00000000 */
+/** Return the actual data */
+#define CTL_57_LPBKDOT_LPBKACT 0x00100000
+/** Loopback Control
+    Selects the different options in loopback mode. */
+#define CTL_57_LPBKCTRL_MASK 0x000C0000
+/** field offset */
+#define CTL_57_LPBKCTRL_OFFSET 18
+/** Normal operational mode */
+#define CTL_57_LPBKCTRL_LPBKN 0x00000000
+/** Enables loopback write mode */
+#define CTL_57_LPBKCTRL_LPBKW 0x00040000
+/** Stop loopback to check the error register */
+#define CTL_57_LPBKCTRL_LPBKST 0x00080000
+/** Clear loopback registers */
+#define CTL_57_LPBKCTRL_LPBKC 0x000C0000
+/** Loopback Read MUX
+    Controls the loopback read multiplexer. */
+#define CTL_57_LPBKRM 0x00020000
+/** Loopback Write MUX
+    Controls the loopback write multiplexer. */
+#define CTL_57_LPBKWM 0x00010000
+/** Loopback LFSR to Error Checking Logic Delay
+    Sets the cycle delay between the Linear Feedback Shift Register (LFSR) and loopback error check logic. */
+#define CTL_57_LPBKLFSRECLD_MASK 0x00007000
+/** field offset */
+#define CTL_57_LPBKLFSRECLD_OFFSET 12
+/** Read DQS Gate Close Configuration
+    This bit is used to delay the read DQS gate close logic in the DDR SDRAM PHY. This bit should be set to b1 if the DDR SDRAM controller is running in echo gate mode (CTL_53.EGC = b1) and the echo delay (pad_out + pad_in + flight + flight + tdqsck_max) 2 cycles. */
+#define CTL_57_DQS_GATE_CLOSE_CFG 0x00000800
+/** Stretch Trailing Edge of DFI Read Data Enable
+    This bit field stretches the trailing edge of dfi_rddata_en for closing the read DQS gate */
+#define CTL_57_STRTREGT_MASK 0x00000700
+/** field offset */
+#define CTL_57_STRTREGT_OFFSET 8
+/** Read DQS Gate Opening
+    This bit field controls, when the read DQS gate opens. This value is the number of cycles to delay the dfi_rddata_en signal prior to opening the read DQS gate. */
+#define CTL_57_DQS_GATE_OPEN_MASK 0x000000FF
+/** field offset */
+#define CTL_57_DQS_GATE_OPEN_OFFSET 0
+
+/* Fields of "Denali CTL_58 register" */
+/** Dynamic On-Die Termination Enable Time
+    Defines the dynamic on-die termination enable time. Larger values add greater delay to when signal tsel turns on. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_58_ODT_ENT_MASK 0xF0000000
+/** field offset */
+#define CTL_58_ODT_ENT_OFFSET 28
+/** Dynamic On-Die Termination Disable Time
+    Defines the dynamic on-die termination disable time. Larger values reduce the delay to when signal tsel turns off. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_58_ODT_DIST_MASK 0x0F000000
+/** field offset */
+#define CTL_58_ODT_DIST_OFFSET 24
+/** Dynamic On-Die Termination Enable
+    Enables/disables dynamic on-die termination in the PHY. This bit must be set to allow dynamic on-die termination options to be used. */
+#define CTL_58_ODT_EN 0x00800000
+/* Disable
+#define CTL_58_ODT_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_58_ODT_EN_EN 0x00800000
+/** Dynamic On-Die Termination Polarity of TSEL
+    Controls the polarity of signal tsel for the data bus, the strobe signals and the data mask signals in the PHY. */
+#define CTL_58_ODT_PTSEL 0x00400000
+/* Negative Polarity
+#define CTL_58_ODT_PTSEL_NEG 0x00000000 */
+/** Positive Polarity */
+#define CTL_58_ODT_PTSEL_POS 0x00400000
+/** Trigger Data Return
+    Triggers a data return (loopback data on the dfi_rddata signal) to the DDR SDRAM Controller. */
+#define CTL_58_TDR 0x00200000
+/* No-Operation
+#define CTL_58_TDR_NOP 0x00000000 */
+/** Trigger */
+#define CTL_58_TDR_TRIG 0x00200000
+/** Loopback Data Output Type
+    Selects data output type to either the actual data or expected data for bit field CTL_63.LPBKDATA */
+#define CTL_58_LPBKDOT 0x00100000
+/* Return the expected data
+#define CTL_58_LPBKDOT_LPBKEXP 0x00000000 */
+/** Return the actual data */
+#define CTL_58_LPBKDOT_LPBKACT 0x00100000
+/** Loopback Control
+    Selects the different options in loopback mode. */
+#define CTL_58_LPBKCTRL_MASK 0x000C0000
+/** field offset */
+#define CTL_58_LPBKCTRL_OFFSET 18
+/** Normal operational mode */
+#define CTL_58_LPBKCTRL_LPBKN 0x00000000
+/** Enables loopback write mode */
+#define CTL_58_LPBKCTRL_LPBKW 0x00040000
+/** Stop loopback to check the error register */
+#define CTL_58_LPBKCTRL_LPBKST 0x00080000
+/** Clear loopback registers */
+#define CTL_58_LPBKCTRL_LPBKC 0x000C0000
+/** Loopback Read MUX
+    Controls the loopback read multiplexer. */
+#define CTL_58_LPBKRM 0x00020000
+/** Loopback Write MUX
+    Controls the loopback write multiplexer. */
+#define CTL_58_LPBKWM 0x00010000
+/** Loopback LFSR to Error Checking Logic Delay
+    Sets the cycle delay between the Linear Feedback Shift Register (LFSR) and loopback error check logic. */
+#define CTL_58_LPBKLFSRECLD_MASK 0x00007000
+/** field offset */
+#define CTL_58_LPBKLFSRECLD_OFFSET 12
+/** Read DQS Gate Close Configuration
+    This bit is used to delay the read DQS gate close logic in the DDR SDRAM PHY. This bit should be set to b1 if the DDR SDRAM controller is running in echo gate mode (CTL_53.EGC = b1) and the echo delay (pad_out + pad_in + flight + flight + tdqsck_max) 2 cycles. */
+#define CTL_58_DQS_GATE_CLOSE_CFG 0x00000800
+/** Stretch Trailing Edge of DFI Read Data Enable
+    This bit field stretches the trailing edge of dfi_rddata_en for closing the read DQS gate */
+#define CTL_58_STRTREGT_MASK 0x00000700
+/** field offset */
+#define CTL_58_STRTREGT_OFFSET 8
+/** Read DQS Gate Opening
+    This bit field controls, when the read DQS gate opens. This value is the number of cycles to delay the dfi_rddata_en signal prior to opening the read DQS gate. */
+#define CTL_58_DQS_GATE_OPEN_MASK 0x000000FF
+/** field offset */
+#define CTL_58_DQS_GATE_OPEN_OFFSET 0
+
+/* Fields of "Denali CTL_59 register" */
+/** Dynamic On-Die Termination Enable Time
+    Defines the dynamic on-die termination enable time. Larger values add greater delay to when signal tsel turns on. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_59_ODT_ENT_MASK 0xF0000000
+/** field offset */
+#define CTL_59_ODT_ENT_OFFSET 28
+/** Dynamic On-Die Termination Disable Time
+    Defines the dynamic on-die termination disable time. Larger values reduce the delay to when signal tsel turns off. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_59_ODT_DIST_MASK 0x0F000000
+/** field offset */
+#define CTL_59_ODT_DIST_OFFSET 24
+/** Dynamic On-Die Termination Enable
+    Enables/disables dynamic on-die termination in the PHY. This bit must be set to allow dynamic on-die termination options to be used. */
+#define CTL_59_ODT_EN 0x00800000
+/* Disable
+#define CTL_59_ODT_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_59_ODT_EN_EN 0x00800000
+/** Dynamic On-Die Termination Polarity of TSEL
+    Controls the polarity of signal tsel for the data bus, the strobe signals and the data mask signals in the PHY. */
+#define CTL_59_ODT_PTSEL 0x00400000
+/* Negative Polarity
+#define CTL_59_ODT_PTSEL_NEG 0x00000000 */
+/** Positive Polarity */
+#define CTL_59_ODT_PTSEL_POS 0x00400000
+/** Trigger Data Return
+    Triggers a data return (loopback data on the dfi_rddata signal) to the DDR SDRAM Controller. */
+#define CTL_59_TDR 0x00200000
+/* No-Operation
+#define CTL_59_TDR_NOP 0x00000000 */
+/** Trigger */
+#define CTL_59_TDR_TRIG 0x00200000
+/** Loopback Data Output Type
+    Selects data output type to either the actual data or expected data for bit field CTL_64.LPBKDATA */
+#define CTL_59_LPBKDOT 0x00100000
+/* Return the expected data
+#define CTL_59_LPBKDOT_LPBKEXP 0x00000000 */
+/** Return the actual data */
+#define CTL_59_LPBKDOT_LPBKACT 0x00100000
+/** Loopback Control
+    Selects the different options in loopback mode. */
+#define CTL_59_LPBKCTRL_MASK 0x000C0000
+/** field offset */
+#define CTL_59_LPBKCTRL_OFFSET 18
+/** Normal operational mode */
+#define CTL_59_LPBKCTRL_LPBKN 0x00000000
+/** Enables loopback write mode */
+#define CTL_59_LPBKCTRL_LPBKW 0x00040000
+/** Stop loopback to check the error register */
+#define CTL_59_LPBKCTRL_LPBKST 0x00080000
+/** Clear loopback registers */
+#define CTL_59_LPBKCTRL_LPBKC 0x000C0000
+/** Loopback Read MUX
+    Controls the loopback read multiplexer. */
+#define CTL_59_LPBKRM 0x00020000
+/** Loopback Write MUX
+    Controls the loopback write multiplexer. */
+#define CTL_59_LPBKWM 0x00010000
+/** Loopback LFSR to Error Checking Logic Delay
+    Sets the cycle delay between the Linear Feedback Shift Register (LFSR) and loopback error check logic. */
+#define CTL_59_LPBKLFSRECLD_MASK 0x00007000
+/** field offset */
+#define CTL_59_LPBKLFSRECLD_OFFSET 12
+/** Read DQS Gate Close Configuration
+    This bit is used to delay the read DQS gate close logic in the DDR SDRAM PHY. This bit should be set to b1 if the DDR SDRAM controller is running in echo gate mode (CTL_53.EGC = b1) and the echo delay (pad_out + pad_in + flight + flight + tdqsck_max) 2 cycles. */
+#define CTL_59_DQS_GATE_CLOSE_CFG 0x00000800
+/** Stretch Trailing Edge of DFI Read Data Enable
+    This bit field stretches the trailing edge of dfi_rddata_en for closing the read DQS gate */
+#define CTL_59_STRTREGT_MASK 0x00000700
+/** field offset */
+#define CTL_59_STRTREGT_OFFSET 8
+/** Read DQS Gate Opening
+    This bit field controls, when the read DQS gate opens. This value is the number of cycles to delay the dfi_rddata_en signal prior to opening the read DQS gate. */
+#define CTL_59_DQS_GATE_OPEN_MASK 0x000000FF
+/** field offset */
+#define CTL_59_DQS_GATE_OPEN_OFFSET 0
+
+/* Fields of "Denali CTL_60 register" */
+/** Dynamic On-Die Termination Enable Time
+    Defines the dynamic on-die termination enable time. Larger values add greater delay to when signal tsel turns on. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_60_ODT_ENT_MASK 0xF0000000
+/** field offset */
+#define CTL_60_ODT_ENT_OFFSET 28
+/** Dynamic On-Die Termination Disable Time
+    Defines the dynamic on-die termination disable time. Larger values reduce the delay to when signal tsel turns off. Each bit changes the output enable time by a 1/2 cycle resolution. */
+#define CTL_60_ODT_DIST_MASK 0x0F000000
+/** field offset */
+#define CTL_60_ODT_DIST_OFFSET 24
+/** Dynamic On-Die Termination Enable
+    Enables/disables dynamic on-die termination in the PHY. This bit must be set to allow dynamic on-die termination options to be used. */
+#define CTL_60_ODT_EN 0x00800000
+/* Disable
+#define CTL_60_ODT_EN_DIS 0x00000000 */
+/** Enable */
+#define CTL_60_ODT_EN_EN 0x00800000
+/** Dynamic On-Die Termination Polarity of TSEL
+    Controls the polarity of signal tsel for the data bus, the strobe signals and the data mask signals in the PHY. */
+#define CTL_60_ODT_PTSEL 0x00400000
+/* Negative Polarity
+#define CTL_60_ODT_PTSEL_NEG 0x00000000 */
+/** Positive Polarity */
+#define CTL_60_ODT_PTSEL_POS 0x00400000
+/** Trigger Data Return
+    Triggers a data return (loopback data on the dfi_rddata signal) to the DDR SDRAM Controller. */
+#define CTL_60_TDR 0x00200000
+/* No-Operation
+#define CTL_60_TDR_NOP 0x00000000 */
+/** Trigger */
+#define CTL_60_TDR_TRIG 0x00200000
+/** Loopback Data Output Type
+    Selects data output type to either the actual data or expected data for bit field CTL_65.LPBKDATA */
+#define CTL_60_LPBKDOT 0x00100000
+/* Return the expected data
+#define CTL_60_LPBKDOT_LPBKEXP 0x00000000 */
+/** Return the actual data */
+#define CTL_60_LPBKDOT_LPBKACT 0x00100000
+/** Loopback Control
+    Selects the different options in loopback mode. */
+#define CTL_60_LPBKCTRL_MASK 0x000C0000
+/** field offset */
+#define CTL_60_LPBKCTRL_OFFSET 18
+/** Normal operational mode */
+#define CTL_60_LPBKCTRL_LPBKN 0x00000000
+/** Enables loopback write mode */
+#define CTL_60_LPBKCTRL_LPBKW 0x00040000
+/** Stop loopback to check the error register */
+#define CTL_60_LPBKCTRL_LPBKST 0x00080000
+/** Clear loopback registers */
+#define CTL_60_LPBKCTRL_LPBKC 0x000C0000
+/** Loopback Read MUX
+    Controls the loopback read multiplexer. */
+#define CTL_60_LPBKRM 0x00020000
+/** Loopback Write MUX
+    Controls the loopback write multiplexer. */
+#define CTL_60_LPBKWM 0x00010000
+/** Loopback LFSR to Error Checking Logic Delay
+    Sets the cycle delay between the Linear Feedback Shift Register (LFSR) and loopback error check logic. */
+#define CTL_60_LPBKLFSRECLD_MASK 0x00007000
+/** field offset */
+#define CTL_60_LPBKLFSRECLD_OFFSET 12
+/** Read DQS Gate Close Configuration
+    This bit is used to delay the read DQS gate close logic in the DDR SDRAM PHY. This bit should be set to b1 if the DDR SDRAM controller is running in echo gate mode (CTL_53.EGC = b1) and the echo delay (pad_out + pad_in + flight + flight + tdqsck_max) 2 cycles. */
+#define CTL_60_DQS_GATE_CLOSE_CFG 0x00000800
+/** Stretch Trailing Edge of DFI Read Data Enable
+    This bit field stretches the trailing edge of dfi_rddata_en for closing the read DQS gate */
+#define CTL_60_STRTREGT_MASK 0x00000700
+/** field offset */
+#define CTL_60_STRTREGT_OFFSET 8
+/** Read DQS Gate Opening
+    This bit field controls, when the read DQS gate opens. This value is the number of cycles to delay the dfi_rddata_en signal prior to opening the read DQS gate. */
+#define CTL_60_DQS_GATE_OPEN_MASK 0x000000FF
+/** field offset */
+#define CTL_60_DQS_GATE_OPEN_OFFSET 0
+
+/* Fields of "Denali CTL_61 register" */
+/** Select Address and Command Path
+    Selects the latency of the address and command path. Note: The Low Latency option is not functional at this time */
+#define CTL_61_SELACP 0x02000000
+/* DFI control signals are captured 1 cycle after being sent from the DDR SDRAM Controller
+#define CTL_61_SELACP_ACCYC 0x00000000 */
+/** DFI control signals are captured 1/4 cycle after being sent from the DDR SDRAM Controller */
+#define CTL_61_SELACP_ACQRT 0x02000000
+/** Select Write Data Path
+    Selects the latency of the write data path. Note:The Low Latency option is not functional at this time */
+#define CTL_61_SELWRP 0x01000000
+/* Write Data is captured 1 cycle after being sent from the DDR SDRAM Controller
+#define CTL_61_SELWRP_WRCYC 0x00000000 */
+/** Write data is captured 1/4 ycle after being sent from the DDR SDRAM Controller. */
+#define CTL_61_SELWRP_WRQRT 0x01000000
+/** DFI Control Mobile MCs
+    DFI Control for Mobile MCs. This bit is unused for this MC. */
+#define CTL_61_DFICM 0x00800000
+/** Loopback Pad Input External Enable
+    Enables the pad inputs specifically for external loopback. */
+#define CTL_61_LPBKPIEXEN 0x00000020
+/* Normal Operation
+#define CTL_61_LPBKPIEXEN_NORM 0x00000000 */
+/** Loopback Mode */
+#define CTL_61_LPBKPIEXEN_LPBK 0x00000020
+/** Loopback Pad Output External Enable
+    Enables the pad outputs specifically for external loopback mode. */
+#define CTL_61_LPBKPOEXEN 0x00000010
+/* Normal Operation
+#define CTL_61_LPBKPOEXEN_NORM 0x00000000 */
+/** Loopback Mode */
+#define CTL_61_LPBKPOEXEN_LPBK 0x00000010
+/** DFI Read Data Valid to Enable Delay
+    Sets the dfi_rddata_valid delay relative to dfi_rddata_en. The dfi_rddata_valid signal is not used in the DDR SDRAM controller */
+#define CTL_61_DFIRDVEDLY_MASK 0x0000000F
+/** field offset */
+#define CTL_61_DFIRDVEDLY_OFFSET 0
+
+/* Fields of "Denali CTL_62 register" */
+/** Gate Close Forced Status
+    Status signal to indicate that the logic gate had to be forced closed. */
+#define CTL_62_GCF 0x01000000
+/* Nothing
+#define CTL_62_GCF_NULL 0x00000000 */
+/** Loopback Data
+    Reports the actual data or expected data, depending on the setting of CTL_57.LPBKDOT. */
+#define CTL_62_LPBKDATA_MASK 0x00FFFF00
+/** field offset */
+#define CTL_62_LPBKDATA_OFFSET 8
+/** Loopback Mask Data
+    Reports the actual data mask or the expected data mask, depending on the setting of CTL_57.LPBKDOT. */
+#define CTL_62_LBMASKDATA_MASK 0x00000030
+/** field offset */
+#define CTL_62_LBMASKDATA_OFFSET 4
+/** Loopback Error Status
+    Reports status of loopback errors. */
+#define CTL_62_LPBKERR 0x00000002
+/* Last Loopback test had no errors.
+#define CTL_62_LPBKERR_NLPBKERR 0x00000000 */
+/** Loopback Mode Status
+    Defines the status of the loopback mode. */
+#define CTL_62_LPBKMODE 0x00000001
+/* Not in loopback mode
+#define CTL_62_LPBKMODE_NLPBKMODE 0x00000000 */
+
+/* Fields of "Denali CTL_63 register" */
+/** Gate Close Forced Status
+    Status signal to indicate that the logic gate had to be forced closed. */
+#define CTL_63_GCF 0x01000000
+/* Nothing
+#define CTL_63_GCF_NULL 0x00000000 */
+/** Loopback Data
+    Reports the actual data or expected data, depending on the setting of CTL_58.LPBKDOT. */
+#define CTL_63_LPBKDATA_MASK 0x00FFFF00
+/** field offset */
+#define CTL_63_LPBKDATA_OFFSET 8
+/** Loopback Mask Data
+    Reports the actual data mask or the expected data mask, depending on the setting of CTL_58.LPBKDOT. */
+#define CTL_63_LBMASKDATA_MASK 0x00000030
+/** field offset */
+#define CTL_63_LBMASKDATA_OFFSET 4
+/** Loopback Error Status
+    Reports status of loopback errors. */
+#define CTL_63_LPBKERR 0x00000002
+/* Last Loopback test had no errors.
+#define CTL_63_LPBKERR_NLPBKERR 0x00000000 */
+/** Loopback Mode Status
+    Defines the status of the loopback mode. */
+#define CTL_63_LPBKMODE 0x00000001
+/* Not in loopback mode
+#define CTL_63_LPBKMODE_NLPBKMODE 0x00000000 */
+
+/* Fields of "Denali CTL_64 register" */
+/** Gate Close Forced Status
+    Status signal to indicate that the logic gate had to be forced closed. */
+#define CTL_64_GCF 0x01000000
+/* Nothing
+#define CTL_64_GCF_NULL 0x00000000 */
+/** Loopback Data
+    Reports the actual data or expected data, depending on the setting of CTL_59.LPBKDOT. */
+#define CTL_64_LPBKDATA_MASK 0x00FFFF00
+/** field offset */
+#define CTL_64_LPBKDATA_OFFSET 8
+/** Loopback Mask Data
+    Reports the actual data mask or the expected data mask, depending on the setting of CTL_59.LPBKDOT. */
+#define CTL_64_LBMASKDATA_MASK 0x00000030
+/** field offset */
+#define CTL_64_LBMASKDATA_OFFSET 4
+/** Loopback Error Status
+    Reports status of loopback errors. */
+#define CTL_64_LPBKERR 0x00000002
+/* Last Loopback test had no errors.
+#define CTL_64_LPBKERR_NLPBKERR 0x00000000 */
+/** Loopback Mode Status
+    Defines the status of the loopback mode. */
+#define CTL_64_LPBKMODE 0x00000001
+/* Not in loopback mode
+#define CTL_64_LPBKMODE_NLPBKMODE 0x00000000 */
+
+/* Fields of "Denali CTL_65 register" */
+/** Gate Close Forced Status
+    Status signal to indicate that the logic gate had to be forced closed. */
+#define CTL_65_GCF 0x01000000
+/* Nothing
+#define CTL_65_GCF_NULL 0x00000000 */
+/** Loopback Data
+    Reports the actual data or expected data, depending on the setting of CTL_60.LPBKDOT. */
+#define CTL_65_LPBKDATA_MASK 0x00FFFF00
+/** field offset */
+#define CTL_65_LPBKDATA_OFFSET 8
+/** Loopback Mask Data
+    Reports the actual data mask or the expected data mask, depending on the setting of CTL_60.LPBKDOT. */
+#define CTL_65_LBMASKDATA_MASK 0x00000030
+/** field offset */
+#define CTL_65_LBMASKDATA_OFFSET 4
+/** Loopback Error Status
+    Reports status of loopback errors. */
+#define CTL_65_LPBKERR 0x00000002
+/* Last Loopback test had no errors.
+#define CTL_65_LPBKERR_NLPBKERR 0x00000000 */
+/** Loopback Mode Status
+    Defines the status of the loopback mode. */
+#define CTL_65_LPBKMODE 0x00000001
+/* Not in loopback mode
+#define CTL_65_LPBKMODE_NLPBKMODE 0x00000000 */
+
+/* Fields of "Denali CTL_66 register" */
+/** Reports master DLL info for delay line 0. Bits [31:0]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_66_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_66_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_67 register" */
+/** Reports master DLL info for delay line 0. Bits [63:32]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_67_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_67_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_68 register" */
+/** Reports master DLL info for delay line 0. Bits [95:64]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_68_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_68_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_69 register" */
+/** Reports master DLL info for delay line 0. Bits [127:96]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_69_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_69_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_70 register" */
+/** Reports master DLL info for delay line 0. Bits [159:128]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_70_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_70_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_71 register" */
+/** Reports master DLL info for delay line 0. Bits [191:160]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_71_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_71_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_72 register" */
+/** Reports master DLL info for delay line 0. Bits [223:192]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_72_DLL_OBS_REG_1_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_72_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_73 register" */
+/** Reports master DLL info for delay line 0. Bits [251:224]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_73_DLL_OBS_REG_1_0_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_73_DLL_OBS_REG_1_0_OFFSET 0
+
+/* Fields of "Denali CTL_74 register" */
+/** Reports master DLL info for delay line 1. Bits [31:0]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_74_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_74_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_75 register" */
+/** Reports master DLL info for delay line 1. Bits [63:32]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_75_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_75_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_76 register" */
+/** Reports master DLL info for delay line 1. Bits [95:64]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_76_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_76_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_77 register" */
+/** Reports master DLL info for delay line 1. Bits [127:96]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_77_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_77_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_78 register" */
+/** Reports master DLL info for delay line 1. Bits [159:128]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_78_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_78_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_79 register" */
+/** Reports master DLL info for delay line 1. Bits [191:160]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_79_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_79_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_80 register" */
+/** Reports master DLL info for delay line 1. Bits [223:192]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_80_DLL_OBS_REG_1_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_80_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_81 register" */
+/** Reports master DLL info for delay line 1. Bits [251:224]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_81_DLL_OBS_REG_1_1_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_81_DLL_OBS_REG_1_1_OFFSET 0
+
+/* Fields of "Denali CTL_82 register" */
+/** Reports master DLL info for delay line 2. Bits [31:0]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_82_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_82_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_83 register" */
+/** Reports master DLL info for delay line 2. Bits [63:32]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_83_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_83_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_84 register" */
+/** Reports master DLL info for delay line 2. Bits [95:64]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_84_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_84_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_85 register" */
+/** Reports master DLL info for delay line 2. Bits [127:96]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_85_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_85_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_86 register" */
+/** Reports master DLL info for delay line 2. Bits [159:128]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_86_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_86_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_87 register" */
+/** Reports master DLL info for delay line 2. Bits [191:160]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_87_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_87_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_88 register" */
+/** Reports master DLL info for delay line 2. Bits [223:192]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_88_DLL_OBS_REG_1_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_88_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_89 register" */
+/** Reports master DLL info for delay line 2. Bits [251:224]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_89_DLL_OBS_REG_1_2_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_89_DLL_OBS_REG_1_2_OFFSET 0
+
+/* Fields of "Denali CTL_90 register" */
+/** Reports master DLL info for delay line 3. Bits [31:0]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_90_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_90_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_91 register" */
+/** Reports master DLL info for delay line 3. Bits [63:32]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_91_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_91_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_92 register" */
+/** Reports master DLL info for delay line 3. Bits [95:64]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_92_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_92_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_93 register" */
+/** Reports master DLL info for delay line 3. Bits [127:96]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_93_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_93_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_94 register" */
+/** Reports master DLL info for delay line 3. Bits [159:128]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_94_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_94_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_95 register" */
+/** Reports master DLL info for delay line 3. Bits [191:160]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_95_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_95_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_96 register" */
+/** Reports master DLL info for delay line 3. Bits [223:192]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_96_DLL_OBS_REG_1_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_96_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_97 register" */
+/** Reports master DLL info for delay line 3. Bits [251:224]
+    One-hot register that identifies which multiplexer controls the master delay line. As an example, 0x200 = b1000000000, so this identifies the 10th multiplexer. */
+#define CTL_97_DLL_OBS_REG_1_3_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_97_DLL_OBS_REG_1_3_OFFSET 0
+
+/* Fields of "Denali CTL_98 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [31:0] */
+#define CTL_98_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_98_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_99 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [63:32] */
+#define CTL_99_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_99_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_100 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [95:64] */
+#define CTL_100_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_100_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_101 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [127:96] */
+#define CTL_101_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_101_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_102 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [159:128] */
+#define CTL_102_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_102_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_103 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [191:160] */
+#define CTL_103_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_103_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_104 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [223:192] */
+#define CTL_104_DLL_OBS_REG_2_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_104_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_105 register" */
+/** Reports the read DQS delay value for data slice 0. Bits [251:224] */
+#define CTL_105_DLL_OBS_REG_2_0_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_105_DLL_OBS_REG_2_0_OFFSET 0
+
+/* Fields of "Denali CTL_106 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [31:0] */
+#define CTL_106_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_106_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_107 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [63:32] */
+#define CTL_107_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_107_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_108 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [95:64] */
+#define CTL_108_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_108_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_109 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [127:96] */
+#define CTL_109_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_109_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_110 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [159:128] */
+#define CTL_110_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_110_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_111 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [191:160] */
+#define CTL_111_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_111_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_112 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [223:192] */
+#define CTL_112_DLL_OBS_REG_2_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_112_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_113 register" */
+/** Reports the read DQS delay value for data slice 1. Bits [251:224] */
+#define CTL_113_DLL_OBS_REG_2_1_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_113_DLL_OBS_REG_2_1_OFFSET 0
+
+/* Fields of "Denali CTL_114 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [31:0] */
+#define CTL_114_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_114_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_115 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [63:32] */
+#define CTL_115_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_115_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_116 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [95:64] */
+#define CTL_116_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_116_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_117 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [127:96] */
+#define CTL_117_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_117_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_118 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [159:128] */
+#define CTL_118_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_118_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_119 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [191:160] */
+#define CTL_119_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_119_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_120 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [223:192] */
+#define CTL_120_DLL_OBS_REG_2_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_120_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_121 register" */
+/** Reports the read DQS delay value for data slice 2. Bits [251:224] */
+#define CTL_121_DLL_OBS_REG_2_2_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_121_DLL_OBS_REG_2_2_OFFSET 0
+
+/* Fields of "Denali CTL_122 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [31:0] */
+#define CTL_122_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_122_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_123 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [63:32] */
+#define CTL_123_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_123_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_124 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [95:64] */
+#define CTL_124_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_124_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_125 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [127:96] */
+#define CTL_125_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_125_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_126 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [159:128] */
+#define CTL_126_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_126_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_127 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [191:160] */
+#define CTL_127_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_127_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_128 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [223:192] */
+#define CTL_128_DLL_OBS_REG_2_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_128_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_129 register" */
+/** Reports the read DQS delay value for data slice 3. Bits [251:224] */
+#define CTL_129_DLL_OBS_REG_2_3_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_129_DLL_OBS_REG_2_3_OFFSET 0
+
+/* Fields of "Denali CTL_130 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [31:0] */
+#define CTL_130_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_130_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_131 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [63:32] */
+#define CTL_131_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_131_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_132 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [95:64] */
+#define CTL_132_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_132_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_133 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [127:96] */
+#define CTL_133_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_133_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_134 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [159:128] */
+#define CTL_134_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_134_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_135 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [191:160] */
+#define CTL_135_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_135_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_136 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [223:192] */
+#define CTL_136_DLL_OBS_REG_3_0_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_136_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_137 register" */
+/** Reports the clk_wr delay value for data slice 0. Bits [251:224] */
+#define CTL_137_DLL_OBS_REG_3_0_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_137_DLL_OBS_REG_3_0_OFFSET 0
+
+/* Fields of "Denali CTL_138 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [31:0] */
+#define CTL_138_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_138_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_139 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [63:32] */
+#define CTL_139_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_139_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_140 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [95:64] */
+#define CTL_140_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_140_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_141 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [127:96] */
+#define CTL_141_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_141_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_142 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [159:128] */
+#define CTL_142_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_142_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_143 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [191:160] */
+#define CTL_143_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_143_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_144 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [223:192] */
+#define CTL_144_DLL_OBS_REG_3_1_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_144_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_145 register" */
+/** Reports the clk_wr delay value for data slice 1. Bits [251:224] */
+#define CTL_145_DLL_OBS_REG_3_1_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_145_DLL_OBS_REG_3_1_OFFSET 0
+
+/* Fields of "Denali CTL_146 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [31:0] */
+#define CTL_146_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_146_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_147 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [63:32] */
+#define CTL_147_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_147_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_148 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [95:64] */
+#define CTL_148_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_148_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_149 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [127:96] */
+#define CTL_149_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_149_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_150 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [159:128] */
+#define CTL_150_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_150_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_151 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [191:160] */
+#define CTL_151_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_151_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_152 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [223:192] */
+#define CTL_152_DLL_OBS_REG_3_2_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_152_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_153 register" */
+/** Reports the clk_wr delay value for data slice 2. Bits [251:224] */
+#define CTL_153_DLL_OBS_REG_3_2_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_153_DLL_OBS_REG_3_2_OFFSET 0
+
+/* Fields of "Denali CTL_154 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [31:0] */
+#define CTL_154_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_154_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_155 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [63:32] */
+#define CTL_155_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_155_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_156 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [95:64] */
+#define CTL_156_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_156_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_157 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [127:96] */
+#define CTL_157_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_157_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_158 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [159:128] */
+#define CTL_158_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_158_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_159 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [191:160] */
+#define CTL_159_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_159_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_160 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [223:192] */
+#define CTL_160_DLL_OBS_REG_3_3_MASK 0xFFFFFFFF
+/** field offset */
+#define CTL_160_DLL_OBS_REG_3_3_OFFSET 0
+
+/* Fields of "Denali CTL_161 register" */
+/** Reports the clk_wr delay value for data slice 3. Bits [251:224] */
+#define CTL_161_DLL_OBS_REG_3_3_MASK 0x0FFFFFFF
+/** field offset */
+#define CTL_161_DLL_OBS_REG_3_3_OFFSET 0
+
+/*! @} */ /* DDRDB_REGISTER */
+
+#endif /* _ddrdb_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/ebu_reg.h b/arch/mips/include/asm/arch-falcon/ebu_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/ebu_reg.h
@@ -0,0 +1,1520 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _ebu_reg_h
+#define _ebu_reg_h
+
+/** \addtogroup EBU_REGISTER
+   @{
+*/
+/* access macros */
+#define ebu_r32(reg) reg_r32(&ebu->reg)
+#define ebu_w32(val, reg) reg_w32(val, &ebu->reg)
+#define ebu_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &ebu->reg)
+#define ebu_r32_table(reg, idx) reg_r32_table(ebu->reg, idx)
+#define ebu_w32_table(val, reg, idx) reg_w32_table(val, ebu->reg, idx)
+#define ebu_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, ebu->reg, idx)
+#define ebu_adr_table(reg, idx) adr_table(ebu->reg, idx)
+
+
+/** EBU register structure */
+struct gpon_reg_ebu
+{
+   /** Reserved */
+   unsigned int res_0[2]; /* 0x00000000 */
+   /** Module ID Register
+       Module type and version identifier */
+   unsigned int modid; /* 0x00000008 */
+   /** Module Control Register
+       This register contains general configuration information observed for all CS regions or dealing with EBU functionality that is not directly related to external memory access. */
+   unsigned int modcon; /* 0x0000000C */
+   /** Bus Read Configuration Register0
+       Note: The actual length of field enable depends on the number of bus ports connected to the EBU. For the GPON it is a single port (the bridge to the Asynchronous Xbar) so only bit 0 is implemented with all other bits tied to '0'. */
+   unsigned int busrcon0; /* 0x00000010 */
+   /** Bus Read Parameters Register0 */
+   unsigned int busrp0; /* 0x00000014 */
+   /** Bus Write Configuration Register0
+       Note: The actual length of field enable depends on the number of bus ports connected to the EBU. For the GPON it is a single port (the bridge to the Asynchronous Xbar) so only bit 0 is implemented with all other bits tied to '0'. */
+   unsigned int buswcon0; /* 0x00000018 */
+   /** Bus Write Parameters Register0 */
+   unsigned int buswp0; /* 0x0000001C */
+   /** Bus Read Configuration Register1
+       Note: The actual length of field enable depends on the number of bus ports connected to the EBU. For the GPON it is a single port (the bridge to the Asynchronous Xbar) so only bit 0 is implemented with all other bits tied to '0'. */
+   unsigned int busrcon1; /* 0x00000020 */
+   /** Bus Read Parameters Register1 */
+   unsigned int busrp1; /* 0x00000024 */
+   /** Bus Write Configuration Register1
+       Note: The actual length of field enable depends on the number of bus ports connected to the EBU. For the GPON it is a single port (the bridge to the Asynchronous Xbar) so only bit 0 is implemented with all other bits tied to '0'. */
+   unsigned int buswcon1; /* 0x00000028 */
+   /** Bus Write Parameters Register1 */
+   unsigned int buswp1; /* 0x0000002C */
+   /** Reserved */
+   unsigned int res_1[8]; /* 0x00000030 */
+   /** Bus Protocol Configuration Extension Register 0 */
+   unsigned int busconext0; /* 0x00000050 */
+   /** Bus Protocol Configuration Extension Register 1 */
+   unsigned int busconext1; /* 0x00000054 */
+   /** Reserved */
+   unsigned int res_2[10]; /* 0x00000058 */
+   /** Serial Flash Configuration Register
+       The content of this register configures the EBU's Serial Flash protocol engine. */
+   unsigned int sfcon; /* 0x00000080 */
+   /** Serial Flash Timing Register
+       This register defines the signal timing for the Serial Flash Access. See Section 3.18.3 on page 112 for details. */
+   unsigned int sftime; /* 0x00000084 */
+   /** Serial Flash Status Register
+       This register holds status information on the Serial Flash device(s) attached and the EBU's Serial Flash protocol engine. */
+   unsigned int sfstat; /* 0x00000088 */
+   /** Serial Flash Command Register
+       When writing to this register's opcode field, a command is started in the EBU's Serial Flash controller. */
+   unsigned int sfcmd; /* 0x0000008C */
+   /** Serial Flash Address Register
+       This register holds the address to be sent (if any) with accesses to/from a Serial Flash started by writing to EBU_SFCMD (Indirect Access Mode, see Section 3.18.2.4.1 on page 103). */
+   unsigned int sfaddr; /* 0x00000090 */
+   /** Serial Flash Data Register
+       This register holds the data being transferred (if any) with accesses to/from a Serial Flash started by writing to EBU_SFCMD (Indirect Access Mode, see Section 4.18.2.4.1 on page 116). */
+   unsigned int sfdata; /* 0x00000094 */
+   /** Serial Flash I/O Control Register
+       This register provides additional configuration for controlling the IO pads of the Serial Flash interface. */
+   unsigned int sfio; /* 0x00000098 */
+   /** Reserved */
+   unsigned int res_3[25]; /* 0x0000009C */
+};
+
+
+/* Fields of "Module ID Register" */
+/** Feature Select
+    This field indicates the types of external devices/protocols supported by the GPON version of the EBU. */
+#define MODID_FSEL_MASK 0xE0000000
+/** field offset */
+#define MODID_FSEL_OFFSET 29
+/** Support for SRAM, NAND/NOR/OneNand Flash and Cellular RAM is implemented. */
+#define MODID_FSEL_SRAM_FLASH_CRAM 0x00000000
+/** Support for SRAM, NAND/NOR/OneNand Flash, Cellular RAM and SDR SDRAM is implemented. */
+#define MODID_FSEL_SRAM_FLASH_CRAM_SDR 0x20000000
+/** Support for SRAM, NAND/NOR/OneNand Flash, Cellular RAM and SDR/DDR SDRAM is implemented. */
+#define MODID_FSEL_SRAM_FLASH_CRAM_DDR 0x40000000
+/** Support for SRAM, NAND/NOR/OneNand Flash, Cellular RAM, SDR/DDR SDRAM 0nd LPDDR-Flash is implemented. */
+#define MODID_FSEL_SRAM_FLASH_CRAM_DDR_LPNVM 0x60000000
+/** Serial Flash Support
+    Indicates whether or not the support of Serial Flash devices is available. */
+#define MODID_SF 0x10000000
+/* Not Available
+#define MODID_SF_NAV 0x00000000 */
+/** Available */
+#define MODID_SF_AV 0x10000000
+/** AAD-mux Support
+    Indicates whether or not the GPON EBU supports AAD-mux protocol for Burst Flash and Cellular RAM. */
+#define MODID_AAD 0x08000000
+/* Not Available
+#define MODID_AAD_NAV 0x00000000 */
+/** Available */
+#define MODID_AAD_AV 0x08000000
+/** Indicates whether or not the GPON EBU implements a DLL which is e.g. used for 50% duty cycle external clock generation. Note that a DLL is always implemented if DDR-SDRAM support is selected. */
+#define MODID_DLL 0x04000000
+/* Not Available
+#define MODID_DLL_NAV 0x00000000 */
+/** Available */
+#define MODID_DLL_AV 0x04000000
+/** Pad Multiplexing Scheme */
+#define MODID_PMS_MASK 0x03000000
+/** field offset */
+#define MODID_PMS_OFFSET 24
+/** The EBU comprises of dedicated address pins A[EXTAW-1=:16]. */
+#define MODID_PMS_PMS_CLASSIC 0x00000000
+/** Revision
+    Revision Number */
+#define MODID_REV_MASK 0x000F0000
+/** field offset */
+#define MODID_REV_OFFSET 16
+/** Module ID
+    This field contains the EBU's unique peripheral ID. */
+#define MODID_ID_MASK 0x0000FF00
+/** field offset */
+#define MODID_ID_OFFSET 8
+/** Version
+    This field gives the EBU version number. */
+#define MODID_VERSION_MASK 0x000000FF
+/** field offset */
+#define MODID_VERSION_OFFSET 0
+
+/* Fields of "Module Control Register" */
+/** Reserved */
+#define MODCON_DLLUPDINT_MASK 0xC0000000
+/** field offset */
+#define MODCON_DLLUPDINT_OFFSET 30
+/** Access Inhibit Acknowledge
+    After suspension of all accesses to the External Bus has been requested by setting bit acc_inh, acc_inh_ack acknowledges the request and inidcates that access suspension is now in effect. The bit is cleared when acc_inh gets deasserted. */
+#define MODCON_AIA 0x02000000
+/* no access restriction are active in the EBU subsystem
+#define MODCON_AIA_NO_INHIBIT 0x00000000 */
+/** accesses are restricted to selected (configuration) system bus port(s) */
+#define MODCON_AIA_INHIBIT 0x02000000
+/** Access Inhibit request
+    Setting this bit will suspend all non-CPU system bus ports and the EBU itself from accessing the External Bus. This feature is usually used when the CPU needs to reconfigure protocol parameters in the EBU in order to avoid external accesses with invalid settings. The EBU acknowledges that the access suspension is in effect by asserting acc_inh_ack. */
+#define MODCON_AI 0x01000000
+/* no access restriction are active in the EBU subsystem
+#define MODCON_AI_NO_INHIBIT 0x00000000 */
+/** accesses are restricted to selected (configuration) system bus port(s) */
+#define MODCON_AI_INHIBIT 0x01000000
+/** Lock Timeout */
+#define MODCON_LTO_MASK 0x00FF0000
+/** field offset */
+#define MODCON_LTO_OFFSET 16
+/** Reserved */
+#define MODCON_DDREN 0x00008000
+/** Pad Drive Control
+    Intended to be used to control the EBU pad''s drive strength. Refer to the GPON chip specification to see which drive strnegth options are available and whether they are actually controlled by the EBU's register bit. The value stored in this register bit is directly connected to the corresponding output of the EBU module and takes no functional effect within the EBU itself. */
+#define MODCON_PEXT 0x00004000
+/* Normal drive
+#define MODCON_PEXT_NORMAL 0x00000000 */
+/** Strong drive */
+#define MODCON_PEXT_STRONG 0x00004000
+/** Pad Slew Falling Edge Control
+    Intended to be used to trim the External Bus pad's falling edge slew rate. Refer to the GPON chip specification to see which slew rate options are available and whether they are actually controlled by the EBU's register bit. The value stored in this register bit is directly connected to the corresponding output of the EBU module and takes no functional effect within the EBU itself. */
+#define MODCON_SLF 0x00002000
+/* Slow slew rate
+#define MODCON_SLF_SLOW 0x00000000 */
+/** Fast slew rate */
+#define MODCON_SLF_FAST 0x00002000
+/** Pad Slew Rising Edge Control
+    Intended to be used to trim the External Bus pad's rising edge slew rate. Refer to the GPON chip specification to see which slew rate options are available and whether they are actually controlled by the EBU's register bit. The value stored in this register bit is directly connected to the corresponding output of the EBU module and takes no functional effect within the EBU itself. */
+#define MODCON_SLR 0x00001000
+/* Slow slew rate
+#define MODCON_SLR_SLOW 0x00000000 */
+/** Fast slew rate */
+#define MODCON_SLR_FAST 0x00001000
+/** Write Buffering Mode
+    This bit controls when the EBU starts a new write burst transaction from the Memport interface. */
+#define MODCON_WBM 0x00000040
+/* The EBU starts a write transaction on the External Bus as early as possible, expecting that the n beats of the write burst will be transferred within n or n+1 clock cycles over the EBU's Memport interface. Use this mode if the EBU is clocked at the same or a slower frequency than the system bus interconnect.
+#define MODCON_WBM_START_WRITE_EARLY 0x00000000 */
+/** The EBU start a write transaction only after all data of a write burst have been received over the EBU's Memport interface. Use this mode if the EBU is clocked at a higher frequency than the system bus interrconnect. */
+#define MODCON_WBM_START_WRITE_LATE 0x00000040
+/** Reserved */
+#define MODCON_SDCLKEN 0x00000020
+/** Standby Mode Enable
+    When set allows the EBU subsystem to enter standby mode in response to a rising edge on input signal standby_req_i. See Section 3.9.3 for details. */
+#define MODCON_STBYEN 0x00000010
+/* Disable
+#define MODCON_STBYEN_DIS 0x00000000 */
+/** Enable */
+#define MODCON_STBYEN_EN 0x00000010
+/** Enable BFCLK1
+    This field will enables or disables mirroring the clock that is output on BFCLKO_0 also on pad BFCLKO_1 to double the drive strength. See also Section 3.17.3) */
+#define MODCON_BFCLK1EN 0x00000008
+/* Disable
+#define MODCON_BFCLK1EN_DIS 0x00000000 */
+/** Enable */
+#define MODCON_BFCLK1EN_EN 0x00000008
+/** Ready/Busy Status Edge
+    This is a read-only bit which shows a change of the logic level shown in the sts field since last read. It is reset by a read access. */
+#define MODCON_STSEDGE 0x00000004
+/** Ready/Busy Status
+    This is a read-only bit which reflects the current logic level present on the RDY/BSY or STS input pin which is (optionally) fed-in from a General Purpose I/O pad which is not part of the EBU via the EBU's input pin signal gpio_nand_rdy_ */
+#define MODCON_STS 0x00000002
+/** External Bus Arbitration Mode
+    This bit allows to disconnect the EBU from the External Bus. While EBU_MODCON.acc_inh_ack is 0, the value of arb_mode is forced to OWN_BUS. */
+#define MODCON_AM 0x00000001
+/* The EBU does not own the bus (multi-master)
+#define MODCON_AM_SHAREDBUS 0x00000000 */
+/** The EBU owns the external bus. */
+#define MODCON_AM_OWNBUS 0x00000001
+
+/* Fields of "Bus Read Configuration Register0" */
+/** Device Type For Region
+    After reset, the CS region is configured for a slow Asynchronous access protocol which is compatible with read access from an external multiplexed or demultiplexed 16-Bit Burst Flash in asynchronous mode. Reset: 0000B */
+#define BUSRCON0_AGEN_MASK 0xF0000000
+/** field offset */
+#define BUSRCON0_AGEN_OFFSET 28
+/** Muxed Asynchronous Type External Memory */
+#define BUSRCON0_AGEN_MUXED_ASYNC_TYPE_EXT_MEM 0x00000000
+/** Muxed Burst Type External Memory */
+#define BUSRCON0_AGEN_MUXED_BURST_TYPE_EXT_MEM 0x10000000
+/** NAND Flash (page optimised) */
+#define BUSRCON0_AGEN_NAND_FLASH 0x20000000
+/** Muxed Cellular RAM External Memory */
+#define BUSRCON0_AGEN_MUXED_CELLULAR_RAM_EXT_MEM 0x30000000
+/** Demuxed Asynchronous Type External Memory */
+#define BUSRCON0_AGEN_DEMUXED_ASYNC_TYPE_EXT_MEM 0x40000000
+/** Demuxed Burst Type External Memory */
+#define BUSRCON0_AGEN_DEMUXED_BURST_TYPE_EXT_MEM 0x50000000
+/** Demuxed Page Mode External Memory */
+#define BUSRCON0_AGEN_DEMUXED_PAGE_MODE_EXT_MEM 0x60000000
+/** Demuxed Cellular RAM External Memory */
+#define BUSRCON0_AGEN_DEMUXED_CELLULAR_RAM_EXT_MEM 0x70000000
+/** Serial Flash */
+#define BUSRCON0_AGEN_SERIAL_FLASH 0xF0000000
+/** Device Addressing Mode
+    t.b.d. */
+#define BUSRCON0_PORTW_MASK 0x0C000000
+/** field offset */
+#define BUSRCON0_PORTW_OFFSET 26
+/** 8-bit multiplexed */
+#define BUSRCON0_PORTW_8_BIT_MUX 0x00000000
+/** 16-bit multiplexed */
+#define BUSRCON0_PORTW_16_BIT_MUX 0x04000000
+/** Twin, 16-bit multiplexed */
+#define BUSRCON0_PORTW_TWIN_16_BIT_MUX 0x08000000
+/** 32-bit multiplexed */
+#define BUSRCON0_PORTW_32_BIT_MUX 0x0C000000
+/** External Wait Control
+    Function of the WAIT input. This is specific to the device type (i.e. the agen field). */
+#define BUSRCON0_WAIT_MASK 0x03000000
+/** field offset */
+#define BUSRCON0_WAIT_OFFSET 24
+/** WAIT is ignored (default after reset). */
+#define BUSRCON0_WAIT_OFF 0x00000000
+/** Synchronous Burst Devices: WAIT signal is provided one cycle ahead of the data cycle it applies to. */
+#define BUSRCON0_WAIT_EARLY_WAIT 0x01000000
+/** Asynchronous Devices: WAIT input passes through a two-stage synchronizer before being evaluated. */
+#define BUSRCON0_WAIT_TWO_STAGE_SYNC 0x01000000
+/** Synchronous Burst Devices: WAIT signal is provided in the same data cycle it applies to. */
+#define BUSRCON0_WAIT_WAIT_WITH_DATA 0x02000000
+/** Asynchronous Devices: WAIT input passes through a single-stage synchronizer before being evaluated. */
+#define BUSRCON0_WAIT_SINGLE_STAGE_SYNC 0x02000000
+/** Synchronous Burst Devices: Abort and retry access if WAIT asserted */
+#define BUSRCON0_WAIT_ABORT_AND_RETRY 0x03000000
+/** Disable Burst Address Wrapping */
+#define BUSRCON0_DBA 0x00800000
+/** Reversed polarity at wait */
+#define BUSRCON0_WAITINV 0x00400000
+/* Low active.
+#define BUSRCON0_WAITINV_ACTLOW 0x00000000 */
+/** High active */
+#define BUSRCON0_WAITINV_ACTHI 0x00400000
+/** Early ADV Enable for Synchronous Bursts */
+#define BUSRCON0_EBSE 0x00200000
+/* Low active.
+#define BUSRCON0_EBSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSRCON0_EBSE_NOT_DELAYED 0x00200000
+/** Early Control Signals for Synchronous Bursts */
+#define BUSRCON0_ECSE 0x00100000
+/* Low active.
+#define BUSRCON0_ECSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSRCON0_ECSE_NOT_DELAYED 0x00100000
+/** Synchronous Burst Buffer Mode Select */
+#define BUSRCON0_FBBMSEL 0x00080000
+/* FIXED_LENGTH
+#define BUSRCON0_FBBMSEL_FIXED_LENGTH 0x00000000 */
+/** CONTINUOUS */
+#define BUSRCON0_FBBMSEL_CONTINUOUS 0x00080000
+/** Burst Length for Synchronous Burst */
+#define BUSRCON0_FETBLEN_MASK 0x00070000
+/** field offset */
+#define BUSRCON0_FETBLEN_OFFSET 16
+/** Up to 1 data cycle (default after reset). */
+#define BUSRCON0_FETBLEN_SINGLE 0x00000000
+/** Up to 2 data cycles. */
+#define BUSRCON0_FETBLEN_BURST2 0x00010000
+/** Up to 4 data cycles. */
+#define BUSRCON0_FETBLEN_BURST4 0x00020000
+/** Up to 8 data cycles. */
+#define BUSRCON0_FETBLEN_BURST8 0x00030000
+/** Up to 16 data cycles. */
+#define BUSRCON0_FETBLEN_BURST16 0x00040000
+/** Reserved
+    This field allows to configure how the EBU generates the CLE and ALE signals for a NAND Flash device. The following options are available */
+#define BUSRCON0_NANDAMAP_MASK 0x0000C000
+/** field offset */
+#define BUSRCON0_NANDAMAP_OFFSET 14
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSRCON0_NANDAMAP_NAND_A17_16 0x00000000
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSRCON0_NANDAMAP_NAND_WAIT_ADV 0x00004000
+/** CLE is taken from AMemport[18] and ALE from AMemport[17] and are output on pins AD[9:8] and A[9:8] on the External Bus. This mode may only be used with a 8-Bit NAND-Flash device. */
+#define BUSRCON0_NANDAMAP_NAND_AD9_8 0x00008000
+/** Reserved for future use. Do not use or unpredictable results may occur. */
+#define BUSRCON0_NANDAMAP_NAND_RFU 0x0000C000
+/** AAD-mux Protocol
+    If this bit is set and the device is configured for a multiplexed access protocol in agen then the device is accessed in read mode using the AAD-mux protocol. If a non-multiplexed device type is selected in agen, field aadmux is ignored. */
+#define BUSRCON0_AADMUX 0x00002000
+/* Muxed device is write accessed in AD-mux mode.
+#define BUSRCON0_AADMUX_AD_MUX 0x00000000 */
+/** Muxed device is write accessed in AAD-mux mode. */
+#define BUSRCON0_AADMUX_AAD_MUX 0x00002000
+/** Asynchronous Address Phase */
+#define BUSRCON0_AAP 0x00001000
+/* Clock is enabled at beginning of access.
+#define BUSRCON0_AAP_EARLY 0x00000000 */
+/** Clock is enabled after address phase. */
+#define BUSRCON0_AAP_LATE 0x00001000
+/** Burst Flash Read Single Stage Synchronisation */
+#define BUSRCON0_BFSSS 0x00000800
+/* Two stages of synchronisation used.
+#define BUSRCON0_BFSSS_TWO_STAGE 0x00000000 */
+/** Single stage of synchronisation used. */
+#define BUSRCON0_BFSSS_SINGLE_STAGE 0x00000800
+/** Burst Flash Clock Feedback Enable */
+#define BUSRCON0_FDBKEN 0x00000400
+/* Disable
+#define BUSRCON0_FDBKEN_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON0_FDBKEN_EN 0x00000400
+/** Auxiliary Chip Select Enable
+    Not supported in GPON-EBU, field must be set to 0. */
+#define BUSRCON0_CSA 0x00000200
+/* Disable
+#define BUSRCON0_CSA_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON0_CSA_EN 0x00000200
+/** Flash Non-Array Access Enable
+    Set to logic one to enable workaround when region is accessed with internal address bit 28 set. See Section 3.17.13 on page 90 for details. */
+#define BUSRCON0_NAA 0x00000100
+/* Disable
+#define BUSRCON0_NAA_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON0_NAA_EN 0x00000100
+/** Module Enable */
+#define BUSRCON0_ENABLE 0x00000001
+/* Disable
+#define BUSRCON0_ENABLE_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON0_ENABLE_EN 0x00000001
+
+/* Fields of "Bus Read Parameters Register0" */
+/** Address Cycles
+    Number of cycles for address phase. */
+#define BUSRP0_ADDRC_MASK 0xF0000000
+/** field offset */
+#define BUSRP0_ADDRC_OFFSET 28
+/** Address Hold Cycles For Multiplexed Address
+    Number of address hold cycles during multiplexed accesses. */
+#define BUSRP0_ADHOLC_MASK 0x0F000000
+/** field offset */
+#define BUSRP0_ADHOLC_OFFSET 24
+/** Programmed Command Delay Cycles
+    Number of delay cycles during command delay phase. */
+#define BUSRP0_CMDDELAY_MASK 0x00F00000
+/** field offset */
+#define BUSRP0_CMDDELAY_OFFSET 20
+/** Extended Data */
+#define BUSRP0_EXTDATA_MASK 0x000C0000
+/** field offset */
+#define BUSRP0_EXTDATA_OFFSET 18
+/** External device outputs data every BFCLK cycle */
+#define BUSRP0_EXTDATA_ONE 0x00000000
+/** External device outputs data every 2nd BFCLK cycles */
+#define BUSRP0_EXTDATA_TWO 0x00040000
+/** External device outputs data every 4th BFCLK cycles */
+#define BUSRP0_EXTDATA_FOUR 0x00080000
+/** External device outputs data every 8th BFCLK cycles */
+#define BUSRP0_EXTDATA_EIGHT 0x000C0000
+/** Frequency of external clock at pin BFCLKO */
+#define BUSRP0_EXTCLOCK_MASK 0x00030000
+/** field offset */
+#define BUSRP0_EXTCLOCK_OFFSET 16
+/** Equal to ebu_clk frequency. */
+#define BUSRP0_EXTCLOCK_ONE_TO_ONE 0x00000000
+/** 1/2 of ebu_clk frequency. */
+#define BUSRP0_EXTCLOCK_ONE_TO_TWO 0x00010000
+/** 1/3 of ebu_clk frequency. */
+#define BUSRP0_EXTCLOCK_ONE_TO_THREE 0x00020000
+/** 1/4 of ebu_clk frequency (default after reset). */
+#define BUSRP0_EXTCLOCK_ONE_TO_FOUR 0x00030000
+/** Data Hold Cycles For read Accesses
+    Number of data hold cycles during read accesses. Applies to spinner support only where the address is guaranteed stable for datac clocks after RD high */
+#define BUSRP0_DATAC_MASK 0x0000F000
+/** field offset */
+#define BUSRP0_DATAC_OFFSET 12
+/** Programmed Wait States for read accesses
+    Number of programmed wait states for read accesses. For synchronous accesses, this will always be adjusted so that the phase exits on a rising edge of the external clock. */
+#define BUSRP0_WAITRDC_MASK 0x00000F80
+/** field offset */
+#define BUSRP0_WAITRDC_OFFSET 7
+/** Recovery Cycles After read Accesses, same CS
+    Number of idle cycles after read accesses when the next access is to the same chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSRCON. */
+#define BUSRP0_RECOVC_MASK 0x00000070
+/** field offset */
+#define BUSRP0_RECOVC_OFFSET 4
+/** Recovery Cycles After read Accesses, other CS
+    Number of idle cycles after read accesses when the next access is to a different chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSRCON. */
+#define BUSRP0_DTACS_MASK 0x0000000F
+/** field offset */
+#define BUSRP0_DTACS_OFFSET 0
+
+/* Fields of "Bus Write Configuration Register0" */
+/** Device Type For Region
+    After reset, the CS region is configured for a slow Asynchronous access protocol which is compatible with read access from an external multiplexed or demultiplexed 16-Bit Burst Flash in asynchronous mode. Reset: 0000B */
+#define BUSWCON0_AGEN_MASK 0xF0000000
+/** field offset */
+#define BUSWCON0_AGEN_OFFSET 28
+/** Muxed Asynchronous Type External Memory */
+#define BUSWCON0_AGEN_MUXED_ASYNC_TYPE_EXT_MEM 0x00000000
+/** Muxed Burst Type External Memory */
+#define BUSWCON0_AGEN_MUXED_BURST_TYPE_EXT_MEM 0x10000000
+/** NAND Flash (page optimised) */
+#define BUSWCON0_AGEN_NAND_FLASH 0x20000000
+/** Muxed Cellular RAM External Memory */
+#define BUSWCON0_AGEN_MUXED_CELLULAR_RAM_EXT_MEM 0x30000000
+/** Demuxed Asynchronous Type External Memory */
+#define BUSWCON0_AGEN_DEMUXED_ASYNC_TYPE_EXT_MEM 0x40000000
+/** Demuxed Burst Type External Memory */
+#define BUSWCON0_AGEN_DEMUXED_BURST_TYPE_EXT_MEM 0x50000000
+/** Demuxed Page Mode External Memory */
+#define BUSWCON0_AGEN_DEMUXED_PAGE_MODE_EXT_MEM 0x60000000
+/** Demuxed Cellular RAM External Memory */
+#define BUSWCON0_AGEN_DEMUXED_CELLULAR_RAM_EXT_MEM 0x70000000
+/** Serial Flash */
+#define BUSWCON0_AGEN_SERIAL_FLASH 0xF0000000
+/** Device Addressing Mode
+    t.b.d. */
+#define BUSWCON0_PORTW_MASK 0x0C000000
+/** field offset */
+#define BUSWCON0_PORTW_OFFSET 26
+/** External Wait Control
+    Function of the WAIT input. This is specific to the device type (i.e. the agen field). */
+#define BUSWCON0_WAIT_MASK 0x03000000
+/** field offset */
+#define BUSWCON0_WAIT_OFFSET 24
+/** WAIT is ignored (default after reset). */
+#define BUSWCON0_WAIT_OFF 0x00000000
+/** Synchronous Burst Devices: WAIT signal is provided one cycle ahead of the data cycle it applies to. */
+#define BUSWCON0_WAIT_EARLY_WAIT 0x01000000
+/** Asynchronous Devices: WAIT input passes through a two-stage synchronizer before being evaluated. */
+#define BUSWCON0_WAIT_TWO_STAGE_SYNC 0x01000000
+/** Synchronous Burst Devices: WAIT signal is provided in the same data cycle it applies to. */
+#define BUSWCON0_WAIT_WAIT_WITH_DATA 0x02000000
+/** Asynchronous Devices: WAIT input passes through a single-stage synchronizer before being evaluated. */
+#define BUSWCON0_WAIT_SINGLE_STAGE_SYNC 0x02000000
+/** Synchronous Burst Devices: Abort and retry access if WAIT asserted */
+#define BUSWCON0_WAIT_ABORT_AND_RETRY 0x03000000
+/** Reserved */
+#define BUSWCON0_LOCKCS 0x00800000
+/** Reversed polarity at wait */
+#define BUSWCON0_WAITINV 0x00400000
+/* Low active.
+#define BUSWCON0_WAITINV_ACTLOW 0x00000000 */
+/** High active */
+#define BUSWCON0_WAITINV_ACTHI 0x00400000
+/** Early ADV Enable for Synchronous Bursts */
+#define BUSWCON0_EBSE 0x00200000
+/* Low active.
+#define BUSWCON0_EBSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSWCON0_EBSE_NOT_DELAYED 0x00200000
+/** Early Control Signals for Synchronous Bursts */
+#define BUSWCON0_ECSE 0x00100000
+/* Low active.
+#define BUSWCON0_ECSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSWCON0_ECSE_NOT_DELAYED 0x00100000
+/** Synchronous Burst Buffer Mode Select */
+#define BUSWCON0_FBBMSEL 0x00080000
+/* FIXED_LENGTH
+#define BUSWCON0_FBBMSEL_FIXED_LENGTH 0x00000000 */
+/** CONTINUOUS */
+#define BUSWCON0_FBBMSEL_CONTINUOUS 0x00080000
+/** Burst Length for Synchronous Burst */
+#define BUSWCON0_FETBLEN_MASK 0x00070000
+/** field offset */
+#define BUSWCON0_FETBLEN_OFFSET 16
+/** Up to 1 data cycle (default after reset). */
+#define BUSWCON0_FETBLEN_SINGLE 0x00000000
+/** Up to 2 data cycles. */
+#define BUSWCON0_FETBLEN_BURST2 0x00010000
+/** Up to 4 data cycles. */
+#define BUSWCON0_FETBLEN_BURST4 0x00020000
+/** Up to 8 data cycles. */
+#define BUSWCON0_FETBLEN_BURST8 0x00030000
+/** Up to 16 data cycles. */
+#define BUSWCON0_FETBLEN_BURST16 0x00040000
+/** Reserved
+    This field allows to configure how the EBU generates the CLE and ALE signals for a NAND Flash device. The following options are available */
+#define BUSWCON0_NANDAMAP_MASK 0x0000C000
+/** field offset */
+#define BUSWCON0_NANDAMAP_OFFSET 14
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSWCON0_NANDAMAP_NAND_A17_16 0x00000000
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSWCON0_NANDAMAP_NAND_WAIT_ADV 0x00004000
+/** CLE is taken from AMemport[18] and ALE from AMemport[17] and are output on pins AD[9:8] and A[9:8] on the External Bus. This mode may only be used with a 8-Bit NAND-Flash device. */
+#define BUSWCON0_NANDAMAP_NAND_AD9_8 0x00008000
+/** Reserved for future use. Do not use or unpredictable results may occur. */
+#define BUSWCON0_NANDAMAP_NAND_RFU 0x0000C000
+/** AAD-mux Protocol
+    If this bit is set and the device is configured for a multiplexed access protocol in agen then the device is accessed in read mode using the AAD-mux protocol. If a non-multiplexed device type is selected in agen, field aadmux is ignored. */
+#define BUSWCON0_AADMUX 0x00002000
+/* Muxed device is write accessed in AD-mux mode.
+#define BUSWCON0_AADMUX_AD_MUX 0x00000000 */
+/** Muxed device is write accessed in AAD-mux mode. */
+#define BUSWCON0_AADMUX_AAD_MUX 0x00002000
+/** Asynchronous Address Phase */
+#define BUSWCON0_AAP 0x00001000
+/* Clock is enabled at beginning of access.
+#define BUSWCON0_AAP_EARLY 0x00000000 */
+/** Clock is enabled after address phase. */
+#define BUSWCON0_AAP_LATE 0x00001000
+/** Auxiliary Chip Select Enable
+    Not supported in GPON-EBU, field must be set to 0. */
+#define BUSWCON0_CSA 0x00000200
+/* Disable
+#define BUSWCON0_CSA_DIS 0x00000000 */
+/** Enable */
+#define BUSWCON0_CSA_EN 0x00000200
+/** Flash Non-Array Access Enable
+    Set to logic one to enable workaround when region is accessed with internal address bit 28 set. See Section 3.17.13 on page 90 for details. */
+#define BUSWCON0_NAA 0x00000100
+/* Disable
+#define BUSWCON0_NAA_DIS 0x00000000 */
+/** Enable */
+#define BUSWCON0_NAA_EN 0x00000100
+/** Module Enable */
+#define BUSWCON0_ENABLE 0x00000001
+/* Disable
+#define BUSWCON0_ENABLE_DIS 0x00000000 */
+/** Enable */
+#define BUSWCON0_ENABLE_EN 0x00000001
+
+/* Fields of "Bus Write Parameters Register0" */
+/** Address Cycles
+    Number of cycles for address phase. */
+#define BUSWP0_ADDRC_MASK 0xF0000000
+/** field offset */
+#define BUSWP0_ADDRC_OFFSET 28
+/** Address Hold Cycles For Multiplexed Address
+    Number of address hold cycles during multiplexed accesses. */
+#define BUSWP0_ADHOLC_MASK 0x0F000000
+/** field offset */
+#define BUSWP0_ADHOLC_OFFSET 24
+/** Programmed Command Delay Cycles
+    Number of delay cycles during command delay phase. */
+#define BUSWP0_CMDDELAY_MASK 0x00F00000
+/** field offset */
+#define BUSWP0_CMDDELAY_OFFSET 20
+/** Extended Data */
+#define BUSWP0_EXTDATA_MASK 0x000C0000
+/** field offset */
+#define BUSWP0_EXTDATA_OFFSET 18
+/** External device outputs data every BFCLK cycle */
+#define BUSWP0_EXTDATA_ONE 0x00000000
+/** External device outputs data every 2nd BFCLK cycles */
+#define BUSWP0_EXTDATA_TWO 0x00040000
+/** External device outputs data every 4th BFCLK cycles */
+#define BUSWP0_EXTDATA_FOUR 0x00080000
+/** External device outputs data every 8th BFCLK cycles */
+#define BUSWP0_EXTDATA_EIGHT 0x000C0000
+/** Frequency of external clock at pin BFCLKO */
+#define BUSWP0_EXTCLOCK_MASK 0x00030000
+/** field offset */
+#define BUSWP0_EXTCLOCK_OFFSET 16
+/** Equal to ebu_clk frequency. */
+#define BUSWP0_EXTCLOCK_ONE_TO_ONE 0x00000000
+/** 1/2 of ebu_clk frequency. */
+#define BUSWP0_EXTCLOCK_ONE_TO_TWO 0x00010000
+/** 1/3 of ebu_clk frequency. */
+#define BUSWP0_EXTCLOCK_ONE_TO_THREE 0x00020000
+/** 1/4 of ebu_clk frequency (default after reset). */
+#define BUSWP0_EXTCLOCK_ONE_TO_FOUR 0x00030000
+/** Data Hold Cycles For write Accesses
+    Number of data hold cycles during write accesses. */
+#define BUSWP0_DATAC_MASK 0x0000F000
+/** field offset */
+#define BUSWP0_DATAC_OFFSET 12
+/** Programmed Wait States For write Accesses
+    Number of programmed wait states for write accesses. For synchronous accesses, this will always be adjusted so that the phase exits on a rising edge of the external clock. */
+#define BUSWP0_WAITWDC_MASK 0x00000F80
+/** field offset */
+#define BUSWP0_WAITWDC_OFFSET 7
+/** Recovery Cycles After write Accesses, same CS
+    Number of idle cycles after write accesses when following access is to the same chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSWCON. */
+#define BUSWP0_RECOVC_MASK 0x00000070
+/** field offset */
+#define BUSWP0_RECOVC_OFFSET 4
+/** Recovery Cycles After write Accesses, other CS
+    Number of idle cycles after write accesses when the following access is to a different chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSWCON. */
+#define BUSWP0_DTACS_MASK 0x0000000F
+/** field offset */
+#define BUSWP0_DTACS_OFFSET 0
+
+/* Fields of "Bus Read Configuration Register1" */
+/** Device Type For Region
+    After reset, the CS region is configured for a slow Asynchronous access protocol which is compatible with read access from an external multiplexed or demultiplexed 16-Bit Burst Flash in asynchronous mode. Reset: 0000B */
+#define BUSRCON1_AGEN_MASK 0xF0000000
+/** field offset */
+#define BUSRCON1_AGEN_OFFSET 28
+/** Muxed Asynchronous Type External Memory */
+#define BUSRCON1_AGEN_MUXED_ASYNC_TYPE_EXT_MEM 0x00000000
+/** Muxed Burst Type External Memory */
+#define BUSRCON1_AGEN_MUXED_BURST_TYPE_EXT_MEM 0x10000000
+/** NAND Flash (page optimised) */
+#define BUSRCON1_AGEN_NAND_FLASH 0x20000000
+/** Muxed Cellular RAM External Memory */
+#define BUSRCON1_AGEN_MUXED_CELLULAR_RAM_EXT_MEM 0x30000000
+/** Demuxed Asynchronous Type External Memory */
+#define BUSRCON1_AGEN_DEMUXED_ASYNC_TYPE_EXT_MEM 0x40000000
+/** Demuxed Burst Type External Memory */
+#define BUSRCON1_AGEN_DEMUXED_BURST_TYPE_EXT_MEM 0x50000000
+/** Demuxed Page Mode External Memory */
+#define BUSRCON1_AGEN_DEMUXED_PAGE_MODE_EXT_MEM 0x60000000
+/** Demuxed Cellular RAM External Memory */
+#define BUSRCON1_AGEN_DEMUXED_CELLULAR_RAM_EXT_MEM 0x70000000
+/** Serial Flash */
+#define BUSRCON1_AGEN_SERIAL_FLASH 0xF0000000
+/** Device Addressing Mode
+    t.b.d. */
+#define BUSRCON1_PORTW_MASK 0x0C000000
+/** field offset */
+#define BUSRCON1_PORTW_OFFSET 26
+/** 8-bit multiplexed */
+#define BUSRCON1_PORTW_8_BIT_MUX 0x00000000
+/** 16-bit multiplexed */
+#define BUSRCON1_PORTW_16_BIT_MUX 0x04000000
+/** Twin, 16-bit multiplexed */
+#define BUSRCON1_PORTW_TWIN_16_BIT_MUX 0x08000000
+/** 32-bit multiplexed */
+#define BUSRCON1_PORTW_32_BIT_MUX 0x0C000000
+/** External Wait Control
+    Function of the WAIT input. This is specific to the device type (i.e. the agen field). */
+#define BUSRCON1_WAIT_MASK 0x03000000
+/** field offset */
+#define BUSRCON1_WAIT_OFFSET 24
+/** WAIT is ignored (default after reset). */
+#define BUSRCON1_WAIT_OFF 0x00000000
+/** Synchronous Burst Devices: WAIT signal is provided one cycle ahead of the data cycle it applies to. */
+#define BUSRCON1_WAIT_EARLY_WAIT 0x01000000
+/** Asynchronous Devices: WAIT input passes through a two-stage synchronizer before being evaluated. */
+#define BUSRCON1_WAIT_TWO_STAGE_SYNC 0x01000000
+/** Synchronous Burst Devices: WAIT signal is provided in the same data cycle it applies to. */
+#define BUSRCON1_WAIT_WAIT_WITH_DATA 0x02000000
+/** Asynchronous Devices: WAIT input passes through a single-stage synchronizer before being evaluated. */
+#define BUSRCON1_WAIT_SINGLE_STAGE_SYNC 0x02000000
+/** Synchronous Burst Devices: Abort and retry access if WAIT asserted */
+#define BUSRCON1_WAIT_ABORT_AND_RETRY 0x03000000
+/** Disable Burst Address Wrapping */
+#define BUSRCON1_DBA 0x00800000
+/** Reversed polarity at wait */
+#define BUSRCON1_WAITINV 0x00400000
+/* Low active.
+#define BUSRCON1_WAITINV_ACTLOW 0x00000000 */
+/** High active */
+#define BUSRCON1_WAITINV_ACTHI 0x00400000
+/** Early ADV Enable for Synchronous Bursts */
+#define BUSRCON1_EBSE 0x00200000
+/* Low active.
+#define BUSRCON1_EBSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSRCON1_EBSE_NOT_DELAYED 0x00200000
+/** Early Control Signals for Synchronous Bursts */
+#define BUSRCON1_ECSE 0x00100000
+/* Low active.
+#define BUSRCON1_ECSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSRCON1_ECSE_NOT_DELAYED 0x00100000
+/** Synchronous Burst Buffer Mode Select */
+#define BUSRCON1_FBBMSEL 0x00080000
+/* FIXED_LENGTH
+#define BUSRCON1_FBBMSEL_FIXED_LENGTH 0x00000000 */
+/** CONTINUOUS */
+#define BUSRCON1_FBBMSEL_CONTINUOUS 0x00080000
+/** Burst Length for Synchronous Burst */
+#define BUSRCON1_FETBLEN_MASK 0x00070000
+/** field offset */
+#define BUSRCON1_FETBLEN_OFFSET 16
+/** Up to 1 data cycle (default after reset). */
+#define BUSRCON1_FETBLEN_SINGLE 0x00000000
+/** Up to 2 data cycles. */
+#define BUSRCON1_FETBLEN_BURST2 0x00010000
+/** Up to 4 data cycles. */
+#define BUSRCON1_FETBLEN_BURST4 0x00020000
+/** Up to 8 data cycles. */
+#define BUSRCON1_FETBLEN_BURST8 0x00030000
+/** Up to 16 data cycles. */
+#define BUSRCON1_FETBLEN_BURST16 0x00040000
+/** Reserved
+    This field allows to configure how the EBU generates the CLE and ALE signals for a NAND Flash device. The following options are available */
+#define BUSRCON1_NANDAMAP_MASK 0x0000C000
+/** field offset */
+#define BUSRCON1_NANDAMAP_OFFSET 14
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSRCON1_NANDAMAP_NAND_A17_16 0x00000000
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSRCON1_NANDAMAP_NAND_WAIT_ADV 0x00004000
+/** CLE is taken from AMemport[18] and ALE from AMemport[17] and are output on pins AD[9:8] and A[9:8] on the External Bus. This mode may only be used with a 8-Bit NAND-Flash device. */
+#define BUSRCON1_NANDAMAP_NAND_AD9_8 0x00008000
+/** Reserved for future use. Do not use or unpredictable results may occur. */
+#define BUSRCON1_NANDAMAP_NAND_RFU 0x0000C000
+/** AAD-mux Protocol
+    If this bit is set and the device is configured for a multiplexed access protocol in agen then the device is accessed in read mode using the AAD-mux protocol. If a non-multiplexed device type is selected in agen, field aadmux is ignored. */
+#define BUSRCON1_AADMUX 0x00002000
+/* Muxed device is write accessed in AD-mux mode.
+#define BUSRCON1_AADMUX_AD_MUX 0x00000000 */
+/** Muxed device is write accessed in AAD-mux mode. */
+#define BUSRCON1_AADMUX_AAD_MUX 0x00002000
+/** Asynchronous Address Phase */
+#define BUSRCON1_AAP 0x00001000
+/* Clock is enabled at beginning of access.
+#define BUSRCON1_AAP_EARLY 0x00000000 */
+/** Clock is enabled after address phase. */
+#define BUSRCON1_AAP_LATE 0x00001000
+/** Burst Flash Read Single Stage Synchronisation */
+#define BUSRCON1_BFSSS 0x00000800
+/* Two stages of synchronisation used.
+#define BUSRCON1_BFSSS_TWO_STAGE 0x00000000 */
+/** Single stage of synchronisation used. */
+#define BUSRCON1_BFSSS_SINGLE_STAGE 0x00000800
+/** Burst Flash Clock Feedback Enable */
+#define BUSRCON1_FDBKEN 0x00000400
+/* Disable
+#define BUSRCON1_FDBKEN_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON1_FDBKEN_EN 0x00000400
+/** Auxiliary Chip Select Enable
+    Not supported in GPON-EBU, field must be set to 0. */
+#define BUSRCON1_CSA 0x00000200
+/* Disable
+#define BUSRCON1_CSA_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON1_CSA_EN 0x00000200
+/** Flash Non-Array Access Enable
+    Set to logic one to enable workaround when region is accessed with internal address bit 28 set. See Section 3.17.13 on page 90 for details. */
+#define BUSRCON1_NAA 0x00000100
+/* Disable
+#define BUSRCON1_NAA_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON1_NAA_EN 0x00000100
+/** Module Enable */
+#define BUSRCON1_ENABLE 0x00000001
+/* Disable
+#define BUSRCON1_ENABLE_DIS 0x00000000 */
+/** Enable */
+#define BUSRCON1_ENABLE_EN 0x00000001
+
+/* Fields of "Bus Read Parameters Register1" */
+/** Address Cycles
+    Number of cycles for address phase. */
+#define BUSRP1_ADDRC_MASK 0xF0000000
+/** field offset */
+#define BUSRP1_ADDRC_OFFSET 28
+/** Address Hold Cycles For Multiplexed Address
+    Number of address hold cycles during multiplexed accesses. */
+#define BUSRP1_ADHOLC_MASK 0x0F000000
+/** field offset */
+#define BUSRP1_ADHOLC_OFFSET 24
+/** Programmed Command Delay Cycles
+    Number of delay cycles during command delay phase. */
+#define BUSRP1_CMDDELAY_MASK 0x00F00000
+/** field offset */
+#define BUSRP1_CMDDELAY_OFFSET 20
+/** Extended Data */
+#define BUSRP1_EXTDATA_MASK 0x000C0000
+/** field offset */
+#define BUSRP1_EXTDATA_OFFSET 18
+/** External device outputs data every BFCLK cycle */
+#define BUSRP1_EXTDATA_ONE 0x00000000
+/** External device outputs data every 2nd BFCLK cycles */
+#define BUSRP1_EXTDATA_TWO 0x00040000
+/** External device outputs data every 4th BFCLK cycles */
+#define BUSRP1_EXTDATA_FOUR 0x00080000
+/** External device outputs data every 8th BFCLK cycles */
+#define BUSRP1_EXTDATA_EIGHT 0x000C0000
+/** Frequency of external clock at pin BFCLKO */
+#define BUSRP1_EXTCLOCK_MASK 0x00030000
+/** field offset */
+#define BUSRP1_EXTCLOCK_OFFSET 16
+/** Equal to ebu_clk frequency. */
+#define BUSRP1_EXTCLOCK_ONE_TO_ONE 0x00000000
+/** 1/2 of ebu_clk frequency. */
+#define BUSRP1_EXTCLOCK_ONE_TO_TWO 0x00010000
+/** 1/3 of ebu_clk frequency. */
+#define BUSRP1_EXTCLOCK_ONE_TO_THREE 0x00020000
+/** 1/4 of ebu_clk frequency (default after reset). */
+#define BUSRP1_EXTCLOCK_ONE_TO_FOUR 0x00030000
+/** Data Hold Cycles For read Accesses
+    Number of data hold cycles during read accesses. Applies to spinner support only where the address is guaranteed stable for datac clocks after RD high */
+#define BUSRP1_DATAC_MASK 0x0000F000
+/** field offset */
+#define BUSRP1_DATAC_OFFSET 12
+/** Programmed Wait States for read accesses
+    Number of programmed wait states for read accesses. For synchronous accesses, this will always be adjusted so that the phase exits on a rising edge of the external clock. */
+#define BUSRP1_WAITRDC_MASK 0x00000F80
+/** field offset */
+#define BUSRP1_WAITRDC_OFFSET 7
+/** Recovery Cycles After read Accesses, same CS
+    Number of idle cycles after read accesses when the next access is to the same chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSRCON. */
+#define BUSRP1_RECOVC_MASK 0x00000070
+/** field offset */
+#define BUSRP1_RECOVC_OFFSET 4
+/** Recovery Cycles After read Accesses, other CS
+    Number of idle cycles after read accesses when the next access is to a different chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSRCON. */
+#define BUSRP1_DTACS_MASK 0x0000000F
+/** field offset */
+#define BUSRP1_DTACS_OFFSET 0
+
+/* Fields of "Bus Write Configuration Register1" */
+/** Device Type For Region
+    After reset, the CS region is configured for a slow Asynchronous access protocol which is compatible with read access from an external multiplexed or demultiplexed 16-Bit Burst Flash in asynchronous mode. Reset: 0000B */
+#define BUSWCON1_AGEN_MASK 0xF0000000
+/** field offset */
+#define BUSWCON1_AGEN_OFFSET 28
+/** Muxed Asynchronous Type External Memory */
+#define BUSWCON1_AGEN_MUXED_ASYNC_TYPE_EXT_MEM 0x00000000
+/** Muxed Burst Type External Memory */
+#define BUSWCON1_AGEN_MUXED_BURST_TYPE_EXT_MEM 0x10000000
+/** NAND Flash (page optimised) */
+#define BUSWCON1_AGEN_NAND_FLASH 0x20000000
+/** Muxed Cellular RAM External Memory */
+#define BUSWCON1_AGEN_MUXED_CELLULAR_RAM_EXT_MEM 0x30000000
+/** Demuxed Asynchronous Type External Memory */
+#define BUSWCON1_AGEN_DEMUXED_ASYNC_TYPE_EXT_MEM 0x40000000
+/** Demuxed Burst Type External Memory */
+#define BUSWCON1_AGEN_DEMUXED_BURST_TYPE_EXT_MEM 0x50000000
+/** Demuxed Page Mode External Memory */
+#define BUSWCON1_AGEN_DEMUXED_PAGE_MODE_EXT_MEM 0x60000000
+/** Demuxed Cellular RAM External Memory */
+#define BUSWCON1_AGEN_DEMUXED_CELLULAR_RAM_EXT_MEM 0x70000000
+/** Serial Flash */
+#define BUSWCON1_AGEN_SERIAL_FLASH 0xF0000000
+/** Device Addressing Mode
+    t.b.d. */
+#define BUSWCON1_PORTW_MASK 0x0C000000
+/** field offset */
+#define BUSWCON1_PORTW_OFFSET 26
+/** External Wait Control
+    Function of the WAIT input. This is specific to the device type (i.e. the agen field). */
+#define BUSWCON1_WAIT_MASK 0x03000000
+/** field offset */
+#define BUSWCON1_WAIT_OFFSET 24
+/** WAIT is ignored (default after reset). */
+#define BUSWCON1_WAIT_OFF 0x00000000
+/** Synchronous Burst Devices: WAIT signal is provided one cycle ahead of the data cycle it applies to. */
+#define BUSWCON1_WAIT_EARLY_WAIT 0x01000000
+/** Asynchronous Devices: WAIT input passes through a two-stage synchronizer before being evaluated. */
+#define BUSWCON1_WAIT_TWO_STAGE_SYNC 0x01000000
+/** Synchronous Burst Devices: WAIT signal is provided in the same data cycle it applies to. */
+#define BUSWCON1_WAIT_WAIT_WITH_DATA 0x02000000
+/** Asynchronous Devices: WAIT input passes through a single-stage synchronizer before being evaluated. */
+#define BUSWCON1_WAIT_SINGLE_STAGE_SYNC 0x02000000
+/** Synchronous Burst Devices: Abort and retry access if WAIT asserted */
+#define BUSWCON1_WAIT_ABORT_AND_RETRY 0x03000000
+/** Reserved */
+#define BUSWCON1_LOCKCS 0x00800000
+/** Reversed polarity at wait */
+#define BUSWCON1_WAITINV 0x00400000
+/* Low active.
+#define BUSWCON1_WAITINV_ACTLOW 0x00000000 */
+/** High active */
+#define BUSWCON1_WAITINV_ACTHI 0x00400000
+/** Early ADV Enable for Synchronous Bursts */
+#define BUSWCON1_EBSE 0x00200000
+/* Low active.
+#define BUSWCON1_EBSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSWCON1_EBSE_NOT_DELAYED 0x00200000
+/** Early Control Signals for Synchronous Bursts */
+#define BUSWCON1_ECSE 0x00100000
+/* Low active.
+#define BUSWCON1_ECSE_DELAYED 0x00000000 */
+/** High active */
+#define BUSWCON1_ECSE_NOT_DELAYED 0x00100000
+/** Synchronous Burst Buffer Mode Select */
+#define BUSWCON1_FBBMSEL 0x00080000
+/* FIXED_LENGTH
+#define BUSWCON1_FBBMSEL_FIXED_LENGTH 0x00000000 */
+/** CONTINUOUS */
+#define BUSWCON1_FBBMSEL_CONTINUOUS 0x00080000
+/** Burst Length for Synchronous Burst */
+#define BUSWCON1_FETBLEN_MASK 0x00070000
+/** field offset */
+#define BUSWCON1_FETBLEN_OFFSET 16
+/** Up to 1 data cycle (default after reset). */
+#define BUSWCON1_FETBLEN_SINGLE 0x00000000
+/** Up to 2 data cycles. */
+#define BUSWCON1_FETBLEN_BURST2 0x00010000
+/** Up to 4 data cycles. */
+#define BUSWCON1_FETBLEN_BURST4 0x00020000
+/** Up to 8 data cycles. */
+#define BUSWCON1_FETBLEN_BURST8 0x00030000
+/** Up to 16 data cycles. */
+#define BUSWCON1_FETBLEN_BURST16 0x00040000
+/** Reserved
+    This field allows to configure how the EBU generates the CLE and ALE signals for a NAND Flash device. The following options are available */
+#define BUSWCON1_NANDAMAP_MASK 0x0000C000
+/** field offset */
+#define BUSWCON1_NANDAMAP_OFFSET 14
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSWCON1_NANDAMAP_NAND_A17_16 0x00000000
+/** is taken from AMemport[18] and ALE from AMemport[17] and are output on pins A[17:16] on the External Bus (default after reset). */
+#define BUSWCON1_NANDAMAP_NAND_WAIT_ADV 0x00004000
+/** CLE is taken from AMemport[18] and ALE from AMemport[17] and are output on pins AD[9:8] and A[9:8] on the External Bus. This mode may only be used with a 8-Bit NAND-Flash device. */
+#define BUSWCON1_NANDAMAP_NAND_AD9_8 0x00008000
+/** Reserved for future use. Do not use or unpredictable results may occur. */
+#define BUSWCON1_NANDAMAP_NAND_RFU 0x0000C000
+/** AAD-mux Protocol
+    If this bit is set and the device is configured for a multiplexed access protocol in agen then the device is accessed in read mode using the AAD-mux protocol. If a non-multiplexed device type is selected in agen, field aadmux is ignored. */
+#define BUSWCON1_AADMUX 0x00002000
+/* Muxed device is write accessed in AD-mux mode.
+#define BUSWCON1_AADMUX_AD_MUX 0x00000000 */
+/** Muxed device is write accessed in AAD-mux mode. */
+#define BUSWCON1_AADMUX_AAD_MUX 0x00002000
+/** Asynchronous Address Phase */
+#define BUSWCON1_AAP 0x00001000
+/* Clock is enabled at beginning of access.
+#define BUSWCON1_AAP_EARLY 0x00000000 */
+/** Clock is enabled after address phase. */
+#define BUSWCON1_AAP_LATE 0x00001000
+/** Auxiliary Chip Select Enable
+    Not supported in GPON-EBU, field must be set to 0. */
+#define BUSWCON1_CSA 0x00000200
+/* Disable
+#define BUSWCON1_CSA_DIS 0x00000000 */
+/** Enable */
+#define BUSWCON1_CSA_EN 0x00000200
+/** Flash Non-Array Access Enable
+    Set to logic one to enable workaround when region is accessed with internal address bit 28 set. See Section 3.17.13 on page 90 for details. */
+#define BUSWCON1_NAA 0x00000100
+/* Disable
+#define BUSWCON1_NAA_DIS 0x00000000 */
+/** Enable */
+#define BUSWCON1_NAA_EN 0x00000100
+/** Module Enable */
+#define BUSWCON1_ENABLE 0x00000001
+/* Disable
+#define BUSWCON1_ENABLE_DIS 0x00000000 */
+/** Enable */
+#define BUSWCON1_ENABLE_EN 0x00000001
+
+/* Fields of "Bus Write Parameters Register1" */
+/** Address Cycles
+    Number of cycles for address phase. */
+#define BUSWP1_ADDRC_MASK 0xF0000000
+/** field offset */
+#define BUSWP1_ADDRC_OFFSET 28
+/** Address Hold Cycles For Multiplexed Address
+    Number of address hold cycles during multiplexed accesses. */
+#define BUSWP1_ADHOLC_MASK 0x0F000000
+/** field offset */
+#define BUSWP1_ADHOLC_OFFSET 24
+/** Programmed Command Delay Cycles
+    Number of delay cycles during command delay phase. */
+#define BUSWP1_CMDDELAY_MASK 0x00F00000
+/** field offset */
+#define BUSWP1_CMDDELAY_OFFSET 20
+/** Extended Data */
+#define BUSWP1_EXTDATA_MASK 0x000C0000
+/** field offset */
+#define BUSWP1_EXTDATA_OFFSET 18
+/** External device outputs data every BFCLK cycle */
+#define BUSWP1_EXTDATA_ONE 0x00000000
+/** External device outputs data every 2nd BFCLK cycles */
+#define BUSWP1_EXTDATA_TWO 0x00040000
+/** External device outputs data every 4th BFCLK cycles */
+#define BUSWP1_EXTDATA_FOUR 0x00080000
+/** External device outputs data every 8th BFCLK cycles */
+#define BUSWP1_EXTDATA_EIGHT 0x000C0000
+/** Frequency of external clock at pin BFCLKO */
+#define BUSWP1_EXTCLOCK_MASK 0x00030000
+/** field offset */
+#define BUSWP1_EXTCLOCK_OFFSET 16
+/** Equal to ebu_clk frequency. */
+#define BUSWP1_EXTCLOCK_ONE_TO_ONE 0x00000000
+/** 1/2 of ebu_clk frequency. */
+#define BUSWP1_EXTCLOCK_ONE_TO_TWO 0x00010000
+/** 1/3 of ebu_clk frequency. */
+#define BUSWP1_EXTCLOCK_ONE_TO_THREE 0x00020000
+/** 1/4 of ebu_clk frequency (default after reset). */
+#define BUSWP1_EXTCLOCK_ONE_TO_FOUR 0x00030000
+/** Data Hold Cycles For write Accesses
+    Number of data hold cycles during write accesses. */
+#define BUSWP1_DATAC_MASK 0x0000F000
+/** field offset */
+#define BUSWP1_DATAC_OFFSET 12
+/** Programmed Wait States For write Accesses
+    Number of programmed wait states for write accesses. For synchronous accesses, this will always be adjusted so that the phase exits on a rising edge of the external clock. */
+#define BUSWP1_WAITWDC_MASK 0x00000F80
+/** field offset */
+#define BUSWP1_WAITWDC_OFFSET 7
+/** Recovery Cycles After write Accesses, same CS
+    Number of idle cycles after write accesses when following access is to the same chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSWCON. */
+#define BUSWP1_RECOVC_MASK 0x00000070
+/** field offset */
+#define BUSWP1_RECOVC_OFFSET 4
+/** Recovery Cycles After write Accesses, other CS
+    Number of idle cycles after write accesses when the following access is to a different chip select. For synchronous accesses, this will always be adjusted so that the phase exits on a rising clock edge. Note that at least one recovery cycle must be programmed in case the region is configured for delayed control signals in field ecse of register EBU_BUSWCON. */
+#define BUSWP1_DTACS_MASK 0x0000000F
+/** field offset */
+#define BUSWP1_DTACS_OFFSET 0
+
+/* Fields of "Bus Protocol Configuration Extension Register 0" */
+/** Byte Control Mapping
+    Remapping of byte enable signals on address lines is not supported in the GPON-EBU. */
+#define BUSCONEXT0_BCMAP_MASK 0x00030000
+/** field offset */
+#define BUSCONEXT0_BCMAP_OFFSET 16
+/** No mirroring of byte enables. */
+#define BUSCONEXT0_BCMAP_NOBCMAP 0x00000000
+/** Asynchronous Early Write
+    This bit is obsolete and must be set to 0 or unpredictable results may result. */
+#define BUSCONEXT0_AEW 0x00008000
+/** AAD-mux Consecutive Address Cycles
+    This bit selects whether ADV gets deasserted between the high and the low address phase of a synchronous AAD-mux access or the two address cycles are consecutive. See Figure 32 for a waveform example that results when acac is set. acac only takes effect if the CS region is configured for synchronous AADmux access (agen = 1 or 3, aadmux = 1) and is ignored otherwise. */
+#define BUSCONEXT0_ACAC 0x00004000
+/* ADV is deasserted between high and low address phase.
+#define BUSCONEXT0_ACAC_SEPERATED 0x00000000 */
+/** ADV is not deasserted between high and low address phase. */
+#define BUSCONEXT0_ACAC_CONSECUTIVE 0x00004000
+/** AAD-mux Write Address-to-Address Delay
+    Gives the length of the AA-Phase (in multiples of the ebu_clk cycle) to be used when writing to the CS region. The parameter is only observed if the CS region is configured for use of the AAD-mux protocol in register EBU_BUSWCON, fields agen and aadmux. */
+#define BUSCONEXT0_WAAC_MASK 0x00003800
+/** field offset */
+#define BUSCONEXT0_WAAC_OFFSET 11
+/** AAD-mux Read Address-to-Address Delay
+    Gives the length of the AA-Phase (in multiples of the ebu_clk cycle) to be used when reading from the CS region. The parameter is only observed if the CS region is configured for use of the AAD-mux protocol in register EBU_BUSRCON, fields agen and aadmux. */
+#define BUSCONEXT0_RAAC_MASK 0x00000700
+/** field offset */
+#define BUSCONEXT0_RAAC_OFFSET 8
+/** AAD-mux Paging Enable for CS0
+    If the external device is configured for AAD-mux protocol in register EBU_BUSRCON, then this field selects whether or not to use paging. If paging is enabled, the EBU skips the high address cycle in case the upper address that would be sent are the same as in the most recent access to the device.configures how to set the AD[15:14] in the high address cycle of an access with the following encoding: */
+#define BUSCONEXT0_PAGE_EN 0x00000080
+/* Disable
+#define BUSCONEXT0_PAGE_EN_DIS 0x00000000 */
+/** Enable */
+#define BUSCONEXT0_PAGE_EN_EN 0x00000080
+/** AAD-mux Address Extension Bit Generation Mode
+    If the external device is configured for AAD-mux protocol in register EBU_BUSRCON, then this field configures how to set the AD[15:14] in the high address cycle of an access with the following encoding: */
+#define BUSCONEXT0_AEBM_MASK 0x00000070
+/** field offset */
+#define BUSCONEXT0_AEBM_OFFSET 4
+/** A[15] in the high address cycle is set to AMemport[amsb+17], A[14] is set to 0 */
+#define BUSCONEXT0_AEBM_AMAP_CRE_RFU0 0x00000000
+/** A[15] in the high address cycle is set to AMemport[amsb+17], A[14] is set to 1 */
+#define BUSCONEXT0_AEBM_AMAP_CRE_RFU1 0x00000010
+/** A[15] in the high address cycle is set to AMemport[amsb+18], A[14] is set to AMemport[amsb+17] */
+#define BUSCONEXT0_AEBM_AMAP_CRE_AND_RFU 0x00000020
+/** Do not use */
+#define BUSCONEXT0_AEBM_reserved 0x00000030
+/** A[15:14] in the high address cycle is set to 00B. */
+#define BUSCONEXT0_AEBM_DIRECT_00 0x00000040
+/** A[15:14] in the high address cycle is set to 01B */
+#define BUSCONEXT0_AEBM_DIRECT_01 0x00000050
+/** A[15:14] in the high address cycle is set to 10B */
+#define BUSCONEXT0_AEBM_DIRECT_10 0x00000060
+/** A[15:14] in the high address cycle is set to 11B. */
+#define BUSCONEXT0_AEBM_DIRECT_11 0x00000070
+/** Most Significant Address Bit of External Device
+    If the external device is configured for AAD-mux protocol in register EBU_BUSRCON, then for amsb < 14 the EBU always sets A[13:amsb] = 0 in the high address cycle of an access. The value of A[15:14] is defined in field aebm. A value of amsb > 13 therefore has no effect. It is recommended to set amsb that it matches the addressable range of the external device according to the following formula: amsb = n - 16 for a device with 2n addressable words. */
+#define BUSCONEXT0_AMSB_MASK 0x0000000F
+/** field offset */
+#define BUSCONEXT0_AMSB_OFFSET 0
+
+/* Fields of "Bus Protocol Configuration Extension Register 1" */
+/** Byte Control Mapping
+    Remapping of byte enable signals on address lines is not supported in the GPON-EBU. */
+#define BUSCONEXT1_BCMAP_MASK 0x00030000
+/** field offset */
+#define BUSCONEXT1_BCMAP_OFFSET 16
+/** No mirroring of byte enables. */
+#define BUSCONEXT1_BCMAP_NOBCMAP 0x00000000
+/** Asynchronous Early Write
+    This bit is obsolete and must be set to 0 or unpredictable results may result. */
+#define BUSCONEXT1_AEW 0x00008000
+/** AAD-mux Consecutive Address Cycles
+    This bit selects whether ADV gets deasserted between the high and the low address phase of a synchronous AAD-mux access or the two address cycles are consecutive. See Figure 32 for a waveform example that results when acac is set. acac only takes effect if the CS region is configured for synchronous AADmux access (agen = 1 or 3, aadmux = 1) and is ignored otherwise. */
+#define BUSCONEXT1_ACAC 0x00004000
+/* ADV is deasserted between high and low address phase.
+#define BUSCONEXT1_ACAC_SEPERATED 0x00000000 */
+/** ADV is not deasserted between high and low address phase. */
+#define BUSCONEXT1_ACAC_CONSECUTIVE 0x00004000
+/** AAD-mux Write Address-to-Address Delay
+    Gives the length of the AA-Phase (in multiples of the ebu_clk cycle) to be used when writing to the CS region. The parameter is only observed if the CS region is configured for use of the AAD-mux protocol in register EBU_BUSWCON, fields agen and aadmux. */
+#define BUSCONEXT1_WAAC_MASK 0x00003800
+/** field offset */
+#define BUSCONEXT1_WAAC_OFFSET 11
+/** AAD-mux Read Address-to-Address Delay
+    Gives the length of the AA-Phase (in multiples of the ebu_clk cycle) to be used when reading from the CS region. The parameter is only observed if the CS region is configured for use of the AAD-mux protocol in register EBU_BUSRCON, fields agen and aadmux. */
+#define BUSCONEXT1_RAAC_MASK 0x00000700
+/** field offset */
+#define BUSCONEXT1_RAAC_OFFSET 8
+/** AAD-mux Paging Enable for CS0
+    If the external device is configured for AAD-mux protocol in register EBU_BUSRCON, then this field selects whether or not to use paging. If paging is enabled, the EBU skips the high address cycle in case the upper address that would be sent are the same as in the most recent access to the device.configures how to set the AD[15:14] in the high address cycle of an access with the following encoding: */
+#define BUSCONEXT1_PAGE_EN 0x00000080
+/* Disable
+#define BUSCONEXT1_PAGE_EN_DIS 0x00000000 */
+/** Enable */
+#define BUSCONEXT1_PAGE_EN_EN 0x00000080
+/** AAD-mux Address Extension Bit Generation Mode
+    If the external device is configured for AAD-mux protocol in register EBU_BUSRCON, then this field configures how to set the AD[15:14] in the high address cycle of an access with the following encoding: */
+#define BUSCONEXT1_AEBM_MASK 0x00000070
+/** field offset */
+#define BUSCONEXT1_AEBM_OFFSET 4
+/** A[15] in the high address cycle is set to AMemport[amsb+17], A[14] is set to 0 */
+#define BUSCONEXT1_AEBM_AMAP_CRE_RFU0 0x00000000
+/** A[15] in the high address cycle is set to AMemport[amsb+17], A[14] is set to 1 */
+#define BUSCONEXT1_AEBM_AMAP_CRE_RFU1 0x00000010
+/** A[15] in the high address cycle is set to AMemport[amsb+18], A[14] is set to AMemport[amsb+17] */
+#define BUSCONEXT1_AEBM_AMAP_CRE_AND_RFU 0x00000020
+/** Do not use */
+#define BUSCONEXT1_AEBM_reserved 0x00000030
+/** A[15:14] in the high address cycle is set to 00B. */
+#define BUSCONEXT1_AEBM_DIRECT_00 0x00000040
+/** A[15:14] in the high address cycle is set to 01B */
+#define BUSCONEXT1_AEBM_DIRECT_01 0x00000050
+/** A[15:14] in the high address cycle is set to 10B */
+#define BUSCONEXT1_AEBM_DIRECT_10 0x00000060
+/** A[15:14] in the high address cycle is set to 11B. */
+#define BUSCONEXT1_AEBM_DIRECT_11 0x00000070
+/** Most Significant Address Bit of External Device
+    If the external device is configured for AAD-mux protocol in register EBU_BUSRCON, then for amsb < 14 the EBU always sets A[13:amsb] = 0 in the high address cycle of an access. The value of A[15:14] is defined in field aebm. A value of amsb > 13 therefore has no effect. It is recommended to set amsb that it matches the addressable range of the external device according to the following formula: amsb = n - 16 for a device with 2n addressable words. */
+#define BUSCONEXT1_AMSB_MASK 0x0000000F
+/** field offset */
+#define BUSCONEXT1_AMSB_OFFSET 0
+
+/* Fields of "Serial Flash Configuration Register" */
+/** Direct Access Device Port Width
+    DA_PORTW Defines the number of signal lines to be used with direct read access from a Serial Flash as defined for the command with opcode rd_opc. Depending on thedevice type and/or command, the number of used signal lines might differbetween command, address, and data phase of the transaction. */
+#define SFCON_DA_PORTW_MASK 0xE0000000
+/** field offset */
+#define SFCON_DA_PORTW_OFFSET 29
+/** One signal line used in all phases of the transaction. */
+#define SFCON_DA_PORTW_WIDTH_1_1_1 0x00000000
+/** One signal line used in the COMMAND and ADDRESS phase of the transaction and two signal lines used in the DATA phase. */
+#define SFCON_DA_PORTW_WIDTH_1_1_2 0x20000000
+/** One signal used in the COMMAND phase of the transaction and two signal lines used in the ADDRESS/DUMMY phase and the DATA phase. */
+#define SFCON_DA_PORTW_WIDTH_1_2_2 0x40000000
+/** Two signal lines used in all phases of the transaction. */
+#define SFCON_DA_PORTW_WIDTH_2_2_2 0x60000000
+/** One signal line used in the COMMAND and ADDRESS phase of the transaction and four signal lines used in the DATA phase. */
+#define SFCON_DA_PORTW_WIDTH_1_1_4 0x80000000
+/** One signal used in the COMMAND phase of the transaction and four signal lines used in the ADDRESS/DUMMY phase and the DATA phase. */
+#define SFCON_DA_PORTW_WIDTH_1_4_4 0xA0000000
+/** Four signal lines used in all phases of the transaction. */
+#define SFCON_DA_PORTW_WIDTH_4_4_4 0xC0000000
+/** for future use. */
+#define SFCON_DA_PORTW_WIDTH_reserved 0xE0000000
+/** Read Abort Enable
+    If set, a read access from the external device can be aborted via signal sf_rd_abort_i. See Section 3.18.2.9 for details. */
+#define SFCON_RD_ABORT_EN 0x10000000
+/** Device Size
+    Defines the number of significant address bits for the Serial Flash device(s). All address bits above the MSB are forced to 0. The configuration in this field also defines for the address auto-increment feature when to wrap around from the upper most address to 0. */
+#define SFCON_DEV_SIZE_MASK 0x0F000000
+/** field offset */
+#define SFCON_DEV_SIZE_OFFSET 24
+/** 16 MBit device */
+#define SFCON_DEV_SIZE_A20_0 0x00000000
+/** 32 MBit device */
+#define SFCON_DEV_SIZE_A21_0 0x01000000
+/** 64 MBit device */
+#define SFCON_DEV_SIZE_A22_0 0x02000000
+/** 128 MBit device */
+#define SFCON_DEV_SIZE_A23_0 0x03000000
+/** 256 MBit device */
+#define SFCON_DEV_SIZE_A24_0 0x04000000
+/** 512 MBit device */
+#define SFCON_DEV_SIZE_A25_0 0x05000000
+/** 1 GBit device */
+#define SFCON_DEV_SIZE_A26_0 0x06000000
+/** 2 GBit device */
+#define SFCON_DEV_SIZE_A27_0 0x07000000
+/** 4 GBit device */
+#define SFCON_DEV_SIZE_A28_0 0x08000000
+/** 8 GBit device */
+#define SFCON_DEV_SIZE_A29_0 0x09000000
+/** 16 GBit device */
+#define SFCON_DEV_SIZE_A30_0 0x0A000000
+/** 32 GBit device */
+#define SFCON_DEV_SIZE_A31_0 0x0B000000
+/** Device Page Size
+    Defines the page size employed by all connected Serial Flash devices. The device page size is used to determine the address wrap-around for the write address auto-increment feature. */
+#define SFCON_DPS_MASK 0x00C00000
+/** field offset */
+#define SFCON_DPS_OFFSET 22
+/** Device page size is 256 Bytes */
+#define SFCON_DPS_DPS_256 0x00000000
+/** Device page size is 512 Bytes */
+#define SFCON_DPS_DPS_512 0x00400000
+/** Page Buffer Size
+    Defines the size of the EBU's page buffer used in Buffered Access. Page buffer size configured here must be less than or equal to the maximum page buffer size which is a built option of the EBU (256 Bytes for GPON). */
+#define SFCON_PB_SIZE_MASK 0x00300000
+/** field offset */
+#define SFCON_PB_SIZE_OFFSET 20
+/** No read buffer is available/used. */
+#define SFCON_PB_SIZE_NONE 0x00000000
+/** 128 Bytes */
+#define SFCON_PB_SIZE_SIZE_128 0x00100000
+/** 256 Bytes */
+#define SFCON_PB_SIZE_SIZE_256 0x00200000
+/** Bidirectional Data Bus
+    Defines whether the Serial Flash uses a unidirectional or a bidirectional data bus. */
+#define SFCON_BIDIR 0x00080000
+/* The Serial Flash interface uses a pair of two unidirectional busses (one for write, one for read)
+#define SFCON_BIDIR_UNIDIRECTIONAL 0x00000000 */
+/** The Serial Flash interface uses a bidirectional data bus. */
+#define SFCON_BIDIR_BIDIRECTIONAL 0x00080000
+/** No Busy Error termination
+    By default, the EBU error-terminates all direct access to a Serial Flash while EBU_SFSTAT.busy is set. By setting NO_BUSY_ERR, the EBU can be configured to permit direct accesses to proceed to the Serial Flash, e.g. for devices that support a read-while-write functionality. */
+#define SFCON_NO_BUSY_ERR 0x00040000
+/** End-of-Busy Detection Mode
+    Defines how the EBU detects the end of a busy phase in the Serial Flash device. The current version of the EBU requires the software to explicitly poll the device's status register and then inform the EBU on the end of the busy status by clearing the corresponding bit in register EBU_SF_STAT. */
+#define SFCON_EOBDM_MASK 0x00030000
+/** field offset */
+#define SFCON_EOBDM_OFFSET 16
+/** No read buffer is available/used. */
+#define SFCON_EOBDM_SOFTWARE 0x00000000
+/** Poll device status register (not supported yet) */
+#define SFCON_EOBDM_POLL_SR 0x00010000
+/** Poll devices busy/ready pin fed into EBU via WAIT pin (not supported yet). */
+#define SFCON_EOBDM_POLL_RDY 0x00020000
+/** Same as POLL_RDY, but CS must be asserted to have the device output its busy/ready status (not supported yet). */
+#define SFCON_EOBDM_POLL_RDY_WITH_CS 0x00030000
+/** Direct Access Keep Chip Select
+    Defines whether the Serial Flash remains selected after a direct access transaction has been finished. */
+#define SFCON_DA_KEEP_CS 0x00008000
+/* After a direct read access, the Serial Flash device is always deselected (CS deasserted). Follow-up read accesses always require sending command opcode and address.
+#define SFCON_DA_KEEP_CS_DESELECT 0x00000000 */
+/** Chip Select of device is kept active after direct read access so that device is ready for follow-up read of next sequential byte without the need to send command and address. If the next command is to another Chip Select, is a different command or accesses a different address, the EBU first deactivates the kept Chip Select before it starts the new transaction with sending the command opcode and address. */
+#define SFCON_DA_KEEP_CS_KEEP_SELECTED 0x00008000
+/** Early Read Abort Enable
+    When aborting a Serial Flash Read is enabled in bit EBU_SFCON.rd_abort_en, bit early_abort selects at what point in the protocol an external access might be aborted. Datasheets of many Serial Flash devices are not explicit on what happens (and whether it is allowed) when a read access is cut-short by deselecting the device during the CMD, ADDR or DUMMY phase of the protocol. */
+#define SFCON_EARLY_ABORT 0x00004000
+/* DISABLE Early abortion is disabled (default after reset). Once the EBU has started the access on the External Bus (first bit time slot), the EBU continues the external transfer until the first data byte has been received. After a direct read access, the Serial Flash device is always deselected (CS deasserted). Follow-up read accesses always require sending command opcode and address.
+#define SFCON_EARLY_ABORT_DISABLE 0x00000000 */
+/** Early abortion is not yet supported in the current version of the EBU. Do not use. The feature is a late improvement to the EBU and could not be verified completely before the final release. After proven to work, it should be made officially available to reduce access latency after aborted Serial Flash reads. Setting early_abort to ENABLE alters the read abort handling in the following way: Once the EBU has started the access on the External Bus, the transfer is cut-short after transferring the CMD byte, the three address bytes, any DUMMY bits or at the end of the next data byte - whatever comes first. */
+#define SFCON_EARLY_ABORT_ENABLE 0x00004000
+/** Direct Access Address Length
+    Defines the number of address bytes to be sent (MSB first) to the device with a direct read access transaction. Other values than listed below are not supported and have unpredictable results. */
+#define SFCON_DA_ALEN_MASK 0x00003000
+/** field offset */
+#define SFCON_DA_ALEN_OFFSET 12
+/** 3 address bytes (bits 23:0 of the internal address) */
+#define SFCON_DA_ALEN_THREE 0x00000000
+/** Read Access Dummy Bytes
+    This field defines the number of dummy bytes to send between the last address byte before the EBU starts capturing read data from the bus for a direct read access. The number of dummy bytes depends on the data access command being used (see field), the clock frequency and the type of device being used. */
+#define SFCON_RD_DUMLEN_MASK 0x00000F00
+/** field offset */
+#define SFCON_RD_DUMLEN_OFFSET 8
+/** Direct Read Access Command Opcode
+    This byte defines the command opcode to send when performing a data read from the Serial Flash in Direct Access Mode. Any value can be set (the EBU does not interpret the value, but directly uses the contents of this register field in the command phase of the transaction). Common opcodes to be used and understood by most devices are READ (03H) and FAST_READ (0BH), but some devices might provide additional opcodes, e.g. to support higher clock frequencies requiring additional dummy bytes or to define a wider interface bus. */
+#define SFCON_RD_OPC_MASK 0x000000FF
+/** field offset */
+#define SFCON_RD_OPC_OFFSET 0
+/** READ */
+#define SFCON_RD_OPC_READ 0x00000003
+/** FAST_READ */
+#define SFCON_RD_OPC_FAST_READ 0x0000000B
+
+/* Fields of "Serial Flash Timing Register" */
+/** CS Idle time
+    This field defines the minimum time the device's Chip Select has to be deasserted in between accesses. Most devices require a minimum deselect time between 50 and 100 ns. See Table 43 for the encoding used in this field. */
+#define SFTIME_CS_IDLE_MASK 0xF0000000
+/** field offset */
+#define SFTIME_CS_IDLE_OFFSET 28
+/** 1 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_0 0x00000000
+/** 2 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_1 0x10000000
+/** 3 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_2 0x20000000
+/** 4 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_3 0x30000000
+/** 6 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_4 0x40000000
+/** 8 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_5 0x50000000
+/** 10 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_6 0x60000000
+/** 12 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_7 0x70000000
+/** 14 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_8 0x80000000
+/** 16 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_9 0x90000000
+/** 20 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_10 0xA0000000
+/** 24 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_11 0xB0000000
+/** 32 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_12 0xC0000000
+/** 40 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_13 0xD0000000
+/** 48 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_14 0xE0000000
+/** 64 EBU clock cycles */
+#define SFTIME_CS_IDLE_CLKC_15 0xF0000000
+/** CS Hold time
+    This field defines (in multiples of the EBU internal clock's period) the minimum time the device's Chip Select must remain asserted after transfer of the last bit of a write transaction. This CS hold time does not apply to read accesses */
+#define SFTIME_CS_HOLD_MASK 0x0C000000
+/** field offset */
+#define SFTIME_CS_HOLD_OFFSET 26
+/** CS Setup time
+    This field defines (in multiples of the EBU internal clock's period) when to assert the device's Chip Select before the first SCK clock period for transferring the command is started on the External Bus */
+#define SFTIME_CS_SETUP_MASK 0x03000000
+/** field offset */
+#define SFTIME_CS_SETUP_OFFSET 24
+/** Write-to-Read Pause
+    This field defines the length of the optional pause when switching from write to read direction in the transaction. During this pause, SCK is held stable. */
+#define SFTIME_WR2RD_PAUSE_MASK 0x00300000
+/** field offset */
+#define SFTIME_WR2RD_PAUSE_OFFSET 20
+/** Read Data Position
+    This field defines when to capture valid read data bit(s) (in multiples of half of the EBU internal clock's period) relative to the beginning of the SCK clock's period defined in EBU_SFTIME.sck_per. RD_POS must be less than or equal to EBU_SFTIME.sck_per (not checked in hardware) or unpredictable results may occur. */
+#define SFTIME_RD_POS_MASK 0x000F0000
+/** field offset */
+#define SFTIME_RD_POS_OFFSET 16
+/** SCK Fall-edge Position
+    This field defines the positioning of the SCK fall edge (in multiples of half of the EBU internal clock's period) with respect to the beginning of the SCK clock's period defined in EBU_SFTIME.sck_per. SCKF_POS must be less than or equal to SCK_PER (not checked in hardware) or unpredictable results may occur. If EBU_SFTIME.sck_inv is set, SCKF_POS defines the positioning of the falling instead of the rising edge of SCK. In the current version of the EBU, SCKF_POS must be set 0 or unpredictable results may occur. */
+#define SFTIME_SCKF_POS_MASK 0x0000F000
+/** field offset */
+#define SFTIME_SCKF_POS_OFFSET 12
+/** SCK Rise-edge Position
+    This field defines the positioning of the SCK rise edge (in multiples of half of the EBU internal clock's period) with respect to the beginning of the SCK clock's period defined in EBU_SFTIME.sck_per. SCKR_POS must be less than EBU_SFTIME.sck_per (not checked in hardware) or unpredictable results may occur. If EBU_SFTIME.sck_inv is set, SCKR_POS defines the positioning of the falling instead of the rising edge of SCK. */
+#define SFTIME_SCKR_POS_MASK 0x00000F00
+/** field offset */
+#define SFTIME_SCKR_POS_OFFSET 8
+/** SCK Feedback Clock Inversion
+    If set, read data gets captured with the falling instead of the rising edge of SCK if clock feedback is enabled in EBU_SFTIME.sck_fdbk_en. */
+#define SFTIME_SCK_FDBK_INV 0x00000040
+/** SCK Clock Feedback
+    If set, read data is captured using the external SCK clock feedback into the chip instead of the EBU's internal clock. Using the feedback clock compensate for the high delay over the pads and its use is required at higher frequencies. A penalty for synchronizing the read data from the SCK into the ebu_clk domain applies to the read access latency. */
+#define SFTIME_SCK_FDBK_EN 0x00000020
+/** Inverted SCK
+    If set, the clock to the Serial Flash devices is inverted. This also results in SCK high while a Serial Flash remains selected between transactions (keep_cs feature). In the current version of the EBU, clock inversion is not supported. SCK_INV must be set to 0 or unpredictable results may occur. */
+#define SFTIME_SCK_INV 0x00000010
+/** SCK Period
+    This field defines the period of the SCK clock in multiples of half of the EBU clock period. The EBU supports values between 2 and 14, corresponding to a frequency ratio range from 1:1. to 1:7 between SCK and the internal clock. Other values are prohibited and result in unpredictable behaviour. In the current version of the EBU, odd values for SCK_PER are not supported. */
+#define SFTIME_SCK_PER_MASK 0x0000000F
+/** field offset */
+#define SFTIME_SCK_PER_OFFSET 0
+
+/* Fields of "Serial Flash Status Register" */
+/** Command Overwrite Error
+    This bit is set on an attempt to start an indirect access while a previous indirect access has not finished. The bit remains unaltered when the software writes a '0' and is toggled when a '1' is written. This toggle-by-write-1 behavior allows to also set the bit for testing purposes. In normal operation, the software is supposed to only write a '1' to this bit to clear after it has been set by the Serial Flash protocol engine. */
+#define SFSTAT_CMD_OVWRT_ERR 0x40000000
+/** Command Error
+    This bit is set when the EBU discards an indirect or direct access to/from a Serial Flash. The bit remains unaltered when the software writes a '0' and is toggled when a '1' is written. This toggle-by-write-1 behavior allows to also set the bit for testing purposes. In normal operation, the software is supposed to only write a '1' to this bit to clear after it has been set by the Serial Flash protocol engine. */
+#define SFSTAT_CMD_ERR 0x20000000
+/** Access Command Pending
+    If set, indicates that access from/to a Serial Flash device has not finished yet. */
+#define SFSTAT_CMD_PEND 0x00400000
+/** External Device Selected
+    If set, indicates that the Chip Select of a Serial Flash device is currently active on the External Bus. */
+#define SFSTAT_SELECTED 0x00200000
+/** Protocol Engine Active
+    If set, indicates that the EBU's Serial Flash protocol engine is active. */
+#define SFSTAT_ACTIVE 0x00100000
+/** Page Buffer Invalidate
+    When writing a one to this bit, bits PB_VALID and PB_UPDATE are both cleared, thereby invalidating the page buffer for access to/from the Serial Flash device. After invalidating the buffer, PB_INVALID is automatically cleared so that it always reads as 0. */
+#define SFSTAT_PB_INVALID 0x00010000
+/** Page Buffer Update
+    This bit is set when data in the page buffer gets modified. It is cleared when new data gets loaded to the page buffer, when it is written back to the device (WRITE_PAGE command) or when PB_VALID gets cleared. */
+#define SFSTAT_PB_UPDATE 0x00002000
+/** Page Buffer Valid
+    This bit is set after the last data byte of a LOAD_PAGE command has been stored in the page buffer or when the page buffer is explicitely validated via a VALIDATE_PAGE special command. It remains set until the page buffer gets invalidated by writing a 1 to PB_INVALID or any of the LOAD_PAGE special commands. While PB_VALID is set, all accesses to the buffered address range are diverted to the page buffer with no access being performed on the External Bus. */
+#define SFSTAT_PB_VALID 0x00001000
+/** Page Buffer Busy
+    The bit is set when the EBU starts executing a LOAD_PAGE or a WRITE_PAGE command and cleared when the last byte of the requested page has been transferred from/to the external device. The inverted value of PB_BUSY is output on the EBU interface and may trigger a system interrupt. */
+#define SFSTAT_PB_BUSY 0x00000100
+/** Device Busy
+    This bit is set by the Serial Flash protocol engine when an indirect access is performed via register EBU_SFCMD with SET_BUSY being set. While busy is set, access to the Serial Flash is very limited and all transactions are error-terminated except when explicitly marked to ignore the busy status. If the EBU is configured in EBU_SFCON.EOBDM to automatically poll the busy status of the device, busy is cleared as soon as the device is found to be idle again. On a software write, busy remains unaltered when written with a '0' and is toggled when written with a '1', respectively.This toggle-by-write-1 behaviour allows to also set the bit for testing purposes. In normal operation, the software is supposed to only write a '1' to this bit after it got set by the Serial Flash protocol engine and no automatic busy detection is configured in EBU_SFCON.EOBDM Then the software has to clear busy when it finds the device to be no longer busy by either polling the device's status register via the EBU or by waiting for the maximum busy time of the operation started in the device. */
+#define SFSTAT_BUSY 0x00000001
+
+/* Fields of "Serial Flash Command Register" */
+/** Command Type
+    This field is a qualifier of the command opcode in EBU_SFCMD.opc. Two types */
+#define SFCMD_CMDTYPE 0x80000000
+/* The opcode in EBU_SFCMD.opc is directly used in the command phase of a single transaction to the Serial Flash device.
+#define SFCMD_CMDTYPE_ACCESS_CMD 0x00000000 */
+/** The opcode in EBU_SFCMD.opc is used to start a special command in the Serial Flash Controller which might include any number of external transactions to/from the Serial Flash device. */
+#define SFCMD_CMDTYPE_SPECIAL_CMD 0x80000000
+/** Device Port Width
+    Defines the number of signal lines to be used with direct read access from a Serial Flash as defined for the command with opcode opc. The encoding of this field is the same as forDA_PORTW. */
+#define SFCMD_PORTW_MASK 0x70000000
+/** field offset */
+#define SFCMD_PORTW_OFFSET 28
+/** Bidirectional Signal Lines
+    If set selects bidirectional signal lines to be used for the data transfer. */
+#define SFCMD_BIDIR 0x08000000
+/** Chip Select
+    This field selects which of the EBU's Chip Selects to activated for the command that is written to EBU_SFCMD.opc. A value between 0 and 3 selects one of the EBU's main CSs while 4 to 7 chooses one of the Auxiliary Chip Selects CSA[3:0], respectively. */
+#define SFCMD_CS_MASK 0x07000000
+/** field offset */
+#define SFCMD_CS_OFFSET 24
+/** Disable Auto Address Increment
+    By default, the address in register EBU_SFADDR is automatically incremented with each data byte being transferred. By setting this bit, the auto-increment can be disabled. */
+#define SFCMD_DIS_AAI 0x00800000
+/** Address Length
+    Defines the number of address bytes from register EBU_SFADDR to sent in the address phase of the transaction to/from the Serial Flash. Note: Address bytes are also sent when the command has no data. */
+#define SFCMD_ALEN_MASK 0x00700000
+/** field offset */
+#define SFCMD_ALEN_OFFSET 20
+/** Dummy Phase Length
+    Defines the number of dummy bytes to send to the device between the command/address phase and the data phase of a transaction. Note:Dummy bytes are also sent when the command has no address and/or no data. */
+#define SFCMD_DUMLEN_MASK 0x000F0000
+/** field offset */
+#define SFCMD_DUMLEN_OFFSET 16
+/** Keep Chip Select
+    Defines whether the Serial Flash remains selected after the indirect access transaction has been finished. */
+#define SFCMD_KEEP_CS 0x00008000
+/* After a direct read access, the Serial Flash device is always deselected (CS deasserted). Follow-up read accesses always require sending command opcode and address.
+#define SFCMD_KEEP_CS_DESELECT 0x00000000 */
+/** Chip Select of device is kept active after direct read access so that device is ready for follow-up read of next sequential byte without the need to send command and address. If the next command is to another Chip Select, is a different command or accesses a different address, the EBU first deactivates the kept Chip Select before it starts the new transaction with sending the command opcode and address. */
+#define SFCMD_KEEP_CS_KEEP_SELECTED 0x00008000
+/** Set Busy Flag
+    If set, starting the command sets EBU_SFSTAT.busy. */
+#define SFCMD_SET_BUSY 0x00004000
+/** Ignore Busy
+    By default, the EBU error terminates all attempts to access a Serial Flash while EBU_SFSTAT.busy is set. Setting this bit overrules this error termination and permits the command written to EBU_SFCMD.opc to proceed to the External Bus. Normally, this bit is only set to execute a Read Status Register command to the Serial Flash, but may also be used for any other type of access the device is able to handle while it is busy. */
+#define SFCMD_IGNORE_BUSY 0x00002000
+/** Skip Opcode
+    If this bit is set, the opcode in field OPC is not sent to the External Bus, but the external transaction starts with sending the first address byte (if ALEN 0), the first dummy byte (if alen = 0 and DUMLEN 0), or directly with transferring the data bytes (if ALEN = DUMLEN = 0 and DLEN 0). Limiting the external transfer to just the data phase - together with the keep_cs feature - allow to transfer any number of data bytes for a device command sent via EBU_SFCMD by keeping the device selected between accesses and chaining multiple indirect access commands each transferring up to 4 data bytes from/to register EBU_SFDATA. */
+#define SFCMD_SKIP_OPC 0x00001000
+/** Data Length
+    This field defines the number of data bytes to transfer in the data phase of the command. For a read command, the data bytes are stored in register EBU_SFDATA, for a write transfer they are taken from that register. As the data register can hold at most 4 bytes, DLEN is restricted to the range [0..4]. */
+#define SFCMD_DLEN_MASK 0x00000E00
+/** field offset */
+#define SFCMD_DLEN_OFFSET 9
+/** Direction
+    Defines the direction of the data transfer (if any) in the data phase of the transaction to/from the serial bus. */
+#define SFCMD_DIR 0x00000100
+/* dlen bytes of data are read from the Serial Flash during the data phase of the transaction and stored in register EBU_SFDATA.
+#define SFCMD_DIR_READ 0x00000000 */
+/** dlen bytes of data are read from register EBU_SFDATA and written to the Serial Flash during the data phase of the transactione */
+#define SFCMD_DIR_WRITE 0x00000100
+/** Command Opcode
+    A write access to this field starts an Indirect Access command in the EBU's Serial Flash controller. Two types of commands are supported (selected in EBU_SFCMD.cmdtype) and determine how the EBU interprets the opcode:- - For a ACCESS_CMD, a single transaction is executed to/from the Serial Flash device and the OPC is sent to the device in the command phase of the protocol. The number of address, dummy and data bytes to transfer with the command are given in fields ALEN, DUMLEN, and DLEN of register EBU_SFCMD, respectively. - For a SPECIAL_CMD, the EBU starts a complex operation that usually involves multiple transactions to/from the Serial Flash device. See Section 3.18.2.5 for an overview of the complex commands currently supported. */
+#define SFCMD_OPC_MASK 0x000000FF
+/** field offset */
+#define SFCMD_OPC_OFFSET 0
+
+/* Fields of "Serial Flash Address Register" */
+/** Address
+    Before writing to register EBU_SFCMD to start a command that requires the transfer of an address, the address to use must be stored in this register. If not disabled in EBU_SFCMD.dis_aai, ADDR is incremented automatically with each data byte transferred between the EBU and the Serial Flash for an indirect access. Note:Register EBU_SFADDR is only used for access in Indirect Access Mode and is ignored/remains unaltered for all accesses in Direct Access Mode. */
+#define SFADDR_ADDR_MASK 0xFFFFFFFF
+/** field offset */
+#define SFADDR_ADDR_OFFSET 0
+
+/* Fields of "Serial Flash Data Register" */
+/** Data Bytes
+    Before writing to register EBU_SFCMD to start a command that requires the transfer of data from the EBU to the Serial Flash device (write access), the data to send must be stored in this register. The data bytes have to be right-aligned in this register, that is, the last byte to send must be placed in bits DATA[7:0], the second-to-last byte in bits DATA[15:8], etc.. Similarly, for a read access with data being transferred from the Serial Flash to the EBU, this register collects the read data received from the device. The read data is right-aligned, that is, the last byte received gets placed in bits DATA[7:0], the second-to-last byte in bits DATA[15:8], etc... The number of data bytes to be transferred between EBU and the Serial Flash is defined in EBU_SFCMD.DLEN. Note:Register EBU_SFDATA is only used for accesses in Indirect Access Mode and is ignored/remains unaltered for all accesses in Direct Access Mode. */
+#define SFDATA_DATA_MASK 0xFFFFFFFF
+/** field offset */
+#define SFDATA_DATA_OFFSET 0
+
+/* Fields of "Serial Flash I/O Control Register" */
+/** Start of Write Delay
+    By default, the EBU starts driving to AD[3:0] two EBU clock cycles before asserting the CS for an external Serial Flash access. For write accesses, this delay can be increased via field SOWD. */
+#define SFIO_SOWD_MASK 0x0000F000
+/** field offset */
+#define SFIO_SOWD_OFFSET 12
+/** End of Write Delay
+    This field defines the time (in number of EBU clock cycles) for which the EBU keeps driving the External Bus AD[3:0] after deassertion of the device's CS. */
+#define SFIO_EOWD_MASK 0x00000F00
+/** field offset */
+#define SFIO_EOWD_OFFSET 8
+/** Data Output
+    The EBU always controls the AD[3:0] pins while a CS for a Serial Flash device is asserted. Field UNUSED_WD defines the values being driven to these pins while the Serial Flash controller is not writing data to or is reading data from the device via the respective line. See Section 3.18.6 for details. */
+#define SFIO_UNUSED_WD_MASK 0x0000000F
+/** field offset */
+#define SFIO_UNUSED_WD_OFFSET 0
+
+/*! @} */ /* EBU_REGISTER */
+
+#endif /* _ebu_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/gpio_reg.h b/arch/mips/include/asm/arch-falcon/gpio_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/gpio_reg.h
@@ -0,0 +1,2346 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _gpio_reg_h
+#define _gpio_reg_h
+
+/** \addtogroup GPIO_REGISTER
+   @{
+*/
+/* access macros */
+#define gpio0_r32(reg) reg_r32(&gpio0->reg)
+#define gpio0_w32(val, reg) reg_w32(val, &gpio0->reg)
+#define gpio0_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &gpio0->reg)
+#define gpio0_r32_table(reg, idx) reg_r32_table(gpio0->reg, idx)
+#define gpio0_w32_table(val, reg, idx) reg_w32_table(val, gpio0->reg, idx)
+#define gpio0_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, gpio0->reg, idx)
+#define gpio0_adr_table(reg, idx) adr_table(gpio0->reg, idx)
+
+#define gpio1_r32(reg) reg_r32(&gpio1->reg)
+#define gpio1_w32(val, reg) reg_w32(val, &gpio1->reg)
+#define gpio1_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &gpio1->reg)
+#define gpio1_r32_table(reg, idx) reg_r32_table(gpio1->reg, idx)
+#define gpio1_w32_table(val, reg, idx) reg_w32_table(val, gpio1->reg, idx)
+#define gpio1_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, gpio1->reg, idx)
+#define gpio1_adr_table(reg, idx) adr_table(gpio1->reg, idx)
+
+#define gpio2_r32(reg) reg_r32(&gpio2->reg)
+#define gpio2_w32(val, reg) reg_w32(val, &gpio2->reg)
+#define gpio2_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &gpio2->reg)
+#define gpio2_r32_table(reg, idx) reg_r32_table(gpio2->reg, idx)
+#define gpio2_w32_table(val, reg, idx) reg_w32_table(val, gpio2->reg, idx)
+#define gpio2_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, gpio2->reg, idx)
+#define gpio2_adr_table(reg, idx) adr_table(gpio2->reg, idx)
+
+#define gpio3_r32(reg) reg_r32(&gpio3->reg)
+#define gpio3_w32(val, reg) reg_w32(val, &gpio3->reg)
+#define gpio3_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &gpio3->reg)
+#define gpio3_r32_table(reg, idx) reg_r32_table(gpio3->reg, idx)
+#define gpio3_w32_table(val, reg, idx) reg_w32_table(val, gpio3->reg, idx)
+#define gpio3_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, gpio3->reg, idx)
+#define gpio3_adr_table(reg, idx) adr_table(gpio3->reg, idx)
+
+#define gpio4_r32(reg) reg_r32(&gpio4->reg)
+#define gpio4_w32(val, reg) reg_w32(val, &gpio4->reg)
+#define gpio4_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &gpio4->reg)
+#define gpio4_r32_table(reg, idx) reg_r32_table(gpio4->reg, idx)
+#define gpio4_w32_table(val, reg, idx) reg_w32_table(val, gpio4->reg, idx)
+#define gpio4_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, gpio4->reg, idx)
+#define gpio4_adr_table(reg, idx) adr_table(gpio4->reg, idx)
+
+
+/** GPIO register structure */
+struct gpon_reg_gpio
+{
+   /** Data Output Register
+       Via this register the output values of the different bits can be set if they are switched as outputs. */
+   unsigned int out; /* 0x00000000 */
+   /** Data Input Register
+       Via this register the input values of the different bits can be observed. */
+   unsigned int in; /* 0x00000004 */
+   /** Direction Register
+       Via this register the input direction of the different bits can be determined. */
+   unsigned int dir; /* 0x00000008 */
+   /** Reserved */
+   unsigned int res_0[3]; /* 0x0000000C */
+   /** External Interrupt Control Register 0 */
+   unsigned int exintcr0; /* 0x00000018 */
+   /** External Interrupt Control Register 1 */
+   unsigned int exintcr1; /* 0x0000001C */
+   /** IRN Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncr; /* 0x00000020 */
+   /** IRN Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irnicr; /* 0x00000024 */
+   /** IRN Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irnen; /* 0x00000028 */
+   /** IRN Interrupt Configuration Register
+       Configures the interrupts bitwise to be edge-senstivie or level-sensitive. */
+   unsigned int irncfg; /* 0x0000002C */
+   /** IRN Interrupt Enable Set Register
+       The corresponding bit in the IRNEN register can be set with an atomic access. */
+   unsigned int irnenset; /* 0x00000030 */
+   /** IRN Interrupt Enable Clear Register
+       The corresponding bit in the IRNEN register can be cleared with an atomic access. */
+   unsigned int irnenclr; /* 0x00000034 */
+   /** Reserved */
+   unsigned int res_1[2]; /* 0x00000038 */
+   /** Output Set Register
+       This register can be used to set certain bits within the OUT register without touching the other bits. */
+   unsigned int outset; /* 0x00000040 */
+   /** Output Clear Register
+       This register can be used to clear certain bits within the OUT register without touching the other bits. */
+   unsigned int outclr; /* 0x00000044 */
+   /** Direction Set Register
+       This register can be used to set certain bits within the DIR register without touching the other bits. */
+   unsigned int dirset; /* 0x00000048 */
+   /** Direction Clear Register
+       This register can be used to clear certain bits within the DIR register without touching the other bits. */
+   unsigned int dirclr; /* 0x0000004C */
+   /** Reserved */
+   unsigned int res_2[12]; /* 0x00000050 */
+};
+
+
+/* Fields of "Data Output Register" */
+/** Bit 24 Output Value */
+#define GPIO_OUT_P24 0x01000000
+/** Bit 23 Output Value */
+#define GPIO_OUT_P23 0x00800000
+/** Bit 22 Output Value */
+#define GPIO_OUT_P22 0x00400000
+/** Bit 21 Output Value */
+#define GPIO_OUT_P21 0x00200000
+/** Bit 20 Output Value */
+#define GPIO_OUT_P20 0x00100000
+/** Bit 19 Output Value */
+#define GPIO_OUT_P19 0x00080000
+/** Bit 18 Output Value */
+#define GPIO_OUT_P18 0x00040000
+/** Bit 17 Output Value */
+#define GPIO_OUT_P17 0x00020000
+/** Bit 16 Output Value */
+#define GPIO_OUT_P16 0x00010000
+/** Bit 15 Output Value */
+#define GPIO_OUT_P15 0x00008000
+/** Bit 14 Output Value */
+#define GPIO_OUT_P14 0x00004000
+/** Bit 13 Output Value */
+#define GPIO_OUT_P13 0x00002000
+/** Bit 12 Output Value */
+#define GPIO_OUT_P12 0x00001000
+/** Bit 11 Output Value */
+#define GPIO_OUT_P11 0x00000800
+/** Bit 10 Output Value */
+#define GPIO_OUT_P10 0x00000400
+/** Bit 9 Output Value */
+#define GPIO_OUT_P9 0x00000200
+/** Bit 8 Output Value */
+#define GPIO_OUT_P8 0x00000100
+/** Bit 7 Output Value */
+#define GPIO_OUT_P7 0x00000080
+/** Bit 6 Output Value */
+#define GPIO_OUT_P6 0x00000040
+/** Bit 5 Output Value */
+#define GPIO_OUT_P5 0x00000020
+/** Bit 4 Output Value */
+#define GPIO_OUT_P4 0x00000010
+/** Bit 3 Output Value */
+#define GPIO_OUT_P3 0x00000008
+/** Bit 2 Output Value */
+#define GPIO_OUT_P2 0x00000004
+/** Bit 1 Output Value */
+#define GPIO_OUT_P1 0x00000002
+/** Bit 0 Output Value */
+#define GPIO_OUT_P0 0x00000001
+
+/* Fields of "Data Input Register" */
+/** Bit 24 Latched Input Value */
+#define GPIO_IN_P24 0x01000000
+/** Bit 23 Latched Input Value */
+#define GPIO_IN_P23 0x00800000
+/** Bit 22 Latched Input Value */
+#define GPIO_IN_P22 0x00400000
+/** Bit 21 Latched Input Value */
+#define GPIO_IN_P21 0x00200000
+/** Bit 20 Latched Input Value */
+#define GPIO_IN_P20 0x00100000
+/** Bit 19 Latched Input Value */
+#define GPIO_IN_P19 0x00080000
+/** Bit 18 Latched Input Value */
+#define GPIO_IN_P18 0x00040000
+/** Bit 17 Latched Input Value */
+#define GPIO_IN_P17 0x00020000
+/** Bit 16 Latched Input Value */
+#define GPIO_IN_P16 0x00010000
+/** Bit 15 Latched Input Value */
+#define GPIO_IN_P15 0x00008000
+/** Bit 14 Latched Input Value */
+#define GPIO_IN_P14 0x00004000
+/** Bit 13 Latched Input Value */
+#define GPIO_IN_P13 0x00002000
+/** Bit 12 Latched Input Value */
+#define GPIO_IN_P12 0x00001000
+/** Bit 11 Latched Input Value */
+#define GPIO_IN_P11 0x00000800
+/** Bit 10 Latched Input Value */
+#define GPIO_IN_P10 0x00000400
+/** Bit 9 Latched Input Value */
+#define GPIO_IN_P9 0x00000200
+/** Bit 8 Latched Input Value */
+#define GPIO_IN_P8 0x00000100
+/** Bit 7 Latched Input Value */
+#define GPIO_IN_P7 0x00000080
+/** Bit 6 Latched Input Value */
+#define GPIO_IN_P6 0x00000040
+/** Bit 5 Latched Input Value */
+#define GPIO_IN_P5 0x00000020
+/** Bit 4 Latched Input Value */
+#define GPIO_IN_P4 0x00000010
+/** Bit 3 Latched Input Value */
+#define GPIO_IN_P3 0x00000008
+/** Bit 2 Latched Input Value */
+#define GPIO_IN_P2 0x00000004
+/** Bit 1 Latched Input Value */
+#define GPIO_IN_P1 0x00000002
+/** Bit 0 Latched Input Value */
+#define GPIO_IN_P0 0x00000001
+
+/* Fields of "Direction Register" */
+/** Bit 24 Direction Control */
+#define GPIO_DIR_P24 0x01000000
+/* Input
+#define GPIO_DIR_P24_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P24_OUT 0x01000000
+/** Bit 23 Direction Control */
+#define GPIO_DIR_P23 0x00800000
+/* Input
+#define GPIO_DIR_P23_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P23_OUT 0x00800000
+/** Bit 22 Direction Control */
+#define GPIO_DIR_P22 0x00400000
+/* Input
+#define GPIO_DIR_P22_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P22_OUT 0x00400000
+/** Bit 21 Direction Control */
+#define GPIO_DIR_P21 0x00200000
+/* Input
+#define GPIO_DIR_P21_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P21_OUT 0x00200000
+/** Bit 20 Direction Control */
+#define GPIO_DIR_P20 0x00100000
+/* Input
+#define GPIO_DIR_P20_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P20_OUT 0x00100000
+/** Bit 19 Direction Control */
+#define GPIO_DIR_P19 0x00080000
+/* Input
+#define GPIO_DIR_P19_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P19_OUT 0x00080000
+/** Bit 18 Direction Control */
+#define GPIO_DIR_P18 0x00040000
+/* Input
+#define GPIO_DIR_P18_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P18_OUT 0x00040000
+/** Bit 17 Direction Control */
+#define GPIO_DIR_P17 0x00020000
+/* Input
+#define GPIO_DIR_P17_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P17_OUT 0x00020000
+/** Bit 16 Direction Control */
+#define GPIO_DIR_P16 0x00010000
+/* Input
+#define GPIO_DIR_P16_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P16_OUT 0x00010000
+/** Bit 15 Direction Control */
+#define GPIO_DIR_P15 0x00008000
+/* Input
+#define GPIO_DIR_P15_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P15_OUT 0x00008000
+/** Bit 14 Direction Control */
+#define GPIO_DIR_P14 0x00004000
+/* Input
+#define GPIO_DIR_P14_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P14_OUT 0x00004000
+/** Bit 13 Direction Control */
+#define GPIO_DIR_P13 0x00002000
+/* Input
+#define GPIO_DIR_P13_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P13_OUT 0x00002000
+/** Bit 12 Direction Control */
+#define GPIO_DIR_P12 0x00001000
+/* Input
+#define GPIO_DIR_P12_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P12_OUT 0x00001000
+/** Bit 11 Direction Control */
+#define GPIO_DIR_P11 0x00000800
+/* Input
+#define GPIO_DIR_P11_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P11_OUT 0x00000800
+/** Bit 10 Direction Control */
+#define GPIO_DIR_P10 0x00000400
+/* Input
+#define GPIO_DIR_P10_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P10_OUT 0x00000400
+/** Bit 9 Direction Control */
+#define GPIO_DIR_P9 0x00000200
+/* Input
+#define GPIO_DIR_P9_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P9_OUT 0x00000200
+/** Bit 8 Direction Control */
+#define GPIO_DIR_P8 0x00000100
+/* Input
+#define GPIO_DIR_P8_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P8_OUT 0x00000100
+/** Bit 7 Direction Control */
+#define GPIO_DIR_P7 0x00000080
+/* Input
+#define GPIO_DIR_P7_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P7_OUT 0x00000080
+/** Bit 6 Direction Control */
+#define GPIO_DIR_P6 0x00000040
+/* Input
+#define GPIO_DIR_P6_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P6_OUT 0x00000040
+/** Bit 5 Direction Control */
+#define GPIO_DIR_P5 0x00000020
+/* Input
+#define GPIO_DIR_P5_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P5_OUT 0x00000020
+/** Bit 4 Direction Control */
+#define GPIO_DIR_P4 0x00000010
+/* Input
+#define GPIO_DIR_P4_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P4_OUT 0x00000010
+/** Bit 3 Direction Control */
+#define GPIO_DIR_P3 0x00000008
+/* Input
+#define GPIO_DIR_P3_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P3_OUT 0x00000008
+/** Bit 2 Direction Control */
+#define GPIO_DIR_P2 0x00000004
+/* Input
+#define GPIO_DIR_P2_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P2_OUT 0x00000004
+/** Bit 1 Direction Control */
+#define GPIO_DIR_P1 0x00000002
+/* Input
+#define GPIO_DIR_P1_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P1_OUT 0x00000002
+/** Bit 0 Direction Control */
+#define GPIO_DIR_P0 0x00000001
+/* Input
+#define GPIO_DIR_P0_IN 0x00000000 */
+/** Output */
+#define GPIO_DIR_P0_OUT 0x00000001
+
+/* Fields of "External Interrupt Control Register 0" */
+/** Bit 24 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P24 0x01000000
+/* Positive Logic
+#define GPIO_EXINTCR0_P24_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P24_NEG 0x01000000
+/** Bit 23 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P23 0x00800000
+/* Positive Logic
+#define GPIO_EXINTCR0_P23_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P23_NEG 0x00800000
+/** Bit 22 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P22 0x00400000
+/* Positive Logic
+#define GPIO_EXINTCR0_P22_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P22_NEG 0x00400000
+/** Bit 21 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P21 0x00200000
+/* Positive Logic
+#define GPIO_EXINTCR0_P21_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P21_NEG 0x00200000
+/** Bit 20 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P20 0x00100000
+/* Positive Logic
+#define GPIO_EXINTCR0_P20_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P20_NEG 0x00100000
+/** Bit 19 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P19 0x00080000
+/* Positive Logic
+#define GPIO_EXINTCR0_P19_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P19_NEG 0x00080000
+/** Bit 18 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P18 0x00040000
+/* Positive Logic
+#define GPIO_EXINTCR0_P18_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P18_NEG 0x00040000
+/** Bit 17 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P17 0x00020000
+/* Positive Logic
+#define GPIO_EXINTCR0_P17_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P17_NEG 0x00020000
+/** Bit 16 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P16 0x00010000
+/* Positive Logic
+#define GPIO_EXINTCR0_P16_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P16_NEG 0x00010000
+/** Bit 15 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P15 0x00008000
+/* Positive Logic
+#define GPIO_EXINTCR0_P15_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P15_NEG 0x00008000
+/** Bit 14 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P14 0x00004000
+/* Positive Logic
+#define GPIO_EXINTCR0_P14_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P14_NEG 0x00004000
+/** Bit 13 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P13 0x00002000
+/* Positive Logic
+#define GPIO_EXINTCR0_P13_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P13_NEG 0x00002000
+/** Bit 12 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P12 0x00001000
+/* Positive Logic
+#define GPIO_EXINTCR0_P12_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P12_NEG 0x00001000
+/** Bit 11 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P11 0x00000800
+/* Positive Logic
+#define GPIO_EXINTCR0_P11_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P11_NEG 0x00000800
+/** Bit 10 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P10 0x00000400
+/* Positive Logic
+#define GPIO_EXINTCR0_P10_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P10_NEG 0x00000400
+/** Bit 9 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P9 0x00000200
+/* Positive Logic
+#define GPIO_EXINTCR0_P9_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P9_NEG 0x00000200
+/** Bit 8 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P8 0x00000100
+/* Positive Logic
+#define GPIO_EXINTCR0_P8_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P8_NEG 0x00000100
+/** Bit 7 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P7 0x00000080
+/* Positive Logic
+#define GPIO_EXINTCR0_P7_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P7_NEG 0x00000080
+/** Bit 6 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P6 0x00000040
+/* Positive Logic
+#define GPIO_EXINTCR0_P6_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P6_NEG 0x00000040
+/** Bit 5 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P5 0x00000020
+/* Positive Logic
+#define GPIO_EXINTCR0_P5_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P5_NEG 0x00000020
+/** Bit 4 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P4 0x00000010
+/* Positive Logic
+#define GPIO_EXINTCR0_P4_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P4_NEG 0x00000010
+/** Bit 3 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P3 0x00000008
+/* Positive Logic
+#define GPIO_EXINTCR0_P3_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P3_NEG 0x00000008
+/** Bit 2 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P2 0x00000004
+/* Positive Logic
+#define GPIO_EXINTCR0_P2_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P2_NEG 0x00000004
+/** Bit 1 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P1 0x00000002
+/* Positive Logic
+#define GPIO_EXINTCR0_P1_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P1_NEG 0x00000002
+/** Bit 0 External Interrupt Control 0
+    Selects whether a positive logic event (rising edge, high level) or a negative logic event (falling edge, low level) triggers the interrupt. Selection between edge or level sensitivity can be determined using the IRNCFG register. */
+#define GPIO_EXINTCR0_P0 0x00000001
+/* Positive Logic
+#define GPIO_EXINTCR0_P0_POS 0x00000000 */
+/** Negative Logic */
+#define GPIO_EXINTCR0_P0_NEG 0x00000001
+
+/* Fields of "External Interrupt Control Register 1" */
+/** Bit 24 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P24 0x01000000
+/* Single edge
+#define GPIO_EXINTCR1_P24_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P24_BOTH 0x01000000
+/** Bit 23 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P23 0x00800000
+/* Single edge
+#define GPIO_EXINTCR1_P23_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P23_BOTH 0x00800000
+/** Bit 22 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P22 0x00400000
+/* Single edge
+#define GPIO_EXINTCR1_P22_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P22_BOTH 0x00400000
+/** Bit 21 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P21 0x00200000
+/* Single edge
+#define GPIO_EXINTCR1_P21_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P21_BOTH 0x00200000
+/** Bit 20 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P20 0x00100000
+/* Single edge
+#define GPIO_EXINTCR1_P20_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P20_BOTH 0x00100000
+/** Bit 19 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P19 0x00080000
+/* Single edge
+#define GPIO_EXINTCR1_P19_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P19_BOTH 0x00080000
+/** Bit 18 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P18 0x00040000
+/* Single edge
+#define GPIO_EXINTCR1_P18_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P18_BOTH 0x00040000
+/** Bit 17 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P17 0x00020000
+/* Single edge
+#define GPIO_EXINTCR1_P17_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P17_BOTH 0x00020000
+/** Bit 16 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P16 0x00010000
+/* Single edge
+#define GPIO_EXINTCR1_P16_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P16_BOTH 0x00010000
+/** Bit 15 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P15 0x00008000
+/* Single edge
+#define GPIO_EXINTCR1_P15_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P15_BOTH 0x00008000
+/** Bit 14 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P14 0x00004000
+/* Single edge
+#define GPIO_EXINTCR1_P14_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P14_BOTH 0x00004000
+/** Bit 13 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P13 0x00002000
+/* Single edge
+#define GPIO_EXINTCR1_P13_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P13_BOTH 0x00002000
+/** Bit 12 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P12 0x00001000
+/* Single edge
+#define GPIO_EXINTCR1_P12_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P12_BOTH 0x00001000
+/** Bit 11 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P11 0x00000800
+/* Single edge
+#define GPIO_EXINTCR1_P11_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P11_BOTH 0x00000800
+/** Bit 10 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P10 0x00000400
+/* Single edge
+#define GPIO_EXINTCR1_P10_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P10_BOTH 0x00000400
+/** Bit 9 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P9 0x00000200
+/* Single edge
+#define GPIO_EXINTCR1_P9_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P9_BOTH 0x00000200
+/** Bit 8 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P8 0x00000100
+/* Single edge
+#define GPIO_EXINTCR1_P8_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P8_BOTH 0x00000100
+/** Bit 7 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P7 0x00000080
+/* Single edge
+#define GPIO_EXINTCR1_P7_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P7_BOTH 0x00000080
+/** Bit 6 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P6 0x00000040
+/* Single edge
+#define GPIO_EXINTCR1_P6_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P6_BOTH 0x00000040
+/** Bit 5 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P5 0x00000020
+/* Single edge
+#define GPIO_EXINTCR1_P5_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P5_BOTH 0x00000020
+/** Bit 4 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P4 0x00000010
+/* Single edge
+#define GPIO_EXINTCR1_P4_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P4_BOTH 0x00000010
+/** Bit 3 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P3 0x00000008
+/* Single edge
+#define GPIO_EXINTCR1_P3_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P3_BOTH 0x00000008
+/** Bit 2 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P2 0x00000004
+/* Single edge
+#define GPIO_EXINTCR1_P2_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P2_BOTH 0x00000004
+/** Bit 1 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P1 0x00000002
+/* Single edge
+#define GPIO_EXINTCR1_P1_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P1_BOTH 0x00000002
+/** Bit 0 External Interrupt Control 1
+    Selects whether just one edge or both edges should trigger the interrupt. Note: This bit is only useful if the corresponding interrupt is configured to be edge sensitive in its IRNCFG register. */
+#define GPIO_EXINTCR1_P0 0x00000001
+/* Single edge
+#define GPIO_EXINTCR1_P0_SGL 0x00000000 */
+/** Both edges */
+#define GPIO_EXINTCR1_P0_BOTH 0x00000001
+
+/* Fields of "IRN Capture Register" */
+/** P24 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P24 0x01000000
+/* Nothing
+#define GPIO_IRNCR_P24_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P24_INTACK 0x01000000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P24_INTOCC 0x01000000
+/** P23 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P23 0x00800000
+/* Nothing
+#define GPIO_IRNCR_P23_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P23_INTACK 0x00800000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P23_INTOCC 0x00800000
+/** P22 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P22 0x00400000
+/* Nothing
+#define GPIO_IRNCR_P22_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P22_INTACK 0x00400000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P22_INTOCC 0x00400000
+/** P21 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P21 0x00200000
+/* Nothing
+#define GPIO_IRNCR_P21_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P21_INTACK 0x00200000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P21_INTOCC 0x00200000
+/** P20 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P20 0x00100000
+/* Nothing
+#define GPIO_IRNCR_P20_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P20_INTACK 0x00100000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P20_INTOCC 0x00100000
+/** P19 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P19 0x00080000
+/* Nothing
+#define GPIO_IRNCR_P19_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P19_INTACK 0x00080000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P19_INTOCC 0x00080000
+/** P18 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P18 0x00040000
+/* Nothing
+#define GPIO_IRNCR_P18_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P18_INTACK 0x00040000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P18_INTOCC 0x00040000
+/** P17 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P17 0x00020000
+/* Nothing
+#define GPIO_IRNCR_P17_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P17_INTACK 0x00020000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P17_INTOCC 0x00020000
+/** P16 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P16 0x00010000
+/* Nothing
+#define GPIO_IRNCR_P16_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P16_INTACK 0x00010000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P16_INTOCC 0x00010000
+/** P15 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P15 0x00008000
+/* Nothing
+#define GPIO_IRNCR_P15_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P15_INTACK 0x00008000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P15_INTOCC 0x00008000
+/** P14 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P14 0x00004000
+/* Nothing
+#define GPIO_IRNCR_P14_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P14_INTACK 0x00004000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P14_INTOCC 0x00004000
+/** P13 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P13 0x00002000
+/* Nothing
+#define GPIO_IRNCR_P13_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P13_INTACK 0x00002000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P13_INTOCC 0x00002000
+/** P12 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P12 0x00001000
+/* Nothing
+#define GPIO_IRNCR_P12_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P12_INTACK 0x00001000
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P12_INTOCC 0x00001000
+/** P11 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P11 0x00000800
+/* Nothing
+#define GPIO_IRNCR_P11_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P11_INTACK 0x00000800
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P11_INTOCC 0x00000800
+/** P10 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P10 0x00000400
+/* Nothing
+#define GPIO_IRNCR_P10_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P10_INTACK 0x00000400
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P10_INTOCC 0x00000400
+/** P9 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P9 0x00000200
+/* Nothing
+#define GPIO_IRNCR_P9_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P9_INTACK 0x00000200
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P9_INTOCC 0x00000200
+/** P8 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P8 0x00000100
+/* Nothing
+#define GPIO_IRNCR_P8_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P8_INTACK 0x00000100
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P8_INTOCC 0x00000100
+/** P7 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P7 0x00000080
+/* Nothing
+#define GPIO_IRNCR_P7_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P7_INTACK 0x00000080
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P7_INTOCC 0x00000080
+/** P6 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P6 0x00000040
+/* Nothing
+#define GPIO_IRNCR_P6_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P6_INTACK 0x00000040
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P6_INTOCC 0x00000040
+/** P5 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P5 0x00000020
+/* Nothing
+#define GPIO_IRNCR_P5_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P5_INTACK 0x00000020
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P5_INTOCC 0x00000020
+/** P4 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P4 0x00000010
+/* Nothing
+#define GPIO_IRNCR_P4_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P4_INTACK 0x00000010
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P4_INTOCC 0x00000010
+/** P3 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P3 0x00000008
+/* Nothing
+#define GPIO_IRNCR_P3_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P3_INTACK 0x00000008
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P3_INTOCC 0x00000008
+/** P2 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P2 0x00000004
+/* Nothing
+#define GPIO_IRNCR_P2_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P2_INTACK 0x00000004
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P2_INTOCC 0x00000004
+/** P1 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P1 0x00000002
+/* Nothing
+#define GPIO_IRNCR_P1_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P1_INTACK 0x00000002
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P1_INTOCC 0x00000002
+/** P0 Interrupt
+    This bit is configurable to be either level- or edge-sensitive. This bit contributes to the indirect interrupt. */
+#define GPIO_IRNCR_P0 0x00000001
+/* Nothing
+#define GPIO_IRNCR_P0_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define GPIO_IRNCR_P0_INTACK 0x00000001
+/** Read: Interrupt occurred. */
+#define GPIO_IRNCR_P0_INTOCC 0x00000001
+
+/* Fields of "IRN Interrupt Control Register" */
+/** P24 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P24 0x01000000
+/** P23 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P23 0x00800000
+/** P22 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P22 0x00400000
+/** P21 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P21 0x00200000
+/** P20 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P20 0x00100000
+/** P19 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P19 0x00080000
+/** P18 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P18 0x00040000
+/** P17 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P17 0x00020000
+/** P16 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P16 0x00010000
+/** P15 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P15 0x00008000
+/** P14 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P14 0x00004000
+/** P13 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P13 0x00002000
+/** P12 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P12 0x00001000
+/** P11 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P11 0x00000800
+/** P10 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P10 0x00000400
+/** P9 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P9 0x00000200
+/** P8 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P8 0x00000100
+/** P7 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P7 0x00000080
+/** P6 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P6 0x00000040
+/** P5 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P5 0x00000020
+/** P4 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P4 0x00000010
+/** P3 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P3 0x00000008
+/** P2 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P2 0x00000004
+/** P1 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P1 0x00000002
+/** P0 Interrupt
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNICR_P0 0x00000001
+
+/* Fields of "IRN Interrupt Enable Register" */
+/** P24 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P24 0x01000000
+/* Disable
+#define GPIO_IRNEN_P24_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P24_EN 0x01000000
+/** P23 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P23 0x00800000
+/* Disable
+#define GPIO_IRNEN_P23_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P23_EN 0x00800000
+/** P22 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P22 0x00400000
+/* Disable
+#define GPIO_IRNEN_P22_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P22_EN 0x00400000
+/** P21 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P21 0x00200000
+/* Disable
+#define GPIO_IRNEN_P21_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P21_EN 0x00200000
+/** P20 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P20 0x00100000
+/* Disable
+#define GPIO_IRNEN_P20_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P20_EN 0x00100000
+/** P19 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P19 0x00080000
+/* Disable
+#define GPIO_IRNEN_P19_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P19_EN 0x00080000
+/** P18 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P18 0x00040000
+/* Disable
+#define GPIO_IRNEN_P18_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P18_EN 0x00040000
+/** P17 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P17 0x00020000
+/* Disable
+#define GPIO_IRNEN_P17_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P17_EN 0x00020000
+/** P16 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P16 0x00010000
+/* Disable
+#define GPIO_IRNEN_P16_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P16_EN 0x00010000
+/** P15 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P15 0x00008000
+/* Disable
+#define GPIO_IRNEN_P15_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P15_EN 0x00008000
+/** P14 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P14 0x00004000
+/* Disable
+#define GPIO_IRNEN_P14_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P14_EN 0x00004000
+/** P13 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P13 0x00002000
+/* Disable
+#define GPIO_IRNEN_P13_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P13_EN 0x00002000
+/** P12 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P12 0x00001000
+/* Disable
+#define GPIO_IRNEN_P12_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P12_EN 0x00001000
+/** P11 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P11 0x00000800
+/* Disable
+#define GPIO_IRNEN_P11_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P11_EN 0x00000800
+/** P10 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P10 0x00000400
+/* Disable
+#define GPIO_IRNEN_P10_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P10_EN 0x00000400
+/** P9 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P9 0x00000200
+/* Disable
+#define GPIO_IRNEN_P9_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P9_EN 0x00000200
+/** P8 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P8 0x00000100
+/* Disable
+#define GPIO_IRNEN_P8_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P8_EN 0x00000100
+/** P7 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P7 0x00000080
+/* Disable
+#define GPIO_IRNEN_P7_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P7_EN 0x00000080
+/** P6 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P6 0x00000040
+/* Disable
+#define GPIO_IRNEN_P6_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P6_EN 0x00000040
+/** P5 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P5 0x00000020
+/* Disable
+#define GPIO_IRNEN_P5_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P5_EN 0x00000020
+/** P4 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P4 0x00000010
+/* Disable
+#define GPIO_IRNEN_P4_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P4_EN 0x00000010
+/** P3 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P3 0x00000008
+/* Disable
+#define GPIO_IRNEN_P3_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P3_EN 0x00000008
+/** P2 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P2 0x00000004
+/* Disable
+#define GPIO_IRNEN_P2_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P2_EN 0x00000004
+/** P1 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P1 0x00000002
+/* Disable
+#define GPIO_IRNEN_P1_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P1_EN 0x00000002
+/** P0 Interrupt
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNEN_P0 0x00000001
+/* Disable
+#define GPIO_IRNEN_P0_DIS 0x00000000 */
+/** Enable */
+#define GPIO_IRNEN_P0_EN 0x00000001
+
+/* Fields of "IRN Interrupt Configuration Register" */
+/** P24 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P24 0x01000000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P24_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P24_LEVEL 0x01000000
+/** P23 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P23 0x00800000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P23_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P23_LEVEL 0x00800000
+/** P22 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P22 0x00400000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P22_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P22_LEVEL 0x00400000
+/** P21 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P21 0x00200000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P21_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P21_LEVEL 0x00200000
+/** P20 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P20 0x00100000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P20_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P20_LEVEL 0x00100000
+/** P19 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P19 0x00080000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P19_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P19_LEVEL 0x00080000
+/** P18 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P18 0x00040000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P18_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P18_LEVEL 0x00040000
+/** P17 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P17 0x00020000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P17_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P17_LEVEL 0x00020000
+/** P16 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P16 0x00010000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P16_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P16_LEVEL 0x00010000
+/** P15 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P15 0x00008000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P15_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P15_LEVEL 0x00008000
+/** P14 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P14 0x00004000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P14_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P14_LEVEL 0x00004000
+/** P13 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P13 0x00002000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P13_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P13_LEVEL 0x00002000
+/** P12 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P12 0x00001000
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P12_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P12_LEVEL 0x00001000
+/** P11 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P11 0x00000800
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P11_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P11_LEVEL 0x00000800
+/** P10 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P10 0x00000400
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P10_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P10_LEVEL 0x00000400
+/** P9 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P9 0x00000200
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P9_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P9_LEVEL 0x00000200
+/** P8 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P8 0x00000100
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P8_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P8_LEVEL 0x00000100
+/** P7 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P7 0x00000080
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P7_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P7_LEVEL 0x00000080
+/** P6 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P6 0x00000040
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P6_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P6_LEVEL 0x00000040
+/** P5 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P5 0x00000020
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P5_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P5_LEVEL 0x00000020
+/** P4 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P4 0x00000010
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P4_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P4_LEVEL 0x00000010
+/** P3 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P3 0x00000008
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P3_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P3_LEVEL 0x00000008
+/** P2 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P2 0x00000004
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P2_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P2_LEVEL 0x00000004
+/** P1 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P1 0x00000002
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P1_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P1_LEVEL 0x00000002
+/** P0 Interrupt
+    Interrupt configuration bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNCFG_P0 0x00000001
+/* Interrupt is edge-sensitive
+#define GPIO_IRNCFG_P0_EDGE 0x00000000 */
+/** Interrupt is level-sensitive */
+#define GPIO_IRNCFG_P0_LEVEL 0x00000001
+
+/* Fields of "IRN Interrupt Enable Set Register" */
+/** P24 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P24 0x01000000
+/* Nothing
+#define GPIO_IRNENSET_P24_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P24_SET 0x01000000
+/** P23 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P23 0x00800000
+/* Nothing
+#define GPIO_IRNENSET_P23_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P23_SET 0x00800000
+/** P22 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P22 0x00400000
+/* Nothing
+#define GPIO_IRNENSET_P22_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P22_SET 0x00400000
+/** P21 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P21 0x00200000
+/* Nothing
+#define GPIO_IRNENSET_P21_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P21_SET 0x00200000
+/** P20 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P20 0x00100000
+/* Nothing
+#define GPIO_IRNENSET_P20_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P20_SET 0x00100000
+/** P19 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P19 0x00080000
+/* Nothing
+#define GPIO_IRNENSET_P19_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P19_SET 0x00080000
+/** P18 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P18 0x00040000
+/* Nothing
+#define GPIO_IRNENSET_P18_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P18_SET 0x00040000
+/** P17 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P17 0x00020000
+/* Nothing
+#define GPIO_IRNENSET_P17_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P17_SET 0x00020000
+/** P16 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P16 0x00010000
+/* Nothing
+#define GPIO_IRNENSET_P16_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P16_SET 0x00010000
+/** P15 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P15 0x00008000
+/* Nothing
+#define GPIO_IRNENSET_P15_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P15_SET 0x00008000
+/** P14 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P14 0x00004000
+/* Nothing
+#define GPIO_IRNENSET_P14_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P14_SET 0x00004000
+/** P13 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P13 0x00002000
+/* Nothing
+#define GPIO_IRNENSET_P13_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P13_SET 0x00002000
+/** P12 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P12 0x00001000
+/* Nothing
+#define GPIO_IRNENSET_P12_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P12_SET 0x00001000
+/** P11 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P11 0x00000800
+/* Nothing
+#define GPIO_IRNENSET_P11_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P11_SET 0x00000800
+/** P10 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P10 0x00000400
+/* Nothing
+#define GPIO_IRNENSET_P10_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P10_SET 0x00000400
+/** P9 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P9 0x00000200
+/* Nothing
+#define GPIO_IRNENSET_P9_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P9_SET 0x00000200
+/** P8 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P8 0x00000100
+/* Nothing
+#define GPIO_IRNENSET_P8_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P8_SET 0x00000100
+/** P7 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P7 0x00000080
+/* Nothing
+#define GPIO_IRNENSET_P7_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P7_SET 0x00000080
+/** P6 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P6 0x00000040
+/* Nothing
+#define GPIO_IRNENSET_P6_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P6_SET 0x00000040
+/** P5 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P5 0x00000020
+/* Nothing
+#define GPIO_IRNENSET_P5_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P5_SET 0x00000020
+/** P4 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P4 0x00000010
+/* Nothing
+#define GPIO_IRNENSET_P4_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P4_SET 0x00000010
+/** P3 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P3 0x00000008
+/* Nothing
+#define GPIO_IRNENSET_P3_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P3_SET 0x00000008
+/** P2 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P2 0x00000004
+/* Nothing
+#define GPIO_IRNENSET_P2_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P2_SET 0x00000004
+/** P1 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P1 0x00000002
+/* Nothing
+#define GPIO_IRNENSET_P1_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P1_SET 0x00000002
+/** P0 Interrupt
+    Interrupt-enable set bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENSET_P0 0x00000001
+/* Nothing
+#define GPIO_IRNENSET_P0_NULL 0x00000000 */
+/** Set */
+#define GPIO_IRNENSET_P0_SET 0x00000001
+
+/* Fields of "IRN Interrupt Enable Clear Register" */
+/** P24 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P24 0x01000000
+/* Nothing
+#define GPIO_IRNENCLR_P24_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P24_CLR 0x01000000
+/** P23 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P23 0x00800000
+/* Nothing
+#define GPIO_IRNENCLR_P23_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P23_CLR 0x00800000
+/** P22 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P22 0x00400000
+/* Nothing
+#define GPIO_IRNENCLR_P22_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P22_CLR 0x00400000
+/** P21 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P21 0x00200000
+/* Nothing
+#define GPIO_IRNENCLR_P21_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P21_CLR 0x00200000
+/** P20 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P20 0x00100000
+/* Nothing
+#define GPIO_IRNENCLR_P20_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P20_CLR 0x00100000
+/** P19 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P19 0x00080000
+/* Nothing
+#define GPIO_IRNENCLR_P19_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P19_CLR 0x00080000
+/** P18 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P18 0x00040000
+/* Nothing
+#define GPIO_IRNENCLR_P18_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P18_CLR 0x00040000
+/** P17 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P17 0x00020000
+/* Nothing
+#define GPIO_IRNENCLR_P17_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P17_CLR 0x00020000
+/** P16 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P16 0x00010000
+/* Nothing
+#define GPIO_IRNENCLR_P16_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P16_CLR 0x00010000
+/** P15 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P15 0x00008000
+/* Nothing
+#define GPIO_IRNENCLR_P15_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P15_CLR 0x00008000
+/** P14 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P14 0x00004000
+/* Nothing
+#define GPIO_IRNENCLR_P14_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P14_CLR 0x00004000
+/** P13 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P13 0x00002000
+/* Nothing
+#define GPIO_IRNENCLR_P13_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P13_CLR 0x00002000
+/** P12 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P12 0x00001000
+/* Nothing
+#define GPIO_IRNENCLR_P12_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P12_CLR 0x00001000
+/** P11 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P11 0x00000800
+/* Nothing
+#define GPIO_IRNENCLR_P11_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P11_CLR 0x00000800
+/** P10 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P10 0x00000400
+/* Nothing
+#define GPIO_IRNENCLR_P10_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P10_CLR 0x00000400
+/** P9 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P9 0x00000200
+/* Nothing
+#define GPIO_IRNENCLR_P9_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P9_CLR 0x00000200
+/** P8 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P8 0x00000100
+/* Nothing
+#define GPIO_IRNENCLR_P8_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P8_CLR 0x00000100
+/** P7 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P7 0x00000080
+/* Nothing
+#define GPIO_IRNENCLR_P7_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P7_CLR 0x00000080
+/** P6 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P6 0x00000040
+/* Nothing
+#define GPIO_IRNENCLR_P6_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P6_CLR 0x00000040
+/** P5 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P5 0x00000020
+/* Nothing
+#define GPIO_IRNENCLR_P5_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P5_CLR 0x00000020
+/** P4 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P4 0x00000010
+/* Nothing
+#define GPIO_IRNENCLR_P4_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P4_CLR 0x00000010
+/** P3 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P3 0x00000008
+/* Nothing
+#define GPIO_IRNENCLR_P3_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P3_CLR 0x00000008
+/** P2 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P2 0x00000004
+/* Nothing
+#define GPIO_IRNENCLR_P2_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P2_CLR 0x00000004
+/** P1 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P1 0x00000002
+/* Nothing
+#define GPIO_IRNENCLR_P1_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P1_CLR 0x00000002
+/** P0 Interrupt
+    Interrupt-enable clear bit for the corresponding bit in the IRNCR register. */
+#define GPIO_IRNENCLR_P0 0x00000001
+/* Nothing
+#define GPIO_IRNENCLR_P0_NULL 0x00000000 */
+/** Clear */
+#define GPIO_IRNENCLR_P0_CLR 0x00000001
+
+/* Fields of "Output Set Register" */
+/** Bit 24 Output Set */
+#define GPIO_OUTSET_P24 0x01000000
+/* No-Operation
+#define GPIO_OUTSET_P24_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P24_SET 0x01000000
+/** Bit 23 Output Set */
+#define GPIO_OUTSET_P23 0x00800000
+/* No-Operation
+#define GPIO_OUTSET_P23_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P23_SET 0x00800000
+/** Bit 22 Output Set */
+#define GPIO_OUTSET_P22 0x00400000
+/* No-Operation
+#define GPIO_OUTSET_P22_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P22_SET 0x00400000
+/** Bit 21 Output Set */
+#define GPIO_OUTSET_P21 0x00200000
+/* No-Operation
+#define GPIO_OUTSET_P21_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P21_SET 0x00200000
+/** Bit 20 Output Set */
+#define GPIO_OUTSET_P20 0x00100000
+/* No-Operation
+#define GPIO_OUTSET_P20_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P20_SET 0x00100000
+/** Bit 19 Output Set */
+#define GPIO_OUTSET_P19 0x00080000
+/* No-Operation
+#define GPIO_OUTSET_P19_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P19_SET 0x00080000
+/** Bit 18 Output Set */
+#define GPIO_OUTSET_P18 0x00040000
+/* No-Operation
+#define GPIO_OUTSET_P18_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P18_SET 0x00040000
+/** Bit 17 Output Set */
+#define GPIO_OUTSET_P17 0x00020000
+/* No-Operation
+#define GPIO_OUTSET_P17_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P17_SET 0x00020000
+/** Bit 16 Output Set */
+#define GPIO_OUTSET_P16 0x00010000
+/* No-Operation
+#define GPIO_OUTSET_P16_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P16_SET 0x00010000
+/** Bit 15 Output Set */
+#define GPIO_OUTSET_P15 0x00008000
+/* No-Operation
+#define GPIO_OUTSET_P15_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P15_SET 0x00008000
+/** Bit 14 Output Set */
+#define GPIO_OUTSET_P14 0x00004000
+/* No-Operation
+#define GPIO_OUTSET_P14_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P14_SET 0x00004000
+/** Bit 13 Output Set */
+#define GPIO_OUTSET_P13 0x00002000
+/* No-Operation
+#define GPIO_OUTSET_P13_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P13_SET 0x00002000
+/** Bit 12 Output Set */
+#define GPIO_OUTSET_P12 0x00001000
+/* No-Operation
+#define GPIO_OUTSET_P12_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P12_SET 0x00001000
+/** Bit 11 Output Set */
+#define GPIO_OUTSET_P11 0x00000800
+/* No-Operation
+#define GPIO_OUTSET_P11_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P11_SET 0x00000800
+/** Bit 10 Output Set */
+#define GPIO_OUTSET_P10 0x00000400
+/* No-Operation
+#define GPIO_OUTSET_P10_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P10_SET 0x00000400
+/** Bit 9 Output Set */
+#define GPIO_OUTSET_P9 0x00000200
+/* No-Operation
+#define GPIO_OUTSET_P9_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P9_SET 0x00000200
+/** Bit 8 Output Set */
+#define GPIO_OUTSET_P8 0x00000100
+/* No-Operation
+#define GPIO_OUTSET_P8_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P8_SET 0x00000100
+/** Bit 7 Output Set */
+#define GPIO_OUTSET_P7 0x00000080
+/* No-Operation
+#define GPIO_OUTSET_P7_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P7_SET 0x00000080
+/** Bit 6 Output Set */
+#define GPIO_OUTSET_P6 0x00000040
+/* No-Operation
+#define GPIO_OUTSET_P6_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P6_SET 0x00000040
+/** Bit 5 Output Set */
+#define GPIO_OUTSET_P5 0x00000020
+/* No-Operation
+#define GPIO_OUTSET_P5_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P5_SET 0x00000020
+/** Bit 4 Output Set */
+#define GPIO_OUTSET_P4 0x00000010
+/* No-Operation
+#define GPIO_OUTSET_P4_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P4_SET 0x00000010
+/** Bit 3 Output Set */
+#define GPIO_OUTSET_P3 0x00000008
+/* No-Operation
+#define GPIO_OUTSET_P3_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P3_SET 0x00000008
+/** Bit 2 Output Set */
+#define GPIO_OUTSET_P2 0x00000004
+/* No-Operation
+#define GPIO_OUTSET_P2_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P2_SET 0x00000004
+/** Bit 1 Output Set */
+#define GPIO_OUTSET_P1 0x00000002
+/* No-Operation
+#define GPIO_OUTSET_P1_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P1_SET 0x00000002
+/** Bit 0 Output Set */
+#define GPIO_OUTSET_P0 0x00000001
+/* No-Operation
+#define GPIO_OUTSET_P0_NOP 0x00000000 */
+/** Set */
+#define GPIO_OUTSET_P0_SET 0x00000001
+
+/* Fields of "Output Clear Register" */
+/** Bit 24 Output Clear */
+#define GPIO_OUTCLR_P24 0x01000000
+/* No-Operation
+#define GPIO_OUTCLR_P24_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P24_CLR 0x01000000
+/** Bit 23 Output Clear */
+#define GPIO_OUTCLR_P23 0x00800000
+/* No-Operation
+#define GPIO_OUTCLR_P23_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P23_CLR 0x00800000
+/** Bit 22 Output Clear */
+#define GPIO_OUTCLR_P22 0x00400000
+/* No-Operation
+#define GPIO_OUTCLR_P22_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P22_CLR 0x00400000
+/** Bit 21 Output Clear */
+#define GPIO_OUTCLR_P21 0x00200000
+/* No-Operation
+#define GPIO_OUTCLR_P21_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P21_CLR 0x00200000
+/** Bit 20 Output Clear */
+#define GPIO_OUTCLR_P20 0x00100000
+/* No-Operation
+#define GPIO_OUTCLR_P20_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P20_CLR 0x00100000
+/** Bit 19 Output Clear */
+#define GPIO_OUTCLR_P19 0x00080000
+/* No-Operation
+#define GPIO_OUTCLR_P19_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P19_CLR 0x00080000
+/** Bit 18 Output Clear */
+#define GPIO_OUTCLR_P18 0x00040000
+/* No-Operation
+#define GPIO_OUTCLR_P18_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P18_CLR 0x00040000
+/** Bit 17 Output Clear */
+#define GPIO_OUTCLR_P17 0x00020000
+/* No-Operation
+#define GPIO_OUTCLR_P17_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P17_CLR 0x00020000
+/** Bit 16 Output Clear */
+#define GPIO_OUTCLR_P16 0x00010000
+/* No-Operation
+#define GPIO_OUTCLR_P16_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P16_CLR 0x00010000
+/** Bit 15 Output Clear */
+#define GPIO_OUTCLR_P15 0x00008000
+/* No-Operation
+#define GPIO_OUTCLR_P15_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P15_CLR 0x00008000
+/** Bit 14 Output Clear */
+#define GPIO_OUTCLR_P14 0x00004000
+/* No-Operation
+#define GPIO_OUTCLR_P14_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P14_CLR 0x00004000
+/** Bit 13 Output Clear */
+#define GPIO_OUTCLR_P13 0x00002000
+/* No-Operation
+#define GPIO_OUTCLR_P13_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P13_CLR 0x00002000
+/** Bit 12 Output Clear */
+#define GPIO_OUTCLR_P12 0x00001000
+/* No-Operation
+#define GPIO_OUTCLR_P12_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P12_CLR 0x00001000
+/** Bit 11 Output Clear */
+#define GPIO_OUTCLR_P11 0x00000800
+/* No-Operation
+#define GPIO_OUTCLR_P11_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P11_CLR 0x00000800
+/** Bit 10 Output Clear */
+#define GPIO_OUTCLR_P10 0x00000400
+/* No-Operation
+#define GPIO_OUTCLR_P10_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P10_CLR 0x00000400
+/** Bit 9 Output Clear */
+#define GPIO_OUTCLR_P9 0x00000200
+/* No-Operation
+#define GPIO_OUTCLR_P9_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P9_CLR 0x00000200
+/** Bit 8 Output Clear */
+#define GPIO_OUTCLR_P8 0x00000100
+/* No-Operation
+#define GPIO_OUTCLR_P8_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P8_CLR 0x00000100
+/** Bit 7 Output Clear */
+#define GPIO_OUTCLR_P7 0x00000080
+/* No-Operation
+#define GPIO_OUTCLR_P7_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P7_CLR 0x00000080
+/** Bit 6 Output Clear */
+#define GPIO_OUTCLR_P6 0x00000040
+/* No-Operation
+#define GPIO_OUTCLR_P6_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P6_CLR 0x00000040
+/** Bit 5 Output Clear */
+#define GPIO_OUTCLR_P5 0x00000020
+/* No-Operation
+#define GPIO_OUTCLR_P5_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P5_CLR 0x00000020
+/** Bit 4 Output Clear */
+#define GPIO_OUTCLR_P4 0x00000010
+/* No-Operation
+#define GPIO_OUTCLR_P4_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P4_CLR 0x00000010
+/** Bit 3 Output Clear */
+#define GPIO_OUTCLR_P3 0x00000008
+/* No-Operation
+#define GPIO_OUTCLR_P3_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P3_CLR 0x00000008
+/** Bit 2 Output Clear */
+#define GPIO_OUTCLR_P2 0x00000004
+/* No-Operation
+#define GPIO_OUTCLR_P2_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P2_CLR 0x00000004
+/** Bit 1 Output Clear */
+#define GPIO_OUTCLR_P1 0x00000002
+/* No-Operation
+#define GPIO_OUTCLR_P1_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P1_CLR 0x00000002
+/** Bit 0 Output Clear */
+#define GPIO_OUTCLR_P0 0x00000001
+/* No-Operation
+#define GPIO_OUTCLR_P0_NOP 0x00000000 */
+/** Clear */
+#define GPIO_OUTCLR_P0_CLR 0x00000001
+
+/* Fields of "Direction Set Register" */
+/** Bit 24 Direction Set */
+#define GPIO_DIRSET_P24 0x01000000
+/* No-Operation
+#define GPIO_DIRSET_P24_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P24_SET 0x01000000
+/** Bit 23 Direction Set */
+#define GPIO_DIRSET_P23 0x00800000
+/* No-Operation
+#define GPIO_DIRSET_P23_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P23_SET 0x00800000
+/** Bit 22 Direction Set */
+#define GPIO_DIRSET_P22 0x00400000
+/* No-Operation
+#define GPIO_DIRSET_P22_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P22_SET 0x00400000
+/** Bit 21 Direction Set */
+#define GPIO_DIRSET_P21 0x00200000
+/* No-Operation
+#define GPIO_DIRSET_P21_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P21_SET 0x00200000
+/** Bit 20 Direction Set */
+#define GPIO_DIRSET_P20 0x00100000
+/* No-Operation
+#define GPIO_DIRSET_P20_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P20_SET 0x00100000
+/** Bit 19 Direction Set */
+#define GPIO_DIRSET_P19 0x00080000
+/* No-Operation
+#define GPIO_DIRSET_P19_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P19_SET 0x00080000
+/** Bit 18 Direction Set */
+#define GPIO_DIRSET_P18 0x00040000
+/* No-Operation
+#define GPIO_DIRSET_P18_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P18_SET 0x00040000
+/** Bit 17 Direction Set */
+#define GPIO_DIRSET_P17 0x00020000
+/* No-Operation
+#define GPIO_DIRSET_P17_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P17_SET 0x00020000
+/** Bit 16 Direction Set */
+#define GPIO_DIRSET_P16 0x00010000
+/* No-Operation
+#define GPIO_DIRSET_P16_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P16_SET 0x00010000
+/** Bit 15 Direction Set */
+#define GPIO_DIRSET_P15 0x00008000
+/* No-Operation
+#define GPIO_DIRSET_P15_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P15_SET 0x00008000
+/** Bit 14 Direction Set */
+#define GPIO_DIRSET_P14 0x00004000
+/* No-Operation
+#define GPIO_DIRSET_P14_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P14_SET 0x00004000
+/** Bit 13 Direction Set */
+#define GPIO_DIRSET_P13 0x00002000
+/* No-Operation
+#define GPIO_DIRSET_P13_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P13_SET 0x00002000
+/** Bit 12 Direction Set */
+#define GPIO_DIRSET_P12 0x00001000
+/* No-Operation
+#define GPIO_DIRSET_P12_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P12_SET 0x00001000
+/** Bit 11 Direction Set */
+#define GPIO_DIRSET_P11 0x00000800
+/* No-Operation
+#define GPIO_DIRSET_P11_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P11_SET 0x00000800
+/** Bit 10 Direction Set */
+#define GPIO_DIRSET_P10 0x00000400
+/* No-Operation
+#define GPIO_DIRSET_P10_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P10_SET 0x00000400
+/** Bit 9 Direction Set */
+#define GPIO_DIRSET_P9 0x00000200
+/* No-Operation
+#define GPIO_DIRSET_P9_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P9_SET 0x00000200
+/** Bit 8 Direction Set */
+#define GPIO_DIRSET_P8 0x00000100
+/* No-Operation
+#define GPIO_DIRSET_P8_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P8_SET 0x00000100
+/** Bit 7 Direction Set */
+#define GPIO_DIRSET_P7 0x00000080
+/* No-Operation
+#define GPIO_DIRSET_P7_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P7_SET 0x00000080
+/** Bit 6 Direction Set */
+#define GPIO_DIRSET_P6 0x00000040
+/* No-Operation
+#define GPIO_DIRSET_P6_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P6_SET 0x00000040
+/** Bit 5 Direction Set */
+#define GPIO_DIRSET_P5 0x00000020
+/* No-Operation
+#define GPIO_DIRSET_P5_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P5_SET 0x00000020
+/** Bit 4 Direction Set */
+#define GPIO_DIRSET_P4 0x00000010
+/* No-Operation
+#define GPIO_DIRSET_P4_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P4_SET 0x00000010
+/** Bit 3 Direction Set */
+#define GPIO_DIRSET_P3 0x00000008
+/* No-Operation
+#define GPIO_DIRSET_P3_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P3_SET 0x00000008
+/** Bit 2 Direction Set */
+#define GPIO_DIRSET_P2 0x00000004
+/* No-Operation
+#define GPIO_DIRSET_P2_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P2_SET 0x00000004
+/** Bit 1 Direction Set */
+#define GPIO_DIRSET_P1 0x00000002
+/* No-Operation
+#define GPIO_DIRSET_P1_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P1_SET 0x00000002
+/** Bit 0 Direction Set */
+#define GPIO_DIRSET_P0 0x00000001
+/* No-Operation
+#define GPIO_DIRSET_P0_NOP 0x00000000 */
+/** Set */
+#define GPIO_DIRSET_P0_SET 0x00000001
+
+/* Fields of "Direction Clear Register" */
+/** Bit 24 Direction Clear */
+#define GPIO_DIRCLR_P24 0x01000000
+/* No-Operation
+#define GPIO_DIRCLR_P24_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P24_CLR 0x01000000
+/** Bit 23 Direction Clear */
+#define GPIO_DIRCLR_P23 0x00800000
+/* No-Operation
+#define GPIO_DIRCLR_P23_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P23_CLR 0x00800000
+/** Bit 22 Direction Clear */
+#define GPIO_DIRCLR_P22 0x00400000
+/* No-Operation
+#define GPIO_DIRCLR_P22_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P22_CLR 0x00400000
+/** Bit 21 Direction Clear */
+#define GPIO_DIRCLR_P21 0x00200000
+/* No-Operation
+#define GPIO_DIRCLR_P21_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P21_CLR 0x00200000
+/** Bit 20 Direction Clear */
+#define GPIO_DIRCLR_P20 0x00100000
+/* No-Operation
+#define GPIO_DIRCLR_P20_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P20_CLR 0x00100000
+/** Bit 19 Direction Clear */
+#define GPIO_DIRCLR_P19 0x00080000
+/* No-Operation
+#define GPIO_DIRCLR_P19_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P19_CLR 0x00080000
+/** Bit 18 Direction Clear */
+#define GPIO_DIRCLR_P18 0x00040000
+/* No-Operation
+#define GPIO_DIRCLR_P18_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P18_CLR 0x00040000
+/** Bit 17 Direction Clear */
+#define GPIO_DIRCLR_P17 0x00020000
+/* No-Operation
+#define GPIO_DIRCLR_P17_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P17_CLR 0x00020000
+/** Bit 16 Direction Clear */
+#define GPIO_DIRCLR_P16 0x00010000
+/* No-Operation
+#define GPIO_DIRCLR_P16_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P16_CLR 0x00010000
+/** Bit 15 Direction Clear */
+#define GPIO_DIRCLR_P15 0x00008000
+/* No-Operation
+#define GPIO_DIRCLR_P15_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P15_CLR 0x00008000
+/** Bit 14 Direction Clear */
+#define GPIO_DIRCLR_P14 0x00004000
+/* No-Operation
+#define GPIO_DIRCLR_P14_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P14_CLR 0x00004000
+/** Bit 13 Direction Clear */
+#define GPIO_DIRCLR_P13 0x00002000
+/* No-Operation
+#define GPIO_DIRCLR_P13_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P13_CLR 0x00002000
+/** Bit 12 Direction Clear */
+#define GPIO_DIRCLR_P12 0x00001000
+/* No-Operation
+#define GPIO_DIRCLR_P12_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P12_CLR 0x00001000
+/** Bit 11 Direction Clear */
+#define GPIO_DIRCLR_P11 0x00000800
+/* No-Operation
+#define GPIO_DIRCLR_P11_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P11_CLR 0x00000800
+/** Bit 10 Direction Clear */
+#define GPIO_DIRCLR_P10 0x00000400
+/* No-Operation
+#define GPIO_DIRCLR_P10_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P10_CLR 0x00000400
+/** Bit 9 Direction Clear */
+#define GPIO_DIRCLR_P9 0x00000200
+/* No-Operation
+#define GPIO_DIRCLR_P9_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P9_CLR 0x00000200
+/** Bit 8 Direction Clear */
+#define GPIO_DIRCLR_P8 0x00000100
+/* No-Operation
+#define GPIO_DIRCLR_P8_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P8_CLR 0x00000100
+/** Bit 7 Direction Clear */
+#define GPIO_DIRCLR_P7 0x00000080
+/* No-Operation
+#define GPIO_DIRCLR_P7_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P7_CLR 0x00000080
+/** Bit 6 Direction Clear */
+#define GPIO_DIRCLR_P6 0x00000040
+/* No-Operation
+#define GPIO_DIRCLR_P6_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P6_CLR 0x00000040
+/** Bit 5 Direction Clear */
+#define GPIO_DIRCLR_P5 0x00000020
+/* No-Operation
+#define GPIO_DIRCLR_P5_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P5_CLR 0x00000020
+/** Bit 4 Direction Clear */
+#define GPIO_DIRCLR_P4 0x00000010
+/* No-Operation
+#define GPIO_DIRCLR_P4_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P4_CLR 0x00000010
+/** Bit 3 Direction Clear */
+#define GPIO_DIRCLR_P3 0x00000008
+/* No-Operation
+#define GPIO_DIRCLR_P3_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P3_CLR 0x00000008
+/** Bit 2 Direction Clear */
+#define GPIO_DIRCLR_P2 0x00000004
+/* No-Operation
+#define GPIO_DIRCLR_P2_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P2_CLR 0x00000004
+/** Bit 1 Direction Clear */
+#define GPIO_DIRCLR_P1 0x00000002
+/* No-Operation
+#define GPIO_DIRCLR_P1_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P1_CLR 0x00000002
+/** Bit 0 Direction Clear */
+#define GPIO_DIRCLR_P0 0x00000001
+/* No-Operation
+#define GPIO_DIRCLR_P0_NOP 0x00000000 */
+/** Clear */
+#define GPIO_DIRCLR_P0_CLR 0x00000001
+
+/*! @} */ /* GPIO_REGISTER */
+
+#endif /* _gpio_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/gpon_reg_base.h b/arch/mips/include/asm/arch-falcon/gpon_reg_base.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/gpon_reg_base.h
@@ -0,0 +1,391 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _gpon_reg_base_h
+#define _gpon_reg_base_h
+
+/** \addtogroup GPON_BASE
+   @{
+*/
+
+#ifndef KSEG1
+#define KSEG1 0xA0000000
+#endif
+
+/** address range for ebu
+    0x18000000--0x180000FF */
+#define GPON_EBU_BASE		(KSEG1 | 0x18000000)
+#define GPON_EBU_END		(KSEG1 | 0x180000FF)
+#define GPON_EBU_SIZE		0x00000100
+/** address range for gpearb
+    0x1D400100--0x1D4001FF */
+#define GPON_GPEARB_BASE		(KSEG1 | 0x1D400100)
+#define GPON_GPEARB_END		(KSEG1 | 0x1D4001FF)
+#define GPON_GPEARB_SIZE		0x00000100
+/** address range for tmu
+    0x1D404000--0x1D404FFF */
+#define GPON_TMU_BASE		(KSEG1 | 0x1D404000)
+#define GPON_TMU_END		(KSEG1 | 0x1D404FFF)
+#define GPON_TMU_SIZE		0x00001000
+/** address range for iqm
+    0x1D410000--0x1D41FFFF */
+#define GPON_IQM_BASE		(KSEG1 | 0x1D410000)
+#define GPON_IQM_END		(KSEG1 | 0x1D41FFFF)
+#define GPON_IQM_SIZE		0x00010000
+/** address range for octrlg
+    0x1D420000--0x1D42FFFF */
+#define GPON_OCTRLG_BASE		(KSEG1 | 0x1D420000)
+#define GPON_OCTRLG_END		(KSEG1 | 0x1D42FFFF)
+#define GPON_OCTRLG_SIZE		0x00010000
+/** address range for octrll0
+    0x1D440000--0x1D4400FF */
+#define GPON_OCTRLL0_BASE		(KSEG1 | 0x1D440000)
+#define GPON_OCTRLL0_END		(KSEG1 | 0x1D4400FF)
+#define GPON_OCTRLL0_SIZE		0x00000100
+/** address range for octrll1
+    0x1D440100--0x1D4401FF */
+#define GPON_OCTRLL1_BASE		(KSEG1 | 0x1D440100)
+#define GPON_OCTRLL1_END		(KSEG1 | 0x1D4401FF)
+#define GPON_OCTRLL1_SIZE		0x00000100
+/** address range for octrll2
+    0x1D440200--0x1D4402FF */
+#define GPON_OCTRLL2_BASE		(KSEG1 | 0x1D440200)
+#define GPON_OCTRLL2_END		(KSEG1 | 0x1D4402FF)
+#define GPON_OCTRLL2_SIZE		0x00000100
+/** address range for octrll3
+    0x1D440300--0x1D4403FF */
+#define GPON_OCTRLL3_BASE		(KSEG1 | 0x1D440300)
+#define GPON_OCTRLL3_END		(KSEG1 | 0x1D4403FF)
+#define GPON_OCTRLL3_SIZE		0x00000100
+/** address range for octrlc
+    0x1D441000--0x1D4410FF */
+#define GPON_OCTRLC_BASE		(KSEG1 | 0x1D441000)
+#define GPON_OCTRLC_END		(KSEG1 | 0x1D4410FF)
+#define GPON_OCTRLC_SIZE		0x00000100
+/** address range for ictrlg
+    0x1D450000--0x1D45FFFF */
+#define GPON_ICTRLG_BASE		(KSEG1 | 0x1D450000)
+#define GPON_ICTRLG_END		(KSEG1 | 0x1D45FFFF)
+#define GPON_ICTRLG_SIZE		0x00010000
+/** address range for ictrll0
+    0x1D460000--0x1D4601FF */
+#define GPON_ICTRLL0_BASE		(KSEG1 | 0x1D460000)
+#define GPON_ICTRLL0_END		(KSEG1 | 0x1D4601FF)
+#define GPON_ICTRLL0_SIZE		0x00000200
+/** address range for ictrll1
+    0x1D460200--0x1D4603FF */
+#define GPON_ICTRLL1_BASE		(KSEG1 | 0x1D460200)
+#define GPON_ICTRLL1_END		(KSEG1 | 0x1D4603FF)
+#define GPON_ICTRLL1_SIZE		0x00000200
+/** address range for ictrll2
+    0x1D460400--0x1D4605FF */
+#define GPON_ICTRLL2_BASE		(KSEG1 | 0x1D460400)
+#define GPON_ICTRLL2_END		(KSEG1 | 0x1D4605FF)
+#define GPON_ICTRLL2_SIZE		0x00000200
+/** address range for ictrll3
+    0x1D460600--0x1D4607FF */
+#define GPON_ICTRLL3_BASE		(KSEG1 | 0x1D460600)
+#define GPON_ICTRLL3_END		(KSEG1 | 0x1D4607FF)
+#define GPON_ICTRLL3_SIZE		0x00000200
+/** address range for ictrlc0
+    0x1D461000--0x1D4610FF */
+#define GPON_ICTRLC0_BASE		(KSEG1 | 0x1D461000)
+#define GPON_ICTRLC0_END		(KSEG1 | 0x1D4610FF)
+#define GPON_ICTRLC0_SIZE		0x00000100
+/** address range for ictrlc1
+    0x1D461100--0x1D4611FF */
+#define GPON_ICTRLC1_BASE		(KSEG1 | 0x1D461100)
+#define GPON_ICTRLC1_END		(KSEG1 | 0x1D4611FF)
+#define GPON_ICTRLC1_SIZE		0x00000100
+/** address range for fsqm
+    0x1D500000--0x1D5FFFFF */
+#define GPON_FSQM_BASE		(KSEG1 | 0x1D500000)
+#define GPON_FSQM_END		(KSEG1 | 0x1D5FFFFF)
+#define GPON_FSQM_SIZE		0x00100000
+/** address range for pctrl
+    0x1D600000--0x1D6001FF */
+#define GPON_PCTRL_BASE		(KSEG1 | 0x1D600000)
+#define GPON_PCTRL_END		(KSEG1 | 0x1D6001FF)
+#define GPON_PCTRL_SIZE		0x00000200
+/** address range for link0
+    0x1D600200--0x1D6002FF */
+#define GPON_LINK0_BASE		(KSEG1 | 0x1D600200)
+#define GPON_LINK0_END		(KSEG1 | 0x1D6002FF)
+#define GPON_LINK0_SIZE		0x00000100
+/** address range for link1
+    0x1D600300--0x1D6003FF */
+#define GPON_LINK1_BASE		(KSEG1 | 0x1D600300)
+#define GPON_LINK1_END		(KSEG1 | 0x1D6003FF)
+#define GPON_LINK1_SIZE		0x00000100
+/** address range for link2
+    0x1D600400--0x1D6004FF */
+#define GPON_LINK2_BASE		(KSEG1 | 0x1D600400)
+#define GPON_LINK2_END		(KSEG1 | 0x1D6004FF)
+#define GPON_LINK2_SIZE		0x00000100
+/** address range for disp
+    0x1D600500--0x1D6005FF */
+#define GPON_DISP_BASE		(KSEG1 | 0x1D600500)
+#define GPON_DISP_END		(KSEG1 | 0x1D6005FF)
+#define GPON_DISP_SIZE		0x00000100
+/** address range for merge
+    0x1D600600--0x1D6006FF */
+#define GPON_MERGE_BASE		(KSEG1 | 0x1D600600)
+#define GPON_MERGE_END		(KSEG1 | 0x1D6006FF)
+#define GPON_MERGE_SIZE		0x00000100
+/** address range for tbm
+    0x1D600700--0x1D6007FF */
+#define GPON_TBM_BASE		(KSEG1 | 0x1D600700)
+#define GPON_TBM_END		(KSEG1 | 0x1D6007FF)
+#define GPON_TBM_SIZE		0x00000100
+/** address range for pe0
+    0x1D610000--0x1D61FFFF */
+#define GPON_PE0_BASE		(KSEG1 | 0x1D610000)
+#define GPON_PE0_END		(KSEG1 | 0x1D61FFFF)
+#define GPON_PE0_SIZE		0x00010000
+/** address range for pe1
+    0x1D620000--0x1D62FFFF */
+#define GPON_PE1_BASE		(KSEG1 | 0x1D620000)
+#define GPON_PE1_END		(KSEG1 | 0x1D62FFFF)
+#define GPON_PE1_SIZE		0x00010000
+/** address range for pe2
+    0x1D630000--0x1D63FFFF */
+#define GPON_PE2_BASE		(KSEG1 | 0x1D630000)
+#define GPON_PE2_END		(KSEG1 | 0x1D63FFFF)
+#define GPON_PE2_SIZE		0x00010000
+/** address range for pe3
+    0x1D640000--0x1D64FFFF */
+#define GPON_PE3_BASE		(KSEG1 | 0x1D640000)
+#define GPON_PE3_END		(KSEG1 | 0x1D64FFFF)
+#define GPON_PE3_SIZE		0x00010000
+/** address range for pe4
+    0x1D650000--0x1D65FFFF */
+#define GPON_PE4_BASE		(KSEG1 | 0x1D650000)
+#define GPON_PE4_END		(KSEG1 | 0x1D65FFFF)
+#define GPON_PE4_SIZE		0x00010000
+/** address range for pe5
+    0x1D660000--0x1D66FFFF */
+#define GPON_PE5_BASE		(KSEG1 | 0x1D660000)
+#define GPON_PE5_END		(KSEG1 | 0x1D66FFFF)
+#define GPON_PE5_SIZE		0x00010000
+/** address range for sys_gpe
+    0x1D700000--0x1D7000FF */
+#define GPON_SYS_GPE_BASE		(KSEG1 | 0x1D700000)
+#define GPON_SYS_GPE_END		(KSEG1 | 0x1D7000FF)
+#define GPON_SYS_GPE_SIZE		0x00000100
+/** address range for eim
+    0x1D800000--0x1D800FFF */
+#define GPON_EIM_BASE		(KSEG1 | 0x1D800000)
+#define GPON_EIM_END		(KSEG1 | 0x1D800FFF)
+#define GPON_EIM_SIZE		0x00001000
+/** address range for sxgmii
+    0x1D808800--0x1D8088FF */
+#define GPON_SXGMII_BASE		(KSEG1 | 0x1D808800)
+#define GPON_SXGMII_END		(KSEG1 | 0x1D8088FF)
+#define GPON_SXGMII_SIZE		0x00000100
+/** address range for sgmii
+    0x1D808C00--0x1D808CFF */
+#define GPON_SGMII_BASE		(KSEG1 | 0x1D808C00)
+#define GPON_SGMII_END		(KSEG1 | 0x1D808CFF)
+#define GPON_SGMII_SIZE		0x00000100
+/** address range for gpio0
+    0x1D810000--0x1D81007F */
+#define GPON_GPIO0_BASE		(KSEG1 | 0x1D810000)
+#define GPON_GPIO0_END		(KSEG1 | 0x1D81007F)
+#define GPON_GPIO0_SIZE		0x00000080
+/** address range for gpio2
+    0x1D810100--0x1D81017F */
+#define GPON_GPIO2_BASE		(KSEG1 | 0x1D810100)
+#define GPON_GPIO2_END		(KSEG1 | 0x1D81017F)
+#define GPON_GPIO2_SIZE		0x00000080
+/** address range for sys_eth
+    0x1DB00000--0x1DB000FF */
+#define GPON_SYS_ETH_BASE		(KSEG1 | 0x1DB00000)
+#define GPON_SYS_ETH_END		(KSEG1 | 0x1DB000FF)
+#define GPON_SYS_ETH_SIZE		0x00000100
+/** address range for padctrl0
+    0x1DB01000--0x1DB010FF */
+#define GPON_PADCTRL0_BASE		(KSEG1 | 0x1DB01000)
+#define GPON_PADCTRL0_END		(KSEG1 | 0x1DB010FF)
+#define GPON_PADCTRL0_SIZE		0x00000100
+/** address range for padctrl2
+    0x1DB02000--0x1DB020FF */
+#define GPON_PADCTRL2_BASE		(KSEG1 | 0x1DB02000)
+#define GPON_PADCTRL2_END		(KSEG1 | 0x1DB020FF)
+#define GPON_PADCTRL2_SIZE		0x00000100
+/** address range for gtc
+    0x1DC05000--0x1DC052D4 */
+#define GPON_GTC_BASE		(KSEG1 | 0x1DC05000)
+#define GPON_GTC_END		(KSEG1 | 0x1DC052D4)
+#define GPON_GTC_SIZE		0x000002D5
+/** address range for pma
+    0x1DD00000--0x1DD003FF */
+#define GPON_PMA_BASE		(KSEG1 | 0x1DD00000)
+#define GPON_PMA_END		(KSEG1 | 0x1DD003FF)
+#define GPON_PMA_SIZE		0x00000400
+/** address range for fcsic
+    0x1DD00600--0x1DD0061F */
+#define GPON_FCSIC_BASE		(KSEG1 | 0x1DD00600)
+#define GPON_FCSIC_END		(KSEG1 | 0x1DD0061F)
+#define GPON_FCSIC_SIZE		0x00000020
+/** address range for pma_int200
+    0x1DD00700--0x1DD0070F */
+#define GPON_PMA_INT200_BASE		(KSEG1 | 0x1DD00700)
+#define GPON_PMA_INT200_END		(KSEG1 | 0x1DD0070F)
+#define GPON_PMA_INT200_SIZE		0x00000010
+/** address range for pma_inttx
+    0x1DD00720--0x1DD0072F */
+#define GPON_PMA_INTTX_BASE		(KSEG1 | 0x1DD00720)
+#define GPON_PMA_INTTX_END		(KSEG1 | 0x1DD0072F)
+#define GPON_PMA_INTTX_SIZE		0x00000010
+/** address range for pma_intrx
+    0x1DD00740--0x1DD0074F */
+#define GPON_PMA_INTRX_BASE		(KSEG1 | 0x1DD00740)
+#define GPON_PMA_INTRX_END		(KSEG1 | 0x1DD0074F)
+#define GPON_PMA_INTRX_SIZE		0x00000010
+/** address range for tod
+    0x1DEFFE00--0x1DEFFEFF */
+#define GPON_TOD_BASE		(KSEG1 | 0x1DEFFE00)
+#define GPON_TOD_END		(KSEG1 | 0x1DEFFEFF)
+#define GPON_TOD_SIZE		0x00000100
+/** address range for gtc_pma
+    0x1DEFFF00--0x1DEFFFFF */
+#define GPON_GTC_PMA_BASE		(KSEG1 | 0x1DEFFF00)
+#define GPON_GTC_PMA_END		(KSEG1 | 0x1DEFFFFF)
+#define GPON_GTC_PMA_SIZE		0x00000100
+/** address range for sys
+    0x1DF00000--0x1DF000FF */
+#define GPON_SYS_BASE		(KSEG1 | 0x1DF00000)
+#define GPON_SYS_END		(KSEG1 | 0x1DF000FF)
+#define GPON_SYS_SIZE		0x00000100
+/** address range for asc1
+    0x1E100B00--0x1E100BFF */
+#define GPON_ASC1_BASE		(KSEG1 | 0x1E100B00)
+#define GPON_ASC1_END		(KSEG1 | 0x1E100BFF)
+#define GPON_ASC1_SIZE		0x00000100
+/** address range for asc0
+    0x1E100C00--0x1E100CFF */
+#define GPON_ASC0_BASE		(KSEG1 | 0x1E100C00)
+#define GPON_ASC0_END		(KSEG1 | 0x1E100CFF)
+#define GPON_ASC0_SIZE		0x00000100
+/** address range for gptc
+    0x1E100E00--0x1E100EFF */
+#define GPON_GPTC_BASE		(KSEG1 | 0x1E100E00)
+#define GPON_GPTC_END		(KSEG1 | 0x1E100EFF)
+#define GPON_GPTC_SIZE		0x00000100
+/** address range for i2c
+    0x1E200000--0x1E20FFFF */
+#define GPON_I2C_BASE		(KSEG1 | 0x1E200000)
+#define GPON_I2C_END		(KSEG1 | 0x1E20FFFF)
+#define GPON_I2C_SIZE		0x00010000
+/** address range for gpio1
+    0x1E800100--0x1E80017F */
+#define GPON_GPIO1_BASE		(KSEG1 | 0x1E800100)
+#define GPON_GPIO1_END		(KSEG1 | 0x1E80017F)
+#define GPON_GPIO1_SIZE		0x00000080
+/** address range for gpio3
+    0x1E800200--0x1E80027F */
+#define GPON_GPIO3_BASE		(KSEG1 | 0x1E800200)
+#define GPON_GPIO3_END		(KSEG1 | 0x1E80027F)
+#define GPON_GPIO3_SIZE		0x00000080
+/** address range for gpio4
+    0x1E800300--0x1E80037F */
+#define GPON_GPIO4_BASE		(KSEG1 | 0x1E800300)
+#define GPON_GPIO4_END		(KSEG1 | 0x1E80037F)
+#define GPON_GPIO4_SIZE		0x00000080
+/** address range for padctrl1
+    0x1E800400--0x1E8004FF */
+#define GPON_PADCTRL1_BASE		(KSEG1 | 0x1E800400)
+#define GPON_PADCTRL1_END		(KSEG1 | 0x1E8004FF)
+#define GPON_PADCTRL1_SIZE		0x00000100
+/** address range for padctrl3
+    0x1E800500--0x1E8005FF */
+#define GPON_PADCTRL3_BASE		(KSEG1 | 0x1E800500)
+#define GPON_PADCTRL3_END		(KSEG1 | 0x1E8005FF)
+#define GPON_PADCTRL3_SIZE		0x00000100
+/** address range for padctrl4
+    0x1E800600--0x1E8006FF */
+#define GPON_PADCTRL4_BASE		(KSEG1 | 0x1E800600)
+#define GPON_PADCTRL4_END		(KSEG1 | 0x1E8006FF)
+#define GPON_PADCTRL4_SIZE		0x00000100
+/** address range for status
+    0x1E802000--0x1E80207F */
+#define GPON_STATUS_BASE		(KSEG1 | 0x1E802000)
+#define GPON_STATUS_END		(KSEG1 | 0x1E80207F)
+#define GPON_STATUS_SIZE		0x00000080
+/** address range for dcdc_core
+    0x1E803000--0x1E8033FF */
+#define GPON_DCDC_CORE_BASE		(KSEG1 | 0x1E803000)
+#define GPON_DCDC_CORE_END		(KSEG1 | 0x1E8033FF)
+#define GPON_DCDC_CORE_SIZE		0x00000400
+/** address range for dcdc_ddr
+    0x1E804000--0x1E8043FF */
+#define GPON_DCDC_DDR_BASE		(KSEG1 | 0x1E804000)
+#define GPON_DCDC_DDR_END		(KSEG1 | 0x1E8043FF)
+#define GPON_DCDC_DDR_SIZE		0x00000400
+/** address range for dcdc_apd
+    0x1E805000--0x1E8053FF */
+#define GPON_DCDC_APD_BASE		(KSEG1 | 0x1E805000)
+#define GPON_DCDC_APD_END		(KSEG1 | 0x1E8053FF)
+#define GPON_DCDC_APD_SIZE		0x00000400
+/** address range for sys1
+    0x1EF00000--0x1EF000FF */
+#define GPON_SYS1_BASE		(KSEG1 | 0x1EF00000)
+#define GPON_SYS1_END		(KSEG1 | 0x1EF000FF)
+#define GPON_SYS1_SIZE		0x00000100
+/** address range for sbs0ctrl
+    0x1F080000--0x1F0801FF */
+#define GPON_SBS0CTRL_BASE		(KSEG1 | 0x1F080000)
+#define GPON_SBS0CTRL_END		(KSEG1 | 0x1F0801FF)
+#define GPON_SBS0CTRL_SIZE		0x00000200
+/** address range for sbs0red
+    0x1F080200--0x1F08027F */
+#define GPON_SBS0RED_BASE		(KSEG1 | 0x1F080200)
+#define GPON_SBS0RED_END		(KSEG1 | 0x1F08027F)
+#define GPON_SBS0RED_SIZE		0x00000080
+/** address range for sbs0ram
+    0x1F200000--0x1F32FFFF */
+#define GPON_SBS0RAM_BASE		(KSEG1 | 0x1F200000)
+#define GPON_SBS0RAM_END		(KSEG1 | 0x1F32FFFF)
+#define GPON_SBS0RAM_SIZE		0x00130000
+/** address range for xbar
+    0x1F700000--0x1F700FFF */
+#define GPON_XBAR_BASE		(KSEG1 | 0x1F700000)
+#define GPON_XBAR_END		(KSEG1 | 0x1F700FFF)
+#define GPON_XBAR_SIZE		0x00001000
+/** address range for ddrdb
+    0x1F701000--0x1F701FFF */
+#define GPON_DDRDB_BASE		(KSEG1 | 0x1F701000)
+#define GPON_DDRDB_END		(KSEG1 | 0x1F701FFF)
+#define GPON_DDRDB_SIZE		0x00001000
+/** address range for sbiu
+    0x1F880000--0x1F8800FF */
+#define GPON_SBIU_BASE		(KSEG1 | 0x1F880000)
+#define GPON_SBIU_END		(KSEG1 | 0x1F8800FF)
+#define GPON_SBIU_SIZE		0x00000100
+/** address range for icu0
+    0x1F880200--0x1F8802DF */
+#define GPON_ICU0_BASE		(KSEG1 | 0x1F880200)
+#define GPON_ICU0_END		(KSEG1 | 0x1F8802DF)
+#define GPON_ICU0_SIZE		0x000000E0
+/** address range for icu1
+    0x1F880300--0x1F8803DF */
+#define GPON_ICU1_BASE		(KSEG1 | 0x1F880300)
+#define GPON_ICU1_END		(KSEG1 | 0x1F8803DF)
+#define GPON_ICU1_SIZE		0x000000E0
+/** address range for wdt
+    0x1F8803F0--0x1F8803FF */
+#define GPON_WDT_BASE		(KSEG1 | 0x1F8803F0)
+#define GPON_WDT_END		(KSEG1 | 0x1F8803FF)
+#define GPON_WDT_SIZE		0x00000010
+
+/*! @} */ /* GPON_BASE */
+
+#endif /* _gpon_reg_base_h */
+
diff --git a/arch/mips/include/asm/arch-falcon/hardware.h b/arch/mips/include/asm/arch-falcon/hardware.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/hardware.h
@@ -0,0 +1,119 @@
+/*
+ * (C) Copyright 2011
+ * Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __FALCON_HW_H
+#define __FALCON_HW_H
+
+#include <asm/arch/gpon_reg_base.h>
+#include <asm/arch/ebu_reg.h>
+#include <asm/arch/sys1_reg.h>
+#include <asm/arch/sys_eth_reg.h>
+#include <asm/arch/sys_gpe_reg.h>
+#include <asm/arch/status_reg.h>
+#include <asm/arch/xbar_reg.h>
+
+/* mapping to u-boot hw-accessor routines */
+#define reg_r32(reg) readl(reg)
+#define reg_w32(val, reg) writel(val, reg)
+#define reg_w32_mask(clear, set, reg) reg_w32((reg_r32(reg) & ~(clear)) | (set), reg)
+
+static struct gpon_reg_ebu * const ebu =
+	(struct gpon_reg_ebu *)GPON_EBU_BASE;
+static struct gpon_reg_sys1 * const sys1 =
+	(struct gpon_reg_sys1 *)GPON_SYS1_BASE;
+static struct gpon_reg_sys_eth * const sys_eth =
+	(struct gpon_reg_sys_eth *)GPON_SYS_ETH_BASE;
+static struct gpon_reg_sys_gpe * const sys_gpe =
+	(struct gpon_reg_sys_gpe *)GPON_SYS_GPE_BASE;
+static struct gpon_reg_status * const status =
+	(struct gpon_reg_status *)GPON_STATUS_BASE;
+static struct gpon_reg_xbar * const xbar =
+	(struct gpon_reg_xbar *)GPON_XBAR_BASE;
+
+static struct gpon_reg_boot {
+	/* bootrom related virtual registers */
+	unsigned int rvec;
+	unsigned int nvec;
+	unsigned int evec;
+	unsigned int cp0_status;
+	unsigned int cp0_epc;
+	unsigned int cp0_eepc;
+	unsigned int size;
+	unsigned int cfg_stat;
+	/* additional virtual registers */
+	unsigned int magic0; /* magic for valid reboot */
+	unsigned int magic1; /*  -"-  */
+	unsigned int bcount; /* reboot counter, used by u-boot */
+} * const boot_reg = (struct gpon_reg_boot *)GPON_SBS0RAM_BASE;
+
+#if defined(CONFIG_FALCON_A1x) && defined(CONFIG_FALCON_A2x)
+__attribute__((always_inline))
+static inline const int falcon_version(void)
+{
+	return (status->chipid & STATUS_CHIPID_VERSION_MASK)
+		>> STATUS_CHIPID_VERSION_OFFSET;
+}
+__attribute__((always_inline))
+static inline const int is_falcon_chip_a1x(void) { return falcon_version() == 1; }
+__attribute__((always_inline))
+static inline const int is_falcon_chip_a2x(void) { return falcon_version() == 2; }
+#else
+#ifdef CONFIG_FALCON_A2x
+static inline int is_falcon_chip_a1x(void) { return 0; }
+static inline int is_falcon_chip_a2x(void) { return 1; }
+#else
+static inline int is_falcon_chip_a1x(void) { return 1; }
+static inline int is_falcon_chip_a2x(void) { return 0; }
+#endif
+#endif
+
+#define FALCON_D	(1<<0)
+#define FALCON_V	(1<<1)
+#define FALCON_M	(1<<2)
+#define FALCON_S	(1<<3)
+
+__attribute__((always_inline))
+static inline u32 falcon_type(void)
+{
+	u32 fuse0 = status_r32(fuse0);
+	u32 fuse0_f0 = (fuse0 & STATUS_FUSE0_F0_MASK)
+		>> STATUS_FUSE0_F0_OFFSET;
+	return 1 << fuse0_f0;
+}
+
+__attribute__((always_inline))
+static inline int support_falcon_type(u32 type)
+{
+	return !!(falcon_type() & type);
+}
+
+#define IS_FALCON(func,def) \
+__attribute__((always_inline)) static inline int func(void) \
+				{ return support_falcon_type(def); }
+
+IS_FALCON(is_falcon_d,FALCON_D)
+IS_FALCON(is_falcon_v,FALCON_V)
+IS_FALCON(is_falcon_m,FALCON_M)
+IS_FALCON(is_falcon_s,FALCON_S)
+
+#endif /* __FALCON_HW_H */
diff --git a/arch/mips/include/asm/arch-falcon/status_reg.h b/arch/mips/include/asm/arch-falcon/status_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/status_reg.h
@@ -0,0 +1,612 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _status_reg_h
+#define _status_reg_h
+
+/** \addtogroup STATUS_REGISTER
+   @{
+*/
+/* access macros */
+#define status_r32(reg) reg_r32(&status->reg)
+#define status_w32(val, reg) reg_w32(val, &status->reg)
+#define status_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &status->reg)
+#define status_r32_table(reg, idx) reg_r32_table(status->reg, idx)
+#define status_w32_table(val, reg, idx) reg_w32_table(val, status->reg, idx)
+#define status_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, status->reg, idx)
+#define status_adr_table(reg, idx) adr_table(status->reg, idx)
+
+
+/** STATUS register structure */
+struct gpon_reg_status
+{
+   /** Reserved */
+   unsigned int res_0[3]; /* 0x00000000 */
+   /** Chip Identification Register */
+   unsigned int chipid; /* 0x0000000C */
+   /** Chip Location Register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int chiploc; /* 0x00000010 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red0; /* 0x00000014 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red1; /* 0x00000018 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red2; /* 0x0000001C */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red3; /* 0x00000020 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red4; /* 0x00000024 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red5; /* 0x00000028 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red6; /* 0x0000002C */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red7; /* 0x00000030 */
+   /** Redundancy register
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int red8; /* 0x00000034 */
+   /** SPARE fuse register 0
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int fuse0; /* 0x00000038 */
+   /** Fuses for Analog modules
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int analog; /* 0x0000003C */
+   /** Configuration fuses for drivers and pll
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int config; /* 0x00000040 */
+   /** SPARE fuse register 1
+       Note: All fuse-bits have a default value of 0 that can be changed to 1 during production test (unfused = 0, fused = 1).The reset-values stated for these bits is 0 even though SW will never be able to read 0 if it was set to 1 during production test. */
+   unsigned int fuse1; /* 0x00000044 */
+   /** Configuration for sbs0 rambist */
+   unsigned int mbcfg; /* 0x00000048 */
+   /** sbs0 bist result and debug data */
+   unsigned int mbdata; /* 0x0000004C */
+   /** Reserved */
+   unsigned int res_1[12]; /* 0x00000050 */
+};
+
+
+/* Fields of "Chip Identification Register" */
+/** Chip Version Number
+    Version number is a constant field and can be changed by Redesign only. The chip version is coded by 3 characters XvY while v is the version, X = A,B,C and Y = 1,2,3 they will be coded in the CONFIG register field SUBVERS). */
+#define STATUS_CHIPID_VERSION_MASK 0xF0000000
+/** field offset */
+#define STATUS_CHIPID_VERSION_OFFSET 28
+/** Part Number, Constant Part
+    The Part Number is fixed to 016Bhex. */
+#define STATUS_CHIPID_PARTNR_MASK 0x0FFFF000
+/** field offset */
+#define STATUS_CHIPID_PARTNR_OFFSET 12
+/** Manufacturer ID
+    The value of bit field MANID is fixed to 41hex as configured in the JTAG ID register. The JEDEC normalized manufacturer code for Infineon Technologies is C1hex */
+#define STATUS_CHIPID_MANID_MASK 0x00000FFE
+/** field offset */
+#define STATUS_CHIPID_MANID_OFFSET 1
+/** Constant bit
+    The value of bit field CONST1 is fixed to 1hex */
+#define STATUS_CHIPID_CONST1 0x00000001
+
+/* Fields of "Chip Location Register" */
+/** Chip Lot ID */
+#define STATUS_CHIPLOC_CHIPLOT_MASK 0xFFFF0000
+/** field offset */
+#define STATUS_CHIPLOC_CHIPLOT_OFFSET 16
+/** Chip X Coordinate */
+#define STATUS_CHIPLOC_CHIPX_MASK 0x0000FF00
+/** field offset */
+#define STATUS_CHIPLOC_CHIPX_OFFSET 8
+/** Chip Y Coordinate */
+#define STATUS_CHIPLOC_CHIPY_MASK 0x000000FF
+/** field offset */
+#define STATUS_CHIPLOC_CHIPY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED0_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED0_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED1_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED1_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED2_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED2_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED3_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED3_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED4_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED4_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED5_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED5_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED6_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED6_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED7_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED7_REDUNDANCY_OFFSET 0
+
+/* Fields of "Redundancy register" */
+/** Redundancy
+    redundancy information stored in eFuses. MSB + MEM_ADDR - MSB = 1 defines a valid address */
+#define STATUS_RED8_REDUNDANCY_MASK 0x0003FFFF
+/** field offset */
+#define STATUS_RED8_REDUNDANCY_OFFSET 0
+
+/* Fields of "SPARE fuse register 0" */
+/** Soft fuse control
+    Controls whether the status block is in its softfused state or not. In the softfused state the values written via software are active effective. */
+#define STATUS_FUSE0_SFC 0x80000000
+/* Not selected
+#define STATUS_FUSE0_SFC_NSEL 0x00000000 */
+/** Selected */
+#define STATUS_FUSE0_SFC_SEL 0x80000000
+/** Soft control MBCFG
+    Controls whether mbist configuration can be overwritten or not from subsystem. If not selected jtag mbcfg register is source for software mbist configuration */
+#define STATUS_FUSE0_SC_MBCFG 0x40000000
+/* Not selected
+#define STATUS_FUSE0_SC_MBCFG_NSEL 0x00000000 */
+/** Selected */
+#define STATUS_FUSE0_SC_MBCFG_SEL 0x40000000
+/** Device Type
+    different device types are coded in this fuse field */
+#define STATUS_FUSE0_F0_MASK 0x3C000000
+/** field offset */
+#define STATUS_FUSE0_F0_OFFSET 26
+/** FALCOND */
+#define STATUS_FUSE0_F0_FALCOND 0x00000000
+/** FALCONV */
+#define STATUS_FUSE0_F0_FALCONV 0x04000000
+/** FALCONM */
+#define STATUS_FUSE0_F0_FALCONM 0x08000000
+/** SFP */
+#define STATUS_FUSE0_F0_FALCONS 0x0C000000
+/** all other codes reserved for future applications */
+#define STATUS_FUSE0_F0_reserved 0x10000000
+/** VCALMM20 Voltage Reference
+    Voltage Reference for calibration via R and constant current (20 uA) */
+#define STATUS_FUSE0_VCALMM20_MASK 0x03F00000
+/** field offset */
+#define STATUS_FUSE0_VCALMM20_OFFSET 20
+/** VCALMM100 Voltage Reference
+    Voltage Reference for calibration via R and constant current (100 uA) */
+#define STATUS_FUSE0_VCALMM100_MASK 0x000FC000
+/** field offset */
+#define STATUS_FUSE0_VCALMM100_OFFSET 14
+/** VCALMM400 Voltage Reference
+    Voltage Reference for calibration via R and constant current (400 uA) */
+#define STATUS_FUSE0_VCALMM400_MASK 0x00003F00
+/** field offset */
+#define STATUS_FUSE0_VCALMM400_OFFSET 8
+/** RCALMM R error correction
+    The resistance deviation from ideal R (1000 Ohm) */
+#define STATUS_FUSE0_RCALMM_MASK 0x000000FF
+/** field offset */
+#define STATUS_FUSE0_RCALMM_OFFSET 0
+
+/* Fields of "Fuses for Analog modules" */
+/** Status of written FUSES
+    Defines which Fuses are activated */
+#define STATUS_ANALOG_FS_MASK 0xE0000000
+/** field offset */
+#define STATUS_ANALOG_FS_OFFSET 29
+/** A11 format, only VBGP and IREFBGP fused, DRIVE and BIAS DAC - 4 bit */
+#define STATUS_ANALOG_FS_FS0 0x00000000
+/** new format, VBGP, IREFBGP, DRIVE dac (5bit) and BIAS dac (5bit) fused */
+#define STATUS_ANALOG_FS_FS1 0x20000000
+/** All other codes reserved for future applications */
+#define STATUS_ANALOG_FS_FS2 0x40000000
+/** reserved Analog eFuses
+    Reserved Register contains information stored in eFuses needed for the analog modules */
+#define STATUS_ANALOG_A0_MASK 0x1C000000
+/** field offset */
+#define STATUS_ANALOG_A0_OFFSET 26
+/** Absolut Temperature
+    Temperature ERROR */
+#define STATUS_ANALOG_TEMPMM_MASK 0x03F00000
+/** field offset */
+#define STATUS_ANALOG_TEMPMM_OFFSET 20
+/** Drive DAC Gain */
+#define STATUS_ANALOG_GAINDRIVEDAC_MASK 0x000F8000
+/** field offset */
+#define STATUS_ANALOG_GAINDRIVEDAC_OFFSET 15
+/** Bias Voltage Generation
+    voltage dependency */
+#define STATUS_ANALOG_VBGP_MASK 0x00007000
+/** field offset */
+#define STATUS_ANALOG_VBGP_OFFSET 12
+/** Bias Current Generation */
+#define STATUS_ANALOG_IREFBGP_MASK 0x00000F00
+/** field offset */
+#define STATUS_ANALOG_IREFBGP_OFFSET 8
+/** Bias Voltage Generation
+    temperature dependency */
+#define STATUS_ANALOG_TBGP_MASK 0x000000E0
+/** field offset */
+#define STATUS_ANALOG_TBGP_OFFSET 5
+/** BIAS DAC Gain */
+#define STATUS_ANALOG_GAINBIASDAC_MASK 0x0000001F
+/** field offset */
+#define STATUS_ANALOG_GAINBIASDAC_OFFSET 0
+
+/* Fields of "Configuration fuses for drivers and pll" */
+/** ddr PU driver
+    ddr pullup driver strength adjustment */
+#define STATUS_CONFIG_DDRPU_MASK 0xC0000000
+/** field offset */
+#define STATUS_CONFIG_DDRPU_OFFSET 30
+/** ddr PD driver
+    ddr pulldown driver strength adjustment */
+#define STATUS_CONFIG_DDRPD_MASK 0x30000000
+/** field offset */
+#define STATUS_CONFIG_DDRPD_OFFSET 28
+/** Authentification Unit enable
+    This bit can only be set via eFuse and enables the authentification unit. */
+#define STATUS_CONFIG_SHA1EN 0x08000000
+/* Not selected
+#define STATUS_CONFIG_SHA1EN_NSEL 0x00000000 */
+/** Selected */
+#define STATUS_CONFIG_SHA1EN_SEL 0x08000000
+/** Encryption Unit enable
+    This bit can only be set via eFuse and enables the encryption unit. */
+#define STATUS_CONFIG_AESEN 0x04000000
+/* Not selected
+#define STATUS_CONFIG_AESEN_NSEL 0x00000000 */
+/** Selected */
+#define STATUS_CONFIG_AESEN_SEL 0x04000000
+/** Subversion Number
+    The subversion number has no direct effect on hardware functions. It is used to provide another chip version number that is fixed in hardware and can be read out by software. The chip version is coded by 3 characters XvY; while v is the version coded in CHIPID Register field VERSION. Following codes are defined: */
+#define STATUS_CONFIG_SUBVERS_MASK 0x03C00000
+/** field offset */
+#define STATUS_CONFIG_SUBVERS_OFFSET 22
+/** 1. Design Version */
+#define STATUS_CONFIG_SUBVERS_Av1 0x00000000
+/** Av2 */
+#define STATUS_CONFIG_SUBVERS_Av2 0x00400000
+/** Av3 */
+#define STATUS_CONFIG_SUBVERS_Av3 0x00800000
+/** Av4 */
+#define STATUS_CONFIG_SUBVERS_Av4 0x00C00000
+/** Bv1 */
+#define STATUS_CONFIG_SUBVERS_Bv1 0x01000000
+/** PLL settings
+    PLL settings for infrastructure block */
+#define STATUS_CONFIG_PLLINFRA_MASK 0x003FF000
+/** field offset */
+#define STATUS_CONFIG_PLLINFRA_OFFSET 12
+/** GPE frequency selection
+    frequency selection of the GPE primary clock. 00 = 769.2MHz, 01 = 625MHz, 10 = 555.6MHz, 11 = 500MHz */
+#define STATUS_CONFIG_GPEFREQ_MASK 0x00000C00
+/** field offset */
+#define STATUS_CONFIG_GPEFREQ_OFFSET 10
+/** RM enable
+    Activates the Read Margin Settings defined in the RM Field, for all VIRAGE Memories except GPE */
+#define STATUS_CONFIG_RME 0x00000200
+/* Not selected
+#define STATUS_CONFIG_RME_NSEL 0x00000000 */
+/** Selected */
+#define STATUS_CONFIG_RME_SEL 0x00000200
+/** RM settings
+    Read Marging Settings for all VIRAGE Memories except GPE */
+#define STATUS_CONFIG_RM_MASK 0x000001E0
+/** field offset */
+#define STATUS_CONFIG_RM_OFFSET 5
+/** RM enable for GPE Memories
+    Activates the Read Margin Settings defined in the RM Field */
+#define STATUS_CONFIG_RMEGPE 0x00000010
+/* Not selected
+#define STATUS_CONFIG_RMEGPE_NSEL 0x00000000 */
+/** Selected */
+#define STATUS_CONFIG_RMEGPE_SEL 0x00000010
+/** RM settings for GPE Memories
+    Read Marging Settings for VIRAGE Memories in GPE module */
+#define STATUS_CONFIG_RMGPE_MASK 0x0000000F
+/** field offset */
+#define STATUS_CONFIG_RMGPE_OFFSET 0
+
+/* Fields of "SPARE fuse register 1" */
+/** spare fuse1
+    eFuses not assigned to hw/sw, at the moment reserved for TE */
+#define STATUS_FUSE1_F1_MASK 0xFFF00000
+/** field offset */
+#define STATUS_FUSE1_F1_OFFSET 20
+/** FREE_1
+    used for future application */
+#define STATUS_FUSE1_FR1_MASK 0x000F0000
+/** field offset */
+#define STATUS_FUSE1_FR1_OFFSET 16
+/** DCDC 1V0 OFFSET
+    offset error sense path */
+#define STATUS_FUSE1_OFFSET1V0DCDC_MASK 0x0000F800
+/** field offset */
+#define STATUS_FUSE1_OFFSET1V0DCDC_OFFSET 11
+/** DCDC APD OFFSET
+    offset error sense path */
+#define STATUS_FUSE1_OFFSETAPDDCDC_MASK 0x000007C0
+/** field offset */
+#define STATUS_FUSE1_OFFSETAPDDCDC_OFFSET 6
+/** DCDC APD GAIN
+    gain error sense path */
+#define STATUS_FUSE1_GAINAPDDCDC_MASK 0x0000003F
+/** field offset */
+#define STATUS_FUSE1_GAINAPDDCDC_OFFSET 0
+
+/* Fields of "Configuration for sbs0 rambist" */
+/** do not use only for debugging on testsystem
+    the GPE SW bist will be shorten to 32 memory locations when it would be enabled by bootmode config */
+#define STATUS_MBCFG_MB_DBG 0x02000000
+/* Disable
+#define STATUS_MBCFG_MB_DBG_DIS 0x00000000 */
+/** Enable */
+#define STATUS_MBCFG_MB_DBG_EN 0x02000000
+/** Disable asc monitoring during boot-up
+    Bit is used to avoid asc output for reducing pattern count on testsystem */
+#define STATUS_MBCFG_ASC_DBGDIS 0x01000000
+/* Disable
+#define STATUS_MBCFG_ASC_DBGDIS_DIS 0x00000000 */
+/** Enable */
+#define STATUS_MBCFG_ASC_DBGDIS_EN 0x01000000
+/** Descrambling Enable/Disable
+    Enables Address and Data Descrambling for internal Memory Test */
+#define STATUS_MBCFG_DSC 0x00800000
+/* Disable
+#define STATUS_MBCFG_DSC_DIS 0x00000000 */
+/** Enable */
+#define STATUS_MBCFG_DSC_EN 0x00800000
+/** Enable repair mode
+    When bit is set redundancy repair mode is activated */
+#define STATUS_MBCFG_REPAIR 0x00400000
+/* Disable
+#define STATUS_MBCFG_REPAIR_DIS 0x00000000 */
+/** Enable */
+#define STATUS_MBCFG_REPAIR_EN 0x00400000
+/** DEBUG Mode */
+#define STATUS_MBCFG_DBG 0x00200000
+/* Disable
+#define STATUS_MBCFG_DBG_DIS 0x00000000 */
+/** Enable */
+#define STATUS_MBCFG_DBG_EN 0x00200000
+/** Retention Time
+    Length oft the Retention Time */
+#define STATUS_MBCFG_RTIME_MASK 0x001C0000
+/** field offset */
+#define STATUS_MBCFG_RTIME_OFFSET 18
+/** retention mode is switched off */
+#define STATUS_MBCFG_RTIME_RET0 0x00000000
+/** Retention time 50 ms */
+#define STATUS_MBCFG_RTIME_RET50 0x00040000
+/** Retention time 60 ms */
+#define STATUS_MBCFG_RTIME_RET60 0x00080000
+/** Retention time 70 ms */
+#define STATUS_MBCFG_RTIME_RET70 0x000C0000
+/** Retention time 80 ms */
+#define STATUS_MBCFG_RTIME_RET80 0x00100000
+/** Retention time 90 ms */
+#define STATUS_MBCFG_RTIME_RET90 0x00140000
+/** Retention time 1000 ms */
+#define STATUS_MBCFG_RTIME_RET1000 0x00180000
+/** Test ID
+    Defines the test to execute. In which order the tests are executed can be defined via TID_n (TID_1 1st execution, TID_2 2nd execution ..) */
+#define STATUS_MBCFG_TID_5_MASK 0x00038000
+/** field offset */
+#define STATUS_MBCFG_TID_5_OFFSET 15
+/** No test is performed */
+#define STATUS_MBCFG_TID_5_NONE 0x00000000
+/** March test */
+#define STATUS_MBCFG_TID_5_MARCH 0x00008000
+/** Checkerboard test */
+#define STATUS_MBCFG_TID_5_CHCK 0x00010000
+/** Hammer test */
+#define STATUS_MBCFG_TID_5_HAM 0x00018000
+/** Address decoder test */
+#define STATUS_MBCFG_TID_5_ADEC 0x00020000
+/** Write mask byte test */
+#define STATUS_MBCFG_TID_5_WMBYTE 0x00028000
+/** Reserved */
+#define STATUS_MBCFG_TID_5_RES 0x00030000
+/** Test ID
+    Defines the test to execute. In which order the tests are executed can be defined via TID_n (TID_1 1st execution, TID_2 2nd execution ..) */
+#define STATUS_MBCFG_TID_4_MASK 0x00007000
+/** field offset */
+#define STATUS_MBCFG_TID_4_OFFSET 12
+/** No test is performed */
+#define STATUS_MBCFG_TID_4_NONE 0x00000000
+/** March test */
+#define STATUS_MBCFG_TID_4_MARCH 0x00001000
+/** Checkerboard test */
+#define STATUS_MBCFG_TID_4_CHCK 0x00002000
+/** Hammer test */
+#define STATUS_MBCFG_TID_4_HAM 0x00003000
+/** Address decoder test */
+#define STATUS_MBCFG_TID_4_ADEC 0x00004000
+/** Write mask byte test */
+#define STATUS_MBCFG_TID_4_WMBYTE 0x00005000
+/** Reserved */
+#define STATUS_MBCFG_TID_4_RES 0x00006000
+/** Test ID
+    Defines the test to execute. In which order the tests are executed can be defined via TID_n (TID_1 1st execution, TID_2 2nd execution ..) */
+#define STATUS_MBCFG_TID_3_MASK 0x00000E00
+/** field offset */
+#define STATUS_MBCFG_TID_3_OFFSET 9
+/** No test is performed */
+#define STATUS_MBCFG_TID_3_NONE 0x00000000
+/** March test */
+#define STATUS_MBCFG_TID_3_MARCH 0x00000200
+/** Checkerboard test */
+#define STATUS_MBCFG_TID_3_CHCK 0x00000400
+/** Hammer test */
+#define STATUS_MBCFG_TID_3_HAM 0x00000600
+/** Address decoder test */
+#define STATUS_MBCFG_TID_3_ADEC 0x00000800
+/** Write mask byte test */
+#define STATUS_MBCFG_TID_3_WMBYTE 0x00000A00
+/** Reserved */
+#define STATUS_MBCFG_TID_3_RES 0x00000C00
+/** Test ID
+    Defines the test to execute. In which order the tests are executed can be defined via TID_n (TID_1 1st execution, TID_2 2nd execution ..) */
+#define STATUS_MBCFG_TID_2_MASK 0x000001C0
+/** field offset */
+#define STATUS_MBCFG_TID_2_OFFSET 6
+/** No test is performed */
+#define STATUS_MBCFG_TID_2_NONE 0x00000000
+/** March test */
+#define STATUS_MBCFG_TID_2_MARCH 0x00000040
+/** Checkerboard test */
+#define STATUS_MBCFG_TID_2_CHCK 0x00000080
+/** Hammer test */
+#define STATUS_MBCFG_TID_2_HAM 0x000000C0
+/** Address decoder test */
+#define STATUS_MBCFG_TID_2_ADEC 0x00000100
+/** Write mask byte test */
+#define STATUS_MBCFG_TID_2_WMBYTE 0x00000140
+/** Reserved */
+#define STATUS_MBCFG_TID_2_RES 0x00000180
+/** Test ID
+    Defines the test to execute. In which order the tests are executed can be defined via TID_n (TID_1 1st execution, TID_2 2nd execution ..) */
+#define STATUS_MBCFG_TID_1_MASK 0x00000038
+/** field offset */
+#define STATUS_MBCFG_TID_1_OFFSET 3
+/** No test is performed */
+#define STATUS_MBCFG_TID_1_NONE 0x00000000
+/** March test */
+#define STATUS_MBCFG_TID_1_MARCH 0x00000008
+/** Checkerboard test */
+#define STATUS_MBCFG_TID_1_CHCK 0x00000010
+/** Hammer test */
+#define STATUS_MBCFG_TID_1_HAM 0x00000018
+/** Address decoder test */
+#define STATUS_MBCFG_TID_1_ADEC 0x00000020
+/** Write mask byte test */
+#define STATUS_MBCFG_TID_1_WMBYTE 0x00000028
+/** Reserved */
+#define STATUS_MBCFG_TID_1_RES 0x00000030
+/** Test ID
+    Defines the test to execute. In which order the tests are executed can be defined via TID_n (TID_1 1st execution, TID_2 2nd execution ..) */
+#define STATUS_MBCFG_TID_0_MASK 0x00000007
+/** field offset */
+#define STATUS_MBCFG_TID_0_OFFSET 0
+/** No test is performed */
+#define STATUS_MBCFG_TID_0_NONE 0x00000000
+/** March test */
+#define STATUS_MBCFG_TID_0_MARCH 0x00000001
+/** Checkerboard test */
+#define STATUS_MBCFG_TID_0_CHCK 0x00000002
+/** Hammer test */
+#define STATUS_MBCFG_TID_0_HAM 0x00000003
+/** Address decoder test */
+#define STATUS_MBCFG_TID_0_ADEC 0x00000004
+/** Write mask byte test */
+#define STATUS_MBCFG_TID_0_WMBYTE 0x00000005
+/** Reserved */
+#define STATUS_MBCFG_TID_0_RES 0x00000006
+
+/* Fields of "sbs0 bist result and debug data" */
+/** BIST result and debug data
+    Stores additional debug information */
+#define STATUS_MBDATA_DATA_MASK 0xFFFC0000
+/** field offset */
+#define STATUS_MBDATA_DATA_OFFSET 18
+/** MBIST NOGO
+    The BIST failed and cannot be repaired due to many failure locations, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_5_NOGO 0x00020000
+/** MBIST FAILED
+    The BIST failed but can be repaired, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_5_FAIL 0x00010000
+/** MBIST PASSED
+    The BIST passed without any Failures, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_5_PASS 0x00008000
+/** MBIST NOGO
+    The BIST failed and cannot be repaired due to many failure locations, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_4_NOGO 0x00004000
+/** MBIST FAILED
+    The BIST failed but can be repaired, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_4_FAIL 0x00002000
+/** MBIST PASSED
+    The BIST passed without any Failures, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_4_PASS 0x00001000
+/** MBIST NOGO
+    The BIST failed and cannot be repaired due to many failure locations, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_3_NOGO 0x00000800
+/** MBIST FAILED
+    The BIST failed but can be repaired, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_3_FAIL 0x00000400
+/** MBIST PASSED
+    The BIST passed without any Failures, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_3_PASS 0x00000200
+/** MBIST NOGO
+    The BIST failed and cannot be repaired due to many failure locations, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_2_NOGO 0x00000100
+/** MBIST FAILED
+    The BIST failed but can be repaired, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_2_FAIL 0x00000080
+/** MBIST PASSED
+    The BIST passed without any Failures, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_2_PASS 0x00000040
+/** MBIST NOGO
+    The BIST failed and cannot be repaired due to many failure locations, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_1_NOGO 0x00000020
+/** MBIST FAILED
+    The BIST failed but can be repaired, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_1_FAIL 0x00000010
+/** MBIST PASSED
+    The BIST passed without any Failures, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_1_PASS 0x00000008
+/** MBIST NOGO
+    The BIST failed and cannot be repaired due to many failure locations, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_0_NOGO 0x00000004
+/** MBIST FAILED
+    The BIST failed but can be repaired, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_0_FAIL 0x00000002
+/** MBIST PASSED
+    The BIST passed without any Failures, depends on the TID setting in the MBCFG register this bit will be set or not */
+#define STATUS_MBDATA_TID_0_PASS 0x00000001
+
+/*! @} */ /* STATUS_REGISTER */
+
+#endif /* _status_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/sys1_reg.h b/arch/mips/include/asm/arch-falcon/sys1_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/sys1_reg.h
@@ -0,0 +1,2026 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _sys1_reg_h
+#define _sys1_reg_h
+
+/** \addtogroup SYS1_REGISTER
+   @{
+*/
+/* access macros */
+#define sys1_r32(reg) reg_r32(&sys1->reg)
+#define sys1_w32(val, reg) reg_w32(val, &sys1->reg)
+#define sys1_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &sys1->reg)
+#define sys1_r32_table(reg, idx) reg_r32_table(sys1->reg, idx)
+#define sys1_w32_table(val, reg, idx) reg_w32_table(val, sys1->reg, idx)
+#define sys1_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, sys1->reg, idx)
+#define sys1_adr_table(reg, idx) adr_table(sys1->reg, idx)
+
+
+/** SYS1 register structure */
+struct gpon_reg_sys1
+{
+   /** Clock Status Register
+       Shows the clock enable bits for the domains. */
+   unsigned int clks; /* 0x00000000 */
+   /** Clock Enable Register
+       Via this register the clock enable bits for the domains can be set. */
+   unsigned int clken; /* 0x00000004 */
+   /** Clock Clear Register
+       Via this register the clock enable bits for the domains can be cleared. */
+   unsigned int clkclr; /* 0x00000008 */
+   /** Reserved */
+   unsigned int res_0[5]; /* 0x0000000C */
+   /** Activation Status Register
+       Shows the activation bits for the domains. */
+   unsigned int acts; /* 0x00000020 */
+   /** Activation Register
+       Via this register the activation bits for the domains can be set. */
+   unsigned int act; /* 0x00000024 */
+   /** Deactivation Register
+       Via this register the activation bits for the domains can be cleared. The clock to a deactivated domain is switched off regardless of the value of the clock enable bit, as it does not make sense to provide a clock to a domain in reset state. */
+   unsigned int deact; /* 0x00000028 */
+   /** Reboot Trigger Register
+       Via this register a reboot of the domains can be triggered. The selected domains are sent through reset. */
+   unsigned int rbt; /* 0x0000002C */
+   /** Reserved */
+   unsigned int res_1[4]; /* 0x00000030 */
+   /** CPU0 Clock Control Register
+       Clock control register for CPU0 */
+   unsigned int cpu0cc; /* 0x00000040 */
+   /** Reserved */
+   unsigned int res_2[7]; /* 0x00000044 */
+   /** CPU0 Reset Source Register
+       Via this register the CPU can find the root cause for the boot it currently goes through, and take the appropriate measures. */
+   unsigned int cpu0rs; /* 0x00000060 */
+   /** Reserved */
+   unsigned int res_3[7]; /* 0x00000064 */
+   /** CPU0 Wakeup Configuration Register
+       Controls the wakeup condition for CPU0. Note: The upper 16 bit of this register have to be set to the same value as the mask bits within the yield-resume interface block. If the yield-resume interface is not used at all, set the upper 16 bit to 0. */
+   unsigned int cpu0wcfg; /* 0x00000080 */
+   /** Reserved */
+   unsigned int res_4[7]; /* 0x00000084 */
+   /** Bootmode Control Register
+       Reflects the bootmode for the CPU and provides means to manipulate it. */
+   unsigned int bmc; /* 0x000000A0 */
+   /** Reserved */
+   unsigned int res_5[3]; /* 0x000000A4 */
+   /** Sleep Configuration Register */
+   unsigned int scfg; /* 0x000000B0 */
+   /** Power Down Configuration Register
+       Via this register the configuration is done whether in case of deactivation the power supply of the domain shall be switched off. */
+   unsigned int pdcfg; /* 0x000000B4 */
+   /** CLKO Pad Control Register
+       Controls the behaviour of the CLKO pad/ball. */
+   unsigned int clkoc; /* 0x000000B8 */
+   /** Infrastructure Control Register
+       Controls the behaviour of the components of the infrastructure block. */
+   unsigned int infrac; /* 0x000000BC */
+   /** HRST_OUT_N Control Register
+       Controls the behaviour of the HRST_OUT_N pin. */
+   unsigned int hrstoutc; /* 0x000000C0 */
+   /** EBU Clock Control Register
+       Clock control register for the EBU. */
+   unsigned int ebucc; /* 0x000000C4 */
+   /** Hardware Reset Control Register
+       A hardware like reset of the entire chip can be triggered here. */
+   unsigned int hrstc; /* 0x000000C8 */
+   /** Reserved */
+   unsigned int res_6; /* 0x000000CC */
+   /** NMI Status Register
+       The Test NMI source is the GPTC counter 1A overflow bit. */
+   unsigned int nmis; /* 0x000000D0 */
+   /** NMI Set Register */
+   unsigned int nmiset; /* 0x000000D4 */
+   /** NMI Clear Register */
+   unsigned int nmiclr; /* 0x000000D8 */
+   /** NMI Test Configuration Register */
+   unsigned int nmitcfg; /* 0x000000DC */
+   /** NMI VPE1 Control Register */
+   unsigned int nmivpe1c; /* 0x000000E0 */
+   /** Reserved */
+   unsigned int res_7[3]; /* 0x000000E4 */
+   /** IRN Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncr; /* 0x000000F0 */
+   /** IRN Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irnicr; /* 0x000000F4 */
+   /** IRN Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irnen; /* 0x000000F8 */
+   /** Reserved */
+   unsigned int res_8; /* 0x000000FC */
+};
+
+
+/* Fields of "Clock Status Register" */
+/** STATUS Clock Enable
+    This domain contains the STATUS block. */
+#define CLKS_STATUS 0x80000000
+/* Disable
+#define CLKS_STATUS_DIS 0x00000000 */
+/** Enable */
+#define CLKS_STATUS_EN 0x80000000
+/** SHA1 Clock Enable
+    This domain contains the SHA1 block. */
+#define CLKS_SHA1 0x40000000
+/* Disable
+#define CLKS_SHA1_DIS 0x00000000 */
+/** Enable */
+#define CLKS_SHA1_EN 0x40000000
+/** AES Clock Enable
+    This domain contains the AES block. */
+#define CLKS_AES 0x20000000
+/* Disable
+#define CLKS_AES_DIS 0x00000000 */
+/** Enable */
+#define CLKS_AES_EN 0x20000000
+/** PCM Clock Enable
+    This domain contains the PCM interface block. */
+#define CLKS_PCM 0x10000000
+/* Disable
+#define CLKS_PCM_DIS 0x00000000 */
+/** Enable */
+#define CLKS_PCM_EN 0x10000000
+/** FSCT Clock Enable
+    This domain contains the FSCT block. */
+#define CLKS_FSCT 0x08000000
+/* Disable
+#define CLKS_FSCT_DIS 0x00000000 */
+/** Enable */
+#define CLKS_FSCT_EN 0x08000000
+/** GPTC Clock Enable
+    This domain contains the GPTC block. */
+#define CLKS_GPTC 0x04000000
+/* Disable
+#define CLKS_GPTC_DIS 0x00000000 */
+/** Enable */
+#define CLKS_GPTC_EN 0x04000000
+/** MPS Clock Enable
+    This domain contains the MPS block. */
+#define CLKS_MPS 0x02000000
+/* Disable
+#define CLKS_MPS_DIS 0x00000000 */
+/** Enable */
+#define CLKS_MPS_EN 0x02000000
+/** DFEV0 Clock Enable
+    This domain contains the DFEV0 block. */
+#define CLKS_DFEV0 0x01000000
+/* Disable
+#define CLKS_DFEV0_DIS 0x00000000 */
+/** Enable */
+#define CLKS_DFEV0_EN 0x01000000
+/** PADCTRL4 Clock Enable
+    This domain contains the PADCTRL4 block. */
+#define CLKS_PADCTRL4 0x00400000
+/* Disable
+#define CLKS_PADCTRL4_DIS 0x00000000 */
+/** Enable */
+#define CLKS_PADCTRL4_EN 0x00400000
+/** PADCTRL3 Clock Enable
+    This domain contains the PADCTRL3 block. */
+#define CLKS_PADCTRL3 0x00200000
+/* Disable
+#define CLKS_PADCTRL3_DIS 0x00000000 */
+/** Enable */
+#define CLKS_PADCTRL3_EN 0x00200000
+/** PADCTRL1 Clock Enable
+    This domain contains the PADCTRL1 block. */
+#define CLKS_PADCTRL1 0x00100000
+/* Disable
+#define CLKS_PADCTRL1_DIS 0x00000000 */
+/** Enable */
+#define CLKS_PADCTRL1_EN 0x00100000
+/** P4 Clock Enable
+    This domain contains the P4 instance of the GPIO block. */
+#define CLKS_P4 0x00040000
+/* Disable
+#define CLKS_P4_DIS 0x00000000 */
+/** Enable */
+#define CLKS_P4_EN 0x00040000
+/** P3 Clock Enable
+    This domain contains the P3 instance of the GPIO block. */
+#define CLKS_P3 0x00020000
+/* Disable
+#define CLKS_P3_DIS 0x00000000 */
+/** Enable */
+#define CLKS_P3_EN 0x00020000
+/** P1 Clock Enable
+    This domain contains the P1 instance of the GPIO block. */
+#define CLKS_P1 0x00010000
+/* Disable
+#define CLKS_P1_DIS 0x00000000 */
+/** Enable */
+#define CLKS_P1_EN 0x00010000
+/** HOST Clock Enable
+    This domain contains the HOST interface block. */
+#define CLKS_HOST 0x00008000
+/* Disable
+#define CLKS_HOST_DIS 0x00000000 */
+/** Enable */
+#define CLKS_HOST_EN 0x00008000
+/** I2C Clock Enable
+    This domain contains the I2C interface block. */
+#define CLKS_I2C 0x00004000
+/* Disable
+#define CLKS_I2C_DIS 0x00000000 */
+/** Enable */
+#define CLKS_I2C_EN 0x00004000
+/** SSC0 Clock Enable
+    This domain contains the SSC0 interface block. */
+#define CLKS_SSC0 0x00002000
+/* Disable
+#define CLKS_SSC0_DIS 0x00000000 */
+/** Enable */
+#define CLKS_SSC0_EN 0x00002000
+/** ASC0 Clock Enable
+    This domain contains the ASC0 interface block. */
+#define CLKS_ASC0 0x00001000
+/* Disable
+#define CLKS_ASC0_DIS 0x00000000 */
+/** Enable */
+#define CLKS_ASC0_EN 0x00001000
+/** ASC1 Clock Enable
+    This domain contains the ASC1 block. */
+#define CLKS_ASC1 0x00000800
+/* Disable
+#define CLKS_ASC1_DIS 0x00000000 */
+/** Enable */
+#define CLKS_ASC1_EN 0x00000800
+/** DCDCAPD Clock Enable
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define CLKS_DCDCAPD 0x00000400
+/* Disable
+#define CLKS_DCDCAPD_DIS 0x00000000 */
+/** Enable */
+#define CLKS_DCDCAPD_EN 0x00000400
+/** DCDCDDR Clock Enable
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define CLKS_DCDCDDR 0x00000200
+/* Disable
+#define CLKS_DCDCDDR_DIS 0x00000000 */
+/** Enable */
+#define CLKS_DCDCDDR_EN 0x00000200
+/** DCDC1V0 Clock Enable
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define CLKS_DCDC1V0 0x00000100
+/* Disable
+#define CLKS_DCDC1V0_DIS 0x00000000 */
+/** Enable */
+#define CLKS_DCDC1V0_EN 0x00000100
+/** TRC2MEM Clock Enable
+    This domain contains the TRC2MEM block. */
+#define CLKS_TRC2MEM 0x00000040
+/* Disable
+#define CLKS_TRC2MEM_DIS 0x00000000 */
+/** Enable */
+#define CLKS_TRC2MEM_EN 0x00000040
+/** DDR Clock Enable
+    This domain contains the DDR interface block. */
+#define CLKS_DDR 0x00000020
+/* Disable
+#define CLKS_DDR_DIS 0x00000000 */
+/** Enable */
+#define CLKS_DDR_EN 0x00000020
+/** EBU Clock Enable
+    This domain contains the EBU interface block. */
+#define CLKS_EBU 0x00000010
+/* Disable
+#define CLKS_EBU_DIS 0x00000000 */
+/** Enable */
+#define CLKS_EBU_EN 0x00000010
+
+/* Fields of "Clock Enable Register" */
+/** Set Clock Enable STATUS
+    This domain contains the STATUS block. */
+#define CLKEN_STATUS 0x80000000
+/* No-Operation
+#define CLKEN_STATUS_NOP 0x00000000 */
+/** Set */
+#define CLKEN_STATUS_SET 0x80000000
+/** Set Clock Enable SHA1
+    This domain contains the SHA1 block. */
+#define CLKEN_SHA1 0x40000000
+/* No-Operation
+#define CLKEN_SHA1_NOP 0x00000000 */
+/** Set */
+#define CLKEN_SHA1_SET 0x40000000
+/** Set Clock Enable AES
+    This domain contains the AES block. */
+#define CLKEN_AES 0x20000000
+/* No-Operation
+#define CLKEN_AES_NOP 0x00000000 */
+/** Set */
+#define CLKEN_AES_SET 0x20000000
+/** Set Clock Enable PCM
+    This domain contains the PCM interface block. */
+#define CLKEN_PCM 0x10000000
+/* No-Operation
+#define CLKEN_PCM_NOP 0x00000000 */
+/** Set */
+#define CLKEN_PCM_SET 0x10000000
+/** Set Clock Enable FSCT
+    This domain contains the FSCT block. */
+#define CLKEN_FSCT 0x08000000
+/* No-Operation
+#define CLKEN_FSCT_NOP 0x00000000 */
+/** Set */
+#define CLKEN_FSCT_SET 0x08000000
+/** Set Clock Enable GPTC
+    This domain contains the GPTC block. */
+#define CLKEN_GPTC 0x04000000
+/* No-Operation
+#define CLKEN_GPTC_NOP 0x00000000 */
+/** Set */
+#define CLKEN_GPTC_SET 0x04000000
+/** Set Clock Enable MPS
+    This domain contains the MPS block. */
+#define CLKEN_MPS 0x02000000
+/* No-Operation
+#define CLKEN_MPS_NOP 0x00000000 */
+/** Set */
+#define CLKEN_MPS_SET 0x02000000
+/** Set Clock Enable DFEV0
+    This domain contains the DFEV0 block. */
+#define CLKEN_DFEV0 0x01000000
+/* No-Operation
+#define CLKEN_DFEV0_NOP 0x00000000 */
+/** Set */
+#define CLKEN_DFEV0_SET 0x01000000
+/** Set Clock Enable PADCTRL4
+    This domain contains the PADCTRL4 block. */
+#define CLKEN_PADCTRL4 0x00400000
+/* No-Operation
+#define CLKEN_PADCTRL4_NOP 0x00000000 */
+/** Set */
+#define CLKEN_PADCTRL4_SET 0x00400000
+/** Set Clock Enable PADCTRL3
+    This domain contains the PADCTRL3 block. */
+#define CLKEN_PADCTRL3 0x00200000
+/* No-Operation
+#define CLKEN_PADCTRL3_NOP 0x00000000 */
+/** Set */
+#define CLKEN_PADCTRL3_SET 0x00200000
+/** Set Clock Enable PADCTRL1
+    This domain contains the PADCTRL1 block. */
+#define CLKEN_PADCTRL1 0x00100000
+/* No-Operation
+#define CLKEN_PADCTRL1_NOP 0x00000000 */
+/** Set */
+#define CLKEN_PADCTRL1_SET 0x00100000
+/** Set Clock Enable P4
+    This domain contains the P4 instance of the GPIO block. */
+#define CLKEN_P4 0x00040000
+/* No-Operation
+#define CLKEN_P4_NOP 0x00000000 */
+/** Set */
+#define CLKEN_P4_SET 0x00040000
+/** Set Clock Enable P3
+    This domain contains the P3 instance of the GPIO block. */
+#define CLKEN_P3 0x00020000
+/* No-Operation
+#define CLKEN_P3_NOP 0x00000000 */
+/** Set */
+#define CLKEN_P3_SET 0x00020000
+/** Set Clock Enable P1
+    This domain contains the P1 instance of the GPIO block. */
+#define CLKEN_P1 0x00010000
+/* No-Operation
+#define CLKEN_P1_NOP 0x00000000 */
+/** Set */
+#define CLKEN_P1_SET 0x00010000
+/** Set Clock Enable HOST
+    This domain contains the HOST interface block. */
+#define CLKEN_HOST 0x00008000
+/* No-Operation
+#define CLKEN_HOST_NOP 0x00000000 */
+/** Set */
+#define CLKEN_HOST_SET 0x00008000
+/** Set Clock Enable I2C
+    This domain contains the I2C interface block. */
+#define CLKEN_I2C 0x00004000
+/* No-Operation
+#define CLKEN_I2C_NOP 0x00000000 */
+/** Set */
+#define CLKEN_I2C_SET 0x00004000
+/** Set Clock Enable SSC0
+    This domain contains the SSC0 interface block. */
+#define CLKEN_SSC0 0x00002000
+/* No-Operation
+#define CLKEN_SSC0_NOP 0x00000000 */
+/** Set */
+#define CLKEN_SSC0_SET 0x00002000
+/** Set Clock Enable ASC0
+    This domain contains the ASC0 interface block. */
+#define CLKEN_ASC0 0x00001000
+/* No-Operation
+#define CLKEN_ASC0_NOP 0x00000000 */
+/** Set */
+#define CLKEN_ASC0_SET 0x00001000
+/** Set Clock Enable ASC1
+    This domain contains the ASC1 block. */
+#define CLKEN_ASC1 0x00000800
+/* No-Operation
+#define CLKEN_ASC1_NOP 0x00000000 */
+/** Set */
+#define CLKEN_ASC1_SET 0x00000800
+/** Set Clock Enable DCDCAPD
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define CLKEN_DCDCAPD 0x00000400
+/* No-Operation
+#define CLKEN_DCDCAPD_NOP 0x00000000 */
+/** Set */
+#define CLKEN_DCDCAPD_SET 0x00000400
+/** Set Clock Enable DCDCDDR
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define CLKEN_DCDCDDR 0x00000200
+/* No-Operation
+#define CLKEN_DCDCDDR_NOP 0x00000000 */
+/** Set */
+#define CLKEN_DCDCDDR_SET 0x00000200
+/** Set Clock Enable DCDC1V0
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define CLKEN_DCDC1V0 0x00000100
+/* No-Operation
+#define CLKEN_DCDC1V0_NOP 0x00000000 */
+/** Set */
+#define CLKEN_DCDC1V0_SET 0x00000100
+/** Set Clock Enable TRC2MEM
+    This domain contains the TRC2MEM block. */
+#define CLKEN_TRC2MEM 0x00000040
+/* No-Operation
+#define CLKEN_TRC2MEM_NOP 0x00000000 */
+/** Set */
+#define CLKEN_TRC2MEM_SET 0x00000040
+/** Set Clock Enable DDR
+    This domain contains the DDR interface block. */
+#define CLKEN_DDR 0x00000020
+/* No-Operation
+#define CLKEN_DDR_NOP 0x00000000 */
+/** Set */
+#define CLKEN_DDR_SET 0x00000020
+/** Set Clock Enable EBU
+    This domain contains the EBU interface block. */
+#define CLKEN_EBU 0x00000010
+/* No-Operation
+#define CLKEN_EBU_NOP 0x00000000 */
+/** Set */
+#define CLKEN_EBU_SET 0x00000010
+
+/* Fields of "Clock Clear Register" */
+/** Clear Clock Enable STATUS
+    This domain contains the STATUS block. */
+#define CLKCLR_STATUS 0x80000000
+/* No-Operation
+#define CLKCLR_STATUS_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_STATUS_CLR 0x80000000
+/** Clear Clock Enable SHA1
+    This domain contains the SHA1 block. */
+#define CLKCLR_SHA1 0x40000000
+/* No-Operation
+#define CLKCLR_SHA1_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_SHA1_CLR 0x40000000
+/** Clear Clock Enable AES
+    This domain contains the AES block. */
+#define CLKCLR_AES 0x20000000
+/* No-Operation
+#define CLKCLR_AES_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_AES_CLR 0x20000000
+/** Clear Clock Enable PCM
+    This domain contains the PCM interface block. */
+#define CLKCLR_PCM 0x10000000
+/* No-Operation
+#define CLKCLR_PCM_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_PCM_CLR 0x10000000
+/** Clear Clock Enable FSCT
+    This domain contains the FSCT block. */
+#define CLKCLR_FSCT 0x08000000
+/* No-Operation
+#define CLKCLR_FSCT_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_FSCT_CLR 0x08000000
+/** Clear Clock Enable GPTC
+    This domain contains the GPTC block. */
+#define CLKCLR_GPTC 0x04000000
+/* No-Operation
+#define CLKCLR_GPTC_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_GPTC_CLR 0x04000000
+/** Clear Clock Enable MPS
+    This domain contains the MPS block. */
+#define CLKCLR_MPS 0x02000000
+/* No-Operation
+#define CLKCLR_MPS_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_MPS_CLR 0x02000000
+/** Clear Clock Enable DFEV0
+    This domain contains the DFEV0 block. */
+#define CLKCLR_DFEV0 0x01000000
+/* No-Operation
+#define CLKCLR_DFEV0_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_DFEV0_CLR 0x01000000
+/** Clear Clock Enable PADCTRL4
+    This domain contains the PADCTRL4 block. */
+#define CLKCLR_PADCTRL4 0x00400000
+/* No-Operation
+#define CLKCLR_PADCTRL4_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_PADCTRL4_CLR 0x00400000
+/** Clear Clock Enable PADCTRL3
+    This domain contains the PADCTRL3 block. */
+#define CLKCLR_PADCTRL3 0x00200000
+/* No-Operation
+#define CLKCLR_PADCTRL3_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_PADCTRL3_CLR 0x00200000
+/** Clear Clock Enable PADCTRL1
+    This domain contains the PADCTRL1 block. */
+#define CLKCLR_PADCTRL1 0x00100000
+/* No-Operation
+#define CLKCLR_PADCTRL1_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_PADCTRL1_CLR 0x00100000
+/** Clear Clock Enable P4
+    This domain contains the P4 instance of the GPIO block. */
+#define CLKCLR_P4 0x00040000
+/* No-Operation
+#define CLKCLR_P4_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_P4_CLR 0x00040000
+/** Clear Clock Enable P3
+    This domain contains the P3 instance of the GPIO block. */
+#define CLKCLR_P3 0x00020000
+/* No-Operation
+#define CLKCLR_P3_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_P3_CLR 0x00020000
+/** Clear Clock Enable P1
+    This domain contains the P1 instance of the GPIO block. */
+#define CLKCLR_P1 0x00010000
+/* No-Operation
+#define CLKCLR_P1_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_P1_CLR 0x00010000
+/** Clear Clock Enable HOST
+    This domain contains the HOST interface block. */
+#define CLKCLR_HOST 0x00008000
+/* No-Operation
+#define CLKCLR_HOST_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_HOST_CLR 0x00008000
+/** Clear Clock Enable I2C
+    This domain contains the I2C interface block. */
+#define CLKCLR_I2C 0x00004000
+/* No-Operation
+#define CLKCLR_I2C_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_I2C_CLR 0x00004000
+/** Clear Clock Enable SSC0
+    This domain contains the SSC0 interface block. */
+#define CLKCLR_SSC0 0x00002000
+/* No-Operation
+#define CLKCLR_SSC0_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_SSC0_CLR 0x00002000
+/** Clear Clock Enable ASC0
+    This domain contains the ASC0 interface block. */
+#define CLKCLR_ASC0 0x00001000
+/* No-Operation
+#define CLKCLR_ASC0_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_ASC0_CLR 0x00001000
+/** Clear Clock Enable ASC1
+    This domain contains the ASC1 block. */
+#define CLKCLR_ASC1 0x00000800
+/* No-Operation
+#define CLKCLR_ASC1_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_ASC1_CLR 0x00000800
+/** Clear Clock Enable DCDCAPD
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define CLKCLR_DCDCAPD 0x00000400
+/* No-Operation
+#define CLKCLR_DCDCAPD_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_DCDCAPD_CLR 0x00000400
+/** Clear Clock Enable DCDCDDR
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define CLKCLR_DCDCDDR 0x00000200
+/* No-Operation
+#define CLKCLR_DCDCDDR_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_DCDCDDR_CLR 0x00000200
+/** Clear Clock Enable DCDC1V0
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define CLKCLR_DCDC1V0 0x00000100
+/* No-Operation
+#define CLKCLR_DCDC1V0_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_DCDC1V0_CLR 0x00000100
+/** Clear Clock Enable TRC2MEM
+    This domain contains the TRC2MEM block. */
+#define CLKCLR_TRC2MEM 0x00000040
+/* No-Operation
+#define CLKCLR_TRC2MEM_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_TRC2MEM_CLR 0x00000040
+/** Clear Clock Enable DDR
+    This domain contains the DDR interface block. */
+#define CLKCLR_DDR 0x00000020
+/* No-Operation
+#define CLKCLR_DDR_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_DDR_CLR 0x00000020
+/** Clear Clock Enable EBU
+    This domain contains the EBU interface block. */
+#define CLKCLR_EBU 0x00000010
+/* No-Operation
+#define CLKCLR_EBU_NOP 0x00000000 */
+/** Clear */
+#define CLKCLR_EBU_CLR 0x00000010
+
+/* Fields of "Activation Status Register" */
+/** STATUS Status
+    This domain contains the STATUS block. */
+#define ACTS_STATUS 0x80000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_STATUS_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_STATUS_ACT 0x80000000
+/** SHA1 Status
+    This domain contains the SHA1 block. */
+#define ACTS_SHA1 0x40000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_SHA1_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_SHA1_ACT 0x40000000
+/** AES Status
+    This domain contains the AES block. */
+#define ACTS_AES 0x20000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_AES_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_AES_ACT 0x20000000
+/** PCM Status
+    This domain contains the PCM interface block. */
+#define ACTS_PCM 0x10000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_PCM_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_PCM_ACT 0x10000000
+/** FSCT Status
+    This domain contains the FSCT block. */
+#define ACTS_FSCT 0x08000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_FSCT_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_FSCT_ACT 0x08000000
+/** GPTC Status
+    This domain contains the GPTC block. */
+#define ACTS_GPTC 0x04000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_GPTC_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_GPTC_ACT 0x04000000
+/** MPS Status
+    This domain contains the MPS block. */
+#define ACTS_MPS 0x02000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_MPS_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_MPS_ACT 0x02000000
+/** DFEV0 Status
+    This domain contains the DFEV0 block. */
+#define ACTS_DFEV0 0x01000000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_DFEV0_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_DFEV0_ACT 0x01000000
+/** PADCTRL4 Status
+    This domain contains the PADCTRL4 block. */
+#define ACTS_PADCTRL4 0x00400000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_PADCTRL4_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_PADCTRL4_ACT 0x00400000
+/** PADCTRL3 Status
+    This domain contains the PADCTRL3 block. */
+#define ACTS_PADCTRL3 0x00200000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_PADCTRL3_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_PADCTRL3_ACT 0x00200000
+/** PADCTRL1 Status
+    This domain contains the PADCTRL1 block. */
+#define ACTS_PADCTRL1 0x00100000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_PADCTRL1_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_PADCTRL1_ACT 0x00100000
+/** P4 Status
+    This domain contains the P4 instance of the GPIO block. */
+#define ACTS_P4 0x00040000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_P4_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_P4_ACT 0x00040000
+/** P3 Status
+    This domain contains the P3 instance of the GPIO block. */
+#define ACTS_P3 0x00020000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_P3_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_P3_ACT 0x00020000
+/** P1 Status
+    This domain contains the P1 instance of the GPIO block. */
+#define ACTS_P1 0x00010000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_P1_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_P1_ACT 0x00010000
+/** HOST Status
+    This domain contains the HOST interface block. */
+#define ACTS_HOST 0x00008000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_HOST_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_HOST_ACT 0x00008000
+/** I2C Status
+    This domain contains the I2C interface block. */
+#define ACTS_I2C 0x00004000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_I2C_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_I2C_ACT 0x00004000
+/** SSC0 Status
+    This domain contains the SSC0 interface block. */
+#define ACTS_SSC0 0x00002000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_SSC0_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_SSC0_ACT 0x00002000
+/** ASC0 Status
+    This domain contains the ASC0 interface block. */
+#define ACTS_ASC0 0x00001000
+/* The block is inactive (reset state, clock is off).
+#define ACTS_ASC0_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_ASC0_ACT 0x00001000
+/** ASC1 Status
+    This domain contains the ASC1 block. */
+#define ACTS_ASC1 0x00000800
+/* The block is inactive (reset state, clock is off).
+#define ACTS_ASC1_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_ASC1_ACT 0x00000800
+/** DCDCAPD Status
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define ACTS_DCDCAPD 0x00000400
+/* The block is inactive (reset state, clock is off).
+#define ACTS_DCDCAPD_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_DCDCAPD_ACT 0x00000400
+/** DCDCDDR Status
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define ACTS_DCDCDDR 0x00000200
+/* The block is inactive (reset state, clock is off).
+#define ACTS_DCDCDDR_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_DCDCDDR_ACT 0x00000200
+/** DCDC1V0 Status
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define ACTS_DCDC1V0 0x00000100
+/* The block is inactive (reset state, clock is off).
+#define ACTS_DCDC1V0_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_DCDC1V0_ACT 0x00000100
+/** TRC2MEM Status
+    This domain contains the TRC2MEM block. */
+#define ACTS_TRC2MEM 0x00000040
+/* The block is inactive (reset state, clock is off).
+#define ACTS_TRC2MEM_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_TRC2MEM_ACT 0x00000040
+/** DDR Status
+    This domain contains the DDR interface block. */
+#define ACTS_DDR 0x00000020
+/* The block is inactive (reset state, clock is off).
+#define ACTS_DDR_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_DDR_ACT 0x00000020
+/** EBU Status
+    This domain contains the EBU interface block. */
+#define ACTS_EBU 0x00000010
+/* The block is inactive (reset state, clock is off).
+#define ACTS_EBU_INACT 0x00000000 */
+/** The block is active (post-reset state, clock depends on CLKS-bit). */
+#define ACTS_EBU_ACT 0x00000010
+
+/* Fields of "Activation Register" */
+/** Set activation STATUS
+    This domain contains the STATUS block. */
+#define ACT_STATUS 0x80000000
+/* No-Operation
+#define ACT_STATUS_NOP 0x00000000 */
+/** Set */
+#define ACT_STATUS_SET 0x80000000
+/** Set activation SHA1
+    This domain contains the SHA1 block. */
+#define ACT_SHA1 0x40000000
+/* No-Operation
+#define ACT_SHA1_NOP 0x00000000 */
+/** Set */
+#define ACT_SHA1_SET 0x40000000
+/** Set activation AES
+    This domain contains the AES block. */
+#define ACT_AES 0x20000000
+/* No-Operation
+#define ACT_AES_NOP 0x00000000 */
+/** Set */
+#define ACT_AES_SET 0x20000000
+/** Set activation PCM
+    This domain contains the PCM interface block. */
+#define ACT_PCM 0x10000000
+/* No-Operation
+#define ACT_PCM_NOP 0x00000000 */
+/** Set */
+#define ACT_PCM_SET 0x10000000
+/** Set activation FSCT
+    This domain contains the FSCT block. */
+#define ACT_FSCT 0x08000000
+/* No-Operation
+#define ACT_FSCT_NOP 0x00000000 */
+/** Set */
+#define ACT_FSCT_SET 0x08000000
+/** Set activation GPTC
+    This domain contains the GPTC block. */
+#define ACT_GPTC 0x04000000
+/* No-Operation
+#define ACT_GPTC_NOP 0x00000000 */
+/** Set */
+#define ACT_GPTC_SET 0x04000000
+/** Set activation MPS
+    This domain contains the MPS block. */
+#define ACT_MPS 0x02000000
+/* No-Operation
+#define ACT_MPS_NOP 0x00000000 */
+/** Set */
+#define ACT_MPS_SET 0x02000000
+/** Set activation DFEV0
+    This domain contains the DFEV0 block. */
+#define ACT_DFEV0 0x01000000
+/* No-Operation
+#define ACT_DFEV0_NOP 0x00000000 */
+/** Set */
+#define ACT_DFEV0_SET 0x01000000
+/** Set activation PADCTRL4
+    This domain contains the PADCTRL4 block. */
+#define ACT_PADCTRL4 0x00400000
+/* No-Operation
+#define ACT_PADCTRL4_NOP 0x00000000 */
+/** Set */
+#define ACT_PADCTRL4_SET 0x00400000
+/** Set activation PADCTRL3
+    This domain contains the PADCTRL3 block. */
+#define ACT_PADCTRL3 0x00200000
+/* No-Operation
+#define ACT_PADCTRL3_NOP 0x00000000 */
+/** Set */
+#define ACT_PADCTRL3_SET 0x00200000
+/** Set activation PADCTRL1
+    This domain contains the PADCTRL1 block. */
+#define ACT_PADCTRL1 0x00100000
+/* No-Operation
+#define ACT_PADCTRL1_NOP 0x00000000 */
+/** Set */
+#define ACT_PADCTRL1_SET 0x00100000
+/** Set activation P4
+    This domain contains the P4 instance of the GPIO block. */
+#define ACT_P4 0x00040000
+/* No-Operation
+#define ACT_P4_NOP 0x00000000 */
+/** Set */
+#define ACT_P4_SET 0x00040000
+/** Set activation P3
+    This domain contains the P3 instance of the GPIO block. */
+#define ACT_P3 0x00020000
+/* No-Operation
+#define ACT_P3_NOP 0x00000000 */
+/** Set */
+#define ACT_P3_SET 0x00020000
+/** Set activation P1
+    This domain contains the P1 instance of the GPIO block. */
+#define ACT_P1 0x00010000
+/* No-Operation
+#define ACT_P1_NOP 0x00000000 */
+/** Set */
+#define ACT_P1_SET 0x00010000
+/** Set activation HOST
+    This domain contains the HOST interface block. */
+#define ACT_HOST 0x00008000
+/* No-Operation
+#define ACT_HOST_NOP 0x00000000 */
+/** Set */
+#define ACT_HOST_SET 0x00008000
+/** Set activation I2C
+    This domain contains the I2C interface block. */
+#define ACT_I2C 0x00004000
+/* No-Operation
+#define ACT_I2C_NOP 0x00000000 */
+/** Set */
+#define ACT_I2C_SET 0x00004000
+/** Set activation SSC0
+    This domain contains the SSC0 interface block. */
+#define ACT_SSC0 0x00002000
+/* No-Operation
+#define ACT_SSC0_NOP 0x00000000 */
+/** Set */
+#define ACT_SSC0_SET 0x00002000
+/** Set activation ASC0
+    This domain contains the ASC0 interface block. */
+#define ACT_ASC0 0x00001000
+/* No-Operation
+#define ACT_ASC0_NOP 0x00000000 */
+/** Set */
+#define ACT_ASC0_SET 0x00001000
+/** Set activation ASC1
+    This domain contains the ASC1 block. */
+#define ACT_ASC1 0x00000800
+/* No-Operation
+#define ACT_ASC1_NOP 0x00000000 */
+/** Set */
+#define ACT_ASC1_SET 0x00000800
+/** Set activation DCDCAPD
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define ACT_DCDCAPD 0x00000400
+/* No-Operation
+#define ACT_DCDCAPD_NOP 0x00000000 */
+/** Set */
+#define ACT_DCDCAPD_SET 0x00000400
+/** Set activation DCDCDDR
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define ACT_DCDCDDR 0x00000200
+/* No-Operation
+#define ACT_DCDCDDR_NOP 0x00000000 */
+/** Set */
+#define ACT_DCDCDDR_SET 0x00000200
+/** Set activation DCDC1V0
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define ACT_DCDC1V0 0x00000100
+/* No-Operation
+#define ACT_DCDC1V0_NOP 0x00000000 */
+/** Set */
+#define ACT_DCDC1V0_SET 0x00000100
+/** Set activation TRC2MEM
+    This domain contains the TRC2MEM block. */
+#define ACT_TRC2MEM 0x00000040
+/* No-Operation
+#define ACT_TRC2MEM_NOP 0x00000000 */
+/** Set */
+#define ACT_TRC2MEM_SET 0x00000040
+/** Set activation DDR
+    This domain contains the DDR interface block. */
+#define ACT_DDR 0x00000020
+/* No-Operation
+#define ACT_DDR_NOP 0x00000000 */
+/** Set */
+#define ACT_DDR_SET 0x00000020
+/** Set activation EBU
+    This domain contains the EBU interface block. */
+#define ACT_EBU 0x00000010
+/* No-Operation
+#define ACT_EBU_NOP 0x00000000 */
+/** Set */
+#define ACT_EBU_SET 0x00000010
+
+/* Fields of "Deactivation Register" */
+/** Clear activation STATUS
+    This domain contains the STATUS block. */
+#define DEACT_STATUS 0x80000000
+/* No-Operation
+#define DEACT_STATUS_NOP 0x00000000 */
+/** Clear */
+#define DEACT_STATUS_CLR 0x80000000
+/** Clear activation SHA1
+    This domain contains the SHA1 block. */
+#define DEACT_SHA1 0x40000000
+/* No-Operation
+#define DEACT_SHA1_NOP 0x00000000 */
+/** Clear */
+#define DEACT_SHA1_CLR 0x40000000
+/** Clear activation AES
+    This domain contains the AES block. */
+#define DEACT_AES 0x20000000
+/* No-Operation
+#define DEACT_AES_NOP 0x00000000 */
+/** Clear */
+#define DEACT_AES_CLR 0x20000000
+/** Clear activation PCM
+    This domain contains the PCM interface block. */
+#define DEACT_PCM 0x10000000
+/* No-Operation
+#define DEACT_PCM_NOP 0x00000000 */
+/** Clear */
+#define DEACT_PCM_CLR 0x10000000
+/** Clear activation FSCT
+    This domain contains the FSCT block. */
+#define DEACT_FSCT 0x08000000
+/* No-Operation
+#define DEACT_FSCT_NOP 0x00000000 */
+/** Clear */
+#define DEACT_FSCT_CLR 0x08000000
+/** Clear activation GPTC
+    This domain contains the GPTC block. */
+#define DEACT_GPTC 0x04000000
+/* No-Operation
+#define DEACT_GPTC_NOP 0x00000000 */
+/** Clear */
+#define DEACT_GPTC_CLR 0x04000000
+/** Clear activation MPS
+    This domain contains the MPS block. */
+#define DEACT_MPS 0x02000000
+/* No-Operation
+#define DEACT_MPS_NOP 0x00000000 */
+/** Clear */
+#define DEACT_MPS_CLR 0x02000000
+/** Clear activation DFEV0
+    This domain contains the DFEV0 block. */
+#define DEACT_DFEV0 0x01000000
+/* No-Operation
+#define DEACT_DFEV0_NOP 0x00000000 */
+/** Clear */
+#define DEACT_DFEV0_CLR 0x01000000
+/** Clear activation PADCTRL4
+    This domain contains the PADCTRL4 block. */
+#define DEACT_PADCTRL4 0x00400000
+/* No-Operation
+#define DEACT_PADCTRL4_NOP 0x00000000 */
+/** Clear */
+#define DEACT_PADCTRL4_CLR 0x00400000
+/** Clear activation PADCTRL3
+    This domain contains the PADCTRL3 block. */
+#define DEACT_PADCTRL3 0x00200000
+/* No-Operation
+#define DEACT_PADCTRL3_NOP 0x00000000 */
+/** Clear */
+#define DEACT_PADCTRL3_CLR 0x00200000
+/** Clear activation PADCTRL1
+    This domain contains the PADCTRL1 block. */
+#define DEACT_PADCTRL1 0x00100000
+/* No-Operation
+#define DEACT_PADCTRL1_NOP 0x00000000 */
+/** Clear */
+#define DEACT_PADCTRL1_CLR 0x00100000
+/** Clear activation P4
+    This domain contains the P4 instance of the GPIO block. */
+#define DEACT_P4 0x00040000
+/* No-Operation
+#define DEACT_P4_NOP 0x00000000 */
+/** Clear */
+#define DEACT_P4_CLR 0x00040000
+/** Clear activation P3
+    This domain contains the P3 instance of the GPIO block. */
+#define DEACT_P3 0x00020000
+/* No-Operation
+#define DEACT_P3_NOP 0x00000000 */
+/** Clear */
+#define DEACT_P3_CLR 0x00020000
+/** Clear activation P1
+    This domain contains the P1 instance of the GPIO block. */
+#define DEACT_P1 0x00010000
+/* No-Operation
+#define DEACT_P1_NOP 0x00000000 */
+/** Clear */
+#define DEACT_P1_CLR 0x00010000
+/** Clear activation HOST
+    This domain contains the HOST interface block. */
+#define DEACT_HOST 0x00008000
+/* No-Operation
+#define DEACT_HOST_NOP 0x00000000 */
+/** Clear */
+#define DEACT_HOST_CLR 0x00008000
+/** Clear activation I2C
+    This domain contains the I2C interface block. */
+#define DEACT_I2C 0x00004000
+/* No-Operation
+#define DEACT_I2C_NOP 0x00000000 */
+/** Clear */
+#define DEACT_I2C_CLR 0x00004000
+/** Clear activation SSC0
+    This domain contains the SSC0 interface block. */
+#define DEACT_SSC0 0x00002000
+/* No-Operation
+#define DEACT_SSC0_NOP 0x00000000 */
+/** Clear */
+#define DEACT_SSC0_CLR 0x00002000
+/** Clear activation ASC0
+    This domain contains the ASC0 interface block. */
+#define DEACT_ASC0 0x00001000
+/* No-Operation
+#define DEACT_ASC0_NOP 0x00000000 */
+/** Clear */
+#define DEACT_ASC0_CLR 0x00001000
+/** Clear activation ASC1
+    This domain contains the ASC1 block. */
+#define DEACT_ASC1 0x00000800
+/* No-Operation
+#define DEACT_ASC1_NOP 0x00000000 */
+/** Clear */
+#define DEACT_ASC1_CLR 0x00000800
+/** Clear activation DCDCAPD
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define DEACT_DCDCAPD 0x00000400
+/* No-Operation
+#define DEACT_DCDCAPD_NOP 0x00000000 */
+/** Clear */
+#define DEACT_DCDCAPD_CLR 0x00000400
+/** Clear activation DCDCDDR
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define DEACT_DCDCDDR 0x00000200
+/* No-Operation
+#define DEACT_DCDCDDR_NOP 0x00000000 */
+/** Clear */
+#define DEACT_DCDCDDR_CLR 0x00000200
+/** Clear activation DCDC1V0
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define DEACT_DCDC1V0 0x00000100
+/* No-Operation
+#define DEACT_DCDC1V0_NOP 0x00000000 */
+/** Clear */
+#define DEACT_DCDC1V0_CLR 0x00000100
+/** Clear activation TRC2MEM
+    This domain contains the TRC2MEM block. */
+#define DEACT_TRC2MEM 0x00000040
+/* No-Operation
+#define DEACT_TRC2MEM_NOP 0x00000000 */
+/** Clear */
+#define DEACT_TRC2MEM_CLR 0x00000040
+/** Clear activation DDR
+    This domain contains the DDR interface block. */
+#define DEACT_DDR 0x00000020
+/* No-Operation
+#define DEACT_DDR_NOP 0x00000000 */
+/** Clear */
+#define DEACT_DDR_CLR 0x00000020
+/** Clear activation EBU
+    This domain contains the EBU interface block. */
+#define DEACT_EBU 0x00000010
+/* No-Operation
+#define DEACT_EBU_NOP 0x00000000 */
+/** Clear */
+#define DEACT_EBU_CLR 0x00000010
+
+/* Fields of "Reboot Trigger Register" */
+/** Reboot STATUS
+    This domain contains the STATUS block. */
+#define RBT_STATUS 0x80000000
+/* No-Operation
+#define RBT_STATUS_NOP 0x00000000 */
+/** Trigger */
+#define RBT_STATUS_TRIG 0x80000000
+/** Reboot SHA1
+    This domain contains the SHA1 block. */
+#define RBT_SHA1 0x40000000
+/* No-Operation
+#define RBT_SHA1_NOP 0x00000000 */
+/** Trigger */
+#define RBT_SHA1_TRIG 0x40000000
+/** Reboot AES
+    This domain contains the AES block. */
+#define RBT_AES 0x20000000
+/* No-Operation
+#define RBT_AES_NOP 0x00000000 */
+/** Trigger */
+#define RBT_AES_TRIG 0x20000000
+/** Reboot PCM
+    This domain contains the PCM interface block. */
+#define RBT_PCM 0x10000000
+/* No-Operation
+#define RBT_PCM_NOP 0x00000000 */
+/** Trigger */
+#define RBT_PCM_TRIG 0x10000000
+/** Reboot FSCT
+    This domain contains the FSCT block. */
+#define RBT_FSCT 0x08000000
+/* No-Operation
+#define RBT_FSCT_NOP 0x00000000 */
+/** Trigger */
+#define RBT_FSCT_TRIG 0x08000000
+/** Reboot GPTC
+    This domain contains the GPTC block. */
+#define RBT_GPTC 0x04000000
+/* No-Operation
+#define RBT_GPTC_NOP 0x00000000 */
+/** Trigger */
+#define RBT_GPTC_TRIG 0x04000000
+/** Reboot MPS
+    This domain contains the MPS block. */
+#define RBT_MPS 0x02000000
+/* No-Operation
+#define RBT_MPS_NOP 0x00000000 */
+/** Trigger */
+#define RBT_MPS_TRIG 0x02000000
+/** Reboot DFEV0
+    This domain contains the DFEV0 block. */
+#define RBT_DFEV0 0x01000000
+/* No-Operation
+#define RBT_DFEV0_NOP 0x00000000 */
+/** Trigger */
+#define RBT_DFEV0_TRIG 0x01000000
+/** Reboot PADCTRL4
+    This domain contains the PADCTRL4 block. */
+#define RBT_PADCTRL4 0x00400000
+/* No-Operation
+#define RBT_PADCTRL4_NOP 0x00000000 */
+/** Trigger */
+#define RBT_PADCTRL4_TRIG 0x00400000
+/** Reboot PADCTRL3
+    This domain contains the PADCTRL3 block. */
+#define RBT_PADCTRL3 0x00200000
+/* No-Operation
+#define RBT_PADCTRL3_NOP 0x00000000 */
+/** Trigger */
+#define RBT_PADCTRL3_TRIG 0x00200000
+/** Reboot PADCTRL1
+    This domain contains the PADCTRL1 block. */
+#define RBT_PADCTRL1 0x00100000
+/* No-Operation
+#define RBT_PADCTRL1_NOP 0x00000000 */
+/** Trigger */
+#define RBT_PADCTRL1_TRIG 0x00100000
+/** Reboot P4
+    This domain contains the P4 instance of the GPIO block. */
+#define RBT_P4 0x00040000
+/* No-Operation
+#define RBT_P4_NOP 0x00000000 */
+/** Trigger */
+#define RBT_P4_TRIG 0x00040000
+/** Reboot P3
+    This domain contains the P3 instance of the GPIO block. */
+#define RBT_P3 0x00020000
+/* No-Operation
+#define RBT_P3_NOP 0x00000000 */
+/** Trigger */
+#define RBT_P3_TRIG 0x00020000
+/** Reboot P1
+    This domain contains the P1 instance of the GPIO block. */
+#define RBT_P1 0x00010000
+/* No-Operation
+#define RBT_P1_NOP 0x00000000 */
+/** Trigger */
+#define RBT_P1_TRIG 0x00010000
+/** Reboot HOST
+    This domain contains the HOST interface block. */
+#define RBT_HOST 0x00008000
+/* No-Operation
+#define RBT_HOST_NOP 0x00000000 */
+/** Trigger */
+#define RBT_HOST_TRIG 0x00008000
+/** Reboot I2C
+    This domain contains the I2C interface block. */
+#define RBT_I2C 0x00004000
+/* No-Operation
+#define RBT_I2C_NOP 0x00000000 */
+/** Trigger */
+#define RBT_I2C_TRIG 0x00004000
+/** Reboot SSC0
+    This domain contains the SSC0 interface block. */
+#define RBT_SSC0 0x00002000
+/* No-Operation
+#define RBT_SSC0_NOP 0x00000000 */
+/** Trigger */
+#define RBT_SSC0_TRIG 0x00002000
+/** Reboot ASC0
+    This domain contains the ASC0 interface block. */
+#define RBT_ASC0 0x00001000
+/* No-Operation
+#define RBT_ASC0_NOP 0x00000000 */
+/** Trigger */
+#define RBT_ASC0_TRIG 0x00001000
+/** Reboot ASC1
+    This domain contains the ASC1 block. */
+#define RBT_ASC1 0x00000800
+/* No-Operation
+#define RBT_ASC1_NOP 0x00000000 */
+/** Trigger */
+#define RBT_ASC1_TRIG 0x00000800
+/** Reboot DCDCAPD
+    This domain contains the digital part of the 60 volts DCDC converter. */
+#define RBT_DCDCAPD 0x00000400
+/* No-Operation
+#define RBT_DCDCAPD_NOP 0x00000000 */
+/** Trigger */
+#define RBT_DCDCAPD_TRIG 0x00000400
+/** Reboot DCDCDDR
+    This domain contains the digital part of the DCDC converter dedicated to the DDR interface. */
+#define RBT_DCDCDDR 0x00000200
+/* No-Operation
+#define RBT_DCDCDDR_NOP 0x00000000 */
+/** Trigger */
+#define RBT_DCDCDDR_TRIG 0x00000200
+/** Reboot DCDC1V0
+    This domain contains the digital part of the 1.0 volts DCDC converter. */
+#define RBT_DCDC1V0 0x00000100
+/* No-Operation
+#define RBT_DCDC1V0_NOP 0x00000000 */
+/** Trigger */
+#define RBT_DCDC1V0_TRIG 0x00000100
+/** Reboot TRC2MEM
+    This domain contains the TRC2MEM block. */
+#define RBT_TRC2MEM 0x00000040
+/* No-Operation
+#define RBT_TRC2MEM_NOP 0x00000000 */
+/** Trigger */
+#define RBT_TRC2MEM_TRIG 0x00000040
+/** Reboot DDR
+    This domain contains the DDR interface block. */
+#define RBT_DDR 0x00000020
+/* No-Operation
+#define RBT_DDR_NOP 0x00000000 */
+/** Trigger */
+#define RBT_DDR_TRIG 0x00000020
+/** Reboot EBU
+    This domain contains the EBU interface block. */
+#define RBT_EBU 0x00000010
+/* No-Operation
+#define RBT_EBU_NOP 0x00000000 */
+/** Trigger */
+#define RBT_EBU_TRIG 0x00000010
+/** Reboot XBAR
+    Triggers a reboot of the XBAR. */
+#define RBT_XBAR 0x00000002
+/* No-Operation
+#define RBT_XBAR_NOP 0x00000000 */
+/** Trigger */
+#define RBT_XBAR_TRIG 0x00000002
+/** Reboot CPU
+    Triggers a reboot of the CPU. */
+#define RBT_CPU 0x00000001
+/* No-Operation
+#define RBT_CPU_NOP 0x00000000 */
+/** Trigger */
+#define RBT_CPU_TRIG 0x00000001
+
+/* Fields of "CPU0 Clock Control Register" */
+/** CPU Clock Divider
+    Via this bit the divider and therefore the frequency of the clock of CPU0 can be selected. */
+#define CPU0CC_CPUDIV 0x00000001
+/* Frequency set to the nominal value.
+#define CPU0CC_CPUDIV_SELFNOM 0x00000000 */
+/** Frequency set to half of its nominal value. */
+#define CPU0CC_CPUDIV_SELFHALF 0x00000001
+
+/* Fields of "CPU0 Reset Source Register" */
+/** Software Reboot Request Occurred
+    This bit can be acknowledged by a write operation. */
+#define CPU0RS_SWRRO 0x00000010
+/* Nothing
+#define CPU0RS_SWRRO_NULL 0x00000000 */
+/** Write: Acknowledge the event. */
+#define CPU0RS_SWRRO_EVACK 0x00000010
+/** Read: Event occurred. */
+#define CPU0RS_SWRRO_EVOCC 0x00000010
+/** Hardware Reset Source
+    Reflects the root cause for the last hardware reset. The infrastructure-block is only reset in case of POR. For all other blocks there is no difference between the different HW-reset sources. */
+#define CPU0RS_HWRS_MASK 0x00000007
+/** field offset */
+#define CPU0RS_HWRS_OFFSET 0
+/** Power-on reset. */
+#define CPU0RS_HWRS_POR 0x00000000
+/** RST pin. */
+#define CPU0RS_HWRS_RST 0x00000001
+/** Watchdog reset request. */
+#define CPU0RS_HWRS_WDT 0x00000002
+/** OLT reset request via dedicated PLOAM message. */
+#define CPU0RS_HWRS_OLT 0x00000003
+/** Software reset request via SYS1 register. */
+#define CPU0RS_HWRS_SYS1 0x00000004
+
+/* Fields of "CPU0 Wakeup Configuration Register" */
+/** Wakeup Request Source Yield Resume 15
+    Select the signal connected to the yield/resume interface pin 15 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR15 0x80000000
+/* Not selected
+#define CPU0WCFG_WRSYR15_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR15_SEL 0x80000000
+/** Wakeup Request Source Yield Resume 14
+    Select the signal connected to the yield/resume interface pin 14 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR14 0x40000000
+/* Not selected
+#define CPU0WCFG_WRSYR14_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR14_SEL 0x40000000
+/** Wakeup Request Source Yield Resume 13
+    Select the signal connected to the yield/resume interface pin 13 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR13 0x20000000
+/* Not selected
+#define CPU0WCFG_WRSYR13_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR13_SEL 0x20000000
+/** Wakeup Request Source Yield Resume 12
+    Select the signal connected to the yield/resume interface pin 12 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR12 0x10000000
+/* Not selected
+#define CPU0WCFG_WRSYR12_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR12_SEL 0x10000000
+/** Wakeup Request Source Yield Resume 11
+    Select the signal connected to the yield/resume interface pin 11 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR11 0x08000000
+/* Not selected
+#define CPU0WCFG_WRSYR11_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR11_SEL 0x08000000
+/** Wakeup Request Source Yield Resume 10
+    Select the signal connected to the yield/resume interface pin 10 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR10 0x04000000
+/* Not selected
+#define CPU0WCFG_WRSYR10_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR10_SEL 0x04000000
+/** Wakeup Request Source Yield Resume 9
+    Select the signal connected to the yield/resume interface pin 9 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR9 0x02000000
+/* Not selected
+#define CPU0WCFG_WRSYR9_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR9_SEL 0x02000000
+/** Wakeup Request Source Yield Resume 8
+    Select the signal connected to the yield/resume interface pin 8 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR8 0x01000000
+/* Not selected
+#define CPU0WCFG_WRSYR8_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR8_SEL 0x01000000
+/** Wakeup Request Source Yield Resume 7
+    Select the signal connected to the yield/resume interface pin 7 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR7 0x00800000
+/* Not selected
+#define CPU0WCFG_WRSYR7_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR7_SEL 0x00800000
+/** Wakeup Request Source Yield Resume 6
+    Select the signal connected to the yield/resume interface pin 6 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR6 0x00400000
+/* Not selected
+#define CPU0WCFG_WRSYR6_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR6_SEL 0x00400000
+/** Wakeup Request Source Yield Resume 5
+    Select the signal connected to the yield/resume interface pin 5 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR5 0x00200000
+/* Not selected
+#define CPU0WCFG_WRSYR5_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR5_SEL 0x00200000
+/** Wakeup Request Source Yield Resume 4
+    Select the signal connected to the yield/resume interface pin 4 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR4 0x00100000
+/* Not selected
+#define CPU0WCFG_WRSYR4_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR4_SEL 0x00100000
+/** Wakeup Request Source Yield Resume 3
+    Select the signal connected to the yield/resume interface pin 3 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR3 0x00080000
+/* Not selected
+#define CPU0WCFG_WRSYR3_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR3_SEL 0x00080000
+/** Wakeup Request Source Yield Resume 2
+    Select the signal connected to the yield/resume interface pin 2 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR2 0x00040000
+/* Not selected
+#define CPU0WCFG_WRSYR2_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR2_SEL 0x00040000
+/** Wakeup Request Source Yield Resume 1
+    Select the signal connected to the yield/resume interface pin 1 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR1 0x00020000
+/* Not selected
+#define CPU0WCFG_WRSYR1_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR1_SEL 0x00020000
+/** Wakeup Request Source Yield Resume 0
+    Select the signal connected to the yield/resume interface pin 0 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSYR0 0x00010000
+/* Not selected
+#define CPU0WCFG_WRSYR0_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSYR0_SEL 0x00010000
+/** Wakeup Request Source Debug
+    Select signal EJ_DINT as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSDBG 0x00000100
+/* Not selected
+#define CPU0WCFG_WRSDBG_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSDBG_SEL 0x00000100
+/** Wakeup Request Source ICU of VPE1
+    Select signal ICU_IRQ of VPE1 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSICUVPE1 0x00000002
+/* Not selected
+#define CPU0WCFG_WRSICUVPE1_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSICUVPE1_SEL 0x00000002
+/** Wakeup Request Source ICU of VPE0
+    Select signal ICU_IRQ of VPE0 as source for wakeup from sleep state. */
+#define CPU0WCFG_WRSICUVPE0 0x00000001
+/* Not selected
+#define CPU0WCFG_WRSICUVPE0_NSEL 0x00000000 */
+/** Selected */
+#define CPU0WCFG_WRSICUVPE0_SEL 0x00000001
+
+/* Fields of "Bootmode Control Register" */
+/** Software Bootmode Select
+    Enables SW writing of Bootmode and shows whether or not the SW-programmed bootmode is reflected in field Bootmode instead of the hardware given value. */
+#define BMC_BMSW 0x80000000
+/* Disable
+#define BMC_BMSW_DIS 0x00000000 */
+/** Enable */
+#define BMC_BMSW_EN 0x80000000
+/** Bootmode
+    Initially this field holds the value of the pinstraps LED_BMODEx on positions 5:0, and the value of the corresponding JTAG register bit on position 6. Writing is enabled by setting Software Bootmode Select to 1 during the write cycle. */
+#define BMC_BM_MASK 0x0000007F
+/** field offset */
+#define BMC_BM_OFFSET 0
+
+/* Fields of "Sleep Configuration Register" */
+/** Enable XBAR Clockoff When All XBAR masters Clockoff
+    Enable XBAR clock shutdown in case all XBAR masters are in clockoff mode. This bit has no effect if bit CPU0 is not enabled. */
+#define SCFG_XBAR 0x00010000
+/* Disable
+#define SCFG_XBAR_DIS 0x00000000 */
+/** Enable */
+#define SCFG_XBAR_EN 0x00010000
+/** CPU0 Clockoff On Sleep
+    Enable CPU0 clock shutdown in case its SI_SLEEP signal becomes active. */
+#define SCFG_CPU0 0x00000001
+/* Disable
+#define SCFG_CPU0_DIS 0x00000000 */
+/** Enable */
+#define SCFG_CPU0_EN 0x00000001
+
+/* Fields of "Power Down Configuration Register" */
+/** Enable Power Down STATUS
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_STATUS 0x80000000
+/* Disable
+#define PDCFG_STATUS_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_STATUS_EN 0x80000000
+/** Enable Power Down SHA1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_SHA1 0x40000000
+/* Disable
+#define PDCFG_SHA1_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_SHA1_EN 0x40000000
+/** Enable Power Down AES
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_AES 0x20000000
+/* Disable
+#define PDCFG_AES_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_AES_EN 0x20000000
+/** Enable Power Down PCM
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_PCM 0x10000000
+/* Disable
+#define PDCFG_PCM_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_PCM_EN 0x10000000
+/** Enable Power Down FSCT
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_FSCT 0x08000000
+/* Disable
+#define PDCFG_FSCT_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_FSCT_EN 0x08000000
+/** Enable Power Down GPTC
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_GPTC 0x04000000
+/* Disable
+#define PDCFG_GPTC_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_GPTC_EN 0x04000000
+/** Enable Power Down MPS
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_MPS 0x02000000
+/* Disable
+#define PDCFG_MPS_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_MPS_EN 0x02000000
+/** Enable Power Down DFEV0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_DFEV0 0x01000000
+/* Disable
+#define PDCFG_DFEV0_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_DFEV0_EN 0x01000000
+/** Enable Power Down PADCTRL4
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_PADCTRL4 0x00400000
+/* Disable
+#define PDCFG_PADCTRL4_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_PADCTRL4_EN 0x00400000
+/** Enable Power Down PADCTRL3
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_PADCTRL3 0x00200000
+/* Disable
+#define PDCFG_PADCTRL3_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_PADCTRL3_EN 0x00200000
+/** Enable Power Down PADCTRL1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_PADCTRL1 0x00100000
+/* Disable
+#define PDCFG_PADCTRL1_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_PADCTRL1_EN 0x00100000
+/** Enable Power Down P4
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_P4 0x00040000
+/* Disable
+#define PDCFG_P4_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_P4_EN 0x00040000
+/** Enable Power Down P3
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_P3 0x00020000
+/* Disable
+#define PDCFG_P3_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_P3_EN 0x00020000
+/** Enable Power Down P1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_P1 0x00010000
+/* Disable
+#define PDCFG_P1_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_P1_EN 0x00010000
+/** Enable Power Down HOST
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_HOST 0x00008000
+/* Disable
+#define PDCFG_HOST_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_HOST_EN 0x00008000
+/** Enable Power Down I2C
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_I2C 0x00004000
+/* Disable
+#define PDCFG_I2C_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_I2C_EN 0x00004000
+/** Enable Power Down SSC0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_SSC0 0x00002000
+/* Disable
+#define PDCFG_SSC0_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_SSC0_EN 0x00002000
+/** Enable Power Down ASC0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_ASC0 0x00001000
+/* Disable
+#define PDCFG_ASC0_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_ASC0_EN 0x00001000
+/** Enable Power Down ASC1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_ASC1 0x00000800
+/* Disable
+#define PDCFG_ASC1_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_ASC1_EN 0x00000800
+/** Enable Power Down DCDCAPD
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_DCDCAPD 0x00000400
+/* Disable
+#define PDCFG_DCDCAPD_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_DCDCAPD_EN 0x00000400
+/** Enable Power Down DCDCDDR
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_DCDCDDR 0x00000200
+/* Disable
+#define PDCFG_DCDCDDR_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_DCDCDDR_EN 0x00000200
+/** Enable Power Down DCDC1V0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_DCDC1V0 0x00000100
+/* Disable
+#define PDCFG_DCDC1V0_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_DCDC1V0_EN 0x00000100
+/** Enable Power Down TRC2MEM
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_TRC2MEM 0x00000040
+/* Disable
+#define PDCFG_TRC2MEM_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_TRC2MEM_EN 0x00000040
+/** Enable Power Down DDR
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_DDR 0x00000020
+/* Disable
+#define PDCFG_DDR_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_DDR_EN 0x00000020
+/** Enable Power Down EBU
+    Ignore this bit as power-gating is not supported for this chip. */
+#define PDCFG_EBU 0x00000010
+/* Disable
+#define PDCFG_EBU_DIS 0x00000000 */
+/** Enable */
+#define PDCFG_EBU_EN 0x00000010
+
+/* Fields of "CLKO Pad Control Register" */
+/** Ethernet Reference Clock CLKO Select
+    Selects the CLKO pad's input as source for the GPHY, SGMII PLLs. */
+#define CLKOC_ETHREF 0x00000002
+/* Not selected
+#define CLKOC_ETHREF_NSEL 0x00000000 */
+/** Selected */
+#define CLKOC_ETHREF_SEL 0x00000002
+/** Output Enable
+    Enables the output driver of the CLKO pad. */
+#define CLKOC_OEN 0x00000001
+/* Disable
+#define CLKOC_OEN_DIS 0x00000000 */
+/** Enable */
+#define CLKOC_OEN_EN 0x00000001
+
+/* Fields of "Infrastructure Control Register" */
+/** General Purpose Control
+    Backup bits. Currently they are connected as: bit 0 : connected to the configmode_on pin of the pinstrapping block. bit 1 : clock enable of the GPE primary clock. bits 3:2 : frequency select of the GPE primary clock. 00 = 769.2MHz, 01 = 625MHz, 10 = 555.6MHz, 11 = 500MHz All other bits are unconnected. */
+#define INFRAC_GP_MASK 0x1F000000
+/** field offset */
+#define INFRAC_GP_OFFSET 24
+/** CMOS2CML Ethernet Control
+    CMOS2CML Ethernet Control. */
+#define INFRAC_CMOS2CML_GPON_MASK 0x0000F000
+/** field offset */
+#define INFRAC_CMOS2CML_GPON_OFFSET 12
+/** CMOS2CML Ethernet Control
+    CMOS2CML Ethernet Control. */
+#define INFRAC_CMOS2CML_ETH_MASK 0x00000F00
+/** field offset */
+#define INFRAC_CMOS2CML_ETH_OFFSET 8
+/** Dying Gasp Enable
+    Enables the dying gasp detector. */
+#define INFRAC_DGASPEN 0x00000040
+/* Disable
+#define INFRAC_DGASPEN_DIS 0x00000000 */
+/** Enable */
+#define INFRAC_DGASPEN_EN 0x00000040
+/** Dying Gasp Hysteresis Control
+    Dying Gasp Hysteresis Control. */
+#define INFRAC_DGASPHYS_MASK 0x00000030
+/** field offset */
+#define INFRAC_DGASPHYS_OFFSET 4
+/** Linear Regulator 1.5V Enable
+    Enables 1.5V linear regulator. */
+#define INFRAC_LIN1V5EN 0x00000008
+/* Disable
+#define INFRAC_LIN1V5EN_DIS 0x00000000 */
+/** Enable */
+#define INFRAC_LIN1V5EN_EN 0x00000008
+/** Linear Regulator 1.5V Control
+    Linear regulator 1.5V control. */
+#define INFRAC_LIN1V5C_MASK 0x00000007
+/** field offset */
+#define INFRAC_LIN1V5C_OFFSET 0
+
+/* Fields of "HRST_OUT_N Control Register" */
+/** HRST_OUT_N Pin Value
+    Controls the value of the HRST_OUT_N pin. */
+#define HRSTOUTC_VALUE 0x00000001
+
+/* Fields of "EBU Clock Control Register" */
+/** EBU Clock Divider
+    Via this bit the frequency of the clock of the EBU can be selected. */
+#define EBUCC_EBUDIV 0x00000001
+/* Frequency set to 50MHz.
+#define EBUCC_EBUDIV_SELF50 0x00000000 */
+/** Frequency set to 100MHz. */
+#define EBUCC_EBUDIV_SELF100 0x00000001
+
+/* Fields of "Hardware Reset Control Register" */
+/** Trigger Hardware Reset
+    Via this bit a reset similar to e.g. a watchdog reset request can be triggered. The occurence of this trigger is reflected in register field CPU0RS.HWRS . */
+#define HRSTC_THRST 0x00000001
+/* No-Operation
+#define HRSTC_THRST_NOP 0x00000000 */
+/** Trigger */
+#define HRSTC_THRST_TRIG 0x00000001
+
+/* Fields of "NMI Status Register" */
+/** NMI Status Flag TEST
+    Shows whether the event NMI TEST occurred. */
+#define NMIS_TEST 0x00000100
+/* Nothing
+#define NMIS_TEST_NULL 0x00000000 */
+/** Read: Event occurred. */
+#define NMIS_TEST_EVOCC 0x00000100
+/** NMI Status Flag DGASP
+    Shows whether the event NMI DGASP occurred. */
+#define NMIS_DGASP 0x00000004
+/* Nothing
+#define NMIS_DGASP_NULL 0x00000000 */
+/** Read: Event occurred. */
+#define NMIS_DGASP_EVOCC 0x00000004
+/** NMI Status Flag HOST
+    Shows whether the event NMI HOST occurred. */
+#define NMIS_HOST 0x00000002
+/* Nothing
+#define NMIS_HOST_NULL 0x00000000 */
+/** Read: Event occurred. */
+#define NMIS_HOST_EVOCC 0x00000002
+/** NMI Status Flag PIN
+    Shows whether the event NMI PIN occurred. */
+#define NMIS_PIN 0x00000001
+/* Nothing
+#define NMIS_PIN_NULL 0x00000000 */
+/** Read: Event occurred. */
+#define NMIS_PIN_EVOCC 0x00000001
+
+/* Fields of "NMI Set Register" */
+/** Set NMI Status Flag TEST
+    Sets the corresponding NMI status flag. */
+#define NMISET_TEST 0x00000100
+/* Nothing
+#define NMISET_TEST_NULL 0x00000000 */
+/** Set */
+#define NMISET_TEST_SET 0x00000100
+/** Set NMI Status Flag DGASP
+    Sets the corresponding NMI status flag. */
+#define NMISET_DGASP 0x00000004
+/* Nothing
+#define NMISET_DGASP_NULL 0x00000000 */
+/** Set */
+#define NMISET_DGASP_SET 0x00000004
+/** Set NMI Status Flag HOST
+    Sets the corresponding NMI status flag. */
+#define NMISET_HOST 0x00000002
+/* Nothing
+#define NMISET_HOST_NULL 0x00000000 */
+/** Set */
+#define NMISET_HOST_SET 0x00000002
+/** Set NMI Status Flag PIN
+    Sets the corresponding NMI status flag. */
+#define NMISET_PIN 0x00000001
+/* Nothing
+#define NMISET_PIN_NULL 0x00000000 */
+/** Set */
+#define NMISET_PIN_SET 0x00000001
+
+/* Fields of "NMI Clear Register" */
+/** Clear NMI Status Flag TEST
+    Clears the corresponding NMI status flag. */
+#define NMICLR_TEST 0x00000100
+/* Nothing
+#define NMICLR_TEST_NULL 0x00000000 */
+/** Clear */
+#define NMICLR_TEST_CLR 0x00000100
+/** Clear NMI Status Flag DGASP
+    Clears the corresponding NMI status flag. */
+#define NMICLR_DGASP 0x00000004
+/* Nothing
+#define NMICLR_DGASP_NULL 0x00000000 */
+/** Clear */
+#define NMICLR_DGASP_CLR 0x00000004
+/** Clear NMI Status Flag HOST
+    Clears the corresponding NMI status flag. */
+#define NMICLR_HOST 0x00000002
+/* Nothing
+#define NMICLR_HOST_NULL 0x00000000 */
+/** Clear */
+#define NMICLR_HOST_CLR 0x00000002
+/** Clear NMI Status Flag PIN
+    Clears the corresponding NMI status flag. */
+#define NMICLR_PIN 0x00000001
+/* Nothing
+#define NMICLR_PIN_NULL 0x00000000 */
+/** Clear */
+#define NMICLR_PIN_CLR 0x00000001
+
+/* Fields of "NMI Test Configuration Register" */
+/** Enable NMI Test Feature
+    Enables the operation of the NMI TEST flag. This is the mask for the Non-Maskable-Interrupt dedicated to SW tests. All others cannot be masked. */
+#define NMITCFG_TEN 0x00000100
+/* Disable
+#define NMITCFG_TEN_DIS 0x00000000 */
+/** Enable */
+#define NMITCFG_TEN_EN 0x00000100
+
+/* Fields of "NMI VPE1 Control Register" */
+/** NMI VPE1 State
+    Reflects the state of the NMI signal towards VPE1. This bit is controlled by software only, there is no hardware NMI source dedicated to VPE1. So VPE0 could trigger an NMI at VPE1 using this bit in its own NMI-routine. */
+#define NMIVPE1C_NMI 0x00000001
+/* False
+#define NMIVPE1C_NMI_FALSE 0x00000000 */
+/** True */
+#define NMIVPE1C_NMI_TRUE 0x00000001
+
+/* Fields of "IRN Capture Register" */
+/** DCDCAPD Alarm
+    The DCDC Converter for the APD Supply submitted an alarm. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define IRNCR_DCDCAPD 0x00400000
+/* Nothing
+#define IRNCR_DCDCAPD_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define IRNCR_DCDCAPD_INTACK 0x00400000
+/** Read: Interrupt occurred. */
+#define IRNCR_DCDCAPD_INTOCC 0x00400000
+/** DCDCDDR Alarm
+    The DCDC Converter for the DDR Supply submitted an alarm. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define IRNCR_DCDCDDR 0x00200000
+/* Nothing
+#define IRNCR_DCDCDDR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define IRNCR_DCDCDDR_INTACK 0x00200000
+/** Read: Interrupt occurred. */
+#define IRNCR_DCDCDDR_INTOCC 0x00200000
+/** DCDC1V0 Alarm
+    The DCDC Converter for the 1.0 Volts submitted an alarm. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define IRNCR_DCDC1V0 0x00100000
+/* Nothing
+#define IRNCR_DCDC1V0_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define IRNCR_DCDC1V0_INTACK 0x00100000
+/** Read: Interrupt occurred. */
+#define IRNCR_DCDC1V0_INTOCC 0x00100000
+/** SIF0 wakeup request
+    SmartSlic Interface 0 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define IRNCR_SIF0 0x00010000
+/* Nothing
+#define IRNCR_SIF0_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define IRNCR_SIF0_INTACK 0x00010000
+/** Read: Interrupt occurred. */
+#define IRNCR_SIF0_INTOCC 0x00010000
+
+/* Fields of "IRN Interrupt Control Register" */
+/** DCDCAPD Alarm
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IRNICR_DCDCAPD 0x00400000
+/** DCDCDDR Alarm
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IRNICR_DCDCDDR 0x00200000
+/** DCDC1V0 Alarm
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IRNICR_DCDC1V0 0x00100000
+/** SIF0 wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IRNICR_SIF0 0x00010000
+
+/* Fields of "IRN Interrupt Enable Register" */
+/** DCDCAPD Alarm
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IRNEN_DCDCAPD 0x00400000
+/* Disable
+#define IRNEN_DCDCAPD_DIS 0x00000000 */
+/** Enable */
+#define IRNEN_DCDCAPD_EN 0x00400000
+/** DCDCDDR Alarm
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IRNEN_DCDCDDR 0x00200000
+/* Disable
+#define IRNEN_DCDCDDR_DIS 0x00000000 */
+/** Enable */
+#define IRNEN_DCDCDDR_EN 0x00200000
+/** DCDC1V0 Alarm
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IRNEN_DCDC1V0 0x00100000
+/* Disable
+#define IRNEN_DCDC1V0_DIS 0x00000000 */
+/** Enable */
+#define IRNEN_DCDC1V0_EN 0x00100000
+/** SIF0 wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IRNEN_SIF0 0x00010000
+/* Disable
+#define IRNEN_SIF0_DIS 0x00000000 */
+/** Enable */
+#define IRNEN_SIF0_EN 0x00010000
+
+/*! @} */ /* SYS1_REGISTER */
+
+#endif /* _sys1_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/sys_eth_reg.h b/arch/mips/include/asm/arch-falcon/sys_eth_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/sys_eth_reg.h
@@ -0,0 +1,1121 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _sys_eth_reg_h
+#define _sys_eth_reg_h
+
+/** \addtogroup SYS_ETH_REGISTER
+   @{
+*/
+/* access macros */
+#define sys_eth_r32(reg) reg_r32(&sys_eth->reg)
+#define sys_eth_w32(val, reg) reg_w32(val, &sys_eth->reg)
+#define sys_eth_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &sys_eth->reg)
+#define sys_eth_r32_table(reg, idx) reg_r32_table(sys_eth->reg, idx)
+#define sys_eth_w32_table(val, reg, idx) reg_w32_table(val, sys_eth->reg, idx)
+#define sys_eth_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, sys_eth->reg, idx)
+#define sys_eth_adr_table(reg, idx) adr_table(sys_eth->reg, idx)
+
+
+/** SYS_ETH register structure */
+struct gpon_reg_sys_eth
+{
+   /** Clock Status Register
+       Shows the clock enable bits for the domains. */
+   unsigned int clks; /* 0x00000000 */
+   /** Clock Enable Register
+       Via this register the clock enable bits for the domains can be set. */
+   unsigned int clken; /* 0x00000004 */
+   /** Clock Clear Register
+       Via this register the clock enable bits for the domains can be cleared. */
+   unsigned int clkclr; /* 0x00000008 */
+   /** Reserved */
+   unsigned int res_0[5]; /* 0x0000000C */
+   /** Activation Status Register
+       Shows the activation bits for the domains. */
+   unsigned int acts; /* 0x00000020 */
+   /** Activation Register
+       Via this register the activation bits for the domains can be set. */
+   unsigned int act; /* 0x00000024 */
+   /** Deactivation Register
+       Via this register the activation bits for the domains can be cleared. The clock to a deactivated domain is switched off regardless of the value of the clock enable bit, as it does not make sense to provide a clock to a domain in reset state. */
+   unsigned int deact; /* 0x00000028 */
+   /** Reboot Trigger Register
+       Via this register a reboot of the domains can be triggered. The selected domains are sent through reset. */
+   unsigned int rbt; /* 0x0000002C */
+   /** Reserved */
+   unsigned int res_1[32]; /* 0x00000030 */
+   /** External PHY Control Register */
+   unsigned int extphyc; /* 0x000000B0 */
+   /** Power Down Configuration Register
+       Via this register the configuration is done whether in case of deactivation the power supply of the domain shall be removed. */
+   unsigned int pdcfg; /* 0x000000B4 */
+   /** Datarate Control Register
+       Controls the datarate of the various physical layers. The contents of the writeable fields of this register shall not be changed during operation. */
+   unsigned int drc; /* 0x000000B8 */
+   /** GMAC Multiplexer Control Register
+       Controls the interconnect between GMACs and the various physical layers. All fields need to have a different content. If two GMACs are muxed to the same PHY unpredictable results may occur. The contents of this register shall not be changed during operation. */
+   unsigned int gmuxc; /* 0x000000BC */
+   /** Datarate Status Register
+       Shows the datarate of the GMACs. The datarate of a GMAC is derived from the datarate of the physical layer it is multiplexed to. This register is for debugging only. */
+   unsigned int drs; /* 0x000000C0 */
+   /** SGMII Control Register */
+   unsigned int sgmiic; /* 0x000000C4 */
+   /** Reserved */
+   unsigned int res_2[14]; /* 0x000000C8 */
+};
+
+
+/* Fields of "Clock Status Register" */
+/** GPHY1MII2 Clock Enable
+    Shows the clock enable bit for GPHY1MII2. */
+#define SYS_ETH_CLKS_GPHY1MII2 0x02000000
+/* Disable
+#define SYS_ETH_CLKS_GPHY1MII2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GPHY1MII2_EN 0x02000000
+/** GPHY0MII2 Clock Enable
+    Shows the clock enable bit for GPHY0MII2. */
+#define SYS_ETH_CLKS_GPHY0MII2 0x01000000
+/* Disable
+#define SYS_ETH_CLKS_GPHY0MII2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GPHY0MII2_EN 0x01000000
+/** PADCTRL2 Clock Enable
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_CLKS_PADCTRL2 0x00200000
+/* Disable
+#define SYS_ETH_CLKS_PADCTRL2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_PADCTRL2_EN 0x00200000
+/** PADCTRL0 Clock Enable
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_CLKS_PADCTRL0 0x00100000
+/* Disable
+#define SYS_ETH_CLKS_PADCTRL0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_PADCTRL0_EN 0x00100000
+/** P2 Clock Enable
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_CLKS_P2 0x00020000
+/* Disable
+#define SYS_ETH_CLKS_P2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_P2_EN 0x00020000
+/** P0 Clock Enable
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_CLKS_P0 0x00010000
+/* Disable
+#define SYS_ETH_CLKS_P0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_P0_EN 0x00010000
+/** xMII Clock Enable
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_CLKS_xMII 0x00000800
+/* Disable
+#define SYS_ETH_CLKS_xMII_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_xMII_EN 0x00000800
+/** SGMII Clock Enable
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKS_SGMII 0x00000400
+/* Disable
+#define SYS_ETH_CLKS_SGMII_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_SGMII_EN 0x00000400
+/** GPHY1 Clock Enable
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKS_GPHY1 0x00000200
+/* Disable
+#define SYS_ETH_CLKS_GPHY1_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GPHY1_EN 0x00000200
+/** GPHY0 Clock Enable
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKS_GPHY0 0x00000100
+/* Disable
+#define SYS_ETH_CLKS_GPHY0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GPHY0_EN 0x00000100
+/** MDIO Clock Enable
+    This domain contains the MDIO block. */
+#define SYS_ETH_CLKS_MDIO 0x00000080
+/* Disable
+#define SYS_ETH_CLKS_MDIO_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_MDIO_EN 0x00000080
+/** GMAC3 Clock Enable
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_CLKS_GMAC3 0x00000008
+/* Disable
+#define SYS_ETH_CLKS_GMAC3_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GMAC3_EN 0x00000008
+/** GMAC2 Clock Enable
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_CLKS_GMAC2 0x00000004
+/* Disable
+#define SYS_ETH_CLKS_GMAC2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GMAC2_EN 0x00000004
+/** GMAC1 Clock Enable
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_CLKS_GMAC1 0x00000002
+/* Disable
+#define SYS_ETH_CLKS_GMAC1_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GMAC1_EN 0x00000002
+/** GMAC0 Clock Enable
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_CLKS_GMAC0 0x00000001
+/* Disable
+#define SYS_ETH_CLKS_GMAC0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_CLKS_GMAC0_EN 0x00000001
+
+/* Fields of "Clock Enable Register" */
+/** Set Clock Enable GPHY1MII2
+    Sets the clock enable bit of the GPHY1MII2. */
+#define SYS_ETH_CLKEN_GPHY1MII2 0x02000000
+/* No-Operation
+#define SYS_ETH_CLKEN_GPHY1MII2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GPHY1MII2_SET 0x02000000
+/** Set Clock Enable GPHY0MII2
+    Sets the clock enable bit of the GPHY0MII2. */
+#define SYS_ETH_CLKEN_GPHY0MII2 0x01000000
+/* No-Operation
+#define SYS_ETH_CLKEN_GPHY0MII2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GPHY0MII2_SET 0x01000000
+/** Set Clock Enable PADCTRL2
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_CLKEN_PADCTRL2 0x00200000
+/* No-Operation
+#define SYS_ETH_CLKEN_PADCTRL2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_PADCTRL2_SET 0x00200000
+/** Set Clock Enable PADCTRL0
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_CLKEN_PADCTRL0 0x00100000
+/* No-Operation
+#define SYS_ETH_CLKEN_PADCTRL0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_PADCTRL0_SET 0x00100000
+/** Set Clock Enable P2
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_CLKEN_P2 0x00020000
+/* No-Operation
+#define SYS_ETH_CLKEN_P2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_P2_SET 0x00020000
+/** Set Clock Enable P0
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_CLKEN_P0 0x00010000
+/* No-Operation
+#define SYS_ETH_CLKEN_P0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_P0_SET 0x00010000
+/** Set Clock Enable xMII
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_CLKEN_xMII 0x00000800
+/* No-Operation
+#define SYS_ETH_CLKEN_xMII_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_xMII_SET 0x00000800
+/** Set Clock Enable SGMII
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKEN_SGMII 0x00000400
+/* No-Operation
+#define SYS_ETH_CLKEN_SGMII_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_SGMII_SET 0x00000400
+/** Set Clock Enable GPHY1
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKEN_GPHY1 0x00000200
+/* No-Operation
+#define SYS_ETH_CLKEN_GPHY1_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GPHY1_SET 0x00000200
+/** Set Clock Enable GPHY0
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKEN_GPHY0 0x00000100
+/* No-Operation
+#define SYS_ETH_CLKEN_GPHY0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GPHY0_SET 0x00000100
+/** Set Clock Enable MDIO
+    This domain contains the MDIO block. */
+#define SYS_ETH_CLKEN_MDIO 0x00000080
+/* No-Operation
+#define SYS_ETH_CLKEN_MDIO_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_MDIO_SET 0x00000080
+/** Set Clock Enable GMAC3
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_CLKEN_GMAC3 0x00000008
+/* No-Operation
+#define SYS_ETH_CLKEN_GMAC3_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GMAC3_SET 0x00000008
+/** Set Clock Enable GMAC2
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_CLKEN_GMAC2 0x00000004
+/* No-Operation
+#define SYS_ETH_CLKEN_GMAC2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GMAC2_SET 0x00000004
+/** Set Clock Enable GMAC1
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_CLKEN_GMAC1 0x00000002
+/* No-Operation
+#define SYS_ETH_CLKEN_GMAC1_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GMAC1_SET 0x00000002
+/** Set Clock Enable GMAC0
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_CLKEN_GMAC0 0x00000001
+/* No-Operation
+#define SYS_ETH_CLKEN_GMAC0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_CLKEN_GMAC0_SET 0x00000001
+
+/* Fields of "Clock Clear Register" */
+/** Clear Clock Enable GPHY1MII2
+    Clears the clock enable bit of the GPHY1MII2. */
+#define SYS_ETH_CLKCLR_GPHY1MII2 0x02000000
+/* No-Operation
+#define SYS_ETH_CLKCLR_GPHY1MII2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GPHY1MII2_CLR 0x02000000
+/** Clear Clock Enable GPHY0MII2
+    Clears the clock enable bit of the GPHY0MII2. */
+#define SYS_ETH_CLKCLR_GPHY0MII2 0x01000000
+/* No-Operation
+#define SYS_ETH_CLKCLR_GPHY0MII2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GPHY0MII2_CLR 0x01000000
+/** Clear Clock Enable PADCTRL2
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_CLKCLR_PADCTRL2 0x00200000
+/* No-Operation
+#define SYS_ETH_CLKCLR_PADCTRL2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_PADCTRL2_CLR 0x00200000
+/** Clear Clock Enable PADCTRL0
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_CLKCLR_PADCTRL0 0x00100000
+/* No-Operation
+#define SYS_ETH_CLKCLR_PADCTRL0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_PADCTRL0_CLR 0x00100000
+/** Clear Clock Enable P2
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_CLKCLR_P2 0x00020000
+/* No-Operation
+#define SYS_ETH_CLKCLR_P2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_P2_CLR 0x00020000
+/** Clear Clock Enable P0
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_CLKCLR_P0 0x00010000
+/* No-Operation
+#define SYS_ETH_CLKCLR_P0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_P0_CLR 0x00010000
+/** Clear Clock Enable xMII
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_CLKCLR_xMII 0x00000800
+/* No-Operation
+#define SYS_ETH_CLKCLR_xMII_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_xMII_CLR 0x00000800
+/** Clear Clock Enable SGMII
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKCLR_SGMII 0x00000400
+/* No-Operation
+#define SYS_ETH_CLKCLR_SGMII_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_SGMII_CLR 0x00000400
+/** Clear Clock Enable GPHY1
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKCLR_GPHY1 0x00000200
+/* No-Operation
+#define SYS_ETH_CLKCLR_GPHY1_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GPHY1_CLR 0x00000200
+/** Clear Clock Enable GPHY0
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_CLKCLR_GPHY0 0x00000100
+/* No-Operation
+#define SYS_ETH_CLKCLR_GPHY0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GPHY0_CLR 0x00000100
+/** Clear Clock Enable MDIO
+    This domain contains the MDIO block. */
+#define SYS_ETH_CLKCLR_MDIO 0x00000080
+/* No-Operation
+#define SYS_ETH_CLKCLR_MDIO_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_MDIO_CLR 0x00000080
+/** Clear Clock Enable GMAC3
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_CLKCLR_GMAC3 0x00000008
+/* No-Operation
+#define SYS_ETH_CLKCLR_GMAC3_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GMAC3_CLR 0x00000008
+/** Clear Clock Enable GMAC2
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_CLKCLR_GMAC2 0x00000004
+/* No-Operation
+#define SYS_ETH_CLKCLR_GMAC2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GMAC2_CLR 0x00000004
+/** Clear Clock Enable GMAC1
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_CLKCLR_GMAC1 0x00000002
+/* No-Operation
+#define SYS_ETH_CLKCLR_GMAC1_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GMAC1_CLR 0x00000002
+/** Clear Clock Enable GMAC0
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_CLKCLR_GMAC0 0x00000001
+/* No-Operation
+#define SYS_ETH_CLKCLR_GMAC0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_CLKCLR_GMAC0_CLR 0x00000001
+
+/* Fields of "Activation Status Register" */
+/** PADCTRL2 Status
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_ACTS_PADCTRL2 0x00200000
+/* The block is inactive.
+#define SYS_ETH_ACTS_PADCTRL2_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_PADCTRL2_ACT 0x00200000
+/** PADCTRL0 Status
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_ACTS_PADCTRL0 0x00100000
+/* The block is inactive.
+#define SYS_ETH_ACTS_PADCTRL0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_PADCTRL0_ACT 0x00100000
+/** P2 Status
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_ACTS_P2 0x00020000
+/* The block is inactive.
+#define SYS_ETH_ACTS_P2_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_P2_ACT 0x00020000
+/** P0 Status
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_ACTS_P0 0x00010000
+/* The block is inactive.
+#define SYS_ETH_ACTS_P0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_P0_ACT 0x00010000
+/** xMII Status
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_ACTS_xMII 0x00000800
+/* The block is inactive.
+#define SYS_ETH_ACTS_xMII_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_xMII_ACT 0x00000800
+/** SGMII Status
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_ACTS_SGMII 0x00000400
+/* The block is inactive.
+#define SYS_ETH_ACTS_SGMII_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_SGMII_ACT 0x00000400
+/** GPHY1 Status
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_ACTS_GPHY1 0x00000200
+/* The block is inactive.
+#define SYS_ETH_ACTS_GPHY1_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_GPHY1_ACT 0x00000200
+/** GPHY0 Status
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_ACTS_GPHY0 0x00000100
+/* The block is inactive.
+#define SYS_ETH_ACTS_GPHY0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_GPHY0_ACT 0x00000100
+/** MDIO Status
+    This domain contains the MDIO block. */
+#define SYS_ETH_ACTS_MDIO 0x00000080
+/* The block is inactive.
+#define SYS_ETH_ACTS_MDIO_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_MDIO_ACT 0x00000080
+/** GMAC3 Status
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_ACTS_GMAC3 0x00000008
+/* The block is inactive.
+#define SYS_ETH_ACTS_GMAC3_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_GMAC3_ACT 0x00000008
+/** GMAC2 Status
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_ACTS_GMAC2 0x00000004
+/* The block is inactive.
+#define SYS_ETH_ACTS_GMAC2_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_GMAC2_ACT 0x00000004
+/** GMAC1 Status
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_ACTS_GMAC1 0x00000002
+/* The block is inactive.
+#define SYS_ETH_ACTS_GMAC1_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_GMAC1_ACT 0x00000002
+/** GMAC0 Status
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_ACTS_GMAC0 0x00000001
+/* The block is inactive.
+#define SYS_ETH_ACTS_GMAC0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_ETH_ACTS_GMAC0_ACT 0x00000001
+
+/* Fields of "Activation Register" */
+/** Activate PADCTRL2
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_ACT_PADCTRL2 0x00200000
+/* No-Operation
+#define SYS_ETH_ACT_PADCTRL2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_PADCTRL2_SET 0x00200000
+/** Activate PADCTRL0
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_ACT_PADCTRL0 0x00100000
+/* No-Operation
+#define SYS_ETH_ACT_PADCTRL0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_PADCTRL0_SET 0x00100000
+/** Activate P2
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_ACT_P2 0x00020000
+/* No-Operation
+#define SYS_ETH_ACT_P2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_P2_SET 0x00020000
+/** Activate P0
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_ACT_P0 0x00010000
+/* No-Operation
+#define SYS_ETH_ACT_P0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_P0_SET 0x00010000
+/** Activate xMII
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_ACT_xMII 0x00000800
+/* No-Operation
+#define SYS_ETH_ACT_xMII_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_xMII_SET 0x00000800
+/** Activate SGMII
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_ACT_SGMII 0x00000400
+/* No-Operation
+#define SYS_ETH_ACT_SGMII_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_SGMII_SET 0x00000400
+/** Activate GPHY1
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_ACT_GPHY1 0x00000200
+/* No-Operation
+#define SYS_ETH_ACT_GPHY1_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_GPHY1_SET 0x00000200
+/** Activate GPHY0
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_ACT_GPHY0 0x00000100
+/* No-Operation
+#define SYS_ETH_ACT_GPHY0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_GPHY0_SET 0x00000100
+/** Activate MDIO
+    This domain contains the MDIO block. */
+#define SYS_ETH_ACT_MDIO 0x00000080
+/* No-Operation
+#define SYS_ETH_ACT_MDIO_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_MDIO_SET 0x00000080
+/** Activate GMAC3
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_ACT_GMAC3 0x00000008
+/* No-Operation
+#define SYS_ETH_ACT_GMAC3_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_GMAC3_SET 0x00000008
+/** Activate GMAC2
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_ACT_GMAC2 0x00000004
+/* No-Operation
+#define SYS_ETH_ACT_GMAC2_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_GMAC2_SET 0x00000004
+/** Activate GMAC1
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_ACT_GMAC1 0x00000002
+/* No-Operation
+#define SYS_ETH_ACT_GMAC1_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_GMAC1_SET 0x00000002
+/** Activate GMAC0
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_ACT_GMAC0 0x00000001
+/* No-Operation
+#define SYS_ETH_ACT_GMAC0_NOP 0x00000000 */
+/** Set */
+#define SYS_ETH_ACT_GMAC0_SET 0x00000001
+
+/* Fields of "Deactivation Register" */
+/** Deactivate PADCTRL2
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_DEACT_PADCTRL2 0x00200000
+/* No-Operation
+#define SYS_ETH_DEACT_PADCTRL2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_PADCTRL2_CLR 0x00200000
+/** Deactivate PADCTRL0
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_DEACT_PADCTRL0 0x00100000
+/* No-Operation
+#define SYS_ETH_DEACT_PADCTRL0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_PADCTRL0_CLR 0x00100000
+/** Deactivate P2
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_DEACT_P2 0x00020000
+/* No-Operation
+#define SYS_ETH_DEACT_P2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_P2_CLR 0x00020000
+/** Deactivate P0
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_DEACT_P0 0x00010000
+/* No-Operation
+#define SYS_ETH_DEACT_P0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_P0_CLR 0x00010000
+/** Deactivate xMII
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_DEACT_xMII 0x00000800
+/* No-Operation
+#define SYS_ETH_DEACT_xMII_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_xMII_CLR 0x00000800
+/** Deactivate SGMII
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_DEACT_SGMII 0x00000400
+/* No-Operation
+#define SYS_ETH_DEACT_SGMII_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_SGMII_CLR 0x00000400
+/** Deactivate GPHY1
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_DEACT_GPHY1 0x00000200
+/* No-Operation
+#define SYS_ETH_DEACT_GPHY1_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_GPHY1_CLR 0x00000200
+/** Deactivate GPHY0
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_DEACT_GPHY0 0x00000100
+/* No-Operation
+#define SYS_ETH_DEACT_GPHY0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_GPHY0_CLR 0x00000100
+/** Deactivate MDIO
+    This domain contains the MDIO block. */
+#define SYS_ETH_DEACT_MDIO 0x00000080
+/* No-Operation
+#define SYS_ETH_DEACT_MDIO_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_MDIO_CLR 0x00000080
+/** Deactivate GMAC3
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_DEACT_GMAC3 0x00000008
+/* No-Operation
+#define SYS_ETH_DEACT_GMAC3_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_GMAC3_CLR 0x00000008
+/** Deactivate GMAC2
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_DEACT_GMAC2 0x00000004
+/* No-Operation
+#define SYS_ETH_DEACT_GMAC2_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_GMAC2_CLR 0x00000004
+/** Deactivate GMAC1
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_DEACT_GMAC1 0x00000002
+/* No-Operation
+#define SYS_ETH_DEACT_GMAC1_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_GMAC1_CLR 0x00000002
+/** Deactivate GMAC0
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_DEACT_GMAC0 0x00000001
+/* No-Operation
+#define SYS_ETH_DEACT_GMAC0_NOP 0x00000000 */
+/** Clear */
+#define SYS_ETH_DEACT_GMAC0_CLR 0x00000001
+
+/* Fields of "Reboot Trigger Register" */
+/** Reboot PADCTRL2
+    This domain contains the PADCTRL2 block. */
+#define SYS_ETH_RBT_PADCTRL2 0x00200000
+/* No-Operation
+#define SYS_ETH_RBT_PADCTRL2_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_PADCTRL2_TRIG 0x00200000
+/** Reboot PADCTRL0
+    This domain contains the PADCTRL0 block. */
+#define SYS_ETH_RBT_PADCTRL0 0x00100000
+/* No-Operation
+#define SYS_ETH_RBT_PADCTRL0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_PADCTRL0_TRIG 0x00100000
+/** Reboot P2
+    This domain contains the P2 instance of the GPIO block. */
+#define SYS_ETH_RBT_P2 0x00020000
+/* No-Operation
+#define SYS_ETH_RBT_P2_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_P2_TRIG 0x00020000
+/** Reboot P0
+    This domain contains the P0 instance of the GPIO block. */
+#define SYS_ETH_RBT_P0 0x00010000
+/* No-Operation
+#define SYS_ETH_RBT_P0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_P0_TRIG 0x00010000
+/** Reboot xMII
+    This domain contains the XMII block. If any of the digital LAN interfaces shall be used, this domain has to be active. */
+#define SYS_ETH_RBT_xMII 0x00000800
+/* No-Operation
+#define SYS_ETH_RBT_xMII_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_xMII_TRIG 0x00000800
+/** Reboot SGMII
+    This domain contains all parts of the EIM related to the SGMII block. The SGMII block itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_RBT_SGMII 0x00000400
+/* No-Operation
+#define SYS_ETH_RBT_SGMII_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_SGMII_TRIG 0x00000400
+/** Reboot GPHY1
+    This domain contains all parts of the EIM related to GPHY1. The GPHY1 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_RBT_GPHY1 0x00000200
+/* No-Operation
+#define SYS_ETH_RBT_GPHY1_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_GPHY1_TRIG 0x00000200
+/** Reboot GPHY0
+    This domain contains all parts of the EIM related to GPHY0. The GPHY0 itself is not contained, as it has its own clock/reset/power management. */
+#define SYS_ETH_RBT_GPHY0 0x00000100
+/* No-Operation
+#define SYS_ETH_RBT_GPHY0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_GPHY0_TRIG 0x00000100
+/** Reboot MDIO
+    This domain contains the MDIO block. */
+#define SYS_ETH_RBT_MDIO 0x00000080
+/* No-Operation
+#define SYS_ETH_RBT_MDIO_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_MDIO_TRIG 0x00000080
+/** Reboot GMAC3
+    This domain contains the GMAC3 block. */
+#define SYS_ETH_RBT_GMAC3 0x00000008
+/* No-Operation
+#define SYS_ETH_RBT_GMAC3_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_GMAC3_TRIG 0x00000008
+/** Reboot GMAC2
+    This domain contains the GMAC2 block. */
+#define SYS_ETH_RBT_GMAC2 0x00000004
+/* No-Operation
+#define SYS_ETH_RBT_GMAC2_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_GMAC2_TRIG 0x00000004
+/** Reboot GMAC1
+    This domain contains the GMAC1 block. */
+#define SYS_ETH_RBT_GMAC1 0x00000002
+/* No-Operation
+#define SYS_ETH_RBT_GMAC1_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_GMAC1_TRIG 0x00000002
+/** Reboot GMAC0
+    This domain contains the GMAC0 block. */
+#define SYS_ETH_RBT_GMAC0 0x00000001
+/* No-Operation
+#define SYS_ETH_RBT_GMAC0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_ETH_RBT_GMAC0_TRIG 0x00000001
+
+/* Fields of "External PHY Control Register" */
+/** PHY_CLKO Output Enable
+    Enables the output driver of the PHY_CLKO pin. */
+#define SYS_ETH_EXTPHYC_CLKEN 0x80000000
+/* Disable
+#define SYS_ETH_EXTPHYC_CLKEN_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_EXTPHYC_CLKEN_EN 0x80000000
+/** PHY_CLKO Frequency Select
+    Selects the frequency of the PHY_CLKO pin. */
+#define SYS_ETH_EXTPHYC_CLKSEL_MASK 0x00000007
+/** field offset */
+#define SYS_ETH_EXTPHYC_CLKSEL_OFFSET 0
+/** 25 MHz. */
+#define SYS_ETH_EXTPHYC_CLKSEL_F25 0x00000001
+/** 125 MHz. */
+#define SYS_ETH_EXTPHYC_CLKSEL_F125 0x00000002
+/** 50 MHz. */
+#define SYS_ETH_EXTPHYC_CLKSEL_F50 0x00000005
+
+/* Fields of "Power Down Configuration Register" */
+/** Enable Power Down PADCTRL2
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_PADCTRL2 0x00200000
+/* Disable
+#define SYS_ETH_PDCFG_PADCTRL2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_PADCTRL2_EN 0x00200000
+/** Enable Power Down PADCTRL0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_PADCTRL0 0x00100000
+/* Disable
+#define SYS_ETH_PDCFG_PADCTRL0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_PADCTRL0_EN 0x00100000
+/** Enable Power Down P2
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_P2 0x00020000
+/* Disable
+#define SYS_ETH_PDCFG_P2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_P2_EN 0x00020000
+/** Enable Power Down P0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_P0 0x00010000
+/* Disable
+#define SYS_ETH_PDCFG_P0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_P0_EN 0x00010000
+/** Enable Power Down xMII
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_xMII 0x00000800
+/* Disable
+#define SYS_ETH_PDCFG_xMII_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_xMII_EN 0x00000800
+/** Enable Power Down SGMII
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_SGMII 0x00000400
+/* Disable
+#define SYS_ETH_PDCFG_SGMII_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_SGMII_EN 0x00000400
+/** Enable Power Down GPHY1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_GPHY1 0x00000200
+/* Disable
+#define SYS_ETH_PDCFG_GPHY1_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_GPHY1_EN 0x00000200
+/** Enable Power Down GPHY0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_GPHY0 0x00000100
+/* Disable
+#define SYS_ETH_PDCFG_GPHY0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_GPHY0_EN 0x00000100
+/** Enable Power Down MDIO
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_MDIO 0x00000080
+/* Disable
+#define SYS_ETH_PDCFG_MDIO_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_MDIO_EN 0x00000080
+/** Enable Power Down GMAC3
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_GMAC3 0x00000008
+/* Disable
+#define SYS_ETH_PDCFG_GMAC3_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_GMAC3_EN 0x00000008
+/** Enable Power Down GMAC2
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_GMAC2 0x00000004
+/* Disable
+#define SYS_ETH_PDCFG_GMAC2_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_GMAC2_EN 0x00000004
+/** Enable Power Down GMAC1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_GMAC1 0x00000002
+/* Disable
+#define SYS_ETH_PDCFG_GMAC1_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_GMAC1_EN 0x00000002
+/** Enable Power Down GMAC0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_ETH_PDCFG_GMAC0 0x00000001
+/* Disable
+#define SYS_ETH_PDCFG_GMAC0_DIS 0x00000000 */
+/** Enable */
+#define SYS_ETH_PDCFG_GMAC0_EN 0x00000001
+
+/* Fields of "Datarate Control Register" */
+/** xMII1 Datarate
+    Selects the datarate of the xMII1 interface. */
+#define SYS_ETH_DRC_xMII1_MASK 0x07000000
+/** field offset */
+#define SYS_ETH_DRC_xMII1_OFFSET 24
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_xMII1_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_xMII1_DR100 0x01000000
+/** 1000 MBit/s. */
+#define SYS_ETH_DRC_xMII1_DR1000 0x02000000
+/** 200 MBit/s. */
+#define SYS_ETH_DRC_xMII1_DR200 0x05000000
+/** xMII0 Datarate
+    Selects the datarate of the xMII0 interface. */
+#define SYS_ETH_DRC_xMII0_MASK 0x00700000
+/** field offset */
+#define SYS_ETH_DRC_xMII0_OFFSET 20
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_xMII0_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_xMII0_DR100 0x00100000
+/** 1000 MBit/s. */
+#define SYS_ETH_DRC_xMII0_DR1000 0x00200000
+/** 200 MBit/s. */
+#define SYS_ETH_DRC_xMII0_DR200 0x00500000
+/** SGMII Datarate
+    Selects the datarate of the SGMII interface. */
+#define SYS_ETH_DRC_SGMII_MASK 0x00070000
+/** field offset */
+#define SYS_ETH_DRC_SGMII_OFFSET 16
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_SGMII_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_SGMII_DR100 0x00010000
+/** 1000 MBit/s. */
+#define SYS_ETH_DRC_SGMII_DR1000 0x00020000
+/** 2500 MBit/s. */
+#define SYS_ETH_DRC_SGMII_DR2500 0x00040000
+/** GPHY1_MII2 Datarate
+    Shows the datarate of the GPHY1_MII2 interface. */
+#define SYS_ETH_DRC_GPHY1_MII2_MASK 0x00007000
+/** field offset */
+#define SYS_ETH_DRC_GPHY1_MII2_OFFSET 12
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_GPHY1_MII2_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_GPHY1_MII2_DR100 0x00001000
+/** GPHY1_GMII Datarate
+    Shows the datarate of the GPHY1_GMII interface. */
+#define SYS_ETH_DRC_GPHY1_GMII_MASK 0x00000700
+/** field offset */
+#define SYS_ETH_DRC_GPHY1_GMII_OFFSET 8
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_GPHY1_GMII_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_GPHY1_GMII_DR100 0x00000100
+/** 1000 MBit/s. */
+#define SYS_ETH_DRC_GPHY1_GMII_DR1000 0x00000200
+/** GPHY0_MII2 Datarate
+    Shows the datarate of the GPHY0_MII2 interface. */
+#define SYS_ETH_DRC_GPHY0_MII2_MASK 0x00000070
+/** field offset */
+#define SYS_ETH_DRC_GPHY0_MII2_OFFSET 4
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_GPHY0_MII2_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_GPHY0_MII2_DR100 0x00000010
+/** GPHY0_GMII Datarate
+    Shows the datarate of the GPHY0_GMII interface. */
+#define SYS_ETH_DRC_GPHY0_GMII_MASK 0x00000007
+/** field offset */
+#define SYS_ETH_DRC_GPHY0_GMII_OFFSET 0
+/** 10 MBit/s. */
+#define SYS_ETH_DRC_GPHY0_GMII_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRC_GPHY0_GMII_DR100 0x00000001
+/** 1000 MBit/s. */
+#define SYS_ETH_DRC_GPHY0_GMII_DR1000 0x00000002
+
+/* Fields of "GMAC Multiplexer Control Register" */
+/** GMAC 3 MUX setting
+    Selects the physical layer to be connected to GMAC3 */
+#define SYS_ETH_GMUXC_GMAC3_MASK 0x00007000
+/** field offset */
+#define SYS_ETH_GMUXC_GMAC3_OFFSET 12
+/** GMAC connects to GPHY0_GMII interface */
+#define SYS_ETH_GMUXC_GMAC3_GPHY0_GMII 0x00000000
+/** GMAC connects to GPHY0_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC3_GPHY0_MII2 0x00001000
+/** GMAC connects to GPHY1_GMII interface */
+#define SYS_ETH_GMUXC_GMAC3_GPHY1_GMII 0x00002000
+/** GMAC connects to GPHY1_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC3_GPHY1_MII2 0x00003000
+/** GMAC connects to SGMII interface */
+#define SYS_ETH_GMUXC_GMAC3_SGMII 0x00004000
+/** GMAC connects to xMII0 interface */
+#define SYS_ETH_GMUXC_GMAC3_xMII0 0x00005000
+/** GMAC connects to xMII1 interface */
+#define SYS_ETH_GMUXC_GMAC3_xMII1 0x00006000
+/** GMAC 2 MUX setting
+    Selects the physical layer to be connected to GMAC2 */
+#define SYS_ETH_GMUXC_GMAC2_MASK 0x00000700
+/** field offset */
+#define SYS_ETH_GMUXC_GMAC2_OFFSET 8
+/** GMAC connects to GPHY0_GMII interface */
+#define SYS_ETH_GMUXC_GMAC2_GPHY0_GMII 0x00000000
+/** GMAC connects to GPHY0_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC2_GPHY0_MII2 0x00000100
+/** GMAC connects to GPHY1_GMII interface */
+#define SYS_ETH_GMUXC_GMAC2_GPHY1_GMII 0x00000200
+/** GMAC connects to GPHY1_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC2_GPHY1_MII2 0x00000300
+/** GMAC connects to SGMII interface */
+#define SYS_ETH_GMUXC_GMAC2_SGMII 0x00000400
+/** GMAC connects to xMII0 interface */
+#define SYS_ETH_GMUXC_GMAC2_xMII0 0x00000500
+/** GMAC connects to xMII1 interface */
+#define SYS_ETH_GMUXC_GMAC2_xMII1 0x00000600
+/** GMAC 1 MUX setting
+    Selects the physical layer to be connected to GMAC1 */
+#define SYS_ETH_GMUXC_GMAC1_MASK 0x00000070
+/** field offset */
+#define SYS_ETH_GMUXC_GMAC1_OFFSET 4
+/** GMAC connects to GPHY0_GMII interface */
+#define SYS_ETH_GMUXC_GMAC1_GPHY0_GMII 0x00000000
+/** GMAC connects to GPHY0_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC1_GPHY0_MII2 0x00000010
+/** GMAC connects to GPHY1_GMII interface */
+#define SYS_ETH_GMUXC_GMAC1_GPHY1_GMII 0x00000020
+/** GMAC connects to GPHY1_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC1_GPHY1_MII2 0x00000030
+/** GMAC connects to SGMII interface */
+#define SYS_ETH_GMUXC_GMAC1_SGMII 0x00000040
+/** GMAC connects to xMII0 interface */
+#define SYS_ETH_GMUXC_GMAC1_xMII0 0x00000050
+/** GMAC connects to xMII1 interface */
+#define SYS_ETH_GMUXC_GMAC1_xMII1 0x00000060
+/** GMAC 0 MUX setting
+    Selects the physical layer to be connected to GMAC0 */
+#define SYS_ETH_GMUXC_GMAC0_MASK 0x00000007
+/** field offset */
+#define SYS_ETH_GMUXC_GMAC0_OFFSET 0
+/** GMAC connects to GPHY0_GMII interface */
+#define SYS_ETH_GMUXC_GMAC0_GPHY0_GMII 0x00000000
+/** GMAC connects to GPHY0_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC0_GPHY0_MII2 0x00000001
+/** GMAC connects to GPHY1_GMII interface */
+#define SYS_ETH_GMUXC_GMAC0_GPHY1_GMII 0x00000002
+/** GMAC connects to GPHY1_MII2 interface */
+#define SYS_ETH_GMUXC_GMAC0_GPHY1_MII2 0x00000003
+/** GMAC connects to SGMII interface */
+#define SYS_ETH_GMUXC_GMAC0_SGMII 0x00000004
+/** GMAC connects to xMII0 interface */
+#define SYS_ETH_GMUXC_GMAC0_xMII0 0x00000005
+/** GMAC connects to xMII1 interface */
+#define SYS_ETH_GMUXC_GMAC0_xMII1 0x00000006
+
+/* Fields of "Datarate Status Register" */
+/** GMAC 3 datarate
+    Shows the datarate of GMAC3 */
+#define SYS_ETH_DRS_GMAC3_MASK 0x00007000
+/** field offset */
+#define SYS_ETH_DRS_GMAC3_OFFSET 12
+/** 10 MBit/s. */
+#define SYS_ETH_DRS_GMAC3_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRS_GMAC3_DR100 0x00001000
+/** 1000 MBit/s. */
+#define SYS_ETH_DRS_GMAC3_DR1000 0x00002000
+/** 2500 MBit/s. */
+#define SYS_ETH_DRS_GMAC3_DR2500 0x00004000
+/** 200 MBit/s. */
+#define SYS_ETH_DRS_GMAC3_DR200 0x00005000
+/** GMAC 2 datarate
+    Shows the datarate of GMAC2 */
+#define SYS_ETH_DRS_GMAC2_MASK 0x00000700
+/** field offset */
+#define SYS_ETH_DRS_GMAC2_OFFSET 8
+/** 10 MBit/s. */
+#define SYS_ETH_DRS_GMAC2_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRS_GMAC2_DR100 0x00000100
+/** 1000 MBit/s. */
+#define SYS_ETH_DRS_GMAC2_DR1000 0x00000200
+/** 2500 MBit/s. */
+#define SYS_ETH_DRS_GMAC2_DR2500 0x00000400
+/** 200 MBit/s. */
+#define SYS_ETH_DRS_GMAC2_DR200 0x00000500
+/** GMAC 1 datarate
+    Shows the datarate of GMAC1 */
+#define SYS_ETH_DRS_GMAC1_MASK 0x00000070
+/** field offset */
+#define SYS_ETH_DRS_GMAC1_OFFSET 4
+/** 10 MBit/s. */
+#define SYS_ETH_DRS_GMAC1_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRS_GMAC1_DR100 0x00000010
+/** 1000 MBit/s. */
+#define SYS_ETH_DRS_GMAC1_DR1000 0x00000020
+/** 2500 MBit/s. */
+#define SYS_ETH_DRS_GMAC1_DR2500 0x00000040
+/** 200 MBit/s. */
+#define SYS_ETH_DRS_GMAC1_DR200 0x00000050
+/** GMAC 0 datarate
+    Shows the datarate of GMAC0 */
+#define SYS_ETH_DRS_GMAC0_MASK 0x00000007
+/** field offset */
+#define SYS_ETH_DRS_GMAC0_OFFSET 0
+/** 10 MBit/s. */
+#define SYS_ETH_DRS_GMAC0_DR10 0x00000000
+/** 100 MBit/s. */
+#define SYS_ETH_DRS_GMAC0_DR100 0x00000001
+/** 1000 MBit/s. */
+#define SYS_ETH_DRS_GMAC0_DR1000 0x00000002
+/** 2500 MBit/s. */
+#define SYS_ETH_DRS_GMAC0_DR2500 0x00000004
+/** 200 MBit/s. */
+#define SYS_ETH_DRS_GMAC0_DR200 0x00000005
+
+/* Fields of "SGMII Control Register" */
+/** Auto Negotiation Protocol
+    Selects the TBX/SGMII mode for the autonegotiation of the SGMII interface. */
+#define SYS_ETH_SGMIIC_ANP 0x00000002
+/* TBX Mode (IEEE 802.3 Clause 37 ANEG)
+#define SYS_ETH_SGMIIC_ANP_TBXM 0x00000000 */
+/** SGMII Mode (Cisco Aneg) */
+#define SYS_ETH_SGMIIC_ANP_SGMIIM 0x00000002
+/** Auto Negotiation MAC/PHY
+    Selects the MAC/PHY mode for the autonegotiation of the SGMII interface. */
+#define SYS_ETH_SGMIIC_ANMP 0x00000001
+/* MAC Mode
+#define SYS_ETH_SGMIIC_ANMP_MAC 0x00000000 */
+/** PHY Mode */
+#define SYS_ETH_SGMIIC_ANMP_PHY 0x00000001
+
+/*! @} */ /* SYS_ETH_REGISTER */
+
+#endif /* _sys_eth_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/sys_gpe_reg.h b/arch/mips/include/asm/arch-falcon/sys_gpe_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/sys_gpe_reg.h
@@ -0,0 +1,2830 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _sys_gpe_reg_h
+#define _sys_gpe_reg_h
+
+/** \addtogroup SYS_GPE_REGISTER
+   @{
+*/
+/* access macros */
+#define sys_gpe_r32(reg) reg_r32(&sys_gpe->reg)
+#define sys_gpe_w32(val, reg) reg_w32(val, &sys_gpe->reg)
+#define sys_gpe_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &sys_gpe->reg)
+#define sys_gpe_r32_table(reg, idx) reg_r32_table(sys_gpe->reg, idx)
+#define sys_gpe_w32_table(val, reg, idx) reg_w32_table(val, sys_gpe->reg, idx)
+#define sys_gpe_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, sys_gpe->reg, idx)
+#define sys_gpe_adr_table(reg, idx) adr_table(sys_gpe->reg, idx)
+
+
+/** SYS_GPE register structure */
+struct gpon_reg_sys_gpe
+{
+   /** Clock Status Register
+       Shows the clock enable bits for the domains. The clock status reflects the actual clocking mode as a function of the SW settings and the hardware sleep mode. */
+   unsigned int clks; /* 0x00000000 */
+   /** Clock Enable Register
+       Via this register the clock enable bits for the domains can be set. */
+   unsigned int clken; /* 0x00000004 */
+   /** Clock Clear Register
+       Via this register the clock enable bits for the domains can be cleared. */
+   unsigned int clkclr; /* 0x00000008 */
+   /** Reserved */
+   unsigned int res_0[5]; /* 0x0000000C */
+   /** Activation Status Register
+       Shows the activation bits for the domains. */
+   unsigned int acts; /* 0x00000020 */
+   /** Activation Register
+       Via this register the activation bits for the domains can be set. */
+   unsigned int act; /* 0x00000024 */
+   /** Deactivation Register
+       Via this register the activation bits for the domains can be cleared. The clock to a deactivated domain is switched off regardless of the value of the clock enable bit, as it does not make sense to provide a clock to a domain in reset state. */
+   unsigned int deact; /* 0x00000028 */
+   /** Reboot Trigger Register
+       Via this register a reboot of the domains can be triggered. The selected domains are sent through reset. */
+   unsigned int rbt; /* 0x0000002C */
+   /** Reserved */
+   unsigned int res_1[33]; /* 0x00000030 */
+   /** Power Down Configuration Register
+       Via this register the configuration is done whether in case of deactivation the power supply of the domain shall be removed. */
+   unsigned int pdcfg; /* 0x000000B4 */
+   /** Sleep Source Configuration Register
+       All sleep/wakeup conditions selected in this register contribute to the generation of the hardware sleep/wakeup request. Unselected conditions are ignored for sleep and wakeup. If no bit is selected, HW sleep is disabled. */
+   unsigned int sscfg; /* 0x000000B8 */
+   /** Sleep Source Timer Register */
+   unsigned int sst; /* 0x000000BC */
+   /** Sleep Destination Status Register
+       Shows the status of the sleep destination vector. All clock domains selected in this register will be shutoff in case of a hardware sleep request. These clocks will be automatically reenabled in case of a hardware wakeup request. */
+   unsigned int sds; /* 0x000000C0 */
+   /** Sleep Destination Set Register
+       Via this register the domains to be shutoff in case of a hardware sleep request can be selected. */
+   unsigned int sdset; /* 0x000000C4 */
+   /** Sleep Destination Clear Register
+       Via this register the domains to be shutoff in case of a hardware sleep request can be deselected. */
+   unsigned int sdclr; /* 0x000000C8 */
+   /** Reserved */
+   unsigned int res_2[9]; /* 0x000000CC */
+   /** IRNCS Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNCSEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncscr; /* 0x000000F0 */
+   /** IRNCS Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irncsicr; /* 0x000000F4 */
+   /** IRNCS Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCSCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irncsen; /* 0x000000F8 */
+   /** Reserved */
+   unsigned int res_3; /* 0x000000FC */
+};
+
+
+/* Fields of "Clock Status Register" */
+/** COP7 Clock Enable
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_CLKS_COP7 0x80000000
+/* Disable
+#define SYS_GPE_CLKS_COP7_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP7_EN 0x80000000
+/** COP6 Clock Enable
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_CLKS_COP6 0x40000000
+/* Disable
+#define SYS_GPE_CLKS_COP6_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP6_EN 0x40000000
+/** COP5 Clock Enable
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_CLKS_COP5 0x20000000
+/* Disable
+#define SYS_GPE_CLKS_COP5_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP5_EN 0x20000000
+/** COP4 Clock Enable
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_CLKS_COP4 0x10000000
+/* Disable
+#define SYS_GPE_CLKS_COP4_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP4_EN 0x10000000
+/** COP3 Clock Enable
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_CLKS_COP3 0x08000000
+/* Disable
+#define SYS_GPE_CLKS_COP3_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP3_EN 0x08000000
+/** COP2 Clock Enable
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_CLKS_COP2 0x04000000
+/* Disable
+#define SYS_GPE_CLKS_COP2_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP2_EN 0x04000000
+/** COP1 Clock Enable
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_CLKS_COP1 0x02000000
+/* Disable
+#define SYS_GPE_CLKS_COP1_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP1_EN 0x02000000
+/** COP0 Clock Enable
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_CLKS_COP0 0x01000000
+/* Disable
+#define SYS_GPE_CLKS_COP0_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_COP0_EN 0x01000000
+/** PE5 Clock Enable
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_CLKS_PE5 0x00200000
+/* Disable
+#define SYS_GPE_CLKS_PE5_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_PE5_EN 0x00200000
+/** PE4 Clock Enable
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_CLKS_PE4 0x00100000
+/* Disable
+#define SYS_GPE_CLKS_PE4_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_PE4_EN 0x00100000
+/** PE3 Clock Enable
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_CLKS_PE3 0x00080000
+/* Disable
+#define SYS_GPE_CLKS_PE3_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_PE3_EN 0x00080000
+/** PE2 Clock Enable
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_CLKS_PE2 0x00040000
+/* Disable
+#define SYS_GPE_CLKS_PE2_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_PE2_EN 0x00040000
+/** PE1 Clock Enable
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_CLKS_PE1 0x00020000
+/* Disable
+#define SYS_GPE_CLKS_PE1_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_PE1_EN 0x00020000
+/** PE0 Clock Enable
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_CLKS_PE0 0x00010000
+/* Disable
+#define SYS_GPE_CLKS_PE0_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_PE0_EN 0x00010000
+/** ARB Clock Enable
+    This domain contains the Arbiter. */
+#define SYS_GPE_CLKS_ARB 0x00002000
+/* Disable
+#define SYS_GPE_CLKS_ARB_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_ARB_EN 0x00002000
+/** FSQM Clock Enable
+    This domain contains the FSQM. */
+#define SYS_GPE_CLKS_FSQM 0x00001000
+/* Disable
+#define SYS_GPE_CLKS_FSQM_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_FSQM_EN 0x00001000
+/** TMU Clock Enable
+    This domain contains the TMU. */
+#define SYS_GPE_CLKS_TMU 0x00000800
+/* Disable
+#define SYS_GPE_CLKS_TMU_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_TMU_EN 0x00000800
+/** MRG Clock Enable
+    This domain contains the Merger. */
+#define SYS_GPE_CLKS_MRG 0x00000400
+/* Disable
+#define SYS_GPE_CLKS_MRG_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_MRG_EN 0x00000400
+/** DISP Clock Enable
+    This domain contains the Dispatcher. */
+#define SYS_GPE_CLKS_DISP 0x00000200
+/* Disable
+#define SYS_GPE_CLKS_DISP_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_DISP_EN 0x00000200
+/** IQM Clock Enable
+    This domain contains the IQM. */
+#define SYS_GPE_CLKS_IQM 0x00000100
+/* Disable
+#define SYS_GPE_CLKS_IQM_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_IQM_EN 0x00000100
+/** CPUE Clock Enable
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_CLKS_CPUE 0x00000080
+/* Disable
+#define SYS_GPE_CLKS_CPUE_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_CPUE_EN 0x00000080
+/** CPUI Clock Enable
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_CLKS_CPUI 0x00000040
+/* Disable
+#define SYS_GPE_CLKS_CPUI_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_CPUI_EN 0x00000040
+/** GPONE Clock Enable
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_CLKS_GPONE 0x00000020
+/* Disable
+#define SYS_GPE_CLKS_GPONE_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_GPONE_EN 0x00000020
+/** GPONI Clock Enable
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_CLKS_GPONI 0x00000010
+/* Disable
+#define SYS_GPE_CLKS_GPONI_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_GPONI_EN 0x00000010
+/** LAN3 Clock Enable
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_CLKS_LAN3 0x00000008
+/* Disable
+#define SYS_GPE_CLKS_LAN3_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_LAN3_EN 0x00000008
+/** LAN2 Clock Enable
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_CLKS_LAN2 0x00000004
+/* Disable
+#define SYS_GPE_CLKS_LAN2_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_LAN2_EN 0x00000004
+/** LAN1 Clock Enable
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_CLKS_LAN1 0x00000002
+/* Disable
+#define SYS_GPE_CLKS_LAN1_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_LAN1_EN 0x00000002
+/** LAN0 Clock Enable
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_CLKS_LAN0 0x00000001
+/* Disable
+#define SYS_GPE_CLKS_LAN0_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_CLKS_LAN0_EN 0x00000001
+
+/* Fields of "Clock Enable Register" */
+/** Set Clock Enable COP7
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_CLKEN_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP7_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP7_SET 0x80000000
+/** Set Clock Enable COP6
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_CLKEN_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP6_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP6_SET 0x40000000
+/** Set Clock Enable COP5
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_CLKEN_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP5_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP5_SET 0x20000000
+/** Set Clock Enable COP4
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_CLKEN_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP4_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP4_SET 0x10000000
+/** Set Clock Enable COP3
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_CLKEN_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP3_SET 0x08000000
+/** Set Clock Enable COP2
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_CLKEN_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP2_SET 0x04000000
+/** Set Clock Enable COP1
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_CLKEN_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP1_SET 0x02000000
+/** Set Clock Enable COP0
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_CLKEN_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_CLKEN_COP0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_COP0_SET 0x01000000
+/** Set Clock Enable PE5
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_CLKEN_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_CLKEN_PE5_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_PE5_SET 0x00200000
+/** Set Clock Enable PE4
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_CLKEN_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_CLKEN_PE4_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_PE4_SET 0x00100000
+/** Set Clock Enable PE3
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_CLKEN_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_CLKEN_PE3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_PE3_SET 0x00080000
+/** Set Clock Enable PE2
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_CLKEN_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_CLKEN_PE2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_PE2_SET 0x00040000
+/** Set Clock Enable PE1
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_CLKEN_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_CLKEN_PE1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_PE1_SET 0x00020000
+/** Set Clock Enable PE0
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_CLKEN_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_CLKEN_PE0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_PE0_SET 0x00010000
+/** Set Clock Enable ARB
+    This domain contains the Arbiter. */
+#define SYS_GPE_CLKEN_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_CLKEN_ARB_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_ARB_SET 0x00002000
+/** Set Clock Enable FSQM
+    This domain contains the FSQM. */
+#define SYS_GPE_CLKEN_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_CLKEN_FSQM_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_FSQM_SET 0x00001000
+/** Set Clock Enable TMU
+    This domain contains the TMU. */
+#define SYS_GPE_CLKEN_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_CLKEN_TMU_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_TMU_SET 0x00000800
+/** Set Clock Enable MRG
+    This domain contains the Merger. */
+#define SYS_GPE_CLKEN_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_CLKEN_MRG_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_MRG_SET 0x00000400
+/** Set Clock Enable DISP
+    This domain contains the Dispatcher. */
+#define SYS_GPE_CLKEN_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_CLKEN_DISP_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_DISP_SET 0x00000200
+/** Set Clock Enable IQM
+    This domain contains the IQM. */
+#define SYS_GPE_CLKEN_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_CLKEN_IQM_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_IQM_SET 0x00000100
+/** Set Clock Enable CPUE
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_CLKEN_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_CLKEN_CPUE_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_CPUE_SET 0x00000080
+/** Set Clock Enable CPUI
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_CLKEN_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_CLKEN_CPUI_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_CPUI_SET 0x00000040
+/** Set Clock Enable GPONE
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_CLKEN_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_CLKEN_GPONE_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_GPONE_SET 0x00000020
+/** Set Clock Enable GPONI
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_CLKEN_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_CLKEN_GPONI_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_GPONI_SET 0x00000010
+/** Set Clock Enable LAN3
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_CLKEN_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_CLKEN_LAN3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_LAN3_SET 0x00000008
+/** Set Clock Enable LAN2
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_CLKEN_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_CLKEN_LAN2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_LAN2_SET 0x00000004
+/** Set Clock Enable LAN1
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_CLKEN_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_CLKEN_LAN1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_LAN1_SET 0x00000002
+/** Set Clock Enable LAN0
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_CLKEN_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_CLKEN_LAN0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_CLKEN_LAN0_SET 0x00000001
+
+/* Fields of "Clock Clear Register" */
+/** Clear Clock Enable COP7
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_CLKCLR_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP7_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP7_CLR 0x80000000
+/** Clear Clock Enable COP6
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_CLKCLR_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP6_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP6_CLR 0x40000000
+/** Clear Clock Enable COP5
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_CLKCLR_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP5_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP5_CLR 0x20000000
+/** Clear Clock Enable COP4
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_CLKCLR_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP4_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP4_CLR 0x10000000
+/** Clear Clock Enable COP3
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_CLKCLR_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP3_CLR 0x08000000
+/** Clear Clock Enable COP2
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_CLKCLR_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP2_CLR 0x04000000
+/** Clear Clock Enable COP1
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_CLKCLR_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP1_CLR 0x02000000
+/** Clear Clock Enable COP0
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_CLKCLR_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_CLKCLR_COP0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_COP0_CLR 0x01000000
+/** Clear Clock Enable PE5
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_CLKCLR_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_CLKCLR_PE5_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_PE5_CLR 0x00200000
+/** Clear Clock Enable PE4
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_CLKCLR_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_CLKCLR_PE4_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_PE4_CLR 0x00100000
+/** Clear Clock Enable PE3
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_CLKCLR_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_CLKCLR_PE3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_PE3_CLR 0x00080000
+/** Clear Clock Enable PE2
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_CLKCLR_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_CLKCLR_PE2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_PE2_CLR 0x00040000
+/** Clear Clock Enable PE1
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_CLKCLR_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_CLKCLR_PE1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_PE1_CLR 0x00020000
+/** Clear Clock Enable PE0
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_CLKCLR_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_CLKCLR_PE0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_PE0_CLR 0x00010000
+/** Clear Clock Enable ARB
+    This domain contains the Arbiter. */
+#define SYS_GPE_CLKCLR_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_CLKCLR_ARB_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_ARB_CLR 0x00002000
+/** Clear Clock Enable FSQM
+    This domain contains the FSQM. */
+#define SYS_GPE_CLKCLR_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_CLKCLR_FSQM_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_FSQM_CLR 0x00001000
+/** Clear Clock Enable TMU
+    This domain contains the TMU. */
+#define SYS_GPE_CLKCLR_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_CLKCLR_TMU_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_TMU_CLR 0x00000800
+/** Clear Clock Enable MRG
+    This domain contains the Merger. */
+#define SYS_GPE_CLKCLR_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_CLKCLR_MRG_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_MRG_CLR 0x00000400
+/** Clear Clock Enable DISP
+    This domain contains the Dispatcher. */
+#define SYS_GPE_CLKCLR_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_CLKCLR_DISP_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_DISP_CLR 0x00000200
+/** Clear Clock Enable IQM
+    This domain contains the IQM. */
+#define SYS_GPE_CLKCLR_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_CLKCLR_IQM_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_IQM_CLR 0x00000100
+/** Clear Clock Enable CPUE
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_CLKCLR_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_CLKCLR_CPUE_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_CPUE_CLR 0x00000080
+/** Clear Clock Enable CPUI
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_CLKCLR_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_CLKCLR_CPUI_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_CPUI_CLR 0x00000040
+/** Clear Clock Enable GPONE
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_CLKCLR_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_CLKCLR_GPONE_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_GPONE_CLR 0x00000020
+/** Clear Clock Enable GPONI
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_CLKCLR_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_CLKCLR_GPONI_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_GPONI_CLR 0x00000010
+/** Clear Clock Enable LAN3
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_CLKCLR_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_CLKCLR_LAN3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_LAN3_CLR 0x00000008
+/** Clear Clock Enable LAN2
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_CLKCLR_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_CLKCLR_LAN2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_LAN2_CLR 0x00000004
+/** Clear Clock Enable LAN1
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_CLKCLR_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_CLKCLR_LAN1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_LAN1_CLR 0x00000002
+/** Clear Clock Enable LAN0
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_CLKCLR_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_CLKCLR_LAN0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_CLKCLR_LAN0_CLR 0x00000001
+
+/* Fields of "Activation Status Register" */
+/** COP7 Status
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_ACTS_COP7 0x80000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP7_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP7_ACT 0x80000000
+/** COP6 Status
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_ACTS_COP6 0x40000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP6_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP6_ACT 0x40000000
+/** COP5 Status
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_ACTS_COP5 0x20000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP5_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP5_ACT 0x20000000
+/** COP4 Status
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_ACTS_COP4 0x10000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP4_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP4_ACT 0x10000000
+/** COP3 Status
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_ACTS_COP3 0x08000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP3_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP3_ACT 0x08000000
+/** COP2 Status
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_ACTS_COP2 0x04000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP2_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP2_ACT 0x04000000
+/** COP1 Status
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_ACTS_COP1 0x02000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP1_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP1_ACT 0x02000000
+/** COP0 Status
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_ACTS_COP0 0x01000000
+/* The block is inactive.
+#define SYS_GPE_ACTS_COP0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_COP0_ACT 0x01000000
+/** PE5 Status
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_ACTS_PE5 0x00200000
+/* The block is inactive.
+#define SYS_GPE_ACTS_PE5_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_PE5_ACT 0x00200000
+/** PE4 Status
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_ACTS_PE4 0x00100000
+/* The block is inactive.
+#define SYS_GPE_ACTS_PE4_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_PE4_ACT 0x00100000
+/** PE3 Status
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_ACTS_PE3 0x00080000
+/* The block is inactive.
+#define SYS_GPE_ACTS_PE3_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_PE3_ACT 0x00080000
+/** PE2 Status
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_ACTS_PE2 0x00040000
+/* The block is inactive.
+#define SYS_GPE_ACTS_PE2_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_PE2_ACT 0x00040000
+/** PE1 Status
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_ACTS_PE1 0x00020000
+/* The block is inactive.
+#define SYS_GPE_ACTS_PE1_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_PE1_ACT 0x00020000
+/** PE0 Status
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_ACTS_PE0 0x00010000
+/* The block is inactive.
+#define SYS_GPE_ACTS_PE0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_PE0_ACT 0x00010000
+/** ARB Status
+    This domain contains the Arbiter. */
+#define SYS_GPE_ACTS_ARB 0x00002000
+/* The block is inactive.
+#define SYS_GPE_ACTS_ARB_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_ARB_ACT 0x00002000
+/** FSQM Status
+    This domain contains the FSQM. */
+#define SYS_GPE_ACTS_FSQM 0x00001000
+/* The block is inactive.
+#define SYS_GPE_ACTS_FSQM_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_FSQM_ACT 0x00001000
+/** TMU Status
+    This domain contains the TMU. */
+#define SYS_GPE_ACTS_TMU 0x00000800
+/* The block is inactive.
+#define SYS_GPE_ACTS_TMU_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_TMU_ACT 0x00000800
+/** MRG Status
+    This domain contains the Merger. */
+#define SYS_GPE_ACTS_MRG 0x00000400
+/* The block is inactive.
+#define SYS_GPE_ACTS_MRG_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_MRG_ACT 0x00000400
+/** DISP Status
+    This domain contains the Dispatcher. */
+#define SYS_GPE_ACTS_DISP 0x00000200
+/* The block is inactive.
+#define SYS_GPE_ACTS_DISP_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_DISP_ACT 0x00000200
+/** IQM Status
+    This domain contains the IQM. */
+#define SYS_GPE_ACTS_IQM 0x00000100
+/* The block is inactive.
+#define SYS_GPE_ACTS_IQM_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_IQM_ACT 0x00000100
+/** CPUE Status
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_ACTS_CPUE 0x00000080
+/* The block is inactive.
+#define SYS_GPE_ACTS_CPUE_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_CPUE_ACT 0x00000080
+/** CPUI Status
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_ACTS_CPUI 0x00000040
+/* The block is inactive.
+#define SYS_GPE_ACTS_CPUI_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_CPUI_ACT 0x00000040
+/** GPONE Status
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_ACTS_GPONE 0x00000020
+/* The block is inactive.
+#define SYS_GPE_ACTS_GPONE_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_GPONE_ACT 0x00000020
+/** GPONI Status
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_ACTS_GPONI 0x00000010
+/* The block is inactive.
+#define SYS_GPE_ACTS_GPONI_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_GPONI_ACT 0x00000010
+/** LAN3 Status
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_ACTS_LAN3 0x00000008
+/* The block is inactive.
+#define SYS_GPE_ACTS_LAN3_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_LAN3_ACT 0x00000008
+/** LAN2 Status
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_ACTS_LAN2 0x00000004
+/* The block is inactive.
+#define SYS_GPE_ACTS_LAN2_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_LAN2_ACT 0x00000004
+/** LAN1 Status
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_ACTS_LAN1 0x00000002
+/* The block is inactive.
+#define SYS_GPE_ACTS_LAN1_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_LAN1_ACT 0x00000002
+/** LAN0 Status
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_ACTS_LAN0 0x00000001
+/* The block is inactive.
+#define SYS_GPE_ACTS_LAN0_INACT 0x00000000 */
+/** The block is active. */
+#define SYS_GPE_ACTS_LAN0_ACT 0x00000001
+
+/* Fields of "Activation Register" */
+/** Activate COP7
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_ACT_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_ACT_COP7_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP7_SET 0x80000000
+/** Activate COP6
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_ACT_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_ACT_COP6_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP6_SET 0x40000000
+/** Activate COP5
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_ACT_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_ACT_COP5_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP5_SET 0x20000000
+/** Activate COP4
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_ACT_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_ACT_COP4_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP4_SET 0x10000000
+/** Activate COP3
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_ACT_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_ACT_COP3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP3_SET 0x08000000
+/** Activate COP2
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_ACT_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_ACT_COP2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP2_SET 0x04000000
+/** Activate COP1
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_ACT_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_ACT_COP1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP1_SET 0x02000000
+/** Activate COP0
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_ACT_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_ACT_COP0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_COP0_SET 0x01000000
+/** Activate PE5
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_ACT_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_ACT_PE5_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_PE5_SET 0x00200000
+/** Activate PE4
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_ACT_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_ACT_PE4_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_PE4_SET 0x00100000
+/** Activate PE3
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_ACT_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_ACT_PE3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_PE3_SET 0x00080000
+/** Activate PE2
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_ACT_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_ACT_PE2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_PE2_SET 0x00040000
+/** Activate PE1
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_ACT_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_ACT_PE1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_PE1_SET 0x00020000
+/** Activate PE0
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_ACT_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_ACT_PE0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_PE0_SET 0x00010000
+/** Activate ARB
+    This domain contains the Arbiter. */
+#define SYS_GPE_ACT_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_ACT_ARB_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_ARB_SET 0x00002000
+/** Activate FSQM
+    This domain contains the FSQM. */
+#define SYS_GPE_ACT_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_ACT_FSQM_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_FSQM_SET 0x00001000
+/** Activate TMU
+    This domain contains the TMU. */
+#define SYS_GPE_ACT_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_ACT_TMU_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_TMU_SET 0x00000800
+/** Activate MRG
+    This domain contains the Merger. */
+#define SYS_GPE_ACT_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_ACT_MRG_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_MRG_SET 0x00000400
+/** Activate DISP
+    This domain contains the Dispatcher. */
+#define SYS_GPE_ACT_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_ACT_DISP_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_DISP_SET 0x00000200
+/** Activate IQM
+    This domain contains the IQM. */
+#define SYS_GPE_ACT_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_ACT_IQM_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_IQM_SET 0x00000100
+/** Activate CPUE
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_ACT_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_ACT_CPUE_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_CPUE_SET 0x00000080
+/** Activate CPUI
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_ACT_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_ACT_CPUI_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_CPUI_SET 0x00000040
+/** Activate GPONE
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_ACT_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_ACT_GPONE_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_GPONE_SET 0x00000020
+/** Activate GPONI
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_ACT_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_ACT_GPONI_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_GPONI_SET 0x00000010
+/** Activate LAN3
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_ACT_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_ACT_LAN3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_LAN3_SET 0x00000008
+/** Activate LAN2
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_ACT_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_ACT_LAN2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_LAN2_SET 0x00000004
+/** Activate LAN1
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_ACT_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_ACT_LAN1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_LAN1_SET 0x00000002
+/** Activate LAN0
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_ACT_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_ACT_LAN0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_ACT_LAN0_SET 0x00000001
+
+/* Fields of "Deactivation Register" */
+/** Deactivate COP7
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_DEACT_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP7_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP7_CLR 0x80000000
+/** Deactivate COP6
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_DEACT_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP6_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP6_CLR 0x40000000
+/** Deactivate COP5
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_DEACT_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP5_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP5_CLR 0x20000000
+/** Deactivate COP4
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_DEACT_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP4_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP4_CLR 0x10000000
+/** Deactivate COP3
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_DEACT_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP3_CLR 0x08000000
+/** Deactivate COP2
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_DEACT_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP2_CLR 0x04000000
+/** Deactivate COP1
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_DEACT_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP1_CLR 0x02000000
+/** Deactivate COP0
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_DEACT_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_DEACT_COP0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_COP0_CLR 0x01000000
+/** Deactivate PE5
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_DEACT_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_DEACT_PE5_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_PE5_CLR 0x00200000
+/** Deactivate PE4
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_DEACT_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_DEACT_PE4_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_PE4_CLR 0x00100000
+/** Deactivate PE3
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_DEACT_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_DEACT_PE3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_PE3_CLR 0x00080000
+/** Deactivate PE2
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_DEACT_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_DEACT_PE2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_PE2_CLR 0x00040000
+/** Deactivate PE1
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_DEACT_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_DEACT_PE1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_PE1_CLR 0x00020000
+/** Deactivate PE0
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_DEACT_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_DEACT_PE0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_PE0_CLR 0x00010000
+/** Deactivate ARB
+    This domain contains the Arbiter. */
+#define SYS_GPE_DEACT_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_DEACT_ARB_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_ARB_CLR 0x00002000
+/** Deactivate FSQM
+    This domain contains the FSQM. */
+#define SYS_GPE_DEACT_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_DEACT_FSQM_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_FSQM_CLR 0x00001000
+/** Deactivate TMU
+    This domain contains the TMU. */
+#define SYS_GPE_DEACT_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_DEACT_TMU_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_TMU_CLR 0x00000800
+/** Deactivate MRG
+    This domain contains the Merger. */
+#define SYS_GPE_DEACT_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_DEACT_MRG_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_MRG_CLR 0x00000400
+/** Deactivate DISP
+    This domain contains the Dispatcher. */
+#define SYS_GPE_DEACT_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_DEACT_DISP_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_DISP_CLR 0x00000200
+/** Deactivate IQM
+    This domain contains the IQM. */
+#define SYS_GPE_DEACT_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_DEACT_IQM_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_IQM_CLR 0x00000100
+/** Deactivate CPUE
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_DEACT_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_DEACT_CPUE_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_CPUE_CLR 0x00000080
+/** Deactivate CPUI
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_DEACT_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_DEACT_CPUI_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_CPUI_CLR 0x00000040
+/** Deactivate GPONE
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_DEACT_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_DEACT_GPONE_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_GPONE_CLR 0x00000020
+/** Deactivate GPONI
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_DEACT_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_DEACT_GPONI_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_GPONI_CLR 0x00000010
+/** Deactivate LAN3
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_DEACT_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_DEACT_LAN3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_LAN3_CLR 0x00000008
+/** Deactivate LAN2
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_DEACT_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_DEACT_LAN2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_LAN2_CLR 0x00000004
+/** Deactivate LAN1
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_DEACT_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_DEACT_LAN1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_LAN1_CLR 0x00000002
+/** Deactivate LAN0
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_DEACT_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_DEACT_LAN0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_DEACT_LAN0_CLR 0x00000001
+
+/* Fields of "Reboot Trigger Register" */
+/** Reboot COP7
+    This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_RBT_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_RBT_COP7_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP7_TRIG 0x80000000
+/** Reboot COP6
+    This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_RBT_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_RBT_COP6_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP6_TRIG 0x40000000
+/** Reboot COP5
+    This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_RBT_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_RBT_COP5_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP5_TRIG 0x20000000
+/** Reboot COP4
+    This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_RBT_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_RBT_COP4_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP4_TRIG 0x10000000
+/** Reboot COP3
+    This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_RBT_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_RBT_COP3_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP3_TRIG 0x08000000
+/** Reboot COP2
+    This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_RBT_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_RBT_COP2_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP2_TRIG 0x04000000
+/** Reboot COP1
+    This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_RBT_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_RBT_COP1_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP1_TRIG 0x02000000
+/** Reboot COP0
+    This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_RBT_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_RBT_COP0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_COP0_TRIG 0x01000000
+/** Reboot PE5
+    This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_RBT_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_RBT_PE5_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_PE5_TRIG 0x00200000
+/** Reboot PE4
+    This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_RBT_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_RBT_PE4_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_PE4_TRIG 0x00100000
+/** Reboot PE3
+    This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_RBT_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_RBT_PE3_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_PE3_TRIG 0x00080000
+/** Reboot PE2
+    This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_RBT_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_RBT_PE2_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_PE2_TRIG 0x00040000
+/** Reboot PE1
+    This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_RBT_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_RBT_PE1_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_PE1_TRIG 0x00020000
+/** Reboot PE0
+    This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_RBT_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_RBT_PE0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_PE0_TRIG 0x00010000
+/** Reboot ARB
+    This domain contains the Arbiter. */
+#define SYS_GPE_RBT_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_RBT_ARB_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_ARB_TRIG 0x00002000
+/** Reboot FSQM
+    This domain contains the FSQM. */
+#define SYS_GPE_RBT_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_RBT_FSQM_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_FSQM_TRIG 0x00001000
+/** Reboot TMU
+    This domain contains the TMU. */
+#define SYS_GPE_RBT_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_RBT_TMU_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_TMU_TRIG 0x00000800
+/** Reboot MRG
+    This domain contains the Merger. */
+#define SYS_GPE_RBT_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_RBT_MRG_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_MRG_TRIG 0x00000400
+/** Reboot DISP
+    This domain contains the Dispatcher. */
+#define SYS_GPE_RBT_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_RBT_DISP_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_DISP_TRIG 0x00000200
+/** Reboot IQM
+    This domain contains the IQM. */
+#define SYS_GPE_RBT_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_RBT_IQM_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_IQM_TRIG 0x00000100
+/** Reboot CPUE
+    This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_RBT_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_RBT_CPUE_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_CPUE_TRIG 0x00000080
+/** Reboot CPUI
+    This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_RBT_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_RBT_CPUI_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_CPUI_TRIG 0x00000040
+/** Reboot GPONE
+    This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_RBT_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_RBT_GPONE_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_GPONE_TRIG 0x00000020
+/** Reboot GPONI
+    This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_RBT_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_RBT_GPONI_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_GPONI_TRIG 0x00000010
+/** Reboot LAN3
+    This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_RBT_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_RBT_LAN3_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_LAN3_TRIG 0x00000008
+/** Reboot LAN2
+    This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_RBT_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_RBT_LAN2_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_LAN2_TRIG 0x00000004
+/** Reboot LAN1
+    This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_RBT_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_RBT_LAN1_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_LAN1_TRIG 0x00000002
+/** Reboot LAN0
+    This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_RBT_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_RBT_LAN0_NOP 0x00000000 */
+/** Trigger */
+#define SYS_GPE_RBT_LAN0_TRIG 0x00000001
+
+/* Fields of "Power Down Configuration Register" */
+/** Enable Power Down COP7
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP7 0x80000000
+/* Disable
+#define SYS_GPE_PDCFG_COP7_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP7_EN 0x80000000
+/** Enable Power Down COP6
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP6 0x40000000
+/* Disable
+#define SYS_GPE_PDCFG_COP6_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP6_EN 0x40000000
+/** Enable Power Down COP5
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP5 0x20000000
+/* Disable
+#define SYS_GPE_PDCFG_COP5_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP5_EN 0x20000000
+/** Enable Power Down COP4
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP4 0x10000000
+/* Disable
+#define SYS_GPE_PDCFG_COP4_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP4_EN 0x10000000
+/** Enable Power Down COP3
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP3 0x08000000
+/* Disable
+#define SYS_GPE_PDCFG_COP3_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP3_EN 0x08000000
+/** Enable Power Down COP2
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP2 0x04000000
+/* Disable
+#define SYS_GPE_PDCFG_COP2_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP2_EN 0x04000000
+/** Enable Power Down COP1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP1 0x02000000
+/* Disable
+#define SYS_GPE_PDCFG_COP1_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP1_EN 0x02000000
+/** Enable Power Down COP0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_COP0 0x01000000
+/* Disable
+#define SYS_GPE_PDCFG_COP0_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_COP0_EN 0x01000000
+/** Enable Power Down PE5
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_PE5 0x00200000
+/* Disable
+#define SYS_GPE_PDCFG_PE5_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_PE5_EN 0x00200000
+/** Enable Power Down PE4
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_PE4 0x00100000
+/* Disable
+#define SYS_GPE_PDCFG_PE4_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_PE4_EN 0x00100000
+/** Enable Power Down PE3
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_PE3 0x00080000
+/* Disable
+#define SYS_GPE_PDCFG_PE3_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_PE3_EN 0x00080000
+/** Enable Power Down PE2
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_PE2 0x00040000
+/* Disable
+#define SYS_GPE_PDCFG_PE2_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_PE2_EN 0x00040000
+/** Enable Power Down PE1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_PE1 0x00020000
+/* Disable
+#define SYS_GPE_PDCFG_PE1_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_PE1_EN 0x00020000
+/** Enable Power Down PE0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_PE0 0x00010000
+/* Disable
+#define SYS_GPE_PDCFG_PE0_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_PE0_EN 0x00010000
+/** Enable Power Down ARB
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_ARB 0x00002000
+/* Disable
+#define SYS_GPE_PDCFG_ARB_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_ARB_EN 0x00002000
+/** Enable Power Down FSQM
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_FSQM 0x00001000
+/* Disable
+#define SYS_GPE_PDCFG_FSQM_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_FSQM_EN 0x00001000
+/** Enable Power Down TMU
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_TMU 0x00000800
+/* Disable
+#define SYS_GPE_PDCFG_TMU_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_TMU_EN 0x00000800
+/** Enable Power Down MRG
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_MRG 0x00000400
+/* Disable
+#define SYS_GPE_PDCFG_MRG_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_MRG_EN 0x00000400
+/** Enable Power Down DISP
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_DISP 0x00000200
+/* Disable
+#define SYS_GPE_PDCFG_DISP_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_DISP_EN 0x00000200
+/** Enable Power Down IQM
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_IQM 0x00000100
+/* Disable
+#define SYS_GPE_PDCFG_IQM_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_IQM_EN 0x00000100
+/** Enable Power Down CPUE
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_CPUE 0x00000080
+/* Disable
+#define SYS_GPE_PDCFG_CPUE_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_CPUE_EN 0x00000080
+/** Enable Power Down CPUI
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_CPUI 0x00000040
+/* Disable
+#define SYS_GPE_PDCFG_CPUI_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_CPUI_EN 0x00000040
+/** Enable Power Down GPONE
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_GPONE 0x00000020
+/* Disable
+#define SYS_GPE_PDCFG_GPONE_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_GPONE_EN 0x00000020
+/** Enable Power Down GPONI
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_GPONI 0x00000010
+/* Disable
+#define SYS_GPE_PDCFG_GPONI_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_GPONI_EN 0x00000010
+/** Enable Power Down LAN3
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_LAN3 0x00000008
+/* Disable
+#define SYS_GPE_PDCFG_LAN3_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_LAN3_EN 0x00000008
+/** Enable Power Down LAN2
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_LAN2 0x00000004
+/* Disable
+#define SYS_GPE_PDCFG_LAN2_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_LAN2_EN 0x00000004
+/** Enable Power Down LAN1
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_LAN1 0x00000002
+/* Disable
+#define SYS_GPE_PDCFG_LAN1_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_LAN1_EN 0x00000002
+/** Enable Power Down LAN0
+    Ignore this bit as power-gating is not supported for this chip. */
+#define SYS_GPE_PDCFG_LAN0 0x00000001
+/* Disable
+#define SYS_GPE_PDCFG_LAN0_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_PDCFG_LAN0_EN 0x00000001
+
+/* Fields of "Sleep Source Configuration Register" */
+/** Sleep/Wakeup Source CPU
+    Selects the CPU access signal as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_CPU 0x00020000
+/* Not selected
+#define SYS_GPE_SSCFG_CPU_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_CPU_SEL 0x00020000
+/** Sleep/Wakeup Source FSQM
+    Selects the FSQM signal as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_FSQM 0x00008000
+/* Not selected
+#define SYS_GPE_SSCFG_FSQM_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_FSQM_SEL 0x00008000
+/** Sleep/Wakeup Source GPONT
+    Selects the FIFO empty signal of the TCONT Request FIFO of port GPON as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_GPONT 0x00002000
+/* Not selected
+#define SYS_GPE_SSCFG_GPONT_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_GPONT_SEL 0x00002000
+/** Sleep/Wakeup Source GPONE
+    Selects the FIFO empty signal of the EGRESS FIFO of port GPON as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_GPONE 0x00001000
+/* Not selected
+#define SYS_GPE_SSCFG_GPONE_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_GPONE_SEL 0x00001000
+/** Sleep/Wakeup Source LAN3E
+    Selects the FIFO empty signal of the EGRESS FIFO of port LAN3 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN3E 0x00000800
+/* Not selected
+#define SYS_GPE_SSCFG_LAN3E_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN3E_SEL 0x00000800
+/** Sleep/Wakeup Source LAN2E
+    Selects the FIFO empty signal of the EGRESS FIFO of port LAN2 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN2E 0x00000400
+/* Not selected
+#define SYS_GPE_SSCFG_LAN2E_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN2E_SEL 0x00000400
+/** Sleep/Wakeup Source LAN1E
+    Selects the FIFO empty signal of the EGRESS FIFO of port LAN1 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN1E 0x00000200
+/* Not selected
+#define SYS_GPE_SSCFG_LAN1E_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN1E_SEL 0x00000200
+/** Sleep/Wakeup Source LAN0E
+    Selects the FIFO empty signal of the EGRESS FIFO of port LAN0 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN0E 0x00000100
+/* Not selected
+#define SYS_GPE_SSCFG_LAN0E_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN0E_SEL 0x00000100
+/** Sleep/Wakeup Source GPONI
+    Selects the FIFO empty signal of the INGRESS FIFO of port GPON as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_GPONI 0x00000010
+/* Not selected
+#define SYS_GPE_SSCFG_GPONI_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_GPONI_SEL 0x00000010
+/** Sleep/Wakeup Source LAN3I
+    Selects the FIFO empty signal of the INGRESS FIFO of port LAN3 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN3I 0x00000008
+/* Not selected
+#define SYS_GPE_SSCFG_LAN3I_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN3I_SEL 0x00000008
+/** Sleep/Wakeup Source LAN2I
+    Selects the FIFO empty signal of the INGRESS FIFO of port LAN2 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN2I 0x00000004
+/* Not selected
+#define SYS_GPE_SSCFG_LAN2I_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN2I_SEL 0x00000004
+/** Sleep/Wakeup Source LAN1I
+    Selects the FIFO empty signal of the INGRESS FIFO of port LAN1 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN1I 0x00000002
+/* Not selected
+#define SYS_GPE_SSCFG_LAN1I_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN1I_SEL 0x00000002
+/** Sleep/Wakeup Source LAN0I
+    Selects the FIFO empty signal of the INGRESS FIFO of port LAN0 as sleep/wakeup source. */
+#define SYS_GPE_SSCFG_LAN0I 0x00000001
+/* Not selected
+#define SYS_GPE_SSCFG_LAN0I_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SSCFG_LAN0I_SEL 0x00000001
+
+/* Fields of "Sleep Source Timer Register" */
+/** Sleep Delay Value
+    A HW sleep request is delayed by this value multiplied by 3.2ns before it takes effect. A wakeup request is not delayed but takes effect immediately. Values lower than 256 are limited to 256. */
+#define SYS_GPE_SST_SDV_MASK 0x7FFFFFFF
+/** field offset */
+#define SYS_GPE_SST_SDV_OFFSET 0
+
+/* Fields of "Sleep Destination Status Register" */
+/** Shutoff COP7 on HW Sleep
+    If selected the domain COP7 is shutoff on a hardware sleep request. This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_SDS_COP7 0x80000000
+/* Not selected
+#define SYS_GPE_SDS_COP7_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP7_SEL 0x80000000
+/** Shutoff COP6 on HW Sleep
+    If selected the domain COP6 is shutoff on a hardware sleep request. This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_SDS_COP6 0x40000000
+/* Not selected
+#define SYS_GPE_SDS_COP6_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP6_SEL 0x40000000
+/** Shutoff COP5 on HW Sleep
+    If selected the domain COP5 is shutoff on a hardware sleep request. This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_SDS_COP5 0x20000000
+/* Not selected
+#define SYS_GPE_SDS_COP5_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP5_SEL 0x20000000
+/** Shutoff COP4 on HW Sleep
+    If selected the domain COP4 is shutoff on a hardware sleep request. This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_SDS_COP4 0x10000000
+/* Not selected
+#define SYS_GPE_SDS_COP4_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP4_SEL 0x10000000
+/** Shutoff COP3 on HW Sleep
+    If selected the domain COP3 is shutoff on a hardware sleep request. This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_SDS_COP3 0x08000000
+/* Not selected
+#define SYS_GPE_SDS_COP3_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP3_SEL 0x08000000
+/** Shutoff COP2 on HW Sleep
+    If selected the domain COP2 is shutoff on a hardware sleep request. This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_SDS_COP2 0x04000000
+/* Not selected
+#define SYS_GPE_SDS_COP2_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP2_SEL 0x04000000
+/** Shutoff COP1 on HW Sleep
+    If selected the domain COP1 is shutoff on a hardware sleep request. This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_SDS_COP1 0x02000000
+/* Not selected
+#define SYS_GPE_SDS_COP1_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP1_SEL 0x02000000
+/** Shutoff COP0 on HW Sleep
+    If selected the domain COP0 is shutoff on a hardware sleep request. This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_SDS_COP0 0x01000000
+/* Not selected
+#define SYS_GPE_SDS_COP0_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_COP0_SEL 0x01000000
+/** Shutoff PE5 on HW Sleep
+    If selected the domain PE5 is shutoff on a hardware sleep request. This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_SDS_PE5 0x00200000
+/* Not selected
+#define SYS_GPE_SDS_PE5_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_PE5_SEL 0x00200000
+/** Shutoff PE4 on HW Sleep
+    If selected the domain PE4 is shutoff on a hardware sleep request. This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_SDS_PE4 0x00100000
+/* Not selected
+#define SYS_GPE_SDS_PE4_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_PE4_SEL 0x00100000
+/** Shutoff PE3 on HW Sleep
+    If selected the domain PE3 is shutoff on a hardware sleep request. This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_SDS_PE3 0x00080000
+/* Not selected
+#define SYS_GPE_SDS_PE3_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_PE3_SEL 0x00080000
+/** Shutoff PE2 on HW Sleep
+    If selected the domain PE2 is shutoff on a hardware sleep request. This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_SDS_PE2 0x00040000
+/* Not selected
+#define SYS_GPE_SDS_PE2_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_PE2_SEL 0x00040000
+/** Shutoff PE1 on HW Sleep
+    If selected the domain PE1 is shutoff on a hardware sleep request. This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_SDS_PE1 0x00020000
+/* Not selected
+#define SYS_GPE_SDS_PE1_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_PE1_SEL 0x00020000
+/** Shutoff PE0 on HW Sleep
+    If selected the domain PE0 is shutoff on a hardware sleep request. This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_SDS_PE0 0x00010000
+/* Not selected
+#define SYS_GPE_SDS_PE0_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_PE0_SEL 0x00010000
+/** Shutoff ARB on HW Sleep
+    If selected the domain ARB is shutoff on a hardware sleep request. This domain contains the Arbiter. */
+#define SYS_GPE_SDS_ARB 0x00002000
+/* Not selected
+#define SYS_GPE_SDS_ARB_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_ARB_SEL 0x00002000
+/** Shutoff FSQM on HW Sleep
+    If selected the domain FSQM is shutoff on a hardware sleep request. This domain contains the FSQM. */
+#define SYS_GPE_SDS_FSQM 0x00001000
+/* Not selected
+#define SYS_GPE_SDS_FSQM_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_FSQM_SEL 0x00001000
+/** Shutoff TMU on HW Sleep
+    If selected the domain TMU is shutoff on a hardware sleep request. This domain contains the TMU. */
+#define SYS_GPE_SDS_TMU 0x00000800
+/* Not selected
+#define SYS_GPE_SDS_TMU_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_TMU_SEL 0x00000800
+/** Shutoff MRG on HW Sleep
+    If selected the domain MRG is shutoff on a hardware sleep request. This domain contains the Merger. */
+#define SYS_GPE_SDS_MRG 0x00000400
+/* Not selected
+#define SYS_GPE_SDS_MRG_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_MRG_SEL 0x00000400
+/** Shutoff DISP on HW Sleep
+    If selected the domain DISP is shutoff on a hardware sleep request. This domain contains the Dispatcher. */
+#define SYS_GPE_SDS_DISP 0x00000200
+/* Not selected
+#define SYS_GPE_SDS_DISP_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_DISP_SEL 0x00000200
+/** Shutoff IQM on HW Sleep
+    If selected the domain IQM is shutoff on a hardware sleep request. This domain contains the IQM. */
+#define SYS_GPE_SDS_IQM 0x00000100
+/* Not selected
+#define SYS_GPE_SDS_IQM_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_IQM_SEL 0x00000100
+/** Shutoff CPUE on HW Sleep
+    If selected the domain CPUE is shutoff on a hardware sleep request. This domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_SDS_CPUE 0x00000080
+/* Not selected
+#define SYS_GPE_SDS_CPUE_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_CPUE_SEL 0x00000080
+/** Shutoff CPUI on HW Sleep
+    If selected the domain CPUI is shutoff on a hardware sleep request. This domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_SDS_CPUI 0x00000040
+/* Not selected
+#define SYS_GPE_SDS_CPUI_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_CPUI_SEL 0x00000040
+/** Shutoff GPONE on HW Sleep
+    If selected the domain GPONE is shutoff on a hardware sleep request. This domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_SDS_GPONE 0x00000020
+/* Not selected
+#define SYS_GPE_SDS_GPONE_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_GPONE_SEL 0x00000020
+/** Shutoff GPONI on HW Sleep
+    If selected the domain GPONI is shutoff on a hardware sleep request. This domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_SDS_GPONI 0x00000010
+/* Not selected
+#define SYS_GPE_SDS_GPONI_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_GPONI_SEL 0x00000010
+/** Shutoff LAN3 on HW Sleep
+    If selected the domain LAN3 is shutoff on a hardware sleep request. This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_SDS_LAN3 0x00000008
+/* Not selected
+#define SYS_GPE_SDS_LAN3_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_LAN3_SEL 0x00000008
+/** Shutoff LAN2 on HW Sleep
+    If selected the domain LAN2 is shutoff on a hardware sleep request. This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_SDS_LAN2 0x00000004
+/* Not selected
+#define SYS_GPE_SDS_LAN2_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_LAN2_SEL 0x00000004
+/** Shutoff LAN1 on HW Sleep
+    If selected the domain LAN1 is shutoff on a hardware sleep request. This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_SDS_LAN1 0x00000002
+/* Not selected
+#define SYS_GPE_SDS_LAN1_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_LAN1_SEL 0x00000002
+/** Shutoff LAN0 on HW Sleep
+    If selected the domain LAN0 is shutoff on a hardware sleep request. This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_SDS_LAN0 0x00000001
+/* Not selected
+#define SYS_GPE_SDS_LAN0_NSEL 0x00000000 */
+/** Selected */
+#define SYS_GPE_SDS_LAN0_SEL 0x00000001
+
+/* Fields of "Sleep Destination Set Register" */
+/** Set Sleep Selection COP7
+    Sets the selection bit for domain COP7This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_SDSET_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP7_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP7_SET 0x80000000
+/** Set Sleep Selection COP6
+    Sets the selection bit for domain COP6This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_SDSET_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP6_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP6_SET 0x40000000
+/** Set Sleep Selection COP5
+    Sets the selection bit for domain COP5This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_SDSET_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP5_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP5_SET 0x20000000
+/** Set Sleep Selection COP4
+    Sets the selection bit for domain COP4This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_SDSET_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP4_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP4_SET 0x10000000
+/** Set Sleep Selection COP3
+    Sets the selection bit for domain COP3This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_SDSET_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP3_SET 0x08000000
+/** Set Sleep Selection COP2
+    Sets the selection bit for domain COP2This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_SDSET_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP2_SET 0x04000000
+/** Set Sleep Selection COP1
+    Sets the selection bit for domain COP1This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_SDSET_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP1_SET 0x02000000
+/** Set Sleep Selection COP0
+    Sets the selection bit for domain COP0This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_SDSET_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_SDSET_COP0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_COP0_SET 0x01000000
+/** Set Sleep Selection PE5
+    Sets the selection bit for domain PE5This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_SDSET_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_SDSET_PE5_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_PE5_SET 0x00200000
+/** Set Sleep Selection PE4
+    Sets the selection bit for domain PE4This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_SDSET_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_SDSET_PE4_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_PE4_SET 0x00100000
+/** Set Sleep Selection PE3
+    Sets the selection bit for domain PE3This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_SDSET_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_SDSET_PE3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_PE3_SET 0x00080000
+/** Set Sleep Selection PE2
+    Sets the selection bit for domain PE2This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_SDSET_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_SDSET_PE2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_PE2_SET 0x00040000
+/** Set Sleep Selection PE1
+    Sets the selection bit for domain PE1This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_SDSET_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_SDSET_PE1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_PE1_SET 0x00020000
+/** Set Sleep Selection PE0
+    Sets the selection bit for domain PE0This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_SDSET_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_SDSET_PE0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_PE0_SET 0x00010000
+/** Set Sleep Selection ARB
+    Sets the selection bit for domain ARBThis domain contains the Arbiter. */
+#define SYS_GPE_SDSET_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_SDSET_ARB_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_ARB_SET 0x00002000
+/** Set Sleep Selection FSQM
+    Sets the selection bit for domain FSQMThis domain contains the FSQM. */
+#define SYS_GPE_SDSET_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_SDSET_FSQM_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_FSQM_SET 0x00001000
+/** Set Sleep Selection TMU
+    Sets the selection bit for domain TMUThis domain contains the TMU. */
+#define SYS_GPE_SDSET_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_SDSET_TMU_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_TMU_SET 0x00000800
+/** Set Sleep Selection MRG
+    Sets the selection bit for domain MRGThis domain contains the Merger. */
+#define SYS_GPE_SDSET_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_SDSET_MRG_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_MRG_SET 0x00000400
+/** Set Sleep Selection DISP
+    Sets the selection bit for domain DISPThis domain contains the Dispatcher. */
+#define SYS_GPE_SDSET_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_SDSET_DISP_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_DISP_SET 0x00000200
+/** Set Sleep Selection IQM
+    Sets the selection bit for domain IQMThis domain contains the IQM. */
+#define SYS_GPE_SDSET_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_SDSET_IQM_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_IQM_SET 0x00000100
+/** Set Sleep Selection CPUE
+    Sets the selection bit for domain CPUEThis domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_SDSET_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_SDSET_CPUE_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_CPUE_SET 0x00000080
+/** Set Sleep Selection CPUI
+    Sets the selection bit for domain CPUIThis domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_SDSET_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_SDSET_CPUI_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_CPUI_SET 0x00000040
+/** Set Sleep Selection GPONE
+    Sets the selection bit for domain GPONEThis domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_SDSET_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_SDSET_GPONE_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_GPONE_SET 0x00000020
+/** Set Sleep Selection GPONI
+    Sets the selection bit for domain GPONIThis domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_SDSET_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_SDSET_GPONI_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_GPONI_SET 0x00000010
+/** Set Sleep Selection LAN3
+    Sets the selection bit for domain LAN3This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_SDSET_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_SDSET_LAN3_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_LAN3_SET 0x00000008
+/** Set Sleep Selection LAN2
+    Sets the selection bit for domain LAN2This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_SDSET_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_SDSET_LAN2_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_LAN2_SET 0x00000004
+/** Set Sleep Selection LAN1
+    Sets the selection bit for domain LAN1This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_SDSET_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_SDSET_LAN1_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_LAN1_SET 0x00000002
+/** Set Sleep Selection LAN0
+    Sets the selection bit for domain LAN0This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_SDSET_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_SDSET_LAN0_NOP 0x00000000 */
+/** Set */
+#define SYS_GPE_SDSET_LAN0_SET 0x00000001
+
+/* Fields of "Sleep Destination Clear Register" */
+/** Clear Sleep Selection COP7
+    Clears the selection bit for domain COP7This domain contains the Coprocessor 7 of the SCE. */
+#define SYS_GPE_SDCLR_COP7 0x80000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP7_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP7_CLR 0x80000000
+/** Clear Sleep Selection COP6
+    Clears the selection bit for domain COP6This domain contains the Coprocessor 6 of the SCE. */
+#define SYS_GPE_SDCLR_COP6 0x40000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP6_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP6_CLR 0x40000000
+/** Clear Sleep Selection COP5
+    Clears the selection bit for domain COP5This domain contains the Coprocessor 5 of the SCE. */
+#define SYS_GPE_SDCLR_COP5 0x20000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP5_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP5_CLR 0x20000000
+/** Clear Sleep Selection COP4
+    Clears the selection bit for domain COP4This domain contains the Coprocessor 4 of the SCE. */
+#define SYS_GPE_SDCLR_COP4 0x10000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP4_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP4_CLR 0x10000000
+/** Clear Sleep Selection COP3
+    Clears the selection bit for domain COP3This domain contains the Coprocessor 3 of the SCE. */
+#define SYS_GPE_SDCLR_COP3 0x08000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP3_CLR 0x08000000
+/** Clear Sleep Selection COP2
+    Clears the selection bit for domain COP2This domain contains the Coprocessor 2 of the SCE. */
+#define SYS_GPE_SDCLR_COP2 0x04000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP2_CLR 0x04000000
+/** Clear Sleep Selection COP1
+    Clears the selection bit for domain COP1This domain contains the Coprocessor 1 of the SCE. */
+#define SYS_GPE_SDCLR_COP1 0x02000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP1_CLR 0x02000000
+/** Clear Sleep Selection COP0
+    Clears the selection bit for domain COP0This domain contains the Coprocessor 0 of the SCE. */
+#define SYS_GPE_SDCLR_COP0 0x01000000
+/* No-Operation
+#define SYS_GPE_SDCLR_COP0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_COP0_CLR 0x01000000
+/** Clear Sleep Selection PE5
+    Clears the selection bit for domain PE5This domain contains the Processing Element 5 of the SCE. */
+#define SYS_GPE_SDCLR_PE5 0x00200000
+/* No-Operation
+#define SYS_GPE_SDCLR_PE5_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_PE5_CLR 0x00200000
+/** Clear Sleep Selection PE4
+    Clears the selection bit for domain PE4This domain contains the Processing Element 4 of the SCE. */
+#define SYS_GPE_SDCLR_PE4 0x00100000
+/* No-Operation
+#define SYS_GPE_SDCLR_PE4_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_PE4_CLR 0x00100000
+/** Clear Sleep Selection PE3
+    Clears the selection bit for domain PE3This domain contains the Processing Element 3 of the SCE. */
+#define SYS_GPE_SDCLR_PE3 0x00080000
+/* No-Operation
+#define SYS_GPE_SDCLR_PE3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_PE3_CLR 0x00080000
+/** Clear Sleep Selection PE2
+    Clears the selection bit for domain PE2This domain contains the Processing Element 2 of the SCE. */
+#define SYS_GPE_SDCLR_PE2 0x00040000
+/* No-Operation
+#define SYS_GPE_SDCLR_PE2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_PE2_CLR 0x00040000
+/** Clear Sleep Selection PE1
+    Clears the selection bit for domain PE1This domain contains the Processing Element 1 of the SCE. */
+#define SYS_GPE_SDCLR_PE1 0x00020000
+/* No-Operation
+#define SYS_GPE_SDCLR_PE1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_PE1_CLR 0x00020000
+/** Clear Sleep Selection PE0
+    Clears the selection bit for domain PE0This domain contains the Processing Element 0 of the SCE. */
+#define SYS_GPE_SDCLR_PE0 0x00010000
+/* No-Operation
+#define SYS_GPE_SDCLR_PE0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_PE0_CLR 0x00010000
+/** Clear Sleep Selection ARB
+    Clears the selection bit for domain ARBThis domain contains the Arbiter. */
+#define SYS_GPE_SDCLR_ARB 0x00002000
+/* No-Operation
+#define SYS_GPE_SDCLR_ARB_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_ARB_CLR 0x00002000
+/** Clear Sleep Selection FSQM
+    Clears the selection bit for domain FSQMThis domain contains the FSQM. */
+#define SYS_GPE_SDCLR_FSQM 0x00001000
+/* No-Operation
+#define SYS_GPE_SDCLR_FSQM_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_FSQM_CLR 0x00001000
+/** Clear Sleep Selection TMU
+    Clears the selection bit for domain TMUThis domain contains the TMU. */
+#define SYS_GPE_SDCLR_TMU 0x00000800
+/* No-Operation
+#define SYS_GPE_SDCLR_TMU_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_TMU_CLR 0x00000800
+/** Clear Sleep Selection MRG
+    Clears the selection bit for domain MRGThis domain contains the Merger. */
+#define SYS_GPE_SDCLR_MRG 0x00000400
+/* No-Operation
+#define SYS_GPE_SDCLR_MRG_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_MRG_CLR 0x00000400
+/** Clear Sleep Selection DISP
+    Clears the selection bit for domain DISPThis domain contains the Dispatcher. */
+#define SYS_GPE_SDCLR_DISP 0x00000200
+/* No-Operation
+#define SYS_GPE_SDCLR_DISP_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_DISP_CLR 0x00000200
+/** Clear Sleep Selection IQM
+    Clears the selection bit for domain IQMThis domain contains the IQM. */
+#define SYS_GPE_SDCLR_IQM 0x00000100
+/* No-Operation
+#define SYS_GPE_SDCLR_IQM_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_IQM_CLR 0x00000100
+/** Clear Sleep Selection CPUE
+    Clears the selection bit for domain CPUEThis domain contains all parts related to the CPU EGRESS interface. */
+#define SYS_GPE_SDCLR_CPUE 0x00000080
+/* No-Operation
+#define SYS_GPE_SDCLR_CPUE_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_CPUE_CLR 0x00000080
+/** Clear Sleep Selection CPUI
+    Clears the selection bit for domain CPUIThis domain contains all parts related to the CPU INGRESS interface. */
+#define SYS_GPE_SDCLR_CPUI 0x00000040
+/* No-Operation
+#define SYS_GPE_SDCLR_CPUI_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_CPUI_CLR 0x00000040
+/** Clear Sleep Selection GPONE
+    Clears the selection bit for domain GPONEThis domain contains all parts related to the GPON (GTC) EGRESS interface. */
+#define SYS_GPE_SDCLR_GPONE 0x00000020
+/* No-Operation
+#define SYS_GPE_SDCLR_GPONE_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_GPONE_CLR 0x00000020
+/** Clear Sleep Selection GPONI
+    Clears the selection bit for domain GPONIThis domain contains all parts related to the GPON (GTC) INGRESS interface. */
+#define SYS_GPE_SDCLR_GPONI 0x00000010
+/* No-Operation
+#define SYS_GPE_SDCLR_GPONI_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_GPONI_CLR 0x00000010
+/** Clear Sleep Selection LAN3
+    Clears the selection bit for domain LAN3This domain contains all parts related to the LAN3 interface. */
+#define SYS_GPE_SDCLR_LAN3 0x00000008
+/* No-Operation
+#define SYS_GPE_SDCLR_LAN3_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_LAN3_CLR 0x00000008
+/** Clear Sleep Selection LAN2
+    Clears the selection bit for domain LAN2This domain contains all parts related to the LAN2 interface. */
+#define SYS_GPE_SDCLR_LAN2 0x00000004
+/* No-Operation
+#define SYS_GPE_SDCLR_LAN2_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_LAN2_CLR 0x00000004
+/** Clear Sleep Selection LAN1
+    Clears the selection bit for domain LAN1This domain contains all parts related to the LAN1 interface. */
+#define SYS_GPE_SDCLR_LAN1 0x00000002
+/* No-Operation
+#define SYS_GPE_SDCLR_LAN1_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_LAN1_CLR 0x00000002
+/** Clear Sleep Selection LAN0
+    Clears the selection bit for domain LAN0This domain contains all parts related to the LAN0 interface. */
+#define SYS_GPE_SDCLR_LAN0 0x00000001
+/* No-Operation
+#define SYS_GPE_SDCLR_LAN0_NOP 0x00000000 */
+/** Clear */
+#define SYS_GPE_SDCLR_LAN0_CLR 0x00000001
+
+/* Fields of "IRNCS Capture Register" */
+/** FSQM wakeup request
+    The FSQM submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_FSQMWR 0x80000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_FSQMWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_FSQMWR_INTACK 0x80000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_FSQMWR_INTOCC 0x80000000
+/** GPONT wakeup request
+    The TCONT Request FIFO of port GPON submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_GPONTWR 0x20000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_GPONTWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_GPONTWR_INTACK 0x20000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_GPONTWR_INTOCC 0x20000000
+/** GPONE wakeup request
+    The EGRESS FIFO of port GPON submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_GPONEWR 0x10000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_GPONEWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_GPONEWR_INTACK 0x10000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_GPONEWR_INTOCC 0x10000000
+/** LAN3E wakeup request
+    The EGRESS FIFO of port LAN3 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3EWR 0x08000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN3EWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3EWR_INTACK 0x08000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN3EWR_INTOCC 0x08000000
+/** LAN2E wakeup requestThe ENGRESS FIFO of port LAN2 submitted a wakeup request.
+    This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2EWR 0x04000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN2EWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2EWR_INTACK 0x04000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN2EWR_INTOCC 0x04000000
+/** LAN1E wakeup request
+    The EGRESS FIFO of port LAN1 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1EWR 0x02000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN1EWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1EWR_INTACK 0x02000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN1EWR_INTOCC 0x02000000
+/** LAN0E wakeup request
+    The EGRESS FIFO of port LAN0 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0EWR 0x01000000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN0EWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0EWR_INTACK 0x01000000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN0EWR_INTOCC 0x01000000
+/** GPONI wakeup request
+    The INGRESS FIFO of port GPON submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_GPONIWR 0x00100000
+/* Nothing
+#define SYS_GPE_IRNCSCR_GPONIWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_GPONIWR_INTACK 0x00100000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_GPONIWR_INTOCC 0x00100000
+/** LAN3I wakeup request
+    The INGRESS FIFO of port LAN3 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3IWR 0x00080000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN3IWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3IWR_INTACK 0x00080000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN3IWR_INTOCC 0x00080000
+/** LAN2I wakeup request
+    The INGRESS FIFO of port LAN2 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2IWR 0x00040000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN2IWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2IWR_INTACK 0x00040000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN2IWR_INTOCC 0x00040000
+/** LAN1I wakeup request
+    The INGRESS FIFO of port LAN1 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1IWR 0x00020000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN1IWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1IWR_INTACK 0x00020000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN1IWR_INTOCC 0x00020000
+/** LAN0I wakeup request
+    The INGRESS FIFO of port LAN0 submitted a wakeup request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0IWR 0x00010000
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN0IWR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0IWR_INTACK 0x00010000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN0IWR_INTOCC 0x00010000
+/** FSQM sleep request
+    The FSQM submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_FSQMSR 0x00008000
+/* Nothing
+#define SYS_GPE_IRNCSCR_FSQMSR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_FSQMSR_INTACK 0x00008000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_FSQMSR_INTOCC 0x00008000
+/** GPONT sleep request
+    The TCONT Request FIFO of port GPON submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_GPONTSR 0x00002000
+/* Nothing
+#define SYS_GPE_IRNCSCR_GPONTSR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_GPONTSR_INTACK 0x00002000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_GPONTSR_INTOCC 0x00002000
+/** GPONE sleep request
+    The EGRESS FIFO of port GPON submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_GPONESR 0x00001000
+/* Nothing
+#define SYS_GPE_IRNCSCR_GPONESR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_GPONESR_INTACK 0x00001000
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_GPONESR_INTOCC 0x00001000
+/** LAN3E sleep request
+    The EGRESS FIFO of port LAN3 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3ESR 0x00000800
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN3ESR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3ESR_INTACK 0x00000800
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN3ESR_INTOCC 0x00000800
+/** LAN2E sleep requestThe ENGRESS FIFO of port LAN2 submitted a sleep request.
+    This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2ESR 0x00000400
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN2ESR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2ESR_INTACK 0x00000400
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN2ESR_INTOCC 0x00000400
+/** LAN1E sleep request
+    The EGRESS FIFO of port LAN1 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1ESR 0x00000200
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN1ESR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1ESR_INTACK 0x00000200
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN1ESR_INTOCC 0x00000200
+/** LAN0E sleep request
+    The EGRESS FIFO of port LAN0 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0ESR 0x00000100
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN0ESR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0ESR_INTACK 0x00000100
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN0ESR_INTOCC 0x00000100
+/** GPONI sleep request
+    The INGRESS FIFO of port GPON submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_GPONISR 0x00000010
+/* Nothing
+#define SYS_GPE_IRNCSCR_GPONISR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_GPONISR_INTACK 0x00000010
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_GPONISR_INTOCC 0x00000010
+/** LAN3I sleep request
+    The INGRESS FIFO of port LAN3 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3ISR 0x00000008
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN3ISR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN3ISR_INTACK 0x00000008
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN3ISR_INTOCC 0x00000008
+/** LAN2I sleep request
+    The INGRESS FIFO of port LAN2 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2ISR 0x00000004
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN2ISR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN2ISR_INTACK 0x00000004
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN2ISR_INTOCC 0x00000004
+/** LAN1I sleep request
+    The INGRESS FIFO of port LAN1 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1ISR 0x00000002
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN1ISR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN1ISR_INTACK 0x00000002
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN1ISR_INTOCC 0x00000002
+/** LAN0I sleep request
+    The INGRESS FIFO of port LAN0 submitted a sleep request. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0ISR 0x00000001
+/* Nothing
+#define SYS_GPE_IRNCSCR_LAN0ISR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define SYS_GPE_IRNCSCR_LAN0ISR_INTACK 0x00000001
+/** Read: Interrupt occurred. */
+#define SYS_GPE_IRNCSCR_LAN0ISR_INTOCC 0x00000001
+
+/* Fields of "IRNCS Interrupt Control Register" */
+/** FSQM wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_FSQMWR 0x80000000
+/** GPONT wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_GPONTWR 0x20000000
+/** GPONE wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_GPONEWR 0x10000000
+/** LAN3E wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN3EWR 0x08000000
+/** LAN2E wakeup requestThe ENGRESS FIFO of port LAN2 submitted a wakeup request.
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN2EWR 0x04000000
+/** LAN1E wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN1EWR 0x02000000
+/** LAN0E wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN0EWR 0x01000000
+/** GPONI wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_GPONIWR 0x00100000
+/** LAN3I wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN3IWR 0x00080000
+/** LAN2I wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN2IWR 0x00040000
+/** LAN1I wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN1IWR 0x00020000
+/** LAN0I wakeup request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN0IWR 0x00010000
+/** FSQM sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_FSQMSR 0x00008000
+/** GPONT sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_GPONTSR 0x00002000
+/** GPONE sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_GPONESR 0x00001000
+/** LAN3E sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN3ESR 0x00000800
+/** LAN2E sleep requestThe ENGRESS FIFO of port LAN2 submitted a sleep request.
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN2ESR 0x00000400
+/** LAN1E sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN1ESR 0x00000200
+/** LAN0E sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN0ESR 0x00000100
+/** GPONI sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_GPONISR 0x00000010
+/** LAN3I sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN3ISR 0x00000008
+/** LAN2I sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN2ISR 0x00000004
+/** LAN1I sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN1ISR 0x00000002
+/** LAN0I sleep request
+    Interrupt control bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSICR_LAN0ISR 0x00000001
+
+/* Fields of "IRNCS Interrupt Enable Register" */
+/** FSQM wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_FSQMWR 0x80000000
+/* Disable
+#define SYS_GPE_IRNCSEN_FSQMWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_FSQMWR_EN 0x80000000
+/** GPONT wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_GPONTWR 0x20000000
+/* Disable
+#define SYS_GPE_IRNCSEN_GPONTWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_GPONTWR_EN 0x20000000
+/** GPONE wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_GPONEWR 0x10000000
+/* Disable
+#define SYS_GPE_IRNCSEN_GPONEWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_GPONEWR_EN 0x10000000
+/** LAN3E wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN3EWR 0x08000000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN3EWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN3EWR_EN 0x08000000
+/** LAN2E wakeup requestThe ENGRESS FIFO of port LAN2 submitted a wakeup request.
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN2EWR 0x04000000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN2EWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN2EWR_EN 0x04000000
+/** LAN1E wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN1EWR 0x02000000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN1EWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN1EWR_EN 0x02000000
+/** LAN0E wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN0EWR 0x01000000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN0EWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN0EWR_EN 0x01000000
+/** GPONI wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_GPONIWR 0x00100000
+/* Disable
+#define SYS_GPE_IRNCSEN_GPONIWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_GPONIWR_EN 0x00100000
+/** LAN3I wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN3IWR 0x00080000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN3IWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN3IWR_EN 0x00080000
+/** LAN2I wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN2IWR 0x00040000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN2IWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN2IWR_EN 0x00040000
+/** LAN1I wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN1IWR 0x00020000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN1IWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN1IWR_EN 0x00020000
+/** LAN0I wakeup request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN0IWR 0x00010000
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN0IWR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN0IWR_EN 0x00010000
+/** FSQM sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_FSQMSR 0x00008000
+/* Disable
+#define SYS_GPE_IRNCSEN_FSQMSR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_FSQMSR_EN 0x00008000
+/** GPONT sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_GPONTSR 0x00002000
+/* Disable
+#define SYS_GPE_IRNCSEN_GPONTSR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_GPONTSR_EN 0x00002000
+/** GPONE sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_GPONESR 0x00001000
+/* Disable
+#define SYS_GPE_IRNCSEN_GPONESR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_GPONESR_EN 0x00001000
+/** LAN3E sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN3ESR 0x00000800
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN3ESR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN3ESR_EN 0x00000800
+/** LAN2E sleep requestThe ENGRESS FIFO of port LAN2 submitted a sleep request.
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN2ESR 0x00000400
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN2ESR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN2ESR_EN 0x00000400
+/** LAN1E sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN1ESR 0x00000200
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN1ESR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN1ESR_EN 0x00000200
+/** LAN0E sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN0ESR 0x00000100
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN0ESR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN0ESR_EN 0x00000100
+/** GPONI sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_GPONISR 0x00000010
+/* Disable
+#define SYS_GPE_IRNCSEN_GPONISR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_GPONISR_EN 0x00000010
+/** LAN3I sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN3ISR 0x00000008
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN3ISR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN3ISR_EN 0x00000008
+/** LAN2I sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN2ISR 0x00000004
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN2ISR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN2ISR_EN 0x00000004
+/** LAN1I sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN1ISR 0x00000002
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN1ISR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN1ISR_EN 0x00000002
+/** LAN0I sleep request
+    Interrupt enable bit for the corresponding bit in the IRNCSCR register. */
+#define SYS_GPE_IRNCSEN_LAN0ISR 0x00000001
+/* Disable
+#define SYS_GPE_IRNCSEN_LAN0ISR_DIS 0x00000000 */
+/** Enable */
+#define SYS_GPE_IRNCSEN_LAN0ISR_EN 0x00000001
+
+/*! @} */ /* SYS_GPE_REGISTER */
+
+#endif /* _sys_gpe_reg_h */
diff --git a/arch/mips/include/asm/arch-falcon/sysctrl.h b/arch/mips/include/asm/arch-falcon/sysctrl.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/sysctrl.h
@@ -0,0 +1,45 @@
+/*
+ * (C) Copyright 2011
+ * Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __FALCON_SYS_H
+#define __FALCON_SYS_H
+
+extern void sys1_hw_activate(u32 mask);
+extern void sys1_hw_deactivate(u32 mask);
+extern void sys1_hw_clk_enable(u32 mask);
+extern void sys1_hw_clk_disable(u32 mask);
+extern void sys1_hw_activate_or_reboot(u32 mask);
+
+extern void sys_eth_hw_activate(u32 mask);
+extern void sys_eth_hw_deactivate(u32 mask);
+extern void sys_eth_hw_clk_enable(u32 mask);
+extern void sys_eth_hw_clk_disable(u32 mask);
+extern void sys_eth_hw_activate_or_reboot(u32 mask);
+
+extern void sys_gpe_hw_activate(u32 mask);
+extern void sys_gpe_hw_deactivate(u32 mask);
+extern void sys_gpe_hw_clk_enable(u32 mask);
+extern void sys_gpe_hw_clk_disable(u32 mask);
+extern void sys_gpe_hw_activate_or_reboot(u32 mask);
+
+#endif /* __FALCON_SYS_H */
diff --git a/arch/mips/include/asm/arch-falcon/xbar_reg.h b/arch/mips/include/asm/arch-falcon/xbar_reg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/xbar_reg.h
@@ -0,0 +1,402 @@
+/******************************************************************************
+
+                               Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _xbar_reg_h
+#define _xbar_reg_h
+
+/** \addtogroup XBAR_REGISTER
+   @{
+*/
+/* access macros */
+#define xbar_r32(reg) reg_r32(&xbar->reg)
+#define xbar_w32(val, reg) reg_w32(val, &xbar->reg)
+#define xbar_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &xbar->reg)
+#define xbar_r32_table(reg, idx) reg_r32_table(xbar->reg, idx)
+#define xbar_w32_table(val, reg, idx) reg_w32_table(val, xbar->reg, idx)
+#define xbar_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, xbar->reg, idx)
+#define xbar_adr_table(reg, idx) adr_table(xbar->reg, idx)
+
+
+/** XBAR register structure */
+struct gpon_reg_xbar
+{
+   /** CPU Subsystem Identification Registert
+       t.b.d. */
+   unsigned int css_id; /* 0x00000000 */
+   /** Reserved */
+   unsigned int res_0[7]; /* 0x00000004 */
+   /** CPU Subsystem Transaction Initiator cpu Address Range Check Register
+       The permission to perform read and write operations from cpu to the different targets may be configured using this register. Operations, which are configured not to be allowed will be error-terminated at the input of the crossbar already. Disabling write permissions may be convenient to debug problems, where multiple ports interfere eachother's transactions by writing to the same destination. Caveat: DO NOT CHANGE THE PERMISSIONS FOR A PORT WHILE TRAFFIC IS GOING ON ON THAT PORT! */
+   unsigned int css_ti_cpu_chk; /* 0x00000020 */
+   /** Reserved */
+   unsigned int res_1[7]; /* 0x00000024 */
+   /** CPU Subsystem Transaction Target Security Register
+       The css_tt_sec register specifies the significant bits of the address range associated with the free-programmable address range. */
+   unsigned int css_tt_sec; /* 0x00000040 */
+   /** Reserved */
+   unsigned int res_2[57]; /* 0x00000044 */
+   /** CPU Subsystem Transaction Target fmi0 FPI Bus Master Control Registerm
+       Register css_tt_fmi0_cr controls the functionality of the FPI-Bus master interface and the associated Downsizer. */
+   unsigned int css_tt_fmi0_cr; /* 0x00000128 */
+   /** Reserved */
+   unsigned int res_3[53]; /* 0x0000012C */
+   /** CPU Subsystem Interrupt Node Enable Register
+       The interrupt node enable register CSS_IRNEN is used to enable/disable the propagation of individual interrupt signals from the Interrupt Node of the CPU Subsystem (CSS IRN) to the ICU. */
+   unsigned int css_irn_en; /* 0x00000200 */
+   /** Reserved */
+   unsigned int res_4; /* 0x00000204 */
+   /** CPU Subsystem Interrupt Node Control Register
+       The interrupt node control register CSS_IRNCR is used to read the masked value of the interrupt capture register CSS_IRNICR in the CSS interrupt node and to clear interrupts, after they have been processed by the CPU. */
+   unsigned int css_irn_cr; /* 0x00000208 */
+   /** Reserved */
+   unsigned int res_5; /* 0x0000020C */
+   /** CPU Subsystem Interrupt Node Interrupt Capture Register
+       The interrupt node interrupt capture register css_irn_icr is used to directly read/modify the captured interrupts inthe interrupt node of the CSS. Reading returns the unmasked value of the interrupts, that have been signalled by the CSS. Writing overwrites all values in the interrupt capture register, regardless whether the CSS has signalled interrupts or not. This can be used either to fake interrupts for test purposes or to kill interrupts, that are not interesting any more. For each css_irn_icr bit, hardware changes take precedence over software changes. If software tries to clear an interrupt bit by writing to css_irn_icr but at the same time the hardware signals a new interrupt condition, the interrupt bit will be set afterwards. */
+   unsigned int css_irn_icr; /* 0x00000210 */
+   /** Reserved */
+   unsigned int res_6[123]; /* 0x00000214 */
+   /** DDR SDRAM Controller Global Status Register 0
+       Register ddr_gsr0 holds general status information of the DDR SDRAM Controller. Note: The functionality of thisregister and status bits is not verified. */
+   unsigned int ddr_gsr0; /* 0x00000400 */
+   /** Reserved */
+   unsigned int res_7; /* 0x00000404 */
+   /** DDR SDRAM Controller Global Control Register 0
+       Register ddr_gcr1 controls the manually self refresh entry. Note: The functionality of this register and control bits is not verified. */
+   unsigned int ddr_gcr0; /* 0x00000408 */
+   /** Reserved */
+   unsigned int res_8; /* 0x0000040C */
+   /** DDR SDRAM Controller Global Control Register 1
+       Register ddr_gcr1 controls the driver strength of the SSTL_2 pads */
+   unsigned int ddr_gcr1; /* 0x00000410 */
+   /** Reserved */
+   unsigned int res_9; /* 0x00000414 */
+   /** DDR SDRAM Controller Transaction Initiator Priority Register
+       Register ddr_prio_ti controls the priority of the transaction initiators. */
+   unsigned int ddr_prio_ti; /* 0x00000418 */
+   /** Reserved */
+   unsigned int res_10; /* 0x0000041C */
+   /** DDR SDRAM Controller Echo Gate DLL Control Register 0
+       Register ddr_echo_dll0 controls the additional delay inserted by the DLL. */
+   unsigned int ddr_echo_dll0; /* 0x00000420 */
+   /** Reserved */
+   unsigned int res_11; /* 0x00000424 */
+   /** DDR SDRAM Controller Echo Gate DLL Control Register 1
+       Register ddr_echo_dll1 controls the additional delay inserted by the DLL. */
+   unsigned int ddr_echo_dll1; /* 0x00000428 */
+   /** Reserved */
+   unsigned int res_12[5]; /* 0x0000042C */
+   /** Select Control Register 0
+       Register pmon_pcesscr0 selects event and source to be forwarded to the CPU internal performance counter 0 */
+   unsigned int pmon_pcesscr0; /* 0x00000440 */
+   /** Select Control Register 1
+       Register pmon_pcesscr1 selects event and source to be forwarded to the CPU internal performance counter 1 */
+   unsigned int pmon_pcesscr1; /* 0x00000444 */
+   /** Select Control Register 2
+       Register pmon_pcesscr2 selects event and source to be forwarded to the CPU internal performance counter 2 */
+   unsigned int pmon_pcesscr2; /* 0x00000448 */
+   /** Select Control Register 3
+       Register pmon_pcesscr3 selects event and source to be forwarded to the CPU internal performance counter 3 */
+   unsigned int pmon_pcesscr3; /* 0x0000044C */
+   /** Select Control Register 4
+       Register pmon_pcesscr4 selects event and source to be forwarded to the CPU internal performance counter 4 */
+   unsigned int pmon_pcesscr4; /* 0x00000450 */
+   /** Select Control Register 5
+       Register pmon_pcesscr5 selects event and source to be forwarded to the CPU internal performance counter 5 */
+   unsigned int pmon_pcesscr5; /* 0x00000454 */
+   /** Select Control Register 6
+       Register pmon_pcesscr6 selects event and source to be forwarded to the CPU internal performance counter 6 */
+   unsigned int pmon_pcesscr6; /* 0x00000458 */
+   /** Select Control Register 7
+       Register pmon_pcesscr7 selects event and source to be forwarded to the CPU internal performance counter 7 */
+   unsigned int pmon_pcesscr7; /* 0x0000045C */
+   /** Reserved */
+   unsigned int res_13[744]; /* 0x00000460 */
+};
+
+
+/* Fields of "CPU Subsystem Identification Registert" */
+/** Field Layout
+    version number of the layout database */
+#define XBAR_CSS_ID_LAYOUT_MASK 0xFFFF0000
+/** field offset */
+#define XBAR_CSS_ID_LAYOUT_OFFSET 16
+/** Field rtl
+    version number of the RTL code */
+#define XBAR_CSS_ID_RTL_MASK 0x0000FFFF
+/** field offset */
+#define XBAR_CSS_ID_RTL_OFFSET 0
+
+/* Fields of "CPU Subsystem Transaction Initiator cpu Address Range Check Register" */
+/** Field tt_sec_write_en
+    enable write permission for crossbar input cpu to secure address range */
+#define XBAR_CSS_TI_CPU_CHK_TT_SEC_WRITE_EN 0x00200000
+/** Field tt_smi2_write_en
+    enable write permission for crossbar input cpu to SRAM bus SMI2 */
+#define XBAR_CSS_TI_CPU_CHK_TT_SMI2_WRITE_EN 0x00100000
+/** Field tt_smi0_write_en
+    enable write permission for crossbar input cpu to SRAM bus SMI0 */
+#define XBAR_CSS_TI_CPU_CHK_TT_SMI0_WRITE_EN 0x00080000
+/** Field tt_fmi0_write_en
+    enable write permission for crossbar input cpu to FPI bus FMI0 */
+#define XBAR_CSS_TI_CPU_CHK_TT_FMI0_WRITE_EN 0x00040000
+/** Field tt_ddr_write_end
+    enable write permission for crossbar input cpu to DDR SDRAM controller */
+#define XBAR_CSS_TI_CPU_CHK_TT_DDR_WRITE_EN 0x00020000
+/** Field tt_ebu_write_en
+    enable write permission for crossbar input cpu to EBU */
+#define XBAR_CSS_TI_CPU_CHK_TT_EBU_WRITE_EN 0x00010000
+/** Field tt_sec_read_en
+    enable read permission for crossbar input cpu to secure address range */
+#define XBAR_CSS_TI_CPU_CHK_TT_SEC_READ_EN 0x00000020
+/** Field tt_smi2_read_en
+    enable read permission for crossbar input cpu to SRAM bus SMI2 */
+#define XBAR_CSS_TI_CPU_CHK_TT_SMI2_READ_EN 0x00000010
+/** Field tt_smi0_read_en
+    enable read permission for crossbar input cpu to SRAM bus SMI0 */
+#define XBAR_CSS_TI_CPU_CHK_TT_SMI0_READ_EN 0x00000008
+/** Field tt_fmi0_read_en
+    enable read permission for crossbar input cpu to FPI bus FMI0 */
+#define XBAR_CSS_TI_CPU_CHK_TT_FMI0_READ_EN 0x00000004
+/** Field tt_ddr_read_en
+    enable read permission for crossbar input cpu to DDR SDRAM controller */
+#define XBAR_CSS_TI_CPU_CHK_TT_DDR_READ_EN 0x00000002
+/** Field tt_ebu_read_en
+    enable read permission for crossbar input cpu to EBU */
+#define XBAR_CSS_TI_CPU_CHK_TT_EBU_READ_EN 0x00000001
+
+/* Fields of "CPU Subsystem Transaction Target Security Register" */
+/** Field base
+    Base Address of Security Address Range: Specifies the base address of the address range associated with the free programmable address range. */
+#define XBAR_CSS_TT_SEC_BASE_MASK 0xFFF00000
+/** field offset */
+#define XBAR_CSS_TT_SEC_BASE_OFFSET 20
+/** Field cmp
+    Significant Bits of a Memory Address Range: Specifies these address bits which are used in the address comparison: 0xF00 256MByte The freeprogrammable address range is 256 MByte, 0xF80 128MByte The freeprogrammableaddress range is 128 MByte, 0xFC0 64MByte The freeprogrammableaddress range is 64 MByte, 0xFE0 32MByte The freeprogrammableaddress range is 32 MByte, 0xFF0 16MByte The freeprogrammableaddress range is 16 MByte, 0xFF8 8MByte The freeprogrammableaddress range is 8 MByte, 0xFFC 4MByte The freeprogrammableaddress range is 4 MByte */
+#define XBAR_CSS_TT_SEC_CMP_MASK 0x0000FFF0
+/** field offset */
+#define XBAR_CSS_TT_SEC_CMP_OFFSET 4
+/** Field inverse
+    Invert secure range (encoding 0 = protect addresses within secure range, 1 = protect addresses outside of secure range). */
+#define XBAR_CSS_TT_SEC_INVERSE 0x00000001
+
+/* Fields of "CPU Subsystem Transaction Target fmi0 FPI Bus Master Control Registerm" */
+/** Field burst2single
+    Burst to Single: 1 B2S1 All MemPort transactions are performed as a sequence of single data transfers on the FPI bus. This allows to restrict the FPI commands to a minimum subset, which can be expected to be acceptable by all kinds of slaves. */
+#define XBAR_CSS_TT_FMI0_CR_BURST2SINGLE 0x00000001
+
+/* Fields of "CPU Subsystem Interrupt Node Enable Register" */
+/** Field unused
+    Unused Asynchronous Interrupt Enable Bit */
+#define XBAR_CSS_IRN_EN_UNUSED 0x00000004
+/** Field ti_cpu_cerr
+    Transaction Initiator cpu Conflict Interrupt Request Enable. 0 DIS the propagation of the interrupt request is disabled, 1 EN the propagation of the interrupt request is enablede */
+#define XBAR_CSS_IRN_EN_TI_CPU_CERR 0x00000002
+/* Disable
+#define XBAR_CSS_IRN_EN_TI_CPU_CERR_DIS 0x00000000 */
+/** Enable */
+#define XBAR_CSS_IRN_EN_TI_CPU_CERR_EN 0x00000002
+/** Field ti_cpu_werr
+    Transaction Initiator cpu Write Error Interrupt Request Enable. 0 DIS the propagation of the interrupt request is disabled, 1 EN the propagation of the interrupt request is enabled */
+#define XBAR_CSS_IRN_EN_TI_CPU_WERR 0x00000001
+/* Disable
+#define XBAR_CSS_IRN_EN_TI_CPU_WERR_DIS 0x00000000 */
+/** Enable */
+#define XBAR_CSS_IRN_EN_TI_CPU_WERR_EN 0x00000001
+
+/* Fields of "CPU Subsystem Interrupt Node Control Register" */
+/** Field unused
+    Unused Asynchronous Interrupt Control Bit */
+#define XBAR_CSS_IRN_CR_UNUSED 0x00000004
+/** Field ti_cpu_cerr
+    Transaction Initiator cpu Conflict Interrupt Request. Writing 1 clears the interrupt request in css_irn_icr.ti_cpu_cerr. Writing 0 has no effect. Reading returns the logical AND of css_irn_icr.ti_cpu_cerr and css_irn_en.ti_cpu_cerr. */
+#define XBAR_CSS_IRN_CR_TI_CPU_CERR_1 0x00000002
+/** Field ti_cpu_werr
+    Transaction Initiator cpu Write Error Interrupt Request. Writing 1 clears the interrupt request in css_irn_icr.ti_cpu_werr. Writing 0 has no effect. Reading returns the logical AND of css_irn_icr.ti_cpu_werr and css_irn_en.ti_cpu_werr */
+#define XBAR_CSS_IRN_CR_TI_CPU_WERR_1 0x00000001
+
+/* Fields of "CPU Subsystem Interrupt Node Interrupt Capture Register" */
+/** Field unused
+    Unused Asynchronous Interrupt Capture Bit */
+#define XBAR_CSS_IRN_ICR_UNUSED 0x00000004
+/** Field ti_cpu_cerr
+    Transaction Initiator cpu Conflict Interrupt Request. If ti_cpu_cerr is set, a interrupt request is signalled depending on the css_irn_en.ti_cpu_cerr bit. If ti_cpu_cerr is cleared, a interrupt request is killed. Reading shows, whether a interrupt request has been captured by the interrupt node (even if the interrupt is not forwarded to the CPU, because it is disabled in css_irn_en register). */
+#define XBAR_CSS_IRN_ICR_TI_CPU_CERR_2 0x00000002
+/** Field ti_cpu_werr
+    Transaction Initiator cpu Write Error Interrupt Request. If ti_cpu_werr is set, a interrupt request is signalled depending on the css_irn_en.ti_cpu_werr bit. If ti_cpu_werr is cleared, a interrupt request is killed. Reading shows, whether a interrupt request has been captured by the interrupt node (even if the interrupt is not forwarded to the CPU, because it is disabled in css_irn_en register). */
+#define XBAR_CSS_IRN_ICR_TI_CPU_WERR_2 0x00000001
+
+/* Fields of "DDR SDRAM Controller Global Status Register 0" */
+/** Command Queue Full Status
+    Indicates that the command queue is full. While this bit is high, the command queue will not capture any command requests. */
+#define XBAR_DDR_GSR0_CQF 0x00000020
+/** Queue Almost Full Status
+    Indicates that the queue has reached the value set in the q_fullness parameter. 1 QAF_1 Queue almost full */
+#define XBAR_DDR_GSR0_QAF 0x00000010
+/** Controller Busy Status
+    Status signal from the DDR SDRAM controller. This will only be low when the DDR SDRAM controller is neither reading data, writing data nor processing a command. 1 cbusy_1 DDR SDRAM controller is bus */
+#define XBAR_DDR_GSR0_CBUSY 0x00000008
+/** Refresh in Process Status
+    Active-high signal that indicates that the memory controller is executing a refresh command. This signal is asserted when a refresh command is sent to the DRAM devices and remains asserted until the refresh command has completed. 1 rip_1 Refresh in process for the DDR SDRAM device(s) */
+#define XBAR_DDR_GSR0_RIP 0x00000004
+/** cke Signal Status
+    Status bit cke reflects level of the cke_status signal, which indicates if the DDR SDRAM device(s) are in either in self-refresh or power-down mode. This signal is the status of the control_cke signal inside the DDR SDRAM controller, but may be delayed via the bit field CKE_DELAY to reflect the cke status on the DDR SDRAM interface. 1 cke_1 e */
+#define XBAR_DDR_GSR0_CKE 0x00000002
+/** Self-Refresh Acknolwdge
+    Status bit sra reflects the level of the acknowledge signal srefresh_ack, which indicates if the DDR SDRAM device(s) are in self-refresh mode. This signal will only be asserted if the DDR SDRAM device(s) have been placed into self-refresh mode through the assertion of the request bit SRR and the assoicated srefresh_enter signal and if this signal is still held high until the DDR SDRAM device(s) enters selfrefresh mode. 1 sra_1 DDR SDRAM device(s) are in self-refresh modeh */
+#define XBAR_DDR_GSR0_SRA 0x00000001
+
+/* Fields of "DDR SDRAM Controller Global Control Register 0" */
+/** Self-Refresh Request
+    Writing 1 to SRR activates signal srefsh_enter, which initiates a selfrefresh to the DDR SDRAM devices(s) and updates bit SREFRESH. Request bit SRR and signal srefsh_enter is driven active-high, until the DDR SDRAM controller acknowledges via signal srefresh_ack that the DDR SDRAM devices(s) have entered self-refresh mode. 0 SRR_0 No action, 1 SRR_1 Request the DDR SDRAM devices(s) to enter selfrefresh mode */
+#define XBAR_DDR_GCR0_SRR 0x00000001
+
+/* Fields of "DDR SDRAM Controller Global Control Register 1" */
+/** Field ck
+    SSTL_2 Class I or Class II Output Driver Strength per CK/CKn. Controls the driving strength of the SSTL_2 output driver associated with the clock signals CK/CKn: 0 CLASS_I SSTL_2 class I output driver strength for CK/CKn, 1 CLASS_II SSTL_2 class II output driver strength for CK/CK */
+#define XBAR_DDR_GCR1_CK 0x00000020
+/** Field ca
+    SSTL_2 Class I or Class II Output Driver Strength per CA. Controls the driving strength of the SSTL_2 output driver associated with the command and address bus. There is one control bit for the CA block: 0 CLASS_I SSTL_2 class I output driver strength for CA, 1 CLASS_II SSTL_2 class II output driver strength for CA */
+#define XBAR_DDR_GCR1_CA 0x00000010
+/** Field3
+    SSTL_2 Class I or Class II Output Driver Strength per Data Slice #3Controls the driving strength of the SSTL_2 output driver associated with Data Slice #3. 0 CLASS_I SSTL_2 class I output driver strength for DQ[31:24], 1 CLASS_II SSTL_2 class II output driver strength for DQ[31:24] */
+#define XBAR_DDR_GCR1_DS3 0x00000008
+/** Field2
+    SSTL_2 Class I or Class II Output Driver Strength per Data Slice #2Controls the driving strength of the SSTL_2 output driver associated with Data Slice #2. 0 CLASS_I SSTL_2 class I output driver strength for DQ[23:16], 1 CLASS_II SSTL_2 class II output driver strength for DQ[23:16] */
+#define XBAR_DDR_GCR1_DS2 0x00000004
+/** Field1
+    SSTL_2 Class I or Class II Output Driver Strength per Data Slice #1Controls the driving strength of the SSTL_2 output driver associated with Data Slice #1. 0 CLASS_I SSTL_2 class I output driver strength for DQ[15:8], 1 CLASS_II SSTL_2 class II output driver strength for DQ[15:8] */
+#define XBAR_DDR_GCR1_DS1 0x00000002
+/** Field0
+    SSTL_2 Class I or Class II Output Driver Strength per Data Slice #0Controls the driving strength of the SSTL_2 output driver associated with Data Slice #0. 0 CLASS_I SSTL_2 class I output driver strength for DQ[7:0], 1 CLASS_II SSTL_2 class II output driver strength for DQ[7:0] */
+#define XBAR_DDR_GCR1_DS0 0x00000001
+
+/* Fields of "DDR SDRAM Controller Transaction Initiator Priority Register" */
+/** Field disable_dmc2pad_rx_enable
+    disable dynamic receiver enable */
+#define XBAR_DDR_PRIO_TI_DISABLE_DMC2PAD_RX_ENABLE 0x00010000
+/** Field dr_prio_ti_cpu
+    ddr controller priority for transactions from initiator cpu */
+#define XBAR_DDR_PRIO_TI_DR_PRIO_TI_CPU_MASK 0x00000030
+/** field offset */
+#define XBAR_DDR_PRIO_TI_DR_PRIO_TI_CPU_OFFSET 4
+
+/* Fields of "DDR SDRAM Controller Echo Gate DLL Control Register 0" */
+/** Field echo_dll0
+    ddr controller DLL sel value */
+#define XBAR_DDR_ECHO_DLL0_ECHO_DLL0_MASK 0x000000FF
+/** field offset */
+#define XBAR_DDR_ECHO_DLL0_ECHO_DLL0_OFFSET 0
+
+/* Fields of "DDR SDRAM Controller Echo Gate DLL Control Register 1" */
+/** Field echo_dll1
+    ddr controller DLL sel value */
+#define XBAR_DDR_ECHO_DLL1_ECHO_DLL1_MASK 0x000000FF
+/** field offset */
+#define XBAR_DDR_ECHO_DLL1_ECHO_DLL1_OFFSET 0
+
+/* Fields of "Select Control Register 0" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 0 */
+#define XBAR_PMON_PCESSCR0_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR0_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 0 */
+#define XBAR_PMON_PCESSCR0_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR0_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 1" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 1 */
+#define XBAR_PMON_PCESSCR1_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR1_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 1 */
+#define XBAR_PMON_PCESSCR1_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR1_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 2" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 2 */
+#define XBAR_PMON_PCESSCR2_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR2_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 2 */
+#define XBAR_PMON_PCESSCR2_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR2_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 3" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 3 */
+#define XBAR_PMON_PCESSCR3_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR3_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 3 */
+#define XBAR_PMON_PCESSCR3_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR3_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 4" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 4 */
+#define XBAR_PMON_PCESSCR4_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR4_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 4 */
+#define XBAR_PMON_PCESSCR4_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR4_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 5" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 5 */
+#define XBAR_PMON_PCESSCR5_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR5_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 5 */
+#define XBAR_PMON_PCESSCR5_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR5_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 6" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 6 */
+#define XBAR_PMON_PCESSCR6_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR6_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 6 */
+#define XBAR_PMON_PCESSCR6_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR6_EVENT_OFFSET 0
+
+/* Fields of "Select Control Register 7" */
+/** Field source
+    This bit field selects one source to be forwarded to the CPU internal performance counter 7 */
+#define XBAR_PMON_PCESSCR7_SOURCE_MASK 0x0000007C
+/** field offset */
+#define XBAR_PMON_PCESSCR7_SOURCE_OFFSET 2
+/** Field event
+    This bit field selects one event to be forwarded to the CPU internal performance counter 7 */
+#define XBAR_PMON_PCESSCR7_EVENT_MASK 0x00000003
+/** field offset */
+#define XBAR_PMON_PCESSCR7_EVENT_OFFSET 0
+
+/*! @} */ /* XBAR_REGISTER */
+
+#endif /* _xbar_reg_h */
diff --git a/arch/mips/include/asm/falcon.h b/arch/mips/include/asm/falcon.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/falcon.h
@@ -0,0 +1,32 @@
+/*
+ * (C) Copyright 2011 Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+extern phys_size_t falcon_ddr_init(void);
+extern void print_chip_info(void);
+extern void falcon_early_init_f(void);
+extern void falcon_misc_init_r(void);
+extern void falcon_extphy_enable(int enable);
+extern void load_default_ethaddr(void);
+extern void falcon_dcdc_core_set_voltage(unsigned int voltage);
+extern int falcon_dcdc_core_init(unsigned int voltage);
+extern int falcon_dcdc_ddr_init(unsigned int voltage);
+
diff --git a/arch/mips/include/asm/gpio.h b/arch/mips/include/asm/gpio.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/gpio.h
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2011
+ * Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ASM_MIPS_GPIO_H_
+#define _ASM_MIPS_GPIO_H_
+
+extern int gpio_request(unsigned gpio, const char *label);
+extern void gpio_free(unsigned gpio);
+extern int gpio_direction_input(unsigned gpio);
+extern int gpio_direction_output(unsigned gpio, int value);
+extern int gpio_get_value(unsigned gpio);
+extern void gpio_set_value(unsigned gpio, int value);
+
+#endif /* _ASM_MIPS_GPIO_H_ */
