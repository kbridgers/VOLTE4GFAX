add ifx targets (easy50712,...)
fixme: split into separate patches

diff --git a/Makefile b/Makefile
--- a/Makefile
+++ b/Makefile
@@ -557,7 +557,7 @@ checkstack:	$(obj)u-boot
 	set -e ; \
 	: Extract the config macros ; \
 	$(CPP) $(CFLAGS) -DDO_DEPS_ONLY -dM include/common.h | \
-		sed -n -f tools/scripts/define2mk.sed > $@.tmp && \
+		sed -n -f tools/scripts/define2mk.sed |sort > $@.tmp && \
 	mv $@.tmp $@
 
 $(obj)include/generated/generic-asm-offsets.h:	$(obj)include/autoconf.mk.dep \
diff --git a/arch/mips/cpu/mips32/ar9/Makefile b/arch/mips/cpu/mips32/ar9/Makefile
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/ar9/Makefile
@@ -0,0 +1,46 @@
+#########################################################################
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS	= clock.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/ar9/clock.c b/arch/mips/cpu/mips32/ar9/clock.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/ar9/clock.c
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/ar9.h>
+
+ulong ifx_get_ddr_hz(void)
+{
+	switch((*AR9_CGU_SYS) & 0x05) {
+		case 0x01: 
+		case 0x05: 
+		return CLOCK_111M;
+	
+		case 0x00: 
+		case 0x04: 
+		return CLOCK_166M;
+	}
+
+	return 0;
+}
+
+ulong get_cpuclk(void)
+{
+	switch((*AR9_CGU_SYS) & 0x05) {
+		case 0x00: 
+		case 0x01: 
+		return CLOCK_333M;
+
+		case 0x04: 
+		return CLOCK_166M;
+
+		case 0x05: 
+		return CLOCK_111M;
+	}
+
+	return 0;
+}
+
+ulong get_bus_freq(ulong dummy)
+{
+	unsigned int ddr_clock=ifx_get_ddr_hz();
+	if((*AR9_CGU_SYS) & 0x40){
+		return ddr_clock/2;
+	} else {
+		return ddr_clock;
+	}
+}
diff --git a/arch/mips/cpu/mips32/ar9/ifx_cache.S b/arch/mips/cpu/mips32/ar9/ifx_cache.S
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/ar9/ifx_cache.S
@@ -0,0 +1,60 @@
+
+#define IFX_CACHE_EXTRA_INVALID_TAG						\
+	mtc0	zero, CP0_TAGLO, 1;						\
+	mtc0	zero, CP0_TAGLO, 2;						\
+	mtc0	zero, CP0_TAGLO, 3;						\
+	mtc0	zero, CP0_TAGLO, 4;
+
+#define IFX_CACHE_EXTRA_OPERATION						\
+	/* set WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ECCF_WST;							\
+	or	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	li	a0, K0BASE;							\
+	move	a2, t2;		/* icacheSize */				\
+	move	a3, t4;		/* icacheLineSize */				\
+	move	a1, a2;								\
+	icacheop(a0,a1,a2,a3,(Index_Store_Tag_I));				\
+										\
+	/* clear WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ~ECCF_WST;							\
+	and	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	/* 1: initialise dcache tags. */					\
+										\
+	/* cache line size */							\
+	li	a2, CFG_CACHELINE_SIZE;						\
+	/* kseg0 mem address */							\
+	li	a1, 0;								\
+	li	a3, CFG_CACHE_SETS * CFG_CACHE_WAYS;				\
+1:										\
+	/* store tag (invalid, not locked) */					\
+	cache 0x8, 0(a1);							\
+	cache 0x9, 0(a1);							\
+										\
+	add	a3, -1;								\
+	bne	a3, zero, 1b;							\
+	add	a1, a2;								\
+										\
+	/* set WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ECCF_WST;							\
+	or	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	li	a0, K0BASE;							\
+	move	a2, t3;		/* dcacheSize */				\
+	move	a3, t5;		/* dcacheLineSize */				\
+	move	a1, a2;								\
+	icacheop(a0,a1,a2,a3,(Index_Store_Tag_D));				\
+										\
+	/* clear WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ~ECCF_WST;							\
+	and	a0, a1;								\
+	mtc0	a0, CP0_ECC;
+
diff --git a/arch/mips/cpu/mips32/danube/Makefile b/arch/mips/cpu/mips32/danube/Makefile
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/Makefile
@@ -0,0 +1,48 @@
+#########################################################################
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y += clock.o
+COBJS-$(CONFIG_FLASH_CFI_DRIVER) += ebu_nor.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/danube/clock.c b/arch/mips/cpu/mips32/danube/clock.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/clock.c
@@ -0,0 +1,65 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/danube.h>
+
+ulong ifx_get_ddr_hz(void)
+{
+	static const ulong ddr_freq[] = {166666667,133333333,111111111,83333333};
+	return ddr_freq[((*DANUBE_CGU_SYS) & 0x3)];
+}
+
+ulong get_cpuclk(void)
+{
+#ifdef CONFIG_USE_EMULATOR
+	return EMULATOR_CPU_SPEED;
+#else //NOT CONFIG_USE_EMULATOR
+	unsigned int ddr_clock=ifx_get_ddr_hz();
+	switch((*DANUBE_CGU_SYS) & 0xc){
+		case 0:
+		default:
+			return 323333333;
+		case 4:
+			return ddr_clock;
+		case 8:
+			return ddr_clock << 1;
+	}
+#endif
+}
+
+ulong get_bus_freq(ulong dummy)
+{
+#ifdef CONFIG_USE_EMULATOR
+	unsigned int  clkCPU;
+	clkCPU = ifx_get_cpuclk();
+	return clkCPU >> 2;
+#else //NOT CONFIG_USE_EMULATOR
+	unsigned int ddr_clock=ifx_get_ddr_hz();
+	if ((*DANUBE_CGU_SYS) & 0x40){
+		return ddr_clock >> 1;
+	}
+	return ddr_clock;
+#endif
+}
+
diff --git a/arch/mips/cpu/mips32/danube/ebu_nor.c b/arch/mips/cpu/mips32/danube/ebu_nor.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/ebu_nor.c
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2011
+ * Thomas Langer, Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+
+#include <asm/io.h>
+
+static inline void *flash_fixup_addr(void *addr)
+{
+	void *fix_addr = ((void *)((ulong) (addr) ^ 2));
+	return fix_addr;
+}
+
+/*
+ * Accessor functions replacing the "weak" functions in
+ * drivers/mtd/cfi_flash.c
+ */
+void flash_write8(u8 value, void *addr)
+{
+	__raw_writeb(value, flash_fixup_addr(addr));
+}
+void flash_write8_data(u8 value, void *addr)
+{
+	__raw_writeb(value, addr);
+}
+void flash_write16(u16 value, void *addr)
+{
+	__raw_writew(value, flash_fixup_addr(addr));
+}
+void flash_write16_data(u16 value, void *addr)
+{
+	__raw_writew(value, addr);
+}
+u8 flash_read8(void *addr)
+{
+	return __raw_readb(flash_fixup_addr(addr));
+}
+u8 flash_read8_data(void *addr)
+{
+	return __raw_readb(addr);
+}
+u16 flash_read16(void *addr)
+{
+	return __raw_readw(flash_fixup_addr(addr));
+}
+u16 flash_read16_data(void *addr)
+{
+	return __raw_readw(addr);
+}
diff --git a/arch/mips/cpu/mips32/danube/ifx_cache.S b/arch/mips/cpu/mips32/danube/ifx_cache.S
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/ifx_cache.S
@@ -0,0 +1,60 @@
+
+#define IFX_CACHE_EXTRA_INVALID_TAG						\
+	mtc0	zero, CP0_TAGLO, 1;						\
+	mtc0	zero, CP0_TAGLO, 2;						\
+	mtc0	zero, CP0_TAGLO, 3;						\
+	mtc0	zero, CP0_TAGLO, 4;
+
+#define IFX_CACHE_EXTRA_OPERATION						\
+	/* set WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ECCF_WST;							\
+	or	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	li	a0, K0BASE;							\
+	move	a2, t2;		/* icacheSize */				\
+	move	a3, t4;		/* icacheLineSize */				\
+	move	a1, a2;								\
+	icacheop(a0,a1,a2,a3,(Index_Store_Tag_I));				\
+										\
+	/* clear WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ~ECCF_WST;							\
+	and	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	/* 1: initialise dcache tags. */					\
+										\
+	/* cache line size */							\
+	li	a2, CFG_CACHELINE_SIZE;						\
+	/* kseg0 mem address */							\
+	li	a1, 0;								\
+	li	a3, CFG_CACHE_SETS * CFG_CACHE_WAYS;				\
+1:										\
+	/* store tag (invalid, not locked) */					\
+	cache 0x8, 0(a1);							\
+	cache 0x9, 0(a1);							\
+										\
+	add	a3, -1;								\
+	bne	a3, zero, 1b;							\
+	add	a1, a2;								\
+										\
+	/* set WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ECCF_WST;							\
+	or	a0, a1;								\
+	mtc0	a0, CP0_ECC;							\
+										\
+	li	a0, K0BASE;							\
+	move	a2, t3;		/* dcacheSize */				\
+	move	a3, t5;		/* dcacheLineSize */				\
+	move	a1, a2;								\
+	icacheop(a0,a1,a2,a3,(Index_Store_Tag_D));				\
+										\
+	/* clear WST bit */							\
+	mfc0	a0, CP0_ECC;							\
+	li	a1, ~ECCF_WST;							\
+	and	a0, a1;								\
+	mtc0	a0, CP0_ECC;
+
diff --git a/arch/mips/include/asm/ar9.h b/arch/mips/include/asm/ar9.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/ar9.h
@@ -0,0 +1,424 @@
+/*
+ * (C) Copyright 2011
+ * Ralph Hempel
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/***********************************************************************/
+/*  Module      :  PMU register address and bits                       */
+/***********************************************************************/
+#define AR9_PMU									(0xBF102000)
+/* PMU Power down Control Register */
+#define AR9_PMU_PWDCR							((volatile u32*)(AR9_PMU + 0x001C))
+/* PMU Status Register */
+#define AR9_PMU_SR								((volatile u32*)(AR9_PMU + 0x0020))
+/** DMA block */
+#define AR9_PMU_DMA								(1<<5)
+#define AR9_PMU_SDIO							(1<<16)
+#define AR9_PMU_USB0							(1<<6)
+#define AR9_PMU_USB0_P							(1<<0)
+#define AR9_PMU_SWITCH							(1<<28)
+
+
+/***********************************************************************/
+/*  Module      :  RCU register address and bits                       */
+/***********************************************************************/
+#define AR9_RCU_BASE_ADDR						(0xBF203000)
+#define AR9_RCU_RST_REQ							((volatile u32*)(AR9_RCU_BASE_ADDR + 0x0010))
+#define AR9_RCU_RST_STAT						((volatile u32*)(AR9_RCU_BASE_ADDR + 0x0014))
+#define AR9_RST_ALL								(1 << 30)
+
+/*** Reset Request Register Bits ***/
+#define AR9_RCU_RST_REQ_SRST					(1 << 30)
+#define AR9_RCU_RST_REQ_ARC_JTAG				(1 << 20)
+#define AR9_RCU_RST_REQ_PCI						(1 << 13)
+#define AR9_RCU_RST_REQ_AFE						(1 << 11)
+#define AR9_RCU_RST_REQ_SDIO					(1 << 19)
+#define AR9_RCU_RST_REQ_DMA						(1 << 9)
+#define AR9_RCU_RST_REQ_PPE						(1 << 8)
+#define AR9_RCU_RST_REQ_DFE						(1 << 7)
+
+/***********************************************************************/
+/*  Module      :  GPIO register address and bits                       */
+/***********************************************************************/
+#define AR9_GPIO								(0xBE100B00)
+/***Port 0 Data Output Register (0010H)***/
+#define AR9_GPIO_P0_OUT							((volatile u32 *)(AR9_GPIO+ 0x0010))
+/***Port 1 Data Output Register (0040H)***/
+#define AR9_GPIO_P1_OUT							((volatile u32 *)(AR9_GPIO+ 0x0040))
+/***Port 2 Data Output Register (0070H)***/
+#define AR9_GPIO_P2_OUT							((volatile u32 *)(AR9_GPIO+ 0x0070))
+/***Port 3 Data Output Register (00A0H)***/
+#define AR9_GPIO_P3_OUT							((volatile u32 *)(AR9_GPIO+ 0x00A0))
+/***Port 0 Data Input Register (0014H)***/
+#define AR9_GPIO_P0_IN							((volatile u32 *)(AR9_GPIO+ 0x0014))
+/***Port 1 Data Input Register (0044H)***/
+#define AR9_GPIO_P1_IN							((volatile u32 *)(AR9_GPIO+ 0x0044))
+/***Port 2 Data Input Register (0074H)***/
+#define AR9_GPIO_P2_IN							((volatile u32 *)(AR9_GPIO+ 0x0074))
+/***Port 3 Data Input Register (00A4H)***/
+#define AR9_GPIO_P3_IN							((volatile u32 *)(AR9_GPIO+ 0x00A4))
+/***Port 0 Direction Register (0018H)***/
+#define AR9_GPIO_P0_DIR							((volatile u32 *)(AR9_GPIO+ 0x0018))
+/***Port 1 Direction Register (0048H)***/
+#define AR9_GPIO_P1_DIR							((volatile u32 *)(AR9_GPIO+ 0x0048))
+/***Port 2 Direction Register (0078H)***/
+#define AR9_GPIO_P2_DIR							((volatile u32 *)(AR9_GPIO+ 0x0078))
+/***Port 3 Direction Register (0048H)***/
+#define AR9_GPIO_P3_DIR							((volatile u32 *)(AR9_GPIO+ 0x00A8))
+/***Port 0 Alternate Function Select Register 0 (001C H) ***/
+#define AR9_GPIO_P0_ALTSEL0						((volatile u32 *)(AR9_GPIO+ 0x001C))
+/***Port 1 Alternate Function Select Register 0 (004C H) ***/
+#define AR9_GPIO_P1_ALTSEL0						((volatile u32 *)(AR9_GPIO+ 0x004C))
+/***Port 2 Alternate Function Select Register 0 (007C H) ***/
+#define AR9_GPIO_P2_ALTSEL0						((volatile u32 *)(AR9_GPIO+ 0x007C))
+/***Port 3 Alternate Function Select Register 0 (00AC H) ***/
+#define AR9_GPIO_P3_ALTSEL0						((volatile u32 *)(AR9_GPIO+ 0x00AC))
+/***Port 0 Alternate Function Select Register 1 (0020 H) ***/
+#define AR9_GPIO_P0_ALTSEL1						((volatile u32 *)(AR9_GPIO+ 0x0020))
+/***Port 1 Alternate Function Select Register 0 (0050 H) ***/
+#define AR9_GPIO_P1_ALTSEL1					((volatile u32 *)(AR9_GPIO+ 0x0050))
+/***Port 2 Alternate Function Select Register 0 (0080 H) ***/
+#define AR9_GPIO_P2_ALTSEL1						((volatile u32 *)(AR9_GPIO+ 0x0080))
+/***Port 3 Alternate Function Select Register 0 (0064 H) ***/
+#define AR9_GPIO_P3_ALTSEL1						((volatile u32 *)(AR9_GPIO+ 0x0064))
+/***Port 0 Open Drain Control Register (0024H)***/
+#define AR9_GPIO_P0_OD							((volatile u32 *)(AR9_GPIO+ 0x0024))
+/***Port 1 Open Drain Control Register (0054H)***/
+#define AR9_GPIO_P1_OD							((volatile u32 *)(AR9_GPIO+ 0x0054))
+/***Port 2 Open Drain Control Register (0084H)***/
+#define AR9_GPIO_P2_OD							((volatile u32 *)(AR9_GPIO+ 0x0084))
+/***Port 3 Open Drain Control Register (0034H)***/
+#define AR9_GPIO_P3_OD							((volatile u32 *)(AR9_GPIO+ 0x0034))
+/***Port 0 Input Schmitt-Trigger Off Register (0028 H) ***/
+#define AR9_GPIO_P0_STOFF						((volatile u32 *)(AR9_GPIO+ 0x0028))
+/***Port 1 Input Schmitt-Trigger Off Register (0058 H) ***/
+#define AR9_GPIO_P1_STOFF						((volatile u32 *)(AR9_GPIO+ 0x0058))
+/***Port 2 Input Schmitt-Trigger Off Register (0088 H) ***/
+#define AR9_GPIO_P2_STOFF						((volatile u32 *)(AR9_GPIO+ 0x0088))
+/***Port 3 Input Schmitt-Trigger Off Register (0094 H) ***/
+//#define AR9_GPIO_P3_STOFF						((volatile u32 *)(AR9_GPIO+ 0x0094))
+/***Port 0 Pull Up/Pull Down Select Register (002C H)***/
+#define AR9_GPIO_P0_PUDSEL						((volatile u32 *)(AR9_GPIO+ 0x002C))
+/***Port 1 Pull Up/Pull Down Select Register (005C H)***/
+#define AR9_GPIO_P1_PUDSEL						((volatile u32 *)(AR9_GPIO+ 0x005C))
+/***Port 2 Pull Up/Pull Down Select Register (008C H)***/
+#define AR9_GPIO_P2_PUDSEL						((volatile u32 *)(AR9_GPIO+ 0x008C))
+/***Port 3 Pull Up/Pull Down Select Register (0038 H)***/
+#define AR9_GPIO_P3_PUDSEL						((volatile u32 *)(AR9_GPIO+ 0x0038))
+/***Port 0 Pull Up Device Enable Register (0030 H)***/
+#define AR9_GPIO_P0_PUDEN						((volatile u32 *)(AR9_GPIO+ 0x0030))
+/***Port 1 Pull Up Device Enable Register (0060 H)***/
+#define AR9_GPIO_P1_PUDEN						((volatile u32 *)(AR9_GPIO+ 0x0060))
+/***Port 2 Pull Up Device Enable Register (0090 H)***/
+#define AR9_GPIO_P2_PUDEN						((volatile u32 *)(AR9_GPIO+ 0x0090))
+/***Port 3 Pull Up Device Enable Register (003c H)***/
+#define AR9_GPIO_P3_PUDEN						((volatile u32 *)(AR9_GPIO+ 0x003C))
+
+/***********************************************************************/
+/*  Module      :  CGU register address and bits                       */
+/***********************************************************************/
+#define AR9_CGU									(0xBF103000)
+/***CGU Clock PLL0 ***/
+#define AR9_CGU_PLL0_CFG						((volatile u32*)(AR9_CGU+ 0x0004))
+/***CGU Clock PLL1 ***/
+#define AR9_CGU_PLL1_CFG						((volatile u32*)(AR9_CGU+ 0x0008))
+/***CGU Clock SYS Mux Register***/
+#define AR9_CGU_SYS								((volatile u32*)(AR9_CGU+ 0x0010))
+/***CGU Interface Clock Control Register***/
+#define AR9_CGU_IFCCR							((volatile u32*)(AR9_CGU+ 0x0018))
+/***CGU PCI Clock Control Register**/
+#define AR9_CGU_PCICR							((volatile u32*)(AR9_CGU+ 0x0034))
+#define CLOCK_60M								60000000
+#define CLOCK_83M								83333333
+#define CLOCK_111M								111111111
+#define CLOCK_133M								133333333
+#define CLOCK_166M								166666667
+#define CLOCK_196M								196666667
+#define CLOCK_333M								333333333
+#define CLOCK_366M								366666667
+#define CLOCK_500M								500000000
+
+/***********************************************************************/
+/*  Module      :  MPS register address and bits                       */
+/***********************************************************************/
+#define AR9_MPS									(KSEG1+0x1F107000)
+#define AR9_MPS_CHIPID							((volatile u32*)(AR9_MPS + 0x0344))
+#define AR9_MPS_CHIPID_VERSION_GET(value)		(((value) >> 28) & ((1 << 4) - 1))
+#define AR9_MPS_CHIPID_PARTNUM_GET(value)		(((value) >> 12) & ((1 << 16) - 1))
+#define AR9_MPS_CHIPID_MANID_GET(value)			(((value) >> 1) & ((1 << 10) - 1))
+
+/***********************************************************************/
+/*  Module      :  EBU register address and bits                       */
+/***********************************************************************/
+#define AR9_EBU									(0xBE105300)
+
+#define AR9_EBU_CLC								((volatile u32*)(AR9_EBU+ 0x0000))
+#define AR9_EBU_CLC_DISS						(1 << 1)
+#define AR9_EBU_CLC_DISR						(1 << 0)
+
+#define AR9_EBU_ID								((volatile u32*)(AR9_EBU+ 0x0008))
+
+/***EBU Global Control Register***/
+#define AR9_EBU_CON								((volatile u32*)(AR9_EBU+ 0x0010))
+#define AR9_EBU_CON_DTACS (value)				(((( 1 << 3) - 1) & (value)) << 20)
+#define AR9_EBU_CON_DTARW (value)				(((( 1 << 3) - 1) & (value)) << 16)
+#define AR9_EBU_CON_TOUTC (value)				(((( 1 << 8) - 1) & (value)) << 8)
+#define AR9_EBU_CON_ARBMODE (value)				(((( 1 << 2) - 1) & (value)) << 6)
+#define AR9_EBU_CON_ARBSYNC						(1 << 5)
+//#define AR9_EBU_CON_1							(1 << 3)
+
+/***EBU Address Select Register 0***/
+#define AR9_EBU_ADDSEL0							((volatile u32*)(AR9_EBU + 0x0020))
+/***EBU Address Select Register 1***/
+#define AR9_EBU_ADDSEL1							((volatile u32*)(AR9_EBU + 0x0024))
+/***EBU Address Select Register 2***/
+#define AR9_EBU_ADDSEL2							((volatile u32*)(AR9_EBU + 0x0028))
+/***EBU Address Select Register 3***/
+#define AR9_EBU_ADDSEL3							((volatile u32*)(AR9_EBU + 0x002C))
+#define AR9_EBU_ADDSEL_BASE (value)				(((( 1 << 20) - 1) & (value)) << 12)
+#define AR9_EBU_ADDSEL_MASK (value)				(((( 1 << 4) - 1) & (value)) << 4)
+#define AR9_EBU_ADDSEL_MIRRORE					(1 << 1)
+#define AR9_EBU_ADDSEL_REGEN					(1 << 0)
+
+/***EBU Bus Configuration Register 0***/
+#define AR9_EBU_BUSCON0							((volatile u32*)(AR9_EBU+ 0x0060))
+#define AR9_EBU_BUSCON0_WRDIS					(1 << 31)
+#define AR9_EBU_BUSCON0_ADSWP (value)			(1 << 30)
+#define AR9_EBU_BUSCON0_PG_EN (value)			(1 << 29)
+#define AR9_EBU_BUSCON0_AGEN (value)			(((( 1 << 3) - 1) & (value)) << 24)
+#define AR9_EBU_BUSCON0_SETUP					(1 << 22)
+#define AR9_EBU_BUSCON0_WAIT (value)			(((( 1 << 2) - 1) & (value)) << 20)
+#define AR9_EBU_BUSCON0_WAITINV					(1 << 19)
+#define AR9_EBU_BUSCON0_VN_EN					(1 << 18)
+#define AR9_EBU_BUSCON0_PORTW (value)			(((( 1 << 2) - 1) & (value)) << 16)
+#define AR9_EBU_BUSCON0_ALEC (value)			(((( 1 << 2) - 1) & (value)) << 14)
+#define AR9_EBU_BUSCON0_BCGEN (value)			(((( 1 << 2) - 1) & (value)) << 12)
+#define AR9_EBU_BUSCON0_WAITWDC (value)			(((( 1 << 4) - 1) & (value)) << 8)
+#define AR9_EBU_BUSCON0_WAITRRC (value)			(((( 1 << 2) - 1) & (value)) << 6)
+#define AR9_EBU_BUSCON0_HOLDC (value)			(((( 1 << 2) - 1) & (value)) << 4)
+#define AR9_EBU_BUSCON0_RECOVC (value)			(((( 1 << 2) - 1) & (value)) << 2)
+#define AR9_EBU_BUSCON0_CMULT (value)			(((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 1***/
+#define AR9_EBU_BUSCON1							((volatile u32*)(AR9_EBU+ 0x0064))
+#define AR9_EBU_BUSCON1_WRDIS					(1 << 31)
+#define AR9_EBU_BUSCON1_ALEC (value)			(((( 1 << 2) - 1) & (value)) << 29)
+#define AR9_EBU_BUSCON1_BCGEN (value)			(((( 1 << 2) - 1) & (value)) << 27)
+#define AR9_EBU_BUSCON1_AGEN (value)			(((( 1 << 2) - 1) & (value)) << 24)
+#define AR9_EBU_BUSCON1_CMULTR (value)			(((( 1 << 2) - 1) & (value)) << 22)
+#define AR9_EBU_BUSCON1_WAIT (value)			(((( 1 << 2) - 1) & (value)) << 20)
+#define AR9_EBU_BUSCON1_WAITINV					(1 << 19)
+#define AR9_EBU_BUSCON1_SETUP					(1 << 18)
+#define AR9_EBU_BUSCON1_PORTW (value)			(((( 1 << 2) - 1) & (value)) << 16)
+#define AR9_EBU_BUSCON1_WAITRDC (value)			(((( 1 << 7) - 1) & (value)) << 9)
+#define AR9_EBU_BUSCON1_WAITWRC (value)			(((( 1 << 3) - 1) & (value)) << 6)
+#define AR9_EBU_BUSCON1_HOLDC (value)			(((( 1 << 2) - 1) & (value)) << 4)
+#define AR9_EBU_BUSCON1_RECOVC (value)			(((( 1 << 2) - 1) & (value)) << 2)
+#define AR9_EBU_BUSCON1_CMULT (value)			(((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 2***/
+#define AR9_EBU_BUSCON2							((volatile u32*)(AR9_EBU+ 0x0068))
+#define AR9_EBU_BUSCON2_WRDIS					(1 << 31)
+#define AR9_EBU_BUSCON2_ALEC (value)			(((( 1 << 2) - 1) & (value)) << 29)
+#define AR9_EBU_BUSCON2_BCGEN (value)			(((( 1 << 2) - 1) & (value)) << 27)
+#define AR9_EBU_BUSCON2_AGEN (value)			(((( 1 << 2) - 1) & (value)) << 24)
+#define AR9_EBU_BUSCON2_CMULTR (value)			(((( 1 << 2) - 1) & (value)) << 22)
+#define AR9_EBU_BUSCON2_WAIT (value)			(((( 1 << 2) - 1) & (value)) << 20)
+#define AR9_EBU_BUSCON2_WAITINV					(1 << 19)
+#define AR9_EBU_BUSCON2_SETUP					(1 << 18)
+#define AR9_EBU_BUSCON2_PORTW (value)			(((( 1 << 2) - 1) & (value)) << 16)
+#define AR9_EBU_BUSCON2_WAITRDC (value)			(((( 1 << 7) - 1) & (value)) << 9)
+#define AR9_EBU_BUSCON2_WAITWRC (value)			(((( 1 << 3) - 1) & (value)) << 6)
+#define AR9_EBU_BUSCON2_HOLDC (value)			(((( 1 << 2) - 1) & (value)) << 4)
+#define AR9_EBU_BUSCON2_RECOVC (value)			(((( 1 << 2) - 1) & (value)) << 2)
+#define AR9_EBU_BUSCON2_CMULT (value)			(((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 2***/
+#define AR9_EBU_BUSCON3							((volatile u32*)(AR9_EBU+ 0x006C))
+#define AR9_EBU_BUSCON3_WRDIS					(1 << 31)
+#define AR9_EBU_BUSCON3_ADSWP (value)			(1 << 30)
+#define AR9_EBU_BUSCON3_PG_EN (value)			(1 << 29)
+#define AR9_EBU_BUSCON3_AGEN (value)			(((( 1 << 3) - 1) & (value)) << 24)
+#define AR9_EBU_BUSCON3_SETUP					(1 << 22)
+#define AR9_EBU_BUSCON3_WAIT (value) 			(((( 1 << 2) - 1) & (value)) << 20)
+#define AR9_EBU_BUSCON3_WAITINV					(1 << 19)
+#define AR9_EBU_BUSCON3_VN_EN					(1 << 18)
+#define AR9_EBU_BUSCON3_PORTW (value)			(((( 1 << 2) - 1) & (value)) << 16)
+#define AR9_EBU_BUSCON3_ALEC (value)			(((( 1 << 2) - 1) & (value)) << 14)
+#define AR9_EBU_BUSCON3_BCGEN (value)			(((( 1 << 2) - 1) & (value)) << 12)
+#define AR9_EBU_BUSCON3_WAITWDC (value)			(((( 1 << 4) - 1) & (value)) << 8)
+#define AR9_EBU_BUSCON3_WAITRRC (value)			(((( 1 << 2) - 1) & (value)) << 6)
+#define AR9_EBU_BUSCON3_HOLDC (value)			(((( 1 << 2) - 1) & (value)) << 4)
+#define AR9_EBU_BUSCON3_RECOVC (value)			(((( 1 << 2) - 1) & (value)) << 2)
+#define AR9_EBU_BUSCON3_CMULT (value)			(((( 1 << 2) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  SDRAM register address and bits                     */
+/***********************************************************************/
+#define AR9_SDRAM								(0xBF800000)
+
+/***********************************************************************/
+/*  Module      :  ASC0 register address and bits                      */
+/***********************************************************************/
+#define AR9_ASC0								(KSEG1 | 0x1E100400)
+#define AR9_ASC0_TBUF							((volatile u32*)(AR9_ASC0 + 0x0020))
+#define AR9_ASC0_RBUF							((volatile u32*)(AR9_ASC0 + 0x0024))
+#define AR9_ASC0_FSTAT							((volatile u32*)(AR9_ASC0 + 0x0048))
+
+/***********************************************************************/
+/*  Module      :  ASC1 register address and bits                      */
+/***********************************************************************/
+#define AR9_ASC1								(KSEG1 | 0x1E100C00)
+#define AR9_ASC1_TBUF							((volatile u32*)(AR9_ASC1 + 0x0020))
+#define AR9_ASC1_RBUF							((volatile u32*)(AR9_ASC1 + 0x0024))
+#define AR9_ASC1_FSTAT							((volatile u32*)(AR9_ASC1 + 0x0048))
+
+/***********************************************************************/
+/*  Module      :  DMA register address and bits                       */
+/***********************************************************************/
+#define AR9_DMA_OFFSET 							(0xBE104100)
+/***********************************************************************/
+#define AR9_DMA_CLC								((volatile u32*)(AR9_DMA_OFFSET + 0x0000))
+#define AR9_DMA_ID								((volatile u32*)(AR9_DMA_OFFSET + 0x0008))
+#define AR9_DMA_CTRL							(volatile u32*)(AR9_DMA_BASE + 0x10)
+
+/** DMA Port Select Register */
+#define AR9_DMA_PS								((volatile u32*)(AR9_DMA_OFFSET + 0x0040))
+/** DMA Port Control Register */
+#define AR9_DMA_PCTRL							((volatile u32*)(AR9_DMA_OFFSET + 0x0044))
+#define AR9_DMA_IRNEN							((volatile u32*)(AR9_DMA_OFFSET + 0x00F4))
+#define AR9_DMA_IRNCR							((volatile u32*)(AR9_DMA_OFFSET + 0x00F8))
+#define AR9_DMA_IRNICR							((volatile u32*)(AR9_DMA_OFFSET + 0x00FC))
+
+#define AR9_DMA_CS								((volatile u32*)(AR9_DMA_OFFSET + 0x0018))
+#define AR9_DMA_CCTRL							((volatile u32*)(AR9_DMA_OFFSET + 0x001C))
+#define AR9_DMA_CDBA							((volatile u32*)(AR9_DMA_OFFSET + 0x0020))
+#define AR9_DMA_CIE								((volatile u32*)(AR9_DMA_OFFSET + 0x002C))
+#define AR9_DMA_CIS								((volatile u32*)(AR9_DMA_OFFSET + 0x0028))
+#define AR9_DMA_CDLEN							((volatile u32*)(AR9_DMA_OFFSET + 0x0024))
+#define AR9_DMA_CPOLL							((volatile u32*)(AR9_DMA_OFFSET + 0x0014))
+
+/***********************************************************************/
+/*  Module      :  GPORT switch register                               */
+/***********************************************************************/
+#define AR9_SW									(0xBE108000)
+#define AR9_SW_PS								(AR9_SW + 0x000)
+#define AR9_SW_P0_CTL							(AR9_SW + 0x004)
+#define AR9_SW_P1_CTL							(AR9_SW + 0x008)
+#define AR9_SW_P2_CTL							(AR9_SW + 0x00C)
+#define AR9_SW_P0_VLAN							(AR9_SW + 0x010)
+#define AR9_SW_P1_VLAN							(AR9_SW + 0x014)
+#define AR9_SW_P2_VLAN							(AR9_SW + 0x018)
+#define AR9_SW_P0_INCTL							(AR9_SW + 0x020)
+#define AR9_SW_P1_INCTL							(AR9_SW + 0x024)
+#define AR9_SW_P2_INCTL							(AR9_SW + 0x028)
+#define AR9_SW_DF_PORTMAP						(AR9_SW + 0x02C)
+#define AR9_SW_P0_ECS_Q32						(AR9_SW + 0x030)
+#define AR9_SW_P0_ECS_Q10						(AR9_SW + 0x034)
+#define AR9_SW_P0_ECW_Q32						(AR9_SW + 0x038)
+#define AR9_SW_P0_ECW_Q10						(AR9_SW + 0x03C)
+#define AR9_SW_P1_ECS_Q32						(AR9_SW + 0x040)
+#define AR9_SW_P1_ECS_Q10						(AR9_SW + 0x044)
+#define AR9_SW_P1_ECW_Q32						(AR9_SW + 0x048)
+#define AR9_SW_P1_ECW_Q10						(AR9_SW + 0x04C)
+#define AR9_SW_P2_ECS_Q32						(AR9_SW + 0x050)
+#define AR9_SW_P2_ECS_Q10						(AR9_SW + 0x054)
+#define AR9_SW_P2_ECW_Q32						(AR9_SW + 0x058)
+#define AR9_SW_P2_ECW_Q10						(AR9_SW + 0x05C)
+#define AR9_SW_INT_ENA							(AR9_SW + 0x060)
+#define AR9_SW_INT_ST							(AR9_SW + 0x064)
+#define AR9_SW_GCTL0							(AR9_SW + 0x068)
+#define AR9_SW_GCTL1							(AR9_SW + 0x06C)
+#define AR9_SW_ARP								(AR9_SW + 0x070)
+#define AR9_SW_STRM_CTL							(AR9_SW + 0x074)
+#define AR9_SW_RGMII_CTL						(AR9_SW + 0x078)
+#define AR9_SW_1P_PRT							(AR9_SW + 0x07C)
+#define AR9_SW_GBKT_SZBS						(AR9_SW + 0x080)
+#define AR9_SW_GBKT_SZEBS						(AR9_SW + 0x084)
+#define AR9_SW_BF_TH							(AR9_SW + 0x088)
+#define AR9_SW_PMAC_HD_CTL						(AR9_SW + 0x08C)
+#define AR9_SW_PMAC_SA1							(AR9_SW + 0x090)
+#define AR9_SW_PMAC_SA2							(AR9_SW + 0x094)
+#define AR9_SW_PMAC_DA1							(AR9_SW + 0x098)
+#define AR9_SW_PMAC_DA2							(AR9_SW + 0x09C)
+#define AR9_SW_PMAC_VLAN						(AR9_SW + 0x0A0)
+#define AR9_SW_PMAC_TX_IPG						(AR9_SW + 0x0A4)
+#define AR9_SW_PMAC_RX_IPG						(AR9_SW + 0x0A8)
+#define AR9_SW_ADR_TB_CTL0						(AR9_SW + 0x0AC)
+#define AR9_SW_ADR_TB_CTL1						(AR9_SW + 0x0B0)
+#define AR9_SW_ADR_TB_CTL2						(AR9_SW + 0x0B4)
+#define AR9_SW_ADR_TB_ST0						(AR9_SW + 0x0B8)
+#define AR9_SW_ADR_TB_ST1						(AR9_SW + 0x0BC)
+#define AR9_SW_ADR_TB_ST2						(AR9_SW + 0x0C0)
+#define AR9_SW_RMON_CTL							(AR9_SW + 0x0C4)
+#define AR9_SW_RMON_ST							(AR9_SW + 0x0C8)
+#define AR9_SW_MDIO_CTL							(AR9_SW + 0x0CC)
+#define AR9_SW_MDIO_DATA						(AR9_SW + 0x0D0)
+#define AR9_SW_TP_FLT_ACT						(AR9_SW + 0x0D4)
+#define AR9_SW_PRTCL_FLT_ACT					(AR9_SW + 0x0D8)
+#define AR9_SW_VLAN_FLT0						(AR9_SW + 0x100)
+#define AR9_SW_VLAN_FLT1						(AR9_SW + 0x104)
+#define AR9_SW_VLAN_FLT2						(AR9_SW + 0x108)
+#define AR9_SW_VLAN_FLT3						(AR9_SW + 0x10C)
+#define AR9_SW_VLAN_FLT4						(AR9_SW + 0x110)
+#define AR9_SW_VLAN_FLT5						(AR9_SW + 0x114)
+#define AR9_SW_VLAN_FLT6						(AR9_SW + 0x118)
+#define AR9_SW_VLAN_FLT7						(AR9_SW + 0x11C)
+#define AR9_SW_VLAN_FLT8						(AR9_SW + 0x120)
+#define AR9_SW_VLAN_FLT9						(AR9_SW + 0x124)
+#define AR9_SW_VLAN_FLT10						(AR9_SW + 0x128)
+#define AR9_SW_VLAN_FLT11						(AR9_SW + 0x12C)
+#define AR9_SW_VLAN_FLT12						(AR9_SW + 0x130)
+#define AR9_SW_VLAN_FLT13						(AR9_SW + 0x134)
+#define AR9_SW_VLAN_FLT14						(AR9_SW + 0x138)
+#define AR9_SW_VLAN_FLT15						(AR9_SW + 0x13C)
+#define AR9_SW_TP_FLT10							(AR9_SW + 0x140)
+#define AR9_SW_TP_FLT32							(AR9_SW + 0x144)
+#define AR9_SW_TP_FLT54							(AR9_SW + 0x148)
+#define AR9_SW_TP_FLT76							(AR9_SW + 0x14C)
+#define AR9_SW_DFSRV_MAP0						(AR9_SW + 0x150)
+#define AR9_SW_DFSRV_MAP1						(AR9_SW + 0x154)
+#define AR9_SW_DFSRV_MAP2						(AR9_SW + 0x158)
+#define AR9_SW_DFSRV_MAP3						(AR9_SW + 0x15C)
+#define AR9_SW_TCP_PF0							(AR9_SW + 0x160)
+#define AR9_SW_TCP_PF1							(AR9_SW + 0x164)
+#define AR9_SW_TCP_PF2							(AR9_SW + 0x168)
+#define AR9_SW_TCP_PF3							(AR9_SW + 0x16C)
+#define AR9_SW_TCP_PF4							(AR9_SW + 0x170)
+#define AR9_SW_TCP_PF5							(AR9_SW + 0x174)
+#define AR9_SW_TCP_PF6							(AR9_SW + 0x178)
+#define AR9_SW_TCP_PF7							(AR9_SW + 0x17C)
+#define AR9_SW_RA_03_00							(AR9_SW + 0x180)
+#define AR9_SW_RA_07_04							(AR9_SW + 0x184)
+#define AR9_SW_RA_0B_08							(AR9_SW + 0x188)
+#define AR9_SW_RA_0F_0C							(AR9_SW + 0x18C)
+#define AR9_SW_RA_13_10							(AR9_SW + 0x190)
+#define AR9_SW_RA_17_14							(AR9_SW + 0x194)
+#define AR9_SW_RA_1B_18							(AR9_SW + 0x198)
+#define AR9_SW_RA_1F_1C							(AR9_SW + 0x19C)
+#define AR9_SW_RA_23_20							(AR9_SW + 0x1A0)
+#define AR9_SW_RA_27_24							(AR9_SW + 0x1A4)
+#define AR9_SW_RA_2B_28							(AR9_SW + 0x1A8)
+#define AR9_SW_RA_2F_2C							(AR9_SW + 0x1AC)
+#define AR9_SW_F0								(AR9_SW + 0x1B0)
+#define AR9_SW_F1								(AR9_SW + 0x1B4)
+
+#define REG32(addr)								*((volatile u32 *)(addr))
diff --git a/arch/mips/include/asm/danube.h b/arch/mips/include/asm/danube.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/danube.h
@@ -0,0 +1,2015 @@
+#ifndef DANUBE_H
+#define DANUBE_H
+/******************************************************************************
+       Copyright (c) 2002, Infineon Technologies.  All rights reserved.
+
+                               No Warranty
+   Because the program is licensed free of charge, there is no warranty for
+   the program, to the extent permitted by applicable law.  Except when
+   otherwise stated in writing the copyright holders and/or other parties
+   provide the program "as is" without warranty of any kind, either
+   expressed or implied, including, but not limited to, the implied
+   warranties of merchantability and fitness for a particular purpose. The
+   entire risk as to the quality and performance of the program is with
+   you.  should the program prove defective, you assume the cost of all
+   necessary servicing, repair or correction.
+
+   In no event unless required by applicable law or agreed to in writing
+   will any copyright holder, or any other party who may modify and/or
+   redistribute the program as permitted above, be liable to you for
+   damages, including any general, special, incidental or consequential
+   damages arising out of the use or inability to use the program
+   (including but not limited to loss of data or data being rendered
+   inaccurate or losses sustained by you or third parties or a failure of
+   the program to operate with any other programs), even if such holder or
+   other party has been advised of the possibility of such damages.
+******************************************************************************/
+
+/***********************************************************************/
+/*  Module      :  MEI register address and bits                       */
+/***********************************************************************/
+#define MEI_SPACE_ACCESS	0xB0100C00
+#define MEI_DATA_XFR				(0x0000 + MEI_SPACE_ACCESS)
+#define	MEI_VERSION				(0x0200 + MEI_SPACE_ACCESS)
+#define	ARC_GP_STAT				(0x0204 + MEI_SPACE_ACCESS)
+#define	MEI_XFR_ADDR				(0x020C + MEI_SPACE_ACCESS)
+#define	MEI_TO_ARC_INT				(0x021C + MEI_SPACE_ACCESS)
+#define	ARC_TO_MEI_INT				(0x0220 + MEI_SPACE_ACCESS)
+#define	ARC_TO_MEI_INT_MASK			(0x0224 + MEI_SPACE_ACCESS)
+#define	MEI_DEBUG_WAD				(0x0228 + MEI_SPACE_ACCESS)
+#define MEI_DEBUG_RAD				(0x022C + MEI_SPACE_ACCESS)
+#define	MEI_DEBUG_DATA				(0x0230 + MEI_SPACE_ACCESS)
+#define	MEI_DEBUG_DEC				(0x0234 + MEI_SPACE_ACCESS)
+#define	MEI_CONTROL				(0x0238 + MEI_SPACE_ACCESS)
+#define	AT_CELLRDY_BC0				(0x023C + MEI_SPACE_ACCESS)
+#define	AT_CELLRDY_BC1				(0x0240 + MEI_SPACE_ACCESS)
+#define	AR_CELLRDY_BC0				(0x0244 + MEI_SPACE_ACCESS)
+#define	AR_CELLRDY_BC1				(0x0248 + MEI_SPACE_ACCESS)
+#define	AAI_ACCESS				(0x024C + MEI_SPACE_ACCESS)
+#define	AAITXCB0				(0x0300 + MEI_SPACE_ACCESS)
+#define	AAITXCB1				(0x0304 + MEI_SPACE_ACCESS)
+#define	AAIRXCB0				(0x0308 + MEI_SPACE_ACCESS)
+#define	AAIRXCB1				(0x030C + MEI_SPACE_ACCESS)
+
+
+/***********************************************************************/
+/*  Module      :  WDT register address and bits                       */
+/***********************************************************************/
+#define DANUBE_BIU_WDT_BASE             (0xBf8803F0)
+#define DANUBE_BIU_WDT_CR     		(0x0000 + DANUBE_BIU_WDT_BASE)
+#define DANUBE_BIU_WDT_SR     		(0x0008 + DANUBE_BIU_WDT_BASE)
+
+
+/***********************************************************************/
+/*  Module      :  PMU register address and bits                       */
+/***********************************************************************/
+#define DANUBE_PMU_BASE_ADDR 				(KSEG1+0x1F102000)
+
+/***PM Control Register***/
+#define DANUBE_PMU_CR 					((volatile u32*)(0x001C + DANUBE_PMU_BASE_ADDR))
+#define DANUBE_PMU_PWDCR				DANUBE_PMU_CR
+#define DANUBE_PMU_SR 					((volatile u32*)(0x0020 + DANUBE_PMU_BASE_ADDR))
+
+#define DANUBE_PMU_DMA_SHIFT                    5
+#define DANUBE_PMU_PPE_SHIFT                    13
+#define DANUBE_PMU_ETOP_SHIFT                   22
+#define DANUBE_PMU_ENET0_SHIFT                  24
+#define DANUBE_PMU_ENET1_SHIFT                  25
+
+
+#define DANUBE_PMU 					DANUBE_PMU_BASE_ADDR
+/***PM Global Enable Register***/
+#define DANUBE_PMU_PM_GEN                       ((volatile u32*)(DANUBE_PMU+ 0x0000))
+#define DANUBE_PMU_PM_GEN_EN16                            (1 << 16)
+#define DANUBE_PMU_PM_GEN_EN15                            (1 << 15)
+#define DANUBE_PMU_PM_GEN_EN14                            (1 << 14)
+#define DANUBE_PMU_PM_GEN_EN13                            (1 << 13)
+#define DANUBE_PMU_PM_GEN_EN12                            (1 << 12)
+#define DANUBE_PMU_PM_GEN_EN11                            (1 << 11)
+#define DANUBE_PMU_PM_GEN_EN10                            (1 << 10)
+#define DANUBE_PMU_PM_GEN_EN9                              (1 << 9)
+#define DANUBE_PMU_PM_GEN_EN8                              (1 << 8)
+#define DANUBE_PMU_PM_GEN_EN7                              (1 << 7)
+#define DANUBE_PMU_PM_GEN_EN6                              (1 << 6)
+#define DANUBE_PMU_PM_GEN_EN5                              (1 << 5)
+#define DANUBE_PMU_PM_GEN_EN4                              (1 << 4)
+#define DANUBE_PMU_PM_GEN_EN3                              (1 << 3)
+#define DANUBE_PMU_PM_GEN_EN2                              (1 << 2)
+#define DANUBE_PMU_PM_GEN_EN0                              (1 << 0)
+
+/***PM Power Down Enable Register***/
+#define DANUBE_PMU_PM_PDEN                      ((volatile u32*)(DANUBE_PMU+ 0x0008))
+#define DANUBE_PMU_PM_PDEN_EN16                            (1 << 16)
+#define DANUBE_PMU_PM_PDEN_EN15                            (1 << 15)
+#define DANUBE_PMU_PM_PDEN_EN14                            (1 << 14)
+#define DANUBE_PMU_PM_PDEN_EN13                            (1 << 13)
+#define DANUBE_PMU_PM_PDEN_EN12                            (1 << 12)
+#define DANUBE_PMU_PM_PDEN_EN11                            (1 << 11)
+#define DANUBE_PMU_PM_PDEN_EN10                            (1 << 10)
+#define DANUBE_PMU_PM_PDEN_EN9                              (1 << 9)
+#define DANUBE_PMU_PM_PDEN_EN8                              (1 << 8)
+#define DANUBE_PMU_PM_PDEN_EN7                              (1 << 7)
+#define DANUBE_PMU_PM_PDEN_EN5                              (1 << 5)
+#define DANUBE_PMU_PM_PDEN_EN4                              (1 << 4)
+#define DANUBE_PMU_PM_PDEN_EN3                              (1 << 3)
+#define DANUBE_PMU_PM_PDEN_EN2                              (1 << 2)
+#define DANUBE_PMU_PM_PDEN_EN0                              (1 << 0)
+
+/***PM Wake-Up from Power Down Register***/
+#define DANUBE_PMU_PM_WUP                       ((volatile u32*)(DANUBE_PMU+ 0x0010))
+#define DANUBE_PMU_PM_WUP_WUP16                          (1 << 16)
+#define DANUBE_PMU_PM_WUP_WUP15                          (1 << 15)
+#define DANUBE_PMU_PM_WUP_WUP14                          (1 << 14)
+#define DANUBE_PMU_PM_WUP_WUP13                          (1 << 13)
+#define DANUBE_PMU_PM_WUP_WUP12                          (1 << 12)
+#define DANUBE_PMU_PM_WUP_WUP11                          (1 << 11)
+#define DANUBE_PMU_PM_WUP_WUP10                          (1 << 10)
+#define DANUBE_PMU_PM_WUP_WUP9                            (1 << 9)
+#define DANUBE_PMU_PM_WUP_WUP8                            (1 << 8)
+#define DANUBE_PMU_PM_PDEN_EN7                              (1 << 7)
+#define DANUBE_PMU_PM_PDEN_EN5                              (1 << 5)
+#define DANUBE_PMU_PM_PDEN_EN4                              (1 << 4)
+#define DANUBE_PMU_PM_PDEN_EN3                              (1 << 3)
+#define DANUBE_PMU_PM_PDEN_EN2                              (1 << 2)
+#define DANUBE_PMU_PM_PDEN_EN0                              (1 << 0)
+
+/***PM Wake-Up from Power Down Register***/
+#define DANUBE_PMU_PM_WUP                       ((volatile u32*)(DANUBE_PMU+ 0x0010))
+#define DANUBE_PMU_PM_WUP_WUP16                          (1 << 16)
+#define DANUBE_PMU_PM_WUP_WUP15                          (1 << 15)
+#define DANUBE_PMU_PM_WUP_WUP14                          (1 << 14)
+#define DANUBE_PMU_PM_WUP_WUP13                          (1 << 13)
+#define DANUBE_PMU_PM_WUP_WUP12                          (1 << 12)
+#define DANUBE_PMU_PM_WUP_WUP11                          (1 << 11)
+#define DANUBE_PMU_PM_WUP_WUP10                          (1 << 10)
+#define DANUBE_PMU_PM_WUP_WUP9                            (1 << 9)
+#define DANUBE_PMU_PM_WUP_WUP8                            (1 << 8)
+#define DANUBE_PMU_PM_WUP_WUP7                            (1 << 7)
+#define DANUBE_PMU_PM_WUP_WUP5                            (1 << 5)
+#define DANUBE_PMU_PM_WUP_WUP4                            (1 << 4)
+#define DANUBE_PMU_PM_WUP_WUP3                            (1 << 3)
+#define DANUBE_PMU_PM_WUP_WUP2                            (1 << 2)
+#define DANUBE_PMU_PM_WUP_WUP0                            (1 << 0)
+
+/***PM Control Register***/
+#define DANUBE_PMU_PM_CR                        ((volatile u32*)(DANUBE_PMU+ 0x0014))
+#define DANUBE_PMU_PM_CR_AWEN                            (1 << 31)
+#define DANUBE_PMU_PM_CR_SWRST                          (1 << 30)
+#define DANUBE_PMU_PM_CR_SWCR                            (1 << 2)
+#define DANUBE_PMU_PM_CR_CRD (value)                (((( 1 << 2) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  RCU register address and bits                       */
+/***********************************************************************/
+#define DANUBE_RCU_BASE_ADDR 		(0xBF203000)
+
+#define DANUBE_RCU_REQ 			(0x0010 + DANUBE_RCU_BASE_ADDR)
+#define DANUBE_RCU_RST_REQ                      ((volatile u32*)(DANUBE_RCU_REQ))
+#define DANUBE_RCU_STAT		        (0x0014 + DANUBE_RCU_BASE_ADDR)
+#define DANUBE_RCU_RST_SR	        ( (volatile u32 *)(DANUBE_RCU_STAT))
+#define DANUBE_RCU_PCI_RDY	        ( (volatile u32 *)(DANUBE_RCU_BASE_ADDR+0x28))
+#define DANUBE_RCU_MON                  (0x0030 + DANUBE_RCU_BASE_ADDR)
+
+
+/***********************************************************************/
+/*  Module      :  BCU  register address and bits                       */
+/***********************************************************************/
+#define DANUBE_BCU_BASE_ADDR 	(0xB0100000)
+/***BCU Control Register (0010H)***/
+#define DANUBE_BCU_CON 		(0x0010 + DANUBE_BCU_BASE_ADDR)
+#define DANUBE_BCU_BCU_CON_SPC (value)                (((( 1 << 8) - 1) & (value)) << 24)
+#define DANUBE_BCU_BCU_CON_SPE                              (1 << 19)
+#define DANUBE_BCU_BCU_CON_PSE                              (1 << 18)
+#define DANUBE_BCU_BCU_CON_DBG                              (1 << 16)
+#define DANUBE_BCU_BCU_CON_TOUT (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+
+/***BCU Error Control Capture Register (0020H)***/
+#define DANUBE_BCU_ECON 	(0x0020 + DANUBE_BCU_BASE_ADDR)
+#define DANUBE_BCU_BCU_ECON_TAG (value)                (((( 1 << 4) - 1) & (value)) << 24)
+#define DANUBE_BCU_BCU_ECON_RDN                              (1 << 23)
+#define DANUBE_BCU_BCU_ECON_WRN                              (1 << 22)
+#define DANUBE_BCU_BCU_ECON_SVM                              (1 << 21)
+#define DANUBE_BCU_BCU_ECON_ACK (value)                (((( 1 << 2) - 1) & (value)) << 19)
+#define DANUBE_BCU_BCU_ECON_ABT                              (1 << 18)
+#define DANUBE_BCU_BCU_ECON_RDY                              (1 << 17)
+#define DANUBE_BCU_BCU_ECON_TOUT                            (1 << 16)
+#define DANUBE_BCU_BCU_ECON_ERRCNT (value)             (((( 1 << 16) - 1) & (value)) << 0)
+#define DANUBE_BCU_BCU_ECON_OPC (value)                (((( 1 << 4) - 1) & (value)) << 28)
+
+/***BCU Error Address Capture Register (0024 H)***/
+#define DANUBE_BCU_EADD 	(0x0024 + DANUBE_BCU_BASE_ADDR)
+
+/***BCU Error Data Capture Register (0028H)***/
+#define DANUBE_BCU_EDAT 	(0x0028 + DANUBE_BCU_BASE_ADDR)
+
+#define DANUBE_BCU_IRNEN 	(0x00F4 + DANUBE_BCU_BASE_ADDR)
+#define DANUBE_BCU_IRNICR 	(0x00F8 + DANUBE_BCU_BASE_ADDR)
+#define DANUBE_BCU_IRNCR 	(0x00FC + DANUBE_BCU_BASE_ADDR)
+
+
+/***********************************************************************/
+/*  Module      :  MBC register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_MBC                          (0xBF103000)
+/***********************************************************************/
+
+
+/***Mailbox CPU Configuration Register***/
+#define DANUBE_MBC_MBC_CFG                      ((volatile u32*)(DANUBE_MBC+ 0x0080))
+#define DANUBE_MBC_MBC_CFG_SWAP (value)               (((( 1 << 2) - 1) & (value)) << 6)
+#define DANUBE_MBC_MBC_CFG_RES                              (1 << 5)
+#define DANUBE_MBC_MBC_CFG_FWID (value)               (((( 1 << 4) - 1) & (value)) << 1)
+#define DANUBE_MBC_MBC_CFG_SIZE                            (1 << 0)
+
+/***Mailbox CPU Interrupt Status Register***/
+#define DANUBE_MBC_MBC_ISR                      ((volatile u32*)(DANUBE_MBC+ 0x0084))
+#define DANUBE_MBC_MBC_ISR_B3DA                            (1 << 31)
+#define DANUBE_MBC_MBC_ISR_B2DA                            (1 << 30)
+#define DANUBE_MBC_MBC_ISR_B1E                              (1 << 29)
+#define DANUBE_MBC_MBC_ISR_B0E                              (1 << 28)
+#define DANUBE_MBC_MBC_ISR_WDT                              (1 << 27)
+#define DANUBE_MBC_MBC_ISR_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Mask Register***/
+#define DANUBE_MBC_MBC_MSK                      ((volatile u32*)(DANUBE_MBC+ 0x0088))
+#define DANUBE_MBC_MBC_MSK_B3DA                            (1 << 31)
+#define DANUBE_MBC_MBC_MSK_B2DA                            (1 << 30)
+#define DANUBE_MBC_MBC_MSK_B1E                              (1 << 29)
+#define DANUBE_MBC_MBC_MSK_B0E                              (1 << 28)
+#define DANUBE_MBC_MBC_MSK_WDT                              (1 << 27)
+#define DANUBE_MBC_MBC_MSK_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Mask 01 Register***/
+#define DANUBE_MBC_MBC_MSK01                    ((volatile u32*)(DANUBE_MBC+ 0x008C))
+#define DANUBE_MBC_MBC_MSK01_B3DA                            (1 << 31)
+#define DANUBE_MBC_MBC_MSK01_B2DA                            (1 << 30)
+#define DANUBE_MBC_MBC_MSK01_B1E                              (1 << 29)
+#define DANUBE_MBC_MBC_MSK01_B0E                              (1 << 28)
+#define DANUBE_MBC_MBC_MSK01_WDT                              (1 << 27)
+#define DANUBE_MBC_MBC_MSK01_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Mask 10 Register***/
+#define DANUBE_MBC_MBC_MSK10                    ((volatile u32*)(DANUBE_MBC+ 0x0090))
+#define DANUBE_MBC_MBC_MSK10_B3DA                            (1 << 31)
+#define DANUBE_MBC_MBC_MSK10_B2DA                            (1 << 30)
+#define DANUBE_MBC_MBC_MSK10_B1E                              (1 << 29)
+#define DANUBE_MBC_MBC_MSK10_B0E                              (1 << 28)
+#define DANUBE_MBC_MBC_MSK10_WDT                              (1 << 27)
+#define DANUBE_MBC_MBC_MSK10_DS260 (value)             (((( 1 << 27) - 1) & (value)) << 0)
+
+/***Mailbox CPU Short Command Register***/
+#define DANUBE_MBC_MBC_CMD                      ((volatile u32*)(DANUBE_MBC+ 0x0094))
+#define DANUBE_MBC_MBC_CMD_CS270 (value)             (((( 1 << 28) - 1) & (value)) << 0)
+
+/***Mailbox CPU Input Data of Buffer 0***/
+#define DANUBE_MBC_MBC_ID0                      ((volatile u32*)(DANUBE_MBC+ 0x0000))
+#define DANUBE_MBC_MBC_ID0_INDATA
+
+/***Mailbox CPU Input Data of Buffer 1***/
+#define DANUBE_MBC_MBC_ID1                      ((volatile u32*)(DANUBE_MBC+ 0x0020))
+#define DANUBE_MBC_MBC_ID1_INDATA
+
+/***Mailbox CPU Output Data of Buffer 2***/
+#define DANUBE_MBC_MBC_OD2                      ((volatile u32*)(DANUBE_MBC+ 0x0040))
+#define DANUBE_MBC_MBC_OD2_OUTDATA
+
+/***Mailbox CPU Output Data of Buffer 3***/
+#define DANUBE_MBC_MBC_OD3                      ((volatile u32*)(DANUBE_MBC+ 0x0060))
+#define DANUBE_MBC_MBC_OD3_OUTDATA
+
+/***Mailbox CPU Control Register of Buffer 0***/
+#define DANUBE_MBC_MBC_CR0                      ((volatile u32*)(DANUBE_MBC+ 0x0004))
+#define DANUBE_MBC_MBC_CR0_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Control Register of Buffer 1***/
+#define DANUBE_MBC_MBC_CR1                      ((volatile u32*)(DANUBE_MBC+ 0x0024))
+#define DANUBE_MBC_MBC_CR1_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Control Register of Buffer 2***/
+#define DANUBE_MBC_MBC_CR2                      ((volatile u32*)(DANUBE_MBC+ 0x0044))
+#define DANUBE_MBC_MBC_CR2_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Control Register of Buffer 3***/
+#define DANUBE_MBC_MBC_CR3                      ((volatile u32*)(DANUBE_MBC+ 0x0064))
+#define DANUBE_MBC_MBC_CR3_RDYABTFLS (value)          (((( 1 << 3) - 1) & (value)) << 0)
+
+/***Mailbox CPU Free Space of Buffer 0***/
+#define DANUBE_MBC_MBC_FS0                      ((volatile u32*)(DANUBE_MBC+ 0x0008))
+#define DANUBE_MBC_MBC_FS0_FS
+
+/***Mailbox CPU Free Space of Buffer 1***/
+#define DANUBE_MBC_MBC_FS1                      ((volatile u32*)(DANUBE_MBC+ 0x0028))
+#define DANUBE_MBC_MBC_FS1_FS
+
+/***Mailbox CPU Free Space of Buffer 2***/
+#define DANUBE_MBC_MBC_FS2                      ((volatile u32*)(DANUBE_MBC+ 0x0048))
+#define DANUBE_MBC_MBC_FS2_FS
+
+/***Mailbox CPU Free Space of Buffer 3***/
+#define DANUBE_MBC_MBC_FS3                      ((volatile u32*)(DANUBE_MBC+ 0x0068))
+#define DANUBE_MBC_MBC_FS3_FS
+
+/***Mailbox CPU Data Available in Buffer 0***/
+#define DANUBE_MBC_MBC_DA0                      ((volatile u32*)(DANUBE_MBC+ 0x000C))
+#define DANUBE_MBC_MBC_DA0_DA
+
+/***Mailbox CPU Data Available in Buffer 1***/
+#define DANUBE_MBC_MBC_DA1                      ((volatile u32*)(DANUBE_MBC+ 0x002C))
+#define DANUBE_MBC_MBC_DA1_DA
+
+/***Mailbox CPU Data Available in Buffer 2***/
+#define DANUBE_MBC_MBC_DA2                      ((volatile u32*)(DANUBE_MBC+ 0x004C))
+#define DANUBE_MBC_MBC_DA2_DA
+
+/***Mailbox CPU Data Available in Buffer 3***/
+#define DANUBE_MBC_MBC_DA3                      ((volatile u32*)(DANUBE_MBC+ 0x006C))
+#define DANUBE_MBC_MBC_DA3_DA
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 0***/
+#define DANUBE_MBC_MBC_IABS0                    ((volatile u32*)(DANUBE_MBC+ 0x0010))
+#define DANUBE_MBC_MBC_IABS0_IABS
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 1***/
+#define DANUBE_MBC_MBC_IABS1                    ((volatile u32*)(DANUBE_MBC+ 0x0030))
+#define DANUBE_MBC_MBC_IABS1_IABS
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 2***/
+#define DANUBE_MBC_MBC_IABS2                    ((volatile u32*)(DANUBE_MBC+ 0x0050))
+#define DANUBE_MBC_MBC_IABS2_IABS
+
+/***Mailbox CPU Input Absolute Pointer of Buffer 3***/
+#define DANUBE_MBC_MBC_IABS3                    ((volatile u32*)(DANUBE_MBC+ 0x0070))
+#define DANUBE_MBC_MBC_IABS3_IABS
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 0***/
+#define DANUBE_MBC_MBC_ITMP0                    ((volatile u32*)(DANUBE_MBC+ 0x0014))
+#define DANUBE_MBC_MBC_ITMP0_ITMP
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 1***/
+#define DANUBE_MBC_MBC_ITMP1                    ((volatile u32*)(DANUBE_MBC+ 0x0034))
+#define DANUBE_MBC_MBC_ITMP1_ITMP
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 2***/
+#define DANUBE_MBC_MBC_ITMP2                    ((volatile u32*)(DANUBE_MBC+ 0x0054))
+#define DANUBE_MBC_MBC_ITMP2_ITMP
+
+/***Mailbox CPU Input Temporary Pointer of Buffer 3***/
+#define DANUBE_MBC_MBC_ITMP3                    ((volatile u32*)(DANUBE_MBC+ 0x0074))
+#define DANUBE_MBC_MBC_ITMP3_ITMP
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 0***/
+#define DANUBE_MBC_MBC_OABS0                    ((volatile u32*)(DANUBE_MBC+ 0x0018))
+#define DANUBE_MBC_MBC_OABS0_OABS
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 1***/
+#define DANUBE_MBC_MBC_OABS1                    ((volatile u32*)(DANUBE_MBC+ 0x0038))
+#define DANUBE_MBC_MBC_OABS1_OABS
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 2***/
+#define DANUBE_MBC_MBC_OABS2                    ((volatile u32*)(DANUBE_MBC+ 0x0058))
+#define DANUBE_MBC_MBC_OABS2_OABS
+
+/***Mailbox CPU Output Absolute Pointer of Buffer 3***/
+#define DANUBE_MBC_MBC_OABS3                    ((volatile u32*)(DANUBE_MBC+ 0x0078))
+#define DANUBE_MBC_MBC_OABS3_OABS
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 0***/
+#define DANUBE_MBC_MBC_OTMP0                    ((volatile u32*)(DANUBE_MBC+ 0x001C))
+#define DANUBE_MBC_MBC_OTMP0_OTMP
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 1***/
+#define DANUBE_MBC_MBC_OTMP1                    ((volatile u32*)(DANUBE_MBC+ 0x003C))
+#define DANUBE_MBC_MBC_OTMP1_OTMP
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 2***/
+#define DANUBE_MBC_MBC_OTMP2                    ((volatile u32*)(DANUBE_MBC+ 0x005C))
+#define DANUBE_MBC_MBC_OTMP2_OTMP
+
+/***Mailbox CPU Output Temporary Pointer of Buffer 3***/
+#define DANUBE_MBC_MBC_OTMP3                    ((volatile u32*)(DANUBE_MBC+ 0x007C))
+#define DANUBE_MBC_MBC_OTMP3_OTMP
+
+/***DSP Control Register***/
+#define DANUBE_MBC_DCTRL                        ((volatile u32*)(DANUBE_MBC+ 0x00A0))
+#define DANUBE_MBC_DCTRL_BA                              (1 << 0)
+#define DANUBE_MBC_DCTRL_BMOD (value)               (((( 1 << 3) - 1) & (value)) << 1)
+#define DANUBE_MBC_DCTRL_IDL                              (1 << 4)
+#define DANUBE_MBC_DCTRL_RES                              (1 << 15)
+
+/***DSP Status Register***/
+#define DANUBE_MBC_DSTA                         ((volatile u32*)(DANUBE_MBC+ 0x00A4))
+#define DANUBE_MBC_DSTA_IDLE                            (1 << 0)
+#define DANUBE_MBC_DSTA_PD                              (1 << 1)
+
+/***DSP Test 1 Register***/
+#define DANUBE_MBC_DTST1                        ((volatile u32*)(DANUBE_MBC+ 0x00A8))
+#define DANUBE_MBC_DTST1_ABORT                          (1 << 0)
+#define DANUBE_MBC_DTST1_HWF32                          (1 << 1)
+#define DANUBE_MBC_DTST1_HWF4M                          (1 << 2)
+#define DANUBE_MBC_DTST1_HWFOP                          (1 << 3)
+
+
+/***********************************************************************/
+/*  Module      :  SSC1 register address and bits                      */
+/***********************************************************************/
+#define DANUBE_SSC1                       	(KSEG1+0x1e100800)
+/***********************************************************************/
+/***SSC Clock Control Register***/
+#define DANUBE_SSC_CLC                      	(0x0000)
+#define DANUBE_SSC_CLC_RMC(value)               (((( 1 << 8) - 1) & (value)) << 8)
+#define DANUBE_SSC_CLC_DISS                     (1 << 1)
+#define DANUBE_SSC_CLC_DISR                     (1 << 0)
+/***SSC Port Input Selection Register***/
+#define DANUBE_SSC_PISEL                        (0x0004)
+/***SSC Identification Register***/
+#define DANUBE_SSC_ID                           (0x0008)
+/***Control Register (Programming Mode)***/
+#define DANUBE_SSC_CON                  		(0x0010)
+#define DANUBE_SSC_CON_RUEN                            (1 << 12)
+#define DANUBE_SSC_CON_TUEN                              (1 << 11)
+#define DANUBE_SSC_CON_AEN                              (1 << 10)
+#define DANUBE_SSC_CON_REN                              (1 << 9)
+#define DANUBE_SSC_CON_TEN                              (1 << 8)
+#define DANUBE_SSC_CON_LB                              (1 << 7)
+#define DANUBE_SSC_CON_PO                              (1 << 6)
+#define DANUBE_SSC_CON_PH                              (1 << 5)
+#define DANUBE_SSC_CON_HB                              (1 << 4)
+#define DANUBE_SSC_CON_BM(value)                	(((( 1 << 5) - 1) & (value)) << 16)
+#define DANUBE_SSC_CON_RX_OFF                          (1 << 1)
+#define DANUBE_SSC_CON_TX_OFF                          (1 << 0)
+/***SCC Status Register***/
+#define DANUBE_SSC_STATE                  (0x0014)
+#define DANUBE_SSC_STATE_EN                              (1 << 0)
+#define DANUBE_SSC_STATE_MS                              (1 << 1)
+#define DANUBE_SSC_STATE_BSY                              (1 << 13)
+#define DANUBE_SSC_STATE_RUE                              (1 << 12)
+#define DANUBE_SSC_STATE_TUE                              (1 << 11)
+#define DANUBE_SSC_STATE_AE                              (1 << 10)
+#define DANUBE_SSC_STATE_RE                              (1 << 9)
+#define DANUBE_SSC_STATE_TE                              (1 << 8)
+#define DANUBE_SSC_STATE_BC(value)                (((( 1 << 5) - 1) & (value)) << 16)
+/***SSC Write Hardware Modified Control Register***/
+#define DANUBE_SSC_WHBSTATE                   ( 0x0018)
+#define DANUBE_SSC_WHBSTATE_SETBE                          (1 << 15)
+#define DANUBE_SSC_WHBSTATE_SETPE                          (1 << 14)
+#define DANUBE_SSC_WHBSTATE_SETRE                          (1 << 13)
+#define DANUBE_SSC_WHBSTATE_SETTE                          (1 << 12)
+#define DANUBE_SSC_WHBSTATE_CLRBE                          (1 << 11)
+#define DANUBE_SSC_WHBSTATE_CLRPE                          (1 << 10)
+#define DANUBE_SSC_WHBSTATE_CLRRE                          (1 << 9)
+#define DANUBE_SSC_WHBSTATE_CLRTE                          (1 << 8)
+/***SSC Transmitter Buffer Register***/
+#define DANUBE_SSC_TB                       (0x0020)
+#define DANUBE_SSC_TB_TB_VALUE(value)          (((( 1 << 16) - 1) & (value)) << 0)
+/***SSC Receiver Buffer Register***/
+#define DANUBE_SSC_RB                       (0x0024)
+#define DANUBE_SSC_RB_RB_VALUE(value)          (((( 1 << 16) - 1) & (value)) << 0)
+/***SSC Receive FIFO Control Register***/
+#define DANUBE_SSC_RXFCON                   (0x0030)
+#define DANUBE_SSC_RXFCON_RXFITL(value)             (((( 1 << 6) - 1) & (value)) << 8)
+#define DANUBE_SSC_RXFCON_RXTMEN                        (1 << 2)
+#define DANUBE_SSC_RXFCON_RXFLU                          (1 << 1)
+#define DANUBE_SSC_RXFCON_RXFEN                          (1 << 0)
+/***SSC Transmit FIFO Control Register***/
+#define DANUBE_SSC_TXFCON                   ( 0x0034)
+#define DANUBE_SSC_TXFCON_RXFITL(value)             (((( 1 << 6) - 1) & (value)) << 8)
+#define DANUBE_SSC_TXFCON_TXTMEN                        (1 << 2)
+#define DANUBE_SSC_TXFCON_TXFLU                          (1 << 1)
+#define DANUBE_SSC_TXFCON_TXFEN                          (1 << 0)
+/***SSC FIFO Status Register***/
+#define DANUBE_SSC_FSTAT                    (0x0038)
+#define DANUBE_SSC_FSTAT_TXFFL(value)              (((( 1 << 6) - 1) & (value)) << 8)
+#define DANUBE_SSC_FSTAT_RXFFL(value)              (((( 1 << 6) - 1) & (value)) << 0)
+/***SSC Baudrate Timer Reload Register***/
+#define DANUBE_SSC_BR                       (0x0040)
+#define DANUBE_SSC_BR_BR_VALUE(value)          (((( 1 << 16) - 1) & (value)) << 0)
+#define DANUBE_SSC_BRSTAT                       (0x0044)
+#define DANUBE_SSC_SFCON                        (0x0060)
+#define DANUBE_SSC_SFSTAT                       (0x0064)
+#define DANUBE_SSC_GPOCON                       (0x0070)
+#define DANUBE_SSC_GPOSTAT                      (0x0074)
+#define DANUBE_SSC_WHBGPOSTAT                   (0x0078)
+#define DANUBE_SSC_RXREQ                        (0x0080)
+#define DANUBE_SSC_RXCNT                        (0x0084)
+/*DMA Registers in Bus Clock Domain*/
+#define DANUBE_SSC_DMA_CON                      (0x00EC)
+/*interrupt Node Registers in Bus Clock Domain*/
+#define DANUBE_SSC_IRNEN                        (0x00F4)
+#define DANUBE_SSC_IRNCR                        (0x00F8)
+#define DANUBE_SSC_IRNICR                       (0x00FC)
+#define DANUBE_SSC_IRN_FIR			0x8
+#define DANUBE_SSC_IRN_EIR			0x4
+#define DANUBE_SSC_IRN_RIR			0x2
+#define DANUBE_SSC_IRN_TIR			0x1
+
+
+#define	DANUBE_SSC1_CLC			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_CLC))
+#define	DANUBE_SSC1_ID			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_ID))
+#define	DANUBE_SSC1_CON			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_CON))
+#define	DANUBE_SSC1_STATE			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_STATE))
+#define	DANUBE_SSC1_WHBSTATE			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_WHBSTATE))
+#define	DANUBE_SSC1_TB			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_TB))
+#define	DANUBE_SSC1_RB			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_RB))
+#define	DANUBE_SSC1_FSTAT			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_FSTAT))
+#define	DANUBE_SSC1_PISEL			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_PISEL))
+#define	DANUBE_SSC1_RXFCON			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_RXFCON))
+#define	DANUBE_SSC1_TXFCON			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_TXFCON))
+#define	DANUBE_SSC1_BR			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_BR))
+#define	DANUBE_SSC1_BRSTAT			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_BRSTAT))
+#define	DANUBE_SSC1_SFCON			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_SFCON))
+#define	DANUBE_SSC1_SFSTAT			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_SFSTAT))
+#define	DANUBE_SSC1_GPOCON			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_GPOCON))
+#define	DANUBE_SSC1_GPOSTAT			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_GPOSTAT))
+#define	DANUBE_SSC1_WHBGPOSTAT			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_WHBGPOSTAT))
+#define	DANUBE_SSC1_RXREQ			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_RXREQ))
+#define	DANUBE_SSC1_RXCNT			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_RXCNT))
+#define	DANUBE_SSC1_DMA_CON			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_DMA_CON))
+#define	DANUBE_SSC1_IRNEN			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_IRNEN))
+#define	DANUBE_SSC1_IRNICR			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_IRNICR))
+#define	DANUBE_SSC1_IRNCR			((volatile u32*)(DANUBE_SSC1+DANUBE_SSC_IRNCR))
+
+/***********************************************************************/
+/*  Module      :  GPIO register address and bits                       */
+/***********************************************************************/
+#define DANUBE_GPIO                     (0xBE100B00)
+/***Port 0 Data Output Register (0010H)***/
+#define DANUBE_GPIO_P0_OUT              ((volatile u32 *)(DANUBE_GPIO+ 0x0010))
+/***Port 1 Data Output Register (0040H)***/
+#define DANUBE_GPIO_P1_OUT              ((volatile u32 *)(DANUBE_GPIO+ 0x0040))
+/***Port 0 Data Input Register (0014H)***/
+#define DANUBE_GPIO_P0_IN               ((volatile u32 *)(DANUBE_GPIO+ 0x0014))
+/***Port 1 Data Input Register (0044H)***/
+#define DANUBE_GPIO_P1_IN               ((volatile u32 *)(DANUBE_GPIO+ 0x0044))
+/***Port 0 Direction Register (0018H)***/
+#define DANUBE_GPIO_P0_DIR              ((volatile u32 *)(DANUBE_GPIO+ 0x0018))
+/***Port 1 Direction Register (0048H)***/
+#define DANUBE_GPIO_P1_DIR              ((volatile u32 *)(DANUBE_GPIO+ 0x0048))
+/***Port 0 Alternate Function Select Register 0 (001C H) ***/
+#define DANUBE_GPIO_P0_ALTSEL0          ((volatile u32 *)(DANUBE_GPIO+ 0x001C))
+/***Port 1 Alternate Function Select Register 0 (004C H) ***/
+#define DANUBE_GPIO_P1_ALTSEL0          ((volatile u32 *)(DANUBE_GPIO+ 0x004C))
+/***Port 0 Alternate Function Select Register 1 (0020 H) ***/
+#define DANUBE_GPIO_P0_ALTSEL1          ((volatile u32 *)(DANUBE_GPIO+ 0x0020))
+/***Port 1 Alternate Function Select Register 0 (0050 H) ***/
+#define DANUBE_GPIO_P1_ALTSEL1          ((volatile u32 *)(DANUBE_GPIO+ 0x0050))
+/***Port 0 Open Drain Control Register (0024H)***/
+#define DANUBE_GPIO_P0_OD               ((volatile u32 *)(DANUBE_GPIO+ 0x0024))
+/***Port 1 Open Drain Control Register (0054H)***/
+#define DANUBE_GPIO_P1_OD               ((volatile u32 *)(DANUBE_GPIO+ 0x0054))
+/***Port 0 Input Schmitt-Trigger Off Register (0028 H) ***/
+#define DANUBE_GPIO_P0_STOFF            ((volatile u32 *)(DANUBE_GPIO+ 0x0028))
+/***Port 1 Input Schmitt-Trigger Off Register (0058 H) ***/
+#define DANUBE_GPIO_P1_STOFF            ((volatile u32 *)(DANUBE_GPIO+ 0x0058))
+/***Port 0 Pull Up/Pull Down Select Register (002C H)***/
+#define DANUBE_GPIO_P0_PUDSEL           ((volatile u32 *)(DANUBE_GPIO+ 0x002C))
+/***Port 1 Pull Up/Pull Down Select Register (005C H)***/
+#define DANUBE_GPIO_P1_PUDSEL           ((volatile u32 *)(DANUBE_GPIO+ 0x005C))
+/***Port 0 Pull Up Device Enable Register (0030 H)***/
+#define DANUBE_GPIO_P0_PUDEN            ((volatile u32 *)(DANUBE_GPIO+ 0x0030))
+/***Port 1 Pull Up Device Enable Register (0060 H)***/
+#define DANUBE_GPIO_P1_PUDEN            ((volatile u32 *)(DANUBE_GPIO+ 0x0060))
+/***********************************************************************/
+/*  Module      :  CGU register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_CGU                          (0xBF103000)
+/***********************************************************************/
+
+/***CGU Clock PLL0 ***/
+#define DANUBE_CGU_PLL0_CFG                	((volatile u32*)(DANUBE_CGU+ 0x0004))
+/***CGU Clock PLL1 ***/
+#define DANUBE_CGU_PLL1_CFG                	((volatile u32*)(DANUBE_CGU+ 0x0008))
+/***CGU Clock SYS Mux Register***/
+#define DANUBE_CGU_SYS                   	((volatile u32*)(DANUBE_CGU+ 0x0010))
+/***CGU Interface Clock Control Register***/
+#define DANUBE_CGU_IFCCR                        ((volatile u32*)(DANUBE_CGU+ 0x0018))
+/***CGU PCI Clock Control Register**/
+#define DANUBE_CGU_PCICR                          ((volatile u32*)(DANUBE_CGU+ 0x0034))
+
+
+/***********************************************************************/
+/*  Module      :  PCI register address and bits                       */
+/***********************************************************************/
+#define PCI_CR_PR_OFFSET  0xBE105400
+#define PCI_CR_CLK_CTRL_REG         (PCI_CR_PR_OFFSET + 0x0000)
+
+#define PCI_CR_PCI_ID_REG           (PCI_CR_PR_OFFSET + 0x0004)
+#define PCI_CR_SFT_RST_REG          (PCI_CR_PR_OFFSET + 0x0010)
+#define PCI_CR_PCI_FPI_ERR_ADDR_REG (PCI_CR_PR_OFFSET + 0x0014)
+#define PCI_CR_FCI_PCI_ERR_ADDR_REG (PCI_CR_PR_OFFSET + 0x0018)
+#define PCI_CR_FPI_ERR_TAG_REG      (PCI_CR_PR_OFFSET + 0x001C)
+#define PCI_CR_PCI_IRR_REG          (PCI_CR_PR_OFFSET + 0x0020)
+#define PCI_CR_PCI_IRA_REG          (PCI_CR_PR_OFFSET + 0x0024)
+#define PCI_CR_PCI_IRM_REG          (PCI_CR_PR_OFFSET + 0x0028)
+#define PCI_CR_PCI_EOI_REG          (PCI_CR_PR_OFFSET + 0x002C)
+#define PCI_CR_PCI_MOD_REG          (PCI_CR_PR_OFFSET + 0x0030)
+#define PCI_CR_DV_ID_REG            (PCI_CR_PR_OFFSET + 0x0034)
+#define PCI_CR_SUBSYS_ID_REG        (PCI_CR_PR_OFFSET + 0x0038)
+#define PCI_CR_PCI_PM_REG           (PCI_CR_PR_OFFSET + 0x003C)
+#define PCI_CR_CLASS_CODE1_REG      (PCI_CR_PR_OFFSET + 0x0040)
+#define PCI_CR_BAR11MASK_REG        (PCI_CR_PR_OFFSET + 0x0044)
+#define PCI_CR_BAR12MASK_REG        (PCI_CR_PR_OFFSET + 0x0048)
+#define PCI_CR_BAR13MASK_REG        (PCI_CR_PR_OFFSET + 0x004C)
+#define PCI_CR_BAR14MASK_REG        (PCI_CR_PR_OFFSET + 0x0050)
+#define PCI_CR_BAR15MASK_REG        (PCI_CR_PR_OFFSET + 0x0054)
+#define PCI_CR_BAR16MASK_REG        (PCI_CR_PR_OFFSET + 0x0058)
+#define PCI_CR_CIS_PT1_REG          (PCI_CR_PR_OFFSET + 0x005C)
+#define PCI_CR_SUBSYS_ID1_REG       (PCI_CR_PR_OFFSET + 0x0060)
+#define PCI_CR_PCI_ADDR_MAP11_REG   (PCI_CR_PR_OFFSET + 0x0064)
+#define PCI_CR_PCI_ADDR_MAP12_REG   (PCI_CR_PR_OFFSET + 0x0068)
+#define PCI_CR_PCI_ADDR_MAP13_REG   (PCI_CR_PR_OFFSET + 0x006C)
+#define PCI_CR_PCI_ADDR_MAP14_REG   (PCI_CR_PR_OFFSET + 0x0070)
+#define PCI_CR_PCI_ADDR_MAP15_REG   (PCI_CR_PR_OFFSET + 0x0074)
+#define PCI_CR_PCI_ADDR_MAP16_REG   (PCI_CR_PR_OFFSET + 0x0078)
+#define PCI_CR_FPI_SEG_EN_REG       (PCI_CR_PR_OFFSET + 0x007C)
+#define PCI_CR_PC_ARB_REG           (PCI_CR_PR_OFFSET + 0x0080)
+#define PCI_CR_BAR21MASK_REG        (PCI_CR_PR_OFFSET + 0x0084)
+#define PCI_CR_BAR22MASK_REG        (PCI_CR_PR_OFFSET + 0x0088)
+#define PCI_CR_BAR23MASK_REG        (PCI_CR_PR_OFFSET + 0x008C)
+#define PCI_CR_BAR24MASK_REG        (PCI_CR_PR_OFFSET + 0x0090)
+#define PCI_CR_BAR25MASK_REG        (PCI_CR_PR_OFFSET + 0x0094)
+#define PCI_CR_BAR26MASK_REG        (PCI_CR_PR_OFFSET + 0x0098)
+#define PCI_CR_CIS_PT2_REG          (PCI_CR_PR_OFFSET + 0x009C)
+#define PCI_CR_SUBSYS_ID2_REG       (PCI_CR_PR_OFFSET + 0x00A0)
+#define PCI_CR_PCI_ADDR_MAP21_REG   (PCI_CR_PR_OFFSET + 0x00A4)
+#define PCI_CR_PCI_ADDR_MAP22_REG   (PCI_CR_PR_OFFSET + 0x00A8)
+#define PCI_CR_PCI_ADDR_MAP23_REG   (PCI_CR_PR_OFFSET + 0x00AC)
+
+
+/***********************************************************************/
+/*  Module      :  MCD register address and bits                       */
+/***********************************************************************/
+#define DANUBE_MCD                          		(KSEG1+0x1F106000)
+
+/***Manufacturer Identification Register***/
+#define DANUBE_MCD_MANID                        	((volatile u32*)(DANUBE_MCD+ 0x0024))
+#define DANUBE_MCD_MANID_MANUF(value)              	(((( 1 << 11) - 1) & (value)) << 5)
+
+/***Chip Identification Register***/
+#define DANUBE_MCD_CHIPID                       	((volatile u32*)(DANUBE_MCD+ 0x0028))
+#define DANUBE_MCD_CHIPID_VERSION_GET(value)             (((value) >> 28) & ((1 << 4) - 1))
+#define DANUBE_MCD_CHIPID_VERSION_SET(value)             (((( 1 << 4) - 1) & (value)) << 28)
+#define DANUBE_MCD_CHIPID_PART_NUMBER_GET(value)         (((value) >> 12) & ((1 << 16) - 1))
+#define DANUBE_MCD_CHIPID_PART_NUMBER_SET(value)         (((( 1 << 16) - 1) & (value)) << 12)
+#define DANUBE_MCD_CHIPID_MANID_GET(value)               (((value) >> 1) & ((1 << 11) - 1))
+#define DANUBE_MCD_CHIPID_MANID_SET(value)               (((( 1 << 11) - 1) & (value)) << 1)
+
+#define DANUBE_CHIPID_STANDARD				0x00EB
+#define DANUBE_CHIPID_YANGTSE				0x00ED
+
+/***Redesign Tracing Identification Register***/
+#define DANUBE_MCD_RTID                         	((volatile u32*)(DANUBE_MCD+ 0x002C))
+#define DANUBE_MCD_RTID_LC                              (1 << 15)
+#define DANUBE_MCD_RTID_RIX(value)                	(((( 1 << 3) - 1) & (value)) << 0)
+
+
+/***********************************************************************/
+/*  Module      :  EBU register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_EBU                          (0xBE105300)
+#define EBU_NAND_CON       (volatile u32*)(DANUBE_EBU + 0xB0)
+#define EBU_NAND_WAIT      (volatile u32*)(DANUBE_EBU + 0xB4)
+#define EBU_NAND_ECC0      (volatile u32*)(DANUBE_EBU + 0xB8)
+#define EBU_NAND_ECC_AC    (volatile u32*)(DANUBE_EBU + 0xBC)
+
+/***********************************************************************/
+
+
+/***EBU Clock Control Register***/
+#define DANUBE_EBU_CLC                      ((volatile u32*)(DANUBE_EBU+ 0x0000))
+#define DANUBE_EBU_CLC_DISS                            (1 << 1)
+#define DANUBE_EBU_CLC_DISR                            (1 << 0)
+
+/***EBU Global Control Register***/
+#define DANUBE_EBU_CON                      ((volatile u32*)(DANUBE_EBU+ 0x0010))
+#define DANUBE_EBU_CON_DTACS (value)              (((( 1 << 3) - 1) & (value)) << 20)
+#define DANUBE_EBU_CON_DTARW (value)              (((( 1 << 3) - 1) & (value)) << 16)
+#define DANUBE_EBU_CON_TOUTC (value)              (((( 1 << 8) - 1) & (value)) << 8)
+#define DANUBE_EBU_CON_ARBMODE (value)            (((( 1 << 2) - 1) & (value)) << 6)
+#define DANUBE_EBU_CON_ARBSYNC                      (1 << 5)
+#define DANUBE_EBU_CON_1                              (1 << 3)
+
+/***EBU Address Select Register 0***/
+#define DANUBE_EBU_ADDSEL0                  ((volatile u32*)(DANUBE_EBU+ 0x0020))
+#define DANUBE_EBU_ADDSEL0_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define DANUBE_EBU_ADDSEL0_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_EBU_ADDSEL0_MIRRORE                      (1 << 1)
+#define DANUBE_EBU_ADDSEL0_REGEN                          (1 << 0)
+
+/***EBU Address Select Register 1***/
+#define DANUBE_EBU_ADDSEL1                  ((volatile u32*)(DANUBE_EBU+ 0x0024))
+#define DANUBE_EBU_ADDSEL1_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define DANUBE_EBU_ADDSEL1_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_EBU_ADDSEL1_MIRRORE                      (1 << 1)
+#define DANUBE_EBU_ADDSEL1_REGEN                          (1 << 0)
+
+/***EBU Address Select Register 2***/
+#define DANUBE_EBU_ADDSEL2                  ((volatile u32*)(DANUBE_EBU+ 0x0028))
+#define DANUBE_EBU_ADDSEL2_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define DANUBE_EBU_ADDSEL2_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_EBU_ADDSEL2_MIRRORE                      (1 << 1)
+#define DANUBE_EBU_ADDSEL2_REGEN                          (1 << 0)
+
+/***EBU Address Select Register 3***/
+#define DANUBE_EBU_ADDSEL3                  ((volatile u32*)(DANUBE_EBU+ 0x002C))
+#define DANUBE_EBU_ADDSEL3_BASE (value)               (((( 1 << 20) - 1) & (value)) << 12)
+#define DANUBE_EBU_ADDSEL3_MASK (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_EBU_ADDSEL3_MIRRORE                      (1 << 1)
+#define DANUBE_EBU_ADDSEL3_REGEN                          (1 << 0)
+
+/***EBU Bus Configuration Register 0***/
+#define DANUBE_EBU_BUSCON0                  ((volatile u32*)(DANUBE_EBU+ 0x0060))
+#define DANUBE_EBU_BUSCON0_WRDIS                          (1 << 31)
+#define DANUBE_EBU_BUSCON0_ALEC (value)               (((( 1 << 2) - 1) & (value)) << 29)
+#define DANUBE_EBU_BUSCON0_BCGEN (value)              (((( 1 << 2) - 1) & (value)) << 27)
+#define DANUBE_EBU_BUSCON0_AGEN (value)               (((( 1 << 2) - 1) & (value)) << 24)
+#define DANUBE_EBU_BUSCON0_CMULTR (value)             (((( 1 << 2) - 1) & (value)) << 22)
+#define DANUBE_EBU_BUSCON0_WAIT (value)               (((( 1 << 2) - 1) & (value)) << 20)
+#define DANUBE_EBU_BUSCON0_WAITINV                      (1 << 19)
+#define DANUBE_EBU_BUSCON0_SETUP                          (1 << 18)
+#define DANUBE_EBU_BUSCON0_PORTW (value)              (((( 1 << 2) - 1) & (value)) << 16)
+#define DANUBE_EBU_BUSCON0_WAITRDC (value)            (((( 1 << 7) - 1) & (value)) << 9)
+#define DANUBE_EBU_BUSCON0_WAITWRC (value)            (((( 1 << 3) - 1) & (value)) << 6)
+#define DANUBE_EBU_BUSCON0_HOLDC (value)              (((( 1 << 2) - 1) & (value)) << 4)
+#define DANUBE_EBU_BUSCON0_RECOVC (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define DANUBE_EBU_BUSCON0_CMULT (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 1***/
+#define DANUBE_EBU_BUSCON1                  ((volatile u32*)(DANUBE_EBU+ 0x0064))
+#define DANUBE_EBU_BUSCON1_WRDIS                          (1 << 31)
+#define DANUBE_EBU_BUSCON1_ALEC (value)               (((( 1 << 2) - 1) & (value)) << 29)
+#define DANUBE_EBU_BUSCON1_BCGEN (value)              (((( 1 << 2) - 1) & (value)) << 27)
+#define DANUBE_EBU_BUSCON1_AGEN (value)               (((( 1 << 2) - 1) & (value)) << 24)
+#define DANUBE_EBU_BUSCON1_CMULTR (value)             (((( 1 << 2) - 1) & (value)) << 22)
+#define DANUBE_EBU_BUSCON1_WAIT (value)               (((( 1 << 2) - 1) & (value)) << 20)
+#define DANUBE_EBU_BUSCON1_WAITINV                      (1 << 19)
+#define DANUBE_EBU_BUSCON1_SETUP                          (1 << 18)
+#define DANUBE_EBU_BUSCON1_PORTW (value)              (((( 1 << 2) - 1) & (value)) << 16)
+#define DANUBE_EBU_BUSCON1_WAITRDC (value)            (((( 1 << 7) - 1) & (value)) << 9)
+#define DANUBE_EBU_BUSCON1_WAITWRC (value)            (((( 1 << 3) - 1) & (value)) << 6)
+#define DANUBE_EBU_BUSCON1_HOLDC (value)              (((( 1 << 2) - 1) & (value)) << 4)
+#define DANUBE_EBU_BUSCON1_RECOVC (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define DANUBE_EBU_BUSCON1_CMULT (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***EBU Bus Configuration Register 2***/
+#define DANUBE_EBU_BUSCON2                  ((volatile u32*)(DANUBE_EBU+ 0x0068))
+#define DANUBE_EBU_BUSCON2_WRDIS                          (1 << 31)
+#define DANUBE_EBU_BUSCON2_ALEC (value)               (((( 1 << 2) - 1) & (value)) << 29)
+#define DANUBE_EBU_BUSCON2_BCGEN (value)              (((( 1 << 2) - 1) & (value)) << 27)
+#define DANUBE_EBU_BUSCON2_AGEN (value)               (((( 1 << 2) - 1) & (value)) << 24)
+#define DANUBE_EBU_BUSCON2_CMULTR (value)             (((( 1 << 2) - 1) & (value)) << 22)
+#define DANUBE_EBU_BUSCON2_WAIT (value)               (((( 1 << 2) - 1) & (value)) << 20)
+#define DANUBE_EBU_BUSCON2_WAITINV                      (1 << 19)
+#define DANUBE_EBU_BUSCON2_SETUP                          (1 << 18)
+#define DANUBE_EBU_BUSCON2_PORTW (value)              (((( 1 << 2) - 1) & (value)) << 16)
+#define DANUBE_EBU_BUSCON2_WAITRDC (value)            (((( 1 << 7) - 1) & (value)) << 9)
+#define DANUBE_EBU_BUSCON2_WAITWRC (value)            (((( 1 << 3) - 1) & (value)) << 6)
+#define DANUBE_EBU_BUSCON2_HOLDC (value)              (((( 1 << 2) - 1) & (value)) << 4)
+#define DANUBE_EBU_BUSCON2_RECOVC (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define DANUBE_EBU_BUSCON2_CMULT (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  SDRAM register address and bits                     */
+/***********************************************************************/
+
+#define DANUBE_SDRAM                        (0xBF800000)
+/***********************************************************************/
+
+
+/***MC Access Error Cause Register***/
+#define DANUBE_SDRAM_MC_ERRCAUSE                  ((volatile u32*)(DANUBE_SDRAM+ 0x0100))
+#define DANUBE_SDRAM_MC_ERRCAUSE_ERR                              (1 << 31)
+#define DANUBE_SDRAM_MC_ERRCAUSE_PORT (value)               (((( 1 << 4) - 1) & (value)) << 16)
+#define DANUBE_SDRAM_MC_ERRCAUSE_CAUSE (value)              (((( 1 << 2) - 1) & (value)) << 0)
+#define DANUBE_SDRAM_MC_ERRCAUSE_Res (value)                (((( 1 << NaN) - 1) & (value)) << NaN)
+
+/***MC Access Error Address Register***/
+#define DANUBE_SDRAM_MC_ERRADDR                   ((volatile u32*)(DANUBE_SDRAM+ 0x0108))
+#define DANUBE_SDRAM_MC_ERRADDR_ADDR
+
+/***MC I/O General Purpose Register***/
+#define DANUBE_SDRAM_MC_IOGP                      ((volatile u32*)(DANUBE_SDRAM+ 0x0800))
+#define DANUBE_SDRAM_MC_IOGP_GPR6 (value)               (((( 1 << 4) - 1) & (value)) << 28)
+#define DANUBE_SDRAM_MC_IOGP_GPR5 (value)               (((( 1 << 4) - 1) & (value)) << 24)
+#define DANUBE_SDRAM_MC_IOGP_GPR4 (value)               (((( 1 << 4) - 1) & (value)) << 20)
+#define DANUBE_SDRAM_MC_IOGP_GPR3 (value)               (((( 1 << 4) - 1) & (value)) << 16)
+#define DANUBE_SDRAM_MC_IOGP_GPR2 (value)               (((( 1 << 4) - 1) & (value)) << 12)
+#define DANUBE_SDRAM_MC_IOGP_CPS                              (1 << 11)
+#define DANUBE_SDRAM_MC_IOGP_CLKDELAY (value)          (((( 1 << 3) - 1) & (value)) << 8)
+#define DANUBE_SDRAM_MC_IOGP_CLKRAT (value)             (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_SDRAM_MC_IOGP_RDDEL (value)              (((( 1 << 4) - 1) & (value)) << 0)
+
+/***MC Self Refresh Register***/
+#define DANUBE_SDRAM_MC_SELFRFSH                  ((volatile u32*)(DANUBE_SDRAM+ 0x0A00))
+#define DANUBE_SDRAM_MC_SELFRFSH_PWDS                            (1 << 1)
+#define DANUBE_SDRAM_MC_SELFRFSH_PWD                              (1 << 0)
+#define DANUBE_SDRAM_MC_SELFRFSH_Res (value)                (((( 1 << 30) - 1) & (value)) << 2)
+
+/***MC Enable Register***/
+#define DANUBE_SDRAM_MC_CTRLENA                   ((volatile u32*)(DANUBE_SDRAM+ 0x1000))
+#define DANUBE_SDRAM_MC_CTRLENA_ENA                              (1 << 0)
+#define DANUBE_SDRAM_MC_CTRLENA_Res (value)                (((( 1 << 31) - 1) & (value)) << 1)
+
+/***MC Mode Register Setup Code***/
+#define DANUBE_SDRAM_MC_MRSCODE                   ((volatile u32*)(DANUBE_SDRAM+ 0x1008))
+#define DANUBE_SDRAM_MC_MRSCODE_UMC (value)                (((( 1 << 5) - 1) & (value)) << 7)
+#define DANUBE_SDRAM_MC_MRSCODE_CL (value)                (((( 1 << 3) - 1) & (value)) << 4)
+#define DANUBE_SDRAM_MC_MRSCODE_WT                              (1 << 3)
+#define DANUBE_SDRAM_MC_MRSCODE_BL (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***MC Configuration Data-word Width Register***/
+#define DANUBE_SDRAM_MC_CFGDW                    ((volatile u32*)(DANUBE_SDRAM+ 0x1010))
+#define DANUBE_SDRAM_MC_CFGDW_DW (value)                (((( 1 << 4) - 1) & (value)) << 0)
+#define DANUBE_SDRAM_MC_CFGDW_Res (value)                (((( 1 << 28) - 1) & (value)) << 4)
+
+/***MC Configuration Physical Bank 0 Register***/
+#define DANUBE_SDRAM_MC_CFGPB0                    ((volatile u32*)(DANUBE_SDRAM+ 0x1018))
+#define DANUBE_SDRAM_MC_CFGPB0_MCSEN0 (value)             (((( 1 << 4) - 1) & (value)) << 12)
+#define DANUBE_SDRAM_MC_CFGPB0_BANKN0 (value)             (((( 1 << 4) - 1) & (value)) << 8)
+#define DANUBE_SDRAM_MC_CFGPB0_ROWW0 (value)              (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_SDRAM_MC_CFGPB0_COLW0 (value)              (((( 1 << 4) - 1) & (value)) << 0)
+#define DANUBE_SDRAM_MC_CFGPB0_Res (value)                (((( 1 << 16) - 1) & (value)) << 16)
+
+/***MC Latency Register***/
+#define DANUBE_SDRAM_MC_LATENCY                   ((volatile u32*)(DANUBE_SDRAM+ 0x1038))
+#define DANUBE_SDRAM_MC_LATENCY_TRP (value)                (((( 1 << 4) - 1) & (value)) << 16)
+#define DANUBE_SDRAM_MC_LATENCY_TRAS (value)               (((( 1 << 4) - 1) & (value)) << 12)
+#define DANUBE_SDRAM_MC_LATENCY_TRCD (value)               (((( 1 << 4) - 1) & (value)) << 8)
+#define DANUBE_SDRAM_MC_LATENCY_TDPL (value)               (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_SDRAM_MC_LATENCY_TDAL (value)               (((( 1 << 4) - 1) & (value)) << 0)
+#define DANUBE_SDRAM_MC_LATENCY_Res (value)                (((( 1 << 12) - 1) & (value)) << 20)
+
+/***MC Refresh Cycle Time Register***/
+#define DANUBE_SDRAM_MC_TREFRESH                  ((volatile u32*)(DANUBE_SDRAM+ 0x1040))
+#define DANUBE_SDRAM_MC_TREFRESH_TREF (value)               (((( 1 << 13) - 1) & (value)) << 0)
+#define DANUBE_SDRAM_MC_TREFRESH_Res (value)                (((( 1 << 19) - 1) & (value)) << 13)
+
+
+/***********************************************************************/
+/*  Module      :  GPTU register address and bits                      */
+/***********************************************************************/
+
+#define DANUBE_GPTU                         (0xB8000300)
+/***********************************************************************/
+
+
+/***GPT Clock Control Register***/
+#define DANUBE_GPTU_GPT_CLC                      ((volatile u32*)(DANUBE_GPTU+ 0x0000))
+#define DANUBE_GPTU_GPT_CLC_RMC (value)                (((( 1 << 8) - 1) & (value)) << 8)
+#define DANUBE_GPTU_GPT_CLC_DISS                            (1 << 1)
+#define DANUBE_GPTU_GPT_CLC_DISR                            (1 << 0)
+
+/***GPT Timer 3 Control Register***/
+#define DANUBE_GPTU_GPT_T3CON                    ((volatile u32*)(DANUBE_GPTU+ 0x0014))
+#define DANUBE_GPTU_GPT_T3CON_T3RDIR                        (1 << 15)
+#define DANUBE_GPTU_GPT_T3CON_T3CHDIR                      (1 << 14)
+#define DANUBE_GPTU_GPT_T3CON_T3EDGE                        (1 << 13)
+#define DANUBE_GPTU_GPT_T3CON_BPS1 (value)               (((( 1 << 2) - 1) & (value)) << 11)
+#define DANUBE_GPTU_GPT_T3CON_T3OTL                          (1 << 10)
+#define DANUBE_GPTU_GPT_T3CON_T3UD                            (1 << 7)
+#define DANUBE_GPTU_GPT_T3CON_T3R                              (1 << 6)
+#define DANUBE_GPTU_GPT_T3CON_T3M (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define DANUBE_GPTU_GPT_T3CON_T3I (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Write Hardware Modified Timer 3 Control Register
+If set and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define DANUBE_GPTU_GPT_WHBT3CON                 ((volatile u32*)(DANUBE_GPTU+ 0x004C))
+#define DANUBE_GPTU_GPT_WHBT3CON_SETT3CHDIR                (1 << 15)
+#define DANUBE_GPTU_GPT_WHBT3CON_CLRT3CHDIR                (1 << 14)
+#define DANUBE_GPTU_GPT_WHBT3CON_SETT3EDGE                  (1 << 13)
+#define DANUBE_GPTU_GPT_WHBT3CON_CLRT3EDGE                  (1 << 12)
+#define DANUBE_GPTU_GPT_WHBT3CON_SETT3OTL                  (1 << 11)
+#define DANUBE_GPTU_GPT_WHBT3CON_CLRT3OTL                  (1 << 10)
+
+/***GPT Timer 2 Control Register***/
+#define DANUBE_GPTU_GPT_T2CON                    ((volatile u32*)(DANUBE_GPTU+ 0x0010))
+#define DANUBE_GPTU_GPT_T2CON_TxRDIR                        (1 << 15)
+#define DANUBE_GPTU_GPT_T2CON_TxCHDIR                      (1 << 14)
+#define DANUBE_GPTU_GPT_T2CON_TxEDGE                        (1 << 13)
+#define DANUBE_GPTU_GPT_T2CON_TxIRDIS                      (1 << 12)
+#define DANUBE_GPTU_GPT_T2CON_TxRC                            (1 << 9)
+#define DANUBE_GPTU_GPT_T2CON_TxUD                            (1 << 7)
+#define DANUBE_GPTU_GPT_T2CON_TxR                              (1 << 6)
+#define DANUBE_GPTU_GPT_T2CON_TxM (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define DANUBE_GPTU_GPT_T2CON_TxI (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Timer 4 Control Register***/
+#define DANUBE_GPTU_GPT_T4CON                    ((volatile u32*)(DANUBE_GPTU+ 0x0018))
+#define DANUBE_GPTU_GPT_T4CON_TxRDIR                        (1 << 15)
+#define DANUBE_GPTU_GPT_T4CON_TxCHDIR                      (1 << 14)
+#define DANUBE_GPTU_GPT_T4CON_TxEDGE                        (1 << 13)
+#define DANUBE_GPTU_GPT_T4CON_TxIRDIS                      (1 << 12)
+#define DANUBE_GPTU_GPT_T4CON_TxRC                            (1 << 9)
+#define DANUBE_GPTU_GPT_T4CON_TxUD                            (1 << 7)
+#define DANUBE_GPTU_GPT_T4CON_TxR                              (1 << 6)
+#define DANUBE_GPTU_GPT_T4CON_TxM (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define DANUBE_GPTU_GPT_T4CON_TxI (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Write HW Modified Timer 2 Control Register If set
+ and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define DANUBE_GPTU_GPT_WHBT2CON                 ((volatile u32*)(DANUBE_GPTU+ 0x0048))
+#define DANUBE_GPTU_GPT_WHBT2CON_SETTxCHDIR                (1 << 15)
+#define DANUBE_GPTU_GPT_WHBT2CON_CLRTxCHDIR                (1 << 14)
+#define DANUBE_GPTU_GPT_WHBT2CON_SETTxEDGE                  (1 << 13)
+#define DANUBE_GPTU_GPT_WHBT2CON_CLRTxEDGE                  (1 << 12)
+
+/***GPT Write HW Modified Timer 4 Control Register If set
+ and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define DANUBE_GPTU_GPT_WHBT4CON                 ((volatile u32*)(DANUBE_GPTU+ 0x0050))
+#define DANUBE_GPTU_GPT_WHBT4CON_SETTxCHDIR                (1 << 15)
+#define DANUBE_GPTU_GPT_WHBT4CON_CLRTxCHDIR                (1 << 14)
+#define DANUBE_GPTU_GPT_WHBT4CON_SETTxEDGE                  (1 << 13)
+#define DANUBE_GPTU_GPT_WHBT4CON_CLRTxEDGE                  (1 << 12)
+
+/***GPT Capture Reload Register***/
+#define DANUBE_GPTU_GPT_CAPREL                   ((volatile u32*)(DANUBE_GPTU+ 0x0030))
+#define DANUBE_GPTU_GPT_CAPREL_CAPREL (value)             (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 2 Register***/
+#define DANUBE_GPTU_GPT_T2                       ((volatile u32*)(DANUBE_GPTU+ 0x0034))
+#define DANUBE_GPTU_GPT_T2_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 3 Register***/
+#define DANUBE_GPTU_GPT_T3                       ((volatile u32*)(DANUBE_GPTU+ 0x0038))
+#define DANUBE_GPTU_GPT_T3_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 4 Register***/
+#define DANUBE_GPTU_GPT_T4                       ((volatile u32*)(DANUBE_GPTU+ 0x003C))
+#define DANUBE_GPTU_GPT_T4_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 5 Register***/
+#define DANUBE_GPTU_GPT_T5                       ((volatile u32*)(DANUBE_GPTU+ 0x0040))
+#define DANUBE_GPTU_GPT_T5_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 6 Register***/
+#define DANUBE_GPTU_GPT_T6                       ((volatile u32*)(DANUBE_GPTU+ 0x0044))
+#define DANUBE_GPTU_GPT_T6_TVAL (value)               (((( 1 << 16) - 1) & (value)) << 0)
+
+/***GPT Timer 6 Control Register***/
+#define DANUBE_GPTU_GPT_T6CON                    ((volatile u32*)(DANUBE_GPTU+ 0x0020))
+#define DANUBE_GPTU_GPT_T6CON_T6SR                            (1 << 15)
+#define DANUBE_GPTU_GPT_T6CON_T6CLR                          (1 << 14)
+#define DANUBE_GPTU_GPT_T6CON_BPS2 (value)               (((( 1 << 2) - 1) & (value)) << 11)
+#define DANUBE_GPTU_GPT_T6CON_T6OTL                          (1 << 10)
+#define DANUBE_GPTU_GPT_T6CON_T6UD                            (1 << 7)
+#define DANUBE_GPTU_GPT_T6CON_T6R                              (1 << 6)
+#define DANUBE_GPTU_GPT_T6CON_T6M (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define DANUBE_GPTU_GPT_T6CON_T6I (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+/***GPT Write HW Modified Timer 6 Control Register If set
+ and clear bit are written concurrently with 1, the associated bit is not changed.***/
+#define DANUBE_GPTU_GPT_WHBT6CON                 ((volatile u32*)(DANUBE_GPTU+ 0x0054))
+#define DANUBE_GPTU_GPT_WHBT6CON_SETT6OTL                  (1 << 11)
+#define DANUBE_GPTU_GPT_WHBT6CON_CLRT6OTL                  (1 << 10)
+
+/***GPT Timer 5 Control Register***/
+#define DANUBE_GPTU_GPT_T5CON                    ((volatile u32*)(DANUBE_GPTU+ 0x001C))
+#define DANUBE_GPTU_GPT_T5CON_T5SC                            (1 << 15)
+#define DANUBE_GPTU_GPT_T5CON_T5CLR                          (1 << 14)
+#define DANUBE_GPTU_GPT_T5CON_CI (value)                (((( 1 << 2) - 1) & (value)) << 12)
+#define DANUBE_GPTU_GPT_T5CON_T5CC                            (1 << 11)
+#define DANUBE_GPTU_GPT_T5CON_CT3                              (1 << 10)
+#define DANUBE_GPTU_GPT_T5CON_T5RC                            (1 << 9)
+#define DANUBE_GPTU_GPT_T5CON_T5UDE                          (1 << 8)
+#define DANUBE_GPTU_GPT_T5CON_T5UD                            (1 << 7)
+#define DANUBE_GPTU_GPT_T5CON_T5R                              (1 << 6)
+#define DANUBE_GPTU_GPT_T5CON_T5M (value)                (((( 1 << 3) - 1) & (value)) << 3)
+#define DANUBE_GPTU_GPT_T5CON_T5I (value)                (((( 1 << 3) - 1) & (value)) << 0)
+
+
+/***********************************************************************/
+/*  Module      :  IOM register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_IOM                          (0xBF105000)
+/***********************************************************************/
+
+
+/***Receive FIFO***/
+#define DANUBE_IOM_RFIFO                        ((volatile u32*)(DANUBE_IOM+ 0x0000))
+#define DANUBE_IOM_RFIFO_RXD (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Transmit FIFO***/
+#define DANUBE_IOM_XFIFO                        ((volatile u32*)(DANUBE_IOM+ 0x0000))
+#define DANUBE_IOM_XFIFO_TXD (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Interrupt Status Register HDLC***/
+#define DANUBE_IOM_ISTAH                        ((volatile u32*)(DANUBE_IOM+ 0x0080))
+#define DANUBE_IOM_ISTAH_RME                              (1 << 7)
+#define DANUBE_IOM_ISTAH_RPF                              (1 << 6)
+#define DANUBE_IOM_ISTAH_RFO                              (1 << 5)
+#define DANUBE_IOM_ISTAH_XPR                              (1 << 4)
+#define DANUBE_IOM_ISTAH_XMR                              (1 << 3)
+#define DANUBE_IOM_ISTAH_XDU                              (1 << 2)
+
+/***Interrupt Mask Register HDLC***/
+#define DANUBE_IOM_MASKH                        ((volatile u32*)(DANUBE_IOM+ 0x0080))
+#define DANUBE_IOM_MASKH_RME                              (1 << 7)
+#define DANUBE_IOM_MASKH_RPF                              (1 << 6)
+#define DANUBE_IOM_MASKH_RFO                              (1 << 5)
+#define DANUBE_IOM_MASKH_XPR                              (1 << 4)
+#define DANUBE_IOM_MASKH_XMR                              (1 << 3)
+#define DANUBE_IOM_MASKH_XDU                              (1 << 2)
+
+/***Status Register***/
+#define DANUBE_IOM_STAR                         ((volatile u32*)(DANUBE_IOM+ 0x0084))
+#define DANUBE_IOM_STAR_XDOV                            (1 << 7)
+#define DANUBE_IOM_STAR_XFW                              (1 << 6)
+#define DANUBE_IOM_STAR_RACI                            (1 << 3)
+#define DANUBE_IOM_STAR_XACI                            (1 << 1)
+
+/***Command Register***/
+#define DANUBE_IOM_CMDR                         ((volatile u32*)(DANUBE_IOM+ 0x0084))
+#define DANUBE_IOM_CMDR_RMC                              (1 << 7)
+#define DANUBE_IOM_CMDR_RRES                            (1 << 6)
+#define DANUBE_IOM_CMDR_XTF                              (1 << 3)
+#define DANUBE_IOM_CMDR_XME                              (1 << 1)
+#define DANUBE_IOM_CMDR_XRES                            (1 << 0)
+
+/***Mode Register***/
+#define DANUBE_IOM_MODEH                        ((volatile u32*)(DANUBE_IOM+ 0x0088))
+#define DANUBE_IOM_MODEH_MDS2                            (1 << 7)
+#define DANUBE_IOM_MODEH_MDS1                            (1 << 6)
+#define DANUBE_IOM_MODEH_MDS0                            (1 << 5)
+#define DANUBE_IOM_MODEH_RAC                              (1 << 3)
+#define DANUBE_IOM_MODEH_DIM2                            (1 << 2)
+#define DANUBE_IOM_MODEH_DIM1                            (1 << 1)
+#define DANUBE_IOM_MODEH_DIM0                            (1 << 0)
+
+/***Extended Mode Register***/
+#define DANUBE_IOM_EXMR                         ((volatile u32*)(DANUBE_IOM+ 0x008C))
+#define DANUBE_IOM_EXMR_XFBS                            (1 << 7)
+#define DANUBE_IOM_EXMR_RFBS (value)               (((( 1 << 2) - 1) & (value)) << 5)
+#define DANUBE_IOM_EXMR_SRA                              (1 << 4)
+#define DANUBE_IOM_EXMR_XCRC                            (1 << 3)
+#define DANUBE_IOM_EXMR_RCRC                            (1 << 2)
+#define DANUBE_IOM_EXMR_ITF                              (1 << 0)
+
+/***SAPI1 Register***/
+#define DANUBE_IOM_SAP1                         ((volatile u32*)(DANUBE_IOM+ 0x0094))
+#define DANUBE_IOM_SAP1_SAPI1 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+#define DANUBE_IOM_SAP1_MHA                              (1 << 0)
+
+/***Receive Frame Byte Count Low***/
+#define DANUBE_IOM_RBCL                         ((volatile u32*)(DANUBE_IOM+ 0x0098))
+#define DANUBE_IOM_RBCL_RBC(value)              (1 << value)
+
+
+/***SAPI2 Register***/
+#define DANUBE_IOM_SAP2                         ((volatile u32*)(DANUBE_IOM+ 0x0098))
+#define DANUBE_IOM_SAP2_SAPI2 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+#define DANUBE_IOM_SAP2_MLA                              (1 << 0)
+
+/***Receive Frame Byte Count High***/
+#define DANUBE_IOM_RBCH                         ((volatile u32*)(DANUBE_IOM+ 0x009C))
+#define DANUBE_IOM_RBCH_OV                              (1 << 4)
+#define DANUBE_IOM_RBCH_RBC11                          (1 << 3)
+#define DANUBE_IOM_RBCH_RBC10                          (1 << 2)
+#define DANUBE_IOM_RBCH_RBC9                            (1 << 1)
+#define DANUBE_IOM_RBCH_RBC8                            (1 << 0)
+
+/***TEI1 Register 1***/
+#define DANUBE_IOM_TEI1                         ((volatile u32*)(DANUBE_IOM+ 0x009C))
+#define DANUBE_IOM_TEI1_TEI1 (value)               (((( 1 << 7) - 1) & (value)) << 1)
+#define DANUBE_IOM_TEI1_EA                              (1 << 0)
+
+/***Receive Status Register***/
+#define DANUBE_IOM_RSTA                         ((volatile u32*)(DANUBE_IOM+ 0x00A0))
+#define DANUBE_IOM_RSTA_VFR                              (1 << 7)
+#define DANUBE_IOM_RSTA_RDO                              (1 << 6)
+#define DANUBE_IOM_RSTA_CRC                              (1 << 5)
+#define DANUBE_IOM_RSTA_RAB                              (1 << 4)
+#define DANUBE_IOM_RSTA_SA1                              (1 << 3)
+#define DANUBE_IOM_RSTA_SA0                              (1 << 2)
+#define DANUBE_IOM_RSTA_TA                              (1 << 0)
+#define DANUBE_IOM_RSTA_CR                              (1 << 1)
+
+/***TEI2 Register***/
+#define DANUBE_IOM_TEI2                         ((volatile u32*)(DANUBE_IOM+ 0x00A0))
+#define DANUBE_IOM_TEI2_TEI2 (value)               (((( 1 << 7) - 1) & (value)) << 1)
+#define DANUBE_IOM_TEI2_EA                              (1 << 0)
+
+/***Test Mode Register HDLC***/
+#define DANUBE_IOM_TMH                          ((volatile u32*)(DANUBE_IOM+ 0x00A4))
+#define DANUBE_IOM_TMH_TLP                              (1 << 0)
+
+/***Command/Indication Receive 0***/
+#define DANUBE_IOM_CIR0                         ((volatile u32*)(DANUBE_IOM+ 0x00B8))
+#define DANUBE_IOM_CIR0_CODR0 (value)              (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_IOM_CIR0_CIC0                            (1 << 3)
+#define DANUBE_IOM_CIR0_CIC1                            (1 << 2)
+#define DANUBE_IOM_CIR0_SG                              (1 << 1)
+#define DANUBE_IOM_CIR0_BAS                              (1 << 0)
+
+/***Command/Indication Transmit 0***/
+#define DANUBE_IOM_CIX0                         ((volatile u32*)(DANUBE_IOM+ 0x00B8))
+#define DANUBE_IOM_CIX0_CODX0 (value)              (((( 1 << 4) - 1) & (value)) << 4)
+#define DANUBE_IOM_CIX0_TBA2                            (1 << 3)
+#define DANUBE_IOM_CIX0_TBA1                            (1 << 2)
+#define DANUBE_IOM_CIX0_TBA0                            (1 << 1)
+#define DANUBE_IOM_CIX0_BAC                              (1 << 0)
+
+/***Command/Indication Receive 1***/
+#define DANUBE_IOM_CIR1                         ((volatile u32*)(DANUBE_IOM+ 0x00BC))
+#define DANUBE_IOM_CIR1_CODR1 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+
+/***Command/Indication Transmit 1***/
+#define DANUBE_IOM_CIX1                         ((volatile u32*)(DANUBE_IOM+ 0x00BC))
+#define DANUBE_IOM_CIX1_CODX1 (value)              (((( 1 << 6) - 1) & (value)) << 2)
+#define DANUBE_IOM_CIX1_CICW                            (1 << 1)
+#define DANUBE_IOM_CIX1_CI1E                            (1 << 0)
+
+/***Controller Data Access Reg. (CH10)***/
+#define DANUBE_IOM_CDA10                        ((volatile u32*)(DANUBE_IOM+ 0x0100))
+#define DANUBE_IOM_CDA10_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Controller Data Access Reg. (CH11)***/
+#define DANUBE_IOM_CDA11                        ((volatile u32*)(DANUBE_IOM+ 0x0104))
+#define DANUBE_IOM_CDA11_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Controller Data Access Reg. (CH20)***/
+#define DANUBE_IOM_CDA20                        ((volatile u32*)(DANUBE_IOM+ 0x0108))
+#define DANUBE_IOM_CDA20_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Controller Data Access Reg. (CH21)***/
+#define DANUBE_IOM_CDA21                        ((volatile u32*)(DANUBE_IOM+ 0x010C))
+#define DANUBE_IOM_CDA21_CDA (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH10)***/
+#define DANUBE_IOM_CDA_TSDP10                   ((volatile u32*)(DANUBE_IOM+ 0x0110))
+#define DANUBE_IOM_CDA_TSDP10_DPS                              (1 << 7)
+#define DANUBE_IOM_CDA_TSDP10_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH11)***/
+#define DANUBE_IOM_CDA_TSDP11                   ((volatile u32*)(DANUBE_IOM+ 0x0114))
+#define DANUBE_IOM_CDA_TSDP11_DPS                              (1 << 7)
+#define DANUBE_IOM_CDA_TSDP11_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH20)***/
+#define DANUBE_IOM_CDA_TSDP20                   ((volatile u32*)(DANUBE_IOM+ 0x0118))
+#define DANUBE_IOM_CDA_TSDP20_DPS                              (1 << 7)
+#define DANUBE_IOM_CDA_TSDP20_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH21)***/
+#define DANUBE_IOM_CDA_TSDP21                   ((volatile u32*)(DANUBE_IOM+ 0x011C))
+#define DANUBE_IOM_CDA_TSDP21_DPS                              (1 << 7)
+#define DANUBE_IOM_CDA_TSDP21_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH10)***/
+#define DANUBE_IOM_CO_TSDP10                    ((volatile u32*)(DANUBE_IOM+ 0x0120))
+#define DANUBE_IOM_CO_TSDP10_DPS                              (1 << 7)
+#define DANUBE_IOM_CO_TSDP10_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH11)***/
+#define DANUBE_IOM_CO_TSDP11                    ((volatile u32*)(DANUBE_IOM+ 0x0124))
+#define DANUBE_IOM_CO_TSDP11_DPS                              (1 << 7)
+#define DANUBE_IOM_CO_TSDP11_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH20)***/
+#define DANUBE_IOM_CO_TSDP20                    ((volatile u32*)(DANUBE_IOM+ 0x0128))
+#define DANUBE_IOM_CO_TSDP20_DPS                              (1 << 7)
+#define DANUBE_IOM_CO_TSDP20_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Time Slot and Data Port Sel. (CH21)***/
+#define DANUBE_IOM_CO_TSDP21                    ((volatile u32*)(DANUBE_IOM+ 0x012C))
+#define DANUBE_IOM_CO_TSDP21_DPS                              (1 << 7)
+#define DANUBE_IOM_CO_TSDP21_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Ctrl. Reg. Contr. Data Access CH1x***/
+#define DANUBE_IOM_CDA1_CR                      ((volatile u32*)(DANUBE_IOM+ 0x0138))
+#define DANUBE_IOM_CDA1_CR_EN_TBM                        (1 << 5)
+#define DANUBE_IOM_CDA1_CR_EN_I1                          (1 << 4)
+#define DANUBE_IOM_CDA1_CR_EN_I0                          (1 << 3)
+#define DANUBE_IOM_CDA1_CR_EN_O1                          (1 << 2)
+#define DANUBE_IOM_CDA1_CR_EN_O0                          (1 << 1)
+#define DANUBE_IOM_CDA1_CR_SWAP                            (1 << 0)
+
+/***Ctrl. Reg. Contr. Data Access CH1x***/
+#define DANUBE_IOM_CDA2_CR                      ((volatile u32*)(DANUBE_IOM+ 0x013C))
+#define DANUBE_IOM_CDA2_CR_EN_TBM                        (1 << 5)
+#define DANUBE_IOM_CDA2_CR_EN_I1                          (1 << 4)
+#define DANUBE_IOM_CDA2_CR_EN_I0                          (1 << 3)
+#define DANUBE_IOM_CDA2_CR_EN_O1                          (1 << 2)
+#define DANUBE_IOM_CDA2_CR_EN_O0                          (1 << 1)
+#define DANUBE_IOM_CDA2_CR_SWAP                            (1 << 0)
+
+/***Control Register B-Channel Data***/
+#define DANUBE_IOM_BCHA_CR                      ((volatile u32*)(DANUBE_IOM+ 0x0144))
+#define DANUBE_IOM_BCHA_CR_EN_BC2                        (1 << 4)
+#define DANUBE_IOM_BCHA_CR_EN_BC1                        (1 << 3)
+
+/***Control Register B-Channel Data***/
+#define DANUBE_IOM_BCHB_CR                      ((volatile u32*)(DANUBE_IOM+ 0x0148))
+#define DANUBE_IOM_BCHB_CR_EN_BC2                        (1 << 4)
+#define DANUBE_IOM_BCHB_CR_EN_BC1                        (1 << 3)
+
+/***Control Reg. for HDLC and CI1 Data***/
+#define DANUBE_IOM_DCI_CR                       ((volatile u32*)(DANUBE_IOM+ 0x014C))
+#define DANUBE_IOM_DCI_CR_DPS_CI1                      (1 << 7)
+#define DANUBE_IOM_DCI_CR_EN_CI1                        (1 << 6)
+#define DANUBE_IOM_DCI_CR_EN_D                            (1 << 5)
+
+/***Control Reg. for HDLC and CI1 Data***/
+#define DANUBE_IOM_DCIC_CR                      ((volatile u32*)(DANUBE_IOM+ 0x014C))
+#define DANUBE_IOM_DCIC_CR_DPS_CI0                      (1 << 7)
+#define DANUBE_IOM_DCIC_CR_EN_CI0                        (1 << 6)
+#define DANUBE_IOM_DCIC_CR_DPS_D                          (1 << 5)
+
+/***Control Reg. Serial Data Strobe x***/
+#define DANUBE_IOM_SDS_CR                       ((volatile u32*)(DANUBE_IOM+ 0x0154))
+#define DANUBE_IOM_SDS_CR_ENS_TSS                      (1 << 7)
+#define DANUBE_IOM_SDS_CR_ENS_TSS_1                  (1 << 6)
+#define DANUBE_IOM_SDS_CR_ENS_TSS_3                  (1 << 5)
+#define DANUBE_IOM_SDS_CR_TSS (value)                (((( 1 << 4) - 1) & (value)) << 0)
+
+/***Control Register IOM Data***/
+#define DANUBE_IOM_IOM_CR                       ((volatile u32*)(DANUBE_IOM+ 0x015C))
+#define DANUBE_IOM_IOM_CR_SPU                              (1 << 7)
+#define DANUBE_IOM_IOM_CR_CI_CS                          (1 << 5)
+#define DANUBE_IOM_IOM_CR_TIC_DIS                      (1 << 4)
+#define DANUBE_IOM_IOM_CR_EN_BCL                        (1 << 3)
+#define DANUBE_IOM_IOM_CR_CLKM                            (1 << 2)
+#define DANUBE_IOM_IOM_CR_Res                              (1 << 1)
+#define DANUBE_IOM_IOM_CR_DIS_IOM                      (1 << 0)
+
+/***Synchronous Transfer Interrupt***/
+#define DANUBE_IOM_STI                          ((volatile u32*)(DANUBE_IOM+ 0x0160))
+#define DANUBE_IOM_STI_STOV21                        (1 << 7)
+#define DANUBE_IOM_STI_STOV20                        (1 << 6)
+#define DANUBE_IOM_STI_STOV11                        (1 << 5)
+#define DANUBE_IOM_STI_STOV10                        (1 << 4)
+#define DANUBE_IOM_STI_STI21                          (1 << 3)
+#define DANUBE_IOM_STI_STI20                          (1 << 2)
+#define DANUBE_IOM_STI_STI11                          (1 << 1)
+#define DANUBE_IOM_STI_STI10                          (1 << 0)
+
+/***Acknowledge Synchronous Transfer Interrupt***/
+#define DANUBE_IOM_ASTI                         ((volatile u32*)(DANUBE_IOM+ 0x0160))
+#define DANUBE_IOM_ASTI_ACK21                          (1 << 3)
+#define DANUBE_IOM_ASTI_ACK20                          (1 << 2)
+#define DANUBE_IOM_ASTI_ACK11                          (1 << 1)
+#define DANUBE_IOM_ASTI_ACK10                          (1 << 0)
+
+/***Mask Synchronous Transfer Interrupt***/
+#define DANUBE_IOM_MSTI                         ((volatile u32*)(DANUBE_IOM+ 0x0164))
+#define DANUBE_IOM_MSTI_STOV21                        (1 << 7)
+#define DANUBE_IOM_MSTI_STOV20                        (1 << 6)
+#define DANUBE_IOM_MSTI_STOV11                        (1 << 5)
+#define DANUBE_IOM_MSTI_STOV10                        (1 << 4)
+#define DANUBE_IOM_MSTI_STI21                          (1 << 3)
+#define DANUBE_IOM_MSTI_STI20                          (1 << 2)
+#define DANUBE_IOM_MSTI_STI11                          (1 << 1)
+#define DANUBE_IOM_MSTI_STI10                          (1 << 0)
+
+/***Configuration Register for Serial Data Strobes***/
+#define DANUBE_IOM_SDS_CONF                    ((volatile u32*)(DANUBE_IOM+ 0x0168))
+#define DANUBE_IOM_SDS_CONF_SDS_BCL                      (1 << 0)
+
+/***Monitoring CDA Bits***/
+#define DANUBE_IOM_MCDA                         ((volatile u32*)(DANUBE_IOM+ 0x016C))
+#define DANUBE_IOM_MCDA_MCDA21 (value)             (((( 1 << 2) - 1) & (value)) << 6)
+#define DANUBE_IOM_MCDA_MCDA20 (value)             (((( 1 << 2) - 1) & (value)) << 4)
+#define DANUBE_IOM_MCDA_MCDA11 (value)             (((( 1 << 2) - 1) & (value)) << 2)
+#define DANUBE_IOM_MCDA_MCDA10 (value)             (((( 1 << 2) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  ASC0 register address and bits                      */
+/***********************************************************************/
+#define DANUBE_ASC0                          (KSEG1+0x1E100400)
+/***********************************************************************/
+#define DANUBE_ASC0_TBUF                        ((volatile u32*)(DANUBE_ASC0 + 0x0020))
+#define DANUBE_ASC0_RBUF                        ((volatile u32*)(DANUBE_ASC0 + 0x0024))
+#define DANUBE_ASC0_FSTAT                       ((volatile u32*)(DANUBE_ASC0 + 0x0048))
+#define DANUBE_ASC0_FSTAT_TXFREE_GET(value)     (((value) >> 24) & ((1 << 6) - 1))
+#define DANUBE_ASC0_FSTAT_TXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 24)
+#define DANUBE_ASC0_FSTAT_RXFREE_GET(value)     (((value) >> 16) & ((1 << 6) - 1))
+#define DANUBE_ASC0_FSTAT_RXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 16)
+#define DANUBE_ASC0_FSTAT_TXFFL_GET(value)      (((value) >> 8) & ((1 << 6) - 1))
+#define DANUBE_ASC0_FSTAT_TXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 8)
+#define DANUBE_ASC0_FSTAT_RXFFL_GET(value)      (((value) >> 0) & ((1 << 6) - 1))
+#define DANUBE_ASC0_FSTAT_RXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 0)
+
+
+/***********************************************************************/
+/*  Module      :  ASC1 register address and bits                      */
+/***********************************************************************/
+
+#define DANUBE_ASC1                          (KSEG1+0x1E100C00)
+	/***********************************************************************/
+
+#define DANUBE_ASC1_TBUF                        ((volatile u32*)(DANUBE_ASC1 + 0x0020))
+#define DANUBE_ASC1_RBUF                        ((volatile u32*)(DANUBE_ASC1 + 0x0024))
+#define DANUBE_ASC1_FSTAT                       ((volatile u32*)(DANUBE_ASC1 + 0x0048))
+#define DANUBE_ASC1_FSTAT_TXFREE_GET(value)     (((value) >> 24) & ((1 << 6) - 1))
+#define DANUBE_ASC1_FSTAT_TXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 24)
+#define DANUBE_ASC1_FSTAT_RXFREE_GET(value)     (((value) >> 16) & ((1 << 6) - 1))
+#define DANUBE_ASC1_FSTAT_RXFREE_SET(value)     (((( 1 << 6) - 1) & (value)) << 16)
+#define DANUBE_ASC1_FSTAT_TXFFL_GET(value)      (((value) >> 8) & ((1 << 6) - 1))
+#define DANUBE_ASC1_FSTAT_TXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 8)
+#define DANUBE_ASC1_FSTAT_RXFFL_GET(value)      (((value) >> 0) & ((1 << 6) - 1))
+#define DANUBE_ASC1_FSTAT_RXFFL_SET(value)      (((( 1 << 6) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  DMA register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_DMA                          (0xBE104100)
+/***********************************************************************/
+
+#define DANUBE_DMA_BASE                 DANUBE_DMA
+#define DANUBE_DMA_CLC                  (volatile u32*)DANUBE_DMA_BASE
+#define DANUBE_DMA_ID                   (volatile u32*)(DANUBE_DMA_BASE+0x08)
+#define DANUBE_DMA_CTRL                 (volatile u32*)(DANUBE_DMA_BASE+0x10)
+#define DANUBE_DMA_CPOLL                (volatile u32*)(DANUBE_DMA_BASE+0x14)
+#define DANUBE_DMA_CS                   (volatile u32*)(DANUBE_DMA_BASE+0x18)
+#define DANUBE_DMA_CCTRL                (volatile u32*)(DANUBE_DMA_BASE+0x1C)
+#define DANUBE_DMA_CDBA                 (volatile u32*)(DANUBE_DMA_BASE+0x20)
+#define DANUBE_DMA_CDLEN                (volatile u32*)(DANUBE_DMA_BASE+0x24)
+#define DANUBE_DMA_CIS                  (volatile u32*)(DANUBE_DMA_BASE+0x28)
+#define DANUBE_DMA_CIE                  (volatile u32*)(DANUBE_DMA_BASE+0x2C)
+
+#define DANUBE_DMA_PS                   (volatile u32*)(DANUBE_DMA_BASE+0x40)
+#define DANUBE_DMA_PCTRL                (volatile u32*)(DANUBE_DMA_BASE+0x44)
+
+#define DANUBE_DMA_IRNEN                (volatile u32*)(DANUBE_DMA_BASE+0xf4)
+#define DANUBE_DMA_IRNCR                (volatile u32*)(DANUBE_DMA_BASE+0xf8)
+#define DANUBE_DMA_IRNICR               (volatile u32*)(DANUBE_DMA_BASE+0xfc)
+/***********************************************************************/
+/*  Module      :  Debug register address and bits                     */
+/***********************************************************************/
+
+#define DANUBE_Debug                        (0xBF106000)
+/***********************************************************************/
+
+
+/***MCD Break Bus Switch Register***/
+#define DANUBE_Debug_MCD_BBS                      ((volatile u32*)(DANUBE_Debug+ 0x0000))
+#define DANUBE_Debug_MCD_BBS_BTP1                            (1 << 19)
+#define DANUBE_Debug_MCD_BBS_BTP0                            (1 << 18)
+#define DANUBE_Debug_MCD_BBS_BSP1                            (1 << 17)
+#define DANUBE_Debug_MCD_BBS_BSP0                            (1 << 16)
+#define DANUBE_Debug_MCD_BBS_BT5EN                          (1 << 15)
+#define DANUBE_Debug_MCD_BBS_BT4EN                          (1 << 14)
+#define DANUBE_Debug_MCD_BBS_BT5                              (1 << 13)
+#define DANUBE_Debug_MCD_BBS_BT4                              (1 << 12)
+#define DANUBE_Debug_MCD_BBS_BS5EN                          (1 << 7)
+#define DANUBE_Debug_MCD_BBS_BS4EN                          (1 << 6)
+#define DANUBE_Debug_MCD_BBS_BS5                              (1 << 5)
+#define DANUBE_Debug_MCD_BBS_BS4                              (1 << 4)
+
+/***MCD Multiplexer Control Register***/
+#define DANUBE_Debug_MCD_MCR                      ((volatile u32*)(DANUBE_Debug+ 0x0008))
+#define DANUBE_Debug_MCD_MCR_MUX5                            (1 << 4)
+#define DANUBE_Debug_MCD_MCR_MUX4                            (1 << 3)
+#define DANUBE_Debug_MCD_MCR_MUX1                            (1 << 0)
+
+
+/***********************************************************************/
+/*  Module      :  SRAM register address and bits                      */
+/***********************************************************************/
+
+#define DANUBE_SRAM                         (0xBF980000)
+/***********************************************************************/
+
+
+/***SRAM Size Register***/
+#define DANUBE_SRAM_SRAM_SIZE                    ((volatile u32*)(DANUBE_SRAM+ 0x0800))
+#define DANUBE_SRAM_SRAM_SIZE_SIZE (value)               (((( 1 << 23) - 1) & (value)) << 0)
+
+/***********************************************************************/
+/*  Module      :  BIU register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_BIU                          (0xBFA80000)
+/***********************************************************************/
+
+
+/***BIU Identification Register***/
+#define DANUBE_BIU_BIU_ID                       ((volatile u32*)(DANUBE_BIU+ 0x0000))
+#define DANUBE_BIU_BIU_ID_ARCH                            (1 << 16)
+#define DANUBE_BIU_BIU_ID_ID (value)                (((( 1 << 8) - 1) & (value)) << 8)
+#define DANUBE_BIU_BIU_ID_REV (value)                (((( 1 << 8) - 1) & (value)) << 0)
+
+/***BIU Access Error Cause Register***/
+#define DANUBE_BIU_BIU_ERRCAUSE                 ((volatile u32*)(DANUBE_BIU+ 0x0100))
+#define DANUBE_BIU_BIU_ERRCAUSE_ERR                              (1 << 31)
+#define DANUBE_BIU_BIU_ERRCAUSE_PORT (value)               (((( 1 << 4) - 1) & (value)) << 16)
+#define DANUBE_BIU_BIU_ERRCAUSE_CAUSE (value)              (((( 1 << 2) - 1) & (value)) << 0)
+
+/***BIU Access Error Address Register***/
+#define DANUBE_BIU_BIU_ERRADDR                  ((volatile u32*)(DANUBE_BIU+ 0x0108))
+#define DANUBE_BIU_BIU_ERRADDR_ADDR
+
+
+/***********************************************************************/
+/*  Module      :  ICU register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_ICU                          (0xBF880200)
+#define DANUBE_ICU                          (0xBF880200)
+#define DANUBE_ICU_EXI                      (0xBF101000)
+/***********************************************************************/
+
+
+/***IM0 Interrupt Status Register***/
+#define DANUBE_ICU_IM0_ISR                      ((volatile u32*)(DANUBE_ICU+ 0x0000))
+#define DANUBE_ICU_IM0_ISR_IR(value)               (1 << (value))
+
+
+/***IM1 Interrupt Status Register***/
+#define DANUBE_ICU_IM1_ISR                      ((volatile u32*)(DANUBE_ICU+ 0x0020))
+#define DANUBE_ICU_IM1_ISR_IR(value)               (1 << (value))
+
+
+/***IM2 Interrupt Status Register***/
+#define DANUBE_ICU_IM2_ISR                      ((volatile u32*)(DANUBE_ICU+ 0x0040))
+#define DANUBE_ICU_IM2_ISR_IR(value)               (1 << (value))
+
+/***IM3 Interrupt Status Register***/
+#define DANUBE_ICU_IM3_ISR                      ((volatile u32*)(DANUBE_ICU+ 0x0060))
+#define DANUBE_ICU_IM3_ISR_IR(value)               (1 << (value))
+
+/***IM4 Interrupt Status Register***/
+#define DANUBE_ICU_IM4_ISR                      ((volatile u32*)(DANUBE_ICU+ 0x0080))
+#define DANUBE_ICU_IM4_ISR_IR(value)               (1 << (value))
+
+
+/***IM0 Interrupt Enable Register***/
+#define DANUBE_ICU_IM0_IER                      ((volatile u32*)(DANUBE_ICU+ 0x0008))
+#define DANUBE_ICU_IM0_IER_IR(value)               (1 << (value))
+
+
+/***IM1 Interrupt Enable Register***/
+#define DANUBE_ICU_IM1_IER                      ((volatile u32*)(DANUBE_ICU+ 0x0028))
+#define DANUBE_ICU_IM1_IER_IR(value)               (1 << (value))
+
+
+/***IM2 Interrupt Enable Register***/
+#define DANUBE_ICU_IM2_IER                      ((volatile u32*)(DANUBE_ICU+ 0x0048))
+#define DANUBE_ICU_IM2_IER_IR(value)               (1 << (value)8
+
+/***IM3 Interrupt Enable Register***/
+#define DANUBE_ICU_IM3_IER                      ((volatile u32*)(DANUBE_ICU+ 0x0068))
+#define DANUBE_ICU_IM3_IER_IR(value)               (1 << (value))
+
+/***IM4 Interrupt Enable Register***/
+#define DANUBE_ICU_IM4_IER                      ((volatile u32*)(DANUBE_ICU+ 0x0088))
+#define DANUBE_ICU_IM4_IER_IR(value)               (1 << (value))
+
+
+/***IM0 Interrupt Output Status Register***/
+#define DANUBE_ICU_IM0_IOSR                    ((volatile u32*)(DANUBE_ICU+ 0x0010))
+#define DANUBE_ICU_IM0_IOSR_IR(value)               (1 << (value))
+
+
+/***IM1 Interrupt Output Status Register***/
+#define DANUBE_ICU_IM1_IOSR                    ((volatile u32*)(DANUBE_ICU+ 0x0030))
+#define DANUBE_ICU_IM1_IOSR_IR(value)               (1 << (value))
+
+
+/***IM2 Interrupt Output Status Register***/
+#define DANUBE_ICU_IM2_IOSR                    ((volatile u32*)(DANUBE_ICU+ 0x0050))
+#define DANUBE_ICU_IM2_IOSR_IR(value)               (1 << (value))
+
+/***IM3 Interrupt Output Status Register***/
+#define DANUBE_ICU_IM3_IOSR                    ((volatile u32*)(DANUBE_ICU+ 0x0070))
+#define DANUBE_ICU_IM3_IOSR_IR(value)               (1 << (value))
+
+/***IM4 Interrupt Output Status Register***/
+#define DANUBE_ICU_IM4_IOSR                    ((volatile u32*)(DANUBE_ICU+ 0x0090))
+#define DANUBE_ICU_IM4_IOSR_IR(value)               (1 << (value))
+
+
+/***IM0 Interrupt Request Set Register***/
+#define DANUBE_ICU_IM0_IRSR                    ((volatile u32*)(DANUBE_ICU+ 0x0018))
+#define DANUBE_ICU_IM0_IRSR_IR(value)               (1 << (value))
+
+
+/***IM1 Interrupt Request Set Register***/
+#define DANUBE_ICU_IM1_IRSR                    ((volatile u32*)(DANUBE_ICU+ 0x0038))
+#define DANUBE_ICU_IM1_IRSR_IR(value)               (1 << (value))
+
+
+/***IM2 Interrupt Request Set Register***/
+#define DANUBE_ICU_IM2_IRSR                    ((volatile u32*)(DANUBE_ICU+ 0x0058))
+#define DANUBE_ICU_IM2_IRSR_IR(value)               (1 << (value))
+
+/***IM3 Interrupt Request Set Register***/
+#define DANUBE_ICU_IM3_IRSR                    ((volatile u32*)(DANUBE_ICU+ 0x0078))
+#define DANUBE_ICU_IM3_IRSR_IR(value)               (1 << (value))
+
+/***IM4 Interrupt Request Set Register***/
+#define DANUBE_ICU_IM4_IRSR                    ((volatile u32*)(DANUBE_ICU+ 0x0098))
+#define DANUBE_ICU_IM4_IRSR_IR(value)               (1 << (value))
+
+/***Interrupt Vector Value Register***/
+#define DANUBE_ICU_IM_VEC                      ((volatile u32*)(DANUBE_ICU+ 0x0060))
+
+/***Interrupt Vector Value Mask***/
+#define DANUBE_ICU_IM0_VEC_MASK                0x0000001f
+#define DANUBE_ICU_IM1_VEC_MASK                0x000003e0
+#define DANUBE_ICU_IM2_VEC_MASK                0x00007c00
+#define DANUBE_ICU_IM3_VEC_MASK                0x000f8000
+#define DANUBE_ICU_IM4_VEC_MASK                0x01f00000
+
+/***DMA Interrupt Mask Value***/
+#define DANUBE_DMA_H_MASK			0x00000fff
+
+/***External Interrupt Control Register***/
+#define DANUBE_ICU_EXTINTCR                ((volatile u32*)(DANUBE_ICU_EXI+ 0x0000))
+#define DANUBE_ICU_IRNICR                  ((volatile u32*)(DANUBE_ICU_EXI+ 0x0004))
+#define DANUBE_ICU_IRNCR                   ((volatile u32*)(DANUBE_ICU_EXI+ 0x0008))
+#define DANUBE_ICU_IRNEN                   ((volatile u32*)(DANUBE_ICU_EXI+ 0x000c))
+#define DANUBE_ICU_NMI_CR                   ((volatile u32*)(DANUBE_ICU_EXI+ 0x00f0))
+#define DANUBE_ICU_NMI_SR                   ((volatile u32*)(DANUBE_ICU_EXI+ 0x00f4))
+
+/***********************************************************************/
+/*  Module      :  MPS register address and bits                       */
+/***********************************************************************/
+
+#define DANUBE_MPS                          (KSEG1+0x1F107000)
+/***********************************************************************/
+
+#define DANUBE_MPS_CHIPID                       ((volatile u32*)(DANUBE_MPS + 0x0344))
+#define DANUBE_MPS_CHIPID_VERSION_GET(value)    (((value) >> 28) & ((1 << 4) - 1))
+#define DANUBE_MPS_CHIPID_VERSION_SET(value)    (((( 1 << 4) - 1) & (value)) << 28)
+#define DANUBE_MPS_CHIPID_PARTNUM_GET(value)    (((value) >> 12) & ((1 << 16) - 1))
+#define DANUBE_MPS_CHIPID_PARTNUM_SET(value)    (((( 1 << 16) - 1) & (value)) << 12)
+#define DANUBE_MPS_CHIPID_MANID_GET(value)      (((value) >> 1) & ((1 << 10) - 1))
+#define DANUBE_MPS_CHIPID_MANID_SET(value)      (((( 1 << 10) - 1) & (value)) << 1)
+
+
+/* voice channel 0 ... 3 interrupt enable register */
+#define DANUBE_MPS_VC0ENR ((volatile u32*)(DANUBE_MPS + 0x0000))
+#define DANUBE_MPS_VC1ENR ((volatile u32*)(DANUBE_MPS + 0x0004))
+#define DANUBE_MPS_VC2ENR ((volatile u32*)(DANUBE_MPS + 0x0008))
+#define DANUBE_MPS_VC3ENR ((volatile u32*)(DANUBE_MPS + 0x000C))
+/* voice channel 0 ... 3 interrupt status read register */
+#define DANUBE_MPS_RVC0SR ((volatile u32*)(DANUBE_MPS + 0x0010))
+#define DANUBE_MPS_RVC1SR ((volatile u32*)(DANUBE_MPS + 0x0014))
+#define DANUBE_MPS_RVC2SR ((volatile u32*)(DANUBE_MPS + 0x0018))
+#define DANUBE_MPS_RVC3SR ((volatile u32*)(DANUBE_MPS + 0x001C))
+/* voice channel 0 ... 3 interrupt status set register */
+#define DANUBE_MPS_SVC0SR ((volatile u32*)(DANUBE_MPS + 0x0020))
+#define DANUBE_MPS_SVC1SR ((volatile u32*)(DANUBE_MPS + 0x0024))
+#define DANUBE_MPS_SVC2SR ((volatile u32*)(DANUBE_MPS + 0x0028))
+#define DANUBE_MPS_SVC3SR ((volatile u32*)(DANUBE_MPS + 0x002C))
+/* voice channel 0 ... 3 interrupt status clear register */
+#define DANUBE_MPS_CVC0SR ((volatile u32*)(DANUBE_MPS + 0x0030))
+#define DANUBE_MPS_CVC1SR ((volatile u32*)(DANUBE_MPS + 0x0034))
+#define DANUBE_MPS_CVC2SR ((volatile u32*)(DANUBE_MPS + 0x0038))
+#define DANUBE_MPS_CVC3SR ((volatile u32*)(DANUBE_MPS + 0x003C))
+/* common status 0 and 1 read register */
+#define DANUBE_MPS_RAD0SR ((volatile u32*)(DANUBE_MPS + 0x0040))
+#define DANUBE_MPS_RAD1SR ((volatile u32*)(DANUBE_MPS + 0x0044))
+/* common status 0 and 1 set register */
+#define DANUBE_MPS_SAD0SR ((volatile u32*)(DANUBE_MPS + 0x0048))
+#define DANUBE_MPS_SAD1SR ((volatile u32*)(DANUBE_MPS + 0x004C))
+/* common status 0 and 1 clear register */
+#define DANUBE_MPS_CAD0SR ((volatile u32*)(DANUBE_MPS + 0x0050))
+#define DANUBE_MPS_CAD1SR ((volatile u32*)(DANUBE_MPS + 0x0054))
+/* common status 0 and 1 enable register */
+#define DANUBE_MPS_AD0ENR ((volatile u32*)(DANUBE_MPS + 0x0058))
+#define DANUBE_MPS_AD1ENR ((volatile u32*)(DANUBE_MPS + 0x005C))
+/* notification enable register */
+#define DANUBE_MPS_CPU0_NFER ((volatile u32*)(DANUBE_MPS + 0x0060))
+#define DANUBE_MPS_CPU1_NFER ((volatile u32*)(DANUBE_MPS + 0x0064))
+/* CPU to CPU interrup request register */
+#define DANUBE_MPS_CPU0_2_CPU1_IRR ((volatile u32*)(DANUBE_MPS + 0x0070))
+#define DANUBE_MPS_CPU0_2_CPU1_IER ((volatile u32*)(DANUBE_MPS + 0x0074))
+/* Global interrupt request and request enable register */
+#define DANUBE_MPS_GIRR ((volatile u32*)(DANUBE_MPS + 0x0078))
+#define DANUBE_MPS_GIER ((volatile u32*)(DANUBE_MPS + 0x007C))
+
+
+#define DANUBE_MPS_CPU0_SMP0 ((volatile u32*)(DANUBE_MPS + 0x00100))
+
+#define DANUBE_MPS_CPU1_SMP0 ((volatile u32*)(DANUBE_MPS + 0x00200))
+
+/************************************************************************/
+/*   Module       :   DEU register address and bits        		*/
+/************************************************************************/
+#define DANUBE_DEU_BASE_ADDR               (0xBE102000)
+/*   DEU Control Register */
+#define DANUBE_DEU_CLK                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0000))
+#define DANUBE_DEU_ID                      ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0008))
+
+/*   DEU control register */
+#define DANUBE_DEU_CON                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0010))
+#define DANUBE_DEU_IHR                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0014))
+#define DANUBE_DEU_ILR                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0018))
+#define DANUBE_DEU_K1HR                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x001C))
+#define DANUBE_DEU_K1LR                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0020))
+#define DANUBE_DEU_K3HR                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0024))
+#define DANUBE_DEU_K3LR                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0028))
+#define DANUBE_DEU_IVHR                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x002C))
+#define DANUBE_DEU_IVLR                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0030))
+#define DANUBE_DEU_OHR                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0040))
+#define DANUBE_DEU_OLR                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0050))
+
+/* AES DEU register */
+#define DANUBE_AES_CON 			   ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0050))
+#define DANUBE_AES_ID3R                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0054))
+#define DANUBE_AES_ID2R                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0058))
+#define DANUBE_AES_ID1R                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x005C))
+#define DANUBE_AES_ID0R                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0060))
+
+/* AES Key register */
+#define DANUBE_AES_K7R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0064))
+#define DANUBE_AES_K6R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0068))
+#define DANUBE_AES_K5R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x006C))
+#define DANUBE_AES_K4R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0070))
+#define DANUBE_AES_K3R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0074))
+#define DANUBE_AES_K2R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0078))
+#define DANUBE_AES_K1R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x007C))
+#define DANUBE_AES_K0R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0080))
+
+/* AES vector register */
+#define DANUBE_AES_IV3R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0084))
+#define DANUBE_AES_IV2R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0088))
+#define DANUBE_AES_IV1R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x008C))
+#define DANUBE_AES_IV0R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0090))
+#define DANUBE_AES_0D3R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0094))
+#define DANUBE_AES_0D2R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x0098))
+#define DANUBE_AES_OD1R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x009C))
+#define DANUBE_AES_OD0R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00A0))
+
+/* hash control registe */
+#define DANUBE_HASH_CON                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00B0))
+#define DANUBE_HASH_MR                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00B4))
+#define DANUBE_HASH_D1R                    ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00B8 ))
+#define DANUBE_HASH_D2R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00BC ))
+#define DANUBE_HASH_D3R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00C0 ))
+#define DANUBE_HASH_D4R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00C4))
+#define DANUBE_HASH_D5R                     ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00C8))
+
+#define DANUBE_CON                         ((volatile u32 *)(DANUBE_DEU_BASE_ADDR + 0x00EC))
+
+
+
+
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define DANUBE_PPE_BASE_ADDR                (KSEG1 + 0x1E180000)
+#define DANUBE_PPE_PP32_DEBUG_REG_ADDR(x)          ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x0000) << 2)))
+#define DANUBE_PPE_PPM_INT_REG_ADDR(x)             ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x0030) << 2)))
+#define DANUBE_PPE_PP32_INTERNAL_RES_ADDR(x)       ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x0040) << 2)))
+#define DANUBE_PPE_PPE_CLOCK_CONTROL_ADDR(x)       ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x0100) << 2)))
+#define DANUBE_PPE_CDM_CODE_MEMORY_RAM0_ADDR(x)    ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x1000) << 2)))
+#define DANUBE_PPE_CDM_CODE_MEMORY_RAM1_ADDR(x)    ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x2000) << 2)))
+#define DANUBE_PPE_REG_ADDR(x)                     ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x4000) << 2)))
+#define DANUBE_PPE_PP32_DATA_MEMORY_RAM1_ADDR(x)   ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x5000) << 2)))
+#define DANUBE_PPE_PPM_INT_UNIT_ADDR(x)            ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x6000) << 2)))
+#define DANUBE_PPE_PPM_TIMER0_ADDR(x)              ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x6100) << 2)))
+#define DANUBE_PPE_PPM_TASK_IND_REG_ADDR(x)        ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x6200) << 2)))
+#define DANUBE_PPE_PPS_BRK_ADDR(x)                 ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x6300) << 2)))
+#define DANUBE_PPE_PPM_TIMER1_ADDR(x)              ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x6400) << 2)))
+#define DANUBE_PPE_SB_RAM0_ADDR(x)                 ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x8000) << 2)))
+#define DANUBE_PPE_SB_RAM1_ADDR(x)                 ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x8400) << 2)))
+#define DANUBE_PPE_SB_RAM2_ADDR(x)                 ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x8C00) << 2)))
+#define DANUBE_PPE_SB_RAM3_ADDR(x)                 ((volatile u32*)(DANUBE_PPE_BASE_ADDR + (((x) + 0x9600) << 2)))
+
+#define DANUBE_PPE_PP32_SLEEP                      DANUBE_PPE_REG_ADDR(0x0010) /* PP32 Power Saving Register */
+#define DANUBE_PPE_CDM_CFG                         DANUBE_PPE_REG_ADDR(0x0100) /* Code/Data Memory (CDM) Register */
+
+/* Mailbox Registers */
+#define DANUBE_PPE_MBOX_IGU0_ISRS                  DANUBE_PPE_REG_ADDR(0x0200)
+#define DANUBE_PPE_MBOX_IGU0_ISRC                  DANUBE_PPE_REG_ADDR(0x0201)
+#define DANUBE_PPE_MBOX_IGU0_ISR                   DANUBE_PPE_REG_ADDR(0x0202)
+#define DANUBE_PPE_MBOX_IGU0_IER                   DANUBE_PPE_REG_ADDR(0x0203)
+#define DANUBE_PPE_MBOX_IGU1_ISRS0                 DANUBE_PPE_REG_ADDR(0x0204)
+#define DANUBE_PPE_MBOX_IGU1_ISRC0                 DANUBE_PPE_REG_ADDR(0x0205)
+#define DANUBE_PPE_MBOX_IGU1_ISR0                  DANUBE_PPE_REG_ADDR(0x0206)
+#define DANUBE_PPE_MBOX_IGU1_IER0                  DANUBE_PPE_REG_ADDR(0x0207)
+#define DANUBE_PPE_MBOX_IGU1_ISRS1                 DANUBE_PPE_REG_ADDR(0x0208)
+#define DANUBE_PPE_MBOX_IGU1_ISRC1                 DANUBE_PPE_REG_ADDR(0x0209)
+#define DANUBE_PPE_MBOX_IGU1_ISR1                  DANUBE_PPE_REG_ADDR(0x020A)
+#define DANUBE_PPE_MBOX_IGU1_IER1                  DANUBE_PPE_REG_ADDR(0x020B)
+#define DANUBE_PPE_MBOX_IGU1_ISRS2                 DANUBE_PPE_REG_ADDR(0x020C)
+#define DANUBE_PPE_MBOX_IGU1_ISRC2                 DANUBE_PPE_REG_ADDR(0x020D)
+#define DANUBE_PPE_MBOX_IGU1_ISR2                  DANUBE_PPE_REG_ADDR(0x020E)
+#define DANUBE_PPE_MBOX_IGU1_IER2                  DANUBE_PPE_REG_ADDR(0x020F)
+#define DANUBE_PPE_MBOX_IGU2_ISRS                  DANUBE_PPE_REG_ADDR(0x0210)
+#define DANUBE_PPE_MBOX_IGU2_ISRC                  DANUBE_PPE_REG_ADDR(0x0211)
+#define DANUBE_PPE_MBOX_IGU2_ISR                   DANUBE_PPE_REG_ADDR(0x0212)
+#define DANUBE_PPE_MBOX_IGU2_IER                   DANUBE_PPE_REG_ADDR(0x0213)
+#define DANUBE_PPE_MBOX_IGU3_ISRS                  DANUBE_PPE_REG_ADDR(0x0214)
+#define DANUBE_PPE_MBOX_IGU3_ISRC                  DANUBE_PPE_REG_ADDR(0x0215)
+#define DANUBE_PPE_MBOX_IGU3_ISR                   DANUBE_PPE_REG_ADDR(0x0216)
+#define DANUBE_PPE_MBOX_IGU3_IER                   DANUBE_PPE_REG_ADDR(0x0217)
+#define DANUBE_PPE_MBOX_IGU4_ISRS                  DANUBE_PPE_REG_ADDR(0x0218)
+#define DANUBE_PPE_MBOX_IGU4_ISRC                  DANUBE_PPE_REG_ADDR(0x0219)
+#define DANUBE_PPE_MBOX_IGU4_ISR                   DANUBE_PPE_REG_ADDR(0x021A)
+#define DANUBE_PPE_MBOX_IGU4_IER                   DANUBE_PPE_REG_ADDR(0x021B)
+/*
+ *    Shared Buffer (SB) Registers
+ */
+#define DANUBE_PPE_SB_MST_PRI0                     DANUBE_PPE_REG_ADDR(0x0300)
+#define DANUBE_PPE_SB_MST_PRI1                     DANUBE_PPE_REG_ADDR(0x0301)
+#define DANUBE_PPE_SB_MST_PRI2                     DANUBE_PPE_REG_ADDR(0x0302)
+#define DANUBE_PPE_SB_MST_PRI3                     DANUBE_PPE_REG_ADDR(0x0303)
+#define DANUBE_PPE_SB_MST_PRI4                     DANUBE_PPE_REG_ADDR(0x0304)
+#define DANUBE_PPE_SB_MST_SEL                      DANUBE_PPE_REG_ADDR(0x0305)
+/*
+ *    RTHA Registers
+ */
+#define DANUBE_PPE_RFBI_CFG                        DANUBE_PPE_REG_ADDR(0x0400)
+#define DANUBE_PPE_RBA_CFG0                        DANUBE_PPE_REG_ADDR(0x0404)
+#define DANUBE_PPE_RBA_CFG1                        DANUBE_PPE_REG_ADDR(0x0405)
+#define DANUBE_PPE_RCA_CFG0                        DANUBE_PPE_REG_ADDR(0x0408)
+#define DANUBE_PPE_RCA_CFG1                        DANUBE_PPE_REG_ADDR(0x0409)
+#define DANUBE_PPE_RDES_CFG0                       DANUBE_PPE_REG_ADDR(0x040C)
+#define DANUBE_PPE_RDES_CFG1                       DANUBE_PPE_REG_ADDR(0x040D)
+#define DANUBE_PPE_SFSM_STATE0                     DANUBE_PPE_REG_ADDR(0x0410)
+#define DANUBE_PPE_SFSM_STATE1                     DANUBE_PPE_REG_ADDR(0x0411)
+#define DANUBE_PPE_SFSM_DBA0                       DANUBE_PPE_REG_ADDR(0x0412)
+#define DANUBE_PPE_SFSM_DBA1                       DANUBE_PPE_REG_ADDR(0x0413)
+#define DANUBE_PPE_SFSM_CBA0                       DANUBE_PPE_REG_ADDR(0x0414)
+#define DANUBE_PPE_SFSM_CBA1                       DANUBE_PPE_REG_ADDR(0x0415)
+#define DANUBE_PPE_SFSM_CFG0                       DANUBE_PPE_REG_ADDR(0x0416)
+#define DANUBE_PPE_SFSM_CFG1                       DANUBE_PPE_REG_ADDR(0x0417)
+#define DANUBE_PPE_SFSM_PGCNT0                     DANUBE_PPE_REG_ADDR(0x041C)
+#define DANUBE_PPE_SFSM_PGCNT1                     DANUBE_PPE_REG_ADDR(0x041D)
+/*
+ *    TTHA Registers
+ */
+#define DANUBE_PPE_FFSM_DBA0                       DANUBE_PPE_REG_ADDR(0x0508)
+#define DANUBE_PPE_FFSM_DBA1                       DANUBE_PPE_REG_ADDR(0x0509)
+#define DANUBE_PPE_FFSM_CFG0                       DANUBE_PPE_REG_ADDR(0x050A)
+#define DANUBE_PPE_FFSM_CFG1                       DANUBE_PPE_REG_ADDR(0x050B)
+#define DANUBE_PPE_FFSM_IDLE_HEAD_BC0              DANUBE_PPE_REG_ADDR(0x050E)
+#define DANUBE_PPE_FFSM_IDLE_HEAD_BC1              DANUBE_PPE_REG_ADDR(0x050F)
+#define DANUBE_PPE_FFSM_PGCNT0                     DANUBE_PPE_REG_ADDR(0x0514)
+#define DANUBE_PPE_FFSM_PGCNT1                     DANUBE_PPE_REG_ADDR(0x0515)
+/*
+ *    ETOP MDIO Registers
+ */
+#define DANUBE_PPE_ETOP_MDIO_CFG                   DANUBE_PPE_REG_ADDR(0x0600)
+#define DANUBE_PPE_ETOP_MDIO_ACC                   DANUBE_PPE_REG_ADDR(0x0601)
+#define DANUBE_PPE_ETOP_CFG                        DANUBE_PPE_REG_ADDR(0x0602)
+#define DANUBE_PPE_ETOP_IG_VLAN_COS                DANUBE_PPE_REG_ADDR(0x0603)
+#define DANUBE_PPE_ETOP_IG_DSCP_COS3               DANUBE_PPE_REG_ADDR(0x0604)
+#define DANUBE_PPE_ETOP_IG_DSCP_COS2               DANUBE_PPE_REG_ADDR(0x0605)
+#define DANUBE_PPE_ETOP_IG_DSCP_COS1               DANUBE_PPE_REG_ADDR(0x0606)
+#define DANUBE_PPE_ETOP_IG_DSCP_COS0               DANUBE_PPE_REG_ADDR(0x0607)
+#define DANUBE_PPE_ETOP_IG_PLEN_CTRL0              DANUBE_PPE_REG_ADDR(0x0608)
+#define DANUBE_PPE_ETOP_IG_PLEN_CTRL1              DANUBE_PPE_REG_ADDR(0x0609)
+#define DANUBE_PPE_ETOP_ISR                        DANUBE_PPE_REG_ADDR(0x060A)
+#define DANUBE_PPE_ETOP_IER                        DANUBE_PPE_REG_ADDR(0x060B)
+#define DANUBE_PPE_ETOP_VPID                       DANUBE_PPE_REG_ADDR(0x060C)
+#define DANUBE_PPE_ENET_MAC_CFG                    DANUBE_PPE_REG_ADDR(0x0610)
+#define DANUBE_PPE_ENETS_DBA                       DANUBE_PPE_REG_ADDR(0x0612)
+#define DANUBE_PPE_ENETS_CBA                       DANUBE_PPE_REG_ADDR(0x0613)
+#define DANUBE_PPE_ENETS_CFG                       DANUBE_PPE_REG_ADDR(0x0614)
+#define DANUBE_PPE_ENETS_PGCNT                     DANUBE_PPE_REG_ADDR(0x0615)
+#define DANUBE_PPE_ENETS_PGCNT_DSRC_PP32	   (0x00020000)
+#define DANUBE_PPE_ENETS_PGCNT_DVAL_SHIFT	   (9)
+#define DANUBE_PPE_ENETS_PGCNT_DCMD	           (0x00000100)
+#define DANUBE_PPE_ENETS_PKTCNT                    DANUBE_PPE_REG_ADDR(0x0616)
+#define DANUBE_PPE_ENETS_PKTCNT_DSRC_PP32	   (0x00000200)
+#define DANUBE_PPE_ENETS_PKTCNT_DCMD	           (0x00000100)
+#define DANUBE_PPE_ENETS_PKTCNT_UPKT	           (0x000000FF)
+#define DANUBE_PPE_ENETS_BUF_CTRL                  DANUBE_PPE_REG_ADDR(0x0617)
+#define DANUBE_PPE_ENETS_COS_CFG                   DANUBE_PPE_REG_ADDR(0x0618)
+#define DANUBE_PPE_ENETS_IGDROP                    DANUBE_PPE_REG_ADDR(0x0619)
+#define DANUBE_PPE_ENETF_DBA                       DANUBE_PPE_REG_ADDR(0x0630)
+#define DANUBE_PPE_ENETF_CBA                       DANUBE_PPE_REG_ADDR(0x0631)
+#define DANUBE_PPE_ENETF_CFG                       DANUBE_PPE_REG_ADDR(0x0632)
+#define DANUBE_PPE_ENETF_PGCNT                     DANUBE_PPE_REG_ADDR(0x0633)
+#define DANUBE_PPE_ENETF_PGCNT_ISRC_PP32	   (0x00020000)
+#define DANUBE_PPE_ENETF_PGCNT_IVAL_SHIFT	   (9)
+#define DANUBE_PPE_ENETF_PGCNT_ICMD	           (0x00000100)
+#define DANUBE_PPE_ENETF_PKTCNT                    DANUBE_PPE_REG_ADDR(0x0634)
+#define DANUBE_PPE_ENETF_PKTCNT_ISRC_PP32	   (0x00000200)
+#define DANUBE_PPE_ENETF_PKTCNT_ICMD	           (0x00000100)
+#define DANUBE_PPE_ENETF_PKTCNT_VPKT	           (0x000000FF)
+#define DANUBE_PPE_ENETF_HFCTRL                    DANUBE_PPE_REG_ADDR(0x0635)
+#define DANUBE_PPE_ENETF_TXCTRL                    DANUBE_PPE_REG_ADDR(0x0636)
+#define DANUBE_PPE_ENETF_VLCOS0                    DANUBE_PPE_REG_ADDR(0x0638)
+#define DANUBE_PPE_ENETF_VLCOS1                    DANUBE_PPE_REG_ADDR(0x0639)
+#define DANUBE_PPE_ENETF_VLCOS2                    DANUBE_PPE_REG_ADDR(0x063A)
+#define DANUBE_PPE_ENETF_VLCOS3                    DANUBE_PPE_REG_ADDR(0x063B)
+#define DANUBE_PPE_ENETF_EGERR                     DANUBE_PPE_REG_ADDR(0x063C)
+#define DANUBE_PPE_ENETF_EGDROP                    DANUBE_PPE_REG_ADDR(0x063D)
+/*
+ *    DPLUS Registers
+ */
+#define DANUBE_PPE_DPLUS_TXDB                      DANUBE_PPE_REG_ADDR(0x0700)
+#define DANUBE_PPE_DPLUS_TXCB                      DANUBE_PPE_REG_ADDR(0x0701)
+#define DANUBE_PPE_DPLUS_TXCFG                     DANUBE_PPE_REG_ADDR(0x0702)
+#define DANUBE_PPE_DPLUS_TXPGCNT                   DANUBE_PPE_REG_ADDR(0x0703)
+#define DANUBE_PPE_DPLUS_RXDB                      DANUBE_PPE_REG_ADDR(0x0710)
+#define DANUBE_PPE_DPLUS_RXCB                      DANUBE_PPE_REG_ADDR(0x0711)
+#define DANUBE_PPE_DPLUS_RXCFG                     DANUBE_PPE_REG_ADDR(0x0712)
+#define DANUBE_PPE_DPLUS_RXPGCNT                   DANUBE_PPE_REG_ADDR(0x0713)
+/*
+ *    BMC Registers
+ */
+#define DANUBE_PPE_BMC_CMD3                        DANUBE_PPE_REG_ADDR(0x0800)
+#define DANUBE_PPE_BMC_CMD2                        DANUBE_PPE_REG_ADDR(0x0801)
+#define DANUBE_PPE_BMC_CMD1                        DANUBE_PPE_REG_ADDR(0x0802)
+#define DANUBE_PPE_BMC_CMD0                        DANUBE_PPE_REG_ADDR(0x0803)
+#define DANUBE_PPE_BMC_CFG0                        DANUBE_PPE_REG_ADDR(0x0804)
+#define DANUBE_PPE_BMC_CFG1                        DANUBE_PPE_REG_ADDR(0x0805)
+#define DANUBE_PPE_BMC_POLY0                       DANUBE_PPE_REG_ADDR(0x0806)
+#define DANUBE_PPE_BMC_POLY1                       DANUBE_PPE_REG_ADDR(0x0807)
+#define DANUBE_PPE_BMC_CRC0                        DANUBE_PPE_REG_ADDR(0x0808)
+#define DANUBE_PPE_BMC_CRC1                        DANUBE_PPE_REG_ADDR(0x0809)
+/*
+ *    SLL Registers
+ */
+#define DANUBE_PPE_SLL_CMD1                        DANUBE_PPE_REG_ADDR(0x0900)
+#define DANUBE_PPE_SLL_CMD0                        DANUBE_PPE_REG_ADDR(0x0901)
+#define DANUBE_PPE_SLL_KEY0                        DANUBE_PPE_REG_ADDR(0x0910)
+#define DANUBE_PPE_SLL_KEY1                        DANUBE_PPE_REG_ADDR(0x0911)
+#define DANUBE_PPE_SLL_KEY2                        DANUBE_PPE_REG_ADDR(0x0912)
+#define DANUBE_PPE_SLL_KEY3                        DANUBE_PPE_REG_ADDR(0x0913)
+#define DANUBE_PPE_SLL_KEY4                        DANUBE_PPE_REG_ADDR(0x0914)
+#define DANUBE_PPE_SLL_KEY5                        DANUBE_PPE_REG_ADDR(0x0915)
+#define DANUBE_PPE_SLL_RESULT                      DANUBE_PPE_REG_ADDR(0x0920)
+/*
+ *    EMA Registers
+ */
+#define DANUBE_PPE_EMA_CMD2                        DANUBE_PPE_REG_ADDR(0x0A00)
+#define DANUBE_PPE_EMA_CMD1                        DANUBE_PPE_REG_ADDR(0x0A01)
+#define DANUBE_PPE_EMA_CMD0                        DANUBE_PPE_REG_ADDR(0x0A02)
+#define DANUBE_PPE_EMA_ISR                         DANUBE_PPE_REG_ADDR(0x0A04)
+#define DANUBE_PPE_EMA_IER                         DANUBE_PPE_REG_ADDR(0x0A05)
+#define DANUBE_PPE_EMA_CFG                         DANUBE_PPE_REG_ADDR(0x0A06)
+/*
+ *    UTPS Registers
+ */
+#define DANUBE_PPE_UTP_TXCA0                       DANUBE_PPE_REG_ADDR(0x0B00)
+#define DANUBE_PPE_UTP_TXNA0                       DANUBE_PPE_REG_ADDR(0x0B01)
+#define DANUBE_PPE_UTP_TXCA1                       DANUBE_PPE_REG_ADDR(0x0B02)
+#define DANUBE_PPE_UTP_TXNA1                       DANUBE_PPE_REG_ADDR(0x0B03)
+#define DANUBE_PPE_UTP_RXCA0                       DANUBE_PPE_REG_ADDR(0x0B10)
+#define DANUBE_PPE_UTP_RXNA0                       DANUBE_PPE_REG_ADDR(0x0B11)
+#define DANUBE_PPE_UTP_RXCA1                       DANUBE_PPE_REG_ADDR(0x0B12)
+#define DANUBE_PPE_UTP_RXNA1                       DANUBE_PPE_REG_ADDR(0x0B13)
+#define DANUBE_PPE_UTP_CFG                         DANUBE_PPE_REG_ADDR(0x0B20)
+#define DANUBE_PPE_UTP_ISR                         DANUBE_PPE_REG_ADDR(0x0B30)
+#define DANUBE_PPE_UTP_IER                         DANUBE_PPE_REG_ADDR(0x0B31)
+/*
+ *    QSB Registers
+ */
+#define DANUBE_PPE_QSB_RELOG                       DANUBE_PPE_REG_ADDR(0x0C00)
+#define DANUBE_PPE_QSB_EMIT0                       DANUBE_PPE_REG_ADDR(0x0C01)
+#define DANUBE_PPE_QSB_EMIT1                       DANUBE_PPE_REG_ADDR(0x0C02)
+#define DANUBE_PPE_QSB_ICDV                        DANUBE_PPE_REG_ADDR(0x0C07)
+#define DANUBE_PPE_QSB_SBL                         DANUBE_PPE_REG_ADDR(0x0C09)
+#define DANUBE_PPE_QSB_CFG                         DANUBE_PPE_REG_ADDR(0x0C0A)
+#define DANUBE_PPE_QSB_RTM                         DANUBE_PPE_REG_ADDR(0x0C0B)
+#define DANUBE_PPE_QSB_RTD                         DANUBE_PPE_REG_ADDR(0x0C0C)
+#define DANUBE_PPE_QSB_RAMAC                       DANUBE_PPE_REG_ADDR(0x0C0D)
+#define DANUBE_PPE_QSB_ISTAT                       DANUBE_PPE_REG_ADDR(0x0C0E)
+#define DANUBE_PPE_QSB_IMR                         DANUBE_PPE_REG_ADDR(0x0C0F)
+#define DANUBE_PPE_QSB_SRC                         DANUBE_PPE_REG_ADDR(0x0C10)
+/*
+ *    DSP User Registers
+ */
+#define DANUBE_PPE_DREG_A_VERSION                  DANUBE_PPE_REG_ADDR(0x0D00)
+#define DANUBE_PPE_DREG_A_CFG                      DANUBE_PPE_REG_ADDR(0x0D01)
+#define DANUBE_PPE_DREG_AT_CTRL                    DANUBE_PPE_REG_ADDR(0x0D02)
+#define DANUBE_PPE_DREG_AR_CTRL                    DANUBE_PPE_REG_ADDR(0x0D08)
+#define DANUBE_PPE_DREG_A_UTPCFG                   DANUBE_PPE_REG_ADDR(0x0D0E)
+#define DANUBE_PPE_DREG_A_STATUS                   DANUBE_PPE_REG_ADDR(0x0D0F)
+#define DANUBE_PPE_DREG_AT_CFG0                    DANUBE_PPE_REG_ADDR(0x0D20)
+#define DANUBE_PPE_DREG_AT_CFG1                    DANUBE_PPE_REG_ADDR(0x0D21)
+#define DANUBE_PPE_DREG_FB_SIZE0                   DANUBE_PPE_REG_ADDR(0x0D22)
+#define DANUBE_PPE_DREG_FB_SIZE1                   DANUBE_PPE_REG_ADDR(0x0D23)
+#define DANUBE_PPE_DREG_AT_CELL0                   DANUBE_PPE_REG_ADDR(0x0D24)
+#define DANUBE_PPE_DREG_AT_CELL1                   DANUBE_PPE_REG_ADDR(0x0D25)
+#define DANUBE_PPE_DREG_AT_IDLE_CNT0               DANUBE_PPE_REG_ADDR(0x0D26)
+#define DANUBE_PPE_DREG_AT_IDLE_CNT1               DANUBE_PPE_REG_ADDR(0x0D27)
+#define DANUBE_PPE_DREG_AT_IDLE0                   DANUBE_PPE_REG_ADDR(0x0D28)
+#define DANUBE_PPE_DREG_AT_IDLE1                   DANUBE_PPE_REG_ADDR(0x0D29)
+#define DANUBE_PPE_DREG_AR_CFG0                    DANUBE_PPE_REG_ADDR(0x0D60)
+#define DANUBE_PPE_DREG_AR_CFG1                    DANUBE_PPE_REG_ADDR(0x0D61)
+#define DANUBE_PPE_DREG_AR_FB_START0               DANUBE_PPE_REG_ADDR(0x0D62)
+#define DANUBE_PPE_DREG_AR_FB_START1               DANUBE_PPE_REG_ADDR(0x0D63)
+#define DANUBE_PPE_DREG_AR_FB_END0                 DANUBE_PPE_REG_ADDR(0x0D64)
+#define DANUBE_PPE_DREG_AR_FB_END1                 DANUBE_PPE_REG_ADDR(0x0D65)
+#define DANUBE_PPE_DREG_AR_ATM_STAT0               DANUBE_PPE_REG_ADDR(0x0D66)
+#define DANUBE_PPE_DREG_AR_ATM_STAT1               DANUBE_PPE_REG_ADDR(0x0D67)
+#define DANUBE_PPE_DREG_AR_CELL0                   DANUBE_PPE_REG_ADDR(0x0D68)
+#define DANUBE_PPE_DREG_AR_CELL1                   DANUBE_PPE_REG_ADDR(0x0D69)
+#define DANUBE_PPE_DREG_AR_IDLE_CNT0               DANUBE_PPE_REG_ADDR(0x0D6A)
+#define DANUBE_PPE_DREG_AR_IDLE_CNT1               DANUBE_PPE_REG_ADDR(0x0D6B)
+#define DANUBE_PPE_DREG_AR_AIIDLE_CNT0             DANUBE_PPE_REG_ADDR(0x0D6C)
+#define DANUBE_PPE_DREG_AR_AIIDLE_CNT1             DANUBE_PPE_REG_ADDR(0x0D6D)
+#define DANUBE_PPE_DREG_AR_BE_CNT0                 DANUBE_PPE_REG_ADDR(0x0D6E)
+#define DANUBE_PPE_DREG_AR_BE_CNT1                 DANUBE_PPE_REG_ADDR(0x0D6F)
+#define DANUBE_PPE_DREG_AR_HEC_CNT0                DANUBE_PPE_REG_ADDR(0x0D70)
+#define DANUBE_PPE_DREG_AR_HEC_CNT1                DANUBE_PPE_REG_ADDR(0x0D71)
+#define DANUBE_PPE_DREG_AR_CD_CNT0                 DANUBE_PPE_REG_ADDR(0x0D72)
+#define DANUBE_PPE_DREG_AR_CD_CNT1                 DANUBE_PPE_REG_ADDR(0x0D73)
+#define DANUBE_PPE_DREG_AR_IDLE0                   DANUBE_PPE_REG_ADDR(0x0D74)
+#define DANUBE_PPE_DREG_AR_IDLE1                   DANUBE_PPE_REG_ADDR(0x0D75)
+#define DANUBE_PPE_DREG_AR_DELIN0                  DANUBE_PPE_REG_ADDR(0x0D76)
+#define DANUBE_PPE_DREG_AR_DELIN1                  DANUBE_PPE_REG_ADDR(0x0D77)
+#define DANUBE_PPE_DREG_RESV0                      DANUBE_PPE_REG_ADDR(0x0D78)
+#define DANUBE_PPE_DREG_RESV1                      DANUBE_PPE_REG_ADDR(0x0D79)
+#define DANUBE_PPE_DREG_RX_MIB_CMD0                DANUBE_PPE_REG_ADDR(0x0D80)
+#define DANUBE_PPE_DREG_RX_MIB_CMD1                DANUBE_PPE_REG_ADDR(0x0D81)
+#define DANUBE_PPE_DREG_AR_OVDROP_CNT0             DANUBE_PPE_REG_ADDR(0x0D98)
+#define DANUBE_PPE_DREG_AR_OVDROP_CNT1             DANUBE_PPE_REG_ADDR(0x0D99)
+
+
+/************************************************************************/
+/*   Module       :   PPE register address and bits        		*/
+/************************************************************************/
+#define DANUBE_PPE32_BASE  0xBE180000
+#define DANUBE_PPE32_DEBUG_BREAK_TRACE_REG   (DANUBE_PPE32_BASE + (0x0000 * 4))
+#define DANUBE_PPE32_INT_MASK_STATUS_REG     (DANUBE_PPE32_BASE + (0x0030 * 4))
+#define DANUBE_PPE32_INT_RESOURCE_REG        (DANUBE_PPE32_BASE + (0x0040 * 4))
+#define DANUBE_PPE32_CDM_CODE_MEM_B0         (DANUBE_PPE32_BASE + (0x1000 * 4))
+#define DANUBE_PPE32_CDM_CODE_MEM_B1         (DANUBE_PPE32_BASE + (0x2000 * 4))
+#define DANUBE_PPE32_DATA_MEM_MAP_REG_BASE   (DANUBE_PPE32_BASE + (0x4000 * 4))
+
+/*
+ *    ETOP MDIO Registers
+ */
+#define ETOP_MDIO_CFG           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0600 * 4)))
+#define ETOP_MDIO_ACC           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0601 * 4)))
+#define ETOP_CFG                ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0602 * 4)))
+#define ETOP_IG_VLAN_COS        ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0603 * 4)))
+#define ETOP_IG_DSCP_COS3       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0604 * 4)))
+#define ETOP_IG_DSCP_COS2       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0605 * 4)))
+#define ETOP_IG_DSCP_COS1       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0606 * 4)))
+#define ETOP_IG_DSCP_COS0       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0607 * 4)))
+#define ETOP_IG_PLEN_CTRL       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0608 * 4)))
+#define ETOP_ISR                ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060A * 4)))
+#define ETOP_IER                ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060B * 4)))
+#define ETOP_VPID               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060C * 4)))
+#define ENET_MAC_CFG            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define ENETS_DBA               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0612 * 4)))
+#define ENETS_CBA               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0613 * 4)))
+#define ENETS_CFG               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0614 * 4)))
+#define ENETS_PGCNT             ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0615 * 4)))
+#define ENETS_PKTCNT            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0616 * 4)))
+#define ENETS_BUF_CTRL          ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0617 * 4)))
+#define ENETS_COS_CFG           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+#define ENETS_IGDROP            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define ENETS_IGERR             ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061A * 4)))
+#define ENET_MAC_DA0           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061B * 4)))
+#define ENET_MAC_DA1           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x061C * 4)))
+
+#define ENETF_DBA               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0630 * 4)))
+#define ENETF_CBA               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0631 * 4)))
+#define ENETF_CFG               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0632 * 4)))
+#define ENETF_PGCNT             ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0633 * 4)))
+#define ENETF_PKTCNT            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0634 * 4)))
+#define ENETF_HFCTRL            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0635 * 4)))
+#define ENETF_TXCTRL            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0636 * 4)))
+
+#define ENETF_VLCOS0            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0638 * 4)))
+#define ENETF_VLCOS1            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0639 * 4)))
+#define ENETF_VLCOS2            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063A * 4)))
+#define ENETF_VLCOS3            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063B * 4)))
+#define ENETF_EGERR             ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063C * 4)))
+#define ENETF_EGDROP            ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x063D * 4)))
+
+
+/*
+ *    ETOP MDIO Registers
+ */
+#define DANUBE_PPE32_ETOP_MDIO_CFG           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0600 * 4)))
+#define DANUBE_PPE32_ETOP_MDIO_ACC           ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0601 * 4)))
+#define DANUBE_PPE32_ETOP_CFG                ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0602 * 4)))
+#define DANUBE_PPE32_ETOP_IG_VLAN_COS        ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0603 * 4)))
+#define DANUBE_PPE32_ETOP_IG_DSCP_COS3       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0604 * 4)))
+#define DANUBE_PPE32_ETOP_IG_DSCP_COS2       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0605 * 4)))
+#define DANUBE_PPE32_ETOP_IG_DSCP_COS1       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0606 * 4)))
+#define DANUBE_PPE32_ETOP_IG_DSCP_COS0       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0607 * 4)))
+#define DANUBE_PPE32_ETOP_IG_PLEN_CTRL       ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0608 * 4)))
+#define DANUBE_PPE32_ETOP_ISR                ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060A * 4)))
+#define DANUBE_PPE32_ETOP_IER                ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060B * 4)))
+#define DANUBE_PPE32_ETOP_VPID               ((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x060C * 4)))
+
+
+/* ENET Register */
+#define DANUBE_PPE32_ENET_MAC_CFG            	((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0610 * 4)))
+#define DANUBE_PPE32_ENET_IG_PKTDROP          	((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0619 * 4)))
+#define DANUBE_PPE32_ENET_CoS_CFG          	((volatile u32 *)(DANUBE_PPE32_DATA_MEM_MAP_REG_BASE + (0x0618 * 4)))
+
+/*********LED register definition****************/
+
+#define DANUBE_LED                      0xBE100BB0
+#define DANUBE_LED_CON0                 ((volatile u32*)(DANUBE_LED + 0x0000))
+#define DANUBE_LED_CON1                 ((volatile u32*)(DANUBE_LED + 0x0004))
+#define DANUBE_LED_CPU0                 ((volatile u32*)(DANUBE_LED + 0x0008))
+#define DANUBE_LED_CPU1                 ((volatile u32*)(DANUBE_LED + 0x000C))
+#define DANUBE_LED_AR                   ((volatile u32*)(DANUBE_LED + 0x0010))
+
+
+
+
+/***********************************************************************/
+#define DANUBE_REG32(addr)		   *((volatile u32 *)(addr))
+/***********************************************************************/
+#endif //DANUBE_H
diff --git a/board/infineon/easy50712/Makefile b/board/infineon/easy50712/Makefile
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+#COBJS	:= $(BOARD).o
+COBJS-y	+= danube.o
+
+SOBJS	= lowlevel_init.o pmuenable.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/infineon/easy50712/danube.c b/board/infineon/easy50712/danube.c
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/danube.c
@@ -0,0 +1,393 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2011
+ * Thomas Langer, Ralph Hempel
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <asm/addrspace.h>
+#include <asm/danube.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#if defined(CONFIG_CMD_HTTPD)
+#include <httpd.h>
+#endif
+
+extern ulong ifx_get_ddr_hz(void);
+
+/* definitions for external PHYs / Switches */
+/* Split values into phy address and register address */
+#define PHYADDR(_reg)	((_reg >> 5) & 0xff), (_reg & 0x1f)
+
+/* IDs and registers of known external switches */
+#define ID_SAMURAI_0	0x1020
+#define ID_SAMURAI_1	0x0007
+#define SAMURAI_ID_REG0	0xA0
+#define SAMURAI_ID_REG1	0xA1
+
+#define ID_TANTOS	0x2599
+
+void _machine_restart(void)
+{
+	*DANUBE_RCU_RST_REQ |=1<<30;
+}
+
+#ifdef CONFIG_SYS_RAMBOOT
+phys_size_t initdram(int board_type)
+{
+	return get_ram_size((long *)CONFIG_SYS_SDRAM_BASE, CONFIG_SYS_MAX_RAM);
+}
+#elif defined(CONFIG_USE_DDR_RAM)
+phys_size_t initdram(int board_type)
+{
+	return (CONFIG_SYS_MAX_RAM);
+}
+#else
+
+static ulong max_sdram_size(void)     /* per Chip Select */
+{
+	/* The only supported SDRAM data width is 16bit.
+	 */
+#define CFG_DW	4
+
+	/* The only supported number of SDRAM banks is 4.
+	 */
+#define CFG_NB	4
+
+	ulong cfgpb0 = *DANUBE_SDRAM_MC_CFGPB0;
+	int   cols   = cfgpb0 & 0xF;
+	int   rows   = (cfgpb0 & 0xF0) >> 4;
+	ulong size   = (1 << (rows + cols)) * CFG_DW * CFG_NB;
+
+	return size;
+}
+
+/*
+ * Check memory range for valid RAM. A simple memory test determines
+ * the actually available RAM size between addresses `base' and
+ * `base + maxsize'.
+ */
+
+static long int dram_size(long int *base, long int maxsize)
+{
+	volatile long int *addr;
+	ulong cnt, val;
+	ulong save[32];			/* to make test non-destructive */
+	unsigned char i = 0;
+
+	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
+		addr = base + cnt;		/* pointer arith! */
+
+		save[i++] = *addr;
+		*addr = ~cnt;
+	}
+
+	/* write 0 to base address */
+	addr = base;
+	save[i] = *addr;
+	*addr = 0;
+
+	/* check at base address */
+	if ((val = *addr) != 0) {
+		*addr = save[i];
+		return (0);
+	}
+
+	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
+		addr = base + cnt;		/* pointer arith! */
+
+		val = *addr;
+		*addr = save[--i];
+
+		if (val != (~cnt)) {
+			return (cnt * sizeof (long));
+		}
+	}
+	return (maxsize);
+}
+
+phys_size_t initdram(int board_type)
+{
+	int   rows, cols, best_val = *DANUBE_SDRAM_MC_CFGPB0;
+	ulong size, max_size       = 0;
+	ulong our_address;
+
+	/* load t9 into our_address */
+	asm volatile ("move %0, $25" : "=r" (our_address) :);
+
+	/* Can't probe for RAM size unless we are running from Flash.
+	 * find out whether running from DRAM or Flash.
+	 */
+	if (CPHYSADDR(our_address) < CPHYSADDR(PHYS_FLASH_1))
+	{
+		return max_sdram_size();
+	}
+
+	for (cols = 0x8; cols <= 0xC; cols++)
+	{
+		for (rows = 0xB; rows <= 0xD; rows++)
+		{
+			*DANUBE_SDRAM_MC_CFGPB0 = (0x14 << 8) |
+			                          (rows << 4) | cols;
+			size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
+			                          max_sdram_size());
+
+			if (size > max_size)
+			{
+				best_val = *DANUBE_SDRAM_MC_CFGPB0;
+				max_size = size;
+			}
+		}
+	}
+
+	*DANUBE_SDRAM_MC_CFGPB0 = best_val;
+	return max_size;
+}
+#endif
+
+int checkboard (void)
+{
+	unsigned long chipid = *DANUBE_MPS_CHIPID;
+	int part_num;
+
+	puts ("Board: ");
+
+	part_num = DANUBE_MPS_CHIPID_PARTNUM_GET(chipid);
+	switch (part_num)
+	{
+	case 0x129:
+	case 0x12D:
+		puts("Danube/Twinpass/Vinax-VE ");
+		break;
+	default:
+		printf ("unknown, chip part number 0x%03X ", part_num);
+		break;
+	}
+	printf ("V1.%ld, ", DANUBE_MPS_CHIPID_VERSION_GET(chipid));
+
+	printf("DDR Speed %ld MHz, ", ifx_get_ddr_hz()/1000000);
+	printf("CPU Speed %ld MHz\n", get_cpuclk()/1000000);
+
+	return 0;
+}
+
+#ifdef CONFIG_SKIP_LOWLEVEL_INIT
+int board_early_init_f(void)
+{
+#ifdef CONFIG_EBU_ADDSEL0
+	(*DANUBE_EBU_ADDSEL0) = CONFIG_EBU_ADDSEL0;
+#endif
+#ifdef CONFIG_EBU_ADDSEL1
+	(*DANUBE_EBU_ADDSEL1) = CONFIG_EBU_ADDSEL1;
+#endif
+#ifdef CONFIG_EBU_ADDSEL2
+	(*DANUBE_EBU_ADDSEL2) = CONFIG_EBU_ADDSEL2;
+#endif
+#ifdef CONFIG_EBU_ADDSEL3
+	(*DANUBE_EBU_ADDSEL3) = CONFIG_EBU_ADDSEL3;
+#endif
+#ifdef CONFIG_EBU_BUSCON0
+	(*DANUBE_EBU_BUSCON0) = CONFIG_EBU_BUSCON0;
+#endif
+#ifdef CONFIG_EBU_BUSCON1
+	(*DANUBE_EBU_BUSCON1) = CONFIG_EBU_BUSCON1;
+#endif
+#ifdef CONFIG_EBU_BUSCON2
+	(*DANUBE_EBU_BUSCON2) = CONFIG_EBU_BUSCON2;
+#endif
+#ifdef CONFIG_EBU_BUSCON3
+	(*DANUBE_EBU_BUSCON3) = CONFIG_EBU_BUSCON3;
+#endif
+
+	return 0;
+}
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
+
+#ifdef CONFIG_EXTRA_SWITCH
+static int external_switch_init(void)
+{
+	unsigned short chipid0=0xdead, chipid1=0xbeef;
+	static char * const name = "ltq_cpe_eth";
+
+#ifdef CLK_OUT2_25MHZ
+	*DANUBE_GPIO_P0_DIR=0x0000ae78;
+	*DANUBE_GPIO_P0_ALTSEL0=0x00008078;
+	//joelin for Mii-1       *DANUBE_GPIO_P0_ALTSEL1=0x80000080;
+	*DANUBE_GPIO_P0_ALTSEL1=0x80000000; //joelin for Mii-1
+	*DANUBE_CGU_IFCCR=0x00400010;
+	*DANUBE_GPIO_P0_OD=0x0000ae78;
+#endif
+
+	/* earlier no valid response is available, at least on Twinpass & Tantos @ 111MHz, M4530 platform */
+	udelay(100000);
+
+	debug("\nsearching for Samurai switch ... ");
+	if ( (miiphy_read(name, PHYADDR(SAMURAI_ID_REG0), &chipid0)==0) &&
+	     (miiphy_read(name, PHYADDR(SAMURAI_ID_REG1), &chipid1)==0) ) {
+		if (((chipid0 & 0xFFF0) == ID_SAMURAI_0) &&
+		    ((chipid1 & 0x000F) == ID_SAMURAI_1)) {
+			debug("found");
+
+			/* enable "Crossover Auto Detect" + defaults */
+			/* P0 */
+			miiphy_write(name, PHYADDR(0x01), 0x840F);
+			/* P1 */
+			miiphy_write(name, PHYADDR(0x03), 0x840F);
+			/* P2 */
+			miiphy_write(name, PHYADDR(0x05), 0x840F);
+			/* P3 */
+			miiphy_write(name, PHYADDR(0x07), 0x840F);
+			/* P4 */
+			miiphy_write(name, PHYADDR(0x08), 0x840F);
+			/* P5 */
+			miiphy_write(name, PHYADDR(0x09), 0x840F);
+			/* System Control 4: CPU on port 1 and other */
+			miiphy_write(name, PHYADDR(0x12), 0x3602);
+			#ifdef CLK_OUT2_25MHZ
+			/* Bandwidth Control Enable Register: enable */
+			miiphy_write(name, PHYADDR(0x33), 0x4000);
+			#endif
+		}
+	}
+
+	debug("\nsearching for TANTOS switch ... ");
+	if (miiphy_read(name, PHYADDR(0x101), &chipid0) == 0) {
+		if (chipid0 == ID_TANTOS) {
+			debug("found");
+
+			/* P5 Basic Control: Force Link Up */
+			miiphy_write(name, PHYADDR(0xA1), 0x0004);
+			/* P6 Basic Control: Force Link Up */
+			miiphy_write(name, PHYADDR(0xC1), 0x0004);
+			/* RGMII/MII Port Control (P4/5/6) */
+			miiphy_write(name, PHYADDR(0xF5), 0x0773);
+
+			/* Software workaround. */
+			/* PHY reset from P0 to P4. */
+
+			/* set data for indirect write */
+			miiphy_write(name, PHYADDR(0x121), 0x8000);
+
+			/* P0 */
+			miiphy_write(name, PHYADDR(0x120), 0x0400);
+			udelay(1000);
+			/* P1 */
+			miiphy_write(name, PHYADDR(0x120), 0x0420);
+			udelay(1000);
+			/* P2 */
+			miiphy_write(name, PHYADDR(0x120), 0x0440);
+			udelay(1000);
+			/* P3 */
+			miiphy_write(name, PHYADDR(0x120), 0x0460);
+			udelay(1000);
+			/* P4 */
+			miiphy_write(name, PHYADDR(0x120), 0x0480);
+			udelay(1000);
+		}
+	}
+	debug("\n");
+
+	return 0;
+}
+#endif /* CONFIG_EXTRA_SWITCH */
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_IFX_ETOP)
+
+	*DANUBE_PMU_PWDCR &= 0xFFFFEFDF;
+	*DANUBE_PMU_PWDCR &=~(1<<DANUBE_PMU_DMA_SHIFT);/*enable DMA from PMU*/
+
+	if (ltq_eth_initialize(bis)<0)
+		return -1;
+
+	*DANUBE_RCU_RST_REQ |=1;
+	udelay(200000);
+	*DANUBE_RCU_RST_REQ &=(unsigned long)~1;
+	udelay(1000);
+
+#ifdef CONFIG_EXTRA_SWITCH
+	if (external_switch_init()<0)
+		return -1;
+#endif /* CONFIG_EXTRA_SWITCH */
+#endif /* CONFIG_IFX_ETOP */
+
+	return 0;
+}
+
+#if defined(CONFIG_CMD_HTTPD)
+int do_http_upgrade(const unsigned char *data, const ulong size)
+{
+	char buf[128];
+
+	if(getenv ("ram_addr") == NULL)
+		return -1;
+	if(getenv ("kernel_addr") == NULL)
+		return -1;
+	/* check the image */
+	if(run_command("imi ${ram_addr}", 0) < 0) {
+		return -1;
+	}
+	/* write the image to the flash */
+	puts("http ugrade ...\n");
+	sprintf(buf, "era ${kernel_addr} +0x%lx; cp.b ${ram_addr} ${kernel_addr} 0x%lx", size, size);
+	return run_command(buf, 0);
+}
+
+int do_http_progress(const int state)
+{
+	/* toggle LED's here */
+	switch(state) {
+		case HTTP_PROGRESS_START:
+		puts("http start\n");
+		break;
+		case HTTP_PROGRESS_TIMEOUT:
+		puts(".");
+		break;
+		case HTTP_PROGRESS_UPLOAD_READY:
+		puts("http upload ready\n");
+		break;
+		case HTTP_PROGRESS_UGRADE_READY:
+		puts("http ugrade ready\n");
+		break;
+		case HTTP_PROGRESS_UGRADE_FAILED:
+		puts("http ugrade failed\n");
+		break;
+	}
+	return 0;
+}
+
+unsigned long do_http_tmp_address(void)
+{
+	char *s = getenv ("ram_addr");
+	if (s) {
+		ulong tmp = simple_strtoul (s, NULL, 16);
+		return tmp;
+	}
+	return 0 /*0x80a00000*/;
+}
+
+#endif
diff --git a/board/infineon/easy50712/ddr_settings.h b/board/infineon/easy50712/ddr_settings.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03
+#define MC_DC21_VALUE	0x1d00
+#define MC_DC22_VALUE	0x1d1d
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* was 0x7f */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_PROMOSDDR400.h b/board/infineon/easy50712/ddr_settings_PROMOSDDR400.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_PROMOSDDR400.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xa02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x0
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1200
+#define MC_DC22_VALUE	0x1212
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x4e20
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_Samsung_166.h b/board/infineon/easy50712/ddr_settings_Samsung_166.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_Samsung_166.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Samsung DDR K4H561638H Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x120  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1400
+#define MC_DC22_VALUE	0x1414
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x4e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d93
+#define MC_DC30_VALUE	0x8235
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_e111.h b/board/infineon/easy50712/ddr_settings_e111.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_e111.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_e166.h b/board/infineon/easy50712/ddr_settings_e166.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_e166.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_psc_166.h b/board/infineon/easy50712/ddr_settings_psc_166.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_psc_166.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for PSC DDR A2S56D40CTP for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x120  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1700
+#define MC_DC22_VALUE	0x1717
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x52   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x4e20
+#define MC_DC30_VALUE	0x8235
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_r111.h b/board/infineon/easy50712/ddr_settings_r111.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_r111.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1200
+#define MC_DC22_VALUE	0x1212
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/ddr_settings_r166.h b/board/infineon/easy50712/ddr_settings_r166.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/ddr_settings_r166.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0xd00
+#define MC_DC22_VALUE	0xd0d
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50712/lowlevel_init.S b/board/infineon/easy50712/lowlevel_init.S
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/lowlevel_init.S
@@ -0,0 +1,613 @@
+/*
+ *  Memory sub-system initialization code for Danube board.
+ *  Andre Messerschmidt
+ *  Copyright (c) 2005	Infineon Technologies AG
+ *
+ *  Based on Inca-IP code
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/* History:
+      peng liu May 25, 2006, for PLL setting after reset, 05252006
+ */
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+
+#if defined(CONFIG_USE_DDR_RAM)
+
+#if defined(CONFIG_USE_DDR_RAM_CFG_111M)
+#include "ddr_settings_r111.h"
+#define DDR111
+#elif defined(CONFIG_USE_DDR_RAM_CFG_166M)
+#include "ddr_settings_r166.h"
+#define DDR166
+#elif defined(CONFIG_USE_DDR_RAM_CFG_e111M)
+#include "ddr_settings_e111.h"
+#define DDR111
+#elif defined(CONFIG_USE_DDR_RAM_CFG_e166M)
+#include "ddr_settings_e166.h"
+#define DDR166
+#elif defined(CONFIG_USE_DDR_RAM_CFG_promos400)
+#include "ddr_settings_PROMOSDDR400.h"
+#define DDR166
+#elif defined(CONFIG_USE_DDR_RAM_CFG_samsung166)
+#include "ddr_settings_Samsung_166.h"
+#define DDR166
+#elif defined(CONFIG_USE_DDR_RAM_CFG_psc166)
+#include "ddr_settings_psc_166.h"
+#define DDR166
+#else
+#warning "missing definition for ddr_settings.h, use default!"
+#include "ddr_settings.h"
+#endif
+#endif /* CONFIG_USE_DDR_RAM */
+
+#if defined(CONFIG_USE_DDR_RAM) &&  !defined(MC_DC0_VALUE)
+#error "missing include of ddr_settings.h"
+#endif
+
+#define EBU_MODUL_BASE		0xBE105300
+#define EBU_CLC(value)		0x0000(value)
+#define EBU_CON(value)		0x0010(value)
+#define EBU_ADDSEL0(value)	0x0020(value)
+#define EBU_ADDSEL1(value)	0x0024(value)
+#define EBU_ADDSEL2(value)	0x0028(value)
+#define EBU_ADDSEL3(value)	0x002C(value)
+#define EBU_BUSCON0(value)	0x0060(value)
+#define EBU_BUSCON1(value)	0x0064(value)
+#define EBU_BUSCON2(value)	0x0068(value)
+#define EBU_BUSCON3(value)	0x006C(value)
+
+#define MC_MODUL_BASE		0xBF800000
+#define MC_ERRCAUSE(value)	0x0010(value)
+#define MC_ERRADDR(value)	0x0020(value)
+#define MC_CON(value)		0x0060(value)
+
+#define MC_SRAM_ENABLE		0x00000004
+#define MC_SDRAM_ENABLE		0x00000002
+#define MC_DDRRAM_ENABLE	0x00000001
+
+#define MC_SDR_MODUL_BASE	0xBF800200
+#define MC_IOGP(value)		0x0000(value)
+#define MC_CTRLENA(value)	0x0010(value)
+#define MC_MRSCODE(value)	0x0020(value)
+#define MC_CFGDW(value)		0x0030(value)
+#define MC_CFGPB0(value)	0x0040(value)
+#define MC_LATENCY(value)	0x0080(value)
+#define MC_TREFRESH(value)	0x0090(value)
+#define MC_SELFRFSH(value)	0x00A0(value)
+
+#define MC_DDR_MODUL_BASE	0xBF801000
+#define MC_DC00(value)		0x0000(value)
+#define MC_DC01(value)		0x0010(value)
+#define MC_DC02(value)		0x0020(value)
+#define MC_DC03(value)		0x0030(value)
+#define MC_DC04(value)		0x0040(value)
+#define MC_DC05(value)		0x0050(value)
+#define MC_DC06(value)		0x0060(value)
+#define MC_DC07(value)		0x0070(value)
+#define MC_DC08(value)		0x0080(value)
+#define MC_DC09(value)		0x0090(value)
+#define MC_DC10(value)		0x00A0(value)
+#define MC_DC11(value)		0x00B0(value)
+#define MC_DC12(value)		0x00C0(value)
+#define MC_DC13(value)		0x00D0(value)
+#define MC_DC14(value)		0x00E0(value)
+#define MC_DC15(value)		0x00F0(value)
+#define MC_DC16(value)		0x0100(value)
+#define MC_DC17(value)		0x0110(value)
+#define MC_DC18(value)		0x0120(value)
+#define MC_DC19(value)		0x0130(value)
+#define MC_DC20(value)		0x0140(value)
+#define MC_DC21(value)		0x0150(value)
+#define MC_DC22(value)		0x0160(value)
+#define MC_DC23(value)		0x0170(value)
+#define MC_DC24(value)		0x0180(value)
+#define MC_DC25(value)		0x0190(value)
+#define MC_DC26(value)		0x01A0(value)
+#define MC_DC27(value)		0x01B0(value)
+#define MC_DC28(value)		0x01C0(value)
+#define MC_DC29(value)		0x01D0(value)
+#define MC_DC30(value)		0x01E0(value)
+#define MC_DC31(value)		0x01F0(value)
+#define MC_DC32(value)		0x0200(value)
+#define MC_DC33(value)		0x0210(value)
+#define MC_DC34(value)		0x0220(value)
+#define MC_DC35(value)		0x0230(value)
+#define MC_DC36(value)		0x0240(value)
+#define MC_DC37(value)		0x0250(value)
+#define MC_DC38(value)		0x0260(value)
+#define MC_DC39(value)		0x0270(value)
+#define MC_DC40(value)		0x0280(value)
+#define MC_DC41(value)		0x0290(value)
+#define MC_DC42(value)		0x02A0(value)
+#define MC_DC43(value)		0x02B0(value)
+#define MC_DC44(value)		0x02C0(value)
+#define MC_DC45(value)		0x02D0(value)
+#define MC_DC46(value)		0x02E0(value)
+
+#define RCU_OFFSET  0xBF203000
+#define RCU_RST_REQ      (RCU_OFFSET + 0x0010)
+#define RCU_STS          (RCU_OFFSET + 0x0014)
+
+#define CGU_OFFSET  0xBF103000
+#define  PLL0_CFG     (CGU_OFFSET + 0x0004)
+#define  PLL1_CFG     (CGU_OFFSET + 0x0008)
+#define  PLL2_CFG     (CGU_OFFSET + 0x000C)
+#define  CGU_SYS      (CGU_OFFSET + 0x0010)
+#define  CGU_UPDATE   (CGU_OFFSET + 0x0014)
+#define  IF_CLK       (CGU_OFFSET + 0x0018)
+#define  CGU_SMD      (CGU_OFFSET + 0x0020)
+#define  CGU_CT1SR    (CGU_OFFSET + 0x0028)
+#define  CGU_CT2SR    (CGU_OFFSET + 0x002C)
+#define  CGU_PCMCR    (CGU_OFFSET + 0x0030)
+#define  PCI_CR_PCI   (CGU_OFFSET + 0x0034)
+#define  CGU_OSC_CTRL (CGU_OFFSET + 0x001C)
+#define  CGU_MIPS_PWR_DWN (CGU_OFFSET + 0x0038)
+#define  CLK_MEASURE  (CGU_OFFSET + 0x003C)
+
+//05252006
+#define  pll0_35MHz_CONFIG 0x9D861059
+#define  pll1_35MHz_CONFIG 0x1A260CD9
+#define  pll2_35MHz_CONFIG 0x8000f1e5
+#define  pll0_36MHz_CONFIG 0x1000125D
+#define  pll1_36MHz_CONFIG 0x1B1E0C99
+#define  pll2_36MHz_CONFIG 0x8002f2a1
+//05252006
+
+//06063001-joelin disable the PCI CFRAME mask -start
+/*CFRAME is an I/O signal, in the chip, the output CFRAME is selected via GPIO altsel pins, so if you select MII1 RXD1, the CFRAME will not come out.
+But the CFRAME input still take the signal from the pad and not disabled when altsel choose other function. So when MII1_RXD1 is low from other device, the EBU interface will be disabled.
+
+The chip function in such a way that disable the CFRAME mask mean EBU not longer check CFRAME to be the device using the bus.
+The side effect is the entire PCI block will see CFRAME low all the time meaning PCI cannot use the bus at all so no more PCI function.
+*/
+#define PCI_CR_PR_OFFSET  0xBE105400
+#define PCI_CR_PCI_MOD_REG          (PCI_CR_PR_OFFSET + 0x0030)
+#define PCI_CONFIG_SPACE  0xB7000000
+#define CS_CFM		(PCI_CONFIG_SPACE + 0x6C)
+//06063001-joelin disable the PCI CFRAME mask -end
+	.set	noreorder
+
+
+/*
+ * void ebu_init(void)
+ */
+	.globl	ebu_init
+	.ent	ebu_init
+ebu_init:
+
+#if defined(CONFIG_EBU_ADDSEL0) || defined(CONFIG_EBU_ADDSEL1) || \
+	defined(CONFIG_EBU_ADDSEL2) || defined(CONFIG_EBU_ADDSEL3) || \
+	defined(CONFIG_EBU_BUSCON0) || defined(CONFIG_EBU_BUSCON1) || \
+	defined(CONFIG_EBU_BUSCON2) || defined(CONFIG_EBU_BUSCON3)
+
+	li	t1, EBU_MODUL_BASE
+#if defined(CONFIG_EBU_ADDSEL0)
+	li	t2, CONFIG_EBU_ADDSEL0
+	sw	t2, EBU_ADDSEL0(t1)
+#endif
+#if defined(CONFIG_EBU_ADDSEL1)
+	li	t2, CONFIG_EBU_ADDSEL1
+	sw	t2, EBU_ADDSEL1(t1)
+#endif
+#if defined(CONFIG_EBU_ADDSEL2)
+	li	t2, CONFIG_EBU_ADDSEL2
+	sw	t2, EBU_ADDSEL2(t1)
+#endif
+#if defined(CONFIG_EBU_ADDSEL3)
+	li	t2, CONFIG_EBU_ADDSEL3
+	sw	t2, EBU_ADDSEL3(t1)
+#endif
+
+#if defined(CONFIG_EBU_BUSCON0)
+	li	t2, CONFIG_EBU_BUSCON0
+	sw	t2, EBU_BUSCON0(t1)
+#endif
+#if defined(CONFIG_EBU_BUSCON1)
+	li	t2, CONFIG_EBU_BUSCON1
+	sw	t2, EBU_BUSCON1(t1)
+#endif
+#if defined(CONFIG_EBU_BUSCON2)
+	li	t2, CONFIG_EBU_BUSCON2
+	sw	t2, EBU_BUSCON2(t1)
+#endif
+#if defined(CONFIG_EBU_BUSCON3)
+	li	t2, CONFIG_EBU_BUSCON3
+	sw	t2, EBU_BUSCON3(t1)
+#endif
+
+#endif
+
+	j	ra
+	nop
+
+	.end	ebu_init
+
+
+/*
+ * void cgu_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	cgu_init
+	.ent	cgu_init
+cgu_init:
+	li  t2, CGU_SYS
+	lw  t2,0(t2)
+	beq t2,a0,freq_up2date
+	nop
+
+	li  t2, RCU_STS
+	lw  t2, 0(t2)
+	and t2,0x00020000
+	beq t2,0x00020000,boot_36MHZ
+	nop
+//05252006
+	li  t1, PLL0_CFG
+	li  t2, pll0_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL1_CFG
+	li  t2, pll1_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL2_CFG
+	li  t2, pll2_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, CGU_SYS
+	sw	a0,0(t1)
+	li  t1, RCU_RST_REQ
+	li  t2, 0x40000008
+	sw	t2,0(t1)
+	b   wait_reset
+	nop
+boot_36MHZ:
+	li  t1, PLL0_CFG
+	li  t2, pll0_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL1_CFG
+	li  t2, pll1_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL2_CFG
+	li  t2, pll2_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, CGU_SYS
+	sw	a0,0(t1)
+	li  t1, RCU_RST_REQ
+	li  t2, 0x40000008
+	sw	t2,0(t1)
+//05252006
+
+wait_reset:
+	b   wait_reset
+	nop
+freq_up2date:
+	j ra
+	nop
+
+	.end	cgu_init
+
+#ifndef CONFIG_USE_DDR_RAM
+/*
+ * void sdram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	sdram_init
+	.ent	sdram_init
+sdram_init:
+
+	/* SDRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+
+	/* Enable SDRAM module in memory controller */
+	li	t3, MC_SDRAM_ENABLE
+	lw	t2, MC_CON(t1)
+	or	t3, t2, t3
+	sw	t3, MC_CON(t1)
+
+	li	t1, MC_SDR_MODUL_BASE
+
+	/* disable the controller */
+	li	t2, 0
+	sw	t2, MC_CTRLENA(t1)
+
+	li	t2, 0x822
+	sw	t2, MC_IOGP(t1)
+
+	li	t2, 0x2
+	sw	t2, MC_CFGDW(t1)
+
+	/* Set CAS Latency */
+	li	t2, 0x00000020
+	sw	t2, MC_MRSCODE(t1)
+
+	/* Set CS0 to SDRAM parameters */
+	li	t2, 0x000014d8
+	sw	t2, MC_CFGPB0(t1)
+
+	/* Set SDRAM latency parameters */
+	li  	t2, 0x00036325;   /* BC PC100 */
+	sw	t2, MC_LATENCY(t1)
+
+	/* Set SDRAM refresh rate */
+	li	t2, 0x00000C30
+	sw	t2, MC_TREFRESH(t1)
+
+	/* Clear Power-down registers */
+	sw	zero, MC_SELFRFSH(t1)
+
+	/* Finally enable the controller */
+	li	t2, 1
+	sw	t2, MC_CTRLENA(t1)
+
+	j	ra
+	nop
+
+	.end	sdram_init
+
+#endif /* !CONFIG_USE_DDR_RAM */
+
+#ifdef CONFIG_USE_DDR_RAM
+/*
+ * void ddrram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	ddrram_init
+	.ent	ddrram_init
+ddrram_init:
+
+	/* DDR-DRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+
+	/* Enable DDR module in memory controller */
+	li	t3, MC_DDRRAM_ENABLE
+	lw	t2, MC_CON(t1)
+	or	t3, t2, t3
+	sw	t3, MC_CON(t1)
+
+	li	t1, MC_DDR_MODUL_BASE
+
+	/* Write configuration to DDR controller registers */
+	li	t2, MC_DC0_VALUE
+	sw	t2, MC_DC00(t1)
+
+	li	t2, MC_DC1_VALUE
+	sw	t2, MC_DC01(t1)
+
+	li	t2, MC_DC2_VALUE
+	sw	t2, MC_DC02(t1)
+
+	li	t2, MC_DC3_VALUE
+	sw	t2, MC_DC03(t1)
+
+	li	t2, MC_DC4_VALUE
+	sw	t2, MC_DC04(t1)
+
+	li	t2, MC_DC5_VALUE
+	sw	t2, MC_DC05(t1)
+
+	li	t2, MC_DC6_VALUE
+	sw	t2, MC_DC06(t1)
+
+	li	t2, MC_DC7_VALUE
+	sw	t2, MC_DC07(t1)
+
+	li	t2, MC_DC8_VALUE
+	sw	t2, MC_DC08(t1)
+
+	li	t2, MC_DC9_VALUE
+	sw	t2, MC_DC09(t1)
+
+	li	t2, MC_DC10_VALUE
+	sw	t2, MC_DC10(t1)
+
+	li	t2, MC_DC11_VALUE
+	sw	t2, MC_DC11(t1)
+
+	li	t2, MC_DC12_VALUE
+	sw	t2, MC_DC12(t1)
+
+	li	t2, MC_DC13_VALUE
+	sw	t2, MC_DC13(t1)
+
+	li	t2, MC_DC14_VALUE
+	sw	t2, MC_DC14(t1)
+
+	li	t2, MC_DC15_VALUE
+	sw	t2, MC_DC15(t1)
+
+	li	t2, MC_DC16_VALUE
+	sw	t2, MC_DC16(t1)
+
+	li	t2, MC_DC17_VALUE
+	sw	t2, MC_DC17(t1)
+
+	li	t2, MC_DC18_VALUE
+	sw	t2, MC_DC18(t1)
+
+	li	t2, MC_DC19_VALUE
+	sw	t2, MC_DC19(t1)
+
+	li	t2, MC_DC20_VALUE
+	sw	t2, MC_DC20(t1)
+
+	li	t2, MC_DC21_VALUE
+	sw	t2, MC_DC21(t1)
+
+	li	t2, MC_DC22_VALUE
+	sw	t2, MC_DC22(t1)
+
+	li	t2, MC_DC23_VALUE
+	sw	t2, MC_DC23(t1)
+
+	li	t2, MC_DC24_VALUE
+	sw	t2, MC_DC24(t1)
+
+	li	t2, MC_DC25_VALUE
+	sw	t2, MC_DC25(t1)
+
+	li	t2, MC_DC26_VALUE
+	sw	t2, MC_DC26(t1)
+
+	li	t2, MC_DC27_VALUE
+	sw	t2, MC_DC27(t1)
+
+	li	t2, MC_DC28_VALUE
+	sw	t2, MC_DC28(t1)
+
+	li	t2, MC_DC29_VALUE
+	sw	t2, MC_DC29(t1)
+
+	li	t2, MC_DC30_VALUE
+	sw	t2, MC_DC30(t1)
+
+	li	t2, MC_DC31_VALUE
+	sw	t2, MC_DC31(t1)
+
+	li	t2, MC_DC32_VALUE
+	sw	t2, MC_DC32(t1)
+
+	li	t2, MC_DC33_VALUE
+	sw	t2, MC_DC33(t1)
+
+	li	t2, MC_DC34_VALUE
+	sw	t2, MC_DC34(t1)
+
+	li	t2, MC_DC35_VALUE
+	sw	t2, MC_DC35(t1)
+
+	li	t2, MC_DC36_VALUE
+	sw	t2, MC_DC36(t1)
+
+	li	t2, MC_DC37_VALUE
+	sw	t2, MC_DC37(t1)
+
+	li	t2, MC_DC38_VALUE
+	sw	t2, MC_DC38(t1)
+
+	li	t2, MC_DC39_VALUE
+	sw	t2, MC_DC39(t1)
+
+	li	t2, MC_DC40_VALUE
+	sw	t2, MC_DC40(t1)
+
+	li	t2, MC_DC41_VALUE
+	sw	t2, MC_DC41(t1)
+
+	li	t2, MC_DC42_VALUE
+	sw	t2, MC_DC42(t1)
+
+	li	t2, MC_DC43_VALUE
+	sw	t2, MC_DC43(t1)
+
+	li	t2, MC_DC44_VALUE
+	sw	t2, MC_DC44(t1)
+
+	li	t2, MC_DC45_VALUE
+	sw	t2, MC_DC45(t1)
+
+	li	t2, MC_DC46_VALUE
+	sw	t2, MC_DC46(t1)
+
+	li	t2, 0x00000100
+	sw	t2, MC_DC03(t1)
+
+	j	ra
+	nop
+
+	.end	ddrram_init
+#endif /* CONFIG_USE_DDR_RAM */
+
+	.globl	lowlevel_init
+	.ent	lowlevel_init
+lowlevel_init:
+	/* EBU, CGU and SDRAM/DDR-RAM Initialization.
+	 */
+	move	t0, ra
+	/* We rely on the fact that non of the following ..._init() functions
+	 * modify t0
+	 */
+#if defined(CONFIG_SYS_EBU_BOOT)
+#if defined(DDR166)
+	/* 0xe8 means CPU0/CPU1 333M, DDR 167M, FPI 83M, PPE 240M */
+	li  a0,0xe8
+#elif defined(DDR133)
+	/* 0xe9 means CPU0/CPU1 333M, DDR 133M, FPI 83M, PPE 240M */
+	li  a0,0xe9
+#else /* defined(DDR111) */
+	/* 0xea means CPU0/CPU1 333M, DDR 111M, FPI 83M, PPE 240M */
+	li  a0,0xea
+#endif
+	bal	cgu_init
+	nop
+#endif /* CONFIG_SYS_EBU_BOOT */
+
+	bal	ebu_init
+	nop
+
+//06063001-joelin disable the PCI CFRAME mask-start
+#ifdef DISABLE_CFRAME
+	li  t1, PCI_CR_PCI	//mw bf103034 80000000
+	li  t2, 0x80000000
+	sw	t2,0(t1)
+
+	li  t1, PCI_CR_PCI_MOD_REG	//mw be105430 103
+	li  t2, 0x103
+	sw  t2,0(t1)
+
+	li  t1, CS_CFM			//mw b700006c 0
+	li  t2, 0x00
+	sw  t2, 0(t1)
+
+	li  t1, PCI_CR_PCI_MOD_REG	//mw be105430 103
+	li  t2, 0x1000103
+	sw  t2, 0(t1)
+#endif
+//06063001-joelin disable the PCI CFRAME mask-end
+
+#ifdef CONFIG_SYS_EBU_BOOT
+#ifndef CONFIG_SYS_RAMBOOT
+#ifdef CONFIG_USE_DDR_RAM
+	bal	ddrram_init
+	nop
+#else
+	bal	sdram_init
+	nop
+#endif
+#endif /* CONFIG_SYS_RAMBOOT */
+#endif /* CONFIG_SYS_EBU_BOOT */
+
+	move	ra, t0
+	j	ra
+	nop
+
+	.end	lowlevel_init
diff --git a/board/infineon/easy50712/pmuenable.S b/board/infineon/easy50712/pmuenable.S
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50712/pmuenable.S
@@ -0,0 +1,48 @@
+/*
+ *  Power Management unit initialization code for AMAZON development board.
+ *
+ *  Copyright (c) 2003	Ou Ke, Infineon.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+
+#define PMU_PWDCR 		0xBF10201C
+#define PMU_SR			0xBF102020
+
+	.globl	pmuenable
+
+pmuenable:
+	li      t0, PMU_PWDCR
+	li      t1, 0x2		/* enable everything */
+	sw      t1, 0(t0)
+#if 0
+1:
+	li	t0, PMU_SR
+	lw      t2, 0(t0)
+	bne     t1, t2, 1b
+	nop
+#endif
+	j	ra
+	nop
+
+
diff --git a/board/infineon/easy50812/Makefile b/board/infineon/easy50812/Makefile
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+#COBJS	:= $(BOARD).o
+COBJS-y	+= ar9.o
+
+SOBJS	= lowlevel_init.o pmuenable.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/infineon/easy50812/ar9.c b/board/infineon/easy50812/ar9.c
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/ar9.c
@@ -0,0 +1,622 @@
+/*
+* (C) Copyright 2003
+* Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+*
+* (C) Copyright 2011
+* Thomas Langer, Ralph Hempel
+*
+* See file CREDITS for list of people who contributed to this
+* project.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; either version 2 of
+* the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <asm/addrspace.h>
+#include <asm/ar9.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#if defined(CONFIG_CMD_HTTPD)
+#include <httpd.h>
+#endif
+
+extern ulong ifx_get_ddr_hz(void);
+
+/* definitions for external PHYs / Switches */
+/* Split values into phy address and register address */
+#define PHYADDR(_reg)	((_reg >> 5) & 0xff), (_reg & 0x1f)
+
+/* IDs and registers of known external switches */
+#define ID_SAMURAI_0			0x1020
+#define ID_SAMURAI_1			0x0007
+#define SAMURAI_ID_REG0			0xA0
+#define SAMURAI_ID_REG1			0xA1
+#define ID_TANTOS			0x2599
+
+#define RGMII_MODE			0
+#define MII_MODE			1
+#define REV_MII_MODE			2
+#define RED_MII_MODE_IC			3		/*Input clock */
+#define RGMII_MODE_100MB		4
+#define TURBO_REV_MII_MODE		6		/*Turbo Rev Mii mode */
+#define RED_MII_MODE_OC			7		/*Output clock */
+#define RGMII_MODE_10MB			8
+
+#define mdelay(n)   udelay((n)*1000)
+
+static void ar9_sw_chip_init(u8 port, u8 mode);
+static void ar9_enable_sw_port(u8 port, u8 state);
+static void ar9_configure_sw_port(u8 port, u8 mode);
+static u16 ar9_smi_reg_read(u16 reg);
+static u16 ar9_smi_reg_write(u16 reg, u16 data);
+static char * const name = "ltq_cpe_eth";
+static int external_switch_init(void);
+
+void _machine_restart(void)
+{
+	*AR9_RCU_RST_REQ |= AR9_RST_ALL;
+}
+
+#ifdef CONFIG_SYS_RAMBOOT
+phys_size_t initdram(int board_type)
+{
+	return get_ram_size((long *)CONFIG_SYS_SDRAM_BASE, CONFIG_SYS_MAX_RAM);
+}
+#elif defined(CONFIG_USE_DDR_RAM)
+phys_size_t initdram(int board_type)
+{
+	return (CONFIG_SYS_MAX_RAM);
+}
+#else
+
+static ulong max_sdram_size(void)     /* per Chip Select */
+{
+	/* The only supported SDRAM data width is 16bit.
+	*/
+#define CFG_DW	4
+
+	/* The only supported number of SDRAM banks is 4.
+	*/
+#define CFG_NB	4
+
+	ulong cfgpb0 = *AR9_SDRAM_MC_CFGPB0;
+	int   cols   = cfgpb0 & 0xF;
+	int   rows   = (cfgpb0 & 0xF0) >> 4;
+	ulong size   = (1 << (rows + cols)) * CFG_DW * CFG_NB;
+
+	return size;
+}
+
+/*
+* Check memory range for valid RAM. A simple memory test determines
+* the actually available RAM size between addresses `base' and
+* `base + maxsize'.
+*/
+
+static long int dram_size(long int *base, long int maxsize)
+{
+	volatile long int *addr;
+	ulong cnt, val;
+	ulong save[32];			/* to make test non-destructive */
+	unsigned char i = 0;
+
+	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
+		addr = base + cnt;		/* pointer arith! */
+
+		save[i++] = *addr;
+		*addr = ~cnt;
+	}
+
+	/* write 0 to base address */
+	addr = base;
+	save[i] = *addr;
+	*addr = 0;
+
+	/* check at base address */
+	if ((val = *addr) != 0) {
+		*addr = save[i];
+		return (0);
+	}
+
+	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
+		addr = base + cnt;		/* pointer arith! */
+
+		val = *addr;
+		*addr = save[--i];
+
+		if (val != (~cnt)) {
+			return (cnt * sizeof (long));
+		}
+	}
+	return (maxsize);
+}
+
+phys_size_t initdram(int board_type)
+{
+	int   rows, cols, best_val = *AR9_SDRAM_MC_CFGPB0;
+	ulong size, max_size       = 0;
+	ulong our_address;
+
+	/* load t9 into our_address */
+	asm volatile ("move %0, $25" : "=r" (our_address) :);
+
+	/* Can't probe for RAM size unless we are running from Flash.
+	* find out whether running from DRAM or Flash.
+	*/
+	if (CPHYSADDR(our_address) < CPHYSADDR(PHYS_FLASH_1))
+	{
+		return max_sdram_size();
+	}
+
+	for (cols = 0x8; cols <= 0xC; cols++)
+	{
+		for (rows = 0xB; rows <= 0xD; rows++)
+		{
+			*AR9_SDRAM_MC_CFGPB0 = (0x14 << 8) |
+											(rows << 4) | cols;
+			size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
+											max_sdram_size());
+
+			if (size > max_size)
+			{
+				best_val = *AR9_SDRAM_MC_CFGPB0;
+				max_size = size;
+			}
+		}
+	}
+
+	*AR9_SDRAM_MC_CFGPB0 = best_val;
+	return max_size;
+}
+#endif
+
+int checkboard (void)
+{
+	unsigned long chipid = *AR9_MPS_CHIPID;
+	int part_num;
+
+	puts ("Board: ");
+
+	part_num = AR9_MPS_CHIPID_PARTNUM_GET(chipid);
+	switch (part_num)
+	{
+	case 0x16C:
+		puts("ARX188 ");
+		break;
+	case 0x16D:
+		puts("ARX168 ");
+		break;
+	case 0x16F:
+		puts("ARX182 ");
+		break;
+	case 0x170:
+		puts("GRX188 ");
+		break;
+	case 0x171:
+		puts("GRX168 ");
+		break;
+	default:
+		printf ("unknown, chip part number 0x%03X ", part_num);
+		break;
+	}
+	printf ("V1.%ld, ", AR9_MPS_CHIPID_VERSION_GET(chipid));
+
+	printf("DDR Speed %ld MHz, ", ifx_get_ddr_hz()/1000000);
+	printf("CPU Speed %ld MHz\n", get_cpuclk()/1000000);
+
+	return 0;
+}
+
+#ifdef CONFIG_SKIP_LOWLEVEL_INIT
+int board_early_init_f(void)
+{
+#ifdef CONFIG_EBU_ADDSEL0
+	(*AR9_EBU_ADDSEL0) = CONFIG_EBU_ADDSEL0;
+#endif
+#ifdef CONFIG_EBU_ADDSEL1
+	(*AR9_EBU_ADDSEL1) = CONFIG_EBU_ADDSEL1;
+#endif
+#ifdef CONFIG_EBU_ADDSEL2
+	(*AR9_EBU_ADDSEL2) = CONFIG_EBU_ADDSEL2;
+#endif
+#ifdef CONFIG_EBU_ADDSEL3
+	(*AR9_EBU_ADDSEL3) = CONFIG_EBU_ADDSEL3;
+#endif
+#ifdef CONFIG_EBU_BUSCON0
+	(*AR9_EBU_BUSCON0) = CONFIG_EBU_BUSCON0;
+#endif
+#ifdef CONFIG_EBU_BUSCON1
+	(*AR9_EBU_BUSCON1) = CONFIG_EBU_BUSCON1;
+#endif
+#ifdef CONFIG_EBU_BUSCON2
+	(*AR9_EBU_BUSCON2) = CONFIG_EBU_BUSCON2;
+#endif
+#ifdef CONFIG_EBU_BUSCON3
+	(*AR9_EBU_BUSCON3) = CONFIG_EBU_BUSCON3;
+#endif
+
+	return 0;
+}
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_IFX_ETOP)
+
+	*AR9_PMU_PWDCR &= 0xFFFFEFDF;
+	*AR9_PMU_PWDCR &= ~AR9_PMU_DMA; /* enable DMA from PMU */
+
+	if (ltq_eth_initialize(bis) < 0)
+		return -1;
+
+	*AR9_RCU_RST_REQ |= 1;
+	udelay(200000);
+	*AR9_RCU_RST_REQ &= (unsigned long)~1;
+	udelay(1000);
+
+#ifdef CONFIG_EXTRA_SWITCH
+	if (external_switch_init()<0)
+		return -1;
+#endif /* CONFIG_EXTRA_SWITCH */
+#endif /* CONFIG_IFX_ETOP */
+
+	return 0;
+}
+
+static void ar9_configure_sw_port(u8 port, u8 mode)
+{
+	if(port)
+	{
+		if (mode  == 1) //MII mode
+		{
+			*AR9_GPIO_P2_ALTSEL0 = *AR9_GPIO_P2_ALTSEL0 | (0xf000);
+			*AR9_GPIO_P2_ALTSEL1 = *AR9_GPIO_P2_ALTSEL1 & ~(0xf000);
+			*AR9_GPIO_P2_DIR = (*AR9_GPIO_P2_DIR & ~(0xf000)) | 0x2000;
+			*AR9_GPIO_P2_OD = *AR9_GPIO_P2_OD | 0x2000;
+		}
+		else if(mode == 2 || mode == 6) //Rev Mii mode
+		{
+			*AR9_GPIO_P2_ALTSEL0 = *AR9_GPIO_P2_ALTSEL0 | (0xf000);
+			*AR9_GPIO_P2_ALTSEL1 = *AR9_GPIO_P2_ALTSEL1 & ~(0xf000);
+			*AR9_GPIO_P2_DIR = (*AR9_GPIO_P2_DIR | (0xf000)) & ~0x2000;
+			*AR9_GPIO_P2_OD = *AR9_GPIO_P2_OD | 0xd000;
+		}
+	}
+	else //Port 0
+	{
+		if (mode  == 1) //MII mode
+		{
+			*AR9_GPIO_P2_ALTSEL0 = *AR9_GPIO_P2_ALTSEL0 | (0x0303);
+			*AR9_GPIO_P2_ALTSEL1 = *AR9_GPIO_P2_ALTSEL1 & ~(0x0303);
+			*AR9_GPIO_P2_DIR = (*AR9_GPIO_P2_DIR & ~(0x0303)) | 0x0100;
+			*AR9_GPIO_P2_OD = *AR9_GPIO_P2_OD | 0x0100;
+		}
+		else if(mode ==2 || mode ==6) //Rev Mii mode
+		{
+			*AR9_GPIO_P2_ALTSEL0 = *AR9_GPIO_P2_ALTSEL0 | (0x0303);
+			*AR9_GPIO_P2_ALTSEL1 = *AR9_GPIO_P2_ALTSEL1 & ~(0x0303);
+			*AR9_GPIO_P2_DIR = (*AR9_GPIO_P2_DIR | (0x0303)) & ~0x0100;
+			*AR9_GPIO_P2_OD = *AR9_GPIO_P2_OD | 0x0203;
+		}
+	}
+}
+
+/*
+Call this function to place either MAC port 0 or 1 into working mode.
+Parameters:
+port - select ports 0 or 1.
+state of interface : state
+0: RGMII
+1: MII
+2: Rev MII
+3: Reduce MII (input clock)
+4: RGMII 100mb
+5: Reserve
+6: Turbo Rev MII
+7: Reduce MII (output clock)
+*/
+void ar9_enable_sw_port(u8 port, u8 state)
+{
+	REG32(AR9_SW_GCTL0) |= 0x80000000;
+	if (port == 0)
+	{
+		REG32(AR9_SW_RGMII_CTL) &= 0xffcffc0e ;
+	//#if AR9_REFBOARD_TANTOS
+		REG32(0xbf20302c) &= 0xffff81ff;
+		REG32(0xbf20302c) |= 4<<9 ;
+	//#endif
+		REG32(AR9_SW_RGMII_CTL) |= ((u32)(state &0x3))<<8;
+		if((state &0x3) == 0)
+		{
+			REG32(AR9_SW_RGMII_CTL) &= 0xfffffff3;
+			if(state == 4)
+				REG32(AR9_SW_RGMII_CTL) |= 0x4;
+			else
+				REG32(AR9_SW_RGMII_CTL) |= 0x8;
+		}
+		if(state == 6)
+			REG32(AR9_SW_RGMII_CTL) |= ((u32) (1<<20));
+		if(state == 7)
+			REG32(AR9_SW_RGMII_CTL) |= ((u32) (1<<21));
+	}
+//  *AR9_PPE32_ETOP_CFG = *AR9_PPE32_ETOP_CFG & 0xfffffffe;
+	else
+	{
+		REG32(AR9_SW_RGMII_CTL) &= 0xff303fff ;
+		REG32(AR9_SW_RGMII_CTL) |= ((u32)(state &0x3))<<18;
+		if((state &0x3) == 0)
+		{
+			REG32(AR9_SW_RGMII_CTL) &= 0xffffcfff;
+			if(state == 4)
+				REG32(AR9_SW_RGMII_CTL) |= 0x1000;
+			else
+				REG32(AR9_SW_RGMII_CTL) |= 0x2000;
+		}
+		if(state == 6)
+			REG32(AR9_SW_RGMII_CTL) |= ((u32) (1<<22));
+		if(state == 7)
+			REG32(AR9_SW_RGMII_CTL) |= ((u32) (1<<23));
+	}
+}
+
+void pci_reset(void)
+{
+	int i,j;
+#define AR9_V1_PCI_RST_FIX 1
+#if AR9_V1_PCI_RST_FIX // 5th June 2008 Add GPIO19 to control EJTAG_TRST
+	*AR9_GPIO_P1_ALTSEL0 = *AR9_GPIO_P1_ALTSEL0 & ~0x8;
+	*AR9_GPIO_P1_ALTSEL1 = *AR9_GPIO_P1_ALTSEL1 & ~0x8;
+	*AR9_GPIO_P1_DIR = *AR9_GPIO_P1_DIR | 0x8;
+	*AR9_GPIO_P1_OD = *AR9_GPIO_P1_OD | 0x8;
+	*AR9_GPIO_P1_OUT = *AR9_GPIO_P1_OUT | 0x8;
+	*AR9_GPIO_P0_ALTSEL0 = *AR9_GPIO_P0_ALTSEL0 & ~0x4000;
+	*AR9_GPIO_P0_ALTSEL1 = *AR9_GPIO_P0_ALTSEL1 & ~0x4000;
+	*AR9_GPIO_P0_DIR = *AR9_GPIO_P0_DIR | 0x4000;
+	*AR9_GPIO_P0_OD = *AR9_GPIO_P0_OD | 0x4000;
+	for(j=0;j<5;j++) {
+		*AR9_GPIO_P0_OUT = *AR9_GPIO_P0_OUT & ~0x4000;
+		for(i=0;i<0x10000;i++);
+		*AR9_GPIO_P0_OUT = *AR9_GPIO_P0_OUT | 0x4000;
+		for(i=0;i<0x10000;i++);
+	}
+	*AR9_GPIO_P0_DIR = *AR9_GPIO_P0_DIR &  ~0x4000;
+	*AR9_GPIO_P1_DIR = *AR9_GPIO_P1_DIR &  ~0x8;
+#endif
+}
+
+static u16 ar9_smi_reg_read(u16 reg)
+{
+	int i;
+	while(REG32(AR9_SW_MDIO_CTL) & 0x8000);
+	REG32(AR9_SW_MDIO_CTL) = 0x8000| 0x2<<10 | ((u32) (reg&0x3ff)) ; /*0x10=MDIO_OP_READ*/
+	for(i=0;i<0x3fff;i++);
+	udelay(50);
+        while(REG32(AR9_SW_MDIO_CTL) & 0x8000);
+	return((u16) (REG32(AR9_SW_MDIO_DATA)));
+}
+
+static u16 ar9_smi_reg_write(u16 reg, u16 data)
+{
+	int i;
+
+	while(REG32(AR9_SW_MDIO_CTL) & 0x8000);
+
+	REG32(AR9_SW_MDIO_CTL) = 0x8000| (((u32) data)<<16) | 0x01<<10 | ((u32) (reg&0x3ff)) ; /*0x01=MDIO_OP_WRITE*/
+
+	/* let the external device apply changes */
+	mdelay(10);
+
+	return 0;
+}
+
+static void ar9_sw_chip_init(u8 port, u8 mode)
+{
+	int i;
+	u16 chipid;
+
+	debug("\nsearching for switches ... ");
+
+	asm("sync");
+	pci_reset();
+
+	/* 25mhz clock out */
+	*AR9_CGU_IFCCR &= ~(3<<10);
+	*AR9_GPIO_P0_ALTSEL0 = *AR9_GPIO_P0_ALTSEL0 | (1<<3);
+	*AR9_GPIO_P0_ALTSEL1 = *AR9_GPIO_P0_ALTSEL1 & ~(1<<3);
+	*AR9_GPIO_P0_DIR = *AR9_GPIO_P0_DIR  | (1<<3);
+	*AR9_GPIO_P0_OD = *AR9_GPIO_P0_OD | (1<<3);
+	*AR9_GPIO_P2_ALTSEL0 = *AR9_GPIO_P2_ALTSEL0 & ~(1<<0);
+	*AR9_GPIO_P2_ALTSEL1 = *AR9_GPIO_P2_ALTSEL1 & ~(1<<0);
+	*AR9_GPIO_P2_DIR = *AR9_GPIO_P2_DIR  | (1<<0);
+	*AR9_GPIO_P2_OD = *AR9_GPIO_P2_OD | (1<<0);
+
+	*AR9_PMU_PWDCR = (*AR9_PMU_PWDCR & 0xFFFBDFDF) ; 
+	*AR9_PMU_PWDCR = (*AR9_PMU_PWDCR & ~(AR9_PMU_DMA | AR9_PMU_SWITCH));
+	*AR9_PMU_PWDCR = (*AR9_PMU_PWDCR | AR9_PMU_USB0 | AR9_PMU_USB0_P);
+
+	*AR9_GPIO_P2_OUT &= ~(1<<0);
+	asm("sync");
+
+	ar9_configure_sw_port(port, mode);
+	ar9_enable_sw_port(port, mode);
+	REG32(AR9_SW_P0_CTL) |= 0x400000; /* disable mdio polling for tantos */
+	asm("sync");
+
+	/*GPIO 55(P3.7) used as output, set high*/
+	*AR9_GPIO_P3_OD |=(1<<7);
+	*AR9_GPIO_P3_DIR |= (1<<7);
+	*AR9_GPIO_P3_ALTSEL0 &=~(1<<7);
+	*AR9_GPIO_P3_ALTSEL1 &=~(1<<7);
+	asm("sync");
+	udelay(10);
+
+	*AR9_GPIO_P3_OUT &= ~(1<<7);
+	for(i=0;i<1000;i++)
+		udelay(110);
+	*AR9_GPIO_P3_OUT |=(1<<7);
+	udelay(100);
+
+	if(port==0)
+		REG32(AR9_SW_P0_CTL) |= 0x40001;
+	else
+		REG32(AR9_SW_P1_CTL) |= 0x40001;
+
+	REG32(AR9_SW_P2_CTL) |= 0x40001;
+	REG32(AR9_SW_PMAC_HD_CTL) |= 0x40000; /* enable CRC */
+
+	*AR9_GPIO_P2_ALTSEL0 = *AR9_GPIO_P2_ALTSEL0 | (0xc00);
+	*AR9_GPIO_P2_ALTSEL1 = *AR9_GPIO_P2_ALTSEL1 & ~(0xc00);
+	*AR9_GPIO_P2_DIR = *AR9_GPIO_P2_DIR  | 0xc00;
+	*AR9_GPIO_P2_OD = *AR9_GPIO_P2_OD | 0xc00;
+
+	asm("sync");
+	chipid = (unsigned short)(ar9_smi_reg_read(0x101));
+	printf("\nswitch chip id=%08x\n",chipid);
+	if (chipid != ID_TANTOS) {
+		debug("whatever detected\n");
+		ar9_smi_reg_write(0x1,0x840f);
+		ar9_smi_reg_write(0x3,0x840f);
+		ar9_smi_reg_write(0x5,0x840f);
+		ar9_smi_reg_write(0x7,0x840f);
+		ar9_smi_reg_write(0x8,0x840f);
+		ar9_smi_reg_write(0x12,0x3602);
+#ifdef CLK_OUT2_25MHZ
+		ar9_smi_reg_write(0x33,0x4000);
+#endif
+	} else { // Tantos switch ship
+		debug("Tantos switch detected\n");
+		ar9_smi_reg_write(0xa1,0x0004); /*port 5 force link up*/
+		ar9_smi_reg_write(0xc1,0x0004); /*port 6 force link up*/
+		ar9_smi_reg_write(0xf5,0x0BBB); /*port 4 duplex mode, flow control enable,1000Mbit/s*/
+										/*port 5 duplex mode, flow control enable, 1000Mbit/s*/
+										/*port 6 duplex mode, flow control enable, 1000Mbit/s*/
+	}
+	asm("sync");
+
+	/*reset GPHY*/
+	mdelay(200);
+	*AR9_RCU_RST_REQ |= (AR9_RCU_RST_REQ_DMA | AR9_RCU_RST_REQ_PPE) ;
+	udelay(50);
+	*AR9_GPIO_P2_OUT |= (1<<0);
+}
+
+static void ar9_dma_init(void)
+{
+	/* select port */
+	*AR9_DMA_PS = 0;
+
+	/* 
+	TXWGT 14:12 rw Port Weight for Transmit Direction (the default value 001)
+
+	TXENDI 11:10 rw Endianness for Transmit Direction
+	Determine a byte swap between memory interface (left hand side) and
+	peripheral interface (right hand side).
+	00B B0_B1_B2_B3 No byte switching
+	01B B1_B0_B3_B2 B0B1B2B3 => B1B0B3B2
+	10B B2_B3_B0_B1 B0B1B2B3 => B2B3B0B1
+	
+	RXENDI 9:8 rw Endianness for Receive Direction
+	Determine a byte swap between peripheral (left hand side) and memory
+	interface (right hand side).
+	00B B0_B1_B2_B3 No byte switching
+	01B B1_B0_B3_B2 B0B1B2B3 => B1B0B3B2
+	10B B2_B3_B0_B1 B0B1B2B3 => B2B3B0B1
+	11B B3_B2_B1_B0 B0B1B2B3 => B3B2B1B0 
+
+	TXBL 5:4 rw Burst Length for Transmit Direction
+	Selects burst length for TX direction.
+	Others are reserved and will result in 2_WORDS burst length.
+	01B 2_WORDS 2 words
+	10B 4_WORDS 4 words
+	11B 8_WORDS 8 words
+
+	RXBL 3:2 rw Burst Length for Receive Direction
+	Selects burst length for RX direction.
+	Others are reserved and will result in 2_WORDS burst length.
+	01B 2_WORDS 2 words
+	10B 4_WORDS 4 words
+	11B 8_WORDS 8 words	
+	*/
+	*AR9_DMA_PCTRL = 0x1f28;
+}
+
+#ifdef CONFIG_EXTRA_SWITCH
+static int external_switch_init(void)
+{
+	ar9_sw_chip_init(0, RGMII_MODE);
+
+	ar9_dma_init();
+
+	return 0;
+}
+#endif /* CONFIG_EXTRA_SWITCH */
+
+#if defined(CONFIG_CMD_HTTPD)
+int do_http_upgrade(const unsigned char *data, const ulong size)
+{
+	char buf[128];
+
+	if(getenv ("ram_addr") == NULL)
+		return -1;
+	if(getenv ("kernel_addr") == NULL)
+		return -1;
+	/* check the image */
+	if(run_command("imi ${ram_addr}", 0) < 0) {
+		return -1;
+	}
+	/* write the image to the flash */
+	puts("http ugrade ...\n");
+	sprintf(buf, "era ${kernel_addr} +0x%lx; cp.b ${ram_addr} ${kernel_addr} 0x%lx", size, size);
+	return run_command(buf, 0);
+}
+
+int do_http_progress(const int state)
+{
+	/* toggle LED's here */
+	switch(state) {
+		case HTTP_PROGRESS_START:
+		puts("http start\n");
+		break;
+		case HTTP_PROGRESS_TIMEOUT:
+		puts(".");
+		break;
+		case HTTP_PROGRESS_UPLOAD_READY:
+		puts("http upload ready\n");
+		break;
+		case HTTP_PROGRESS_UGRADE_READY:
+		puts("http ugrade ready\n");
+		break;
+		case HTTP_PROGRESS_UGRADE_FAILED:
+		puts("http ugrade failed\n");
+		break;
+	}
+	return 0;
+}
+
+unsigned long do_http_tmp_address(void)
+{
+	char *s = getenv ("ram_addr");
+	if (s) {
+		ulong tmp = simple_strtoul (s, NULL, 16);
+		return tmp;
+	}
+	return 0 /*0x80a00000*/;
+}
+
+#endif
diff --git a/board/infineon/easy50812/ar9_ddr111_settings.h b/board/infineon/easy50812/ar9_ddr111_settings.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/ar9_ddr111_settings.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Samsung DDR K4H561638H Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x306
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x139  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0x2200
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x59   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x514
+#define MC_DC29_VALUE	0x2d93
+#define MC_DC30_VALUE	0x8235
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x600
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50812/ar9_ddr166_settings.h b/board/infineon/easy50812/ar9_ddr166_settings.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/ar9_ddr166_settings.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Samsung DDR K4H561638H Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x306
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x13f  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0x2200
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1600
+#define MC_DC22_VALUE	0x1616
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5d   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x514
+#define MC_DC29_VALUE	0x2d93
+#define MC_DC30_VALUE	0x8235
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x600
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50812/ar9_ddr196_settings.h b/board/infineon/easy50812/ar9_ddr196_settings.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/ar9_ddr196_settings.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Samsung DDR K4H561638H Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x306
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x80B
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xD02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x144  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xF
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1200
+#define MC_DC22_VALUE	0x1212
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x66   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x5FB
+#define MC_DC29_VALUE	0x35DF
+#define MC_DC30_VALUE	0x99E9
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x600
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50812/ar9_ddr221_settings.h b/board/infineon/easy50812/ar9_ddr221_settings.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/ar9_ddr221_settings.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for AR9 Ref Board DDR 221 Mhz - by Ng Aik Ann 16th May 2008 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x306
+#define MC_DC7_VALUE	0x403
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x90c
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xf02
+#define MC_DC12_VALUE	0x2c8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x12f  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xc800
+#define MC_DC17_VALUE	0xf
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1500
+#define MC_DC22_VALUE	0x1515
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x57   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x6b8
+#define MC_DC29_VALUE	0x3c84
+#define MC_DC30_VALUE	0xace5
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x600
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50812/ar9_ddr250_settings.h b/board/infineon/easy50812/ar9_ddr250_settings.h
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/ar9_ddr250_settings.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for AR9 Ref Board DDR 221 Mhz - by Ng Aik Ann 16th May 2008 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x306
+#define MC_DC7_VALUE	0x403
+#define MC_DC8_VALUE	0x103
+#define MC_DC9_VALUE	0xb0e
+#define MC_DC10_VALUE	0x204
+#define MC_DC11_VALUE	0x1102
+#define MC_DC12_VALUE	0x2c8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x155  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xc800
+#define MC_DC17_VALUE	0x13
+#define MC_DC18_VALUE	0x401
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0xc00
+#define MC_DC22_VALUE	0xc0c
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x74   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x798
+#define MC_DC29_VALUE	0x445d
+#define MC_DC30_VALUE	0xc351
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x600
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
diff --git a/board/infineon/easy50812/lowlevel_init.S b/board/infineon/easy50812/lowlevel_init.S
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/lowlevel_init.S
@@ -0,0 +1,543 @@
+/*
+ *  Memory sub-system initialization code for AR9 board.
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *  Copyright (c) 2005	Andre Messerschmidt  Infineon
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/* History:
+      peng liu May 25, 2006, for PLL setting after reset, 05252006
+ */
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+
+#if defined(CONFIG_USE_DDR_RAM)
+
+#if defined(CONFIG_CPU_111M_RAM_111M) || defined(CONFIG_CPU_333M_RAM_111M)
+#	include "ar9_ddr111_settings.h"  
+#elif defined(CONFIG_CPU_166M_RAM_166M) || defined(CONFIG_CPU_333M_RAM_166M) || defined(CONFIG_CPU_500M_RAM_166M) 
+#	include "ar9_ddr166_settings.h"
+#elif defined(CONFIG_CPU_442M_RAM_147M)
+#	include "ar9_ddr166_settings.h"
+#elif defined(CONFIG_CPU_393M_RAM_196M)
+#	ifdef CONFIG_ETRON_RAM
+#		include "etron_ddr196_settings.h"
+#	else
+#		include "ar9_ddr196_settings.h"
+#	endif
+#elif defined(CONFIG_CPU_442M_RAM_221M)
+#	include "ar9_ddr221_settings.h"
+#elif defined(CONFIG_CPU_500M_RAM_250M)
+#	include "ar9_ddr250_settings.h"
+#else
+#	warning "missing definition for ddr_settings.h, use default!"
+#	include "ar9_ddr_settings.h"
+#endif
+#endif /* CONFIG_USE_DDR_RAM */
+
+#if defined(CONFIG_USE_DDR_RAM) && !defined(MC_DC0_VALUE)
+#error "missing include of ddr_settings.h"
+#endif
+
+#define EBU_MODUL_BASE		0xBE105300
+#define EBU_CLC(value)		0x0000(value)
+#define EBU_CON(value)		0x0010(value)
+#define EBU_ADDSEL0(value)	0x0020(value)
+#define EBU_ADDSEL1(value)	0x0024(value)
+#define EBU_ADDSEL2(value)	0x0028(value)
+#define EBU_ADDSEL3(value)	0x002C(value)
+#define EBU_BUSCON0(value)	0x0060(value)
+#define EBU_BUSCON1(value)	0x0064(value)
+#define EBU_BUSCON2(value)	0x0068(value)
+#define EBU_BUSCON3(value)	0x006C(value)
+
+#define MC_MODUL_BASE		0xBF800000
+#define MC_ERRCAUSE(value)	0x0010(value)
+#define MC_ERRADDR(value)	0x0020(value)
+#define MC_CON(value)		0x0060(value)
+
+#define MC_SRAM_ENABLE		0x00000004
+#define MC_SDRAM_ENABLE		0x00000002
+#define MC_DDRRAM_ENABLE	0x00000001
+
+#define MC_SDR_MODUL_BASE	0xBF800200
+#define MC_IOGP(value)		0x0000(value)
+#define MC_CTRLENA(value)	0x0010(value)
+#define MC_MRSCODE(value)	0x0020(value)
+#define MC_CFGDW(value)		0x0030(value)
+#define MC_CFGPB0(value)	0x0040(value)
+#define MC_LATENCY(value)	0x0080(value)
+#define MC_TREFRESH(value)	0x0090(value)
+#define MC_SELFRFSH(value)	0x00A0(value)
+
+#define MC_DDR_MODUL_BASE	0xBF801000
+#define MC_DC00(value)		0x0000(value)
+#define MC_DC01(value)		0x0010(value)
+#define MC_DC02(value)		0x0020(value)
+#define MC_DC03(value)		0x0030(value)
+#define MC_DC04(value)		0x0040(value)
+#define MC_DC05(value)		0x0050(value)
+#define MC_DC06(value)		0x0060(value)
+#define MC_DC07(value)		0x0070(value)
+#define MC_DC08(value)		0x0080(value)
+#define MC_DC09(value)		0x0090(value)
+#define MC_DC10(value)		0x00A0(value)
+#define MC_DC11(value)		0x00B0(value)
+#define MC_DC12(value)		0x00C0(value)
+#define MC_DC13(value)		0x00D0(value)
+#define MC_DC14(value)		0x00E0(value)
+#define MC_DC15(value)		0x00F0(value)
+#define MC_DC16(value)		0x0100(value)
+#define MC_DC17(value)		0x0110(value)
+#define MC_DC18(value)		0x0120(value)
+#define MC_DC19(value)		0x0130(value)
+#define MC_DC20(value)		0x0140(value)
+#define MC_DC21(value)		0x0150(value)
+#define MC_DC22(value)		0x0160(value)
+#define MC_DC23(value)		0x0170(value)
+#define MC_DC24(value)		0x0180(value)
+#define MC_DC25(value)		0x0190(value)
+#define MC_DC26(value)		0x01A0(value)
+#define MC_DC27(value)		0x01B0(value)
+#define MC_DC28(value)		0x01C0(value)
+#define MC_DC29(value)		0x01D0(value)
+#define MC_DC30(value)		0x01E0(value)
+#define MC_DC31(value)		0x01F0(value)
+#define MC_DC32(value)		0x0200(value)
+#define MC_DC33(value)		0x0210(value)
+#define MC_DC34(value)		0x0220(value)
+#define MC_DC35(value)		0x0230(value)
+#define MC_DC36(value)		0x0240(value)
+#define MC_DC37(value)		0x0250(value)
+#define MC_DC38(value)		0x0260(value)
+#define MC_DC39(value)		0x0270(value)
+#define MC_DC40(value)		0x0280(value)
+#define MC_DC41(value)		0x0290(value)
+#define MC_DC42(value)		0x02A0(value)
+#define MC_DC43(value)		0x02B0(value)
+#define MC_DC44(value)		0x02C0(value)
+#define MC_DC45(value)		0x02D0(value)
+#define MC_DC46(value)		0x02E0(value)
+
+#define RCU_OFFSET  0xBF203000
+#define RCU_RST_REQ      (RCU_OFFSET + 0x0010)
+#define RCU_STS          (RCU_OFFSET + 0x0014)
+
+#define CGU_OFFSET  0xBF103000
+#define  PLL0_CFG     (CGU_OFFSET + 0x0004)
+#define  PLL1_CFG     (CGU_OFFSET + 0x0008)
+#define  PLL2_CFG     (CGU_OFFSET + 0x000C)
+#define  CGU_SYS      (CGU_OFFSET + 0x0010)
+#define  CGU_UPDATE   (CGU_OFFSET + 0x0014)
+#define  IF_CLK       (CGU_OFFSET + 0x0018)
+#define  CGU_SMD      (CGU_OFFSET + 0x0020)
+#define  CGU_CT1SR    (CGU_OFFSET + 0x0028)
+#define  CGU_CT2SR    (CGU_OFFSET + 0x002C)
+#define  CGU_PCMCR    (CGU_OFFSET + 0x0030)
+#define  PCI_CR_PCI   (CGU_OFFSET + 0x0034)
+#define  CGU_OSC_CTRL (CGU_OFFSET + 0x001C)
+#define  CGU_MIPS_PWR_DWN (CGU_OFFSET + 0x0038)
+#define  CLK_MEASURE  (CGU_OFFSET + 0x003C)
+
+#define  pll1_36MHz_CONFIG 0x9800f25f
+
+	.set	noreorder
+
+
+/*
+ * void ebu_init(void)
+ */
+	.globl	ebu_init
+	.ent	ebu_init
+ebu_init:
+
+#if defined(CONFIG_EBU_ADDSEL0) || defined(CONFIG_EBU_ADDSEL1) || \
+	defined(CONFIG_EBU_ADDSEL2) || defined(CONFIG_EBU_ADDSEL3) || \
+	defined(CONFIG_EBU_BUSCON0) || defined(CONFIG_EBU_BUSCON1) || \
+	defined(CONFIG_EBU_BUSCON2) || defined(CONFIG_EBU_BUSCON3)
+
+	li	t1, EBU_MODUL_BASE
+#if defined(CONFIG_EBU_ADDSEL0)
+	li	t2, CONFIG_EBU_ADDSEL0
+	sw	t2, EBU_ADDSEL0(t1)
+#endif
+#if defined(CONFIG_EBU_ADDSEL1)
+	li	t2, CONFIG_EBU_ADDSEL1
+	sw	t2, EBU_ADDSEL1(t1)
+#endif
+#if defined(CONFIG_EBU_ADDSEL2)
+	li	t2, CONFIG_EBU_ADDSEL2
+	sw	t2, EBU_ADDSEL2(t1)
+#endif
+#if defined(CONFIG_EBU_ADDSEL3)
+	li	t2, CONFIG_EBU_ADDSEL3
+	sw	t2, EBU_ADDSEL3(t1)
+#endif
+
+#if defined(CONFIG_EBU_BUSCON0)
+	li	t2, CONFIG_EBU_BUSCON0
+	sw	t2, EBU_BUSCON0(t1)
+#endif
+#if defined(CONFIG_EBU_BUSCON1)
+	li	t2, CONFIG_EBU_BUSCON1
+	sw	t2, EBU_BUSCON1(t1)
+#endif
+#if defined(CONFIG_EBU_BUSCON2)
+	li	t2, CONFIG_EBU_BUSCON2
+	sw	t2, EBU_BUSCON2(t1)
+#endif
+#if defined(CONFIG_EBU_BUSCON3)
+	li	t2, CONFIG_EBU_BUSCON3
+	sw	t2, EBU_BUSCON3(t1)
+#endif
+
+#endif
+
+	j	ra
+	nop
+
+	.end	ebu_init
+
+
+/*
+ * void cgu_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	cgu_init
+	.ent	cgu_init
+cgu_init:
+        li  t2, CGU_SYS
+        lw  t2,0(t2)
+        beq t2,a0,freq_up2date
+        nop
+        li  t1, CGU_SYS
+        sw	a0,0(t1)
+
+#if defined(CONFIG_CPU_333M_RAM_166M) && defined(CONFIG_USE_PLL1)
+        li  t1, PLL1_CFG
+        li  a1, pll1_36MHz_CONFIG
+        sw  a1, 0(t1)
+#endif
+
+#if defined(CONFIG_CLASS_II_DDR_PAD) 
+        li  t1, CGU_SMD
+        li  a1, 0x200000
+        sw  a1, 0(t1)      // Turn on DDR PAD Class II to INC drive.
+#endif
+
+        li  t1, RCU_RST_REQ
+        li  t2, 0x40000008
+        sw	t2,0(t1)
+        b   wait_reset
+        nop
+
+wait_reset:
+        b   wait_reset
+        nop
+
+freq_up2date:
+        j ra
+        nop
+	.end	cgu_init
+
+
+#ifndef CONFIG_USE_DDR_RAM
+/*
+ * void sdram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	sdram_init
+	.ent	sdram_init
+sdram_init:
+
+	/* SDRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+
+	/* Enable SDRAM module in memory controller */
+	li	t3, MC_SDRAM_ENABLE
+	lw	t2, MC_CON(t1)
+	or	t3, t2, t3
+	sw	t3, MC_CON(t1)
+
+	li	t1, MC_SDR_MODUL_BASE
+
+	/* disable the controller */
+	li	t2, 0
+	sw	t2, MC_CTRLENA(t1)
+
+	li	t2, 0x822
+	sw	t2, MC_IOGP(t1)
+
+	li	t2, 0x2
+	sw	t2, MC_CFGDW(t1)
+
+	/* Set CAS Latency */
+	li	t2, 0x00000020
+	sw	t2, MC_MRSCODE(t1)
+
+	/* Set CS0 to SDRAM parameters */
+	li	t2, 0x000014d8
+	sw	t2, MC_CFGPB0(t1)
+
+	/* Set SDRAM latency parameters */
+	li  	t2, 0x00036325;   /* BC PC100 */
+	sw	t2, MC_LATENCY(t1)
+
+	/* Set SDRAM refresh rate */
+	li	t2, 0x00000C30
+	sw	t2, MC_TREFRESH(t1)
+
+	/* Clear Power-down registers */
+	sw	zero, MC_SELFRFSH(t1)
+
+	/* Finally enable the controller */
+	li	t2, 1
+	sw	t2, MC_CTRLENA(t1)
+
+	j	ra
+	nop
+
+	.end	sdram_init
+
+#endif /* !CONFIG_USE_DDR_RAM */
+
+#ifdef CONFIG_USE_DDR_RAM
+/*
+ * void ddrram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	ddrram_init
+	.ent	ddrram_init
+ddrram_init:
+
+	/* DDR-DRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+
+	/* Enable DDR module in memory controller */
+	li	t3, MC_DDRRAM_ENABLE
+	lw	t2, MC_CON(t1)
+	or	t3, t2, t3
+	sw	t3, MC_CON(t1)
+
+	li	t1, MC_DDR_MODUL_BASE
+
+	/* Write configuration to DDR controller registers */
+	li	t2, MC_DC0_VALUE
+	sw	t2, MC_DC00(t1)
+
+	li	t2, MC_DC1_VALUE
+	sw	t2, MC_DC01(t1)
+
+	li	t2, MC_DC2_VALUE
+	sw	t2, MC_DC02(t1)
+
+	li	t2, MC_DC3_VALUE
+	sw	t2, MC_DC03(t1)
+
+	li	t2, MC_DC4_VALUE
+	sw	t2, MC_DC04(t1)
+
+	li	t2, MC_DC5_VALUE
+	sw	t2, MC_DC05(t1)
+
+	li	t2, MC_DC6_VALUE
+	sw	t2, MC_DC06(t1)
+
+	li	t2, MC_DC7_VALUE
+	sw	t2, MC_DC07(t1)
+
+	li	t2, MC_DC8_VALUE
+	sw	t2, MC_DC08(t1)
+
+	li	t2, MC_DC9_VALUE
+	sw	t2, MC_DC09(t1)
+
+	li	t2, MC_DC10_VALUE
+	sw	t2, MC_DC10(t1)
+
+	li	t2, MC_DC11_VALUE
+	sw	t2, MC_DC11(t1)
+
+	li	t2, MC_DC12_VALUE
+	sw	t2, MC_DC12(t1)
+
+	li	t2, MC_DC13_VALUE
+	sw	t2, MC_DC13(t1)
+
+	li	t2, MC_DC14_VALUE
+	sw	t2, MC_DC14(t1)
+
+	li	t2, MC_DC15_VALUE
+	sw	t2, MC_DC15(t1)
+
+	li	t2, MC_DC16_VALUE
+	sw	t2, MC_DC16(t1)
+
+	li	t2, MC_DC17_VALUE
+	sw	t2, MC_DC17(t1)
+
+	li	t2, MC_DC18_VALUE
+	sw	t2, MC_DC18(t1)
+
+	li	t2, MC_DC19_VALUE
+	sw	t2, MC_DC19(t1)
+
+	li	t2, MC_DC20_VALUE
+	sw	t2, MC_DC20(t1)
+
+	li	t2, MC_DC21_VALUE
+	sw	t2, MC_DC21(t1)
+
+	li	t2, MC_DC22_VALUE
+	sw	t2, MC_DC22(t1)
+
+	li	t2, MC_DC23_VALUE
+	sw	t2, MC_DC23(t1)
+
+	li	t2, MC_DC24_VALUE
+	sw	t2, MC_DC24(t1)
+
+	li	t2, MC_DC25_VALUE
+	sw	t2, MC_DC25(t1)
+
+	li	t2, MC_DC26_VALUE
+	sw	t2, MC_DC26(t1)
+
+	li	t2, MC_DC27_VALUE
+	sw	t2, MC_DC27(t1)
+
+	li	t2, MC_DC28_VALUE
+	sw	t2, MC_DC28(t1)
+
+	li	t2, MC_DC29_VALUE
+	sw	t2, MC_DC29(t1)
+
+	li	t2, MC_DC30_VALUE
+	sw	t2, MC_DC30(t1)
+
+	li	t2, MC_DC31_VALUE
+	sw	t2, MC_DC31(t1)
+
+	li	t2, MC_DC32_VALUE
+	sw	t2, MC_DC32(t1)
+
+	li	t2, MC_DC33_VALUE
+	sw	t2, MC_DC33(t1)
+
+	li	t2, MC_DC34_VALUE
+	sw	t2, MC_DC34(t1)
+
+	li	t2, MC_DC35_VALUE
+	sw	t2, MC_DC35(t1)
+
+	li	t2, MC_DC36_VALUE
+	sw	t2, MC_DC36(t1)
+
+	li	t2, MC_DC37_VALUE
+	sw	t2, MC_DC37(t1)
+
+	li	t2, MC_DC38_VALUE
+	sw	t2, MC_DC38(t1)
+
+	li	t2, MC_DC39_VALUE
+	sw	t2, MC_DC39(t1)
+
+	li	t2, MC_DC40_VALUE
+	sw	t2, MC_DC40(t1)
+
+	li	t2, MC_DC41_VALUE
+	sw	t2, MC_DC41(t1)
+
+	li	t2, MC_DC42_VALUE
+	sw	t2, MC_DC42(t1)
+
+	li	t2, MC_DC43_VALUE
+	sw	t2, MC_DC43(t1)
+
+	li	t2, MC_DC44_VALUE
+	sw	t2, MC_DC44(t1)
+
+	li	t2, MC_DC45_VALUE
+	sw	t2, MC_DC45(t1)
+
+	li	t2, MC_DC46_VALUE
+	sw	t2, MC_DC46(t1)
+
+	li	t2, 0x00000100
+	sw	t2, MC_DC03(t1)
+
+	j	ra
+	nop
+
+	.end	ddrram_init
+#endif /* CONFIG_USE_DDR_RAM */
+
+	.globl	lowlevel_init
+	.ent	lowlevel_init
+lowlevel_init:
+	/* EBU, CGU and SDRAM/DDR-RAM Initialization.
+	 */
+	move	t0, ra
+	/* We rely on the fact that non of the following ..._init() functions
+	 * modify t0
+	 */
+#if defined(CONFIG_SYS_EBU_BOOT)
+/*
+	using PPL1 value
+*/
+	li  a0,0x90
+	bal	cgu_init
+	nop
+#endif /* CONFIG_SYS_EBU_BOOT */
+
+	bal	ebu_init
+	nop
+
+#ifdef CONFIG_SYS_EBU_BOOT
+#ifndef CONFIG_SYS_RAMBOOT
+#ifdef CONFIG_USE_DDR_RAM
+	bal	ddrram_init
+	nop
+#else
+	bal	sdram_init
+	nop
+#endif
+#endif /* CONFIG_SYS_RAMBOOT */
+#endif /* CONFIG_SYS_EBU_BOOT */
+
+	move	ra, t0
+	j	ra
+	nop
+
+	.end	lowlevel_init
diff --git a/board/infineon/easy50812/pmuenable.S b/board/infineon/easy50812/pmuenable.S
new file mode 100644
--- /dev/null
+++ b/board/infineon/easy50812/pmuenable.S
@@ -0,0 +1,48 @@
+/*
+ *  Power Management unit initialization code for AMAZON development board.
+ *
+ *  Copyright (c) 2003	Ou Ke, Infineon.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+
+#define PMU_PWDCR 		0xBF10201C
+#define PMU_SR			0xBF102020
+
+	.globl	pmuenable
+
+pmuenable:
+	li      t0, PMU_PWDCR
+	li      t1, 0x2		/* enable everything */
+	sw      t1, 0(t0)
+#if 0
+1:
+	li	t0, PMU_SR
+	lw      t2, 0(t0)
+	bne     t1, t2, 1b
+	nop
+#endif
+	j	ra
+	nop
+
+
diff --git a/boards.cfg b/boards.cfg
--- a/boards.cfg
+++ b/boards.cfg
@@ -348,6 +348,10 @@ dbau1100                     mips       
 dbau1500                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1500
 dbau1550                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550
 dbau1550_el                  mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550
+easy50712_DDR166M            mips        mips32      easy50712           infineon       danube      easy50712:USE_DDR_RAM,USE_DDR_RAM_CFG_166M
+easy50712_DDR166M_ramboot    mips        mips32      easy50712           infineon       danube      easy50712:SYS_RAMBOOT
+easy50812_DDR166M            mips        mips32      easy50812           infineon       ar9         easy50812:USE_DDR_RAM,USE_DDR_RAM_CFG_166M
+easy50812_DDR166M_ramboot    mips        mips32      easy50812           infineon       ar9         easy50812:SYS_RAMBOOT
 gth2                         mips        mips32      -                   -              au1x00
 pb1000                       mips        mips32      pb1x00              -              au1x00      pb1x00:PB1000
 incaip                       mips        mips32      incaip              -              incaip
diff --git a/include/configs/easy50712.h b/include/configs/easy50712.h
new file mode 100644
--- /dev/null
+++ b/include/configs/easy50712.h
@@ -0,0 +1,107 @@
+/*
+ * (C) Copyright 2003-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the Danube reference board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifndef BOARD_NAME_LINUX
+#define BOARD_NAME_LINUX	EASY50712
+#endif
+
+#define CONFIG_MIPS32			/* MIPS32 CPU compatible		*/
+#define CONFIG_MIPS24KEC		/* MIPS 24KEc CPU core			*/
+#define CONFIG_DANUBE			/* in a Danube/Twinpass Chip		*/
+#define CONFIG_EASY50712		/* on the Danube Reference Board	*/
+
+#define CONFIG_SYS_MIPS_MULTI_CPU	/* This is a multi cpu system */
+
+#define CONFIG_SYS_MAX_RAM	(32 << 20)
+#define CONFIG_FLASH_CFI_DRIVER
+
+#define CONFIG_SYS_INIT_RAM_LOCK_MIPS
+
+#ifdef CONFIG_SYS_RAMBOOT
+	#define CONFIG_SYS_TEXT_BASE		0xA0400000
+	#define CONFIG_SKIP_LOWLEVEL_INIT
+#else /* CONFIG_SYS_RAMBOOT */
+	#define CONFIG_SYS_TEXT_BASE		0xB0000000
+	#define CONFIG_SYS_EBU_BOOT
+	#define INFINEON_EBU_BOOTCFG		0x688C688C
+#endif /* CONFIG_SYS_RAMBOOT */
+
+#define	CONFIG_SYS_PROMPT	"DANUBE => "	/* Monitor Command Prompt */
+
+#ifdef CONFIG_TWO_IMAGES
+#	define	CONFIG_SYS_HUSH_PARSER		/* Use the HUSH parser */
+#else
+#	undef	CONFIG_SYS_HUSH_PARSER
+#endif
+
+/*
+ * Include common defines/options for all Infineon boards
+ */
+#include "ifx-common.h"
+
+/*
+ * Cache Configuration (cpu/chip specific, Danube)
+ */
+#define CONFIG_SYS_DCACHE_SIZE		(16 << 10)
+#define CONFIG_SYS_ICACHE_SIZE		(16 << 10)
+#define CONFIG_SYS_CACHELINE_SIZE	32
+#define CONFIG_SYS_MIPS_CACHE_MODE	CONF_CM_CACHABLE_NO_WA
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_IFX_ETOP			/* lantiq ethernet cpe interface */
+#define CLK_OUT2_25MHZ
+#define CONFIG_EXTRA_SWITCH		/* search for external switches like tantos */
+#define CONFIG_RMII			/* use interface in RMII mode */
+
+/* enable MII commands */
+#define CONFIG_MII
+#define CONFIG_CMD_MII
+
+#define CONFIG_LTQ_ASC			/* use lantiq ASC driver */
+#ifdef CONFIG_USE_ASC0
+#define CONFIG_SYS_LTQ_ASC_BASE		0x1E100400
+#else
+#define CONFIG_SYS_LTQ_ASC_BASE		0x1E100C00
+#endif
+
+#ifdef CONFIG_SYS_RAMBOOT
+/* Configuration of EBU: */
+/* starting address from 0xb0000000 */
+/* make the flash available from RAM boot */
+#	define CONFIG_EBU_ADDSEL0		0x10000031
+#	define CONFIG_EBU_BUSCON0		0x0001D7FF
+#endif
+
+#ifndef CONFIG_SYS_RAMBOOT
+#define CONFIG_CMD_HTTPD		/* enable upgrade via HTTPD */
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/easy50812.h b/include/configs/easy50812.h
new file mode 100644
--- /dev/null
+++ b/include/configs/easy50812.h
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2003-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the AR9 reference board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifndef BOARD_NAME_LINUX
+#define BOARD_NAME_LINUX	EASY50812
+#endif
+
+#define CONFIG_MIPS32				/* MIPS32 CPU compatible */
+#define CONFIG_MIPS34KC				/* MIPS 34Kc CPU core */
+#define CONFIG_AR9				/* an AR9 device */
+#define CONFIG_EASY50812			/* on the AR9 reference board */
+
+#define CONFIG_SYS_MAX_RAM	(32 << 20)	/* 32 MB */
+#define CONFIG_FLASH_CFI_DRIVER			/* using CFI flash driver */
+
+#define CONFIG_SYS_INIT_RAM_LOCK_MIPS
+
+/* use PPL1 and fixed values for CPU / DDR and bus speed */
+#define CONFIG_USE_PLL1
+#define CONFIG_CPU_333M_RAM_166M
+#define CONFIG_CLASS_II_DDR_PAD
+
+#ifndef CONFIG_SYS_RAMBOOT
+	#define CONFIG_SYS_TEXT_BASE		0xB0000000
+	#define CONFIG_SYS_EBU_BOOT
+	#define INFINEON_EBU_BOOTCFG		0x688C688C
+#else
+	#define CONFIG_SYS_TEXT_BASE		0xA0400000
+	#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+#define	CONFIG_SYS_PROMPT	"AR9 => "	/* Monitor Command Prompt */
+
+#ifdef CONFIG_TWO_IMAGES
+#	define	CONFIG_SYS_HUSH_PARSER		/* Use the HUSH parser */
+#else
+#	undef	CONFIG_SYS_HUSH_PARSER
+#endif
+
+/*
+ * Include common defines/options for all Lantiq boards
+ */
+#include "ifx-common.h"
+
+/*
+ * Cache Configuration (cpu/chip specific, ar9)
+ */
+#define CONFIG_SYS_DCACHE_SIZE		(16 << 10)
+#define CONFIG_SYS_ICACHE_SIZE		(16 << 10)
+#define CONFIG_SYS_CACHELINE_SIZE	32
+#define CONFIG_SYS_MIPS_CACHE_MODE	CONF_CM_CACHABLE_NO_WA
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_IFX_ETOP			/* lantiq ethernet cpe interface */
+#define CLK_OUT2_25MHZ
+#define CONFIG_EXTRA_SWITCH		/* search for external switches like tantos */
+#define CONFIG_RMII			/* use interface in RMII mode */
+
+/* enable MII commands */
+#define CONFIG_MII
+#define CONFIG_CMD_MII
+
+#define CONFIG_LTQ_ASC			/* use lantiq ASC driver */
+#ifdef CONFIG_USE_ASC0
+#define CONFIG_SYS_LTQ_ASC_BASE		0x1E100400
+#else
+#define CONFIG_SYS_LTQ_ASC_BASE		0x1E100C00
+#endif
+
+#ifdef CONFIG_SYS_RAMBOOT
+/* Configuration of EBU: */
+/* starting address from 0xb0000000 */
+/* make the flash available from RAM boot */
+#	define CONFIG_EBU_ADDSEL0		0x10000031
+#	define CONFIG_EBU_BUSCON0		0x0001D7FF
+#endif
+
+#ifndef CONFIG_SYS_RAMBOOT
+#define CONFIG_CMD_HTTPD		/* enable upgrade via HTTPD */
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ifx-common.h b/include/configs/ifx-common.h
new file mode 100644
--- /dev/null
+++ b/include/configs/ifx-common.h
@@ -0,0 +1,308 @@
+/*
+ * (C) Copyright 2008
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * Common configuration options for all AMCC boards
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __IFX_COMMON_H
+#define __IFX_COMMON_H
+
+#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
+
+#ifndef ENV_MACHTYPE
+#ifdef BOARD_NAME_LINUX
+#define ENV_MACHTYPE "machtype=" MK_STR(BOARD_NAME_LINUX) "\0"
+#else
+#define ENV_MACHTYPE
+#endif
+#endif
+
+#ifdef CONFIG_EMULATION
+#define CONFIG_BAUDRATE		600
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 600, 1200, 2400, 9600, 19200, 38400, 57600, 115200, 230400 }
+#else
+#define CONFIG_BAUDRATE		115200
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200, 230400 }
+#endif
+
+
+#define CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_PREBOOT	"echo;"	\
+	"echo Type \\\"run flash_nfs\\\" to mount root filesystem over NFS;" \
+	"echo"
+
+#undef	CONFIG_BOOTARGS
+
+#ifndef ENV_IMAGENAME
+#define ENV_IMAGENAME "image_name=openwrt-lantiq-xway-" MK_STR(BOARD_NAME_LINUX) "\0"
+#endif
+
+#ifdef CONFIG_TWO_IMAGES
+#define UBOOT_FILENAME		"u-boot.bin"
+#define UBOOT_ADDR		PHYS_FLASH_1
+#define UBOOT_SIZE		256
+
+#define UBOOTENV_ADDR		CONFIG_ENV_ADDR
+#define UBOOTENV_SIZE		64
+
+#define BOOTSCRIPT_FILENAME	"bootscript.img"
+#define BOOTSCRIPT_ADDR		0xB0050000
+#define BOOTSCRIPT_SIZE		64
+
+#define IMAGE0_FILENAME		"image0.img"
+#define IMAGE0_ADDR		0xB0060000
+#define IMAGE0_SIZE		3904
+
+#define IMAGE1_FILENAME		"image1.img"
+#define IMAGE1_ADDR		0xB0430000
+#define IMAGE1_SIZE		3904
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"ram_addr=0x80500000\0"						\
+	"image0_addr=" MK_STR(IMAGE0_ADDR) "\0"				\
+	"image1_addr=" MK_STR(IMAGE1_ADDR) "\0"				\
+	ENV_MACHTYPE                                                       \
+	ENV_IMAGENAME                                                   \
+	"bootscript_addr=" MK_STR(BOOTSCRIPT_ADDR) "\0"			\
+	"activate_image=-1\0"						\
+	"committed_image=0\0"						\
+	"image0_is_valid=1\0"						\
+	"image1_is_valid=0\0"						\
+	"flashargs=setenv bootargs rootfstype=squashfs,jffs2\0"		\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
+		"nfsroot=${serverip}:${rootpath} \0"			\
+	"addip=setenv bootargs ${bootargs} "				\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
+		":${hostname}:${netdev}:off\0"				\
+	"addmisc=setenv bootargs ${bootargs} init=/etc/preinit "	\
+		"console=ttyS1,115200 ethaddr=${ethaddr} \0"		\
+	"addmtdparts0=setenv bootargs ${bootargs} "			\
+		"mtdparts=lq_nor:"					\
+		MK_STR(UBOOT_SIZE)	"k(uboot)ro,"			\
+		MK_STR(UBOOTENV_SIZE)	"k(uboot_env),"			\
+		MK_STR(BOOTSCRIPT_SIZE)	"k(bootscript),"		\
+		"64k(kernel)ro,"					\
+		MK_STR(IMAGE0_SIZE)	"k(rootfs)ro,"			\
+		"-(image1)\0"						\
+	"addmtdparts1=setenv bootargs ${bootargs} "			\
+		"mtdparts=lq_nor:"					\
+		MK_STR(UBOOT_SIZE)	"k(uboot)ro,"			\
+		MK_STR(UBOOTENV_SIZE)	"k(uboot_env),"			\
+		MK_STR(BOOTSCRIPT_SIZE)	"k(bootscript),"		\
+		MK_STR(IMAGE0_SIZE)	"k(image0),"			\
+		"64k(kernel)ro,"					\
+		"-(rootfs)ro\0"						\
+	"flash_flash=run flashargs addip addmisc && "			\
+		"source ${bootscript_addr}\0"				\
+	"flash_nfs=run nfsargs addip addmisc addmtdparts0 && "		\
+		"bootm ${image0_addr}\0"				\
+	"net_flash=run load_kernel flashargs addip addmisc "		\
+		"addmtdparts0 && bootm ${ram_addr}\0"			\
+	"net_nfs=run load_kernel nfsargs addip addmisc addmtdparts0 && "\
+		"bootm ${ram_addr}\0"					\
+	"load_kernel=tftp ${ram_addr} "					\
+		"${tftppath}${image_name}-uImage\0"		        \
+	"update_uboot="							\
+		"tftp ${ram_addr} ${tftppath}" UBOOT_FILENAME " && "	\
+		"protect off all && "					\
+		"era " MK_STR(UBOOT_ADDR) " +${filesize} && "		\
+		"era " MK_STR(UBOOT_ADDR) " +65535 && "			\
+		"cp.b ${ram_addr} " MK_STR(UBOOT_ADDR) " ${filesize}\0"	\
+	"update_bootscript=tftp ${ram_addr} ${tftppath}"		\
+			BOOTSCRIPT_FILENAME " && "			\
+		"protect off all && "					\
+		"era ${bootscript_addr} +${filesize} && "		\
+		"cp.b ${ram_addr} ${bootscript_addr} ${filesize}\0"	\
+	"update_openwrt=tftp ${ram_addr} "				\
+		"${tftppath}${image_name}-squashfs.image && "	        \
+		"protect off all && "					\
+		"era ${image0_addr} +${filesize} && "			\
+		"cp.b ${ram_addr} ${image0_addr} ${filesize}\0"		\
+	"update_image0="						\
+		"tftp ${ram_addr} ${tftppath}" IMAGE0_FILENAME " && "	\
+		"protect off all && "					\
+		"era ${image0_addr} +${filesize} && "			\
+		"cp.b ${ram_addr} ${image0_addr} ${filesize}\0"		\
+	"update_image1="						\
+		"tftp ${ram_addr} ${tftppath}" IMAGE1_FILENAME " && "	\
+		"protect off all && "					\
+		"era ${image1_addr} +${filesize} && "			\
+		"cp.b ${ram_addr} ${image1_addr} ${filesize}\0"		\
+	"boot_image0="							\
+		"run flashargs addip addmisc addmtdparts0 && "		\
+		"bootm $image0_addr\0"					\
+	"boot_image1="							\
+		"run flashargs addip addmisc addmtdparts1 && "		\
+		"bootm $image1_addr\0"
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"ram_addr=0x80500000\0"						\
+	"kernel_addr=0xb0050000\0"					\
+	ENV_MACHTYPE                                                       \
+	ENV_IMAGENAME                                                   \
+	"mtdparts=mtdparts=lq_nor:256k(uboot)ro,64k(uboot_env)ro,-(linux)\0" \
+	"flashargs=setenv bootargs rootfstype=squashfs,jffs2\0"		\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
+		"nfsroot=${serverip}:${rootpath} \0"			\
+	"addip=setenv bootargs ${bootargs} "				\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
+		":${hostname}:${netdev}:off\0"				\
+	"addmisc=setenv bootargs ${bootargs} "	                        \
+		"console=ttyS1,115200 ethaddr=${ethaddr} "              \
+		"machtype=${machtype} ${mtdparts}\0"                    \
+	"flash_flash=run flashargs addip addmisc;"			\
+		"bootm ${kernel_addr}\0"				\
+	"flash_nfs=run nfsargs addip addmisc;bootm ${kernel_addr}\0"	\
+	"net_flash=run load_kernel flashargs addip addmisc;"		\
+		"bootm ${ram_addr}\0"					\
+	"net_nfs=run load_kernel nfsargs addip addmisc;"		\
+		"bootm ${ram_addr}\0"					\
+	"load_kernel=tftp ${ram_addr} "					\
+		"${tftppath}${image_name}-uImage\0"		        \
+	"update_uboot=tftp 0x80500000 ${tftppath}u-boot.bin;era 0xb0000000 +${filesize};" \
+		"cp.b 0x80500000 0xb0000000 ${filesize}\0"              \
+	"update_openwrt=tftp ${ram_addr} "				\
+		"${tftppath}${image_name}-squashfs.image;"              \
+		"era ${kernel_addr} +${filesize};"			\
+		"cp.b ${ram_addr} ${kernel_addr} ${filesize}\0"
+#endif
+
+#define CONFIG_BOOTCOMMAND	"run flash_flash"
+
+/*
+ * TFTP is using fragmented packets
+*/
+#define CONFIG_IP_DEFRAG
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_XIMG
+
+//#define CONFIG_CMD_ASKENV
+//#define CONFIG_CMD_DHCP
+//#define CONFIG_CMD_ELF
+#define CONFIG_CMD_PING
+//#define CONFIG_CMD_JFFS2
+//#define CONFIG_CMD_SNTP
+
+
+/*
+ * Miscellaneous configurable options
+ */
+
+#define CONFIG_LZMA
+
+#define CONFIG_SYS_LONGHELP				/* undef to save memory */
+#ifndef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		"=> "		/* Monitor Command Prompt */
+#endif
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)  /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args */
+
+#define CONFIG_SYS_MALLOC_LEN		(1 << 20)
+#define CONFIG_SYS_BOOTPARAMS_LEN	(128 << 10)
+
+#define CONFIG_SYS_MIPS_TIMER_FREQ	(get_cpuclk()/2)
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_LOAD_ADDR		0x80100000	/* default load address	*/
+#define CONFIG_SYS_MEMTEST_START	0x80100000
+#define CONFIG_SYS_MEMTEST_END		0x80800000
+
+#define CONFIG_CMDLINE_EDITING		/* add command line history	*/
+#define CONFIG_AUTO_COMPLETE		/* add autocompletion support	*/
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+#define CONFIG_VERSION_VARIABLE		/* include version env variable */
+#define CONFIG_SYS_CONSOLE_INFO_QUIET	/* don't print console @ startup*/
+
+#ifdef CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#endif
+
+#define CONFIG_LOADS_ECHO		/* echo on for serial download	*/
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change	*/
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	(140)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1			0xB0000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2			0xB0800000 /* Flash Bank #2 */
+
+/* The following #defines are needed to get flash environment right */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_MONITOR_LEN		(192 << 10)
+
+#define CONFIG_SYS_INIT_SP_OFFSET	0x400000
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_IS_IN_FLASH
+
+/* Address and size of Primary Environment Sector	*/
+#define CONFIG_ENV_ADDR			0xB0040000
+#ifdef CONFIG_EMULATION
+#define CONFIG_ENV_SIZE			0x10
+#else
+#define CONFIG_ENV_SIZE			0x10000
+#endif
+
+#ifdef CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+#endif
+
+#ifdef CONFIG_SYS_EBU_BOOT
+#ifndef INFINEON_EBU_BOOTCFG
+#error Please define INFINEON_EBU_BOOTCFG
+#endif
+#endif
+
+#endif /* __IFX_COMMON_H */
