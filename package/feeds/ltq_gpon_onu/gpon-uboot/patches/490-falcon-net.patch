add falcon network driver

diff --git a/Makefile b/Makefile
--- a/Makefile
+++ b/Makefile
@@ -255,6 +255,7 @@ LIBS += drivers/mtd/onenand/libonenand.o
 LIBS += drivers/mtd/ubi/libubi.o
 LIBS += drivers/mtd/spi/libspi_flash.o
 LIBS += drivers/net/libnet.o
+LIBS += drivers/net/falcon/libfalcon.o
 LIBS += drivers/net/phy/libphy.o
 LIBS += drivers/pci/libpci.o
 LIBS += drivers/pcmcia/libpcmcia.o
diff --git a/arch/mips/include/asm/arch-falcon/net.h b/arch/mips/include/asm/arch-falcon/net.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/arch-falcon/net.h
@@ -0,0 +1,59 @@
+/*
+ * (C) Copyright 2011 Lantiq Deutschland GmbH, http://www.lantiq.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __FALCON_NET_H
+#define __FALCON_NET_H
+
+#define FALCON_NET_PORT_MASK_GPHY0	(1<<0)
+#define FALCON_NET_PORT_MASK_GPHY1	(1<<1)
+#define FALCON_NET_PORT_MASK_RGMII0	(1<<2)
+#define FALCON_NET_PORT_MASK_RGMII1	(1<<3)
+#define FALCON_NET_PORT_MASK_GMII_PHY	(1<<4)
+#define FALCON_NET_PORT_MASK_GMII_MAC	(1<<5)
+#define FALCON_NET_PORT_MASK_MII_PHY	(1<<6)
+#define FALCON_NET_PORT_MASK_MII_MAC	(1<<7)
+#define FALCON_NET_PORT_MASK_SGMII	(1<<8)
+
+#define FALCON_NET_PORT_MASK_GPHY \
+	(FALCON_NET_PORT_MASK_GPHY0 | FALCON_NET_PORT_MASK_GPHY1)
+
+#define FALCON_NET_PORT_MASK_RGMII \
+	(FALCON_NET_PORT_MASK_RGMII0 | FALCON_NET_PORT_MASK_RGMII1)
+
+#define FALCON_NET_PORT_MASK_GMII \
+	(FALCON_NET_PORT_MASK_GMII_PHY | FALCON_NET_PORT_MASK_GMII_MAC)
+
+#define FALCON_NET_PORT_MASK_MII \
+	(FALCON_NET_PORT_MASK_MII_PHY | FALCON_NET_PORT_MASK_MII_MAC)
+
+#define FALCON_NET_PORT_MASK_xMII \
+	(FALCON_NET_PORT_MASK_RGMII | \
+	 FALCON_NET_PORT_MASK_GMII | \
+	 FALCON_NET_PORT_MASK_MII)
+
+#define FALCON_NET_PORT_MASK_ALL \
+	(FALCON_NET_PORT_MASK_GPHY | FALCON_NET_PORT_MASK_RGMII | \
+	 FALCON_NET_PORT_MASK_GMII | FALCON_NET_PORT_MASK_MII | \
+	 FALCON_NET_PORT_MASK_SGMII)
+
+#ifndef CONFIG_FALCON_NET_PORT_MASK
+#define CONFIG_FALCON_NET_PORT_MASK	FALCON_NET_PORT_MASK_ALL
+#endif
+
+int falcon_net_register(unsigned int mask);
+
+#endif /* __FALCON_NET_H */
diff --git a/drivers/net/falcon/Makefile b/drivers/net/falcon/Makefile
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/Makefile
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# File: drivers/net/falcon/Makefile
+#
+# Makefile for the FALCON device driver. Based on SK-98xx.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libfalcon.o
+
+COBJS-$(CONFIG_FALCON_ETH) += \
+	falcon_ll.o \
+	falcon.o
+
+COBJS	:= $(COBJS-y)
+SRCS	= $(COBJS:.o=.c)
+OBJS	= $(addprefix $(obj),$(COBJS))
+
+CFLAGS += $(EXTRA_CFLAGS)
+HOSTCFLAGS += $(EXTRA_CFLAGS)
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/net/falcon/eim_reg.h b/drivers/net/falcon/eim_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/eim_reg.h
@@ -0,0 +1,2009 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _eim_reg_h
+#define _eim_reg_h
+
+/** \addtogroup EIM_REGISTER
+   @{
+*/
+/* access macros */
+#define eim_a1x_r32(reg) reg_r32(&eim_a1x->reg)
+#define eim_a1x_w32(val, reg) reg_w32(val, &eim_a1x->reg)
+#define eim_a1x_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &eim_a1x->reg)
+
+#define eim_a2x_r32(reg) reg_r32(&eim_a2x->reg)
+#define eim_a2x_w32(val, reg) reg_w32(val, &eim_a2x->reg)
+#define eim_a2x_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &eim_a2x->reg)
+
+#define eim_r32(reg) (is_falcon_chip_a1x()?eim_a1x_r32(reg):eim_a2x_r32(reg))
+#define eim_w32(val, reg) \
+	do { \
+		if (is_falcon_chip_a1x()) \
+			eim_a1x_w32(val, reg); \
+		else \
+			eim_a2x_w32(val, reg); \
+	} while(0)
+#define eim_w32_mask(clear, set, reg) \
+	do { \
+		if (is_falcon_chip_a1x()) \
+			eim_a1x_w32_mask(clear, set, reg); \
+		else \
+			eim_a2x_w32_mask(clear, set, reg); \
+	} while(0)
+
+
+/** EIM_MACS_TOP_PDI: Ethernet MAC Toplevel Registers */
+struct eim_macs_top_pdi
+{
+   /** MAC Test Register
+       This register is used to select test functions. */
+   unsigned int mac_test; /* 0x00000000 */
+   /** MAC Pause Frame Source Address Configuration Register
+       This register is used to configure if a common MAC source address is used for transmitted Pause frames on all Ethernet ports or if individual addresses are used. */
+   unsigned int mac_pfad_cfg; /* 0x00000004 */
+   /** Pause Frame Source Address Part 0
+       This register is used to configure the Pause frame source address. */
+   unsigned int mac_pfsa[3]; /* 0x00000008 */
+   /** MAC Frame Length Register
+       This register is used to configure the maximum frame length for Jumbo frames. */
+   unsigned int mac_flen; /* 0x00000014 */
+   /** MAC VLAN Ethertype Register 0
+       This register is used to configure the Ethertype to detect an outer VLAN tag. */
+   unsigned int mac_vlan_etype[2]; /* 0x00000018 */
+};
+
+/** EIM_MAC_PDI: Ethernet MAC Registers */
+struct eim_mac_pdi_a1x
+{
+   /** MAC Port Status Register
+       This register provides information about the current status of the Ethernet MAC. Additionally, status information of the attached Ethernet PHY are provided in the same register. PHY status information is retrieved by using the auto-polling process. */
+   unsigned int pstat; /* 0x00000020 */
+   /** MAC Interrupt Status Register
+       This register provides information about the current status of the Ethernet MAC and generates an interrupt. */
+   unsigned int pisr; /* 0x00000024 */
+   /** MAC Interrupt Enable Register
+       This register enables the activation of interrupts. */
+   unsigned int pier; /* 0x00000028 */
+   /** MAC Control Register 0
+       This register is used to configure the Ethernet MAC. */
+   unsigned int ctrl_0; /* 0x0000002C */
+   /** MAC Control Register 1
+       This register is used to configure the Ethernet MAC. */
+   unsigned int ctrl_1; /* 0x00000030 */
+   /** MAC Control Register 2
+       This register is used to configure the maximum frame length to be received. */
+   unsigned int ctrl_2; /* 0x00000034 */
+   /** MAC Control Register 3
+       This register is used to configure the frame handling in half-duplex mode. */
+   unsigned int ctrl_3; /* 0x00000038 */
+   /** MAC Control Register 4
+       This register is used to configure the LPI function. */
+   unsigned int ctrl_4; /* 0x0000003C */
+   /** MAC Control Register 5
+       This register is used to configure the Jam pattern size. */
+   unsigned int ctrl_5; /* 0x00000040 */
+   /** Transmit and Receive Buffer Control Register
+       This register is used to configure the internal buffer configuration. */
+   unsigned int ctrl_6; /* 0x00000044 */
+   /** MAC Receive and Transmit Buffer Status Register
+       This register is used to indicate the internal buffer status. */
+   unsigned int bufst; /* 0x00000048 */
+   /** MAC Test Enable Register
+       This register is used to select MAC-related test functions. */
+   unsigned int testen; /* 0x0000004C */
+};
+
+/** EIM_MAC_PDI: Ethernet MAC Registers */
+struct eim_mac_pdi_a2x
+{
+   /** MAC Port Status Register
+       This register provides information about the current status of the Ethernet MAC. Additionally, status information of the attached Ethernet PHY are provided in the same register. PHY status information is retrieved by using the auto-polling process. */
+   unsigned int pstat; /* 0x00000028 */
+   /** MAC Interrupt Status Register
+       This register provides information about the current status of the Ethernet MAC and generates an interrupt. */
+   unsigned int pisr; /* 0x0000002C */
+   /** MAC Interrupt Enable Register
+       This register enables the activation of interrupts. */
+   unsigned int pier; /* 0x00000030 */
+   /** MAC Control Register 0
+       This register is used to configure the Ethernet MAC. */
+   unsigned int ctrl_0; /* 0x00000034 */
+   /** MAC Control Register 1
+       This register is used to configure the Ethernet MAC. */
+   unsigned int ctrl_1; /* 0x00000038 */
+   /** MAC Control Register 2
+       This register is used to configure the maximum frame length to be received. */
+   unsigned int ctrl_2; /* 0x0000003C */
+   /** MAC Control Register 3
+       This register is used to configure the frame handling in half-duplex mode. */
+   unsigned int ctrl_3; /* 0x00000040 */
+   /** MAC Control Register 4
+       This register is used to configure the LPI function. */
+   unsigned int ctrl_4; /* 0x00000044 */
+   /** MAC Control Register 5
+       This register is used to configure the Jam pattern size. */
+   unsigned int ctrl_5; /* 0x00000048 */
+   /** MAC Test Enable Register
+       This register is used to select MAC-related test functions. */
+   unsigned int testen; /* 0x0000004C */
+};
+
+/** EIM_TOP_PDI: GPON Ethernet Interface Module Toplevel Registers */
+struct eim_top_pdi
+{
+   /** Reset Control Register */
+   unsigned int gphy_ctl;
+   /** GPHY Version Configuration Register */
+   unsigned int gphy_cfg_ver;
+   /** GPHY PLL Configuration Register */
+   unsigned int gphy_cfg_pll;
+   /** GPHY General Configuration Register */
+   unsigned int gphy_cfg_gen[2];
+   /** GPHY Auto-Negotiation Capability Configuration Register */
+   unsigned int gphy_cfg_aneg[2];
+   /** GPHY PHY Address Configuration Register */
+   unsigned int gphy_cfg_addr[2];
+   /** Configuration register for Strobe Generator 0 (2Hz target frequency) */
+   unsigned int eim_strb_gen0_ctl;
+   /** Configuration register for Strobe Generator 1 (25MHz target frequency) */
+   unsigned int eim_strb_gen1_ctl;
+   /** Configuration register for Packet Engine Interface 0 */
+   unsigned int eim_lan_ifc_cfg_0;
+   /** Configuration register for Packet Engine Interface 1  */
+   unsigned int eim_lan_ifc_cfg_1;
+   /** MIB Counter (FCS Errored Frames) */
+   unsigned int eim_mib_fcser[4];
+   /** MIB Counter (Oversized Frames) */
+   unsigned int eim_mib_ovsz[4];
+   /** MIB Counter (Misaligned Frames) */
+   unsigned int eim_mib_algn[4];
+   /** MIB Counter (Late Collsions) */
+   unsigned int eim_mib_late_col[4];
+   /** MIB Counter (Excessive Collisions) */
+   unsigned int eim_mib_exc_col[4];
+   /** MIB Counter (Single Collisions) */
+   unsigned int eim_mib_sgl_col[4];
+   /** MIB Counter (Multiple Collisions) */
+   unsigned int eim_mib_mul_col[4];
+   /** MIB Counter (Deferred Transmission) */
+   unsigned int eim_mib_def_trans[4];
+   /** Central EIM Interrupt Enable */
+   unsigned int eim_ier;
+   /** Central EIM Interrupt Register */
+   unsigned int eim_isr;
+};
+
+/** EIM_MDIO_MAC_PDI: This is the register description of the MDIO interface (MAC part) */
+struct eim_mdio_mac_pdi
+{
+   /** Interrupt Status Register */
+   unsigned int istat; /* 0x0000019C */
+   /** Interrupt Enable Register */
+   unsigned int ienable; /* 0x000001A0 */
+   /** Configuration Register */
+   unsigned int cfg; /* 0x000001A4 */
+   /** Startup Phase Data Register
+       This register holds the DATA DEVAD, the PHYAD, the ST and OP fields, which are currently received by the mdio interface serial to parallel converter, independent on MAC read or PHY receive mode. The data stored in this register will be written from the HW (during a MAC transmit or a PHY receive mode) and could be observed by CPU / SW. After an MAC transmit or MAC receive or PHY receive access has finished the data are xxx.... */
+   unsigned int startup; /* 0x000001A8 */
+   /** Mac Data Transmit Register
+       Only used in MAC mode. Data to be transmitted to the PHY on the mdio interface in mac mode. */
+   unsigned int mac_data; /* 0x000001AC */
+   /** Mac Header Transmit Register
+       Only used in MAC mode. Header to be transmitted to the PHY. With this register it also chosen what kind of access (read or write) should be done. With the start_tx bit the transmission of the mdio frame to the PHY is started. The rw bit decides about the kind of access (read / write) independent of the content of the programmed bits in the bit positions 15:0 */
+   unsigned int mac_header; /* 0x000001B0 */
+   /** MAC Preamble Transmit Length Register
+       This register is only used in MAC mode. With this register the length of the transmitted preamble length (ones) can be set, the IEEE assumes 32 bit, but many PHY's have the ability to handle so called short preambles. With this register the preamble length up front an read or write access could be set. The register is used only in MAC mode while sending the preamble. */
+   unsigned int preamble; /* 0x000001B4 */
+   /** Preamble Length Register
+       This register is used in MAC and PHY mode for all the incoming (received) data. In both cases the input is observing the mdio pin. In MAC mode the register must have the same content as the 'preamble' register. In MAC or PHY mode the register is used by the mdio_read_phy_fsm to detect the earliest possible position of the ST bits at the end of the preamble. */
+   unsigned int preamble_incoming; /* 0x000001B8 */
+};
+
+/** ETHSW_EIM_MDIO_PDI: MDIO Master and Global Control and Status Registers */
+struct ethsw_eim_mdio_pdi
+{
+   /** MDIO Control Register
+       This register is used to access devices that are connected to the serial MDIO master interface, internally or externally. */
+   unsigned int mdio_ctrl; /* 0x00000184 */
+   /** MDIO Read Data Register
+       This register is used to read back data across the serial MDIO master interface, internally or externally. */
+   unsigned int mdio_read; /* 0x00000188 */
+   /** MDIO Write Data Register
+       This register is used to write data across the serial MDIO master interface, internally or externally. */
+   unsigned int mdio_write; /* 0x0000018C */
+   /** MDC Clock Configuration Register 0
+       This register is used to control the MDC clock output and polling state machine. */
+   unsigned int mdc_cfg_0; /* 0x00000190 */
+   /** MDC Clock Configuration Register 1
+       This register is used to configure clocking rate for the MDIO master interfaces. */
+   unsigned int mdc_cfg_1; /* 0x00000194 */
+   /** PHY Address Register PORT 0
+       This register is used to define the phy address of the port. */
+   unsigned int phy_addr[4]; /* 0x00000198 */
+   /** PHY MDIO Polling Status per PORT
+       This register provides information about the current status of the attached Ethernet PHY retrieved by using the auto-polling process. */
+   unsigned int mdio_stat[4]; /* 0x000001A8 */
+   /** EEE auto negotiation overides
+       Overide what is conveyd to the MAC from the auto negotiation with PHY. */
+   unsigned int aneg_eee[4]; /* 0x000001B8 */
+};
+
+/** EIM_MII_PDI: xMII Control Registers */
+struct eim_mii_pdi
+{
+   /** xMII Port Configuration Register
+       This register controls the settings of the xMII Interface. */
+   unsigned int mii_cfg;
+   /** Configuration of Clock Delay
+       This register controls the settings of the receive and transmit clock delay (used for RGMII mode only). */
+   unsigned int pcdu;
+   /** Configuration of Jitter Buffer */
+   unsigned int buff;
+};
+
+/** EIM register structure for A1x version */
+struct gpon_reg_eim_a1x
+{
+   struct eim_macs_top_pdi macs_top_pdi;	/* 0x00000000--0x0000001F */
+   struct eim_mac_pdi_a1x mac_pdi[4];		/* 0x00000020--0x000000DF */
+   struct eim_top_pdi top_pdi;			/* 0x000000E0--0x0000019B */
+   struct eim_mdio_mac_pdi mdio_mac_pdi;	/* 0x0000019C--0x000001BB */
+   struct eim_mii_pdi mii_pdi[2];		/* 0x000001BC--0x000001D3 */
+};
+
+/** EIM register structure for A2x version */
+struct gpon_reg_eim_a2x
+{
+   struct eim_macs_top_pdi macs_top_pdi;	/* 0x00000000--0x0000001F */
+
+   /** MAC Interrupt Enable Register
+       This register is used to enable or disable all MAC interrupts per port. */
+   unsigned int macs_top_pdi_mac_ier;		/* 0x00000020 */
+   /** MAC Interrupt Status Register
+       This register collects the interrupt status information that is provided per port. */
+   unsigned int macs_top_pdi_mac_isr;		/* 0x00000024 */
+
+   struct eim_mac_pdi_a2x mac_pdi[4];		/* 0x00000028--0x000000C7 */
+
+   struct eim_top_pdi top_pdi;			/* 0x000000C8--0x00000183 */
+   struct ethsw_eim_mdio_pdi mdio_pdi;		/* 0x00000184--0x000001C7 */
+   struct eim_mii_pdi mii_pdi[2];		/* 0x000001C8--0x000001DF */
+
+};
+
+/* Fields of "MAC Test Register" */
+/** Jitter Test Pattern
+    User definable test pattern for jitter test mode 3. */
+#define EIM_MAC_TEST_JTP_MASK 0x0000FFFF
+/** field offset */
+#define EIM_MAC_TEST_JTP_OFFSET 0
+
+/* Fields of "MAC Pause Frame Source Address Configuration Register" */
+/** Source Address Mode
+    Enables individual MAC source addresses per Ethernet port for transmitted Pause frames. */
+#define EIM_MAC_PFAD_CFG_SAMOD 0x00000001
+/* pause frames use a common MAC source address
+#define EIM_MAC_PFAD_CFG_SAMOD_COMMON 0x00000000 */
+/** pause frames use a port-specific MAC source address */
+#define EIM_MAC_PFAD_CFG_SAMOD_PORT 0x00000001
+
+/* Fields of "Pause Frame Source Address Part 0" */
+/** Pause Frame Source Address Part 0
+    Defines bit 15:0 of the Pause frame source address. */
+#define EIM_MAC_PFSA_PFAD_MASK 0x0000FFFF
+/** field offset */
+#define EIM_MAC_PFSA_PFAD_OFFSET 0
+
+/* Fields of "MAC Frame Length Register" */
+/** Maximum Frame Length
+    Defines the maximum length of frames to be received, given in number of bytes. The count includes the optional VLAN tag(s). */
+#define EIM_MAC_FLEN_LEN_MASK 0x00003FFF
+/** field offset */
+#define EIM_MAC_FLEN_LEN_OFFSET 0
+
+/* Fields of "MAC VLAN Ethertype Register 0" */
+/** Ethertype
+    Defines the Ethertype associated with the outer VLAN tag. */
+#define EIM_MAC_VLAN_ETYPE_OUTER_MASK 0x0000FFFF
+/** field offset */
+#define EIM_MAC_VLAN_ETYPE_OUTER_OFFSET 0
+
+/* Fields of "MAC Interrupt Enable Register" */
+/** MAC Interrupt Enable
+    Setting a bit enables MAC interrupts from the related port. */
+#define EIM_MAC_IER_MACIEN_MASK 0x0000000F
+/** field offset */
+#define EIM_MAC_IER_MACIEN_OFFSET 0
+
+/* Fields of "MAC Interrupt Status Register" */
+/** MAC Interrupt
+    Indicates if an interrupt related to this port needs service. */
+#define EIM_MAC_ISR_MACINT_MASK 0x0000000F
+/** field offset */
+#define EIM_MAC_ISR_MACINT_OFFSET 0
+
+/* Fields of "MAC Port Status Register" */
+/** PHY Active Status
+    Indicates if the external PHY is responding to MDIO accesses. */
+#define EIM_MAC_PSTAT_PACT 0x00000800
+/* the PHY is inactive or not present
+#define EIM_MAC_PSTAT_PACT_INACTIVE 0x00000000 */
+/** the PHY is active and responds to MDIO accesses */
+#define EIM_MAC_PSTAT_PACT_ACTIVE 0x00000800
+/** Gigabit Speed Status
+    Indicates if Gigabit Ethernet speed is used by the Interface. */
+#define EIM_MAC_PSTAT_GBIT 0x00000400
+/* low speed (10 or 100 Mbit/s)
+#define EIM_MAC_PSTAT_GBIT_LOW 0x00000000 */
+/** High speed status (1000 Mbit/s or 2000 Mbit/s) */
+#define EIM_MAC_PSTAT_GBIT_HIGH 0x00000400
+/** Megabit Speed Status
+    Indicates if the attached PHY runs at a data rate of 10 or 100 Mbit/s. */
+#define EIM_MAC_PSTAT_MBIT 0x00000200
+/* 10 Mbit/s
+#define EIM_MAC_PSTAT_MBIT_E10 0x00000000 */
+/** 100 Mbit/s */
+#define EIM_MAC_PSTAT_MBIT_E100 0x00000200
+/** Full Duplex Status
+    Indicates if the attached PHY runs in half- or full-duplex mode. */
+#define EIM_MAC_PSTAT_FDUP 0x00000100
+/* half-duplex mode
+#define EIM_MAC_PSTAT_FDUP_HALF 0x00000000 */
+/** full-duplex mode */
+#define EIM_MAC_PSTAT_FDUP_FULL 0x00000100
+/** Receive Pause Status
+    Indicates if the receive pause status is active in the MAC. */
+#define EIM_MAC_PSTAT_RXPAU 0x00000080
+/* normal receive operation
+#define EIM_MAC_PSTAT_RXPAU_NORM 0x00000000 */
+/** receive pause status is active */
+#define EIM_MAC_PSTAT_RXPAU_PAU 0x00000080
+/** Transmit Pause Status
+    Indicates if the transmit pause status is active in the MAC. */
+#define EIM_MAC_PSTAT_TXPAU 0x00000040
+/* normal transmit operation
+#define EIM_MAC_PSTAT_TXPAU_NORM 0x00000000 */
+/** transmit pause status is active */
+#define EIM_MAC_PSTAT_TXPAU_PAU 0x00000040
+/** Receive Pause Enable Status
+    This status information is retrieved from the attached Ethernet PHY by polling the related MDIO register. */
+#define EIM_MAC_PSTAT_RXPAUEN 0x00000020
+/* the link partner does not send pause frames
+#define EIM_MAC_PSTAT_RXPAUEN_DIS 0x00000000 */
+/** the link partner sends pause frames */
+#define EIM_MAC_PSTAT_RXPAUEN_EN 0x00000020
+/** Transmit Pause Enable Status
+    This status information is retrieved from the attached Ethernet PHY by polling the related MDIO register. */
+#define EIM_MAC_PSTAT_TXPAUEN 0x00000010
+/* the link partner does not accept pause frames
+#define EIM_MAC_PSTAT_TXPAUEN_DIS 0x00000000 */
+/** the link partner accepts pause frames */
+#define EIM_MAC_PSTAT_TXPAUEN_EN 0x00000010
+/** Link Status
+    This status information is retrieved from the attached Ethernet PHY by polling the related MDIO register. */
+#define EIM_MAC_PSTAT_LSTAT 0x00000008
+/* the link is down
+#define EIM_MAC_PSTAT_LSTAT_DOWN 0x00000000 */
+/** the link is up */
+#define EIM_MAC_PSTAT_LSTAT_UP 0x00000008
+/** Carrier Sense Status
+    Indicates if a carrier is detected in half-duplex mode. */
+#define EIM_MAC_PSTAT_CRS 0x00000004
+/* no carrier detected
+#define EIM_MAC_PSTAT_CRS_NO 0x00000000 */
+/** Transmit Low-power Idle Status
+    Indicates the Low-power Idle status in transmit direction. This bit is set as long as the LPI_TX_Indicate is received from the EEE transmit state machine. */
+#define EIM_MAC_PSTAT_TXLPI 0x00000002
+/* normal power state
+#define EIM_MAC_PSTAT_TXLPI_NORM 0x00000000 */
+/** low-power idle state */
+#define EIM_MAC_PSTAT_TXLPI_LPI 0x00000002
+/** Receive Low-power Idle Status
+    Indicates the Low-power Idle status in receive direction. This bit is set as long as the LPI_RX_Indicate is received from the EEE receive state machine. */
+#define EIM_MAC_PSTAT_RXLPI 0x00000001
+/* normal power state
+#define EIM_MAC_PSTAT_RXLPI_NORM 0x00000000 */
+/** low-power idle state */
+#define EIM_MAC_PSTAT_RXLPI_LPI 0x00000001
+
+/* Fields of "MAC Interrupt Status Register" */
+/** PHY Receive Error
+    Indicates the reception of an errored frame. */
+#define EIM_MAC_PISR_RXER 0x00004000
+/* no interrupt condition detected
+#define EIM_MAC_PISR_RXER_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_RXER_INT 0x00004000
+/** PHY Active Status
+    Indicates a change of link activity. See PSTAT register. */
+#define EIM_MAC_PISR_PACT 0x00002000
+/* no interrupt condition detected
+#define EIM_MAC_PISR_PACT_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_PACT_INT 0x00002000
+/** Megabit Speed Status
+    Indicates a change of speed mode. See PSTAT register. */
+#define EIM_MAC_PISR_SPEED 0x00001000
+/* no interrupt condition detected
+#define EIM_MAC_PISR_SPEED_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_SPEED_INT 0x00001000
+/** Full Duplex Status
+    Indicates a change of half- or full-duplex mode. See PSTAT register. */
+#define EIM_MAC_PISR_FDUP 0x00000800
+/* no interrupt condition detected
+#define EIM_MAC_PISR_FDUP_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_FDUP_INT 0x00000800
+/** Receive Pause Enable Status
+    Indicates a change of Receive Pause Enable Status. See PSTAT register. */
+#define EIM_MAC_PISR_RXPAUEN 0x00000400
+/* no interrupt condition detected
+#define EIM_MAC_PISR_RXPAUEN_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_RXPAUEN_INT 0x00000400
+/** Transmit Pause Enable Status
+    Indicates a change of Transmit Pause Enable Status. See PSTAT register. */
+#define EIM_MAC_PISR_TXPAUEN 0x00000200
+/* no interrupt condition detected
+#define EIM_MAC_PISR_TXPAUEN_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_TXPAUEN_INT 0x00000200
+/** Receive Low-power Idle Mode is left
+    Indicates that LPI mode has been left in receive (ingress) direction. */
+#define EIM_MAC_PISR_LPIOFF 0x00000100
+/* no interrupt condition detected
+#define EIM_MAC_PISR_LPIOFF_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_LPIOFF_INT 0x00000100
+/** Receive Low-power Idle Mode is entered
+    Indicates that a Low-power Idle condition has been detected in receive (ingress) direction. */
+#define EIM_MAC_PISR_LPION 0x00000080
+/* no interrupt condition detected
+#define EIM_MAC_PISR_LPION_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_LPION_INT 0x00000080
+/** Jam Status Detected
+    Indicates that a Jam condition has been detected. */
+#define EIM_MAC_PISR_JAM 0x00000040
+/* no interrupt condition detected
+#define EIM_MAC_PISR_JAM_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_JAM_INT 0x00000040
+/** Too Short Frame Error Detected
+    Indicates that a frame has been received which is shorter than the minimum allowed frame length. */
+#define EIM_MAC_PISR_TOOSHORT 0x00000020
+/* no interrupt condition detected
+#define EIM_MAC_PISR_TOOSHORT_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_TOOSHORT_INT 0x00000020
+/** Too Long Frame Error Detected
+    Indicates that a frame has been received which is longer than the maximum allowed frame length. */
+#define EIM_MAC_PISR_TOOLONG 0x00000010
+/* no interrupt condition detected
+#define EIM_MAC_PISR_TOOLONG_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_TOOLONG_INT 0x00000010
+/** Length Mismatch Error Detected
+    Indicates that a frames has been received where the indicated length did not fit the actually received number of bytes. */
+#define EIM_MAC_PISR_LENERR 0x00000008
+/* no interrupt condition detected
+#define EIM_MAC_PISR_LENERR_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_LENERR_INT 0x00000008
+/** Frame Checksum Error Detected
+    Indicates that an FCS error has been detected for an incoming frame. */
+#define EIM_MAC_PISR_FCSERR 0x00000004
+/* no interrupt condition detected
+#define EIM_MAC_PISR_FCSERR_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_FCSERR_INT 0x00000004
+/** Pause Frame Transmitted
+    Indicates that at least one Pause frame has been transmitted. */
+#define EIM_MAC_PISR_TXPAUSE 0x00000002
+/* no interrupt condition detected
+#define EIM_MAC_PISR_TXPAUSE_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_TXPAUSE_INT 0x00000002
+/** Pause Frame Received
+    Indicates that at least one Pause frame has been received. */
+#define EIM_MAC_PISR_RXPAUSE 0x00000001
+/* no interrupt condition detected
+#define EIM_MAC_PISR_RXPAUSE_NOINT 0x00000000 */
+/** interrupt condition has been detected at least once */
+#define EIM_MAC_PISR_RXPAUSE_INT 0x00000001
+/* Fields of "MAC Interrupt Enable Register" */
+/** PHY Receive Error (A1X) */
+#define EIM_MAC_PIER_A1X_RXER 0x00004000
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_A1X_RXER_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_A1X_RXER_EN 0x00004000
+/** PHY Error Interrupt (A2X) */
+#define EIM_MAC_PIER_A2X_PHYERR 0x00008000
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_PHYERR_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_A2X_PHYERR_EN 0x00008000
+/** Allignment Error Interrupt (A2X) */
+#define EIM_MAC_PIER_A2X_ALIGN 0x00004000
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_ALIGN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_A2X_ALIGN_EN 0x00004000
+/** PHY Active Status */
+#define EIM_MAC_PIER_PACT 0x00002000
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_PACT_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_PACT_EN 0x00002000
+/** Megabit Speed Status */
+#define EIM_MAC_PIER_SPEED 0x00001000
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_SPEED_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_SPEED_EN 0x00001000
+/** Full Duplex Status */
+#define EIM_MAC_PIER_FDUP 0x00000800
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_FDUP_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_FDUP_EN 0x00000800
+/** Receive Pause Enable Status */
+#define EIM_MAC_PIER_RXPAUEN 0x00000400
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_RXPAUEN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_RXPAUEN_EN 0x00000400
+/** Transmit Pause Enable Status */
+#define EIM_MAC_PIER_TXPAUEN 0x00000200
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_TXPAUEN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_TXPAUEN_EN 0x00000200
+/** Low-power Idle Off Interrupt Mask */
+#define EIM_MAC_PIER_LPIOFF 0x00000100
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_LPIOFF_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_LPIOFF_EN 0x00000100
+/** Low-power Idle On Interrupt Mask */
+#define EIM_MAC_PIER_LPION 0x00000080
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_LPION_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_LPION_EN 0x00000080
+/** Jam Status Interrupt Mask */
+#define EIM_MAC_PIER_JAM 0x00000040
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_JAM_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_JAM_EN 0x00000040
+/** Too Short Frame Error Interrupt Mask */
+#define EIM_MAC_PIER_TOOSHORT 0x00000020
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_TOOSHORT_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_TOOSHORT_EN 0x00000020
+/** Too Long Frame Error Interrupt Mask */
+#define EIM_MAC_PIER_TOOLONG 0x00000010
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_TOOLONG_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_TOOLONG_EN 0x00000010
+/** Length Mismatch Error Interrupt Mask */
+#define EIM_MAC_PIER_LENERR 0x00000008
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_LENERR_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_LENERR_EN 0x00000008
+/** Frame Checksum Error Interrupt Mask */
+#define EIM_MAC_PIER_FCSERR 0x00000004
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_FCSERR_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_FCSERR_EN 0x00000004
+/** Transmit Pause Frame Interrupt Mask */
+#define EIM_MAC_PIER_TXPAUSE 0x00000002
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_TXPAUSE_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_TXPAUSE_EN 0x00000002
+/** Receive Pause Frame Interrupt Mask */
+#define EIM_MAC_PIER_RXPAUSE 0x00000001
+/* interrupt is disabled (default)
+#define EIM_MAC_PIER_RXPAUSE_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_MAC_PIER_RXPAUSE_EN 0x00000001
+
+/* Fields of "MAC Control Register 0" */
+/** Late Collision Control
+    Late collision handling is different for 10/100BASE-T and 1000BASE-T operation mode. Frames can either be dropped or repeated. */
+#define EIM_MAC_A1X_CTRL_0_LCOL_MASK 0x00006000
+/** field offset */
+#define EIM_MAC_A1X_CTRL_0_LCOL_OFFSET 13
+/** mode detected by autonegotiation (default) */
+#define EIM_MAC_A1X_CTRL_0_LCOL_AUTO 0x00000000
+/** drop frames in case of late collisions */
+#define EIM_MAC_A1X_CTRL_0_LCOL_DRP 0x00002000
+/** repeat frames in case of late collisions */
+#define EIM_MAC_A1X_CTRL_0_LCOL_REP 0x00004000
+/** reserved */
+#define EIM_MAC_A1X_CTRL_0_LCOL_RES 0x00006000
+/** Burst Mode Control
+    Burst frame transmission can be used in half duplex mode to claim the carrier for more than one frame. */
+#define EIM_MAC_CTRL_0_BM 0x00001000
+/* burst mode is disabled (default)
+#define EIM_MAC_CTRL_0_BM_DIS 0x00000000 */
+/** burst mode is enabled */
+#define EIM_MAC_CTRL_0_BM_EN 0x00001000
+/** Automatic VLAN Padding Enable
+    Padding of short VLAN frames can be enabled. Normal frames and VLAN frames are automatically distinguished. */
+#define EIM_MAC_CTRL_0_APADEN 0x00000800
+/* VLAN padding is disabled (default)
+#define EIM_MAC_CTRL_0_APADEN_DIS 0x00000000 */
+/** VLAN padding is enabled */
+#define EIM_MAC_CTRL_0_APADEN_EN 0x00000800
+/** Stacked VLAN Padding Enable
+    Padding of short stacked VLAN frames can be enabled. The following conditions apply: */
+#define EIM_MAC_CTRL_0_VPAD2EN 0x00000400
+/* stacked VLAN padding is disabled (default)
+#define EIM_MAC_CTRL_0_VPAD2EN_DIS 0x00000000 */
+/** stacked VLAN padding is enabled */
+#define EIM_MAC_CTRL_0_VPAD2EN_EN 0x00000400
+/** VLAN Padding Enable
+    Padding of short VLAN frames can be enabled. The following conditions apply: */
+#define EIM_MAC_CTRL_0_VPADEN 0x00000200
+/* VLAN padding is disabled (default)
+#define EIM_MAC_CTRL_0_VPADEN_DIS 0x00000000 */
+/** VLAN padding is enabled */
+#define EIM_MAC_CTRL_0_VPADEN_EN 0x00000200
+/** Padding Enable
+    Padding of short frames can be enabled. If disabled, bits APADEN, VPADEN, and VPAD2EN are ignored. */
+#define EIM_MAC_CTRL_0_PADEN 0x00000100
+/* padding is disabled (default)
+#define EIM_MAC_CTRL_0_PADEN_DIS 0x00000000 */
+/** padding is enabled */
+#define EIM_MAC_CTRL_0_PADEN_EN 0x00000100
+/** Transmit FCS Control
+    Frame checksum generation can be enabled in transmit direction. If disabled, no FCS is attached. */
+#define EIM_MAC_CTRL_0_FCS 0x00000080
+/* FCS generation is disabled
+#define EIM_MAC_CTRL_0_FCS_DIS 0x00000000 */
+/** FCS generation is enabled (default) */
+#define EIM_MAC_CTRL_0_FCS_EN 0x00000080
+/** Flow Control Mode
+    Selects the flow control operation mode. */
+#define EIM_MAC_CTRL_0_FCON_MASK 0x00000070
+/** field offset */
+#define EIM_MAC_CTRL_0_FCON_OFFSET 4
+/** mode detected by autonegotiation (default) */
+#define EIM_MAC_CTRL_0_FCON_AUTO 0x00000000
+/** flow control in receive (ingress direction) only */
+#define EIM_MAC_CTRL_0_FCON_RX 0x00000010
+/** flow control in transmit (egress direction) only */
+#define EIM_MAC_CTRL_0_FCON_TX 0x00000020
+/** flow control in receive and transmit direction */
+#define EIM_MAC_CTRL_0_FCON_RXTX 0x00000030
+/** flow control is disabled */
+#define EIM_MAC_CTRL_0_FCON_NONE 0x00000040
+/** reserved */
+#define EIM_MAC_CTRL_0_FCON_RES1 0x00000050
+/** reserved */
+#define EIM_MAC_CTRL_0_FCON_RES2 0x00000060
+/** reserved */
+#define EIM_MAC_CTRL_0_FCON_RES3 0x00000070
+/** Full Duplex Control
+    Selects between automatic, half-duplex and full-duplex mode. */
+#define EIM_MAC_CTRL_0_FDUP_MASK 0x0000000C
+/** field offset */
+#define EIM_MAC_CTRL_0_FDUP_OFFSET 2
+/** mode detected by autonegotiation (default) */
+#define EIM_MAC_CTRL_0_FDUP_AUTO 0x00000000
+/** full duplex mode */
+#define EIM_MAC_CTRL_0_FDUP_EN 0x00000004
+/** reserved */
+#define EIM_MAC_CTRL_0_FDUP_RES 0x00000008
+/** half duplex mode */
+#define EIM_MAC_CTRL_0_FDUP_DIS 0x0000000C
+/** GMII/MII interface mode selection
+    Selects between GMII and MII interface mode. */
+#define EIM_MAC_CTRL_0_GMII_MASK 0x00000003
+/** field offset */
+#define EIM_MAC_CTRL_0_GMII_OFFSET 0
+/** mode detected by autonegotiation (default) */
+#define EIM_MAC_CTRL_0_GMII_AUTO 0x00000000
+/** MII/RMII interface mode at 10, 100, or 200 Mbit/s */
+#define EIM_MAC_CTRL_0_GMII_MII 0x00000001
+/** GMII/RGMII interface mode at 1000 Mbit/s */
+#define EIM_MAC_CTRL_0_GMII_GMII 0x00000002
+/** reserved */
+#define EIM_MAC_CTRL_0_GMII_RES 0x00000003
+
+/* Fields of "MAC Control Register 1" */
+/** Short Preamble Control
+    Shorten the Preamble to 1 byte. */
+#define EIM_MAC_CTRL_1_SHORTPRE 0x00000100
+/* Preamble is 7 byte (default)
+#define EIM_MAC_CTRL_1_SHORTPRE_DIS 0x00000000 */
+/** Preamble is 1 byte */
+#define EIM_MAC_CTRL_1_SHORTPRE_EN 0x00000100
+/** Minimum Inter Packet Gap Size
+    Number of bytes to be inserted between frames that are transmitted back-to-back. */
+#define EIM_MAC_CTRL_1_IPG_MASK 0x0000000F
+/** field offset */
+#define EIM_MAC_CTRL_1_IPG_OFFSET 0
+
+/* Fields of "MAC Control Register 2" */
+/** Maximum Untagged Frame Length
+    Defines the maximum length of frames to be received, given in number of bytes. They do not include the optional VLAN tag(s). */
+#define EIM_MAC_CTRL_2_MLEN 0x00000008
+/* 1518 byte (no VLAN tags included, default)
+#define EIM_MAC_CTRL_2_MLEN_NORMAL 0x00000000 */
+/** configured value, including any number of VLAN tags */
+#define EIM_MAC_CTRL_2_MLEN_JUMBO 0x00000008
+/** Frame Length Check Long Enable
+    The length of received Ethernet frames is checked against the configured limit. */
+#define EIM_MAC_CTRL_2_LCHKL 0x00000004
+/* length check long is disabled
+#define EIM_MAC_CTRL_2_LCHKL_DIS 0x00000000 */
+/** length check long is enabled (default) */
+#define EIM_MAC_CTRL_2_LCHKL_EN 0x00000004
+/** Frame Length Check Short Enable
+    The length of received Ethernet frames is checked against the standard minimum of 64 byte including VLAN TAG's or leaving VLAN TAG's unconsidered. */
+#define EIM_MAC_CTRL_2_LCHKS_MASK 0x00000003
+/** field offset */
+#define EIM_MAC_CTRL_2_LCHKS_OFFSET 0
+/** length check short is disabled */
+#define EIM_MAC_CTRL_2_LCHKS_DIS 0x00000000
+/** length check short is enabled for 64 byte, VLAN TAGs unconsidered */
+#define EIM_MAC_CTRL_2_LCHKS_EN_UNTAG 0x00000001
+/** length check short is enabled including detected VLAN TAG's */
+#define EIM_MAC_CTRL_2_LCHKS_EN_TAG 0x00000002
+/** RESERVED */
+#define EIM_MAC_CTRL_2_LCHKS_RESERVED 0x00000003
+
+/* Fields of "MAC Control Register 3" */
+/** Retry Count
+    Defines the number of retries in case of collisions. The default is 15. */
+#define EIM_MAC_CTRL_3_RCNT_MASK 0x0000000F
+/** field offset */
+#define EIM_MAC_CTRL_3_RCNT_OFFSET 0
+
+/* Fields of "MAC Control Register 4" */
+/** LPI Wait Time for 1G (only A2X)
+    Defines the wait time for the EEE state machine. */
+#define EIM_MAC_CTRL_4_GWAIT_MASK 0x00007F00
+/** field offset */
+#define EIM_MAC_CTRL_4_GWAIT_OFFSET 8
+/** LPI Mode Enable
+    Enables the LPI function. */
+#define EIM_MAC_CTRL_4_LPIEN 0x00000080
+/* the LPI function is disabled
+#define EIM_MAC_CTRL_4_LPIEN_DIS 0x00000000 */
+/** the LPI function is enabled */
+#define EIM_MAC_CTRL_4_LPIEN_EN 0x00000080
+/** LPI Wait Time (for 100M on A2X)
+    Defines the wait time for the EEE state machine. */
+#define EIM_MAC_CTRL_4_WAIT_MASK 0x0000007F
+/** field offset */
+#define EIM_MAC_CTRL_4_WAIT_OFFSET 0
+
+/* Fields of "MAC Control Register 5" */
+/** Prolonged Jam pattern size during no-backpressure state
+    Jam pattern size in case of no backpressure. */
+#define EIM_MAC_CTRL_5_PJPS_NOBP 0x00000002
+/* 32 bit jam pattern
+#define EIM_MAC_CTRL_5_PJPS_NOBP_SHORT 0x00000000 */
+/** 64 bit jam pattern */
+#define EIM_MAC_CTRL_5_PJPS_NOBP_LONG 0x00000002
+/** Prolonged Jam pattern size during backpressure state
+    Jam pattern size in case of backpressure. */
+#define EIM_MAC_CTRL_5_PJPS_BP 0x00000001
+/* 32 bit jam pattern
+#define EIM_MAC_CTRL_5_PJPS_BP_SHORT 0x00000000 */
+/** 64 bit jam pattern */
+#define EIM_MAC_CTRL_5_PJPS_BP_LONG 0x00000001
+
+/* Fields of "Transmit and Receive Buffer Control Register" */
+/** Delay
+    This register is used to configure the initial delay of the write pointer in the receive buffer. */
+#define EIM_MAC_A1X_CTRL_6_RBUF_DLY_WP_MASK 0x00000E00
+/** field offset */
+#define EIM_MAC_A1X_CTRL_6_RBUF_DLY_WP_OFFSET 9
+/** Receive Buffer Initialization
+    If this control bit is activated the receive buffer will be reset and initialized (idle state). */
+#define EIM_MAC_A1X_CTRL_6_RBUF_INIT 0x00000100
+/* the receive buffer is operating normally
+#define EIM_MAC_A1X_CTRL_6_RBUF_INIT_NOP 0x00000000 */
+/** the receive buffer is initialized */
+#define EIM_MAC_A1X_CTRL_6_RBUF_INIT_INIT 0x00000100
+/** Bypass the Receive Buffer
+    This bit controls the receive buffer bypass mode. */
+#define EIM_MAC_A1X_CTRL_6_RBUF_BYPASS 0x00000040
+/* receive buffer is active
+#define EIM_MAC_A1X_CTRL_6_RBUF_BYPASS_BUFFER 0x00000000 */
+/** receive buffer is bypassed */
+#define EIM_MAC_A1X_CTRL_6_RBUF_BYPASS_BYPASS 0x00000040
+/** Delay
+    This register is used to configure the initial delay of the write pointer in the transmit buffer. */
+#define EIM_MAC_A1X_CTRL_6_XBUF_DLY_WP_MASK 0x00000038
+/** field offset */
+#define EIM_MAC_A1X_CTRL_6_XBUF_DLY_WP_OFFSET 3
+/** Initialize the Transmit Buffer
+    If this control bit is activated the transmit buffer will be reset and initialized (idle state). */
+#define EIM_MAC_A1X_CTRL_6_XBUF_INIT 0x00000004
+/* the transmit buffer is operating normally
+#define EIM_MAC_A1X_CTRL_6_XBUF_INIT_NOP 0x00000000 */
+/** the transmit buffer is initialized */
+#define EIM_MAC_A1X_CTRL_6_XBUF_INIT_INIT 0x00000004
+/** Bypass the Transmit Buffer
+    This control bit is used to bypass the transmit buffer. */
+#define EIM_MAC_A1X_CTRL_6_XBUF_BYPASS 0x00000001
+/* transmit buffer is active
+#define EIM_MAC_A1X_CTRL_6_XBUF_BYPASS_BUFFER 0x00000000 */
+/** transmit buffer is bypassed */
+#define EIM_MAC_A1X_CTRL_6_XBUF_BYPASS_BYPASS 0x00000001
+
+/* Fields of "MAC Receive and Transmit Buffer Status Register" */
+/** Receive Buffer Underflow Indicator
+    Indicates if one or more receive buffer underflow events have been detected. */
+#define EIM_MAC_A1X_BUFST_RBUF_UFL 0x00000008
+/* Underflow never detected
+#define EIM_MAC_A1X_BUFST_RBUF_UFL_NONE 0x00000000 */
+/** Underflow occurred at least once */
+#define EIM_MAC_A1X_BUFST_RBUF_UFL_UFL 0x00000008
+/** Receive Buffer Overflow Indicator
+    Indicates if one or more receive buffer overflow events have been detected. */
+#define EIM_MAC_A1X_BUFST_RBUF_OFL 0x00000004
+/* Overflow never detected
+#define EIM_MAC_A1X_BUFST_RBUF_OFL_NONE 0x00000000 */
+/** Overflow occurred at least once */
+#define EIM_MAC_A1X_BUFST_RBUF_OFL_OFL 0x00000004
+/** Transmit Buffer Underflow Indicator
+    Indicates if one or more transmit buffer underflow events have been detected. */
+#define EIM_MAC_A1X_BUFST_XBUF_UFL 0x00000002
+/* Underflow never detected
+#define EIM_MAC_A1X_BUFST_XBUF_UFL_NONE 0x00000000 */
+/** Underflow occurred at least once */
+#define EIM_MAC_A1X_BUFST_XBUF_UFL_UFL 0x00000002
+/** Transmit Buffer Overflow Indicator
+    Indicates if one or more transmit buffer overflow events have been detected. */
+#define EIM_MAC_A1X_BUFST_XBUF_OFL 0x00000001
+/* Overflow never detected
+#define EIM_MAC_A1X_BUFST_XBUF_OFL_NONE 0x00000000 */
+/** Overflow occurred at least once */
+#define EIM_MAC_A1X_BUFST_XBUF_OFL_OFL 0x00000001
+
+/* Fields of "MAC Test Enable Register" */
+/** Jitter Test Enable
+    Loopback mode for test purposes. */
+#define EIM_MAC_TESTEN_JTEN 0x00000004
+/* test mode is disabled (default)
+#define EIM_MAC_TESTEN_JTEN_NORM 0x00000000 */
+/** test mode is enabled */
+#define EIM_MAC_TESTEN_JTEN_TEST 0x00000004
+/** Transmit Error Insertion
+    Inject a transmit error during frame transmission. */
+#define EIM_MAC_TESTEN_TXER 0x00000002
+/* test mode is disabled (default)
+#define EIM_MAC_TESTEN_TXER_NORM 0x00000000 */
+/** test mode is enabled */
+#define EIM_MAC_TESTEN_TXER_TEST 0x00000002
+/** MAC Loopback Enable
+    8-bit PCS loopback mode for test purposes. */
+#define EIM_MAC_TESTEN_LOOP 0x00000001
+/* loopback is disabled (default)
+#define EIM_MAC_TESTEN_LOOP_DIS 0x00000000 */
+/** loopback is enabled */
+#define EIM_MAC_TESTEN_LOOP_EN 0x00000001
+
+/* Fields of "Reset Control Register" */
+/** MDIO Software Reset
+    This register controls the software reset of the MDIO module. */
+#define EIM_GPHY_CTL_A1X_MDIO_SRST 0x00000004
+/* Run
+#define EIM_GPHY_CTL_A1X_MDIO_SRST_RUN 0x00000000 */
+/** Reset the GPHY */
+#define EIM_GPHY_CTL_A1X_MDIO_SRST_RESET 0x00000004
+/** GPHY Software Reset
+    This register controls the software reset of the GPHY IP macro. */
+#define EIM_GPHY_CTL_GPHY_SRST_1 0x00000002
+/* Reset the GPHY
+#define EIM_GPHY_CTL_GPHY_SRST_1_RESET 0x00000000 */
+/** Run */
+#define EIM_GPHY_CTL_GPHY_SRST_1_RUN 0x00000002
+/** GPHY Software Reset
+    This register controls the software reset of the GPHY IP macro. */
+#define EIM_GPHY_CTL_GPHY_SRST_0 0x00000001
+/* Reset the GPHY
+#define EIM_GPHY_CTL_GPHY_SRST_0_RESET 0x00000000 */
+/** Run */
+#define EIM_GPHY_CTL_GPHY_SRST_0_RUN 0x00000001
+
+/* Fields of "GPHY Version Configuration Register" */
+/** CHIP Version Configuration
+    This type of information is evaluated by the integrated */
+#define EIM_GPHY_CFG_VER_CHIP_VER_MASK 0x000000F0
+/** field offset */
+#define EIM_GPHY_CFG_VER_CHIP_VER_OFFSET 4
+/** Chip-ID of the instantiating SOC Configuration
+    These pins specify the Chip Identification Number of the */
+#define EIM_GPHY_CFG_VER_CHIP_ID_MASK 0x0000000F
+/** field offset */
+#define EIM_GPHY_CFG_VER_CHIP_ID_OFFSET 0
+
+/* Fields of "GPHY PLL Configuration Register" */
+/** Divider 1 */
+#define EIM_GPHY_CFG_PLL_DIV1_MASK 0x0000003E
+/** field offset */
+#define EIM_GPHY_CFG_PLL_DIV1_OFFSET 1
+/** Divider 0 */
+#define EIM_GPHY_CFG_PLL_DIV0 0x00000001
+
+/* Fields of "GPHY General Configuration Register" */
+/** Base Frequency Deviation Configuration
+    This input is used as a pin-strapping to specify the deviation */
+#define EIM_GPHY_CFG_GEN_BFDEV_MASK 0xFFFF0000
+/** field offset */
+#define EIM_GPHY_CFG_GEN_BFDEV_OFFSET 16
+/** General Purpose Pin-Strapping
+    Use this input to pin-strap software mapped functionality. */
+#define EIM_GPHY_CFG_GEN_GPS_MASK 0x0000FF00
+/** field offset */
+#define EIM_GPHY_CFG_GEN_GPS_OFFSET 8
+/** MDIO Interrupt Polarity Configuration
+    This type of information is evaluated by the integrated */
+#define EIM_GPHY_CFG_GEN_MDINTP 0x00000008
+/* MDIO interrupt is low-active
+#define EIM_GPHY_CFG_GEN_MDINTP_LOW 0x00000000 */
+/** MDIO interrupt is high-active */
+#define EIM_GPHY_CFG_GEN_MDINTP_HIGH 0x00000008
+/** Clock Input Single-Ended Configuration
+    This pin allows for a pin-strapping in order to select the */
+#define EIM_GPHY_CFG_GEN_SECLK_EN 0x00000004
+/* Use CLK_DIFF_IN[P/N] as clock.
+#define EIM_GPHY_CFG_GEN_SECLK_EN_DIFFERENTIAL 0x00000000 */
+/** Use CLK as input clock source. */
+#define EIM_GPHY_CFG_GEN_SECLK_EN_SINGLE_ENDED 0x00000004
+/** Clock Input Speed Bypass Configuration
+    This pin allows for a pin-strapping in order to select the */
+#define EIM_GPHY_CFG_GEN_CLK 0x00000002
+/* Input Clock is provided at 25MHz.
+#define EIM_GPHY_CFG_GEN_CLK_MHZ25 0x00000000 */
+/** Input Clock is provided at 125MHz. */
+#define EIM_GPHY_CFG_GEN_CLK_MHZ125 0x00000002
+/** PLL Bypass Configuration
+    This is the PLL Bypass Configuration Pin. It can be used to */
+#define EIM_GPHY_CFG_GEN_PLLBYP 0x00000001
+/* PLL is used in normal mode
+#define EIM_GPHY_CFG_GEN_PLLBYP_NORMAL 0x00000000 */
+/** PLL is bypassed */
+#define EIM_GPHY_CFG_GEN_PLLBYP_BYPASS 0x00000001
+
+/* Fields of "GPHY Auto-Negotiation Capability Configuration Register" */
+/** Autonegociation Capability for Pause
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_PS_MASK 0x00000300
+/** field offset */
+#define EIM_GPHY_CFG_ANEG_CAP_PS_OFFSET 8
+/** No Pause Supported. */
+#define EIM_GPHY_CFG_ANEG_CAP_PS_NO 0x00000000
+/** Asymmetric Pause towards Link-Partner */
+#define EIM_GPHY_CFG_ANEG_CAP_PS_ASYM 0x00000100
+/** Symetric Pause */
+#define EIM_GPHY_CFG_ANEG_CAP_PS_SYM 0x00000200
+/** Symmetric Pause and Asymmetric Pause towards local device */
+#define EIM_GPHY_CFG_ANEG_CAP_PS_BOTH 0x00000300
+/** Autonegociation Capability for 100baseFX Full-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_100BFX_FDX 0x00000080
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_100BFX_FDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_100BFX_FDX_ENABLE 0x00000080
+/** Autonegociation Capability for 100baseFX Half-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_100BFX_HDX 0x00000040
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_100BFX_HDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_100BFX_HDX_ENABLE 0x00000040
+/** Autonegociation Capability for 10baseT Full-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_10BT_FDX 0x00000020
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_10BT_FDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_10BT_FDX_ENABLE 0x00000020
+/** Autonegociation Capability for 10baseT Half-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_10BT_HDX 0x00000010
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_10BT_HDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_10BT_HDX_ENABLE 0x00000010
+/** Autonegociation Capability for 100baseTX Full-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_100BTX_FDX 0x00000008
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_100BTX_FDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_100BTX_FDX_ENABLE 0x00000008
+/** Autonegociation Capability for 100baseTX Half-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_100BTX_HDX 0x00000004
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_100BTX_HDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_100BTX_HDX_ENABLE 0x00000004
+/** Autonegociation Capability for 1000baseT Full-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_1000BT_FDX 0x00000002
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_1000BT_FDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_1000BT_FDX_ENABLE 0x00000002
+/** Autonegociation Capability for 1000baseT Half-Duplex
+    Use this input to select the capabilities which shall be */
+#define EIM_GPHY_CFG_ANEG_CAP_1000BT_HDX 0x00000001
+/* Disables this Capability
+#define EIM_GPHY_CFG_ANEG_CAP_1000BT_HDX_DISBALE 0x00000000 */
+/** Enables this Capability */
+#define EIM_GPHY_CFG_ANEG_CAP_1000BT_HDX_ENABLE 0x00000001
+
+/* Fields of "GPHY PHY Address Configuration Register" */
+/** Physical Layer Address 2 (MDIO) Configuration
+    This is the Configuration Input for the MDIO address of the */
+#define EIM_GPHY_CFG_ADDR_PHYADR2_MASK 0x00001F00
+/** field offset */
+#define EIM_GPHY_CFG_ADDR_PHYADR2_OFFSET 8
+/** Physical Layer Address 1 (MDIO) Configuration
+    This is the Configuration Input for the MDIO address of the */
+#define EIM_GPHY_CFG_ADDR_PHYADR1_MASK 0x0000001F
+/** field offset */
+#define EIM_GPHY_CFG_ADDR_PHYADR1_OFFSET 0
+
+/* Fields of "Configuration register for Strobe Generator 0 (2Hz target frequency)" */
+/** Strobe Generator Mode
+    Enables the strobe generator. */
+#define EIM_EIM_STRB_GEN0_CTL_EN 0x40000000
+/* Disable
+#define EIM_EIM_STRB_GEN0_CTL_EN_DIS 0x00000000 */
+/** Strobe Generator Mode
+    Selects the operating mode. When set to PULSE, the generated strobe will only be active for 1 system clock cycle. Otherwise a symmetric duty cycle will be generated. */
+#define EIM_EIM_STRB_GEN0_CTL_MODE 0x20000000
+/* Symmetric Duty Cycle
+#define EIM_EIM_STRB_GEN0_CTL_MODE_SYM 0x00000000 */
+/** Pulsed Shape */
+#define EIM_EIM_STRB_GEN0_CTL_MODE_PULSE 0x20000000
+/** Divider
+    Sets the divider value used for strobe generation. By default strobe generator 0 will produce a 2Hz signal derived from a 125 MHz clock. */
+#define EIM_EIM_STRB_GEN0_CTL_DVD_MASK 0x1FFFFFFF
+/** field offset */
+#define EIM_EIM_STRB_GEN0_CTL_DVD_OFFSET 0
+
+/* Fields of "Configuration register for Strobe Generator 1 (25MHz target frequency)" */
+/** Strobe Generator Mode
+    Enables the strobe generator. */
+#define EIM_EIM_STRB_GEN1_CTL_EN 0x40000000
+/* Disable
+#define EIM_EIM_STRB_GEN1_CTL_EN_DIS 0x00000000 */
+/** Strobe Generator Mode
+    Selects the operating mode. When set to PULSE, the generated strobe will only be active for 1 system clock cycle. Otherwise a symmetric duty cycle will be generated. */
+#define EIM_EIM_STRB_GEN1_CTL_MODE 0x20000000
+/* Symmetric Duty Cycle
+#define EIM_EIM_STRB_GEN1_CTL_MODE_SYM 0x00000000 */
+/** Pulsed Shape */
+#define EIM_EIM_STRB_GEN1_CTL_MODE_PULSE 0x20000000
+/** Divider
+    Sets the divider value used for strobe generation. By default strobe generator 1 will produce a 25MHz signal derived from a 125 MHz clock. */
+#define EIM_EIM_STRB_GEN1_CTL_DVD_MASK 0x1FFFFFFF
+/** field offset */
+#define EIM_EIM_STRB_GEN1_CTL_DVD_OFFSET 0
+
+/* Fields of "Configuration register for Packet Engine Interface 0" */
+/** Threshold for LAN-Interface
+    Number of words which need to be available at LAN Interface before 'not empty' is signalled. */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_3_MASK 0xFF000000
+/** field offset */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_3_OFFSET 24
+/** Threshold for LAN-Interface
+    Number of words which need to be available at LAN Interface before 'not empty' is signalled. */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_2_MASK 0x00FF0000
+/** field offset */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_2_OFFSET 16
+/** Threshold for LAN-Interface
+    Number of words which need to be available at LAN Interface before 'not empty' is signalled. */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_1_MASK 0x0000FF00
+/** field offset */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_1_OFFSET 8
+/** Threshold for LAN-Interface
+    Number of words which need to be available at LAN Interface before 'not empty' is signalled. */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_0_MASK 0x000000FF
+/** field offset */
+#define EIM_EIM_LAN_IFC_CFG_0_THR_0_OFFSET 0
+
+/* Fields of "Configuration register for Packet Engine Interface 1" */
+/** SEND LPI on MAC-TX
+    Starting with the next interframe gap Low-Power Idle will be send instead of normal idle. Should only be activated when no data is expected to be transferred on this interface for some while. */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_3 0x00000080
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_3_OFF 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_3_ON 0x00000080
+/** SEND LPI on MAC-TX
+    Starting with the next interframe gap Low-Power Idle will be send instead of normal idle. Should only be activated when no data is expected to be transferred on this interface for some while. */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_2 0x00000040
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_2_OFF 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_2_ON 0x00000040
+/** SEND LPI on MAC-TX
+    Starting with the next interframe gap Low-Power Idle will be send instead of normal idle. Should only be activated when no data is expected to be transferred on this interface for some while. */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_1 0x00000020
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_1_OFF 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_1_ON 0x00000020
+/** SEND LPI on MAC-TX
+    Starting with the next interframe gap Low-Power Idle will be send instead of normal idle. Should only be activated when no data is expected to be transferred on this interface for some while. */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_0 0x00000010
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_0_OFF 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_TXLPI_0_ON 0x00000010
+/** Byte Endianess on LAN-Interface
+    Selects the byte endianess on LAN Interface. (Little means, byte 0 is on bit position 7..0 of the incoming 32-bit vector.) */
+#define EIM_EIM_LAN_IFC_CFG_1_END_3 0x00000008
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_END_3_BIG 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_END_3_LITTLE 0x00000008
+/** Byte Endianess on LAN-Interface
+    Selects the byte endianess on LAN Interface. (Little means, byte 0 is on bit position 7..0 of the incoming 32-bit vector.) */
+#define EIM_EIM_LAN_IFC_CFG_1_END_2 0x00000004
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_END_2_BIG 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_END_2_LITTLE 0x00000004
+/** Byte Endianess on LAN-Interface
+    Selects the byte endianess on LAN Interface. (Little means, byte 0 is on bit position 7..0 of the incoming 32-bit vector.) */
+#define EIM_EIM_LAN_IFC_CFG_1_END_1 0x00000002
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_END_1_BIG 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_END_1_LITTLE 0x00000002
+/** Byte Endianess on LAN-Interface
+    Selects the byte endianess on LAN Interface. (Little means, byte 0 is on bit position 7..0 of the incoming 32-bit vector.) */
+#define EIM_EIM_LAN_IFC_CFG_1_END_0 0x00000001
+/* Big Endian
+#define EIM_EIM_LAN_IFC_CFG_1_END_0_BIG 0x00000000 */
+/** Little Endian */
+#define EIM_EIM_LAN_IFC_CFG_1_END_0_LITTLE 0x00000001
+
+/* Fields of "MIB Counter (FCS Errored Frames)" */
+/** 32-Bit counter
+    Counts the total number of FCS violated frames. */
+#define EIM_EIM_MIB_FCSER_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_FCSER_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Oversized Frames)" */
+/** 32-Bit counter
+    Counts the total number of frames with more bytes than specified by EIM_MAX_FRSZ. */
+#define EIM_EIM_MIB_OVSZ_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_OVSZ_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Misaligned Frames)" */
+/** 32-Bit counter
+    Counts the total number of frames which aren't byte aligned. */
+#define EIM_EIM_MIB_ALGN_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_ALGN_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Late Collsions)" */
+/** 32-Bit counter
+    Counts the total number of late collisions in half duplex mode. */
+#define EIM_EIM_MIB_LATE_COL_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_LATE_COL_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Excessive Collisions)" */
+/** 32-Bit counter
+    Counts the total number of excessive colisions in half duplex mode. (An excessive collision occurs when a single frame i srepeated more often then the programmed number of times due to a collision). */
+#define EIM_EIM_MIB_EXC_COL_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_EXC_COL_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Single Collisions)" */
+/** 32-Bit counter
+    Counts the total number of frames which experienced a single collision in half duplex mode. (Thus they've been transmitted successfully after the first re-transmission). */
+#define EIM_EIM_MIB_SGL_COL_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_SGL_COL_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Multiple Collisions)" */
+/** 32-Bit counter
+    Counts the total number of frames which experienced multiple collision in half duplex mode. (The frame was successfully transmitted after more than one retry; butr less than programmed for excessive collisions). */
+#define EIM_EIM_MIB_MUL_COL_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_MUL_COL_CNT_OFFSET 0
+
+/* Fields of "MIB Counter (Deferred Transmission)" */
+/** 32-Bit counter
+    Counts the total number of frames whose transmission was delayed on its first attempt because the medium was busy. */
+#define EIM_EIM_MIB_DEF_TRANS_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define EIM_EIM_MIB_DEF_TRANS_CNT_OFFSET 0
+
+/* Fields of "Central EIM Interrupt Enable" */
+/** LAN Egress Underflow Enable */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_3 0x00008000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_3 0x00000400
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_EG_UNFL_3_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_3_EN 0x00008000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_3_EN 0x00000400
+/** LAN Egress Underflow Enable */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_2 0x00004000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_2 0x00000200
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_EG_UNFL_2_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_2_EN 0x00004000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_2_EN 0x00000200
+/** LAN Egress Underflow Enable */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_1 0x00002000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_1 0x00000100
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_EG_UNFL_1_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_1_EN 0x00002000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_1_EN 0x00000100
+/** LAN Egress Underflow Enable */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_0 0x00001000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_0 0x00000080
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_EG_UNFL_0_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_EG_UNFL_0_EN 0x00001000
+#define EIM_EIM_IER_A2X_LAN_EG_UNFL_0_EN 0x00000080
+/** LAN Ingress Overflow Enable */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_3 0x00000800
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_3 0x00000040
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_IG_OVFL_3_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_3_EN 0x00000800
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_3_EN 0x00000040
+/** LAN Ingress Overflow Enable */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_2 0x00000400
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_2 0x00000020
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_IG_OVFL_2_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_2_EN 0x00000400
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_2_EN 0x00000020
+/** LAN Ingress Overflow Enable */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_1 0x00000200
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_1 0x00000010
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_IG_OVFL_1_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_1_EN 0x00000200
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_1_EN 0x00000010
+/** LAN Ingress Overflow Enable */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_0 0x00000100
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_0 0x00000008
+/* interrupt is disabled
+#define EIM_EIM_IER_LAN_IG_OVFL_0_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_LAN_IG_OVFL_0_EN 0x00000100
+#define EIM_EIM_IER_A2X_LAN_IG_OVFL_0_EN 0x00000008
+/** SGMII Interrupt Enable */
+#define EIM_EIM_IER_A1X_SGMII_IEN 0x00000080
+#define EIM_EIM_IER_A2X_SGMII_IEN 0x00000004
+/* interrupt is disabled
+#define EIM_EIM_IER_SGMII_IEN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_SGMII_IEN_EN 0x00000080
+#define EIM_EIM_IER_A2X_SGMII_IEN_EN 0x00000004
+/** GPHY1 Interrupt Enable */
+#define EIM_EIM_IER_A1X_GPHY1_IEN 0x00000040
+#define EIM_EIM_IER_A2X_GPHY1_IEN 0x00000002
+/* interrupt is disabled
+#define EIM_EIM_IER_GPHY1_IEN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_GPHY1_IEN_EN 0x00000040
+#define EIM_EIM_IER_A2X_GPHY1_IEN_EN 0x00000002
+/** GPHY0 Interrupt Enable */
+#define EIM_EIM_IER_A1X_GPHY0_IEN 0x00000020
+#define EIM_EIM_IER_A2X_GPHY0_IEN 0x00000001
+/* interrupt is disabled
+#define EIM_EIM_IER_GPHY0_IEN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_GPHY0_IEN_EN 0x00000020
+#define EIM_EIM_IER_A2X_GPHY0_IEN_EN 0x00000001
+/** MDIO Interrupt Enable */
+#define EIM_EIM_IER_A1X_MDIO_IEN 0x00000010
+/* interrupt is disabled
+#define EIM_EIM_IER_A1X_MDIO_IEN_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_MDIO_IEN_EN 0x00000010
+/** MAC Interrupt Enable */
+#define EIM_EIM_IER_A1X_MAC_IRQ_3 0x00000008
+/* interrupt is disabled
+#define EIM_EIM_IER_A1X_MAC_IRQ_3_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_MAC_IRQ_3_EN 0x00000008
+/** MAC Interrupt Enable */
+#define EIM_EIM_IER_A1X_MAC_IRQ_2 0x00000004
+/* interrupt is disabled
+#define EIM_EIM_IER_A1X_MAC_IRQ_2_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_MAC_IRQ_2_EN 0x00000004
+/** MAC Interrupt Enable */
+#define EIM_EIM_IER_A1X_MAC_IRQ_1 0x00000002
+/* interrupt is disabled
+#define EIM_EIM_IER_A1X_MAC_IRQ_1_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_MAC_IRQ_1_EN 0x00000002
+/** MAC Interrupt Enable */
+#define EIM_EIM_IER_A1X_MAC_IRQ_0 0x00000001
+/* interrupt is disabled
+#define EIM_EIM_IER_A1X_MAC_IRQ_0_DIS 0x00000000 */
+/** interrupt is enabled */
+#define EIM_EIM_IER_A1X_MAC_IRQ_0_EN 0x00000001
+
+/* Fields of "Central EIM Interrupt Register" */
+/** MAC Interrupt Request
+    Interrupt from a MAC port received. This bit is mirrored from register file ETHSW_MACS_PDI. The corresponding interrupt enable bit is also located in that file. */
+#define EIM_EIM_ISR_A2X_MAC_IRQ 0x00000800
+/** LAN Egress Underflow
+    An underflow on the egress lane (MAC TX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_EG_UNFL_3 0x00008000
+#define EIM_EIM_ISR_A2X_LAN_EG_UNFL_3 0x00000400
+/** LAN Egress Underflow
+    An underflow on the egress lane (MAC TX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_EG_UNFL_2 0x00004000
+#define EIM_EIM_ISR_A2X_LAN_EG_UNFL_2 0x00000200
+/** LAN Egress Underflow
+    An underflow on the egress lane (MAC TX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_EG_UNFL_1 0x00002000
+#define EIM_EIM_ISR_A2X_LAN_EG_UNFL_1 0x00000100
+/** LAN Egress Underflow
+    An underflow on the egress lane (MAC TX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_EG_UNFL_0 0x00001000
+#define EIM_EIM_ISR_A2X_LAN_EG_UNFL_0 0x00000080
+/** LAN Ingress Overflow
+    An overflow on the ingress lane (MAC RX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_IG_OVFL_3 0x00000800
+#define EIM_EIM_ISR_A2X_LAN_IG_OVFL_3 0x00000040
+/** LAN Ingress Overflow
+    An overflow on the ingress lane (MAC RX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_IG_OVFL_2 0x00000400
+#define EIM_EIM_ISR_A2X_LAN_IG_OVFL_2 0x00000020
+/** LAN Ingress Overflow
+    An overflow on the ingress lane (MAC RX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_IG_OVFL_1 0x00000200
+#define EIM_EIM_ISR_A2X_LAN_IG_OVFL_1 0x00000010
+/** LAN Ingress Overflow
+    An overflow on the ingress lane (MAC RX) of the LAN interface occured. */
+#define EIM_EIM_ISR_A1X_LAN_IG_OVFL_0 0x00000100
+#define EIM_EIM_ISR_A2X_LAN_IG_OVFL_0 0x00000008
+/** SGMII Interrupt Request */
+#define EIM_EIM_ISR_A1X_SGMII_IRQ 0x00000080
+#define EIM_EIM_ISR_A2X_SGMII_IRQ 0x00000004
+/** GPHY1 Interrupt Request */
+#define EIM_EIM_ISR_A1X_GPHY1_IRQ 0x00000040
+#define EIM_EIM_ISR_A2X_GPHY1_IRQ 0x00000002
+/** GPHY0 Interrupt Request */
+#define EIM_EIM_ISR_A1X_GPHY0_IRQ 0x00000020
+#define EIM_EIM_ISR_A2X_GPHY0_IRQ 0x00000001
+/** MDIO Interrupt Request */
+#define EIM_EIM_ISR_A1X_MDIO_IRQ 0x00000010
+/** MAC Interrupt Request */
+#define EIM_EIM_ISR_A1X_MAC_IRQ_3 0x00000008
+/** MAC Interrupt Request */
+#define EIM_EIM_ISR_A1X_MAC_IRQ_2 0x00000004
+/** MAC Interrupt Request */
+#define EIM_EIM_ISR_A1X_MAC_IRQ_1 0x00000002
+/** MAC Interrupt Request */
+#define EIM_EIM_ISR_A1X_MAC_IRQ_0 0x00000001
+
+/* Fields of "Interrupt Status Register" */
+/** MAC mode: transmission / reception of complete frame finished
+    Initiated (mac_header.start_tx) read or write access (mac_header.wr) in */
+#define EIM_ISTAT_INT_MAC 0x00000001
+
+/* Fields of "Interrupt Enable Register" */
+/** forward interrupt enable */
+#define EIM_IENABLE_INT_MAC 0x00000001
+/* interrupt is disabled
+#define EIM_IENABLE_INT_MAC_DISBALE 0x00000000 */
+/** interrupt is enabled */
+#define EIM_IENABLE_INT_MAC_ENABLE 0x00000001
+
+/* Fields of "Configuration Register" */
+/** reset the MAC FSM
+    0: MAC FSM is not in reset */
+#define EIM_CFG_MAC_FSM_RES 0x00000001
+
+/* Fields of "Startup Phase Data Register" */
+/** ST bits received
+    The received ST bits within the MDIO frame */
+#define EIM_STARTUP_ST_MASK 0xC0000000
+/** field offset */
+#define EIM_STARTUP_ST_OFFSET 30
+/** OP bits received
+    The received OP bits within the MDIO frame */
+#define EIM_STARTUP_OP_MASK 0x30000000
+/** field offset */
+#define EIM_STARTUP_OP_OFFSET 28
+/** PRTAD bits received
+    The received prtad bits within the MDIO Frame (clause 22 the name is PHYAD) */
+#define EIM_STARTUP_PRTAD_MASK 0x0F800000
+/** field offset */
+#define EIM_STARTUP_PRTAD_OFFSET 23
+/** DEVAD bits received
+    The received DEVAD bits within the MDIO Frame (clause 22 the name is REGAD) */
+#define EIM_STARTUP_DEVAD_MASK 0x007C0000
+/** field offset */
+#define EIM_STARTUP_DEVAD_OFFSET 18
+/** TA bits received
+    The received TA */
+#define EIM_STARTUP_TA_MASK 0x00030000
+/** field offset */
+#define EIM_STARTUP_TA_OFFSET 16
+/** DATA bits received
+    The received DATA or ADDRESS (only with clause 45 access) */
+#define EIM_STARTUP_DATA_MASK 0x0000FFFF
+/** field offset */
+#define EIM_STARTUP_DATA_OFFSET 0
+
+/* Fields of "Mac Data Transmit Register" */
+/** data
+    16 bit data to transmit in mac mode (clause 22 data) */
+#define EIM_MAC_DATA_DATA_MASK 0x0000FFFF
+/** field offset */
+#define EIM_MAC_DATA_DATA_OFFSET 0
+
+/* Fields of "Mac Header Transmit Register" */
+/** start_transmission
+    With this bit the transmission of the actual header and data will be send. Self-clearing. */
+#define EIM_MAC_HEADER_START_TX 0x00020000
+/** read/write bit
+    Bit indicates if the next access is a read or a write access (0 write, 1 read) */
+#define EIM_MAC_HEADER_RW 0x00010000
+/* WRITE
+#define EIM_MAC_HEADER_RW_WRITE 0x00000000 */
+/** READ */
+#define EIM_MAC_HEADER_RW_READ 0x00010000
+/** ST bits transmit
+    The transmit ST bits within the MDIO frame */
+#define EIM_MAC_HEADER_ST_MASK 0x0000C000
+/** field offset */
+#define EIM_MAC_HEADER_ST_OFFSET 14
+/** OP bits received
+    The transmit OP bits within the MDIO frame */
+#define EIM_MAC_HEADER_OP_MASK 0x00003000
+/** field offset */
+#define EIM_MAC_HEADER_OP_OFFSET 12
+/** PHYAD bits transmit
+    The transmit prtad bits within the MDIO Frame */
+#define EIM_MAC_HEADER_PHYAD_MASK 0x00000F80
+/** field offset */
+#define EIM_MAC_HEADER_PHYAD_OFFSET 7
+/** REGAD bits transmit
+    The transmit DEVAD bits within the MDIO Frame */
+#define EIM_MAC_HEADER_REGAD_MASK 0x0000007C
+/** field offset */
+#define EIM_MAC_HEADER_REGAD_OFFSET 2
+/** TA bits to transmit
+    The TA bits to transmit */
+#define EIM_MAC_HEADER_TA_MASK 0x00000003
+/** field offset */
+#define EIM_MAC_HEADER_TA_OFFSET 0
+
+/* Fields of "MAC Preamble Transmit Length Register" */
+/** length of preamble
+    Length of the transmitted preamble (ones) */
+#define EIM_PREAMBLE_LEN_MASK 0x0000007F
+/** field offset */
+#define EIM_PREAMBLE_LEN_OFFSET 0
+
+/* Fields of "Preamble Length Register" */
+/** length of preamble
+    Minimum length of the received preamble */
+#define EIM_PREAMBLE_INCOMING_LEN_MASK 0x0000007F
+/** field offset */
+#define EIM_PREAMBLE_INCOMING_LEN_OFFSET 0
+
+/* Fields of "MDIO Control Register" */
+/** MDIO Busy
+    This bit is set to BSY by hardware upon each write access to the register, which starts a transmission. */
+#define EIM_MDIO_CTRL_MBUSY 0x00001000
+/* the bus is available
+#define EIM_MDIO_CTRL_MBUSY_IDLE 0x00000000 */
+/** the bus is busy */
+#define EIM_MDIO_CTRL_MBUSY_BUSY 0x00001000
+/** Operation Code
+    Selects the operation command. The value is directly mapped into the serial address frame. */
+#define EIM_MDIO_CTRL_OP_MASK 0x00000C00
+/** field offset */
+#define EIM_MDIO_CTRL_OP_OFFSET 10
+/** reserved, do not use */
+#define EIM_MDIO_CTRL_OP_RES0 0x00000000
+/** write access */
+#define EIM_MDIO_CTRL_OP_WR 0x00000400
+/** read access */
+#define EIM_MDIO_CTRL_OP_RD 0x00000800
+/** reserved, do not use */
+#define EIM_MDIO_CTRL_OP_RES3 0x00000C00
+/** PHY Address
+    PHY address of the target device. The value is directly mapped into the serial address frame. */
+#define EIM_MDIO_CTRL_PHYAD_MASK 0x000003E0
+/** field offset */
+#define EIM_MDIO_CTRL_PHYAD_OFFSET 5
+/** Register Address
+    Register address in the target device. The value is directly mapped into the serial address frame. */
+#define EIM_MDIO_CTRL_REGAD_MASK 0x0000001F
+/** field offset */
+#define EIM_MDIO_CTRL_REGAD_OFFSET 0
+
+/* Fields of "MDIO Read Data Register" */
+/** Read Data
+    A read access is triggered by writing to MDIO_CTRL (OP = RD, MBUSY = BSY). After MBUSY = RDY, data can be read. */
+#define EIM_MDIO_READ_RDATA_MASK 0x0000FFFF
+/** field offset */
+#define EIM_MDIO_READ_RDATA_OFFSET 0
+
+/* Fields of "MDIO Write Data Register" */
+/** Write Data
+    A write access is triggered by writing to MDIO_CTRL (OP = WR, MBUSY = BSY). */
+#define EIM_MDIO_WRITE_WDATA_MASK 0x0000FFFF
+/** field offset */
+#define EIM_MDIO_WRITE_WDATA_OFFSET 0
+
+/* Fields of "MDC Clock Configuration Register 0" */
+/** Polling State Machine Enable
+    Enables the state machine to read PHY information automatically on this port. Unused ports should be disabled to reduce the polling latency. If px_port_disable is set the autopolling is also disabled. */
+#define EIM_MDC_CFG_0_PEN_3 0x00000008
+/* automatic PHY polling is disabled on this port
+#define EIM_MDC_CFG_0_PEN_3_DIS 0x00000000 */
+/** automatic PHY polling is enabled on this port (default) */
+#define EIM_MDC_CFG_0_PEN_3_EN 0x00000008
+/** Polling State Machine Enable
+    Enables the state machine to read PHY information automatically on this port. Unused ports should be disabled to reduce the polling latency. If px_port_disable is set the autopolling is also disabled. */
+#define EIM_MDC_CFG_0_PEN_2 0x00000004
+/* automatic PHY polling is disabled on this port
+#define EIM_MDC_CFG_0_PEN_2_DIS 0x00000000 */
+/** automatic PHY polling is enabled on this port (default) */
+#define EIM_MDC_CFG_0_PEN_2_EN 0x00000004
+/** Polling State Machine Enable
+    Enables the state machine to read PHY information automatically on this port. Unused ports should be disabled to reduce the polling latency. If px_port_disable is set the autopolling is also disabled. */
+#define EIM_MDC_CFG_0_PEN_1 0x00000002
+/* automatic PHY polling is disabled on this port
+#define EIM_MDC_CFG_0_PEN_1_DIS 0x00000000 */
+/** automatic PHY polling is enabled on this port (default) */
+#define EIM_MDC_CFG_0_PEN_1_EN 0x00000002
+/** Polling State Machine Enable
+    Enables the state machine to read PHY information automatically on this port. Unused ports should be disabled to reduce the polling latency. If px_port_disable is set the autopolling is also disabled. */
+#define EIM_MDC_CFG_0_PEN_0 0x00000001
+/* automatic PHY polling is disabled on this port
+#define EIM_MDC_CFG_0_PEN_0_DIS 0x00000000 */
+/** automatic PHY polling is enabled on this port (default) */
+#define EIM_MDC_CFG_0_PEN_0_EN 0x00000001
+
+/* Fields of "MDC Clock Configuration Register 1" */
+/** MDIO Hardware Reset
+    Reset all hardware modules except for the register settings. */
+#define EIM_MDC_CFG_1_RES 0x00008000
+/* reset is off
+#define EIM_MDC_CFG_1_RES_OFF 0x00000000 */
+/** reset is active */
+#define EIM_MDC_CFG_1_RES_ON 0x00008000
+/** Management Clock Enable
+    Enables the MDC clock driver. The driver can be disabled to save power if no external devices are connected to the MDIO master interface. */
+#define EIM_MDC_CFG_1_MCEN 0x00000100
+/* clock driver is disabled
+#define EIM_MDC_CFG_1_MCEN_DIS 0x00000000 */
+/** clock driver is enabled (default) */
+#define EIM_MDC_CFG_1_MCEN_EN 0x00000100
+/** MDIO Interface Clock Rate
+    Selects the interface data and clock rate for the MDIO master interface. */
+#define EIM_MDC_CFG_1_FREQ_MASK 0x000000FF
+/** field offset */
+#define EIM_MDC_CFG_1_FREQ_OFFSET 0
+/** 25.0 MHz */
+#define EIM_MDC_CFG_1_FREQ_S0 0x00000000
+/** 12.50 MHz */
+#define EIM_MDC_CFG_1_FREQ_S1 0x00000001
+/** 8.333 MHz */
+#define EIM_MDC_CFG_1_FREQ_S2 0x00000002
+/** 6.250 MHz */
+#define EIM_MDC_CFG_1_FREQ_S3 0x00000003
+/** 5.000 MHz */
+#define EIM_MDC_CFG_1_FREQ_S4 0x00000004
+/** 4.167 MHz */
+#define EIM_MDC_CFG_1_FREQ_S5 0x00000005
+/** 3.571 MHz */
+#define EIM_MDC_CFG_1_FREQ_S6 0x00000006
+/** 3.125 MHz */
+#define EIM_MDC_CFG_1_FREQ_S7 0x00000007
+/** 2.778 MHz */
+#define EIM_MDC_CFG_1_FREQ_S8 0x00000008
+/** 2.500 MHz(default) */
+#define EIM_MDC_CFG_1_FREQ_S9 0x00000009
+/** 2.273 MHz */
+#define EIM_MDC_CFG_1_FREQ_S10 0x0000000A
+/** 2.083 MHz */
+#define EIM_MDC_CFG_1_FREQ_S11 0x0000000B
+/** 1.923 MHz */
+#define EIM_MDC_CFG_1_FREQ_S12 0x0000000C
+/** 1.786 MHz */
+#define EIM_MDC_CFG_1_FREQ_S13 0x0000000D
+/** 1.667 MHz */
+#define EIM_MDC_CFG_1_FREQ_S14 0x0000000E
+/** 1.563 MHz */
+#define EIM_MDC_CFG_1_FREQ_S15 0x0000000F
+/** 97.6 kHz */
+#define EIM_MDC_CFG_1_FREQ_S255 0x000000FF
+
+/* Fields of "PHY Address Register PORT 0" */
+/** Link Status Control */
+#define EIM_PHY_ADDR_LNKST_MASK 0x00006000
+/** field offset */
+#define EIM_PHY_ADDR_LNKST_OFFSET 13
+/** automatic mode detection by the Ethernet PHY (default) */
+#define EIM_PHY_ADDR_LNKST_AUTO 0x00000000
+/** the link status is forced up */
+#define EIM_PHY_ADDR_LNKST_UP 0x00002000
+/** the link status is forced down */
+#define EIM_PHY_ADDR_LNKST_DOWN 0x00004000
+/** reserved, do not use */
+#define EIM_PHY_ADDR_LNKST_RES 0x00006000
+/** Speed Control */
+#define EIM_PHY_ADDR_SPEED_MASK 0x00001800
+/** field offset */
+#define EIM_PHY_ADDR_SPEED_OFFSET 11
+/** Data Rate 10 MBPS */
+#define EIM_PHY_ADDR_SPEED_M10 0x00000000
+/** Data Rate 100 MBPS */
+#define EIM_PHY_ADDR_SPEED_M100 0x00000800
+/** Data Rate 1 GBPS */
+#define EIM_PHY_ADDR_SPEED_G1 0x00001000
+/** automatic mode detection by the Ethernet PHY (default) */
+#define EIM_PHY_ADDR_SPEED_AUTO 0x00001800
+/** Full Duplex Control */
+#define EIM_PHY_ADDR_FDUP_MASK 0x00000600
+/** field offset */
+#define EIM_PHY_ADDR_FDUP_OFFSET 9
+/** automatic mode detection by the Ethernet PHY (default) */
+#define EIM_PHY_ADDR_FDUP_AUTO 0x00000000
+/** full duplex mode */
+#define EIM_PHY_ADDR_FDUP_EN 0x00000200
+/** reserved */
+#define EIM_PHY_ADDR_FDUP_RES 0x00000400
+/** half duplex mode */
+#define EIM_PHY_ADDR_FDUP_DIS 0x00000600
+/** Flow Control Mode TX */
+#define EIM_PHY_ADDR_FCONTX_MASK 0x00000180
+/** field offset */
+#define EIM_PHY_ADDR_FCONTX_OFFSET 7
+/** automatic mode detection by the Ethernet PHY (default) */
+#define EIM_PHY_ADDR_FCONTX_AUTO 0x00000000
+/** flow control in receive (ingress direction) only */
+#define EIM_PHY_ADDR_FCONTX_EN 0x00000080
+/** reserved */
+#define EIM_PHY_ADDR_FCONTX_RES 0x00000100
+/** flow control in transmit (egress direction) only */
+#define EIM_PHY_ADDR_FCONTX_DIS 0x00000180
+/** Flow Control Mode RX */
+#define EIM_PHY_ADDR_FCONRX_MASK 0x00000060
+/** field offset */
+#define EIM_PHY_ADDR_FCONRX_OFFSET 5
+/** automatic mode detection by the Ethernet PHY (default) */
+#define EIM_PHY_ADDR_FCONRX_AUTO 0x00000000
+/** flow control in receive (ingress direction) only */
+#define EIM_PHY_ADDR_FCONRX_EN 0x00000020
+/** reserved */
+#define EIM_PHY_ADDR_FCONRX_RES 0x00000040
+/** flow control in transmit (egress direction) only */
+#define EIM_PHY_ADDR_FCONRX_DIS 0x00000060
+/** PHY Address */
+#define EIM_PHY_ADDR_ADDR_MASK 0x0000001F
+/** field offset */
+#define EIM_PHY_ADDR_ADDR_OFFSET 0
+
+/* Fields of "PHY MDIO Polling Status per PORT" */
+/** PHY supports MAC turning of TX clk */
+#define EIM_MDIO_STAT_CLK_STOP_CAPABLE 0x00000100
+/* is not supported
+#define EIM_MDIO_STAT_CLK_STOP_CAPABLE_DIS 0x00000000 */
+/** is supported */
+#define EIM_MDIO_STAT_CLK_STOP_CAPABLE_EN 0x00000100
+/** PHY and link partner support EEE for current speed */
+#define EIM_MDIO_STAT_EEE_CAPABLE 0x00000080
+/* is not supported
+#define EIM_MDIO_STAT_EEE_CAPABLE_DIS 0x00000000 */
+/** is supported */
+#define EIM_MDIO_STAT_EEE_CAPABLE_EN 0x00000080
+/** PHY Active Status
+    Indicates if the external PHY is responding to MDIO accesses. */
+#define EIM_MDIO_STAT_PACT 0x00000040
+/* the PHY is inactive or not present
+#define EIM_MDIO_STAT_PACT_INACTIVE 0x00000000 */
+/** the PHY is active and responds to MDIO accesses */
+#define EIM_MDIO_STAT_PACT_ACTIVE 0x00000040
+/** Link Status
+    This status information is retrieved from the attached Ethernet PHY by polling the related MDIO register. */
+#define EIM_MDIO_STAT_LSTAT 0x00000020
+/* the link is down
+#define EIM_MDIO_STAT_LSTAT_DOWN 0x00000000 */
+/** the link is up */
+#define EIM_MDIO_STAT_LSTAT_UP 0x00000020
+/** Speed Control */
+#define EIM_MDIO_STAT_SPEED_MASK 0x00000018
+/** field offset */
+#define EIM_MDIO_STAT_SPEED_OFFSET 3
+/** Data Rate 10 MBPS */
+#define EIM_MDIO_STAT_SPEED_M10 0x00000000
+/** Data Rate 100 MBPS */
+#define EIM_MDIO_STAT_SPEED_M100 0x00000008
+/** Data Rate 1 GBPS */
+#define EIM_MDIO_STAT_SPEED_G1 0x00000010
+/** reserved */
+#define EIM_MDIO_STAT_SPEED_RES 0x00000018
+/** Full Duplex Status
+    Indicates if the attached PHY runs in half- or full-duplex mode. */
+#define EIM_MDIO_STAT_FDUP 0x00000004
+/* half-duplex mode
+#define EIM_MDIO_STAT_FDUP_HALF 0x00000000 */
+/** full-duplex mode */
+#define EIM_MDIO_STAT_FDUP_FULL 0x00000004
+/** Receive Pause Enable Status
+    This status information is retrieved from the attached Ethernet PHY by polling the related MDIO register. */
+#define EIM_MDIO_STAT_RXPAUEN 0x00000002
+/* the link partner does not send pause frames
+#define EIM_MDIO_STAT_RXPAUEN_DIS 0x00000000 */
+/** the link partner sends pause frames */
+#define EIM_MDIO_STAT_RXPAUEN_EN 0x00000002
+/** Transmit Pause Enable Status
+    This status information is retrieved from the attached Ethernet PHY by polling the related MDIO register. */
+#define EIM_MDIO_STAT_TXPAUEN 0x00000001
+/* the link partner does not accept pause frames
+#define EIM_MDIO_STAT_TXPAUEN_DIS 0x00000000 */
+/** the link partner accepts pause frames */
+#define EIM_MDIO_STAT_TXPAUEN_EN 0x00000001
+
+/* Fields of "EEE auto negotiation overides" */
+/** clk stop capable */
+#define EIM_ANEG_EEE_CLK_STOP_CAPABLE_MASK 0x0000000C
+/** field offset */
+#define EIM_ANEG_EEE_CLK_STOP_CAPABLE_OFFSET 2
+/** automatic detection by auto negotiation with PHY (default) */
+#define EIM_ANEG_EEE_CLK_STOP_CAPABLE_AUTO 0x00000000
+/** force capable on */
+#define EIM_ANEG_EEE_CLK_STOP_CAPABLE_EN 0x00000004
+/** reserved */
+#define EIM_ANEG_EEE_CLK_STOP_CAPABLE_RES 0x00000008
+/** force capable off */
+#define EIM_ANEG_EEE_CLK_STOP_CAPABLE_DIS 0x0000000C
+/** EEE capable */
+#define EIM_ANEG_EEE_EEE_CAPABLE_MASK 0x00000003
+/** field offset */
+#define EIM_ANEG_EEE_EEE_CAPABLE_OFFSET 0
+/** automatic detection by auto negotiation with PHY (default) */
+#define EIM_ANEG_EEE_EEE_CAPABLE_AUTO 0x00000000
+/** force capable on */
+#define EIM_ANEG_EEE_EEE_CAPABLE_EN 0x00000001
+/** reserved */
+#define EIM_ANEG_EEE_EEE_CAPABLE_RES 0x00000002
+/** force capable off */
+#define EIM_ANEG_EEE_EEE_CAPABLE_DIS 0x00000003
+
+/* Fields of "xMII Port Configuration Register" */
+/** Hardware Reset
+    Resets all related hardware modules except for the register settings. */
+#define EIM_MII_CFG_RES 0x00008000
+/* reset is off
+#define EIM_MII_CFG_RES_OFF 0x00000000 */
+/** reset is active */
+#define EIM_MII_CFG_RES_ON 0x00008000
+/** xMII Interface Enable
+    The corresponding port can only be enabled if the disable signal at macro boundary is inactive. */
+#define EIM_MII_CFG_EN 0x00004000
+/* disable the interface
+#define EIM_MII_CFG_EN_DIS 0x00000000 */
+/** Loopback
+    Enables the far-end tesloop which sends back all ingress data (RX when MAC mode) back to the egress port (TX when MAC mode). */
+#define EIM_MII_CFG_LPBK 0x00000800
+/* disable the interface
+#define EIM_MII_CFG_LPBK_DIS 0x00000000 */
+/** enable the interface */
+#define EIM_MII_CFG_LPBK_EN 0x00000800
+/** CRS Sensitivity Configuration
+    These Bits are only valid in PHY Mode. CRS can be configured depending on RX and TX activity and Half/Full Duplex Modes (HDX/FDX) */
+#define EIM_MII_CFG_CRS_MASK 0x00000600
+/** field offset */
+#define EIM_MII_CFG_CRS_OFFSET 9
+/** HDX:TX+RX, FDX:RX */
+#define EIM_MII_CFG_CRS_MODE1 0x00000000
+/** HDX:TX+RX, FDX:0 */
+#define EIM_MII_CFG_CRS_MODE2 0x00000200
+/** HDX:RX, FDX:RX */
+#define EIM_MII_CFG_CRS_MODE3 0x00000400
+/** HDX:RX, FDX:0 */
+#define EIM_MII_CFG_CRS_MODE4 0x00000600
+/** RGMII In Band Status
+    If RGMII mode is selected, this bit controls if the In Band Status Bits Link, Clock Speed duplex are transmitted during IPG */
+#define EIM_MII_CFG_RGMII_IBS 0x00000100
+/* RGMII In Band Status off
+#define EIM_MII_CFG_RGMII_IBS_OFF 0x00000000 */
+/** RGMII In Band Satus on */
+#define EIM_MII_CFG_RGMII_IBS_ON 0x00000100
+/** RMII Reference Clock Direction of the Port
+    If RMII mode is selected, this bit controls the clock source of the port. */
+#define EIM_MII_CFG_RMII 0x00000080
+/* RMII clock is input
+#define EIM_MII_CFG_RMII_IN 0x00000000 */
+/** RMII clock is output */
+#define EIM_MII_CFG_RMII_OUT 0x00000080
+/** xMII Port Interface Clock Rate
+    Selects the data and clock rate for the xMII interface. */
+#define EIM_MII_CFG_MIIRATE_MASK 0x00000070
+/** field offset */
+#define EIM_MII_CFG_MIIRATE_OFFSET 4
+/** 2.5 MHz */
+#define EIM_MII_CFG_MIIRATE_M2P5 0x00000000
+/** 25 MHz */
+#define EIM_MII_CFG_MIIRATE_M25 0x00000010
+/** 125 MHz */
+#define EIM_MII_CFG_MIIRATE_M125 0x00000020
+/** 50 MHz */
+#define EIM_MII_CFG_MIIRATE_M50 0x00000030
+/** Speed used from Autopolling */
+#define EIM_MII_CFG_MIIRATE_AUTO 0x00000040
+/** xMII Interface Mode
+    This selects the xMII interface mode. */
+#define EIM_MII_CFG_MIIMODE_MASK 0x0000000F
+/** field offset */
+#define EIM_MII_CFG_MIIMODE_OFFSET 0
+/** (G)MII PHY mode, connected to external MAC */
+#define EIM_MII_CFG_MIIMODE_MIIP 0x00000000
+/** (G)MII MAC mode, connected to external PHY */
+#define EIM_MII_CFG_MIIMODE_MIIM 0x00000001
+/** RMII PHY mode, connected to external MAC */
+#define EIM_MII_CFG_MIIMODE_RMIIP 0x00000002
+/** RMII MAC mode, connected to external PHY */
+#define EIM_MII_CFG_MIIMODE_RMIIM 0x00000003
+/** RGMII MAC mode, connected to external PHY */
+#define EIM_MII_CFG_MIIMODE_RGMII 0x00000004
+
+/* Fields of "Configuration of Clock Delay" */
+/** Lock Status MDL of Receive PCDU */
+#define EIM_PCDU_RXLOCK 0x00008000
+/* Receive MDL is out of sync
+#define EIM_PCDU_RXLOCK_UNLOCK 0x00000000 */
+/** Receive MDL is LOCKED */
+#define EIM_PCDU_RXLOCK_LOCKED 0x00008000
+/** Lock Status of MDL of Transmit PCDU */
+#define EIM_PCDU_TXLOCK 0x00004000
+/* Transmit MDL is out of sync
+#define EIM_PCDU_TXLOCK_UNLOCK 0x00000000 */
+/** Transmit MDL is LOCKED */
+#define EIM_PCDU_TXLOCK_LOCKED 0x00004000
+/** Input Clock Selection for Receive PCDU
+    Selection of AUTO mode is recommended for normal operation. In this mode, RXCLK is used if the clock rate is 125 MHz and CLKREF in all other cases. */
+#define EIM_PCDU_RXSEL_CLK_MASK 0x00003000
+/** field offset */
+#define EIM_PCDU_RXSEL_CLK_OFFSET 12
+/** Selection of input clock depends on speed */
+#define EIM_PCDU_RXSEL_CLK_AUTO 0x00000000
+/** Input clock is CLKREF (125 MHz) */
+#define EIM_PCDU_RXSEL_CLK_CLKREF 0x00001000
+/** Input clock is RXCLK */
+#define EIM_PCDU_RXSEL_CLK_RXCLK 0x00002000
+/** reserved */
+#define EIM_PCDU_RXSEL_CLK_RES3 0x00003000
+/** Reset of Receive PCDU */
+#define EIM_PCDU_RXINIT 0x00000800
+/* Normal operation of Receive PCDU
+#define EIM_PCDU_RXINIT_NORMAL 0x00000000 */
+/** Reset Receive PCDU */
+#define EIM_PCDU_RXINIT_INIT 0x00000800
+/** Power Down of Receive PCDU */
+#define EIM_PCDU_RXPD 0x00000400
+/* Receive PCDU is enabled
+#define EIM_PCDU_RXPD_ENABLE 0x00000000 */
+/** Receive PCDU is in Power Down Mode */
+#define EIM_PCDU_RXPD_PDOWN 0x00000400
+/** Configure Receive Clock Delay
+    Configure the delay of RX_CLK_D versus RX_CLK in steps of 500 ps. The resulting delay is TD = RXDLY * 500 ps. */
+#define EIM_PCDU_RXDLY_MASK 0x00000380
+/** field offset */
+#define EIM_PCDU_RXDLY_OFFSET 7
+/** Input Reference Clock Selection for Transmit PCDU
+    Selection of AUTO mode is recommended for normal operation. In this mode, TXCLK is used if the clock rate is 125 MHz and CLKREF in all other cases. */
+#define EIM_PCDU_TXSEL_CLK_MASK 0x00000060
+/** field offset */
+#define EIM_PCDU_TXSEL_CLK_OFFSET 5
+/** Selection of input clock depends on speed */
+#define EIM_PCDU_TXSEL_CLK_AUTO 0x00000000
+/** Input clock is CLKREF (125 MHz) */
+#define EIM_PCDU_TXSEL_CLK_CLKREF 0x00000020
+/** Input clock is TXCLK */
+#define EIM_PCDU_TXSEL_CLK_TXCLK 0x00000040
+/** reserved */
+#define EIM_PCDU_TXSEL_CLK_RES3 0x00000060
+/** Reset of Transmit PCDU */
+#define EIM_PCDU_TXINIT 0x00000010
+/* Normal operation of Transmit PCDU
+#define EIM_PCDU_TXINIT_NORMAL 0x00000000 */
+/** Reset Transmit PCDU */
+#define EIM_PCDU_TXINIT_INIT 0x00000010
+/** Power Down of Transmit PCDU */
+#define EIM_PCDU_TXPD 0x00000008
+/* Transmit PCDU is enabled
+#define EIM_PCDU_TXPD_ENABLE 0x00000000 */
+/** Transmit PCDU is in Power Down Mode */
+#define EIM_PCDU_TXPD_PDOWN 0x00000008
+/** Configure Transmit Clock Delay
+    Configure the delay of TX_CLK_D versus TX_CLK in steps of 500ps. The total configured delay is TD = TXDLY * 500ps. */
+#define EIM_PCDU_TXDLY_MASK 0x00000007
+/** field offset */
+#define EIM_PCDU_TXDLY_OFFSET 0
+
+/* Fields of "Configuration of Jitter Buffer" */
+/** TXB Under/Overflow Indicator
+     */
+#define EIM_BUFF_TXB_ERR 0x00002000
+/* TXB Under/Overflow never detected
+#define EIM_BUFF_TXB_ERR_NONE 0x00000000 */
+/** TXB Under/Overflow occurred at least once */
+#define EIM_BUFF_TXB_ERR_ONCE 0x00002000
+/** TXB Write pointer offset to read pointer
+    The read pointer always starts at position 0. The write pointer starts at the programmed value. */
+#define EIM_BUFF_TXB_DLY_MASK 0x00001C00
+/** field offset */
+#define EIM_BUFF_TXB_DLY_OFFSET 10
+/** TXB initialization
+    Initializes the TXB. Should be done afte over- or underflow. */
+#define EIM_BUFF_TXB_INIT 0x00000200
+/** TXB enable
+    Enables the RXB. */
+#define EIM_BUFF_TXB_EN 0x00000100
+/** RXB Under/Overflow Indicator
+     */
+#define EIM_BUFF_RXB_ERR 0x00000020
+/* RXB Under/Overflow never detected
+#define EIM_BUFF_RXB_ERR_NONE 0x00000000 */
+/** RXB Under/Overflow occurred at least once */
+#define EIM_BUFF_RXB_ERR_ONCE 0x00000020
+/** RXB Write pointer offset to read pointer
+    The read pointer always starts at position 0. The write pointer starts at the programmed value. */
+#define EIM_BUFF_RXB_DLY_MASK 0x0000001C
+/** field offset */
+#define EIM_BUFF_RXB_DLY_OFFSET 2
+/** RXB initialization
+    Initializes the RXB. Should be done afte over- or underflow. */
+#define EIM_BUFF_RXB_INIT 0x00000002
+/** RXB enable
+    Enables the RXB. */
+#define EIM_BUFF_RXB_EN 0x00000001
+
+/*! @} */ /* EIM_REGISTER */
+
+#endif /* _eim_reg_h */
diff --git a/drivers/net/falcon/falcon.c b/drivers/net/falcon/falcon.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/falcon.c
@@ -0,0 +1,1080 @@
+/*
+ * FALCON U-boot Ethernet driver
+ * Copyright (c) 2011 Lantiq Deutschland GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+/* #define DEBUG_COUNTER */
+/* #define DEBUG_DATA */
+#include <common.h>
+
+#include <malloc.h>
+#include <net.h>
+#include <miiphy.h>
+#include <hwconfig.h>
+
+#include "falcon_std_defs.h"
+#include "falcon_resource.h"
+#include "falcon_register.h"
+
+#include "falcon_ll.h"
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/sysctrl.h>
+#include <asm/arch/net.h>
+#include <asm/falcon.h>
+
+/*
+ * This driver requires CONFIG_MII for some functionality
+ */
+#if !defined(CONFIG_MII)
+#error CONFIG_MII not set!
+#endif
+
+#define INGRESS_QUEUE FALCON_INGRESS_QUEUE_LAN_0
+
+static struct gpon_reg_sbs0ctrl * const sbs0ctrl =
+	(struct gpon_reg_sbs0ctrl *)GPON_SBS0CTRL_BASE;
+static struct gpon_reg_iqm * const iqm =
+	(struct gpon_reg_iqm *) GPON_IQM_BASE;
+static struct gpon_reg_eim_a1x * const eim_a1x =
+	(struct gpon_reg_eim_a1x *) GPON_EIM_BASE;
+static struct gpon_reg_eim_a2x * const eim_a2x =
+	(struct gpon_reg_eim_a2x *) GPON_EIM_BASE;
+static struct gpon_reg_ictrll * const ictrll0 =
+	(struct gpon_reg_ictrll *) GPON_ICTRLL0_BASE;
+static struct gpon_reg_octrll * const octrll0 =
+	(struct gpon_reg_octrll *) GPON_OCTRLL0_BASE;
+static struct gpon_reg_sgmii * const sgmii =
+	(struct gpon_reg_sgmii *)GPON_SGMII_BASE;
+static struct gpon_reg_sxgmii * const sxgmii =
+	(struct gpon_reg_sxgmii *)GPON_SXGMII_BASE;
+
+typedef enum {
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY)
+	PORT_GPHY0,
+	PORT_GPHY1,
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_xMII)
+	PORT_XMII0,
+	PORT_XMII1,
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+	PORT_SGMII
+#endif
+} port_type;
+
+struct eth_port {
+	const char *name;
+	const char *env_name;	/* environment variable to select the phy addr */
+	port_type port;
+	uint32_t sys_eth_act;	/* which modules to activate */
+	int defspeed;		/* Standard speed of port, without phy info */
+	uint32_t miicfg;	/* mii rate and mode (only for xmii) */
+	uint32_t support_mask;	/* mask of supported chip types */
+	uint32_t port_mask;	/* mask for selecting ports from board info */
+};
+
+static const char *mdio_name = "falcon_mdio";
+static int ll_hw_is_initialized;
+
+
+static const struct eth_port falcon_eth_ports[] = {
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY0)
+	{
+		.name = "GPHY0",
+		.env_name = "gphy0_phyaddr",
+		.port = PORT_GPHY0,
+		.sys_eth_act = 0,
+		.defspeed = _1000BASET,
+		.support_mask = FALCON_D | FALCON_V | FALCON_M | FALCON_S,
+		.port_mask = FALCON_NET_PORT_MASK_GPHY0,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY1)
+	{
+		.name = "GPHY1",
+		.env_name = "gphy1_phyaddr",
+		.port = PORT_GPHY1,
+		.sys_eth_act = 0,
+		.defspeed = _1000BASET,
+		.support_mask = FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_GPHY1,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_RGMII0)
+	{
+		.name = "RGMII0",
+		.env_name = "rgmii0_phyaddr",
+		.port = PORT_XMII0,
+		.sys_eth_act = SYS_ETH_ACT_xMII,
+		.defspeed = _1000BASET,
+		.miicfg = EIM_MII_CFG_MIIRATE_AUTO | EIM_MII_CFG_MIIMODE_RGMII,
+		.support_mask = FALCON_D | FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_RGMII0,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_RGMII1)
+	{
+		.name = "RGMII1",
+		.env_name = "rgmii1_phyaddr",
+		.port = PORT_XMII1,
+		.sys_eth_act = SYS_ETH_ACT_xMII,
+		.defspeed = _1000BASET,
+		.miicfg = EIM_MII_CFG_MIIRATE_AUTO | EIM_MII_CFG_MIIMODE_RGMII,
+		.support_mask = FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_RGMII1,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GMII_PHY)
+	{
+		.name = "GMII_PHY",
+		.env_name = "gmiip_phyaddr",
+		.port = PORT_XMII0,
+		.sys_eth_act = SYS_ETH_ACT_xMII,
+		.defspeed = _1000BASET,
+		.miicfg = EIM_MII_CFG_MIIRATE_M125 | EIM_MII_CFG_MIIMODE_MIIP,
+		.support_mask = FALCON_D | FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_GMII_PHY,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GMII_MAC)
+	{
+		.name = "GMII_MAC",
+		.env_name = "gmiim_phyaddr",
+		.port = PORT_XMII0,
+		.sys_eth_act = SYS_ETH_ACT_xMII,
+		.defspeed = _1000BASET,
+		.miicfg = EIM_MII_CFG_MIIRATE_M125 | EIM_MII_CFG_MIIMODE_MIIM,
+		.support_mask = FALCON_D | FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_GMII_MAC,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_MII_PHY)
+	{
+		.name = "MII_PHY",
+		.env_name = "miip_phyaddr",
+		.port = PORT_XMII0,
+		.sys_eth_act = SYS_ETH_ACT_xMII,
+		.defspeed = _100BASET,
+		.miicfg = EIM_MII_CFG_MIIRATE_M25 | EIM_MII_CFG_MIIMODE_MIIP,
+		.support_mask = FALCON_D | FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_MII_PHY,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_MII_MAC)
+	{
+		.name = "MII_MAC",
+		.env_name = "miim_phyaddr",
+		.port = PORT_XMII0,
+		.sys_eth_act = SYS_ETH_ACT_xMII,
+		.defspeed = _100BASET,
+		.miicfg = EIM_MII_CFG_MIIRATE_M25 | EIM_MII_CFG_MIIMODE_MIIM,
+		.support_mask = FALCON_D | FALCON_V | FALCON_M,
+		.port_mask = FALCON_NET_PORT_MASK_MII_MAC,
+	},
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+	{
+		.name = "SGMII",
+		.env_name = "sgmii_phyaddr",
+		.port = PORT_SGMII,
+		.sys_eth_act = SYS_ETH_ACT_SGMII,
+		.defspeed = _1000BASET,
+		.support_mask = FALCON_M | FALCON_S,
+		.port_mask = FALCON_NET_PORT_MASK_SGMII,
+	},
+#endif
+};
+
+static int falcon_send(struct eth_device *dev, volatile void *packet,
+	int length)
+{
+	int ret;
+
+	debug("falcon_send(0x%p, 0x%p, %d)\n", dev, packet, length);
+
+	if (length <= 0) {
+		printf("falcon_send: Invalid packet length (%d)\n", length);
+		return -1;
+	}
+#ifdef DEBUG_DATA
+	print_buffer(0, (void *)packet, 1, (length > 64) ? 64 : length, 0);
+#endif
+
+	ret = falcon_pdu_write(length, (const uint8_t *) packet);
+
+	return ret;
+}
+
+#ifdef DEBUG_COUNTER
+static u32 ictrll0_macerr, ictrll0_pdc, ictrll0_rxpcnt;
+static u32 octrll0_txpcnt;
+static struct eim_top_pdi eim_top_pdi;
+#define CHECK_CNT(hwmod, name) \
+	do { \
+		reg = hwmod ## r32(name); \
+		if (hwmod ## name != reg) { \
+			printf("%8s %8d -> %8d\n", #name, hwmod ## name, reg); \
+			hwmod ## name = reg; \
+		} else if (always) { \
+			printf("%8s %8d\n", #name, reg); \
+		} \
+	} while (0)
+
+static void falcon_check_counter(int always)
+{
+	u32 reg;
+	CHECK_CNT(ictrll0_, macerr);
+	CHECK_CNT(ictrll0_, pdc);
+	CHECK_CNT(ictrll0_, rxpcnt);
+	CHECK_CNT(octrll0_, txpcnt);
+	CHECK_CNT(eim_, top_pdi.eim_mib_fcser[0]);
+}
+#else
+static inline void falcon_check_counter(int always) {}
+#endif
+
+static int falcon_recv(struct eth_device *dev)
+{
+	void *packet = (void *) NetRxPackets[0];
+	struct pdu_info info;
+
+	falcon_check_counter(0);
+
+	if (falcon_pdu_info_read(INGRESS_QUEUE, &info) < 0)
+		return -1;
+
+	if (info.len > PKTSIZE_ALIGN)
+		BUG();
+
+	if (falcon_pdu_data_read(&info, packet) < 0) {
+		puts("error in falcon_pdu_data_read()\n");
+		return -1;
+	}
+
+	debug("falcon_recv(len %d)\n", info.len);
+#ifdef DEBUG_DATA
+	if (info.len)
+		print_buffer(0, packet, 1, (info.len > 64) ? 64 : info.len, 0);
+#endif
+	if (info.len)
+		NetReceive(packet, info.len);
+
+	return info.len;
+}
+
+static void falcon_set_hwaddr(uchar *eth_mac)
+{
+	/* set MAC address */
+	ictrll0_w32(eth_mac[0]<<24 | eth_mac[1]<<16 |
+		    eth_mac[2]<<8 | eth_mac[3],
+		    rawda0);
+	ictrll0_w32(eth_mac[4]<<24 | eth_mac[5]<<16, rawda1);
+}
+
+static int falcon_ll_hwinit(void)
+{
+	if (ll_hw_is_initialized) {
+		/*sys_eth_hw_activate(SYS_ETH_ACT_GMAC0);
+		sys_gpe_hw_activate(SYS_GPE_ACT_LAN0 | SYS_GPE_ACT_FSQM
+			| SYS_GPE_ACT_IQM | SYS_GPE_ACT_ARB);*/
+		iqm_queue_enable_set(INGRESS_QUEUE, 1);
+		return 0;
+	}
+	ll_hw_is_initialized = 1;
+
+	sys_eth_hw_activate_or_reboot(SYS_ETH_ACT_GMAC0);
+	sys_gpe_hw_activate_or_reboot(SYS_GPE_ACT_LAN0 | SYS_GPE_ACT_FSQM
+		| SYS_GPE_ACT_IQM | SYS_GPE_ACT_ARB);
+
+	/* initialize HW */
+	gpearb_init();
+	fsqm_init();
+	iqm_init();
+	octrll_init();
+	ictrll_init();
+
+	/* enable raw mode with broadcasts on ICTRLL0 */
+	ictrll0_w32_mask(0, ICTRLL_CTRL_RAW_EN |
+				 ICTRLL_CTRL_BC_EN, ctrl);
+
+	octrll_port_enable_set(1);
+	ictrll_port_enable_set(1);
+
+	iqm_queue_enable_set(INGRESS_QUEUE, 1);
+
+	return 0;
+}
+
+static void falcon_halt(struct eth_device *dev)
+{
+	debug("falcon_halt(%s)\n", dev->name);
+	if (ll_hw_is_initialized)
+		iqm_queue_enable_set(INGRESS_QUEUE, 0);
+
+	if (ll_hw_is_initialized)
+		falcon_check_counter(1);
+/*
+	sys_eth_hw_clk_disable(SYS_ETH_CLKS_GMAC0);
+	sys_gpe_hw_clk_disable(SYS_GPE_CLKS_LAN0 | SYS_GPE_CLKS_FSQM
+		| SYS_GPE_CLKS_IQM | SYS_GPE_CLKS_ARB);
+*/
+}
+
+#define PHY_AUTONEGOTIATE_TIMEOUT	8000	/* 8000 ms autonegotiate timeout */
+
+static int get_phy_status(struct eth_port *priv, unsigned int phy_addr,
+		int *speed, int *duplex)
+{
+	unsigned short reg;
+	int i;
+
+	if (!speed || !duplex)
+		return -1;
+
+	miiphy_read(mdio_name, phy_addr, MII_BMSR, &reg);
+
+	/*
+	 * Wait if PHY is capable of autonegotiation and autonegotiation is not complete
+	 */
+	if ((reg & BMSR_ANEGCAPABLE) && !(reg & BMSR_ANEGCOMPLETE)) {
+		printf("%s: Waiting for PHY(%d) auto negotiation to complete ",
+			priv->name, phy_addr);
+		i = 0;
+		while (!(reg & BMSR_ANEGCOMPLETE)) {
+			/*
+			 * Timeout reached ?
+			 */
+			if (i > PHY_AUTONEGOTIATE_TIMEOUT) {
+				puts(" TIMEOUT !\n");
+				return -1;
+			}
+
+			if (ctrlc()) {
+				puts(" canceled!\n");
+				return -1;
+			}
+
+			if ((i++ % 1000) == 0)
+				putc('.');
+
+			udelay(1000);	/* 1 ms */
+			miiphy_read(mdio_name, phy_addr, MII_BMSR, &reg);
+		}
+		puts(" done\n");
+	}
+
+	if ((reg & BMSR_LSTATUS) == 0) {
+		printf("%s: No Link!\n", priv->name);
+		return -1;
+	}
+
+	*speed = miiphy_speed(mdio_name, phy_addr);
+	*duplex = miiphy_duplex(mdio_name, phy_addr);
+
+	printf("%s: Link Speed is %d Mbps - %s duplex connection\n",
+		priv->name, *speed, (*duplex == HALF) ? "HALF" : "FULL");
+
+	return 0;
+}
+
+static int update_port_speed(struct eth_device *dev)
+{
+	struct eth_port *priv = dev->priv;
+	int speed = priv->defspeed;
+	int duplex = HALF;
+	const char *s = NULL;
+	size_t len;
+	int phy_addr = -1;
+	uint32_t eim_phy_addr_speed;
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_xMII)
+#define ASSIGN_xMII_VAR(code)	code
+	int speed_idx;
+	port_type port = priv->port;
+	uint32_t drc;
+
+	static const uint32_t drc_mask[3] = {
+		SYS_ETH_DRC_xMII0_MASK,
+		SYS_ETH_DRC_xMII1_MASK,
+		SYS_ETH_DRC_SGMII_MASK,
+	};
+	static const uint32_t drc_vals[3][3] = {
+		{
+		SYS_ETH_DRC_xMII0_DR10,
+		SYS_ETH_DRC_xMII0_DR100,
+		SYS_ETH_DRC_xMII0_DR1000,
+		}, {
+		SYS_ETH_DRC_xMII1_DR10,
+		SYS_ETH_DRC_xMII1_DR100,
+		SYS_ETH_DRC_xMII1_DR1000,
+		}, {
+		SYS_ETH_DRC_SGMII_DR10,
+		SYS_ETH_DRC_SGMII_DR100,
+		SYS_ETH_DRC_SGMII_DR1000,
+		}
+	};
+#else
+#define ASSIGN_xMII_VAR(code)
+#endif
+
+	if (hwconfig(priv->name)) {
+		s = hwconfig_subarg(priv->name, "speed", &len);
+		if ((s != NULL) && (len > 0)) {
+			speed = simple_strtoul(s, NULL, 10);
+			switch (speed) {
+			case _10BASET:
+			case _100BASET:
+			case _1000BASET:
+				/* supported values */
+				break;
+			default:
+				/* fall back to defspeed */
+				speed = priv->defspeed;
+				break;
+			}
+		}
+
+		s = hwconfig_subarg(priv->name, "phyaddr", &len);
+		if ((s != NULL) && (len > 0))
+			phy_addr = simple_strtoul(s, NULL, 10);
+	}
+	/* if no phyaddr in hwconfig, try port specific environment variable */
+	if (s == NULL) {
+		s = getenv((char *)priv->env_name);
+		if (s != NULL)
+			phy_addr = simple_strtoul(s, NULL, 10);
+	}
+
+	if (phy_addr >= 0 && phy_addr < 32) {
+		if (get_phy_status(priv, phy_addr, &speed, &duplex) != 0)
+			return -1;
+	}
+
+	switch (speed) {
+	case _10BASET:
+		ASSIGN_xMII_VAR(speed_idx = 0;)
+		eim_phy_addr_speed = EIM_PHY_ADDR_SPEED_M10;
+		break;
+	case _100BASET:
+		ASSIGN_xMII_VAR(speed_idx = 1;)
+		eim_phy_addr_speed = EIM_PHY_ADDR_SPEED_M100;
+		break;
+	case _1000BASET:
+		ASSIGN_xMII_VAR(speed_idx = 2;)
+		eim_phy_addr_speed = EIM_PHY_ADDR_SPEED_G1;
+		break;
+	default:
+		ASSIGN_xMII_VAR(speed_idx = -1;)
+		eim_phy_addr_speed = EIM_PHY_ADDR_SPEED_AUTO;
+		break;
+	}
+
+	if (is_falcon_chip_a2x()) {
+		u32 reg;
+		reg = eim_a2x_r32(mdio_pdi.phy_addr[0]);
+		reg &= ~(EIM_PHY_ADDR_LNKST_MASK | EIM_PHY_ADDR_SPEED_MASK
+			| EIM_PHY_ADDR_FDUP_MASK);
+		reg |= EIM_PHY_ADDR_LNKST_UP | eim_phy_addr_speed;
+		if (duplex == FULL)
+			reg |= EIM_PHY_ADDR_FDUP_EN;
+		else
+			reg |= EIM_PHY_ADDR_FDUP_DIS;
+		eim_a2x_w32(reg, mdio_pdi.phy_addr[0]);
+	}
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_xMII)
+	if ((speed_idx != -1) && (port >= PORT_XMII0)) {
+		drc = drc_vals[port-PORT_XMII0][speed_idx];
+		sys_eth_hw_clk_disable(SYS_ETH_CLKEN_GMAC0);
+		sys_eth_w32_mask(drc_mask[port-PORT_XMII0], drc, drc);
+		sys_eth_hw_clk_enable(SYS_ETH_CLKEN_GMAC0);
+	}
+#endif
+	return 0;
+}
+
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_xMII)
+static int xmii_init(struct eth_device *dev,
+	port_type port, uint32_t miicfg)
+{
+	struct eth_port *priv = dev->priv;
+	const char *s = NULL;
+	size_t len;
+	uint32_t rxdly = 0;
+	uint32_t txdly = 0;
+	enum lan_mode_duplex duplex;
+	enum lan_mode_flow flow;
+
+	if (hwconfig_subarg_cmp(priv->name, "duplex", "full"))
+		duplex = LAN_MAC_MODE_DUPLEX_FULL;
+	else if (hwconfig_subarg_cmp(priv->name, "duplex", "half"))
+		duplex = LAN_MAC_MODE_DUPLEX_HALF;
+	else
+		duplex = LAN_MAC_MODE_DUPLEX_AUTO;
+
+	if (hwconfig_subarg_cmp(priv->name, "flow", "rxtx"))
+		flow = LAN_MAC_MODE_FLOW_RXTX;
+	else if (hwconfig_subarg_cmp(priv->name, "flow", "rx"))
+		flow = LAN_MAC_MODE_FLOW_RX;
+	else if (hwconfig_subarg_cmp(priv->name, "flow", "tx"))
+		flow = LAN_MAC_MODE_FLOW_TX;
+	else if (hwconfig_subarg_cmp(priv->name, "flow", "none"))
+		flow = LAN_MAC_MODE_FLOW_NONE;
+	else
+		flow = LAN_MAC_MODE_DUPLEX_AUTO;
+
+	s = hwconfig_subarg(priv->name, "rxdly", &len);
+	if ((s != NULL) && (len > 0))
+		rxdly = simple_strtoul(s, NULL, 10);
+
+	s = hwconfig_subarg(priv->name, "txdly", &len);
+	if ((s != NULL) && (len > 0))
+		txdly = simple_strtoul(s, NULL, 10);
+
+	s = getenv("rgmiidelay");
+	if (s != NULL)
+		rxdly = txdly = simple_strtoul(s, NULL, 10);
+
+	eim_mac_config_set(LAN_MAC_MODE_AUTO, duplex, flow);
+
+	if (port == PORT_XMII0)
+		eim_mii_config_set(0, miicfg);
+	else {
+		/* make sure port 1 can used by setting port 0 to RGMII */
+		eim_mii_config_set(0, EIM_MII_CFG_MIIRATE_M25 | EIM_MII_CFG_MIIMODE_RGMII);
+		eim_mii_config_set(1, miicfg);
+	}
+
+	/* always write rgmii delay, doesn't hurt in other modes */
+	if (port == PORT_XMII0)
+		eim_w32_mask(EIM_PCDU_RXDLY_MASK | EIM_PCDU_TXDLY_MASK,
+			((rxdly << EIM_PCDU_RXDLY_OFFSET) & EIM_PCDU_RXDLY_MASK) |
+			((txdly << EIM_PCDU_TXDLY_OFFSET) & EIM_PCDU_TXDLY_MASK),
+			mii_pdi[0].pcdu);
+	else
+		eim_w32_mask(EIM_PCDU_RXDLY_MASK | EIM_PCDU_TXDLY_MASK,
+			((rxdly << EIM_PCDU_RXDLY_OFFSET) & EIM_PCDU_RXDLY_MASK) |
+			((txdly << EIM_PCDU_TXDLY_OFFSET) & EIM_PCDU_TXDLY_MASK),
+			mii_pdi[1].pcdu);
+
+	return 0;
+}
+#endif
+
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+static int sgmii_init(void)
+{
+	static int sgmii_is_initialized = 0;
+	u32 cfg;
+	int cnt;
+	const char *s = NULL;
+	int invrx = 0;
+	int invtx = 0;
+
+	/* default MAC setup */
+	eim_mac_config_set(LAN_MAC_MODE_GMII, LAN_MAC_MODE_DUPLEX_FULL,
+		LAN_MAC_MODE_FLOW_AUTO);
+
+	if (sgmii_is_initialized)
+		goto skip_init;
+
+	sgmii_is_initialized = 1;
+
+	if (hwconfig_sub("SGMII", "invrx"))
+		invrx = 1;
+
+	if (hwconfig_sub("SGMII", "invtx"))
+		invtx = 1;
+
+	s = getenv("sgmii_inv");
+	if (s != NULL)
+		invtx = (simple_strtoul(s, NULL, 10) != 0);
+
+	sgmii_w32_mask(PLL_REGFILE_A_CTRL4_MMD_MASK, 0x2E<<PLL_REGFILE_A_CTRL4_MMD_OFFSET,
+		pll_regfile_a_ctrl4);
+	sgmii_w32_mask(0, PLL_REGFILE_A_CTRL2_LF_MODE,
+		pll_regfile_a_ctrl2);
+	sgmii_w32_mask(PLL_REGFILE_A_CTRL1_CP_SEL_MASK, 0,
+		pll_regfile_a_ctrl1);
+
+	/* restart SGMII PHY */
+	cfg = PMA_REGFILE_STARTUP_CTRL_SKIP_CAL | PMA_REGFILE_STARTUP_CTRL_PD | PMA_REGFILE_STARTUP_CTRL_PLL_PD | PMA_REGFILE_STARTUP_CTRL_BYPASS;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg &= ~PMA_REGFILE_STARTUP_CTRL_PLL_PD;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg |= PMA_REGFILE_STARTUP_CTRL_PLL_RSTN;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg &= ~PMA_REGFILE_STARTUP_CTRL_PD;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg |= PMA_REGFILE_STARTUP_CTRL_CLK_EN;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg |= PMA_REGFILE_STARTUP_CTRL_RSTN_PMD;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg |= PMA_REGFILE_STARTUP_CTRL_RSTN_DIG;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+	cfg |= PMA_REGFILE_STARTUP_CTRL_STARTUP_RDY;
+	sgmii_w32(cfg, pma_regfile_startup_ctrl);
+
+	sgmii_w32_mask(RX_REGFILE_CTRL1_PI_CTRL_MASK | RX_REGFILE_CTRL1_LOAD | RX_REGFILE_CTRL1_FLIP | RX_REGFILE_CTRL1_HALFRATE,
+			(15<<RX_REGFILE_CTRL1_PI_CTRL_OFFSET) | RX_REGFILE_CTRL1_LOAD | RX_REGFILE_CTRL1_HALFRATE,
+		rx_regfile_ctrl1);
+	udelay(1); /* wait a micro second */
+	sgmii_w32_mask(RX_REGFILE_CTRL1_LOAD, 0,
+		rx_regfile_ctrl1);
+	if (invrx)
+		sgmii_w32_mask(0, RX_REGFILE_CTRL1_INV_EN, rx_regfile_ctrl1);
+	sgmii_w32_mask(RX_REGFILE_CDR_COMP_MASK | RX_REGFILE_CDR_SUM_INT | RX_REGFILE_CDR_DUMPINT_MASK,
+		(4<<RX_REGFILE_CDR_COMP_OFFSET) | RX_REGFILE_CDR_XOR_INV,
+		rx_regfile_cdr);
+	sgmii_w32_mask(RX_REGFILE_EI_ENDCNT_MASK, (4<<RX_REGFILE_EI_ENDCNT_OFFSET),
+		rx_regfile_ei);
+
+	sgmii_w32_mask(TX_REGFILE_0_CTRL1_INV_EN | TX_REGFILE_0_CTRL1_FORCE | TX_REGFILE_0_CTRL1_FLIP | TX_REGFILE_0_CTRL1_HALFRATE, TX_REGFILE_0_CTRL1_HALFRATE,
+		tx_regfile_0_ctrl1);
+	if (invtx)
+		sgmii_w32_mask(0, TX_REGFILE_0_CTRL1_INV_EN, tx_regfile_0_ctrl1);
+
+	sgmii_w32_mask(TX_REGFILE_1_CTRL1_INV_EN | TX_REGFILE_1_CTRL1_FLIP | TX_REGFILE_1_CTRL1_HALFRATE, TX_REGFILE_1_CTRL1_HALFRATE,
+		tx_regfile_1_ctrl1);
+	if (invtx)
+		sgmii_w32_mask(0, TX_REGFILE_1_CTRL1_INV_EN, tx_regfile_1_ctrl1);
+	sgmii_w32_mask(TX_REGFILE_0_A_CTRL2_PREDRV_SER_EN_MASK, 4<<TX_REGFILE_0_A_CTRL2_PREDRV_SER_EN_OFFSET,
+		tx_regfile_0_a_ctrl2);
+	sgmii_w32_mask(TX_REGFILE_0_CTRL3_CNTR_LIM_MASK, 0x1FFF<<TX_REGFILE_0_CTRL3_CNTR_LIM_OFFSET,
+		tx_regfile_0_ctrl3);
+	sgmii_w32_mask(TX_REGFILE_0_A_CTRL1_CTRL_MASK, 8<<TX_REGFILE_0_A_CTRL1_CTRL_OFFSET,
+		tx_regfile_0_a_ctrl1);
+	sgmii_w32_mask(TX_REGFILE_0_A_CTRL2_PREDRV_SER_EN_MASK, 0x44<<TX_REGFILE_0_A_CTRL2_PREDRV_SER_EN_OFFSET,
+		tx_regfile_0_a_ctrl2);
+
+	sxgmii_w32_mask(RXBCFG_DLY_WP_MASK, 2<<RXBCFG_DLY_WP_OFFSET,
+		s_sgmii_pcs_pdi_rxbcfg);
+	sxgmii_w32_mask(TXBCFG_DLY_WP_MASK, 2<<TXBCFG_DLY_WP_OFFSET,
+		s_sgmii_pcs_pdi_txbcfg);
+	sxgmii_w32_mask(TBICTL_INITTBI, TBICTL_ENTBI,
+		tbi_pdi_tbictl);
+
+skip_init:
+	cnt = 200;
+	while ((sxgmii_r32(tbi_pdi_tbistat) & TBISTAT_SSTAT) == 0) {
+		if (--cnt == 0) {
+			printf("Error: SGMII TBI not in sync!\n");
+			return 1;
+		}
+		udelay(10);
+	}
+
+	return 0;
+}
+
+static int sgmii_aneg(struct eth_device *dev)
+{
+	int cnt;
+	u32 reg;
+
+	/* if ANEG not enabled? */
+	if ((sxgmii_r32(tbi_pdi_anegctl) & ANEGCTL_ANEGEN) != ANEGCTL_ANEGEN_ENABLE) {
+		puts("SGMII: enable ANEG\n");
+		sys_eth_w32_mask(SYS_ETH_SGMIIC_ANP, SYS_ETH_SGMIIC_ANP_SGMIIM,
+			sgmiic);
+		/* setup ANEG data */
+		sxgmii_w32(0, tbi_pdi_txanegh);
+		sxgmii_w32(1, tbi_pdi_txanegl);
+		/* enable aneg */
+		sxgmii_w32_mask(ANEGCTL_OVRABL_OVERRIDE | ANEGCTL_RANEG_RESTART | ANEGCTL_LT_MASK,
+			ANEGCTL_OVRANEG_OVERRIDE | ANEGCTL_ANEGEN_ENABLE | ANEGCTL_LT_T_1_6MS,
+			tbi_pdi_anegctl);
+	}
+
+	cnt = 100;
+	while ((sxgmii_r32(tbi_pdi_tbistat) & TBISTAT_LSTAT) == 0) {
+		if (--cnt == 0) {
+			puts("SGMII ANEG: No LSTAT\n");
+			return -1;
+		}
+		udelay(1000); /* 1 ms */
+	}
+	if (sxgmii_r32(tbi_pdi_tbistat) & TBISTAT_ANEGERR)
+		puts("Warning: SGMII ANEG Error!\n");
+
+	/* ack the interrupts */
+	sxgmii_w32(sxgmii_r32(tbi_pdi_istat), tbi_pdi_istat);
+
+	reg = sxgmii_r32(tbi_pdi_lpstat);
+	while ((reg & LPSTAT_DR_MASK) == LPSTAT_DR_INVALID) {
+		cnt = 500;
+		while ((sxgmii_r32(tbi_pdi_istat) & ISTAT_ANEG_BP) == 0) {
+			if (--cnt == 0) {
+				puts("SGMII: no PHY Link!\n");
+				return -1;
+			}
+			udelay(100);
+		}
+		reg = sxgmii_r32(tbi_pdi_lpstat);
+	}
+
+	if ((reg & LPSTAT_DR_MASK) == LPSTAT_DR_INVALID) {
+		/* still invalid */
+		puts("SGMII: Invalid Datarate!\n");
+		return -1;
+	}
+
+	sys_eth_hw_clk_disable(SYS_ETH_CLKEN_GMAC0);
+	switch (reg & LPSTAT_DR_MASK) {
+	case LPSTAT_DR_DR10:
+		sys_eth_w32_mask(SYS_ETH_DRC_SGMII_MASK,
+			SYS_ETH_DRC_SGMII_DR10, drc);
+		break;
+	case LPSTAT_DR_DR100:
+		sys_eth_w32_mask(SYS_ETH_DRC_SGMII_MASK,
+			SYS_ETH_DRC_SGMII_DR100, drc);
+		break;
+	case LPSTAT_DR_DR1000:
+		sys_eth_w32_mask(SYS_ETH_DRC_SGMII_MASK,
+			SYS_ETH_DRC_SGMII_DR1000, drc);
+		break;
+	}
+	sys_eth_hw_clk_enable(SYS_ETH_CLKEN_GMAC0);
+	if ((reg & LPSTAT_DPX) == LPSTAT_DPX_FD)
+		eim_mac_config_set(LAN_MAC_MODE_GMII, LAN_MAC_MODE_DUPLEX_FULL,
+			LAN_MAC_MODE_FLOW_AUTO);
+	else
+		eim_mac_config_set(LAN_MAC_MODE_GMII, LAN_MAC_MODE_DUPLEX_HALF,
+			LAN_MAC_MODE_FLOW_AUTO);
+
+	return 0;
+}
+#endif
+
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY)
+/**
+ * Boot a GPHY instance
+ * \param phyno[in]     select GPHY instance
+ * \param addr1[in]     MDIO address 1
+ * \param addr2[in]     MDIO address 2
+ * \return 0            Boot successful
+ *         -1           Error
+ */
+static int gphy_boot(u32 phyno, u32 addr1, u32 addr2)
+{
+	/* address of gphy firmware in ROM */
+	static const u32 *gphy11g_image_A11 = (u32 *)0xbf020000;
+	static const u32 *gphy11g_image_A12 = (u32 *)0xbf018000;
+	u32 gphy11g_image;
+	u32 ier, isr;
+
+	if (phyno > 1)
+		return -1;
+
+	/* detect correct address of gphy firmware */
+	if (*gphy11g_image_A12 == 0xAAAAAAAA)
+		gphy11g_image = (u32)gphy11g_image_A11;
+	else
+		gphy11g_image = (u32)gphy11g_image_A12;
+
+	if (phyno == 0)
+		sbs0ctrl_w32(gphy11g_image & SBS0CTRL_GPHY0IMG_ADDRV_MASK,
+			gphy0img);
+	else
+		sbs0ctrl_w32(gphy11g_image & SBS0CTRL_GPHY1IMG_ADDRV_MASK,
+			gphy1img);
+
+	if (phyno == 0) {
+		if (is_falcon_chip_a1x()) {
+			ier = EIM_EIM_IER_A1X_GPHY0_IEN_EN;
+			isr = EIM_EIM_ISR_A1X_GPHY0_IRQ;
+		} else {
+			ier = EIM_EIM_IER_A2X_GPHY0_IEN_EN;
+			isr = EIM_EIM_ISR_A2X_GPHY0_IRQ;
+		}
+	} else {
+		if (is_falcon_chip_a1x()) {
+			ier = EIM_EIM_IER_A1X_GPHY1_IEN_EN;
+			isr = EIM_EIM_ISR_A1X_GPHY1_IRQ;
+		} else {
+			ier = EIM_EIM_IER_A2X_GPHY1_IEN_EN;
+			isr = EIM_EIM_ISR_A2X_GPHY1_IRQ;
+		}
+	}
+	sys_eth_hw_activate_or_reboot((phyno == 0) ? SYS_ETH_ACT_GPHY0 :
+						     SYS_ETH_ACT_GPHY1);
+
+	eim_w32(((addr1 << EIM_GPHY_CFG_ADDR_PHYADR1_OFFSET) &
+					EIM_GPHY_CFG_ADDR_PHYADR1_MASK)
+		| ((addr2 << EIM_GPHY_CFG_ADDR_PHYADR2_OFFSET) &
+					EIM_GPHY_CFG_ADDR_PHYADR2_MASK),
+		top_pdi.gphy_cfg_addr[phyno]);
+
+	/* enable the interrupt for gphy */
+	eim_w32_mask(0, ier, top_pdi.eim_ier);
+	/* do hard reset on gphy (srst does not work reliable) */
+	sys_eth_w32((phyno == 0) ? SYS_ETH_RBT_GPHY0_TRIG :
+				   SYS_ETH_RBT_GPHY1_TRIG, rbt);
+
+	/* wait for interrupt */
+	while ((eim_r32(top_pdi.eim_isr) & isr) == 0) {
+		};
+	/* disable interrupt */
+	eim_w32_mask(ier, 0, top_pdi.eim_ier);
+	/* acknowledge interrupt */
+	eim_w32_mask(isr, 0, top_pdi.eim_isr);
+
+	return 0;
+}
+#endif
+
+static int falcon_init(struct eth_device *dev, bd_t *bis)
+{
+	struct eth_port *priv = dev->priv;
+	static const uint32_t gmuxc[] = {
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY)
+	[PORT_GPHY0] =
+		SYS_ETH_GMUXC_GMAC0_GPHY0_GMII |
+		SYS_ETH_GMUXC_GMAC1_GPHY0_MII2 |
+		SYS_ETH_GMUXC_GMAC2_GPHY1_GMII |
+		SYS_ETH_GMUXC_GMAC3_GPHY1_MII2,
+	[PORT_GPHY1] =
+		SYS_ETH_GMUXC_GMAC0_GPHY1_GMII |
+		SYS_ETH_GMUXC_GMAC1_GPHY0_MII2 |
+		SYS_ETH_GMUXC_GMAC2_GPHY0_GMII |
+		SYS_ETH_GMUXC_GMAC3_GPHY1_MII2,
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_xMII)
+	[PORT_XMII0] =
+		SYS_ETH_GMUXC_GMAC0_xMII0 |
+		SYS_ETH_GMUXC_GMAC1_GPHY0_MII2 |
+		SYS_ETH_GMUXC_GMAC2_GPHY1_GMII |
+		SYS_ETH_GMUXC_GMAC3_GPHY1_MII2,
+	[PORT_XMII1] =
+		SYS_ETH_GMUXC_GMAC0_xMII1 |
+		SYS_ETH_GMUXC_GMAC1_GPHY0_MII2 |
+		SYS_ETH_GMUXC_GMAC2_GPHY1_GMII |
+		SYS_ETH_GMUXC_GMAC3_GPHY1_MII2,
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+	[PORT_SGMII] =
+		SYS_ETH_GMUXC_GMAC0_SGMII |
+		SYS_ETH_GMUXC_GMAC1_GPHY0_MII2 |
+		SYS_ETH_GMUXC_GMAC2_GPHY1_GMII |
+		SYS_ETH_GMUXC_GMAC3_GPHY1_MII2,
+#endif
+	};
+
+	falcon_ll_hwinit();
+	falcon_set_hwaddr(dev->enetaddr);
+	sys_eth_hw_activate(priv->sys_eth_act);
+
+	/* setup port */
+	switch (priv->port) {
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY)
+	case PORT_GPHY0:
+	case PORT_GPHY1:
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_xMII)
+	case PORT_XMII0:
+	case PORT_XMII1:
+		xmii_init(dev, priv->port, priv->miicfg);
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+	case PORT_SGMII:
+		sgmii_init();
+		break;
+#endif
+	}
+
+	/* connect gmac to port */
+	sys_eth_w32(gmuxc[priv->port], gmuxc);
+
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+	if (priv->port == PORT_SGMII)
+		return sgmii_aneg(dev);
+	else
+#endif
+		return update_port_speed(dev);
+}
+
+static int falcon_miiphy_read(const char *devname, unsigned char addr,
+	unsigned char reg, unsigned short *value)
+{
+	return eim_mdio_data_read(addr, reg, value);
+}
+
+static int falcon_miiphy_write(const char *devname, unsigned char addr,
+	unsigned char reg, unsigned short value)
+{
+	return eim_mdio_data_write(addr, reg, value);
+}
+
+static void falcon_autoset_ethprime(void)
+{
+	char *ethprime;
+
+	/* setup default interface for network boot, depending on bootmode */
+	switch (sys1_r32(bmc) & BMC_BM_MASK) {
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_RGMII0)
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+		ethprime = "RGMII0";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_RGMII1)
+	case 13:
+	case 14:
+	case 15:
+	case 16:
+		ethprime = "RGMII1";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GMII_PHY)
+	case 17:
+		ethprime = "GMII_PHY";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GMII_MAC)
+	case 18:
+		ethprime = "GMII_MAC";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_MII_PHY)
+	case 19:
+		ethprime = "MII_PHY";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_MII_MAC)
+	case 20:
+		ethprime = "MII_MAC";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY0)
+	case 21:
+		ethprime = "GPHY0";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY1)
+	case 22:
+		ethprime = "GPHY1";
+		break;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_SGMII)
+	case 23:
+	case 24:
+	case 25:
+		ethprime = "SGMII";
+		break;
+#endif
+	default:
+		ethprime = NULL;
+		break;
+	}
+	if (ethprime)
+		setenv("ethprime", ethprime);
+}
+
+int falcon_net_register(unsigned int falcon_net_mask)
+{
+	struct eth_device *dev;
+	int i, cnt = 0;
+	const char *s;
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY)
+	size_t len;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY0)
+	unsigned long gphy0_phyaddr = 0;
+#endif
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY1)
+	unsigned long gphy1_phyaddr = 1;
+#endif
+
+	debug("Support mask: compiled 0x%X, detected 0x%X\n",
+		CONFIG_FALCON_NET_PORT_MASK, falcon_net_mask);
+
+	for (i = 0; i < ARRAY_SIZE(falcon_eth_ports); i++) {
+		/*
+		   if interface is selected from hwconfig, register it,
+		   otherwise only register interfaces valid for falcon-type
+		   (allows testing of interfaces on non-qualified chips also)
+		*/
+		debug("Check for %s: ", falcon_eth_ports[i].name);
+		if (!hwconfig(falcon_eth_ports[i].name))
+			if (((falcon_eth_ports[i].port_mask & falcon_net_mask) == 0) ||
+			    (!support_falcon_type(falcon_eth_ports[i].support_mask))) {
+				debug("skip!\n");
+				continue;
+			}
+		debug("register\n");
+		dev = (struct eth_device *) malloc(sizeof(*dev));
+		if (!dev) {
+			puts("Memory allocation error\n");
+			break;
+		}
+
+		memset(dev, 0, sizeof(*dev));
+
+		sprintf(dev->name, "%s", falcon_eth_ports[i].name);
+		dev->init = falcon_init;
+		dev->halt = falcon_halt;
+		dev->send = falcon_send;
+		dev->recv = falcon_recv;
+		dev->priv = (void *)&falcon_eth_ports[i];
+
+		eth_register(dev);
+		cnt++;
+	}
+
+	if (!getenv("ethprime"))
+		falcon_autoset_ethprime();
+
+	eim_init();
+	miiphy_register(mdio_name, falcon_miiphy_read, falcon_miiphy_write);
+
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY0)
+	s = hwconfig_subarg("GPHY0", "phyaddr", &len);
+	if ((s != NULL) && (len > 0))
+		gphy0_phyaddr = simple_strtoul(s, NULL, 10);
+	else {
+		s = getenv("gphy0_phyaddr");
+		if (s != NULL)
+			gphy0_phyaddr = simple_strtoul(s, NULL, 10);
+	}
+	gphy_boot(0, gphy0_phyaddr, 2);
+#endif
+
+#if (CONFIG_FALCON_NET_PORT_MASK & FALCON_NET_PORT_MASK_GPHY1)
+	if (support_falcon_type(FALCON_V | FALCON_M) || hwconfig("GPHY1")) {
+		s = hwconfig_subarg("GPHY1", "phyaddr", &len);
+		if ((s != NULL) && (len > 0))
+			gphy1_phyaddr = simple_strtoul(s, NULL, 10);
+		else {
+			s = getenv("gphy1_phyaddr");
+			if (s != NULL)
+				gphy1_phyaddr = simple_strtoul(s, NULL, 10);
+		}
+		gphy_boot(1, gphy1_phyaddr, 3);
+	}
+#endif
+
+	s = getenv("extphy");
+	if (s != NULL)
+		falcon_extphy_enable(simple_strtoul(s, NULL, 0));
+
+	return cnt;
+}
diff --git a/drivers/net/falcon/falcon_ll.c b/drivers/net/falcon/falcon_ll.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/falcon_ll.c
@@ -0,0 +1,978 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#include "falcon_std_defs.h"
+#include "falcon_resource.h"
+#include "falcon_register.h"
+#include "falcon_ll.h"
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/sysctrl.h>
+
+/* EIM declarations*/
+static struct gpon_reg_eim_a1x * const eim_a1x =
+	(struct gpon_reg_eim_a1x *) GPON_EIM_BASE;
+static struct gpon_reg_eim_a2x * const eim_a2x =
+	(struct gpon_reg_eim_a2x *) GPON_EIM_BASE;
+
+/* IQM declarations*/
+static struct gpon_reg_iqm * const iqm = (struct gpon_reg_iqm *) GPON_IQM_BASE;
+#define IQM_SSB_SIZE		0x1200
+#define IQM_MAX_QUEUE		9
+/** Number of Ingress Packet Pointers */
+#define IQM_NUM_IPP		3072
+/** Ingress queue of CPU for data in downstream direction (to the LAN ports) */
+#define IQM_QUEUE_CPU_DS	4
+/** Ingress queue of CPU for data in uptream direction (to the OLT) */
+#define IQM_QUEUE_CPU_US	8
+/** Ingress queue of ANI port, non-OMCI data, unicast */
+#define IQM_QUEUE_GEM_UC	5
+
+
+/* GPEARB declarations*/
+static struct gpon_reg_gpearb * const gpearb = (struct gpon_reg_gpearb *) GPON_GPEARB_BASE;
+#define GPEARB_PID0_ID1		8       /* (rw) Port ID 1 */
+#define GPEARB_PID0_ID1_INIT	0x0
+#define GPEARB_PID0_ID1_MSK	((1<<6)-1)
+
+/* FSQM declarations*/
+static struct gpon_reg_fsqm * const fsqm = (struct gpon_reg_fsqm *) GPON_FSQM_BASE;
+/** Buffer segment size, in number of bytes */
+#define FSQM_BUFFER_SEGMENT_SIZE 64
+#define FSQM_RCNT_INIT		0x1
+/** Maximum Logical Link Table (LLT) value */
+#define FSQM_LLT_MAX		0x4800
+/** Logical Link Table NIL pointer */
+#define FSQM_LLT_NIL		0x7FFF
+struct fsq {
+	uint16_t head;
+	uint16_t tail;
+};
+
+/* SSB declarations*/
+static struct gpon_reg_sbs0ctrl * const sbs0ctrl = (struct gpon_reg_sbs0ctrl *)GPON_SBS0CTRL_BASE;
+#define ONU_RAM_PACKET_BUFFER_OFFSET (sbs0ctrl_r32(bar1) & SBS0CTRL_BAR1_BA1V_MASK)
+
+/* ICTRLL declarations*/
+static struct gpon_reg_ictrll * const ictrll0 = (struct gpon_reg_ictrll * ) GPON_ICTRLL0_BASE;
+
+/* OCTRLL declarations*/
+static struct gpon_reg_octrll * const octrll0 = (struct gpon_reg_octrll *) GPON_OCTRLL0_BASE;
+
+void eim_init(void)
+{
+	uint8_t i;
+	sys_eth_hw_activate(SYS_ETH_ACT_MDIO);
+	eim_mac_config_set(LAN_MAC_MODE_AUTO, LAN_MAC_MODE_DUPLEX_AUTO,
+		LAN_MAC_MODE_FLOW_AUTO);
+	for (i=0; i<2; i++) {
+		eim_mii_config_set(i,
+			EIM_MII_CFG_MIIRATE_M25 | EIM_MII_CFG_MIIMODE_RGMII);
+	}
+	/* correct settings for gphy */
+	eim_w32(0x27, top_pdi.gphy_cfg_pll);
+}
+
+void eim_mac_config_set(const enum lan_mode mode, 
+			const enum lan_mode_duplex mode_duplex,
+			const enum lan_mode_flow mode_flow)
+{
+	uint32_t cfg = EIM_MAC_CTRL_0_FCS_EN | EIM_MAC_CTRL_0_PADEN_EN;
+
+	switch (mode) {
+	case LAN_MAC_MODE_AUTO:
+	default:
+		break;
+	case LAN_MAC_MODE_MII:
+		cfg |= EIM_MAC_CTRL_0_GMII_MII;
+		break;
+	case LAN_MAC_MODE_GMII:
+		cfg |= EIM_MAC_CTRL_0_GMII_GMII;
+		break;
+	}
+
+	switch (mode_duplex) {
+	case LAN_MAC_MODE_DUPLEX_AUTO:
+	default:
+		break;
+
+	case LAN_MAC_MODE_DUPLEX_FULL:
+		cfg |= EIM_MAC_CTRL_0_FDUP_EN;
+		break;
+
+	case LAN_MAC_MODE_DUPLEX_HALF:
+		cfg |= EIM_MAC_CTRL_0_FDUP_DIS;
+		break;
+	}
+
+	switch (mode_flow) {
+	case LAN_MAC_MODE_FLOW_AUTO:
+	default:
+		cfg |= EIM_MAC_CTRL_0_FCON_AUTO;
+		break;
+	case LAN_MAC_MODE_FLOW_RX:
+		cfg |= EIM_MAC_CTRL_0_FCON_RX;
+		break;
+	case LAN_MAC_MODE_FLOW_TX:
+		cfg |= EIM_MAC_CTRL_0_FCON_TX;
+		break;
+	case LAN_MAC_MODE_FLOW_RXTX:
+		cfg |= EIM_MAC_CTRL_0_FCON_RXTX;
+		break;
+	case LAN_MAC_MODE_FLOW_NONE:
+		cfg |= EIM_MAC_CTRL_0_FCON_NONE;
+		break;
+	}
+
+	eim_w32(cfg, mac_pdi[0].ctrl_0);
+	eim_w32(0, mac_pdi[0].testen);
+}
+
+void eim_mii_config_set(const uint8_t xmii_port_id, uint32_t miicfg)
+{
+	uint32_t cfg = miicfg | EIM_MII_CFG_EN;
+
+	if (xmii_port_id<2) {
+		eim_w32(cfg, mii_pdi[xmii_port_id].mii_cfg);
+		/* configure and enable jitter buffers */
+		cfg = EIM_BUFF_RXB_EN | EIM_BUFF_TXB_EN |
+			EIM_BUFF_RXB_INIT | EIM_BUFF_TXB_INIT |
+			3 << EIM_BUFF_TXB_DLY_OFFSET |
+			3 << EIM_BUFF_RXB_DLY_OFFSET;
+		eim_w32(cfg, mii_pdi[xmii_port_id].buff);
+		eim_w32_mask(EIM_BUFF_RXB_INIT | EIM_BUFF_TXB_INIT, 0,
+			mii_pdi[xmii_port_id].buff);
+	}
+}
+
+
+/** The eim_mdio_data_read function provides read access to an external or
+   internal Ethernet PHY.
+*/
+int eim_mdio_data_read(const uint8_t addr_dev, const uint8_t addr_reg,
+		       uint16_t *data)
+{
+	uint32_t cnt;
+	if (is_falcon_chip_a1x()) {
+		uint32_t cfg = EIM_MAC_HEADER_RW_READ | EIM_MAC_HEADER_START_TX;
+
+		set_val(cfg, 1, EIM_MAC_HEADER_ST_MASK, EIM_MAC_HEADER_ST_OFFSET);
+		set_val(cfg, 2, EIM_MAC_HEADER_OP_MASK, EIM_MAC_HEADER_OP_OFFSET);
+		set_val(cfg, addr_dev, EIM_MAC_HEADER_PHYAD_MASK,
+			EIM_MAC_HEADER_PHYAD_OFFSET);
+		set_val(cfg, addr_reg, EIM_MAC_HEADER_REGAD_MASK,
+			EIM_MAC_HEADER_REGAD_OFFSET);
+
+		cnt = 100;
+		eim_a1x_w32(EIM_ISTAT_INT_MAC, mdio_mac_pdi.istat);
+		while (cnt && ((eim_a1x_r32(mdio_mac_pdi.istat) & EIM_ISTAT_INT_MAC) ==
+								  EIM_ISTAT_INT_MAC) ) {
+			cnt--;
+			udelay(10);
+		}
+
+		if (cnt == 0)
+			return -1;
+
+		cnt = 100;
+		eim_a1x_w32(cfg, mdio_mac_pdi.mac_header);
+		while (cnt && ((eim_a1x_r32(mdio_mac_pdi.istat) & EIM_ISTAT_INT_MAC)
+									       == 0) ) {
+			cnt--;
+			udelay(10);
+		}
+		if (cnt == 0)
+			return -2;
+
+		/* *data = (eim_a1x_r32(mdio_mac_pdi.mac_data) & EIM_MAC_DATA_DATA_MASK);*/
+		*data = (eim_a1x_r32(mdio_mac_pdi.startup) & EIM_STARTUP_DATA_MASK);
+		eim_a1x_w32(EIM_ISTAT_INT_MAC, mdio_mac_pdi.istat);
+
+	} else if (is_falcon_chip_a2x()) {
+		cnt = 100;
+		while (cnt && eim_a2x_r32(mdio_pdi.mdio_ctrl) & EIM_MDIO_CTRL_MBUSY) {
+			cnt--;
+			udelay(10);
+		}
+		if (cnt == 0)
+			return -1;
+		eim_a2x_w32(EIM_MDIO_CTRL_OP_RD | EIM_MDIO_CTRL_MBUSY_BUSY |
+			((addr_dev << EIM_MDIO_CTRL_PHYAD_OFFSET) & EIM_MDIO_CTRL_PHYAD_MASK) |
+			((addr_reg << EIM_MDIO_CTRL_REGAD_OFFSET) & EIM_MDIO_CTRL_REGAD_MASK),
+			mdio_pdi.mdio_ctrl);
+		cnt = 100;
+		while (cnt && eim_a2x_r32(mdio_pdi.mdio_ctrl) & EIM_MDIO_CTRL_MBUSY) {
+			cnt--;
+    			udelay(10);
+		}
+		if (cnt == 0)
+			return -1;
+
+		*data = eim_a2x_r32(mdio_pdi.mdio_read) & EIM_MDIO_READ_RDATA_MASK;
+	} else
+		return -1;
+
+	return 0;
+}
+
+/**
+   Write MDIO register.
+ */
+int eim_mdio_data_write(const uint8_t addr_dev, const uint8_t addr_reg,
+			const uint16_t data)
+{
+	uint32_t cnt;
+	if (is_falcon_chip_a1x()) {
+		uint32_t cfg = EIM_MAC_HEADER_START_TX;
+
+		set_val(cfg, 1, EIM_MAC_HEADER_ST_MASK, EIM_MAC_HEADER_ST_OFFSET);
+		set_val(cfg, 1, EIM_MAC_HEADER_OP_MASK, EIM_MAC_HEADER_OP_OFFSET);
+		set_val(cfg, addr_dev, EIM_MAC_HEADER_PHYAD_MASK,
+			EIM_MAC_HEADER_PHYAD_OFFSET);
+		set_val(cfg, addr_reg, EIM_MAC_HEADER_REGAD_MASK,
+			EIM_MAC_HEADER_REGAD_OFFSET);
+
+		eim_a1x_w32(data, mdio_mac_pdi.mac_data);
+		/*eim_a1x_w32(data, mdio_mac_pdi.startup);*/
+
+		cnt = 100;
+		eim_a1x_w32(EIM_ISTAT_INT_MAC, mdio_mac_pdi.istat);
+		while (cnt && ((eim_a1x_r32(mdio_mac_pdi.istat) & EIM_ISTAT_INT_MAC) ==
+								  EIM_ISTAT_INT_MAC) ) {
+			cnt--;
+			udelay(10);
+		}
+
+		if (cnt == 0)
+			return -1;
+
+		eim_a1x_w32(cfg, mdio_mac_pdi.mac_header);
+		while (cnt && ((eim_a1x_r32(mdio_mac_pdi.istat) & EIM_ISTAT_INT_MAC)
+									       == 0) ) {
+			cnt--;
+			udelay(10);
+		}
+
+		if (cnt == 0)
+			return -2;
+	} else if (is_falcon_chip_a2x()) {
+		cnt = 100;
+		while (cnt && eim_a2x_r32(mdio_pdi.mdio_ctrl) & EIM_MDIO_CTRL_MBUSY) {
+			cnt--;
+			udelay(10);
+		}
+		if (cnt == 0)
+			return -1;
+		eim_a2x_w32(data & EIM_MDIO_WRITE_WDATA_MASK, mdio_pdi.mdio_write);
+		eim_a2x_w32(EIM_MDIO_CTRL_OP_WR | EIM_MDIO_CTRL_MBUSY_BUSY |
+			((addr_dev << EIM_MDIO_CTRL_PHYAD_OFFSET) & EIM_MDIO_CTRL_PHYAD_MASK) |
+			((addr_reg << EIM_MDIO_CTRL_REGAD_OFFSET) & EIM_MDIO_CTRL_REGAD_MASK),
+			mdio_pdi.mdio_ctrl);
+		cnt = 100;
+		while (cnt && eim_a2x_r32(mdio_pdi.mdio_ctrl) & EIM_MDIO_CTRL_MBUSY) {
+			cnt--;
+    			udelay(10);
+		}
+		if (cnt == 0)
+			return -1;
+	} else
+		return -1;
+
+	return 0;
+}
+
+static void iqm_iqt_write(const uint16_t queue_idx,
+			  const struct iqt_entry *entry)
+{
+	uint32_t iqtr;
+
+	iqtr = 0;
+	if (entry->qe)
+		iqtr |= IQM_IQT00_QE;
+
+	set_val(iqtr, entry->qrth, IQM_IQT00_QRTH_MASK, IQM_IQT00_QRTH_OFFSET);
+	set_val(iqtr, entry->qdth, IQM_IQT00_QDTH_MASK, IQM_IQT00_QDTH_OFFSET);
+	iqm_w32(iqtr, iqt[queue_idx].iqt0);
+
+	iqtr = 0;
+	if (entry->qb)
+		iqtr |= IQM_IQT01_QB;
+
+	set_val(iqtr, entry->qbth, IQM_IQT01_QBTH_MASK, IQM_IQT01_QBTH_OFFSET);
+	set_val(iqtr, entry->qbtl, IQM_IQT01_QBTL_MASK, IQM_IQT01_QBTL_OFFSET);
+	iqm_w32(iqtr, iqt[queue_idx].iqt1);
+
+	iqtr = 0;
+	if (entry->qf)
+		iqtr |= IQM_IQT02_QF;
+
+	if (entry->bp)
+		iqtr |= IQM_IQT02_BP;
+
+	set_val(iqtr, entry->pocc, IQM_IQT02_POCC_MASK, IQM_IQT02_POCC_OFFSET);
+	set_val(iqtr, entry->qocc, IQM_IQT02_QOCC_MASK, IQM_IQT02_QOCC_OFFSET);
+	iqm_w32(iqtr, iqt[queue_idx].iqt2);
+
+	iqtr = 0;
+	set_val(iqtr, entry->qdc, IQM_IQT03_QDC_MASK, IQM_IQT03_QDC_OFFSET);
+	iqm_w32(iqtr, iqt[queue_idx].iqt3);
+
+	iqm_w32(entry->tmask, iqt[queue_idx].iqt5);
+}
+
+void iqm_queue_enable_set(const uint16_t queue_idx, const bool queue_en)
+{
+	if (queue_idx < IQM_MAX_QUEUE) {
+		if (queue_en)
+			iqm_w32_mask(0, IQM_IQT00_QE, iqt[queue_idx].iqt0);
+		else
+			iqm_w32_mask(IQM_IQT00_QE, 0, iqt[queue_idx].iqt0);
+	}
+}
+
+/*
+    - Disable and clear all ingress queues
+     IQM.IQT<n>0.QE = EN, <n> = 0 ... number of ingress queues - 1
+     IQM.IQT<n>1.QB = EN,  <n> = 0 ... number of ingress queues - 1
+
+      \todo define how the ingress queues can be cleared, HW documentation is
+	    yet missing
+*/
+void iqm_init(void)
+{
+	/*  initialization such that all queues are enabled and blocked
+	     all discard thresholds set to max, no reservation
+	     all 36 WRR slots allocated
+	     all queues can transmit to all threads
+	*/
+	int i;
+	uint16_t queue_idx;
+	struct iqt_entry iqt_entry;
+	uint32_t qid[5] = {
+		0x76543210,
+		0x65432108,
+		0x54321087,
+		0x43210876,
+		0x32108765,
+	};
+
+	iqm_w32(IQM_CTRL_RAW | IQM_CTRL_FRZ | IQM_CTRL_ACT, ctrl);
+
+	iqm_w32(0 , irncr);
+	iqm_w32(0 , irnicr);
+	iqm_w32(IQM_IRNCR_QF7, irnen);
+
+	/* for all ingress queues write default start table entry */
+	iqt_entry.qe    = 0;       /* queue disable */
+	iqt_entry.qdth  = IQM_SSB_SIZE;   /* queue discard threshold (2304
+					     lowest value such that queue
+					     occupies complete SSB) */
+	iqt_entry.qrth  = 0;       /* queue reservation threshold */
+	iqt_entry.qb    = 1;       /* queue blocked */
+	iqt_entry.qbth  = IQM_SSB_SIZE;   /* queue backpressure threshold high
+					     (no backpressure) */
+	iqt_entry.qbtl  = 0;       /* queue backpressure threshold low
+				      (no backpressure) */
+	iqt_entry.qf    = 0;       /* status bit set to 0 */
+	iqt_entry.bp    = 0;       /* status bit set to 0 */
+	iqt_entry.pocc  = 0;       /* PDU occupancy counter */
+	iqt_entry.qocc  = 0;       /* queue occupancy counter */
+	iqt_entry.qdc   = 0;       /* queue PDU discard counter */
+	iqt_entry.tqpp  = 0xFFFF;  /* tail queue packet pointer
+				      (not visible for CPU) */
+	iqt_entry.hqpp  = 0xFFFF;  /* head queue packet pointer
+				      (not visible for CPU) */
+	iqt_entry.tmask = 0;       /* disable all threads */
+
+	for (queue_idx = 0; queue_idx < IQM_MAX_QUEUE; queue_idx++) {
+		switch (queue_idx) {
+		case IQM_QUEUE_CPU_DS:
+		case IQM_QUEUE_CPU_US:
+		case IQM_QUEUE_GEM_UC:
+			/* forward to hardware/SCI */
+			iqt_entry.qb = 0;
+			break;
+		default:
+			/* make available for software */
+			iqt_entry.qb = 1;
+			break;
+		}
+		iqm_iqt_write(queue_idx, &iqt_entry);
+	}
+
+	iqm_w32(IQM_NUM_IPP, fpcr);
+	iqm_w32(0, gocc);
+	iqm_w32(0, gpdc);
+	iqm_w32(0, ts);
+
+	iqm_w32(IQM_SSB_SIZE, goth);     /*  total SSB capacity in
+					     Segments (=18432) */
+	iqm_w32(36, wrrc);               /*  36 slots in WRR used */
+
+	for (i = 0; i < 5; i++)
+		iqm_w32(qid[i], wrrq[i]); /* all queues treated equally*/
+
+	/* sfreeX shouldn't be initialized */
+
+	iqm_w32(0, drc);
+
+	/* enable the module */
+	iqm_w32_mask(IQM_CTRL_FRZ, IQM_CTRL_RAW | IQM_CTRL_ACT, ctrl);
+}
+
+static void gpearb_config(void)
+{
+	uint32_t wdata;
+	uint32_t loop_cnt=0;
+	uint32_t i;
+	uint8_t nb_of_ports = 13;
+
+	gpearb_w32(nb_of_ports, cntr);
+
+	while (loop_cnt <= (nb_of_ports/4)) {
+		wdata=0;
+		for (i=0;i<4;i++) {
+			if ((loop_cnt*4+i)< nb_of_ports) {
+				wdata |=
+					((loop_cnt*4+i) << (i*GPEARB_PID0_ID1));
+			}
+		}
+		gpearb_w32(wdata, pid[loop_cnt]);
+		loop_cnt++;
+	}
+}
+
+void gpearb_init(void)
+{
+	gpearb_config();
+}
+
+/*
+- FSQM deactivated
+- IO buffer disabled
+- all pause thresholds deasserted
+- all interrupts disabled
+- same prio for all masters, except CPU (highest prio)
+- enable round robin
+*/
+static void fsqm_basic_init(void)
+{
+	uint32_t reg;
+
+	fsqm_w32(0, ctrl);
+
+	if (is_falcon_chip_a1x()) {
+		reg  = 0x0;
+		reg |= FSQM_PRIO_A1X_RR_EN;
+		reg |= (1 << FSQM_PRIO_A1X_PIQM_OFFSET);
+		reg |= (1 << FSQM_PRIO_A1X_POCTRL_OFFSET);
+		reg |= (1 << FSQM_PRIO_A1X_PPCTRL_OFFSET);
+		reg |= (1 << FSQM_PRIO_A1X_PICTRL_OFFSET);
+		fsqm_w32(reg, prio_a1x);
+		fsqm_w32(0, ifsc_a1x);
+		fsqm_w32(0, imq_a1x);
+	}
+
+	/* Disable all interrupts */
+	fsqm_w32(0, irncr);
+	fsqm_w32(0, irnicr);
+	fsqm_w32(0, irnen);
+
+	fsqm_w32(0, ofsc);
+	fsqm_w32(0, fsqt0);
+	fsqm_w32(0, fsqt1);
+	fsqm_w32(0, fsqt2);
+	fsqm_w32(0, fsqt3);
+	fsqm_w32(0, fsqt4);
+	fsqm_w32(0, omq);
+}
+
+/*
+   \param nb_of_elements   Number of memory elements that will be put into
+                           the initial Free Segment Queue (FSQ).
+                           A Linked List Table (LLT) will be built up starting
+                           from first_element to last_element.
+*/
+static void fsqm_llt_init(const uint32_t first_element,
+			  const uint32_t last_element)
+{
+	uint32_t i=first_element;
+	int wdata;
+
+	while (i < (last_element)) {
+		wdata = i+1;
+		fsqm_w32(wdata, ram[i]);
+		fsqm_w32(FSQM_RCNT_INIT, rcnt[i]);
+		i++;
+	}
+
+	fsqm_w32(FSQM_LLT_NIL, ram[i]);
+	fsqm_w32(FSQM_RCNT_INIT, rcnt[i]);
+
+	/* ofsq - is used */
+	/* init in queue head & tail */
+	wdata  = first_element << FSQM_OFSQ_HEAD_OFFSET;
+	wdata |= last_element << FSQM_OFSQ_TAIL_OFFSET;
+	fsqm_w32(wdata, ofsq);
+
+	/* init in queue counter */
+	fsqm_w32((last_element-first_element)-1, ofsc);
+
+	if (is_falcon_chip_a2x()) {
+		/* lsarng - is used */
+		/* init range for checks to head & tail */
+		wdata  = first_element << FSQM_LSARNG_MINLSA_OFFSET;
+		wdata |= last_element << FSQM_LSARNG_MAXLSA_OFFSET;
+		fsqm_w32(wdata, lsarng);
+	}
+	if (is_falcon_chip_a1x()) {
+		/* ifsq - is not used? */
+		/* init out queue head & tail */
+		wdata  = FSQM_LLT_NIL << FSQM_IFSQ_A1X_HEAD_OFFSET;
+		wdata |= FSQM_LLT_NIL << FSQM_IFSQ_A1X_TAIL_OFFSET;
+		fsqm_w32(wdata, ifsq_a1x);
+
+		/* init out queue counter */
+		fsqm_w32(0, ifsc_a1x);
+	}
+}
+
+static uint16_t fsqm_llt_read(const uint16_t idx)
+{
+	return fsqm_r32(ram[idx]);
+}
+
+static void fsqm_llt_write(const uint16_t idx, const uint32_t val)
+{
+	fsqm_w32(val, ram[idx]);
+}
+
+static uint16_t fsqm_seg_alloc(void)
+{
+	uint16_t hlsa;
+	debug("A1 OFSC %d\n", fsqm_r32(ofsc));
+	hlsa = (fsqm_r32(omq[1]) >> FSQM_OMQ_HLSA_OFFSET) &
+				    FSQM_OMQ_HLSA_MASK;
+	debug("A2 OFSC %d\n", fsqm_r32(ofsc));
+	fsqm_w32(1, rcnt[hlsa]);
+	if (hlsa == FSQM_LLT_NIL)
+		printf("ooops, can't get enough segments\n");
+
+	return hlsa;
+}
+
+static void fsqm_seg_free(const uint16_t tlsa, const uint16_t hlsa,
+			  const uint16_t seg_len)
+{
+	if (tlsa == FSQM_LLT_NIL || hlsa == FSQM_LLT_NIL || seg_len == 0)
+		return;
+
+	/*
+	- Free the data segments by writing to
+		FSQM.OMQ.TLSA = TLSA
+		FSQM.OMQ.HLSA = HLSA
+		t.b.d.        = SEGL
+	*/
+	debug("F OFSC %d\n", fsqm_r32(ofsc));
+	fsqm_w32((tlsa << FSQM_OMQ_TLSA_OFFSET) | hlsa, omq[seg_len]);
+}
+
+/**
+   Init FSQM
+*/
+void fsqm_init(void)
+{
+	uint32_t llt_first = 0,
+		 llt_last = (GPON_SBS0RAM_SIZE/FSQM_BUFFER_SEGMENT_SIZE);
+	llt_last -= (sbs0ctrl_r32(bar1) & SBS0CTRL_BAR1_BA1V_MASK)/
+						    FSQM_BUFFER_SEGMENT_SIZE;
+
+	if (llt_last > FSQM_LLT_MAX)
+		llt_last = FSQM_LLT_MAX;
+	/* if more than 6 RAM cells are available, reduce to these */
+	if (llt_last >= 6*512)
+		llt_first=llt_last - 6*512;
+	/* point to the last usable entry */
+	llt_last--;
+
+	/*
+	- SW reset brings module into defined HW state
+	- initializes all registers
+	- builds linked list
+	- and then activates FSQM
+	*/
+	fsqm_w32_mask(0, FSQM_CTRL_RES_EN, ctrl);
+	fsqm_w32_mask(FSQM_CTRL_RES_EN, 0, ctrl);
+
+	fsqm_basic_init();
+	fsqm_llt_init(llt_first, llt_last);
+
+	fsqm_w32_mask(0, 0, io_buf_rd);
+	fsqm_w32_mask(0, 0, io_buf_wr);
+
+	fsqm_w32_mask(0, FSQM_CTRL_ACT_EN, ctrl);
+}
+
+static int ssb_write(const uint32_t max_len, const uint8_t *data,
+		     uint32_t *hlsa, uint32_t *tlsa)
+{
+	int ret = 0;
+	uint32_t i, to_copy, len, segments;
+	const uint8_t *ptr;
+	unsigned long psa;
+
+	ptr = data;
+	len = max_len;
+	segments = (max_len / FSQM_BUFFER_SEGMENT_SIZE) + 1;
+
+	*hlsa = *tlsa = fsqm_seg_alloc();
+	if (*tlsa == FSQM_LLT_NIL) {
+		printf("ooops, can't get enough segments\n");
+		return -1;
+	}
+
+	do {
+
+		if (len > FSQM_BUFFER_SEGMENT_SIZE)
+			to_copy = FSQM_BUFFER_SEGMENT_SIZE;
+		else
+			to_copy = len;
+
+		psa = GPON_SBS0RAM_BASE + ONU_RAM_PACKET_BUFFER_OFFSET +
+		      (*tlsa * FSQM_BUFFER_SEGMENT_SIZE);
+#ifdef DEBUG
+		if (psa >= GPON_SBS0RAM_END)
+			printf("TX SSB invalid: 0x%08lX\n", psa);
+#endif
+
+		if (((ulong_t)ptr & (sizeof(ulong_t)-1)) == 0) {
+			/* source (ptr) is aligned */
+			for (i=0;i<to_copy;) {
+				reg_w32(*((uint32_t *)ptr), (void *)psa);
+				ptr += 4;
+				psa += 4;
+				i += 4;
+			}
+		} else {
+			for (i = 0; i < to_copy;) {
+				uint32_t val;
+				val = ((ptr[0])<<24) + ((ptr[1])<<16) +
+				      ((ptr[2])<<8) + (ptr[3]);
+				reg_w32(val, (void *)psa);
+				ptr += 4;
+				psa += 4;
+				i += 4;
+			}
+		}
+		len -= to_copy;
+		if (len) {
+			i = *tlsa;
+			*tlsa = fsqm_seg_alloc();
+			if (*tlsa == FSQM_LLT_NIL) {
+				printf("ooops, can't get enough segments\n");
+				fsqm_seg_free(*hlsa, i, segments);
+				return -1;
+			}
+			fsqm_llt_write(i, *tlsa);
+		}
+	} while (len);
+
+	return ret;
+}
+
+void ictrll_port_enable_set(const bool lan_port_en)
+{
+	if (lan_port_en)
+		ictrll0_w32_mask(0, ICTRLL_CTRL_ACT_EN, ctrl);
+	else
+		ictrll0_w32_mask(ICTRLL_CTRL_ACT_EN, 0, ctrl);
+}
+
+void ictrll_init(void)
+{
+	uint32_t cfg;
+
+	/*
+	- DBG disabled
+	- BroadCast disabled
+	- RAW mode disabled
+	- Soft reset disabled
+	- ICTRL disabled
+	*/
+	ictrll0_w32(0, ctrl);
+
+	/*
+	Register DMAW_CFG
+	- Queue for Alloc commands = 1
+	- Queue for Free commands = 1
+	- 8 wait cycles
+	*/
+	cfg  = ICTRLL_DMAW_CFG_ALLOCQ | ICTRLL_DMAW_CFG_FREEQ;
+	set_val(cfg, 0x8, ICTRLL_DMAW_CFG_LSARLMT_MASK,
+		ICTRLL_DMAW_CFG_LSARLMT_OFFSET);
+	ictrll0_w32(cfg, dmaw_cfg);
+
+	/* Ethernet DA (high adr) = 0 */
+	ictrll0_w32(0, rawda0);
+
+	/* Ethernet DA (low adr) = 0 */
+	ictrll0_w32(0, rawda1);
+
+	/* max size for ethernet: FALCON_MAX_ETHERNET_FRAME_LENGTH */
+	ictrll0_w32(FALCON_MAX_ETHERNET_FRAME_LENGTH, maxsize0);
+
+	/* Initialize all counters = 0 */
+	ictrll0_w32(0, rxbcnth);
+	ictrll0_w32(0, rxbcntl);
+	ictrll0_w32(0, ovrsize);
+	ictrll0_w32(0, dmawerr);
+	ictrll0_w32(0, macerr);
+	ictrll0_w32(0, rxpcnt);
+	ictrll0_w32(0, rxp64cnt);
+	ictrll0_w32(0, rxp65cnt);
+	ictrll0_w32(0, rxp128cnt);
+	ictrll0_w32(0, rxp256cnt);
+	ictrll0_w32(0, rxp512cnt);
+	ictrll0_w32(0, rxp1024cnt);
+	ictrll0_w32(0, rxp1519cnt);
+	ictrll0_w32(0, undsize);
+
+	/* Disable all interrupts */
+	ictrll0_w32(0, irncr);
+	ictrll0_w32(0, irnicr);
+	ictrll0_w32(0, irnen);
+}
+
+
+void octrll_init(void)
+{
+	/*
+	- assigned EPN: 0, 1, 2, 3
+	- timeout enabled: 1s
+	- FSQM queue 1 selected (LSA freeing)
+	- all counters set = 0
+	- module OCTRLL activated
+	*/
+
+	octrll0_w32_mask(OCTRLL_CTRL_ACT_EN, OCTRLL_CTRL_TOUTEN_EN,
+			      ctrl);
+
+	/* timeout 1 s */
+	octrll0_w32(0x6d, toutcfg);
+	octrll0_w32(0, cfg);
+
+	octrll0_w32(OCTRLL_DCTRL_FQ_Q1, dctrl);
+
+	/* reset counter */
+	octrll0_w32(0, txbcntl);
+	octrll0_w32(0, txbcnth);
+	octrll0_w32(0, txpcnt);
+	octrll0_w32(0, txp64cnt);
+	octrll0_w32(0, txp65cnt);
+	octrll0_w32(0, txp128cnt);
+	octrll0_w32(0, txp256cnt);
+	octrll0_w32(0, txp512cnt);
+	octrll0_w32(0, txp1024cnt);
+	octrll0_w32(0, txp1519cnt);
+}
+
+void octrll_port_enable_set(const bool lan_port_en)
+{
+	if (lan_port_en)
+		octrll0_w32_mask(0, OCTRLL_CTRL_ACT_EN, ctrl);
+	else
+		octrll0_w32_mask(OCTRLL_CTRL_ACT_EN, 0, ctrl);
+}
+
+static int octrll_write(const uint32_t max_len, const uint32_t hlsa,
+			const uint32_t tlsa)
+{
+	uint32_t hdrl, bdyl, cfg;
+
+	if(max_len > FSQM_BUFFER_SEGMENT_SIZE) {
+		hdrl = FSQM_BUFFER_SEGMENT_SIZE;
+		bdyl = max_len - FSQM_BUFFER_SEGMENT_SIZE;
+	} else {
+		hdrl = max_len;
+		bdyl = 0;
+	}
+	octrll0_w32(hlsa, rawcfg0);
+	cfg = 0;
+	cfg |= (hdrl << OCTRLL_RAWCFG1_HDRL_OFFSET) & OCTRLL_RAWCFG1_HDRL_MASK;
+	cfg |= (bdyl << OCTRLL_RAWCFG1_BDYL_OFFSET) & OCTRLL_RAWCFG1_BDYL_MASK;
+	octrll0_w32(cfg, rawcfg1);
+	octrll0_w32(OCTRLL_RAWCTRL_RAWTX, rawctrl);
+
+	return 0;
+}
+
+#define GPE_PDU_TYPE_ETH	0
+
+/** Read from ingress queue
+
+   The OMCI messages can be received either directly from the OMCI ingress
+   queue (before SCE processing) or from one or two egress queues (one per
+   OMCI priority, after SCE processing).
+*/
+int falcon_pdu_info_read(const uint8_t qid, struct pdu_info *info)
+{
+	uint32_t reg, cnt;
+
+	info->len = 0;
+	info->segments = 0;
+	info->hlsa = info->tlsa = FSQM_LLT_NIL;
+
+	cnt = iqm_r32(iqt[qid].iqt2);
+	if ((cnt & IQM_IQT02_QOCC_MASK) == 0)
+		/* no data available */
+		return -1;
+	/*
+	Hardware Programming Details - Read from Ingress Queue
+	- The ingress queue <n> must be configured such that it is not read by
+		the hardware scheduler.
+		The OMCI ingress queue number is defined as
+		n = ONU_GPE_INGRESS_QUEUE_OMCI
+		IQT<n>0.QE = EN   enable the queue to receive data
+		IQT<n>1.QB = EN   block the queue from HW WRR scheduling
+
+		done in GPE_Init by default()
+	*/
+
+	/*
+	- send a dequeue command to the IQM
+         if (IQM.DRCR.EN != 0) {wait} else {
+         IQM.DRCR.QID = ONU_GPE_INGRESS_QUEUE_OMCI
+         IQM.DRCR.EN  = EN }
+
+	*/
+	iqm_w32_mask((IQM_DRC_QID_MASK | IQM_DRC_ENA), (qid | IQM_DRC_ENA),drc);
+	/*
+	- read the dequeue result from the IQM
+         if (IQM.DRCR.ENA != 0) {wait} else {
+         if (IQM.DRPR0.PDUT != ONU_GPE_PDU_TYPE_OMCI) {invalid PDU type, dicard
+							the data} else
+         read IQM.DRPR0.PLEN: this is the payload length to be handled
+         read IQM.DRPR1.HLSA: this is the pointer to the first data segment
+                              (which is the only segment for 48-byte OMCI)
+         read IQM.DRPR1.TLSA: this is the pointer to the last data segment
+                              (same as HLSA for 48-byte OMCI)
+         read IQM.DRPR2.TS  : for debug only - this is a receive time stamp,
+                              the time stamp unit is one clock cycle of the
+                              312.5 MHz module clock (3.2 ns), rolling over
+			      every 53 ms
+	*/
+	cnt = 0;
+	while ((iqm_r32(drc) & IQM_DRC_ENA) && (cnt < 3000))
+		cnt++;
+
+	if (cnt == 3000) {
+		printf("no drc response\n");
+		return -2;
+	}
+
+	reg = iqm_r32(drp2);
+	info->len = (reg & IQM_DRP2_PLEN_MASK) >> IQM_DRP2_PLEN_OFFSET;
+	info->segments = (info->len / FSQM_BUFFER_SEGMENT_SIZE) + 1;
+	reg = iqm_r32(drp3);
+	info->hlsa = (reg & IQM_DRP3_HLSA_MASK) >> IQM_DRP3_HLSA_OFFSET;
+	info->tlsa = (reg & IQM_DRP3_TLSA_MASK) >> IQM_DRP3_TLSA_OFFSET;
+
+	debug("hlsa/tlsa %08x\n", reg);
+
+	if ((iqm_r32(drp1) & IQM_DRP1_PDUT_MASK) !=
+			(uint32_t)(GPE_PDU_TYPE_ETH << IQM_DRP1_PDUT_OFFSET)) {
+		printf("wrong pdu type\n");
+		/* discard data */
+		falcon_pdu_data_read(info, NULL);
+		return -3;
+	}
+
+	return 0;
+}
+
+int falcon_pdu_data_read(const struct pdu_info *info, uint8_t *data)
+{
+	int ret = 0;
+	uint32_t lsa, len=info->len, to_copy, i;
+	uint8_t *ptr;
+	unsigned long psa;
+
+	if (data == NULL || info->segments == 0 || info->tlsa == FSQM_LLT_NIL ||
+	    info->hlsa == FSQM_LLT_NIL || info->len == 0) {
+		ret = -1;
+		goto err;
+	}
+
+	ptr = data;
+	lsa = info->hlsa;
+	do {
+		if (len > FSQM_BUFFER_SEGMENT_SIZE)
+			to_copy = FSQM_BUFFER_SEGMENT_SIZE;
+		else
+			to_copy = len;
+
+		psa = GPON_SBS0RAM_BASE + ONU_RAM_PACKET_BUFFER_OFFSET +
+		      (lsa * FSQM_BUFFER_SEGMENT_SIZE);
+#ifdef DEBUG
+		if (psa >= GPON_SBS0RAM_END)
+			printf("RX SSB invalid: 0x%08lX\n", psa);
+#endif
+
+		/* use uint8_t for ptr to allow unaligned buffers */
+		for (i=0;i<to_copy;) {
+			uint32_t val;
+			val = reg_r32((void *)psa);
+			*ptr++ = (val >> 24) & 0xFF;
+			*ptr++ = (val >> 16) & 0xFF;
+			*ptr++ = (val >>  8) & 0xFF;
+			*ptr++ =  val & 0xFF;
+			psa += 4;
+			i += 4;
+		}
+
+		len -= to_copy;
+		if (len) {
+			uint32_t new_lsa;
+			new_lsa = fsqm_llt_read(lsa);
+#ifdef DEBUG
+			if (new_lsa == FSQM_LLT_NIL) {
+				printf("invalid lsa at 0x%08X\n", lsa);
+				return -1;
+			}
+#endif
+			lsa = new_lsa;
+		}
+	} while (len);
+
+	if (lsa != info->tlsa)
+		printf("tlsa & lsa not equal\n");
+
+err:
+	fsqm_seg_free(info->tlsa, info->hlsa, info->segments);
+
+	return ret;
+}
+
+int falcon_pdu_write(const uint32_t len, const uint8_t *data)
+{
+	int ret = 0;
+	uint32_t hlsa, tlsa;
+
+	ret = ssb_write(len, data, &hlsa, &tlsa);
+
+	if (ret == 0) {
+		ret = octrll_write(len, hlsa, tlsa);
+		if (ret != 0)
+			fsqm_seg_free(hlsa, tlsa,
+				      (len / FSQM_BUFFER_SEGMENT_SIZE) + 1);
+	}
+
+	return ret;
+}
diff --git a/drivers/net/falcon/falcon_ll.h b/drivers/net/falcon/falcon_ll.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/falcon_ll.h
@@ -0,0 +1,197 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _falcon_ll_h
+#define _falcon_ll_h
+
+/** \addtogroup MAPI_REFERENCE_INTERNAL
+   @{
+*/
+
+/** \defgroup FALCON_INTERNAL FalcON Low-Level Interface
+   @{
+*/
+
+/** Ingress queue of UNI port 0 */
+#define FALCON_INGRESS_QUEUE_LAN_0     0
+/** Ingress queue of UNI port 1 */
+#define FALCON_INGRESS_QUEUE_LAN_1     1
+/** Ingress queue of UNI port 2 */
+#define FALCON_INGRESS_QUEUE_LAN_2     2
+/** Ingress queue of UNI port 3 */
+#define FALCON_INGRESS_QUEUE_LAN_3     3
+
+enum lan_mode {
+	/** 10/100/1000BASE-T automatic speed negotiation */
+	LAN_MAC_MODE_AUTO = 0,
+	/** MII/RMII interface mode at 10, 100, or 200 Mbit/s */
+	LAN_MAC_MODE_MII = 1,
+	/** GMII/RGMII interface mode at 1000 Mbit/s */
+	LAN_MAC_MODE_GMII = 2
+};
+
+/** Ethernet PHY duplex modes
+*/
+enum lan_mode_duplex {
+	/** 10/100/1000BASE-T automatic speed negotiation */
+	LAN_MAC_MODE_DUPLEX_AUTO = 0,
+	/** 10BASE-T fixed speed selection */
+	LAN_MAC_MODE_DUPLEX_FULL = 1,
+	/** 100BASE-T fixed speed selection */
+	LAN_MAC_MODE_DUPLEX_HALF = 2
+};
+
+/** Ethernet PHY duplex modes
+*/
+enum lan_mode_flow {
+	/** flow control is automatic */
+	LAN_MAC_MODE_FLOW_AUTO = 0,
+	/** flow control in receive (ingress direction) only */
+	LAN_MAC_MODE_FLOW_RX = 1,
+	/** flow control in transmit (egress direction) only */
+	LAN_MAC_MODE_FLOW_TX = 2,
+	/** flow control in receive and transmit direction */
+	LAN_MAC_MODE_FLOW_RXTX = 3,
+	/** flow control is disabled */
+	LAN_MAC_MODE_FLOW_NONE = 4
+};
+
+
+/** IQT entry
+*/
+struct iqt_entry {
+	uint16_t qe;
+	uint16_t qdth;
+	uint16_t qrth;
+	uint16_t qb;
+	uint16_t qbth;
+	uint16_t qbtl;
+	uint16_t qf;
+	uint16_t bp;
+	uint16_t pocc;
+	uint16_t qocc;
+	uint32_t qdc;
+	uint16_t tick;
+	uint32_t tmask;  /* bit mask t0...t17, link0, link1 */
+	uint16_t tqpp;
+	uint16_t hqpp;
+};
+
+struct pdu_info {
+	/** PDU length in bytes */
+	uint32_t len;
+	/** logical segment address - head */
+	uint32_t hlsa;
+	/** logical segment address - tail */
+	uint32_t tlsa;
+	/** number of segments */
+	uint32_t segments;
+};
+
+/**
+   Initialize the EIM block.
+*/
+void eim_init(void);
+
+/**
+   Configure LAN ports.
+*/
+void eim_mac_config_set(const enum lan_mode mode,
+			const enum lan_mode_duplex mode_duplex,
+			const enum lan_mode_flow mode_flow);
+
+void eim_mii_config_set(const uint8_t xmii_port_id, uint32_t miicfg);
+
+/**
+   Read MDIO register.
+*/
+int eim_mdio_data_read(const uint8_t addr_dev, const uint8_t addr_reg,
+		       uint16_t *data);
+
+/**
+   Write MDIO register.
+*/
+int eim_mdio_data_write(const uint8_t addr_dev, const uint8_t addr_reg,
+			const uint16_t data);
+
+/**
+   Initialize the IQM block.
+*/
+void iqm_init(void);
+
+/** enable/disable a queue */
+void iqm_queue_enable_set(const uint16_t queue_idx, const bool queue_en);
+
+/**
+   Initialize the GPEARB block.
+*/
+void gpearb_init(void);
+
+/**
+   Initialize the FSQM block.
+*/
+void fsqm_init(void);
+
+/**
+   Initialize the ICTRLL block.
+*/
+void ictrll_init(void);
+
+/**
+   Enable LAN ports.
+   \param lan_port_en  LAN port enable
+*/
+void ictrll_port_enable_set(const bool lan_port_en);
+
+/**
+   Initialize the OCTRLL block.
+*/
+void octrll_init(void);
+
+/**
+   Enable LAN ports.
+   \param lan_port_en 	LAN port enable flags
+*/
+void octrll_port_enable_set(const bool lan_port_en);
+
+/**
+   Read the PDU information from the hardware. This information will be used to
+   read the PDU data afterwards.
+
+   The data read process is splitted into tow functions to allow the calling
+   process to allocate the destination data memory.
+*/
+int falcon_pdu_info_read(const uint8_t qid, struct pdu_info *info);
+
+/**
+   Read the PDU data from the hardware.
+   In case that the data pointer is zero the PDU will be freed.
+*/
+int falcon_pdu_data_read(const struct pdu_info *info, uint8_t *data);
+
+/**
+   Write a ethernet frame to the specified LAN port. This mechanism doesn't use
+   the packet engine.
+
+   \param lan_port   LAN port number
+   \param len        data length
+   \param data       ethernet frame (not padded, no fcs)
+
+   \return
+   - -1 error
+   - 0 success
+*/
+int falcon_pdu_write(const uint32_t len, const uint8_t *data);
+
+/*! @} */
+
+/*! @} */
+
+#endif
diff --git a/drivers/net/falcon/falcon_register.h b/drivers/net/falcon/falcon_register.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/falcon_register.h
@@ -0,0 +1,74 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+#ifndef _falcon_register_h
+#define _falcon_register_h
+
+/* exclude some parts from SWIG generation */
+#ifndef SWIG
+
+EXTERN_C_BEGIN
+
+/** \addtogroup MAPI_REFERENCE_INTERNAL
+   @{
+*/
+
+/*! \defgroup ONU_REGISTER_INTERNAL Device Register Access
+   @{
+*/
+
+#include <asm/io.h>
+
+#include "falcon_std_defs.h"
+#include <asm/arch/gpon_reg_base.h>
+#include <asm/arch/sys_eth_reg.h>
+
+#include "fsqm_reg.h"
+#include "gpearb_reg.h"
+#include "iqm_reg.h"
+#include "eim_reg.h"
+#include "ictrll_reg.h"
+#include "octrll_reg.h"
+#include "sbs0ctrl_reg.h"
+#include "sgmii_reg.h"
+#include "sxgmii_reg.h"
+
+/** Read value of register
+
+   \param reg  register address
+   \return register contents
+*/
+#define reg_r32(reg) readl(reg)
+
+/** Write value to register
+
+   \param val  register value
+   \param reg  register address
+*/
+#define reg_w32(val, reg) writel(val, reg)
+
+/** Clear / set bits within a register
+
+   \param clear   clear mask
+   \param set     set mask
+   \param reg     register address
+*/
+#define reg_w32_mask(clear, set, reg) reg_w32((reg_r32(reg) & ~(clear)) | (set), reg)
+
+
+#define set_val(reg, val, mask, offset) do {(reg) |= (((val) << (offset)) & (mask)); } while(0)
+
+/*! @} */
+/*! @} */
+
+EXTERN_C_END
+
+#endif /* SWIG */
+
+#endif
diff --git a/drivers/net/falcon/falcon_resource.h b/drivers/net/falcon/falcon_resource.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/falcon_resource.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file "LICENSE" in the root folder of
+  this software module.
+
+******************************************************************************/
+/**
+   \file falcon_resource.h
+*/
+#ifndef _falcon_resource_h
+#define _falcon_resource_h
+
+/** \defgroup GPON_IMPLEMENTATION GPON Modem Implementation
+    This chapter provides details of the hardware-related implementation.
+@{
+*/
+
+/** \defgroup GPON_RESOURCE FALCON Gpon Modem Hardware and Software Resources
+    This chapter defines values that are related to the FALCON hardware and
+    software.
+@{
+*/
+
+/**
+   This file holds the definitions that are provided to reflect the available
+   resources and other limit values that are related to the implementation.
+   \remark Changing of any of these values will lead to system malfunction if
+           the hardware does not support the assigned value(s)!
+*/
+
+/** Number of Ethernet UNI ports */
+#define ONU_GPE_MAX_ETH_UNI                  4
+
+/** Maximum Ethernet frame size that is supported by hardware.
+    The value is given in number of bytes.
+    9990 byte is the hardware limit of the on-chip PHYs.
+    A smaller value (such as 1518) may be defined instead. */
+#define FALCON_MAX_ETHERNET_FRAME_LENGTH 2047
+
+/*! @} */
+
+/* end ONU_RESOURCE */
+
+/*! @} */
+
+#endif
diff --git a/drivers/net/falcon/falcon_std_defs.h b/drivers/net/falcon/falcon_std_defs.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/falcon_std_defs.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _falcon_std_defs_h
+#define _falcon_std_defs_h
+
+#include "common.h"
+
+#if (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L)) && 0
+/* standard C99 types not available */
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+
+#  if defined(__WORDSIZE) && (__WORDSIZE == 64)
+typedef unsigned long int uint64_t;
+#  else
+typedef unsigned long long int uint64_t;
+#  endif
+#endif
+#if !defined(__cplusplus) && !defined(bool)
+#      ifndef SWIG
+typedef char bool;
+#    endif
+#  define false 0
+#  define true 1
+#endif
+
+typedef unsigned long int ulong_t;
+
+/** This is the volatile unsigned 8-bit datatype. */
+typedef volatile uint8_t  vuint8_t;
+/** This is the volatile signed 8-bit datatype. */
+typedef volatile int8_t   vint8_t;
+/** This is the volatile unsigned 16-bit datatype. */
+typedef volatile uint16_t vuint16_t;
+/** This is the volatile signed 16-bit datatype. */
+typedef volatile int16_t  vint16_t;
+/** This is the volatile unsigned 32-bit datatype. */
+typedef volatile uint32_t vuint32_t;
+/** This is the volatile signed 32-bit datatype. */
+typedef volatile int32_t  vint32_t;
+/** This is the volatile unsigned 64-bit datatype. */
+typedef volatile uint64_t vuint64_t;
+
+#ifdef __cplusplus
+#  ifndef EXTERN_C_BEGIN
+/** Extern C block begin macro */
+#     define EXTERN_C_BEGIN extern "C" {
+#  endif
+#  ifndef EXTERN_C_END
+/** Extern C block end macro */
+#     define EXTERN_C_END }
+#  endif
+#else
+#  ifndef EXTERN_C_BEGIN
+/** Extern C block begin macro */
+#     define EXTERN_C_BEGIN
+#  endif
+#  ifndef EXTERN_C_END
+/** Extern C block end macro */
+#     define EXTERN_C_END
+#  endif
+#endif
+
+#endif
diff --git a/drivers/net/falcon/fsqm_reg.h b/drivers/net/falcon/fsqm_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/fsqm_reg.h
@@ -0,0 +1,839 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _fsqm_reg_h
+#define _fsqm_reg_h
+
+/** \addtogroup FSQM_REGISTER
+   @{
+*/
+/* access macros */
+#define fsqm_r32(reg) reg_r32(&fsqm->reg)
+#define fsqm_w32(val, reg) reg_w32(val, &fsqm->reg)
+#define fsqm_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &fsqm->reg)
+#define fsqm_r32_table(reg, idx) reg_r32_table(fsqm->reg, idx)
+#define fsqm_w32_table(val, reg, idx) reg_w32_table(val, fsqm->reg, idx)
+#define fsqm_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, fsqm->reg, idx)
+#define fsqm_adr_table(reg, idx) adr_table(fsqm->reg, idx)
+
+
+/** FSQM register structure */
+struct gpon_reg_fsqm
+{
+   /** Control Register
+       This register provides the global FSQM controls. */
+   unsigned int ctrl; /* 0x00000000 */
+   /** Priority Control Register (only A1x)
+       This register controls the LLT access priority of the different FSQM bus masters. */
+   unsigned int prio_a1x; /* 0x00000004 */
+   /** IO-Buffer Control Register for Read (ALLOC)
+       This register controls the different IO read buffers in the FSQM. */
+   unsigned int io_buf_rd; /* 0x00000008 */
+   /** IO-Buffer Control Register for Write (FREE)
+       This register controls the different IO write buffers in the FSQM. */
+   unsigned int io_buf_wr; /* 0x0000000C */
+   /** IRN Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncr; /* 0x00000010 */
+   /** IRN Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irnicr; /* 0x00000014 */
+   /** IRN Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irnen; /* 0x00000018 */
+   /** Reserved */
+   unsigned int res_0; /* 0x0000001C */
+   union {
+      /** Input Free Segment Queue Register (only A1x)
+          This register provides access to the head and tail pointers of the Input Free Segment Queue. */
+      unsigned int ifsq_a1x; /* 0x00000020 */
+      /** TAIL LSA Capture Register (only A2x)
+          In case of a memory address violation (FRMEM, ACCMEM), this register holds the OFSQ TAIL captured at that time */
+      unsigned int tailcapr; /* 0x00000020 */
+   };
+   /** Output Free Segment Queue Register
+       This register provides access to the head and tail pointers of the Output Free Segment Queue. */
+   unsigned int ofsq; /* 0x00000024 */
+   /** Input Free Segment Counter Register (only A1x)
+       This register holds the number of entries in the Input Free Segment Queue. */
+   unsigned int ifsc_a1x; /* 0x00000028 */
+   /** Output Free Segment Counter Register
+       This register holds the number of entries in the Output Free Segment Queue. */
+   unsigned int ofsc; /* 0x0000002C */
+   /** Free Segment Queue Threshold Register 0
+       This register provides a general supervision threshold for the free segment queue. */
+   unsigned int fsqt0; /* 0x00000030 */
+   /** Reserved */
+   unsigned int res_1[15]; /* 0x00000034 */
+   /** Free Segment Queue Threshold Register 1
+       This register provides a general supervision threshold for the free segment queue. */
+   unsigned int fsqt1; /* 0x00000070 */
+   /** Reserved */
+   unsigned int res_2[15]; /* 0x00000074 */
+   /** Free Segment Queue Threshold Register 2
+       This register provides a general supervision threshold for the free segment queue. */
+   unsigned int fsqt2; /* 0x000000B0 */
+   /** Reserved */
+   unsigned int res_3[15]; /* 0x000000B4 */
+   /** Free Segment Queue Threshold Register 3
+       This register provides a general supervision threshold for the free segment queue. */
+   unsigned int fsqt3; /* 0x000000F0 */
+   /** Reserved */
+   unsigned int res_4[15]; /* 0x000000F4 */
+   /** Free Segment Queue Threshold Register 4
+       This register provides a general supervision threshold for the free segment queue. */
+   unsigned int fsqt4; /* 0x00000130 */
+   /** Reserved */
+   unsigned int res_5[19]; /* 0x00000134 */
+   /** Logical Segment Address Range (only A2x)
+       This register holds the allowed LSA range for the OFSQ. At initialization the OFSQ must be started at MINLSA and terminated at MAXLSA */
+   unsigned int lsarng; /* 0x00000180 */
+   /** Reserved */
+   unsigned int res_6[3]; /* 0x00000184 */
+   /** Requestrate Limitation Register 0 (only A2x)
+       This register holds the parameters for the request rate limiters for masters 0 ... 3 */
+   unsigned int rlimr0; /* 0x00000190 */
+   /** Requestrate Limitation Register 1 (only A2x)
+       This register holds the parameters for the request rate limiters for masters 4 ... 7 */
+   unsigned int rlimr1; /* 0x00000194 */
+   /** Requestrate Limitation Register 2 (only A2x)
+       This register holds the parameters for the request rate limiters for masters 0 ... 3 */
+   unsigned int rlimr2; /* 0x00000198 */
+   /** Requestrate Limitation Register 3 (only A2x)
+       This register holds the parameters for the request rate limiters for masters 0 ... 3 */
+   unsigned int rlimr3; /* 0x0000019C */
+   /** Reserved */
+   unsigned int res_7[65432]; /* 0x000001A0 */
+   /** Input Message Queue Register (only A1x)
+       When written (FREE command), this register reflects the head and tail entries of the respective Input Message Queue, the length to be freed must be provided in the lower 15 bits of the address. When read (ALLOC command), the register returns an LSA in the field HLSA. */
+   unsigned int imq_a1x[32768]; /* 0x00040000 */
+   /** Output Message Queue Register
+       When written (FREE command), this register reflects the head and tail entries of the respective Output Message Queue, the length to be freed must be provided in the lower 15 bits of the address. When read (ALLOC command), the register returns an LSA in the field HLSA. */
+   unsigned int omq[32768]; /* 0x00060000 */
+   /** Repeat Counter Addresses
+       This addresses reflect the memory containing the Repeat Counter values. */
+   unsigned int rcnt[32768]; /* 0x00080000 */
+   /** Repeat Counter Inc/Dec Addresses
+       This addresses are used to increment (Write) or decrement (Read) the repeat rounter values. A read operation will return the old read counter value. */
+   unsigned int rcnt_incdec[32768]; /* 0x000A0000 */
+   /** LLT RAM Addresses
+       This addresses reflect the memory containing the LLT. */
+   unsigned int ram[65536]; /* 0x000C0000 */
+};
+
+
+/* Fields of "Control Register" */
+/** Alloc Disable for master 14
+    When selected (=1) this bit disables alloc for master14. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD14 0x40000000
+/* Not selected
+#define FSQM_CTRL_AD14_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD14_SEL 0x40000000
+/** Alloc Disable for master 13
+    When selected (=1) this bit disables alloc for master13. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD13 0x20000000
+/* Not selected
+#define FSQM_CTRL_AD13_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD13_SEL 0x20000000
+/** Alloc Disable for master 12
+    When selected (=1) this bit disables alloc for master12. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD12 0x10000000
+/* Not selected
+#define FSQM_CTRL_AD12_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD12_SEL 0x10000000
+/** Alloc Disable for master 11
+    When selected (=1) this bit disables alloc for master11. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD11 0x08000000
+/* Not selected
+#define FSQM_CTRL_AD11_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD11_SEL 0x08000000
+/** Alloc Disable for master 10
+    When selected (=1) this bit disables alloc for master10. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD10 0x04000000
+/* Not selected
+#define FSQM_CTRL_AD10_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD10_SEL 0x04000000
+/** Alloc Disable for master 9
+    When selected (=1) this bit disables alloc for master9. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD9 0x02000000
+/* Not selected
+#define FSQM_CTRL_AD9_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD9_SEL 0x02000000
+/** Alloc Disable for master 8
+    When selected (=1) this bit disables alloc for master8. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD8 0x01000000
+/* Not selected
+#define FSQM_CTRL_AD8_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD8_SEL 0x01000000
+/** Alloc Disable for master 7
+    When selected (=1) this bit disables alloc for master7. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD7 0x00800000
+/* Not selected
+#define FSQM_CTRL_AD7_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD7_SEL 0x00800000
+/** Alloc Disable for master 6
+    When selected (=1) this bit disables alloc for master6. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD6 0x00400000
+/* Not selected
+#define FSQM_CTRL_AD6_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD6_SEL 0x00400000
+/** Alloc Disable for master 5
+    When selected (=1) this bit disables alloc for master5. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD5 0x00200000
+/* Not selected
+#define FSQM_CTRL_AD5_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD5_SEL 0x00200000
+/** Alloc Disable for master 4
+    When selected (=1) this bit disables alloc for master4. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD4 0x00100000
+/* Not selected
+#define FSQM_CTRL_AD4_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD4_SEL 0x00100000
+/** Alloc Disable for master 3
+    When selected (=1) this bit disables alloc for master3. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD3 0x00080000
+/* Not selected
+#define FSQM_CTRL_AD3_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD3_SEL 0x00080000
+/** Alloc Disable for master 2
+    When selected (=1) this bit disables alloc for master2. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD2 0x00040000
+/* Not selected
+#define FSQM_CTRL_AD2_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD2_SEL 0x00040000
+/** Alloc Disable for master 1
+    When selected (=1) this bit disables alloc for master1. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD1 0x00020000
+/* Not selected
+#define FSQM_CTRL_AD1_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD1_SEL 0x00020000
+/** Alloc Disable for master 0
+    When selected (=1) this bit disables alloc for master0. This master will receive NIL = 0x7FFF */
+#define FSQM_CTRL_AD0 0x00010000
+/* Not selected
+#define FSQM_CTRL_AD0_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_AD0_SEL 0x00010000
+/** Soft Reset of the FSQM Module
+    This bit resets all registers of the FSQM. Note that the memory contents are not touched. */
+#define FSQM_CTRL_RES 0x00000010
+/* Disable
+#define FSQM_CTRL_RES_DIS 0x00000000 */
+/** Enable */
+#define FSQM_CTRL_RES_EN 0x00000010
+/** Disable Allocation Mechanism
+    When selected (=1) this bit disables the allocation mechanism in the FSQM completely. Any allocation request to the FSQM will return a NIL! */
+#define FSQM_CTRL_ALLOC_DIS 0x00000004
+/* Not selected
+#define FSQM_CTRL_ALLOC_DIS_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_ALLOC_DIS_SEL 0x00000004
+/** Allocation Freeze Mechanism
+    When selected (=1) this bit disables the allocation mechanism in the FSQM in case of Memory Address Violations. Any subsequent allocation request to the FSQM will return a NIL! */
+#define FSQM_CTRL_ALLOC_FRZ 0x00000002
+/* Not selected
+#define FSQM_CTRL_ALLOC_FRZ_NSEL 0x00000000 */
+/** Selected */
+#define FSQM_CTRL_ALLOC_FRZ_SEL 0x00000002
+/** Activate Core State Machine
+    This bit enables the FSQM state machine. Allocate and Free commands cannot be executed when FSQM is disabled. */
+#define FSQM_CTRL_ACT 0x00000001
+/* Disable
+#define FSQM_CTRL_ACT_DIS 0x00000000 */
+/** Enable */
+#define FSQM_CTRL_ACT_EN 0x00000001
+
+/* Fields of "Priority Control Register" */
+/** Enable/disable round-robin of priorities
+    This bit enables the automatic round-robin of priorities. This bit only affects internal priorities of DMAW1, DMAW2, DMAR. */
+#define FSQM_PRIO_A1X_RR 0x01000000
+/* Disable
+#define FSQM_PRIO_A1X_RR_DIS 0x00000000 */
+/** Enable */
+#define FSQM_PRIO_A1X_RR_EN 0x01000000
+/** Priority number for IQM (GPE_KERNEL)
+    This register holds the priority information for the Ingress Queue Manager. 0 means highest priority, 7 lowest. */
+#define FSQM_PRIO_A1X_PIQM_MASK 0x00070000
+/** field offset */
+#define FSQM_PRIO_A1X_PIQM_OFFSET 16
+/** Priority number for OCTRL (GPE_OUT)
+    This register holds the priority information for the output control bus accesses. 0 means highest priority, 7 lowest. */
+#define FSQM_PRIO_A1X_POCTRL_MASK 0x00007000
+/** field offset */
+#define FSQM_PRIO_A1X_POCTRL_OFFSET 12
+/** Priority number for PCTRL (GPE_KERNEL)
+    This register holds the priority information for the packet control bus accesses. 0 means highest priority, 7 lowest. */
+#define FSQM_PRIO_A1X_PPCTRL_MASK 0x00000700
+/** field offset */
+#define FSQM_PRIO_A1X_PPCTRL_OFFSET 8
+/** Priority number for ICTRL (GPE_IN)
+    This register holds the priority information for the input control bus accesses. 0 means highest priority, 7 lowest. */
+#define FSQM_PRIO_A1X_PICTRL_MASK 0x00000070
+/** field offset */
+#define FSQM_PRIO_A1X_PICTRL_OFFSET 4
+/** Priority number for CPU
+    This register holds the priority information for the CPU. 0 means highest priority, 7 lowest. */
+#define FSQM_PRIO_A1X_PCPU_MASK 0x00000007
+/** field offset */
+#define FSQM_PRIO_A1X_PCPU_OFFSET 0
+
+/* Fields of "IO-Buffer Control Register for Read (ALLOC)" */
+/** Enable/disable specific IO-Buffer(s)
+    This register enables the different IO-buffers. Bit 0 ... CPU, bits 1-5 ... ICTRLx, bits 6-8 ... PCTRL, 9-13 ... OCTRLx, 14 ... IQM. */
+#define FSQM_IO_BUF_RD_BUF_EN_MASK 0x00007FFF
+/** field offset */
+#define FSQM_IO_BUF_RD_BUF_EN_OFFSET 0
+
+/* Fields of "IO-Buffer Control Register for Write (FREE)" */
+/** Enable/disable specific IO-Buffer(s)
+    This register enables the different IO-buffers. Bit 0 ... CPU, bits 1-5 ... ICTRLx, bits 6-8 ... PCTRL, 9-13 ... OCTRLx, 14 ... IQM. */
+#define FSQM_IO_BUF_WR_BUF_EN_MASK 0x00007FFF
+/** field offset */
+#define FSQM_IO_BUF_WR_BUF_EN_OFFSET 0
+
+/* Fields of "IRN Capture Register" */
+/** Alloc Command NIL Response
+    Indicates all cases where an Alloc Command issued towards an enabled port returned a NIL reponse.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_ALLNIL 0x01000000
+/* Nothing
+#define FSQM_IRNCR_ALLNIL_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_ALLNIL_INTACK 0x01000000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_ALLNIL_INTOCC 0x01000000
+/** OFSC Underflow
+    Indicates that the OFSC value was one when the OFSQ Alloc command was permitted.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_OFSCUFL_A1X 0x00400000
+/* Nothing
+#define FSQM_IRNCR_OFSCUFL_A1X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_OFSCUFL_A1X_INTACK 0x00400000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_OFSCUFL_A1X_INTOCC 0x00400000
+/** IFSC Underflow
+    Indicates that the IFSC value was one when the IFSQ Alloc command was permitted.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_IFSCUFL_A1X 0x00200000
+/* Nothing
+#define FSQM_IRNCR_IFSCUFL_A1X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_IFSCUFL_A1X_INTACK 0x00200000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_IFSCUFL_A1X_INTOCC 0x00200000
+/** Free Command Underflow on OFSQ
+    Indicates that at the OFSQ a Free command with length 0 was issued.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_FRUVLO_A1X 0x00100000
+/* Nothing
+#define FSQM_IRNCR_FRUVLO_A1X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_FRUVLO_A1X_INTACK 0x00100000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_FRUVLO_A1X_INTOCC 0x00100000
+/** Free Command Underflow on IFSQ
+    Indicates that at the IFSQ a Free command with length 0 was issued.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_FRUVLI_A1X 0x00080000
+/* Nothing
+#define FSQM_IRNCR_FRUVLI_A1X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_FRUVLI_A1X_INTACK 0x00080000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_FRUVLI_A1X_INTOCC 0x00080000
+/** Free Command Overflow on OFSQ
+    Indicates that the OFSC exceeds the maximum possible value.The maximum possible value is equal to MAXLSA - MINLSA.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_FROVLO_A1X 0x00040000
+#define FSQM_IRNCR_FROVLO_A2X 0x00100000
+/* Nothing
+#define FSQM_IRNCR_FROVLO_A1X_NULL 0x00000000
+#define FSQM_IRNCR_FROVLO_A2X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_FROVLO_A1X_INTACK 0x00040000
+#define FSQM_IRNCR_FROVLO_A2X_INTACK 0x00100000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_FROVLO_A1X_INTOCC 0x00040000
+#define FSQM_IRNCR_FROVLO_A2X_INTOCC 0x00100000
+
+/** Free Command Overflow on IFSQ
+    Indicates that the IFSC exceeds the maximum possible value.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_FROVLI_A1X 0x00020000
+/* Nothing
+#define FSQM_IRNCR_FROVLI_A1X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_FROVLI_A1X_INTACK 0x00020000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_FROVLI_A1X_INTOCC 0x00020000
+/** Free Command RAM Access Violation
+    Indicates that a Free Command tried to free segments outside the allowed address range.The allowed address range is [MINLSA...MAXLSA].When CTRL.ALLOC_FRZ is enabled, the allocation is subsequently stopped.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_FRMEM 0x00010000
+/* Nothing
+#define FSQM_IRNCR_FRMEM_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_FRMEM_INTACK 0x00010000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_FRMEM_INTOCC 0x00010000
+/** RAM Access Violation
+    Indicates that a memory access was done either with an address or data outside the allowed address range.The allowed address range is [MINLSA...MAXLSA].The allowed data range is [MINLSA...MAXLSA] + NIL.When CTRL.ALLOC_FRZ is enabled, the allocation is subsequently stopped.This bit contributes to the FSQM_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_ACCMEM 0x00001000
+/* Nothing
+#define FSQM_IRNCR_ACCMEM_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_ACCMEM_INTACK 0x00001000
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_ACCMEM_INTOCC 0x00001000
+/** Input Free Segment Queue Not Empty
+    Indicates that the IFSQ is not empty. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_IFSQNE_A1X 0x00000100
+/* Nothing
+#define FSQM_IRNCR_IFSQNE_A1X_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_IFSQNE_A1X_INTACK 0x00000100
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_IFSQNE_A1X_INTOCC 0x00000100
+/** Threshold 4 Underflow
+    Indicates that the number of entries in the OFSQ is smaller than Free Segment Queue Threshold Register 4. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_T4U 0x00000010
+/* Nothing
+#define FSQM_IRNCR_T4U_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_T4U_INTACK 0x00000010
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_T4U_INTOCC 0x00000010
+/** Threshold 3 Underflow
+    Indicates that the number of entries in the OFSQ is smaller than Free Segment Queue Threshold Register 3. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_T3U 0x00000008
+/* Nothing
+#define FSQM_IRNCR_T3U_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_T3U_INTACK 0x00000008
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_T3U_INTOCC 0x00000008
+/** Threshold 2 Underflow
+    Indicates that the number of entries in the OFSQ is smaller than Free Segment Queue Threshold Register 2. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_T2U 0x00000004
+/* Nothing
+#define FSQM_IRNCR_T2U_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_T2U_INTACK 0x00000004
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_T2U_INTOCC 0x00000004
+/** Threshold 1 Underflow
+    Indicates that the number of entries in the OFSQ is smaller than Free Segment Queue Threshold Register 1. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_T1U 0x00000002
+/* Nothing
+#define FSQM_IRNCR_T1U_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_T1U_INTACK 0x00000002
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_T1U_INTOCC 0x00000002
+/** Threshold 0 Underflow
+    Indicates that the number of entries in the OFSQ is smaller than Free Segment Queue Threshold Register 0. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define FSQM_IRNCR_T0U 0x00000001
+/* Nothing
+#define FSQM_IRNCR_T0U_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define FSQM_IRNCR_T0U_INTACK 0x00000001
+/** Read: Interrupt occurred. */
+#define FSQM_IRNCR_T0U_INTOCC 0x00000001
+
+/* Fields of "IRN Interrupt Control Register" */
+/** Alloc Command NIL Response
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_ALLNIL 0x01000000
+/** Free Command Overflow on OFSQ
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_FROVLO_A2X 0x00100000
+/** OFSC Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_OFSCUFL_A1X 0x00400000
+/** IFSC Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_IFSCUFL_A1X 0x00200000
+/** Free Command Underflow on OFSQ
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_FRUVLO_A1X 0x00100000
+/** Free Command Underflow on IFSQ
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_FRUVLI_A1X 0x00080000
+/** Free Command Overflow on OFSQ
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_FROVLO_A1X 0x00040000
+/** Free Command Overflow on IFSQ
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_FROVLI_A1X 0x00020000
+/** Free Command RAM Access Violation
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_FRMEM 0x00010000
+/** RAM Access Violation
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_ACCMEM 0x00001000
+/** Input Free Segment Queue Not Empty
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_IFSQNE_A1X 0x00000100
+/** Threshold 4 Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_T4U 0x00000010
+/** Threshold 3 Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_T3U 0x00000008
+/** Threshold 2 Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_T2U 0x00000004
+/** Threshold 1 Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_T1U 0x00000002
+/** Threshold 0 Underflow
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNICR_T0U 0x00000001
+
+/* Fields of "IRN Interrupt Enable Register" */
+/** Alloc Command NIL Response
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_ALLNIL 0x01000000
+/* Disable
+#define FSQM_IRNEN_ALLNIL_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_ALLNIL_EN 0x01000000
+/** OFSC Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_OFSCUFL_A1X 0x00400000
+/* Disable
+#define FSQM_IRNEN_OFSCUFL_A1X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_OFSCUFL_A1X_EN 0x00400000
+/** IFSC Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_IFSCUFL_A1X 0x00200000
+/* Disable
+#define FSQM_IRNEN_IFSCUFL_A1X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_IFSCUFL_A1X_EN 0x00200000
+/** Free Command Underflow on OFSQ
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_FRUVLO_A1X 0x00100000
+/* Disable
+#define FSQM_IRNEN_FRUVLO_A1X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_FRUVLO_A1X_EN 0x00100000
+/** Free Command Underflow on IFSQ
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_FRUVLI_A1X 0x00080000
+/* Disable
+#define FSQM_IRNEN_FRUVLI_A1X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_FRUVLI_A1X_EN 0x00080000
+/** Free Command Overflow on OFSQ
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_FROVLO_A1X 0x00040000
+#define FSQM_IRNEN_FROVLO_A2X 0x00100000
+/* Disable
+#define FSQM_IRNEN_FROVLO_A1X_DIS 0x00000000
+#define FSQM_IRNEN_FROVLO_A2X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_FROVLO_A1X_EN 0x00040000
+#define FSQM_IRNEN_FROVLO_A2X_EN 0x00100000
+/** Free Command Overflow on IFSQ
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_FROVLI_A1X 0x00020000
+/* Disable
+#define FSQM_IRNEN_FROVLI_A1X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_FROVLI_A1X_EN 0x00020000
+/** Free Command RAM Access Violation
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_FRMEM 0x00010000
+/* Disable
+#define FSQM_IRNEN_FRMEM_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_FRMEM_EN 0x00010000
+/** RAM Access Violation
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_ACCMEM 0x00001000
+/* Disable
+#define FSQM_IRNEN_ACCMEM_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_ACCMEM_EN 0x00001000
+/** Input Free Segment Queue Not Empty
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_IFSQNE_A1X 0x00000100
+/* Disable
+#define FSQM_IRNEN_IFSQNE_A1X_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_IFSQNE_A1X_EN 0x00000100
+/** Threshold 4 Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_T4U 0x00000010
+/* Disable
+#define FSQM_IRNEN_T4U_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_T4U_EN 0x00000010
+/** Threshold 3 Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_T3U 0x00000008
+/* Disable
+#define FSQM_IRNEN_T3U_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_T3U_EN 0x00000008
+/** Threshold 2 Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_T2U 0x00000004
+/* Disable
+#define FSQM_IRNEN_T2U_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_T2U_EN 0x00000004
+/** Threshold 1 Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_T1U 0x00000002
+/* Disable
+#define FSQM_IRNEN_T1U_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_T1U_EN 0x00000002
+/** Threshold 0 Underflow
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define FSQM_IRNEN_T0U 0x00000001
+/* Disable
+#define FSQM_IRNEN_T0U_DIS 0x00000000 */
+/** Enable */
+#define FSQM_IRNEN_T0U_EN 0x00000001
+
+/* Fields of "Input Free Segment Queue Register" */
+/** Tail Logical Segment Address
+    Points to the tail of the Free Segment Queue. */
+#define FSQM_IFSQ_A1X_TAIL_MASK 0x7FFF0000
+/** field offset */
+#define FSQM_IFSQ_A1X_TAIL_OFFSET 16
+/** Head Logical Segment Address
+    Points to the head of the Free Segment Queue. */
+#define FSQM_IFSQ_A1X_HEAD_MASK 0x00007FFF
+/** field offset */
+#define FSQM_IFSQ_A1X_HEAD_OFFSET 0
+
+/* Fields of "TAIL LSA Capture Register" */
+/** Logical Segment Address of captured OFSQ TAIL
+    In case of a memory address violation (FRMEM, ACCMEM), this field holds the OFSQ TAIL captured at that time */
+#define FSQM_TAILCAPR_TAIL_FRZ_MASK 0x00007FFF
+/** field offset */
+#define FSQM_TAILCAPR_TAIL_FRZ_OFFSET 0
+
+/* Fields of "Output Free Segment Queue Register" */
+/** Tail Logical Segment Address
+    Points to the tail of the Free Segment Queue. */
+#define FSQM_OFSQ_TAIL_MASK 0x7FFF0000
+/** field offset */
+#define FSQM_OFSQ_TAIL_OFFSET 16
+/** Head Logical Segment Address
+    Points to the head of the Free Segment Queue. */
+#define FSQM_OFSQ_HEAD_MASK 0x00007FFF
+/** field offset */
+#define FSQM_OFSQ_HEAD_OFFSET 0
+
+/* Fields of "Input Free Segment Counter Register" */
+/** Free Segment Counter
+    Holds the number of entries in the Free Segment Queue. */
+#define FSQM_IFSC_A1X_FSC_MASK 0x00007FFF
+/** field offset */
+#define FSQM_IFSC_A1X_FSC_OFFSET 0
+
+/* Fields of "Output Free Segment Counter Register" */
+/** Free Segment Counter
+    Holds the number of entries in the Free Segment Queue. */
+#define FSQM_OFSC_FSC_MASK 0x00007FFF
+/** field offset */
+#define FSQM_OFSC_FSC_OFFSET 0
+
+/* Fields of "Free Segment Queue Threshold Register 0" */
+/** Free Segment Queue Threshold 0
+    When OFSC falls below this threshold, the pause_0 signal is asserted. When OFSC falls below this threshold, the interrupt T0U is asserted. When OFSC raises above this threshold, the interrupt T0U is deasserted. */
+#define FSQM_FSQT0_FSQT_MASK 0x00007FFF
+/** field offset */
+#define FSQM_FSQT0_FSQT_OFFSET 0
+
+/* Fields of "Free Segment Queue Threshold Register 1" */
+/** Free Segment Queue Threshold 1
+    When OFSC falls below this threshold, the pause_1 signal is asserted. When OFSC falls below this threshold, the interrupt T1U is asserted. When OFSC raises above this threshold, the interrupt T1U is deasserted. */
+#define FSQM_FSQT1_FSQT_MASK 0x00007FFF
+/** field offset */
+#define FSQM_FSQT1_FSQT_OFFSET 0
+
+/* Fields of "Free Segment Queue Threshold Register 2" */
+/** Free Segment Queue Threshold 2
+    When OFSC raises above this threshold, the pause_0 signal is deasserted. When OFSC falls below this threshold, the interrupt T2U is asserted. When OFSC raises above this threshold, the interrupt T2U is deasserted. */
+#define FSQM_FSQT2_FSQT_MASK 0x00007FFF
+/** field offset */
+#define FSQM_FSQT2_FSQT_OFFSET 0
+
+/* Fields of "Free Segment Queue Threshold Register 3" */
+/** Free Segment Queue Threshold 3
+    When OFSC raises above this threshold, the pause_1 signal is deasserted. When OFSC falls below this threshold, the interrupt T3U is asserted.When OFSC raises above this threshold, the interrupt T3U is deasserted. */
+#define FSQM_FSQT3_FSQT_MASK 0x00007FFF
+/** field offset */
+#define FSQM_FSQT3_FSQT_OFFSET 0
+
+/* Fields of "Free Segment Queue Threshold Register 4" */
+/** Free Segment Queue Threshold 4
+    When OFSC falls below this threshold, the interrupt T4U is asserted. When OFSC raises above this threshold, the interrupt T4U is deasserted. */
+#define FSQM_FSQT4_FSQT_MASK 0x00007FFF
+/** field offset */
+#define FSQM_FSQT4_FSQT_OFFSET 0
+
+/* Fields of "Logical Segment Address Range" */
+/** Maximum Logical Segment Address
+    Used for range checks. Whenever a LSA returned via FREE is larger than MAXLSA an interrupt is raised */
+#define FSQM_LSARNG_MAXLSA_MASK 0x7FFF0000
+/** field offset */
+#define FSQM_LSARNG_MAXLSA_OFFSET 16
+/** Minimum Logical Segment Address
+    Used for range checks. Whenever a LSA returned via FREE is smaller than MINLSA an interrupt is raised */
+#define FSQM_LSARNG_MINLSA_MASK 0x00007FFF
+/** field offset */
+#define FSQM_LSARNG_MINLSA_OFFSET 0
+
+/* Fields of "Requestrate Limitation Register 0" */
+/** Request rate limitation for master 03
+    The request from master 03 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR0_RLIM03_MASK 0x3F000000
+/** field offset */
+#define FSQM_RLIMR0_RLIM03_OFFSET 24
+/** Request rate limitation for master 02
+    The request from master 02 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR0_RLIM02_MASK 0x003F0000
+/** field offset */
+#define FSQM_RLIMR0_RLIM02_OFFSET 16
+/** Request rate limitation for master 01
+    The request from master 01 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR0_RLIM01_MASK 0x00003F00
+/** field offset */
+#define FSQM_RLIMR0_RLIM01_OFFSET 8
+/** Request rate limitation for master 00
+    The request from master 00 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR0_RLIM00_MASK 0x0000003F
+/** field offset */
+#define FSQM_RLIMR0_RLIM00_OFFSET 0
+
+/* Fields of "Requestrate Limitation Register 1" */
+/** Request rate limitation for master 07
+    The request from master 07 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR1_RLIM07_MASK 0x3F000000
+/** field offset */
+#define FSQM_RLIMR1_RLIM07_OFFSET 24
+/** Request rate limitation for master 06
+    The request from master 06 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR1_RLIM06_MASK 0x003F0000
+/** field offset */
+#define FSQM_RLIMR1_RLIM06_OFFSET 16
+/** Request rate limitation for master 05
+    The request from master 05 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR1_RLIM05_MASK 0x00003F00
+/** field offset */
+#define FSQM_RLIMR1_RLIM05_OFFSET 8
+/** Request rate limitation for master 04
+    The request from master 04 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR1_RLIM04_MASK 0x0000003F
+/** field offset */
+#define FSQM_RLIMR1_RLIM04_OFFSET 0
+
+/* Fields of "Requestrate Limitation Register 2" */
+/** Request rate limitation for master 11
+    The request from master 11 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR2_RLIM11_MASK 0x3F000000
+/** field offset */
+#define FSQM_RLIMR2_RLIM11_OFFSET 24
+/** Request rate limitation for master 10
+    The request from master 10 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR2_RLIM10_MASK 0x003F0000
+/** field offset */
+#define FSQM_RLIMR2_RLIM10_OFFSET 16
+/** Request rate limitation for master 09
+    The request from master 09 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR2_RLIM09_MASK 0x00003F00
+/** field offset */
+#define FSQM_RLIMR2_RLIM09_OFFSET 8
+/** Request rate limitation for master 08
+    The request from master 08 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR2_RLIM08_MASK 0x0000003F
+/** field offset */
+#define FSQM_RLIMR2_RLIM08_OFFSET 0
+
+/* Fields of "Requestrate Limitation Register 3" */
+/** Request rate limitation for master 14
+    The request from master 14 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR3_RLIM14_MASK 0x003F0000
+/** field offset */
+#define FSQM_RLIMR3_RLIM14_OFFSET 16
+/** Request rate limitation for master 13
+    The request from master 13 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR3_RLIM13_MASK 0x00003F00
+/** field offset */
+#define FSQM_RLIMR3_RLIM13_OFFSET 8
+/** Request rate limitation for master 12
+    The request from master 12 is delayed by the number of clocks specified in this field */
+#define FSQM_RLIMR3_RLIM12_MASK 0x0000003F
+/** field offset */
+#define FSQM_RLIMR3_RLIM12_OFFSET 0
+
+/* Fields of "Input Message Queue Register" */
+/** Tail Logical Segment Address
+    Points to the tail of the Free Segment List to be enqueued into the IFSQ. */
+#define FSQM_IMQ_A1X_TLSA_MASK 0x7FFF0000
+/** field offset */
+#define FSQM_IMQ_A1X_TLSA_OFFSET 16
+/** Head Logical Segment Address
+    Points to the head of the Free Segment List to be enqueued into the IFSQ. */
+#define FSQM_IMQ_A1X_HLSA_MASK 0x00007FFF
+/** field offset */
+#define FSQM_IMQ_A1X_HLSA_OFFSET 0
+
+/* Fields of "Output Message Queue Register" */
+/** Tail Logical Segment Address
+    Points to the tail of the Free Segment List to be enqueued into the OFSQ. */
+#define FSQM_OMQ_TLSA_MASK 0x7FFF0000
+/** field offset */
+#define FSQM_OMQ_TLSA_OFFSET 16
+/** Head Logical Segment Address
+    Points to the head of the Free Segment List to be enqueued into the OFSQ. */
+#define FSQM_OMQ_HLSA_MASK 0x00007FFF
+/** field offset */
+#define FSQM_OMQ_HLSA_OFFSET 0
+
+/* Fields of "Repeat Counter Addresses" */
+/** Repeat Counter Value
+    Contains the Repeat Counter for the corresponding LSA. */
+#define FSQM_RCNT_RCNT_MASK 0x00000007
+/** field offset */
+#define FSQM_RCNT_RCNT_OFFSET 0
+
+/* Fields of "Repeat Counter Inc/Dec Addresses" */
+/** Repeat Counter Value
+    Contains the Repeat Counter for the corresponding LSA. */
+#define FSQM_RCNT_INCDEC_RCNT_OLD_MASK 0x00000007
+/** field offset */
+#define FSQM_RCNT_INCDEC_RCNT_OLD_OFFSET 0
+
+/* Fields of "LLT RAM Addresses" */
+/** Pointer to the next segment
+    Contains the memory pointer to the next LSA. */
+#define FSQM_RAM_SNEXT_MASK 0x00007FFF
+/** field offset */
+#define FSQM_RAM_SNEXT_OFFSET 0
+
+/*! @} */ /* FSQM_REGISTER */
+
+#endif /* _fsqm_reg_h */
diff --git a/drivers/net/falcon/gpearb_reg.h b/drivers/net/falcon/gpearb_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/gpearb_reg.h
@@ -0,0 +1,486 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _gpearb_reg_h
+#define _gpearb_reg_h
+
+/** \addtogroup GPEARB_REGISTER
+   @{
+*/
+/* access macros */
+#define gpearb_r32(reg) reg_r32(&gpearb->reg)
+#define gpearb_w32(val, reg) reg_w32(val, &gpearb->reg)
+#define gpearb_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &gpearb->reg)
+#define gpearb_r32_table(reg, idx) reg_r32_table(gpearb->reg, idx)
+#define gpearb_w32_table(val, reg, idx) reg_w32_table(val, gpearb->reg, idx)
+#define gpearb_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, gpearb->reg, idx)
+#define gpearb_adr_table(reg, idx) adr_table(gpearb->reg, idx)
+
+
+/** GPEARB register structure */
+struct gpon_reg_gpearb
+{
+   /** Counter Period Register
+       The TDM Arbiter is counting continuously from 0 up to the programmed PERIOD value. */
+   unsigned int cntr; /* 0x00000000 */
+   /** Port ID Registers
+       Within the 16 PID Register the bandwidth is assigned to the connected modules. */
+   unsigned int pid[16]; /* 0x00000004 */
+   /** Downstream Counter Control Register
+       Downstream: Arbiter - MEM */
+   unsigned int dscntctrl; /* 0x00000044 */
+   /** Total Downstream Counter
+       The Counter is metering the total number of downstream accesses. */
+   unsigned int dstcnt; /* 0x00000048 */
+   /** Downstream Counter for selected ID
+       The Counter is metering the downstream accesses for DSCNTCTRL.DSCNTID. */
+   unsigned int dscnt; /* 0x0000004C */
+   /** Upstream Counter Control Register
+       Upstream: MEM - Arbiter */
+   unsigned int uscntctrl; /* 0x00000050 */
+   /** Total Upstream Counter
+       The Counter is metering the total number of upstream accesses. */
+   unsigned int ustcnt; /* 0x00000054 */
+   /** Upstream Counter for selected ID
+       The Counter is metering the upstream accesses for USCNTCTRL.USCNTID. */
+   unsigned int uscnt; /* 0x00000058 */
+   /** Reserved */
+   unsigned int res_0[41]; /* 0x0000005C */
+};
+
+
+/* Fields of "Counter Period Register" */
+/** TDM Arbiter Counter Period
+    This is the period for the TDM arbitration. */
+#define GPEARB_CNTR_PERIOD_MASK 0x0000003F
+/** field offset */
+#define GPEARB_CNTR_PERIOD_OFFSET 0
+
+/* Fields of "Port ID Register 0" */
+/** ID for TDM timeslot 3
+    This ID defines the Module which is arbitrated in timeslot 3. */
+#define GPEARB_PID0_ID3_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID0_ID3_OFFSET 24
+/** ID for TDM timeslot 2
+    This ID defines the Module which is arbitrated in timeslot 2. */
+#define GPEARB_PID0_ID2_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID0_ID2_OFFSET 16
+/** ID for TDM timeslot 1
+    This ID defines the Module which is arbitrated in timeslot 1. */
+#define GPEARB_PID0_ID1_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID0_ID1_OFFSET 8
+/** ID for TDM timeslot 0
+    This ID defines the Module which is arbitrated in timeslot 0. */
+#define GPEARB_PID0_ID0_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID0_ID0_OFFSET 0
+
+/* Fields of "Port ID Register 1" */
+/** ID for TDM timeslot 7
+    This ID defines the Module which is arbitrated in timeslot 7. */
+#define GPEARB_PID1_ID7_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID1_ID7_OFFSET 24
+/** ID for TDM timeslot 6
+    This ID defines the Module which is arbitrated in timeslot 6. */
+#define GPEARB_PID1_ID6_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID1_ID6_OFFSET 16
+/** ID for TDM timeslot 5
+    This ID defines the Module which is arbitrated in timeslot 5. */
+#define GPEARB_PID1_ID5_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID1_ID5_OFFSET 8
+/** ID for TDM timeslot 4
+    This ID defines the Module which is arbitrated in timeslot 4. */
+#define GPEARB_PID1_ID4_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID1_ID4_OFFSET 0
+
+/* Fields of "Port ID Register 2" */
+/** ID for TDM timeslot 11
+    This ID defines the Module which is arbitrated in timeslot 11. */
+#define GPEARB_PID2_ID11_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID2_ID11_OFFSET 24
+/** ID for TDM timeslot 10
+    This ID defines the Module which is arbitrated in timeslot 10. */
+#define GPEARB_PID2_ID10_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID2_ID10_OFFSET 16
+/** ID for TDM timeslot 9
+    This ID defines the Module which is arbitrated in timeslot 9. */
+#define GPEARB_PID2_ID9_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID2_ID9_OFFSET 8
+/** ID for TDM timeslot 8
+    This ID defines the Module which is arbitrated in timeslot 8. */
+#define GPEARB_PID2_ID8_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID2_ID8_OFFSET 0
+
+/* Fields of "Port ID Register 3" */
+/** ID for TDM timeslot 15
+    This ID defines the Module which is arbitrated in timeslot 15. */
+#define GPEARB_PID3_ID15_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID3_ID15_OFFSET 24
+/** ID for TDM timeslot 14
+    This ID defines the Module which is arbitrated in timeslot 14. */
+#define GPEARB_PID3_ID14_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID3_ID14_OFFSET 16
+/** ID for TDM timeslot 13
+    This ID defines the Module which is arbitrated in timeslot 13. */
+#define GPEARB_PID3_ID13_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID3_ID13_OFFSET 8
+/** ID for TDM timeslot 12
+    This ID defines the Module which is arbitrated in timeslot 12. */
+#define GPEARB_PID3_ID12_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID3_ID12_OFFSET 0
+
+/* Fields of "Port ID Register 4" */
+/** ID for TDM timeslot 19
+    This ID defines the Module which is arbitrated in timeslot 19. */
+#define GPEARB_PID4_ID19_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID4_ID19_OFFSET 24
+/** ID for TDM timeslot 18
+    This ID defines the Module which is arbitrated in timeslot 18. */
+#define GPEARB_PID4_ID18_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID4_ID18_OFFSET 16
+/** ID for TDM timeslot 17
+    This ID defines the Module which is arbitrated in timeslot 17. */
+#define GPEARB_PID4_ID17_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID4_ID17_OFFSET 8
+/** ID for TDM timeslot 16
+    This ID defines the Module which is arbitrated in timeslot 16. */
+#define GPEARB_PID4_ID16_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID4_ID16_OFFSET 0
+
+/* Fields of "Port ID Register 5" */
+/** ID for TDM timeslot 23
+    This ID defines the Module which is arbitrated in timeslot 23. */
+#define GPEARB_PID5_ID23_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID5_ID23_OFFSET 24
+/** ID for TDM timeslot 22
+    This ID defines the Module which is arbitrated in timeslot 22. */
+#define GPEARB_PID5_ID22_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID5_ID22_OFFSET 16
+/** ID for TDM timeslot 21
+    This ID defines the Module which is arbitrated in timeslot 21. */
+#define GPEARB_PID5_ID21_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID5_ID21_OFFSET 8
+/** ID for TDM timeslot 20
+    This ID defines the Module which is arbitrated in timeslot 20. */
+#define GPEARB_PID5_ID20_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID5_ID20_OFFSET 0
+
+/* Fields of "Port ID Register 6" */
+/** ID for TDM timeslot 27
+    This ID defines the Module which is arbitrated in timeslot 27. */
+#define GPEARB_PID6_ID27_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID6_ID27_OFFSET 24
+/** ID for TDM timeslot 26
+    This ID defines the Module which is arbitrated in timeslot 26. */
+#define GPEARB_PID6_ID26_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID6_ID26_OFFSET 16
+/** ID for TDM timeslot 25
+    This ID defines the Module which is arbitrated in timeslot 25. */
+#define GPEARB_PID6_ID25_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID6_ID25_OFFSET 8
+/** ID for TDM timeslot 24
+    This ID defines the Module which is arbitrated in timeslot 24. */
+#define GPEARB_PID6_ID24_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID6_ID24_OFFSET 0
+
+/* Fields of "Port ID Register 7" */
+/** ID for TDM timeslot 31
+    This ID defines the Module which is arbitrated in timeslot 31. */
+#define GPEARB_PID7_ID31_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID7_ID31_OFFSET 24
+/** ID for TDM timeslot 30
+    This ID defines the Module which is arbitrated in timeslot 30. */
+#define GPEARB_PID7_ID30_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID7_ID30_OFFSET 16
+/** ID for TDM timeslot 29
+    This ID defines the Module which is arbitrated in timeslot 29. */
+#define GPEARB_PID7_ID29_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID7_ID29_OFFSET 8
+/** ID for TDM timeslot 28
+    This ID defines the Module which is arbitrated in timeslot 28. */
+#define GPEARB_PID7_ID28_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID7_ID28_OFFSET 0
+
+/* Fields of "Port ID Register 8" */
+/** ID for TDM timeslot 35
+    This ID defines the Module which is arbitrated in timeslot 35. */
+#define GPEARB_PID8_ID35_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID8_ID35_OFFSET 24
+/** ID for TDM timeslot 34
+    This ID defines the Module which is arbitrated in timeslot 34. */
+#define GPEARB_PID8_ID34_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID8_ID34_OFFSET 16
+/** ID for TDM timeslot 33
+    This ID defines the Module which is arbitrated in timeslot 33. */
+#define GPEARB_PID8_ID33_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID8_ID33_OFFSET 8
+/** ID for TDM timeslot 32
+    This ID defines the Module which is arbitrated in timeslot 32. */
+#define GPEARB_PID8_ID32_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID8_ID32_OFFSET 0
+
+/* Fields of "Port ID Register 9" */
+/** ID for TDM timeslot 39
+    This ID defines the Module which is arbitrated in timeslot 39. */
+#define GPEARB_PID9_ID39_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID9_ID39_OFFSET 24
+/** ID for TDM timeslot 38
+    This ID defines the Module which is arbitrated in timeslot 38. */
+#define GPEARB_PID9_ID38_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID9_ID38_OFFSET 16
+/** ID for TDM timeslot 37
+    This ID defines the Module which is arbitrated in timeslot 37. */
+#define GPEARB_PID9_ID37_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID9_ID37_OFFSET 8
+/** ID for TDM timeslot 36
+    This ID defines the Module which is arbitrated in timeslot 36. */
+#define GPEARB_PID9_ID36_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID9_ID36_OFFSET 0
+
+/* Fields of "Port ID Register 10" */
+/** ID for TDM timeslot 43
+    This ID defines the Module which is arbitrated in timeslot 43. */
+#define GPEARB_PID10_ID43_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID10_ID43_OFFSET 24
+/** ID for TDM timeslot 42
+    This ID defines the Module which is arbitrated in timeslot 42. */
+#define GPEARB_PID10_ID42_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID10_ID42_OFFSET 16
+/** ID for TDM timeslot 41
+    This ID defines the Module which is arbitrated in timeslot 41. */
+#define GPEARB_PID10_ID41_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID10_ID41_OFFSET 8
+/** ID for TDM timeslot 40
+    This ID defines the Module which is arbitrated in timeslot 40. */
+#define GPEARB_PID10_ID40_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID10_ID40_OFFSET 0
+
+/* Fields of "Port ID Register 11" */
+/** ID for TDM timeslot 47
+    This ID defines the Module which is arbitrated in timeslot 47. */
+#define GPEARB_PID11_ID47_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID11_ID47_OFFSET 24
+/** ID for TDM timeslot 46
+    This ID defines the Module which is arbitrated in timeslot 46. */
+#define GPEARB_PID11_ID46_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID11_ID46_OFFSET 16
+/** ID for TDM timeslot 45
+    This ID defines the Module which is arbitrated in timeslot 45. */
+#define GPEARB_PID11_ID45_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID11_ID45_OFFSET 8
+/** ID for TDM timeslot 44
+    This ID defines the Module which is arbitrated in timeslot 44. */
+#define GPEARB_PID11_ID44_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID11_ID44_OFFSET 0
+
+/* Fields of "Port ID Register 12" */
+/** ID for TDM timeslot 51
+    This ID defines the Module which is arbitrated in timeslot 51. */
+#define GPEARB_PID12_ID51_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID12_ID51_OFFSET 24
+/** ID for TDM timeslot 50
+    This ID defines the Module which is arbitrated in timeslot 50. */
+#define GPEARB_PID12_ID50_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID12_ID50_OFFSET 16
+/** ID for TDM timeslot 49
+    This ID defines the Module which is arbitrated in timeslot 49. */
+#define GPEARB_PID12_ID49_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID12_ID49_OFFSET 8
+/** ID for TDM timeslot 48
+    This ID defines the Module which is arbitrated in timeslot 48. */
+#define GPEARB_PID12_ID48_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID12_ID48_OFFSET 0
+
+/* Fields of "Port ID Register 13" */
+/** ID for TDM timeslot 55
+    This ID defines the Module which is arbitrated in timeslot 55. */
+#define GPEARB_PID13_ID55_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID13_ID55_OFFSET 24
+/** ID for TDM timeslot 54
+    This ID defines the Module which is arbitrated in timeslot 54. */
+#define GPEARB_PID13_ID54_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID13_ID54_OFFSET 16
+/** ID for TDM timeslot 53
+    This ID defines the Module which is arbitrated in timeslot 53. */
+#define GPEARB_PID13_ID53_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID13_ID53_OFFSET 8
+/** ID for TDM timeslot 52
+    This ID defines the Module which is arbitrated in timeslot 52. */
+#define GPEARB_PID13_ID52_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID13_ID52_OFFSET 0
+
+/* Fields of "Port ID Register 14" */
+/** ID for TDM timeslot 59
+    This ID defines the Module which is arbitrated in timeslot 59. */
+#define GPEARB_PID14_ID59_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID14_ID59_OFFSET 24
+/** ID for TDM timeslot 58
+    This ID defines the Module which is arbitrated in timeslot 58. */
+#define GPEARB_PID14_ID58_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID14_ID58_OFFSET 16
+/** ID for TDM timeslot 57
+    This ID defines the Module which is arbitrated in timeslot 57. */
+#define GPEARB_PID14_ID57_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID14_ID57_OFFSET 8
+/** ID for TDM timeslot 56
+    This ID defines the Module which is arbitrated in timeslot 56. */
+#define GPEARB_PID14_ID56_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID14_ID56_OFFSET 0
+
+/* Fields of "Port ID Register 15" */
+/** ID for TDM timeslot 63
+    This ID defines the Module which is arbitrated in timeslot 63. */
+#define GPEARB_PID15_ID63_MASK 0x0F000000
+/** field offset */
+#define GPEARB_PID15_ID63_OFFSET 24
+/** ID for TDM timeslot 62
+    This ID defines the Module which is arbitrated in timeslot 62. */
+#define GPEARB_PID15_ID62_MASK 0x000F0000
+/** field offset */
+#define GPEARB_PID15_ID62_OFFSET 16
+/** ID for TDM timeslot 61
+    This ID defines the Module which is arbitrated in timeslot 61. */
+#define GPEARB_PID15_ID61_MASK 0x00000F00
+/** field offset */
+#define GPEARB_PID15_ID61_OFFSET 8
+/** ID for TDM timeslot 60
+    This ID defines the Module which is arbitrated in timeslot 60. */
+#define GPEARB_PID15_ID60_MASK 0x0000000F
+/** field offset */
+#define GPEARB_PID15_ID60_OFFSET 0
+
+/* Fields of "Downstream Counter Control Register" */
+/** ID for DSCNT
+    This ID defines the Module for DSCNT. */
+#define GPEARB_DSCNTCTRL_DSCNTID_MASK 0x000F0000
+/** field offset */
+#define GPEARB_DSCNTCTRL_DSCNTID_OFFSET 16
+/** DSCNT Enable
+    Enable Downstream Counter for DSCNTID. */
+#define GPEARB_DSCNTCTRL_DSCNTEN 0x00000002
+/* Disable
+#define GPEARB_DSCNTCTRL_DSCNTEN_DIS 0x00000000 */
+/** Enable */
+#define GPEARB_DSCNTCTRL_DSCNTEN_EN 0x00000002
+/** DSTCNT Enable
+    Total Downstream Counter enable. */
+#define GPEARB_DSCNTCTRL_DSTCNTEN 0x00000001
+/* Disable
+#define GPEARB_DSCNTCTRL_DSTCNTEN_DIS 0x00000000 */
+/** Enable */
+#define GPEARB_DSCNTCTRL_DSTCNTEN_EN 0x00000001
+
+/* Fields of "Total Downstream Counter" */
+/** Counter Value */
+#define GPEARB_DSTCNT_CNT_MASK 0x0000FFFF
+/** field offset */
+#define GPEARB_DSTCNT_CNT_OFFSET 0
+
+/* Fields of "Downstream Counter for selected ID" */
+/** Counter Value */
+#define GPEARB_DSCNT_CNT_MASK 0x0000FFFF
+/** field offset */
+#define GPEARB_DSCNT_CNT_OFFSET 0
+
+/* Fields of "Upstream Counter Control Register" */
+/** ID for USCNT
+    This ID defines the Module for USCNT. */
+#define GPEARB_USCNTCTRL_USCNTID_MASK 0x000F0000
+/** field offset */
+#define GPEARB_USCNTCTRL_USCNTID_OFFSET 16
+/** USCNT Enable
+    Enable Upstream Counter for USCNTID */
+#define GPEARB_USCNTCTRL_USCNTEN 0x00000002
+/* Disable
+#define GPEARB_USCNTCTRL_USCNTEN_DIS 0x00000000 */
+/** Enable */
+#define GPEARB_USCNTCTRL_USCNTEN_EN 0x00000002
+/** USTCNT Enabel
+    Total Upstream Counter enable. */
+#define GPEARB_USCNTCTRL_USTCNTEN 0x00000001
+/* Disable
+#define GPEARB_USCNTCTRL_USTCNTEN_DIS 0x00000000 */
+/** Enable */
+#define GPEARB_USCNTCTRL_USTCNTEN_EN 0x00000001
+
+/* Fields of "Total Upstream Counter" */
+/** Counter Value */
+#define GPEARB_USTCNT_CNT_MASK 0x0000FFFF
+/** field offset */
+#define GPEARB_USTCNT_CNT_OFFSET 0
+
+/* Fields of "Upstream Counter for selected ID" */
+/** Counter Value */
+#define GPEARB_USCNT_CNT_MASK 0x0000FFFF
+/** field offset */
+#define GPEARB_USCNT_CNT_OFFSET 0
+
+/*! @} */ /* GPEARB_REGISTER */
+
+#endif /* _gpearb_reg_h */
diff --git a/drivers/net/falcon/ictrll_reg.h b/drivers/net/falcon/ictrll_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/ictrll_reg.h
@@ -0,0 +1,478 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _ictrll_reg_h
+#define _ictrll_reg_h
+
+/** \addtogroup ICTRLL_REGISTER
+   @{
+*/
+/* access macros */
+#define ictrll0_r32(reg) reg_r32(&ictrll0->reg)
+#define ictrll0_w32(val, reg) reg_w32(val, &ictrll0->reg)
+#define ictrll0_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &ictrll0->reg)
+#define ictrll0_r32_table(reg, idx) reg_r32_table(ictrll0->reg, idx)
+#define ictrll0_w32_table(val, reg, idx) reg_w32_table(val, ictrll0->reg, idx)
+#define ictrll0_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, ictrll0->reg, idx)
+#define ictrll0_adr_table(reg, idx) adr_table(ictrll0->reg, idx)
+
+#define ictrll1_r32(reg) reg_r32(&ictrll1->reg)
+#define ictrll1_w32(val, reg) reg_w32(val, &ictrll1->reg)
+#define ictrll1_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &ictrll1->reg)
+#define ictrll1_r32_table(reg, idx) reg_r32_table(ictrll1->reg, idx)
+#define ictrll1_w32_table(val, reg, idx) reg_w32_table(val, ictrll1->reg, idx)
+#define ictrll1_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, ictrll1->reg, idx)
+#define ictrll1_adr_table(reg, idx) adr_table(ictrll1->reg, idx)
+
+#define ictrll2_r32(reg) reg_r32(&ictrll2->reg)
+#define ictrll2_w32(val, reg) reg_w32(val, &ictrll2->reg)
+#define ictrll2_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &ictrll2->reg)
+#define ictrll2_r32_table(reg, idx) reg_r32_table(ictrll2->reg, idx)
+#define ictrll2_w32_table(val, reg, idx) reg_w32_table(val, ictrll2->reg, idx)
+#define ictrll2_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, ictrll2->reg, idx)
+#define ictrll2_adr_table(reg, idx) adr_table(ictrll2->reg, idx)
+
+#define ictrll3_r32(reg) reg_r32(&ictrll3->reg)
+#define ictrll3_w32(val, reg) reg_w32(val, &ictrll3->reg)
+#define ictrll3_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &ictrll3->reg)
+#define ictrll3_r32_table(reg, idx) reg_r32_table(ictrll3->reg, idx)
+#define ictrll3_w32_table(val, reg, idx) reg_w32_table(val, ictrll3->reg, idx)
+#define ictrll3_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, ictrll3->reg, idx)
+#define ictrll3_adr_table(reg, idx) adr_table(ictrll3->reg, idx)
+
+
+/** ICTRLL register structure */
+struct gpon_reg_ictrll
+{
+   /** Control Register
+       This register provides the global ICTRLL controls. */
+   unsigned int ctrl; /* 0x00000000 */
+   /** DMAW Configuration Register
+       This register contains necessary configuration elements for the DMAW. */
+   unsigned int dmaw_cfg; /* 0x00000004 */
+   /** Reserved */
+   unsigned int res_0[6]; /* 0x00000008 */
+   /** RAW Mode Destination Address 0
+       This register contains the destination address for RAW mode. */
+   unsigned int rawda0; /* 0x00000020 */
+   /** RAW Mode Destination Address 1
+       This register contains the destination address for RAW mode. */
+   unsigned int rawda1; /* 0x00000024 */
+   /** Reserved */
+   unsigned int res_1[2]; /* 0x00000028 */
+   /** Maximum allowed Size for PDU Type 0
+       This register contains the maximum allowed size for PDU type 0. */
+   unsigned int maxsize0; /* 0x00000030 */
+   /** Reserved */
+   unsigned int res_2[7]; /* 0x00000034 */
+   /** Received Bytes Counter (Low Part)
+       This counter is metering the total number of received bytes. */
+   unsigned int rxbcntl; /* 0x00000050 */
+   /** Received Bytes Counter (High Part)
+       This counter is metering the total number of received bytes. */
+   unsigned int rxbcnth; /* 0x00000054 */
+   /** Oversized PDUs Counter
+       This counter is metering the number of oversized PDUs:- Oversized Frame (IRN*.OVRSIZE) */
+   unsigned int ovrsize; /* 0x00000058 */
+   /** DMAW Error Counter
+       This counter is metering the number of DMAW Errors:- DMAW Out of FIFO Error (IRN*.DMAWOOF)- DMAW Out Of Memory Error (IRN*.DMAWOOM)- DMAW Timeout Error (IRN*.DMAWTMO)Note: Due to the LSA prefetch, the DMAW errors Out of Memory and Timeout can also occur when no Ethernet frame is processed. */
+   unsigned int dmawerr; /* 0x0000005C */
+   /** Reserved */
+   unsigned int res_3[8]; /* 0x00000060 */
+   /** GMAC Error Counter
+       This register contains the number of GMAC errors:- MAC Abort (IRN*.MACABT)- Minimum Size Under-run (IRN*.MINSIZE)- Raw Mode Destination Address Error (IRN*.RAWDAERR) */
+   unsigned int macerr; /* 0x00000080 */
+   /** Packet Discard Counter
+       This counter is metering the total number of PDUs which have been discarded due to:- Oversize Errors- GMAC Errors- DMAW Errors */
+   unsigned int pdc; /* 0x00000084 */
+   /** Reserved */
+   unsigned int res_4[2]; /* 0x00000088 */
+   /** Received Packets Counter
+       This counter is metering the total number of received packets. */
+   unsigned int rxpcnt; /* 0x00000090 */
+   /** Received Packets 64 Counter
+       This counter is metering the number of received packets with 64 bytes. */
+   unsigned int rxp64cnt; /* 0x00000094 */
+   /** Received Packets 65 - 127 Counter
+       This counter is metering the number of received packets with 65 to 127 bytes. */
+   unsigned int rxp65cnt; /* 0x00000098 */
+   /** Received Packets 128 - 255 Counter
+       This counter is metering the number of received packets with 128 to 255 bytes. */
+   unsigned int rxp128cnt; /* 0x0000009C */
+   /** Received Packets 256 - 511 Counter
+       This counter is metering the number of received packets with 256 to 511 bytes. */
+   unsigned int rxp256cnt; /* 0x000000A0 */
+   /** Received Packets 512 - 1023 Counter
+       This counter is metering the number of received packets with 512 to 1023 bytes. */
+   unsigned int rxp512cnt; /* 0x000000A4 */
+   /** Received Packets 1024 - 1518 Counter
+       This counter is metering the number of received packets with 1024 to 1518 bytes. */
+   unsigned int rxp1024cnt; /* 0x000000A8 */
+   /** Received Packets 1519 - MAXSIZE Counter
+       This counter is metering the number of received packets with 1519 to MAXSIZE bytes. */
+   unsigned int rxp1519cnt; /* 0x000000AC */
+   /** Received Packets MINSIZE - 63 Counter
+       This counter is metering number of received packets with 5 to 63 bytes. */
+   unsigned int undsize; /* 0x000000B0 */
+   /** Reserved */
+   unsigned int res_5[19]; /* 0x000000B4 */
+   /** IRN Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncr; /* 0x00000100 */
+   /** IRN Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irnicr; /* 0x00000104 */
+   /** IRN Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irnen; /* 0x00000108 */
+   /** Reserved */
+   unsigned int res_6[61]; /* 0x0000010C */
+};
+
+
+/* Fields of "Control Register" */
+/** Activate Debug Mode of the ICTRL Module
+    This bit enables the Debug Mode of the ICTRL. If this bit is set, ICTRLx will always write out data to the IQM, regardless IQM FIFO is ready or not. */
+#define ICTRLL_CTRL_DBG 0x80000000
+/* Disable
+#define ICTRLL_CTRL_DBG_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_CTRL_DBG_EN 0x80000000
+/** Enable Broadcast Filter for Raw Mode of the ICTRL Module
+    This bit enables the Broadcast Filter for Raw Mode of the ICTRL (all packets with destination address 0xFFFF_FFFF_FFFF are accepted) */
+#define ICTRLL_CTRL_BC 0x00000200
+/* Disable
+#define ICTRLL_CTRL_BC_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_CTRL_BC_EN 0x00000200
+/** Activate Raw Mode of the ICTRL Module
+    This bit enables the Raw Mode of the ICTRL. This mode is only used for Ethernet boot mode. */
+#define ICTRLL_CTRL_RAW 0x00000100
+/* Disable
+#define ICTRLL_CTRL_RAW_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_CTRL_RAW_EN 0x00000100
+/** Activate Core State Machine
+    This bit enables the ICTRL state machine. */
+#define ICTRLL_CTRL_ACT 0x00000001
+/* Disable
+#define ICTRLL_CTRL_ACT_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_CTRL_ACT_EN 0x00000001
+
+/* Fields of "DMAW Configuration Register" */
+/** Synchronous Reset of DMAW */
+#define ICTRLL_DMAW_CFG_SRET 0x80000000
+/* NoReset
+#define ICTRLL_DMAW_CFG_SRET_NoReset 0x00000000 */
+/** Reset */
+#define ICTRLL_DMAW_CFG_SRET_Reset 0x80000000
+/** Alloc Queue Selection
+    FSQM Queue selection for LSA allocation. */
+#define ICTRLL_DMAW_CFG_ALLOCQ 0x00000200
+/* Select Queue 0 (Note: Usage is prohibited!)
+#define ICTRLL_DMAW_CFG_ALLOCQ_Q0 0x00000000 */
+/** Select Queue 1 (Default) */
+#define ICTRLL_DMAW_CFG_ALLOCQ_Q1 0x00000200
+/** Free Queue Selection
+    FSQM Queue selection for LSA freeing. */
+#define ICTRLL_DMAW_CFG_FREEQ 0x00000100
+/* Select Queue 0 (Note: Usage is prohibited!)
+#define ICTRLL_DMAW_CFG_FREEQ_Q0 0x00000000 */
+/** Select Queue 1 (Default) */
+#define ICTRLL_DMAW_CFG_FREEQ_Q1 0x00000100
+/** FSQM LSA Request Limitation
+    This is the number of wait cycles until a LSA request to FSQM issues an error. */
+#define ICTRLL_DMAW_CFG_LSARLMT_MASK 0x000000FF
+/** field offset */
+#define ICTRLL_DMAW_CFG_LSARLMT_OFFSET 0
+
+/* Fields of "RAW Mode Destination Address 0" */
+/** Destination Address Byte 0 */
+#define ICTRLL_RAWDA0_DAB0_MASK 0xFF000000
+/** field offset */
+#define ICTRLL_RAWDA0_DAB0_OFFSET 24
+/** Destination Address Byte 1 */
+#define ICTRLL_RAWDA0_DAB1_MASK 0x00FF0000
+/** field offset */
+#define ICTRLL_RAWDA0_DAB1_OFFSET 16
+/** Destination Address Byte 2 */
+#define ICTRLL_RAWDA0_DAB2_MASK 0x0000FF00
+/** field offset */
+#define ICTRLL_RAWDA0_DAB2_OFFSET 8
+/** Destination Address Byte 3 */
+#define ICTRLL_RAWDA0_DAB3_MASK 0x000000FF
+/** field offset */
+#define ICTRLL_RAWDA0_DAB3_OFFSET 0
+
+/* Fields of "RAW Mode Destination Address 1" */
+/** Destination Address Byte 4 */
+#define ICTRLL_RAWDA1_DAB4_MASK 0xFF000000
+/** field offset */
+#define ICTRLL_RAWDA1_DAB4_OFFSET 24
+/** Destination Address Byte 5 */
+#define ICTRLL_RAWDA1_DAB5_MASK 0x00FF0000
+/** field offset */
+#define ICTRLL_RAWDA1_DAB5_OFFSET 16
+
+/* Fields of "Maximum allowed Size for PDU Type 0" */
+/** Size
+    This register holds the size. */
+#define ICTRLL_MAXSIZE0_SIZE_MASK 0x0000FFFF
+/** field offset */
+#define ICTRLL_MAXSIZE0_SIZE_OFFSET 0
+
+/* Fields of "Received Bytes Counter (Low Part)" */
+/** Counter
+    Counter value (Low Part).Note: First the Low and then the High Part has to be read. */
+#define ICTRLL_RXBCNTL_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXBCNTL_CNT_OFFSET 0
+
+/* Fields of "Received Bytes Counter (High Part)" */
+/** Counter
+    Counter value (High Part).Note: First the Low and then the High Part has to be read. */
+#define ICTRLL_RXBCNTH_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXBCNTH_CNT_OFFSET 0
+
+/* Fields of "Oversized PDUs Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_OVRSIZE_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_OVRSIZE_CNT_OFFSET 0
+
+/* Fields of "DMAW Error Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_DMAWERR_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_DMAWERR_CNT_OFFSET 0
+
+/* Fields of "GMAC Error Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_MACERR_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_MACERR_CNT_OFFSET 0
+
+/* Fields of "Packet Discard Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_PDC_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_PDC_CNT_OFFSET 0
+
+/* Fields of "Received Packets Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXPCNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXPCNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 64 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP64CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP64CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 65 - 127 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP65CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP65CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 128 - 255 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP128CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP128CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 256 - 511 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP256CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP256CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 512 - 1023 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP512CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP512CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 1024 - 1518 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP1024CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP1024CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets 1519 - MAXSIZE Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_RXP1519CNT_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_RXP1519CNT_CNT_OFFSET 0
+
+/* Fields of "Received Packets MINSIZE - 63 Counter" */
+/** Counter
+    This register holds the counter value. */
+#define ICTRLL_UNDSIZE_CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define ICTRLL_UNDSIZE_CNT_OFFSET 0
+
+/* Fields of "IRN Capture Register" */
+/** DMAW Out of FIFO Error
+    Indicates that the IQM fifo was full when trying to enqueue the PDU.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_DMAWOOF 0x04000000
+/* Nothing
+#define ICTRLL_IRNCR_DMAWOOF_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_DMAWOOF_INTACK 0x04000000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_DMAWOOF_INTOCC 0x04000000
+/** DMAW Out Of Memory Error
+    Indicates that the LSA request to FSQM returned NIL.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_DMAWOOM 0x02000000
+/* Nothing
+#define ICTRLL_IRNCR_DMAWOOM_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_DMAWOOM_INTACK 0x02000000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_DMAWOOM_INTOCC 0x02000000
+/** DMAW Timeout Error
+    Indicates that the LSA request to FSQM went into timeout.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_DMAWTMO 0x01000000
+/* Nothing
+#define ICTRLL_IRNCR_DMAWTMO_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_DMAWTMO_INTACK 0x01000000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_DMAWTMO_INTOCC 0x01000000
+/** Minimum Size Under-run
+    Indicates that a PDU has under-run the minimum size of 5 bytes.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_MINSIZE 0x00080000
+/* Nothing
+#define ICTRLL_IRNCR_MINSIZE_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_MINSIZE_INTACK 0x00080000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_MINSIZE_INTOCC 0x00080000
+/** MAC Abort
+    Indicates that the GMAC has aborted the transmission at EOF.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_MACABT 0x00040000
+/* Nothing
+#define ICTRLL_IRNCR_MACABT_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_MACABT_INTACK 0x00040000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_MACABT_INTOCC 0x00040000
+/** Raw Mode Destination Address Error
+    Indicates that in raw mode a wrong destination address has been provided.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_RAWDAERR 0x00020000
+/* Nothing
+#define ICTRLL_IRNCR_RAWDAERR_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_RAWDAERR_INTACK 0x00020000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_RAWDAERR_INTOCC 0x00020000
+/** Oversized Frame
+    Indicates that a frame has been oversized, i.e.LENGTH MAXSIZE && MAXSIZE 0.This bit contributes to the ICTRLL_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define ICTRLL_IRNCR_OVRSIZE 0x00010000
+/* Nothing
+#define ICTRLL_IRNCR_OVRSIZE_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define ICTRLL_IRNCR_OVRSIZE_INTACK 0x00010000
+/** Read: Interrupt occurred. */
+#define ICTRLL_IRNCR_OVRSIZE_INTOCC 0x00010000
+
+/* Fields of "IRN Interrupt Control Register" */
+/** DMAW Out of FIFO Error
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_DMAWOOF 0x04000000
+/** DMAW Out Of Memory Error
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_DMAWOOM 0x02000000
+/** DMAW Timeout Error
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_DMAWTMO 0x01000000
+/** Minimum Size Under-run
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_MINSIZE 0x00080000
+/** MAC Abort
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_MACABT 0x00040000
+/** Raw Mode Destination Address Error
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_RAWDAERR 0x00020000
+/** Oversized Frame
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNICR_OVRSIZE 0x00010000
+
+/* Fields of "IRN Interrupt Enable Register" */
+/** DMAW Out of FIFO Error
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_DMAWOOF 0x04000000
+/* Disable
+#define ICTRLL_IRNEN_DMAWOOF_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_DMAWOOF_EN 0x04000000
+/** DMAW Out Of Memory Error
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_DMAWOOM 0x02000000
+/* Disable
+#define ICTRLL_IRNEN_DMAWOOM_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_DMAWOOM_EN 0x02000000
+/** DMAW Timeout Error
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_DMAWTMO 0x01000000
+/* Disable
+#define ICTRLL_IRNEN_DMAWTMO_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_DMAWTMO_EN 0x01000000
+/** Minimum Size Under-run
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_MINSIZE 0x00080000
+/* Disable
+#define ICTRLL_IRNEN_MINSIZE_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_MINSIZE_EN 0x00080000
+/** MAC Abort
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_MACABT 0x00040000
+/* Disable
+#define ICTRLL_IRNEN_MACABT_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_MACABT_EN 0x00040000
+/** Raw Mode Destination Address Error
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_RAWDAERR 0x00020000
+/* Disable
+#define ICTRLL_IRNEN_RAWDAERR_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_RAWDAERR_EN 0x00020000
+/** Oversized Frame
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define ICTRLL_IRNEN_OVRSIZE 0x00010000
+/* Disable
+#define ICTRLL_IRNEN_OVRSIZE_DIS 0x00000000 */
+/** Enable */
+#define ICTRLL_IRNEN_OVRSIZE_EN 0x00010000
+
+/*! @} */ /* ICTRLL_REGISTER */
+
+#endif /* _ictrll_reg_h */
diff --git a/drivers/net/falcon/iqm_reg.h b/drivers/net/falcon/iqm_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/iqm_reg.h
@@ -0,0 +1,2082 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _iqm_reg_h
+#define _iqm_reg_h
+
+/** \addtogroup IQM_REGISTER
+   @{
+*/
+/* access macros */
+#define iqm_r32(reg) reg_r32(&iqm->reg)
+#define iqm_w32(val, reg) reg_w32(val, &iqm->reg)
+#define iqm_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &iqm->reg)
+#define iqm_r32_table(reg, idx) reg_r32_table(iqm->reg, idx)
+#define iqm_w32_table(val, reg, idx) reg_w32_table(val, iqm->reg, idx)
+#define iqm_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, iqm->reg, idx)
+#define iqm_adr_table(reg, idx) adr_table(iqm->reg, idx)
+
+struct iqm_iqt
+{
+   /** Ingress Queue Table Register 0
+       This register provides access to Queue Configuration Parameters. */
+   unsigned int iqt0; /* 0x00000020 */
+   /** Ingress Queue Table Register 1
+       This register provides access to Queue Status. */
+   unsigned int iqt1; /* 0x00000024 */
+   /** Ingress Queue Table Register 2
+       This register provides access to Queue Status. */
+   unsigned int iqt2; /* 0x00000028 */
+   /** Ingress Queue Table Register 3
+       This register provides access to Queue Status. */
+   unsigned int iqt3; /* 0x0000002C */
+   /** Ingress Queue Table Register 4
+       This register provides access to Queue Status. */
+   unsigned int iqt4; /* 0x00000030 */
+   /** Ingress Queue Table Register 5
+       This register provides the thread mask which assigns the Ingress Queue 0 to different threads. */
+   unsigned int iqt5; /* 0x00000034 */
+   /** Reserved */
+   unsigned int res[2]; /* 0x00000038 */
+};
+
+/** IQM register structure */
+struct gpon_reg_iqm
+{
+   /** Control Register
+       This register provides the global IQM controls. */
+   unsigned int ctrl; /* 0x00000000 */
+   /** Reserved */
+   unsigned int res_0[3]; /* 0x00000004 */
+   /** IRN Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncr; /* 0x00000010 */
+   /** IRN Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irnicr; /* 0x00000014 */
+   /** IRN Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irnen; /* 0x00000018 */
+   /** Reserved */
+   unsigned int res_1; /* 0x0000001C */
+
+   struct iqm_iqt iqt[9];
+
+   /** Free Pointer Counter Register
+       This register provides the free PDU pointer counter. */
+   unsigned int fpcr; /* 0x00000140 */
+   /** Reserved */
+   unsigned int res_11[7]; /* 0x00000144 */
+   /** Global Occupancy Counter Register
+       This register provides the global occupancy counter */
+   unsigned int gocc; /* 0x00000160 */
+   /** Global Occupancy Threshold Register
+       This register provides the global occupancy threshold */
+   unsigned int goth; /* 0x00000164 */
+   /** Global PDU Discard Counter Register
+       This register provides the global occupancy discard counter measured in PDUs */
+   unsigned int gpdc; /* 0x00000168 */
+   /** Time Stamp Register
+       This register provides time stamp to be attached to accepted PDUs */
+   unsigned int ts; /* 0x0000016C */
+   /** WRR Control Register
+       This register controls the scheduler behavior. */
+   unsigned int wrrc; /* 0x00000170 */
+   /** Reserved */
+   unsigned int res_12; /* 0x00000174 */
+   /** WRR QID Register
+       This register provides a mapping from the WRR slots to arbitrary QIDs */
+   unsigned int wrrq[5]; /* 0x00000178 */
+   /** Reserved */
+   unsigned int res_13; /* 0x0000018C */
+   /** Segment Free Register 0
+       Each bit in this register indicates by its position if the coresponding pointer segment address is free (=1) */
+   unsigned int sfree0; /* 0x00000190 */
+   /** Segment Free Register 1
+       Each bit in this register indicates by its position if the corresponding pointer segment address is free (=1) */
+   unsigned int sfree1; /* 0x00000194 */
+   /** Reserved */
+   unsigned int res_14[26]; /* 0x00000198 */
+   /** Dequeue Respond Parameter Register 0
+       This register provides respond parameters for a Dequeue_Request command submitted by the CPU */
+   unsigned int drp0; /* 0x00000200 */
+   /** Dequeue Respond Parameter Register 1
+       This register provides respond parameters for a Dequeue_Request command to be submitted by the CPU */
+   unsigned int drp1; /* 0x00000204 */
+   /** Dequeue Respond Parameter Register 2
+       This register provides respond parameters for a Dequeue_Request command to be submitted by the CPU */
+   unsigned int drp2; /* 0x00000208 */
+   /** Dequeue Respond Parameter Register 3
+       This register provides respond parameters for a Dequeue_Request command to be submitted by the CPU */
+   unsigned int drp3; /* 0x0000020C */
+   /** Dequeue Request Command Register
+       This register activates the command submitted by the CPU to the internal state machines */
+   unsigned int drc; /* 0x00000210 */
+   /** Reserved */
+   unsigned int res_15[16251]; /* 0x00000214 */
+};
+
+
+/* Fields of "Control Register" */
+/** TIMESTAMP PRESCALER
+    This field defines the exponent of a clock divider used before the timestamp counter is incremented */
+#define IQM_CTRL_TSPRESCALE_MASK 0x07000000
+/** field offset */
+#define IQM_CTRL_TSPRESCALE_OFFSET 24
+/** RAW mode of data transfer
+    If this mode is enabled, raw packets can be transferred from the LAN interfaces to the CPU via the IQM CPU dequeue register interface, but no data transfer is possible towards the dispatcher. If the raw mode is disabled, the CPU dequeue interface is also disabled and normal data flow to the dispatcher is possible. The raw mode is used during boot-up. */
+#define IQM_CTRL_RAW 0x00000004
+/* Disable
+#define IQM_CTRL_RAW_DIS 0x00000000 */
+/** Enable */
+#define IQM_CTRL_RAW_EN 0x00000004
+/** Freeze Core State Machine
+    This bit freezes the IQM state machine. */
+#define IQM_CTRL_FRZ 0x00000002
+/* Disable
+#define IQM_CTRL_FRZ_DIS 0x00000000 */
+/** Enable */
+#define IQM_CTRL_FRZ_EN 0x00000002
+/** Activate Core State Machine
+    This bit enables the IQM state machine. */
+#define IQM_CTRL_ACT 0x00000001
+/* Disable
+#define IQM_CTRL_ACT_DIS 0x00000000 */
+/** Enable */
+#define IQM_CTRL_ACT_EN 0x00000001
+
+/* Fields of "IRN Capture Register" */
+/** IQM Queue 8 Back Pressure
+    This bit is set, if the IQM Queue 8 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP8 0x10000000
+/* Nothing
+#define IQM_IRNCR_BP8_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP8_INTOCC 0x10000000
+/** IQM Queue 7 Back Pressure
+    This bit is set, if the IQM Queue 7 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP7 0x08000000
+/* Nothing
+#define IQM_IRNCR_BP7_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP7_INTOCC 0x08000000
+/** IQM Queue 6 Back Pressure
+    This bit is set, if the IQM Queue 6 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP6 0x04000000
+/* Nothing
+#define IQM_IRNCR_BP6_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP6_INTOCC 0x04000000
+/** IQM Queue 5 Back Pressure
+    This bit is set, if the IQM Queue 5 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP5 0x02000000
+/* Nothing
+#define IQM_IRNCR_BP5_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP5_INTOCC 0x02000000
+/** IQM Queue 4 Back Pressure
+    This bit is set, if the IQM Queue 4 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP4 0x01000000
+/* Nothing
+#define IQM_IRNCR_BP4_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP4_INTOCC 0x01000000
+/** IQM Queue 3 Back Pressure
+    This bit is set, if the IQM Queue 3 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP3 0x00800000
+/* Nothing
+#define IQM_IRNCR_BP3_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP3_INTOCC 0x00800000
+/** IQM Queue 2 Back Pressure
+    This bit is set, if the IQM Queue 2 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP2 0x00400000
+/* Nothing
+#define IQM_IRNCR_BP2_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP2_INTOCC 0x00400000
+/** IQM Queue 1 Back Pressure
+    This bit is set, if the IQM Queue 1 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP1 0x00200000
+/* Nothing
+#define IQM_IRNCR_BP1_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP1_INTOCC 0x00200000
+/** IQM Queue 0 Back Pressure
+    This bit is set, if the IQM Queue 0 initiates a back presserue. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_BP0 0x00100000
+/* Nothing
+#define IQM_IRNCR_BP0_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_BP0_INTOCC 0x00100000
+/** IQM Queue 8 Filled
+    This bit is set, if the IQM Queue 8 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF8 0x00010000
+/* Nothing
+#define IQM_IRNCR_QF8_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF8_INTOCC 0x00010000
+/** IQM Queue 7 Filled
+    This bit is set, if the IQM Queue 7 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF7 0x00008000
+/* Nothing
+#define IQM_IRNCR_QF7_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF7_INTOCC 0x00008000
+/** IQM Queue 6 Filled
+    This bit is set, if the IQM Queue 6 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF6 0x00004000
+/* Nothing
+#define IQM_IRNCR_QF6_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF6_INTOCC 0x00004000
+/** IQM Queue 5 Filled
+    This bit is set, if the IQM Queue 5 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF5 0x00002000
+/* Nothing
+#define IQM_IRNCR_QF5_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF5_INTOCC 0x00002000
+/** IQM Queue 4 Filled
+    This bit is set, if the IQM Queue 4 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF4 0x00001000
+/* Nothing
+#define IQM_IRNCR_QF4_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF4_INTOCC 0x00001000
+/** IQM Queue 3 FilledThis bit is set, if the IQM Queue 3 is filled (ready).
+    This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF3 0x00000800
+/* Nothing
+#define IQM_IRNCR_QF3_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF3_INTOCC 0x00000800
+/** IQM Queue 2 FilledThis bit is set, if the IQM Queue 2 is filled (ready).
+    This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF2 0x00000400
+/* Nothing
+#define IQM_IRNCR_QF2_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF2_INTOCC 0x00000400
+/** IQM Queue 1 Filled
+    This bit is set, if the IQM Queue 1 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF1 0x00000200
+/* Nothing
+#define IQM_IRNCR_QF1_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF1_INTOCC 0x00000200
+/** IQM Queue 0 Filled
+    This bit is set, if the IQM Queue 0 is filled (ready). This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_QF0 0x00000100
+/* Nothing
+#define IQM_IRNCR_QF0_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_QF0_INTOCC 0x00000100
+/** IQM Full
+    This bit is set, when the shared IQM buffer is full. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_IF 0x00000010
+/* Nothing
+#define IQM_IRNCR_IF_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_IF_INTOCC 0x00000010
+/** Command Error
+    This bit is set, if any invalid command is received (TBD). This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_CER 0x00000008
+/* Nothing
+#define IQM_IRNCR_CER_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define IQM_IRNCR_CER_INTACK 0x00000008
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_CER_INTOCC 0x00000008
+/** Dequeue Ready
+    This bit is set when there is valid data in the DRP registers. This bit is level-sensitive. This bit contributes to the indirect interrupt. */
+#define IQM_IRNCR_DR 0x00000004
+/* Nothing
+#define IQM_IRNCR_DR_NULL 0x00000000 */
+/** Read: Interrupt occurred. */
+#define IQM_IRNCR_DR_INTOCC 0x00000004
+
+/* Fields of "IRN Interrupt Control Register" */
+/** IQM Queue 8 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP8 0x10000000
+/** IQM Queue 7 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP7 0x08000000
+/** IQM Queue 6 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP6 0x04000000
+/** IQM Queue 5 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP5 0x02000000
+/** IQM Queue 4 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP4 0x01000000
+/** IQM Queue 3 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP3 0x00800000
+/** IQM Queue 2 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP2 0x00400000
+/** IQM Queue 1 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP1 0x00200000
+/** IQM Queue 0 Back Pressure
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_BP0 0x00100000
+/** IQM Queue 8 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF8 0x00010000
+/** IQM Queue 7 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF7 0x00008000
+/** IQM Queue 6 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF6 0x00004000
+/** IQM Queue 5 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF5 0x00002000
+/** IQM Queue 4 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF4 0x00001000
+/** IQM Queue 3 FilledThis bit is set, if the IQM Queue 3 is filled (ready).
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF3 0x00000800
+/** IQM Queue 2 FilledThis bit is set, if the IQM Queue 2 is filled (ready).
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF2 0x00000400
+/** IQM Queue 1 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF1 0x00000200
+/** IQM Queue 0 Filled
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_QF0 0x00000100
+/** IQM Full
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_IF 0x00000010
+/** Command Error
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_CER 0x00000008
+/** Dequeue Ready
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNICR_DR 0x00000004
+
+/* Fields of "IRN Interrupt Enable Register" */
+/** IQM Queue 8 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP8 0x10000000
+/* Disable
+#define IQM_IRNEN_BP8_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP8_EN 0x10000000
+/** IQM Queue 7 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP7 0x08000000
+/* Disable
+#define IQM_IRNEN_BP7_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP7_EN 0x08000000
+/** IQM Queue 6 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP6 0x04000000
+/* Disable
+#define IQM_IRNEN_BP6_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP6_EN 0x04000000
+/** IQM Queue 5 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP5 0x02000000
+/* Disable
+#define IQM_IRNEN_BP5_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP5_EN 0x02000000
+/** IQM Queue 4 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP4 0x01000000
+/* Disable
+#define IQM_IRNEN_BP4_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP4_EN 0x01000000
+/** IQM Queue 3 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP3 0x00800000
+/* Disable
+#define IQM_IRNEN_BP3_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP3_EN 0x00800000
+/** IQM Queue 2 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP2 0x00400000
+/* Disable
+#define IQM_IRNEN_BP2_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP2_EN 0x00400000
+/** IQM Queue 1 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP1 0x00200000
+/* Disable
+#define IQM_IRNEN_BP1_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP1_EN 0x00200000
+/** IQM Queue 0 Back Pressure
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_BP0 0x00100000
+/* Disable
+#define IQM_IRNEN_BP0_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_BP0_EN 0x00100000
+/** IQM Queue 8 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF8 0x00010000
+/* Disable
+#define IQM_IRNEN_QF8_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF8_EN 0x00010000
+/** IQM Queue 7 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF7 0x00008000
+/* Disable
+#define IQM_IRNEN_QF7_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF7_EN 0x00008000
+/** IQM Queue 6 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF6 0x00004000
+/* Disable
+#define IQM_IRNEN_QF6_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF6_EN 0x00004000
+/** IQM Queue 5 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF5 0x00002000
+/* Disable
+#define IQM_IRNEN_QF5_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF5_EN 0x00002000
+/** IQM Queue 4 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF4 0x00001000
+/* Disable
+#define IQM_IRNEN_QF4_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF4_EN 0x00001000
+/** IQM Queue 3 FilledThis bit is set, if the IQM Queue 3 is filled (ready).
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF3 0x00000800
+/* Disable
+#define IQM_IRNEN_QF3_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF3_EN 0x00000800
+/** IQM Queue 2 FilledThis bit is set, if the IQM Queue 2 is filled (ready).
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF2 0x00000400
+/* Disable
+#define IQM_IRNEN_QF2_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF2_EN 0x00000400
+/** IQM Queue 1 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF1 0x00000200
+/* Disable
+#define IQM_IRNEN_QF1_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF1_EN 0x00000200
+/** IQM Queue 0 Filled
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_QF0 0x00000100
+/* Disable
+#define IQM_IRNEN_QF0_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_QF0_EN 0x00000100
+/** IQM Full
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_IF 0x00000010
+/* Disable
+#define IQM_IRNEN_IF_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_IF_EN 0x00000010
+/** Command Error
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_CER 0x00000008
+/* Disable
+#define IQM_IRNEN_CER_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_CER_EN 0x00000008
+/** Dequeue Ready
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define IQM_IRNEN_DR 0x00000004
+/* Disable
+#define IQM_IRNEN_DR_DIS 0x00000000 */
+/** Enable */
+#define IQM_IRNEN_DR_EN 0x00000004
+
+/* Fields of "Ingress Queue 0 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT00_QE 0x80000000
+/* Disable
+#define IQM_IQT00_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT00_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT00_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT00_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT00_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT00_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 0 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT01_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT01_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT01_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT01_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT01_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT01_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT01_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 0 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT02_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT02_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT02_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT02_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT02_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT02_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT02_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT02_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT02_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 0 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT03_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT03_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 0 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT04_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT04_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 0 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 0 to CPU Link 1 */
+#define IQM_IQT05_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 0 to CPU Link 0 */
+#define IQM_IQT05_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 0 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT05_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 0 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT05_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 0 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT05_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 0 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT05_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 0 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT05_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 0 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT05_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 0 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT05_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 0 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT05_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 0 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT05_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 0 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT05_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 0 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT05_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 0 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT05_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 0 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT05_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 0 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT05_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 0 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT05_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 0 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT05_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 0 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT05_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 0 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT05_T00 0x00000001
+
+/* Fields of "Ingress Queue 1 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT10_QE 0x80000000
+/* Disable
+#define IQM_IQT10_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT10_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT10_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT10_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT10_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT10_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 1 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT11_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT11_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT11_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT11_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT11_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT11_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT11_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 1 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT12_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT12_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT12_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT12_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT12_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT12_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT12_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT12_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT12_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 1 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT13_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT13_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 1 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT14_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT14_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 1 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 1 to CPU Link 1 */
+#define IQM_IQT15_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 1 to CPU Link 0 */
+#define IQM_IQT15_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 1 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT15_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 1 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT15_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 1 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT15_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 1 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT15_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 1 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT15_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 1 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT15_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 1 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT15_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 1 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT15_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 1 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT15_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 1 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT15_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 1 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT15_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 1 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT15_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 1 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT15_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 1 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT15_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 1 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT15_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 1 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT15_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 1 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT15_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 1 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT15_T00 0x00000001
+
+/* Fields of "Ingress Queue 2 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT20_QE 0x80000000
+/* Disable
+#define IQM_IQT20_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT20_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT20_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT20_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT20_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT20_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 2 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT21_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT21_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT21_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT21_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT21_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT21_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT21_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 2 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT22_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT22_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT22_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT22_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT22_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT22_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT22_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT22_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT22_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 2 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT23_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT23_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 2 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT24_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT24_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 2 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 2 to CPU Link 1 */
+#define IQM_IQT25_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 2 to CPU Link 0 */
+#define IQM_IQT25_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 2 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT25_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 2 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT25_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 2 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT25_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 2 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT25_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 2 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT25_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 2 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT25_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 2 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT25_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 2 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT25_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 2 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT25_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 2 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT25_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 2 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT25_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 2 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT25_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 2 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT25_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 2 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT25_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 2 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT25_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 2 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT25_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 2 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT25_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 2 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT25_T00 0x00000001
+
+/* Fields of "Ingress Queue 3 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT30_QE 0x80000000
+/* Disable
+#define IQM_IQT30_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT30_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT30_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT30_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT30_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT30_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 3 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT31_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT31_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT31_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT31_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT31_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT31_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT31_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 3 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT32_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT32_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT32_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT32_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT32_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT32_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT32_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT32_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT32_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 3 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT33_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT33_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 3 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT34_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT34_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 3 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 3 to CPU Link 1 */
+#define IQM_IQT35_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 3 to CPU Link 0 */
+#define IQM_IQT35_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 3 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT35_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 3 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT35_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 3 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT35_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 3 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT35_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 3 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT35_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 3 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT35_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 3 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT35_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 3 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT35_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 3 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT35_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 3 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT35_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 3 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT35_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 3 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT35_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 3 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT35_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 3 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT35_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 3 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT35_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 3 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT35_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 3 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT35_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 3 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT35_T00 0x00000001
+
+/* Fields of "Ingress Queue 4 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT40_QE 0x80000000
+/* Disable
+#define IQM_IQT40_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT40_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT40_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT40_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT40_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT40_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 4 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT41_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT41_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT41_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT41_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT41_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT41_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT41_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 4 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT42_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT42_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT42_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT42_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT42_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT42_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT42_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT42_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT42_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 4 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT43_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT43_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 4 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT44_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT44_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 4 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 4 to CPU Link 1 */
+#define IQM_IQT45_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 4 to CPU Link 0 */
+#define IQM_IQT45_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 4 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT45_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 4 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT45_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 4 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT45_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 4 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT45_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 4 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT45_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 4 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT45_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 4 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT45_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 4 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT45_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 4 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT45_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 4 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT45_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 4 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT45_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 4 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT45_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 4 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT45_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 4 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT45_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 4 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT45_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 4 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT45_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 4 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT45_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 4 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT45_T00 0x00000001
+
+/* Fields of "Ingress Queue 5 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT50_QE 0x80000000
+/* Disable
+#define IQM_IQT50_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT50_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT50_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT50_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT50_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT50_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 5 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT51_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT51_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT51_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT51_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT51_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT51_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT51_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 5 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT52_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT52_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT52_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT52_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT52_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT52_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT52_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT52_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT52_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 5 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT53_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT53_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 5 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT54_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT54_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 5 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 5 to CPU Link 1 */
+#define IQM_IQT55_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 5 to CPU Link 0 */
+#define IQM_IQT55_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 5 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT55_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 5 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT55_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 5 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT55_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 5 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT55_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 5 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT55_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 5 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT55_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 5 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT55_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 5 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT55_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 5 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT55_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 5 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT55_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 5 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT55_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 5 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT55_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 5 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT55_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 5 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT55_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 5 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT55_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 5 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT55_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 5 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT55_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 5 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT55_T00 0x00000001
+
+/* Fields of "Ingress Queue 6 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT60_QE 0x80000000
+/* Disable
+#define IQM_IQT60_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT60_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT60_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT60_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT60_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT60_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 6 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT61_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT61_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT61_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT61_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT61_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT61_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT61_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 6 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT62_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT62_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT62_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT62_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT62_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT62_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT62_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT62_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT62_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 6 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT63_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT63_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 6 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT64_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT64_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 6 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 6 to CPU Link 1 */
+#define IQM_IQT65_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 6 to CPU Link 0 */
+#define IQM_IQT65_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 6 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT65_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 6 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT65_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 6 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT65_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 6 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT65_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 6 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT65_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 6 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT65_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 6 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT65_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 6 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT65_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 6 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT65_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 6 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT65_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 6 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT65_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 6 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT65_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 6 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT65_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 6 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT65_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 6 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT65_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 6 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT65_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 6 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT65_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 6 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT65_T00 0x00000001
+
+/* Fields of "Ingress Queue 7 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT70_QE 0x80000000
+/* Disable
+#define IQM_IQT70_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT70_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT70_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT70_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT70_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT70_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 7 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT71_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT71_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT71_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT71_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT71_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT71_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT71_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 7 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT72_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT72_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT72_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT72_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT72_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT72_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT72_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT72_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT72_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 7 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT73_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT73_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 7 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT74_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT74_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 7 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 7 to CPU Link 1 */
+#define IQM_IQT75_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 7 to CPU Link 0 */
+#define IQM_IQT75_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 7 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT75_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 7 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT75_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 7 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT75_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 7 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT75_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 7 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT75_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 7 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT75_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 7 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT75_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 7 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT75_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 7 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT75_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 7 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT75_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 7 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT75_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 7 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT75_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 7 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT75_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 7 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT75_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 7 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT75_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 7 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT75_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 7 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT75_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 7 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT75_T00 0x00000001
+
+/* Fields of "Ingress Queue 8 Table Register 0" */
+/** Queue Enable
+    This bit can be set to enable admission of PDUs into the queue */
+#define IQM_IQT80_QE 0x80000000
+/* Disable
+#define IQM_IQT80_QE_DIS 0x00000000 */
+/** Enable */
+#define IQM_IQT80_QE_EN 0x80000000
+/** Queue Tail Drop Threshold
+    This threshold specifies the queue discard level in units of 8 segments. Above this threshold, arriving PDUs are discarded without further check. Highest functional value is 2304, as queue occupies complete SSB */
+#define IQM_IQT80_QDTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT80_QDTH_OFFSET 16
+/** Queue Reservation Threshold
+    This threshold specifies the minimum queue buffer reservation in units of 8 segments. Below this threshold, arriving PDUs are accepted without consideration in the global shared buffer.It is possible to modify this threshold after activation, but it is not recommended to do so unless the SSB is completely emptied of stored PDUs and the ingress traffic to IQM is blocked */
+#define IQM_IQT80_QRTH_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT80_QRTH_OFFSET 0
+
+/* Fields of "Ingress Queue 8 Table Register 1" */
+/** Queue Blocked
+    This bit set indicates that the queue does not participate in the WRR scheduling */
+#define IQM_IQT81_QB 0x80000000
+/* Queue Not Blocked
+#define IQM_IQT81_QB_NB 0x00000000 */
+/** Queue Blocked */
+#define IQM_IQT81_QB_BL 0x80000000
+/** Queue Backpressure Threshold High
+    This threshold specifies the backpressure assertion level in units of 8 segments. If QOCC raises above this threshold, BP is set to 1, asserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT81_QBTH_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT81_QBTH_OFFSET 16
+/** Queue Backpressure Threshold Low
+    This threshold specifies the backpressure de-assertion level in units of 8 segments. If QOCC falls below this threshold, BP is set to 0, deasserting the backpressure signal IQ_Backpressure. */
+#define IQM_IQT81_QBTL_MASK 0x00000FFF
+/** field offset */
+#define IQM_IQT81_QBTL_OFFSET 0
+
+/* Fields of "Ingress Queue 8 Table Register 2" */
+/** Queue Filled
+    This bit set indicates that the queue contains at least one waiting PDU. Used to drive the Q_filled status signals towards PCTRL. */
+#define IQM_IQT82_QF 0x80000000
+/** Backpressure
+    This bit set indicates asserted backpressure towards the ingress interfaces. */
+#define IQM_IQT82_BP 0x40000000
+/* Backpressure De-asserted
+#define IQM_IQT82_BP_BD 0x00000000 */
+/** Backpressure Asserted */
+#define IQM_IQT82_BP_BA 0x40000000
+/** Queue pointer segment full
+    This bit indicates the queue pointer segment full status. */
+#define IQM_IQT82_QPSF 0x10000000
+/** PDU Occupancy Counter
+    This field gives the queue occupancy in units of PDUs. Initialized to 0. */
+#define IQM_IQT82_POCC_MASK 0x0FFF0000
+/** field offset */
+#define IQM_IQT82_POCC_OFFSET 16
+/** Queue Occupancy Counter
+    This field gives the queue occupancy in units of segments. Initialized to 0. */
+#define IQM_IQT82_QOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_IQT82_QOCC_OFFSET 0
+
+/* Fields of "Ingress Queue 8 Table Register 3" */
+/** Queue PDU Discard Counter
+    Roll over at max */
+#define IQM_IQT83_QDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT83_QDC_OFFSET 0
+
+/* Fields of "Ingress Queue 8 Table Register 4" */
+/** Ingress Queue Ticket Counter
+    This counter is incremented for every PDU that is transmitted from the IQM queue to the dispatcher. It wraps at max. The lower 8 bits of TICK are used as a re-sequencing ticket and transferred to the dispatcher in the PDU meta-data. */
+#define IQM_IQT84_TICK_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_IQT84_TICK_OFFSET 0
+
+/* Fields of "Ingress Queue 8 Table Register 5" */
+/** CPU Link 1
+    Dispatches packet header data from Ingress Queue 8 to CPU Link 1 */
+#define IQM_IQT85_T61 0x00080000
+/** CPU Link 0
+    Dispatches packet header data from Ingress Queue 8 to CPU Link 0 */
+#define IQM_IQT85_T60 0x00040000
+/** Thread 5.2.x
+    Dispatches packet header data from Ingress Queue 8 to PE 5, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT85_T52 0x00020000
+/** Thread 5.1.x
+    Dispatches packet header data from Ingress Queue 8 to PE 5, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT85_T51 0x00010000
+/** Thread 5.0.x
+    Dispatches packet header data from Ingress Queue 8 to PE 5, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT85_T50 0x00008000
+/** Thread 4.2.x
+    Dispatches packet header data from Ingress Queue 8 to PE 4, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT85_T42 0x00004000
+/** Thread 4.1.x
+    Dispatches packet header data from Ingress Queue 8 to PE 4, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT85_T41 0x00002000
+/** Thread 4.0.x
+    Dispatches packet header data from Ingress Queue 8 to PE 4, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT85_T40 0x00001000
+/** Thread 3.2.x
+    Dispatches packet header data from Ingress Queue 8 to PE 3, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT85_T32 0x00000800
+/** Thread 3.1.x
+    Dispatches packet header data from Ingress Queue 8 to PE 3, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT85_T31 0x00000400
+/** Thread 3.0.x
+    Dispatches packet header data from Ingress Queue 8 to PE 3, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT85_T30 0x00000200
+/** Thread 2.2.x
+    Dispatches packet header data from Ingress Queue 8 to PE 2, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT85_T22 0x00000100
+/** Thread 2.1.x
+    Dispatches packet header data from Ingress Queue 8 to PE 2, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT85_T21 0x00000080
+/** Thread 2.0.x
+    Dispatches packet header data from Ingress Queue 8 to PE 2, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT85_T20 0x00000040
+/** Thread 1.2.x
+    Dispatches packet header data from Ingress Queue 8 to PE 1, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT85_T12 0x00000020
+/** Thread 1.1.x
+    Dispatches packet header data from Ingress Queue 8 to PE 1, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT85_T11 0x00000010
+/** Thread 1.0.x
+    Dispatches packet header data from Ingress Queue 8 to PE 1, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT85_T10 0x00000008
+/** Thread 0.2.x
+    Dispatches packet header data from Ingress Queue 8 to PE 0, Virtual Machine 2, Threads 0-3 */
+#define IQM_IQT85_T02 0x00000004
+/** Thread 0.1.x
+    Dispatches packet header data from Ingress Queue 8 to PE 0, Virtual Machine 1, Threads 0-3 */
+#define IQM_IQT85_T01 0x00000002
+/** Thread 0.0.x
+    Dispatches packet header data from Ingress Queue 8 to PE 0, Virtual Machine 0, Threads 0-3 */
+#define IQM_IQT85_T00 0x00000001
+
+/* Fields of "Free Pointer Counter Register" */
+/** Free Pointer Counter
+    This field holds the number of free PDU pointers in the IPPT. */
+#define IQM_FPCR_FPC_MASK 0x00000FFF
+/** field offset */
+#define IQM_FPCR_FPC_OFFSET 0
+
+/* Fields of "Global Occupancy Counter Register" */
+/** Global Occupancy Counter
+    This register defines the global occupancy of the IQM in Segments. */
+#define IQM_GOCC_GOCC_MASK 0x00007FFF
+/** field offset */
+#define IQM_GOCC_GOCC_OFFSET 0
+
+/* Fields of "Global Occupancy Threshold Register" */
+/** Global Occupancy Threshold
+    When GOCC raises above this threshold, PDUs are discarded */
+#define IQM_GOTH_GOTH_MASK 0x00007FFF
+/** field offset */
+#define IQM_GOTH_GOTH_OFFSET 0
+
+/* Fields of "Global PDU Discard Counter Register" */
+/** Global PDU Discard Counter
+    Counts PDUs discarded beacause GOTH is exceeded. */
+#define IQM_GPDC_GPDC_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_GPDC_GPDC_OFFSET 0
+
+/* Fields of "Time Stamp Register" */
+/** Time Stamp
+    Each accepted PDU gets the current value of this register interpreted as a time stamp. */
+#define IQM_TS_TS_MASK 0x00FFFFFF
+/** field offset */
+#define IQM_TS_TS_OFFSET 0
+
+/* Fields of "WRR Control Register" */
+/** Scheduler Period
+    This field defines the scheduler period for the IQM module and thus the number of slots in the WRRQx registers which are used. */
+#define IQM_WRRC_PER_MASK 0x0000003F
+/** field offset */
+#define IQM_WRRC_PER_OFFSET 0
+
+/* Fields of "WRR QID Register 0" */
+/** WRR QID slot 7
+    This field holds the QID to be selected in WRR slot 7 */
+#define IQM_WRRQ0_WRRQ7_MASK 0xF0000000
+/** field offset */
+#define IQM_WRRQ0_WRRQ7_OFFSET 28
+/** WRR QID slot 6
+    This field holds the QID to be selected in WRR slot 6 */
+#define IQM_WRRQ0_WRRQ6_MASK 0x0F000000
+/** field offset */
+#define IQM_WRRQ0_WRRQ6_OFFSET 24
+/** WRR QID slot 5
+    This field holds the QID to be selected in WRR slot 5 */
+#define IQM_WRRQ0_WRRQ5_MASK 0x00F00000
+/** field offset */
+#define IQM_WRRQ0_WRRQ5_OFFSET 20
+/** WRR QID slot 4
+    This field holds the QID to be selected in WRR slot 4 */
+#define IQM_WRRQ0_WRRQ4_MASK 0x000F0000
+/** field offset */
+#define IQM_WRRQ0_WRRQ4_OFFSET 16
+/** WRR QID slot 3
+    This field holds the QID to be selected in WRR slot 3 */
+#define IQM_WRRQ0_WRRQ3_MASK 0x0000F000
+/** field offset */
+#define IQM_WRRQ0_WRRQ3_OFFSET 12
+/** WRR QID slot 2
+    This field holds the QID to be selected in WRR slot 2 */
+#define IQM_WRRQ0_WRRQ2_MASK 0x00000F00
+/** field offset */
+#define IQM_WRRQ0_WRRQ2_OFFSET 8
+/** WRR QID slot 1
+    This field holds the QID to be selected in WRR slot 1 */
+#define IQM_WRRQ0_WRRQ1_MASK 0x000000F0
+/** field offset */
+#define IQM_WRRQ0_WRRQ1_OFFSET 4
+/** WRR QID slot 0
+    This field holds the QID to be selected in WRR slot 0 */
+#define IQM_WRRQ0_WRRQ0_MASK 0x0000000F
+/** field offset */
+#define IQM_WRRQ0_WRRQ0_OFFSET 0
+
+/* Fields of "WRR QID Register 1" */
+/** WRR QID slot 15
+    This field holds the QID to be selected in WRR slot 15 */
+#define IQM_WRRQ1_WRRQ15_MASK 0xF0000000
+/** field offset */
+#define IQM_WRRQ1_WRRQ15_OFFSET 28
+/** WRR QID slot 14
+    This field holds the QID to be selected in WRR slot 14 */
+#define IQM_WRRQ1_WRRQ14_MASK 0x0F000000
+/** field offset */
+#define IQM_WRRQ1_WRRQ14_OFFSET 24
+/** WRR QID slot 13
+    This field holds the QID to be selected in WRR slot 13 */
+#define IQM_WRRQ1_WRRQ13_MASK 0x00F00000
+/** field offset */
+#define IQM_WRRQ1_WRRQ13_OFFSET 20
+/** WRR QID slot 12
+    This field holds the QID to be selected in WRR slot 12 */
+#define IQM_WRRQ1_WRRQ12_MASK 0x000F0000
+/** field offset */
+#define IQM_WRRQ1_WRRQ12_OFFSET 16
+/** WRR QID slot 11
+    This field holds the QID to be selected in WRR slot 11 */
+#define IQM_WRRQ1_WRRQ11_MASK 0x0000F000
+/** field offset */
+#define IQM_WRRQ1_WRRQ11_OFFSET 12
+/** WRR QID slot 10
+    This field holds the QID to be selected in WRR slot 10 */
+#define IQM_WRRQ1_WRRQ10_MASK 0x00000F00
+/** field offset */
+#define IQM_WRRQ1_WRRQ10_OFFSET 8
+/** WRR QID slot 9
+    This field holds the QID to be selected in WRR slot 9 */
+#define IQM_WRRQ1_WRRQ9_MASK 0x000000F0
+/** field offset */
+#define IQM_WRRQ1_WRRQ9_OFFSET 4
+/** WRR QID slot 8
+    This field holds the QID to be selected in WRR slot 8 */
+#define IQM_WRRQ1_WRRQ8_MASK 0x0000000F
+/** field offset */
+#define IQM_WRRQ1_WRRQ8_OFFSET 0
+
+/* Fields of "WRR QID Register 2" */
+/** WRR QID slot 23
+    This field holds the QID to be selected in WRR slot 23 */
+#define IQM_WRRQ2_WRRQ23_MASK 0xF0000000
+/** field offset */
+#define IQM_WRRQ2_WRRQ23_OFFSET 28
+/** WRR QID slot 22
+    This field holds the QID to be selected in WRR slot 22 */
+#define IQM_WRRQ2_WRRQ22_MASK 0x0F000000
+/** field offset */
+#define IQM_WRRQ2_WRRQ22_OFFSET 24
+/** WRR QID slot 21
+    This field holds the QID to be selected in WRR slot 21 */
+#define IQM_WRRQ2_WRRQ21_MASK 0x00F00000
+/** field offset */
+#define IQM_WRRQ2_WRRQ21_OFFSET 20
+/** WRR QID slot 20
+    This field holds the QID to be selected in WRR slot 20 */
+#define IQM_WRRQ2_WRRQ20_MASK 0x000F0000
+/** field offset */
+#define IQM_WRRQ2_WRRQ20_OFFSET 16
+/** WRR QID slot 19
+    This field holds the QID to be selected in WRR slot 19 */
+#define IQM_WRRQ2_WRRQ19_MASK 0x0000F000
+/** field offset */
+#define IQM_WRRQ2_WRRQ19_OFFSET 12
+/** WRR QID slot 18
+    This field holds the QID to be selected in WRR slot 18 */
+#define IQM_WRRQ2_WRRQ18_MASK 0x00000F00
+/** field offset */
+#define IQM_WRRQ2_WRRQ18_OFFSET 8
+/** WRR QID slot 17
+    This field holds the QID to be selected in WRR slot 17 */
+#define IQM_WRRQ2_WRRQ17_MASK 0x000000F0
+/** field offset */
+#define IQM_WRRQ2_WRRQ17_OFFSET 4
+/** WRR QID slot 16
+    This field holds the QID to be selected in WRR slot 16 */
+#define IQM_WRRQ2_WRRQ16_MASK 0x0000000F
+/** field offset */
+#define IQM_WRRQ2_WRRQ16_OFFSET 0
+
+/* Fields of "WRR QID Register 3" */
+/** WRR QID slot 31
+    This field holds the QID to be selected in WRR slot 31 */
+#define IQM_WRRQ3_WRRQ31_MASK 0xF0000000
+/** field offset */
+#define IQM_WRRQ3_WRRQ31_OFFSET 28
+/** WRR QID slot 30
+    This field holds the QID to be selected in WRR slot 30 */
+#define IQM_WRRQ3_WRRQ30_MASK 0x0F000000
+/** field offset */
+#define IQM_WRRQ3_WRRQ30_OFFSET 24
+/** WRR QID slot 29
+    This field holds the QID to be selected in WRR slot 29 */
+#define IQM_WRRQ3_WRRQ29_MASK 0x00F00000
+/** field offset */
+#define IQM_WRRQ3_WRRQ29_OFFSET 20
+/** WRR QID slot 28
+    This field holds the QID to be selected in WRR slot 28 */
+#define IQM_WRRQ3_WRRQ28_MASK 0x000F0000
+/** field offset */
+#define IQM_WRRQ3_WRRQ28_OFFSET 16
+/** WRR QID slot 27
+    This field holds the QID to be selected in WRR slot 27 */
+#define IQM_WRRQ3_WRRQ27_MASK 0x0000F000
+/** field offset */
+#define IQM_WRRQ3_WRRQ27_OFFSET 12
+/** WRR QID slot 26
+    This field holds the QID to be selected in WRR slot 26 */
+#define IQM_WRRQ3_WRRQ26_MASK 0x00000F00
+/** field offset */
+#define IQM_WRRQ3_WRRQ26_OFFSET 8
+/** WRR QID slot 25
+    This field holds the QID to be selected in WRR slot 25 */
+#define IQM_WRRQ3_WRRQ25_MASK 0x000000F0
+/** field offset */
+#define IQM_WRRQ3_WRRQ25_OFFSET 4
+/** WRR QID slot 24
+    This field holds the QID to be selected in WRR slot 24 */
+#define IQM_WRRQ3_WRRQ24_MASK 0x0000000F
+/** field offset */
+#define IQM_WRRQ3_WRRQ24_OFFSET 0
+
+/* Fields of "WRR QID Register 4" */
+/** WRR QID slot 35
+    This field holds the QID to be selected in WRR slot 35 */
+#define IQM_WRRQ4_WRRQ35_MASK 0x0000F000
+/** field offset */
+#define IQM_WRRQ4_WRRQ35_OFFSET 12
+/** WRR QID slot 34
+    This field holds the QID to be selected in WRR slot 34 */
+#define IQM_WRRQ4_WRRQ34_MASK 0x00000F00
+/** field offset */
+#define IQM_WRRQ4_WRRQ34_OFFSET 8
+/** WRR QID slot 33
+    This field holds the QID to be selected in WRR slot 33 */
+#define IQM_WRRQ4_WRRQ33_MASK 0x000000F0
+/** field offset */
+#define IQM_WRRQ4_WRRQ33_OFFSET 4
+/** WRR QID slot 32
+    This field holds the QID to be selected in WRR slot 32 */
+#define IQM_WRRQ4_WRRQ32_MASK 0x0000000F
+/** field offset */
+#define IQM_WRRQ4_WRRQ32_OFFSET 0
+
+/* Fields of "Segment Free Register 0" */
+/** Segment 31 - 00 Free
+    Each bit in this register indicates by its position if the corresponding pointer segment address is free (=1) */
+#define IQM_SFREE0_SF31_00_MASK 0xFFFFFFFF
+/** field offset */
+#define IQM_SFREE0_SF31_00_OFFSET 0
+
+/* Fields of "Segment Free Register 1" */
+/** Segment 47 - 32 Free
+    Each bit in this register indicates by its position if the corresponding pointer segment address is free (=1) */
+#define IQM_SFREE1_SF47_32_MASK 0x0000FFFF
+/** field offset */
+#define IQM_SFREE1_SF47_32_OFFSET 0
+
+/* Fields of "Dequeue Respond Parameter Register 0" */
+/** Time Stamp
+    Each accepted PDU gets the current value of this register interpreted as a time stamp. */
+#define IQM_DRP0_TS_MASK 0x00FFFFFF
+/** field offset */
+#define IQM_DRP0_TS_OFFSET 0
+
+/* Fields of "Dequeue Respond Parameter Register 1" */
+/** Head LSA
+    The logical SSB address of the stored PDU head */
+#define IQM_DRP1_NLSA_MASK 0x7FFF0000
+/** field offset */
+#define IQM_DRP1_NLSA_OFFSET 16
+/** PDU Type
+    The PDU type is provided by SDMAx as a basic HW classification */
+#define IQM_DRP1_PDUT_MASK 0x00007000
+/** field offset */
+#define IQM_DRP1_PDUT_OFFSET 12
+/** Ingress Port Identifier
+    Indentifies the ingress port. The assignment is done in hardware upon dequeue. */
+#define IQM_DRP1_IPN_MASK 0x00000F00
+/** field offset */
+#define IQM_DRP1_IPN_OFFSET 8
+/** Ticket
+    The Ticket is locally assigned from a ticket counter per queue. The assignment is done in hardware upon dequeue. */
+#define IQM_DRP1_TICK_MASK 0x000000FF
+/** field offset */
+#define IQM_DRP1_TICK_OFFSET 0
+
+/* Fields of "Dequeue Respond Parameter Register 2" */
+/** GEM Port Index
+    The GEM Port Index is mapped from the GEM Port Identifier in SDMAG */
+#define IQM_DRP2_GPIX_MASK 0x00FF0000
+/** field offset */
+#define IQM_DRP2_GPIX_OFFSET 16
+/** PDU Length
+    The PDU Length in Bytes */
+#define IQM_DRP2_PLEN_MASK 0x0000FFFF
+/** field offset */
+#define IQM_DRP2_PLEN_OFFSET 0
+
+/* Fields of "Dequeue Respond Parameter Register 3" */
+/** Tail LSA
+    The logical SSB address of the stored PDU tail */
+#define IQM_DRP3_TLSA_MASK 0x7FFF0000
+/** field offset */
+#define IQM_DRP3_TLSA_OFFSET 16
+/** Head LSA
+    The logical SSB address of the stored PDU head */
+#define IQM_DRP3_HLSA_MASK 0x00007FFF
+/** field offset */
+#define IQM_DRP3_HLSA_OFFSET 0
+
+/* Fields of "Dequeue Request Command Register" */
+/** Enable
+    Writing a 1 to ENA triggers the submission of the Enqueue_Request command and the corresponding parameters to the internal state machines */
+#define IQM_DRC_ENA 0x00010000
+/** Queue Identifier
+    Selector for the QID needed for the submission of the Dequeue_Request command and the corresponding parameters to the internal state machines */
+#define IQM_DRC_QID_MASK 0x0000000F
+/** field offset */
+#define IQM_DRC_QID_OFFSET 0
+
+/*! @} */ /* IQM_REGISTER */
+
+#endif /* _iqm_reg_h */
diff --git a/drivers/net/falcon/octrll_reg.h b/drivers/net/falcon/octrll_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/octrll_reg.h
@@ -0,0 +1,455 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _octrll_reg_h
+#define _octrll_reg_h
+
+/** \addtogroup OCTRLL_REGISTER
+   @{
+*/
+/* access macros */
+#define octrll0_r32(reg) reg_r32(&octrll0->reg)
+#define octrll0_w32(val, reg) reg_w32(val, &octrll0->reg)
+#define octrll0_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &octrll0->reg)
+#define octrll0_r32_table(reg, idx) reg_r32_table(octrll0->reg, idx)
+#define octrll0_w32_table(val, reg, idx) reg_w32_table(val, octrll0->reg, idx)
+#define octrll0_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, octrll0->reg, idx)
+#define octrll0_adr_table(reg, idx) adr_table(octrll0->reg, idx)
+
+#define octrll1_r32(reg) reg_r32(&octrll1->reg)
+#define octrll1_w32(val, reg) reg_w32(val, &octrll1->reg)
+#define octrll1_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &octrll1->reg)
+#define octrll1_r32_table(reg, idx) reg_r32_table(octrll1->reg, idx)
+#define octrll1_w32_table(val, reg, idx) reg_w32_table(val, octrll1->reg, idx)
+#define octrll1_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, octrll1->reg, idx)
+#define octrll1_adr_table(reg, idx) adr_table(octrll1->reg, idx)
+
+#define octrll2_r32(reg) reg_r32(&octrll2->reg)
+#define octrll2_w32(val, reg) reg_w32(val, &octrll2->reg)
+#define octrll2_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &octrll2->reg)
+#define octrll2_r32_table(reg, idx) reg_r32_table(octrll2->reg, idx)
+#define octrll2_w32_table(val, reg, idx) reg_w32_table(val, octrll2->reg, idx)
+#define octrll2_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, octrll2->reg, idx)
+#define octrll2_adr_table(reg, idx) adr_table(octrll2->reg, idx)
+
+#define octrll3_r32(reg) reg_r32(&octrll3->reg)
+#define octrll3_w32(val, reg) reg_w32(val, &octrll3->reg)
+#define octrll3_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &octrll3->reg)
+#define octrll3_r32_table(reg, idx) reg_r32_table(octrll3->reg, idx)
+#define octrll3_w32_table(val, reg, idx) reg_w32_table(val, octrll3->reg, idx)
+#define octrll3_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, octrll3->reg, idx)
+#define octrll3_adr_table(reg, idx) adr_table(octrll3->reg, idx)
+
+
+/** OCTRLL register structure */
+struct gpon_reg_octrll
+{
+   /** Control Register */
+   unsigned int ctrl; /* 0x00000000 */
+   /** Configuration Register */
+   unsigned int cfg; /* 0x00000004 */
+   /** Raw Control Register */
+   unsigned int rawctrl; /* 0x00000008 */
+   /** Raw Configuration Register 0
+       Note: Modify only when RAWCTRL.RAWTX is disabled! */
+   unsigned int rawcfg0; /* 0x0000000C */
+   /** Raw Configuration Register 1
+       Note: Modify only when RAWCTRL.RAWTX is disabled! */
+   unsigned int rawcfg1; /* 0x00000010 */
+   /** Timeout Configuration Register
+       This Register holds the Timeout Configuration */
+   unsigned int toutcfg; /* 0x00000014 */
+   /** DMAR Control Register */
+   unsigned int dctrl; /* 0x00000018 */
+   /** Transmitted Bytes Counter (Low Part)
+       This counter is metering the transmitted Bytes for the LAN Interface. First the low and then the high part must be read. */
+   unsigned int txbcntl; /* 0x0000001C */
+   /** Transmitted Bytes Counter (High Part)
+       This counter is metering the transmitted Bytes for the LAN Interface. First the low and then the high part must be read. */
+   unsigned int txbcnth; /* 0x00000020 */
+   /** Transmitted Packets Counter
+       This counter is metering the transmitted Packets for the LAN Interface. */
+   unsigned int txpcnt; /* 0x00000024 */
+   /** Transmitted Packets MINSIZE-64 Counter
+       This counter is metering the transmitted Packets with MINSIZE to 64 Bytes for the LAN Interface. */
+   unsigned int txp64cnt; /* 0x00000028 */
+   /** Transmitted Packets 65-127 Counter
+       This counter is metering the transmitted Packets with 65 to 127 Bytes for the LAN Interface. */
+   unsigned int txp65cnt; /* 0x0000002C */
+   /** Transmitted Packets 128-255 Counter
+       This counter is metering the transmitted Packets with 128 to 255 Bytes for the LAN Interface. */
+   unsigned int txp128cnt; /* 0x00000030 */
+   /** Transmitted Packets 256-511 Counter
+       This counter is metering the transmitted Packets with 256 to 511 Bytes for the LAN Interface. */
+   unsigned int txp256cnt; /* 0x00000034 */
+   /** Transmitted Packets 512-1023 Counter
+       This counter is metering the transmitted Packets with 512 to 1023 Bytes for the LAN Interface. */
+   unsigned int txp512cnt; /* 0x00000038 */
+   /** Transmitted Packets 1024-1518 Counter
+       This counter is metering the transmitted Packets with 1024 to 1518 Bytes for the LAN Interface. */
+   unsigned int txp1024cnt; /* 0x0000003C */
+   /** Transmitted Packets 1519-MAXSIZE Counter
+       This counter is metering the transmitted Packets with 1519 to MAXSIZE Bytes for the LAN Interface. */
+   unsigned int txp1519cnt; /* 0x00000040 */
+   /** DMAR Pointer Register
+       This read only Register mirrors the DMAR.PTR Register and may be used for debugging. */
+   unsigned int dptr; /* 0x00000044 */
+   /** DMAR Context Register
+       This read only Register mirrors the DMAR.CONTEXT Register and may be used for debugging. */
+   unsigned int dcontext; /* 0x00000048 */
+   /** State Register
+       This Register shows the internal state. */
+   unsigned int state; /* 0x0000004C */
+   /** Reserved */
+   unsigned int res_0[12]; /* 0x00000050 */
+   /** IRN Capture Register
+       This register shows the currently active interrupt events masked with the corresponding enable bits of the IRNEN register. The interrupts can be acknowledged by a write operation. */
+   unsigned int irncr; /* 0x00000080 */
+   /** IRN Interrupt Control Register
+       A write operation directly effects the interrupts. This can be used to trigger events under software control for testing purposes. A read operation returns the unmasked interrupt events. */
+   unsigned int irnicr; /* 0x00000084 */
+   /** IRN Interrupt Enable Register
+       This register contains the enable (or mask) bits for the interrupts. Disabled interrupts are not visible in the IRNCR register and are not signalled via the interrupt line towards the controller. */
+   unsigned int irnen; /* 0x00000088 */
+   /** Reserved */
+   unsigned int res_1[29]; /* 0x0000008C */
+};
+
+
+/* Fields of "Control Register" */
+/** Retransmission Enable
+    This bit enables the retransmission mode.The value is stored in a shadow register and assigned to the internal register before the start of a packet.A read returns the shadowed value. */
+#define OCTRLL_CTRL_RTX 0x00000004
+/* Disable
+#define OCTRLL_CTRL_RTX_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_CTRL_RTX_EN 0x00000004
+/** Timeout Enable
+    Note: Modify only when ACT is disabled!If set, the queues attached to this interface will be actively emptied after the programmable period TOUTCFG.TOUTVALUE of inactivity. */
+#define OCTRLL_CTRL_TOUTEN 0x00000002
+/* Disable
+#define OCTRLL_CTRL_TOUTEN_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_CTRL_TOUTEN_EN 0x00000002
+/** Activate Core State Machine
+    This bit enables the OCTRL state machine.When deactivating, the current Ethernet frame is finished and then the OCTRL is on hold.Note 1: All static configuration must be done before activation.Note 2: Deactivation is for debugging only. act - deact - act is prohibited! */
+#define OCTRLL_CTRL_ACT 0x00000001
+/* Disable
+#define OCTRLL_CTRL_ACT_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_CTRL_ACT_EN 0x00000001
+
+/* Fields of "Configuration Register" */
+/** Egress Port Number
+    Note: Modify only when CTRL.ACT is disabled!Assigned EPN0 to 71: Implemented EPN range71: No EPN assigned */
+#define OCTRLL_CFG_EPN_MASK 0x0000007F
+/** field offset */
+#define OCTRLL_CFG_EPN_OFFSET 0
+
+/* Fields of "Raw Control Register" */
+/** Transmit Frame in Raw Mode
+    Note: Modify only when disabled, i.e. previous transmission is finished!Triggers Raw transmission when set by CPU.Acknowledge Raw transmission when reset by OCTRL. */
+#define OCTRLL_RAWCTRL_RAWTX 0x00000001
+/* Disable
+#define OCTRLL_RAWCTRL_RAWTX_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_RAWCTRL_RAWTX_EN 0x00000001
+
+/* Fields of "Raw Configuration Register 0" */
+/** Head LSA
+    Head Logical Segment Address */
+#define OCTRLL_RAWCFG0_HLSA_MASK 0x00007FFF
+/** field offset */
+#define OCTRLL_RAWCFG0_HLSA_OFFSET 0
+
+/* Fields of "Raw Configuration Register 1" */
+/** Header Length
+    Length of the Packet Header */
+#define OCTRLL_RAWCFG1_HDRL_MASK 0xFF000000
+/** field offset */
+#define OCTRLL_RAWCFG1_HDRL_OFFSET 24
+/** Offset
+    Offset into Frame Segment(s) */
+#define OCTRLL_RAWCFG1_OFFS_MASK 0x00FF0000
+/** field offset */
+#define OCTRLL_RAWCFG1_OFFS_OFFSET 16
+/** Body Length
+    Length of the Packet Body w/o FCS */
+#define OCTRLL_RAWCFG1_BDYL_MASK 0x0000FFFF
+/** field offset */
+#define OCTRLL_RAWCFG1_BDYL_OFFSET 0
+
+/* Fields of "Timeout Configuration Register" */
+/** Timeout Value
+    This value determines the time till the packet is dropped.0x0000: no timeout0x0001: approx. 9.15ms0xFFFF: approx. 600sNote: The values are based on 312.5MHz core clock frequency. */
+#define OCTRLL_TOUTCFG_TOUTVALUE_MASK 0x0000FFFF
+/** field offset */
+#define OCTRLL_TOUTCFG_TOUTVALUE_OFFSET 0
+
+/* Fields of "DMAR Control Register" */
+/** Free Queue
+    FSQM Queue selection for LSA freeing. */
+#define OCTRLL_DCTRL_FQ 0x00000001
+/* Select Queue 0 (Note: Usage is prohibited!)
+#define OCTRLL_DCTRL_FQ_Q0 0x00000000 */
+/** Select Queue 1 (Default) */
+#define OCTRLL_DCTRL_FQ_Q1 0x00000001
+
+/* Fields of "Transmitted Bytes Counter (Low Part)" */
+/** Counter Value (Low)
+    Byte Counter Value (Low Part) */
+#define OCTRLL_TXBCNTL_BCNTL_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXBCNTL_BCNTL_OFFSET 0
+
+/* Fields of "Transmitted Bytes Counter (High Part)" */
+/** Counter Value (High)
+    Byte Counter Value (High Part) */
+#define OCTRLL_TXBCNTH_BCNTH_MASK 0x0000FFFF
+/** field offset */
+#define OCTRLL_TXBCNTH_BCNTH_OFFSET 0
+
+/* Fields of "Transmitted Packets Counter" */
+/** Counter Value
+    Packet Counter Value */
+#define OCTRLL_TXPCNT_PCNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXPCNT_PCNT_OFFSET 0
+
+/* Fields of "Transmitted Packets MINSIZE-64 Counter" */
+/** Counter Value
+    Packet MINSIZE-64 Counter Value */
+#define OCTRLL_TXP64CNT_P64CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP64CNT_P64CNT_OFFSET 0
+
+/* Fields of "Transmitted Packets 65-127 Counter" */
+/** Counter Value
+    Packet 65-127 Counter Value */
+#define OCTRLL_TXP65CNT_P65CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP65CNT_P65CNT_OFFSET 0
+
+/* Fields of "Transmitted Packets 128-255 Counter" */
+/** Counter Value
+    Packet 128-255 Counter Value */
+#define OCTRLL_TXP128CNT_P128CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP128CNT_P128CNT_OFFSET 0
+
+/* Fields of "Transmitted Packets 256-511 Counter" */
+/** Counter Value
+    Packet 256-511 Counter Value */
+#define OCTRLL_TXP256CNT_P256CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP256CNT_P256CNT_OFFSET 0
+
+/* Fields of "Transmitted Packets 512-1023 Counter" */
+/** Counter Value
+    Packet 512-1023 Counter Value */
+#define OCTRLL_TXP512CNT_P512CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP512CNT_P512CNT_OFFSET 0
+
+/* Fields of "Transmitted Packets 1024-1518 Counter" */
+/** Counter Value
+    Packet 1024-1518 Counter Value */
+#define OCTRLL_TXP1024CNT_P1024CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP1024CNT_P1024CNT_OFFSET 0
+
+/* Fields of "Transmitted Packets 1519-MAXSIZE Counter" */
+/** Counter Value
+    Packet 1519-MAXSIZE Counter Value */
+#define OCTRLL_TXP1519CNT_P1519CNT_MASK 0xFFFFFFFF
+/** field offset */
+#define OCTRLL_TXP1519CNT_P1519CNT_OFFSET 0
+
+/* Fields of "DMAR Pointer Register" */
+/** Tail LSA
+    Tail Logical Segment Address */
+#define OCTRLL_DPTR_TLSA_MASK 0x7FFF0000
+/** field offset */
+#define OCTRLL_DPTR_TLSA_OFFSET 16
+/** Head LSA */
+#define OCTRLL_DPTR_HLSA_MASK 0x00007FFF
+/** field offset */
+#define OCTRLL_DPTR_HLSA_OFFSET 0
+
+/* Fields of "DMAR Context Register" */
+/** Header Length
+    Length of the Packet Header */
+#define OCTRLL_DCONTEXT_HDRL_MASK 0xFF000000
+/** field offset */
+#define OCTRLL_DCONTEXT_HDRL_OFFSET 24
+/** Offset
+    Offset into Frame Segment(s) */
+#define OCTRLL_DCONTEXT_OFFS_MASK 0x00FF0000
+/** field offset */
+#define OCTRLL_DCONTEXT_OFFS_OFFSET 16
+/** Body Length
+    Length of the Packet Body w/o FCS */
+#define OCTRLL_DCONTEXT_BDYL_MASK 0x0000FFFF
+/** field offset */
+#define OCTRLL_DCONTEXT_BDYL_OFFSET 0
+
+/* Fields of "State Register" */
+/** Retransmission Enable
+    This bit shows the value of the internal retransmission mode enable register. */
+#define OCTRLL_STATE_RTX 0x00080000
+/* Disable
+#define OCTRLL_STATE_RTX_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_STATE_RTX_EN 0x00080000
+/** Egress Port Filled
+    Indicates whether Egress Port is filled or not. */
+#define OCTRLL_STATE_EPFILLED 0x00040000
+/* Not Filled
+#define OCTRLL_STATE_EPFILLED_NFILLED 0x00000000 */
+/** Filled */
+#define OCTRLL_STATE_EPFILLED_FILLED 0x00040000
+/** TX-Data Fifo Full
+    Indicates whether the TX-Data Fifo is full or not. */
+#define OCTRLL_STATE_TXFIFOFULL 0x00020000
+/* FIFO not full: There is free space in the FIFO.
+#define OCTRLL_STATE_TXFIFOFULL_FNFULL 0x00000000 */
+/** FIFO full: There is no space in the FIFO. */
+#define OCTRLL_STATE_TXFIFOFULL_FFULL 0x00020000
+/** DMAR Data Ready
+    Indicates whether DMAR Data is ready or not. */
+#define OCTRLL_STATE_DMARDRDY 0x00010000
+/* Not Ready
+#define OCTRLL_STATE_DMARDRDY_NRDY 0x00000000 */
+/** Ready */
+#define OCTRLL_STATE_DMARDRDY_RDY 0x00010000
+/** Transmission State
+    Current state of data transmission. */
+#define OCTRLL_STATE_TX_MASK 0x00000007
+/** field offset */
+#define OCTRLL_STATE_TX_OFFSET 0
+/** Idle */
+#define OCTRLL_STATE_TX_IDLE 0x00000000
+/** Schedule */
+#define OCTRLL_STATE_TX_SCHEDULE 0x00000001
+/** DMAR open channel */
+#define OCTRLL_STATE_TX_DMAROPEN 0x00000002
+/** DMAR data transmission */
+#define OCTRLL_STATE_TX_DMARTX 0x00000003
+/** DMAR close channel */
+#define OCTRLL_STATE_TX_DMARCLOSE 0x00000004
+/** DMAR delete channel (deallocate segments in SSB) */
+#define OCTRLL_STATE_TX_DMARDELETE 0x00000005
+/** Retransmission acknowledge */
+#define OCTRLL_STATE_TX_RTXACK 0x00000006
+
+/* Fields of "IRN Capture Register" */
+/** PDU Length
+    The PDU Length received from the TMU is zero, i.e. HDRL + BDYL = 0.The schedule response is discarded and the next pending PDU is processed.This bit contributes to the OCTRLL0_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define OCTRLL_IRNCR_PLEN 0x00080000
+/* Nothing
+#define OCTRLL_IRNCR_PLEN_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define OCTRLL_IRNCR_PLEN_INTACK 0x00080000
+/** Read: Interrupt occurred. */
+#define OCTRLL_IRNCR_PLEN_INTOCC 0x00080000
+/** OCTRL NIL LSA
+    OCTRL has received a NIL LSA from TMU.The schedule response is discarded and the next pending PDU is processed.This bit contributes to the OCTRLL0_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define OCTRLL_IRNCR_NIL 0x00040000
+/* Nothing
+#define OCTRLL_IRNCR_NIL_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define OCTRLL_IRNCR_NIL_INTACK 0x00040000
+/** Read: Interrupt occurred. */
+#define OCTRLL_IRNCR_NIL_INTOCC 0x00040000
+/** DMAR NIL LSA
+    DMAR has received a NIL LSA from FSQM, i.e. linked list in FSQM is corrupt.The PDU transmission is immediately stopped, the memory, allocated by the already transmitted bytes, is deallocated and the OCTRL will be disabled, i.e. CTRL.ACT = 0.This bit contributes to the OCTRLL0_ERR interrupt. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define OCTRLL_IRNCR_DNIL 0x00010000
+/* Nothing
+#define OCTRLL_IRNCR_DNIL_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define OCTRLL_IRNCR_DNIL_INTACK 0x00010000
+/** Read: Interrupt occurred. */
+#define OCTRLL_IRNCR_DNIL_INTOCC 0x00010000
+/** Timeout
+    A timeout of the transmission backpressure has occured and the egress queue will be actively emptied. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define OCTRLL_IRNCR_TOUT 0x00000002
+/* Nothing
+#define OCTRLL_IRNCR_TOUT_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define OCTRLL_IRNCR_TOUT_INTACK 0x00000002
+/** Read: Interrupt occurred. */
+#define OCTRLL_IRNCR_TOUT_INTOCC 0x00000002
+/** RAW Transmission Acknowledge
+    The Transmission in RAW mode has been finished. This bit is edge-sensitive. This bit contributes to the indirect interrupt. */
+#define OCTRLL_IRNCR_RAWACK 0x00000001
+/* Nothing
+#define OCTRLL_IRNCR_RAWACK_NULL 0x00000000 */
+/** Write: Acknowledge the interrupt. */
+#define OCTRLL_IRNCR_RAWACK_INTACK 0x00000001
+/** Read: Interrupt occurred. */
+#define OCTRLL_IRNCR_RAWACK_INTOCC 0x00000001
+
+/* Fields of "IRN Interrupt Control Register" */
+/** PDU Length
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNICR_PLEN 0x00080000
+/** OCTRL NIL LSA
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNICR_NIL 0x00040000
+/** DMAR NIL LSA
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNICR_DNIL 0x00010000
+/** Timeout
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNICR_TOUT 0x00000002
+/** RAW Transmission Acknowledge
+    Interrupt control bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNICR_RAWACK 0x00000001
+
+/* Fields of "IRN Interrupt Enable Register" */
+/** PDU Length
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNEN_PLEN 0x00080000
+/* Disable
+#define OCTRLL_IRNEN_PLEN_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_IRNEN_PLEN_EN 0x00080000
+/** OCTRL NIL LSA
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNEN_NIL 0x00040000
+/* Disable
+#define OCTRLL_IRNEN_NIL_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_IRNEN_NIL_EN 0x00040000
+/** DMAR NIL LSA
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNEN_DNIL 0x00010000
+/* Disable
+#define OCTRLL_IRNEN_DNIL_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_IRNEN_DNIL_EN 0x00010000
+/** Timeout
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNEN_TOUT 0x00000002
+/* Disable
+#define OCTRLL_IRNEN_TOUT_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_IRNEN_TOUT_EN 0x00000002
+/** RAW Transmission Acknowledge
+    Interrupt enable bit for the corresponding bit in the IRNCR register. */
+#define OCTRLL_IRNEN_RAWACK 0x00000001
+/* Disable
+#define OCTRLL_IRNEN_RAWACK_DIS 0x00000000 */
+/** Enable */
+#define OCTRLL_IRNEN_RAWACK_EN 0x00000001
+
+/*! @} */ /* OCTRLL_REGISTER */
+
+#endif /* _octrll_reg_h */
diff --git a/drivers/net/falcon/sbs0ctrl_reg.h b/drivers/net/falcon/sbs0ctrl_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/sbs0ctrl_reg.h
@@ -0,0 +1,124 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _sbs0ctrl_reg_h
+#define _sbs0ctrl_reg_h
+
+/** \addtogroup SBS0CTRL_REGISTER
+   @{
+*/
+/* access macros */
+#define sbs0ctrl_r32(reg) reg_r32(&sbs0ctrl->reg)
+#define sbs0ctrl_w32(val, reg) reg_w32(val, &sbs0ctrl->reg)
+#define sbs0ctrl_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &sbs0ctrl->reg)
+#define sbs0ctrl_r32_table(reg, idx) reg_r32_table(sbs0ctrl->reg, idx)
+#define sbs0ctrl_w32_table(val, reg, idx) reg_w32_table(val, sbs0ctrl->reg, idx)
+#define sbs0ctrl_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, sbs0ctrl->reg, idx)
+#define sbs0ctrl_adr_table(reg, idx) adr_table(sbs0ctrl->reg, idx)
+
+
+/** SBS0CTRL register structure */
+struct gpon_reg_sbs0ctrl
+{
+   /** Border Address Register 0
+       The border address defines the first RAM address of master port 1. Master port 0 reaches to this border address - 1. */
+   unsigned int bar0; /* 0x00000000 */
+   /** Reserved */
+   unsigned int res_0; /* 0x00000004 */
+   /** Border Address Register 1
+       The border address defines the first RAM address of master port 2. Master port 1 reaches to this border address - 1. */
+   unsigned int bar1; /* 0x00000008 */
+   /** Reserved */
+   unsigned int res_1; /* 0x0000000C */
+   /** GPHY0 Image Start Address */
+   unsigned int gphy0img; /* 0x00000010 */
+   /** Reserved */
+   unsigned int res_2; /* 0x00000014 */
+   /** GPHY1 Image Start Address */
+   unsigned int gphy1img; /* 0x00000018 */
+   /** Reserved */
+   unsigned int res_3; /* 0x0000001C */
+   /** Control bits for memory access modes */
+   unsigned int mctrl; /* 0x00000020 */
+   /** Reserved */
+   unsigned int res_4[119]; /* 0x00000024 */
+};
+
+
+/* Fields of "Border Address Register 0" */
+/** Border Address 0 Invariant MSBs
+    The invariant MSBs of the Border Address 0. */
+#define SBS0CTRL_BAR0_BA0IH_MASK 0x00380000
+/** field offset */
+#define SBS0CTRL_BAR0_BA0IH_OFFSET 19
+/** Border Address 0 Variable MSBs
+    The variable MSBs of the Border Address 0. Values larger than 8 are limited to 8. */
+#define SBS0CTRL_BAR0_BA0V_MASK 0x00078000
+/** field offset */
+#define SBS0CTRL_BAR0_BA0V_OFFSET 15
+/** Border Address 0 Invariant LSBs
+    The invariant LSBs of the Border Address 0. The width matches the physical size of the RAM. */
+#define SBS0CTRL_BAR0_BA0IL_MASK 0x00007FFF
+/** field offset */
+#define SBS0CTRL_BAR0_BA0IL_OFFSET 0
+
+/* Fields of "Border Address Register 1" */
+/** Border Address 1 Invariant MSBs
+    The invariant MSBs of the Border Address 1. */
+#define SBS0CTRL_BAR1_BA1IH_MASK 0x00380000
+/** field offset */
+#define SBS0CTRL_BAR1_BA1IH_OFFSET 19
+/** Border Address 1 Variable MSBs
+    The variable MSBs of the Border Address 1. Values larger than 8 are limited to 8. */
+#define SBS0CTRL_BAR1_BA1V_MASK 0x00078000
+/** field offset */
+#define SBS0CTRL_BAR1_BA1V_OFFSET 15
+/** Border Address 1 Invariant LSBs
+    The invariant LSBs of the Border Address 1. The width matches the physical size of the RAM. */
+#define SBS0CTRL_BAR1_BA1IL_MASK 0x00007FFF
+/** field offset */
+#define SBS0CTRL_BAR1_BA1IL_OFFSET 0
+
+/* Fields of "GPHY0 Image Start Address" */
+/** GPHY Image Start Address Variable MSBs
+    The image for the GPHY starts at this memory address (variable part). */
+#define SBS0CTRL_GPHY0IMG_ADDRV_MASK 0x003FC000
+/** field offset */
+#define SBS0CTRL_GPHY0IMG_ADDRV_OFFSET 14
+/** GPHY Image Start Address Invariant LSBs
+    The image for the GPHY starts at this memory address (invariant part). */
+#define SBS0CTRL_GPHY0IMG_ADDRI_MASK 0x00003FFF
+/** field offset */
+#define SBS0CTRL_GPHY0IMG_ADDRI_OFFSET 0
+
+/* Fields of "GPHY1 Image Start Address" */
+/** GPHY Image Start Address Variable MSBs
+    The image for the GPHY starts at this memory address (variable part). */
+#define SBS0CTRL_GPHY1IMG_ADDRV_MASK 0x003FC000
+/** field offset */
+#define SBS0CTRL_GPHY1IMG_ADDRV_OFFSET 14
+/** GPHY Image Start Address Invariant LSBs
+    The image for the GPHY starts at this memory address (invariant part). */
+#define SBS0CTRL_GPHY1IMG_ADDRI_MASK 0x00003FFF
+/** field offset */
+#define SBS0CTRL_GPHY1IMG_ADDRI_OFFSET 0
+
+/* Fields of "Control bits for memory access modes" */
+/** Descrambling enable/disable
+    control of address and data descrambling for internal memory test. */
+#define SBS0CTRL_MCTRL_DSC 0x00000001
+/* Disable
+#define SBS0CTRL_MCTRL_DSC_DIS 0x00000000 */
+/** Enable */
+#define SBS0CTRL_MCTRL_DSC_EN 0x00000001
+
+/*! @} */ /* SBS0CTRL_REGISTER */
+
+#endif /* _sbs0ctrl_reg_h */
diff --git a/drivers/net/falcon/sgmii_reg.h b/drivers/net/falcon/sgmii_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/sgmii_reg.h
@@ -0,0 +1,1232 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _sgmii_reg_h
+#define _sgmii_reg_h
+
+/** \addtogroup SGMII_REGISTER
+   @{
+*/
+/* access macros */
+#define sgmii_r32(reg) reg_r32(&sgmii->reg)
+#define sgmii_w32(val, reg) reg_w32(val, &sgmii->reg)
+#define sgmii_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &sgmii->reg)
+#define sgmii_r32_table(reg, idx) reg_r32_table(sgmii->reg, idx)
+#define sgmii_w32_table(val, reg, idx) reg_w32_table(val, sgmii->reg, idx)
+#define sgmii_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, sgmii->reg, idx)
+#define sgmii_adr_table(reg, idx) adr_table(sgmii->reg, idx)
+
+
+/** SGMII register structure */
+struct gpon_reg_sgmii
+{
+   /** GLP_REGFILE: GLP Common Registers */
+   /** BIST Control Register
+       This Register is the BIST's control register. */
+   unsigned int glp_regfile_bist_ctrl; /* 0x00000000 */
+   /** BIST status Register
+       This Register is the BIST's status register. */
+   unsigned int glp_regfile_bist_status; /* 0x00000004 */
+   /** BIST Time Out control Register
+       This Register is the BIST's timeout control register. */
+   unsigned int glp_regfile_bist_timectrl; /* 0x00000008 */
+   /** Phase Lock Count Register
+       This Register is the BIST's phase lock count register. */
+   unsigned int glp_regfile_bist_phlock; /* 0x0000000C */
+   /** Bist Endcount Register
+       This Register is the BIST's word count register. */
+   unsigned int glp_regfile_bist_end; /* 0x00000010 */
+   /** BERT Termination Count Register
+       This Register is the BERT's termination count register. */
+   unsigned int glp_regfile_bert_term; /* 0x00000014 */
+   /** BERT Error Count Register
+       This Register is the BERT's Error count register. */
+   unsigned int glp_regfile_bert_err; /* 0x00000018 */
+   /** BERT Reset Control Register
+       This Register is the BERTs' control register. */
+   unsigned int glp_regfile_bert_rst; /* 0x0000001C */
+   /** BERT Control Register
+       This Register is the BERTs' control register. */
+   unsigned int glp_regfile_bert_ctrl; /* 0x00000020 */
+   /** 3GLP Control Register
+       This register is used for general control in the 3GLP. */
+   unsigned int glp_regfile_glp_ctrl; /* 0x00000024 */
+   /** 3GLP Miscellaneous Register
+       This register is used for miscellaneous control or reading bits. */
+   unsigned int glp_regfile_glp_misc; /* 0x00000028 */
+   /** PMA_REGFILE: PMA Registers */
+   /** Start Up Control Register
+       PMA Start Up Register */
+   unsigned int pma_regfile_startup_ctrl; /* 0x0000002C */
+   /** State Register
+       PMA Start Up State Register */
+   unsigned int pma_regfile_state; /* 0x00000030 */
+   /** PLL_REGFILE: PLL Slice Registers */
+   /** Control 1 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl1; /* 0x00000034 */
+   /** Control 2 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl2; /* 0x00000038 */
+   /** Control 3 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl3; /* 0x0000003C */
+   /** Control 4 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl4; /* 0x00000040 */
+   /** Control 5 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl5; /* 0x00000044 */
+   /** Control 6 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl6; /* 0x00000048 */
+   /** Control 7 Register
+       This Register is for controlling the PMA portion of PLL SLICE behavior. */
+   unsigned int pll_regfile_ctrl7; /* 0x0000004C */
+   /** Analog Control 1 Register
+       This Register is for controlling of analog PLL SLICE behavior. */
+   unsigned int pll_regfile_a_ctrl1; /* 0x00000050 */
+   /** Analog Control 2 Register
+       This Register is for controlling of analog PLL SLICE behavior. */
+   unsigned int pll_regfile_a_ctrl2; /* 0x00000054 */
+   /** Analog Control 3 Register
+       This Register is for controlling of analog PLL SLICE behavior. */
+   unsigned int pll_regfile_a_ctrl3; /* 0x00000058 */
+   /** Analog Control 4 Register
+       This Register is for controlling of analog PLL SLICE behavior. */
+   unsigned int pll_regfile_a_ctrl4; /* 0x0000005C */
+   /** PLL Status Register
+       This Register is for reading PLL status. */
+   unsigned int pll_regfile_status; /* 0x00000060 */
+   /** TX_REGFILE_0: TX Slice Registers */
+   /** Control 1 Register
+       This Register is for controlling of TX SLICE behavior. */
+   unsigned int tx_regfile_0_ctrl1; /* 0x00000064 */
+   /** TX Control 2 Register
+       This Register is for controlling of TX SLICE behavior. */
+   unsigned int tx_regfile_0_ctrl2; /* 0x00000068 */
+   /** Control 3 Register
+       This Register is for controlling of TX SLICE behavior. */
+   unsigned int tx_regfile_0_ctrl3; /* 0x0000006C */
+   /** Analog Control 1 Register
+       This Register is for controlling of analog TX SLICE behavior. */
+   unsigned int tx_regfile_0_a_ctrl1; /* 0x00000070 */
+   /** Analog Control 2 Register
+       This Register is for controlling of analog TX SLICE behavior. */
+   unsigned int tx_regfile_0_a_ctrl2; /* 0x00000074 */
+   /** Modulation Configuration 1 Register
+       This Register is the configuration of the Modulation. */
+   unsigned int tx_regfile_0_mod1; /* 0x00000078 */
+   /** Modulation Configuration 2 Register
+       This Register is the configuration of the Modulation. */
+   unsigned int tx_regfile_0_mod2; /* 0x0000007C */
+   /** Modulation Configuration 3 Register
+       This Register is the configuration of the Modulation. */
+   unsigned int tx_regfile_0_mod3; /* 0x00000080 */
+   /** TX_REGFILE_1: TX Slice Registers */
+   /** Control 1 Register
+       This Register is for controlling of TX SLICE behavior. */
+   unsigned int tx_regfile_1_ctrl1; /* 0x00000084 */
+   /** TX Control 2 Register
+       This Register is for controlling of TX SLICE behavior. */
+   unsigned int tx_regfile_1_ctrl2; /* 0x00000088 */
+   /** Control 3 Register
+       This Register is for controlling of TX SLICE behavior. */
+   unsigned int tx_regfile_1_ctrl3; /* 0x0000008C */
+   /** Analog Control 1 Register
+       This Register is for controlling of analog TX SLICE behavior. */
+   unsigned int tx_regfile_1_a_ctrl1; /* 0x00000090 */
+   /** Analog Control 2 Register
+       This Register is for controlling of analog TX SLICE behavior. */
+   unsigned int tx_regfile_1_a_ctrl2; /* 0x00000094 */
+   /** Modulation Configuration 1 Register
+       This Register is the configuration of the Modulation. */
+   unsigned int tx_regfile_1_mod1; /* 0x00000098 */
+   /** Modulation Configuration 2 Register
+       This Register is the configuration of the Modulation. */
+   unsigned int tx_regfile_1_mod2; /* 0x0000009C */
+   /** Modulation Configuration 3 Register
+       This Register is the configuration of the Modulation. */
+   unsigned int tx_regfile_1_mod3; /* 0x000000A0 */
+   /** RX_REGFILE: RX Slice Registers */
+   /** RX Control 1 Register
+       This Register is for controlling of RX SLICE behavior. */
+   unsigned int rx_regfile_ctrl1; /* 0x000000A4 */
+   /** RX Control 2 Register
+       This Register is for controlling of RX SLICE behavior. */
+   unsigned int rx_regfile_ctrl2; /* 0x000000A8 */
+   /** CDR Configuration Register
+       This Register is for Configuration of CDR CTRL. */
+   unsigned int rx_regfile_cdr; /* 0x000000AC */
+   /** EI Register
+       This Register is for Configuration of EI detect. */
+   unsigned int rx_regfile_ei; /* 0x000000B0 */
+   /** CAL Register
+       This Register is for Configuration of CAL. */
+   unsigned int rx_regfile_cal; /* 0x000000B4 */
+   /** Analog Control Register
+       This Register is for controlling of analog RX SLICE behavior. */
+   unsigned int rx_regfile_a_ctrl; /* 0x000000B8 */
+   /** Test Control Register
+       This Register is for Test control of RX SLICE. */
+   unsigned int rx_regfile_test_ctrl; /* 0x000000BC */
+   /** Reserved */
+   unsigned int rx_regfile_res_0[16]; /* 0x000000C0 */
+};
+
+
+/* Fields of "BIST Control Register" */
+/** Enable Bist
+    Override of BIST enable when OVR_EN is OVR. */
+#define GLP_REGFILE_BIST_CTRL_EN 0x00000400
+/** Disable */
+#define GLP_REGFILE_BIST_CTRL_EN_DIS 0x00000400
+/** Enable Override of Bist Enable
+    Controls override of BIST enable. */
+#define GLP_REGFILE_BIST_CTRL_OVR_EN 0x00000200
+/* No override
+#define GLP_REGFILE_BIST_CTRL_OVR_EN_NO_OVR 0x00000000 */
+/** Override */
+#define GLP_REGFILE_BIST_CTRL_OVR_EN_OVR 0x00000200
+/** RX Enables
+    Enables for RX Lanes for BIST loop. */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_MASK 0x000001E0
+/** field offset */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_OFFSET 5
+/** RX BIST disabled */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_RX_BIST_EN_NONE 0x00000000
+/** Enable RX BIST 1 */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_RX_BIST_EN_1 0x00000020
+/** Enable RX BIST 2 */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_RX_BIST_EN_2 0x00000040
+/** Enable RX BIST 3 */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_RX_BIST_EN_3 0x00000080
+/** Enable RX BIST 4 */
+#define GLP_REGFILE_BIST_CTRL_RX_EN_RX_BIST_EN_4 0x00000100
+/** TX Enables
+    Enables for TX Lanes for BIST loop. */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_MASK 0x0000001E
+/** field offset */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_OFFSET 1
+/** TX BIST disabled */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_TX_BIST_EN_NONE 0x00000000
+/** Enable TX BIST 1 */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_TX_BIST_EN_1 0x00000002
+/** Enable TX BIST 2 */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_TX_BIST_EN_2 0x00000004
+/** Enable TX BIST 3 */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_TX_BIST_EN_3 0x00000008
+/** Enable TX BIST 4 */
+#define GLP_REGFILE_BIST_CTRL_TX_EN_TX_BIST_EN_4 0x00000010
+/** Bypass
+    TX_EN and RX_EN will select the respective slices for BIST when BYPASS is EN. */
+#define GLP_REGFILE_BIST_CTRL_BYPASS 0x00000001
+/* Disable Bypass
+#define GLP_REGFILE_BIST_CTRL_BYPASS_DIS 0x00000000 */
+/** Enable Bypass */
+#define GLP_REGFILE_BIST_CTRL_BYPASS_EN 0x00000001
+
+/* Fields of "BIST status Register" */
+/** Timeout Status
+    Timeout on waiting for PHY ready. */
+#define GLP_REGFILE_BIST_STATUS_TIMEOUT 0x00000040
+/** Loop Fail Status
+    Indicates which BIST loop fails. */
+#define GLP_REGFILE_BIST_STATUS_LOOP_FAIL_MASK 0x0000003C
+/** field offset */
+#define GLP_REGFILE_BIST_STATUS_LOOP_FAIL_OFFSET 2
+/** DONE Status
+    Overall BIST done status. */
+#define GLP_REGFILE_BIST_STATUS_DONE 0x00000002
+/** Fail Status
+    Overall BIST fail status. */
+#define GLP_REGFILE_BIST_STATUS_FAIL 0x00000001
+
+/* Fields of "BIST Time Out control Register" */
+/** Enable Timeout monitor
+    Enable timeout monitor when BIST starts to enable PHY. */
+#define GLP_REGFILE_BIST_TIMECTRL_TIMEOUT_EN 0x00000100
+/* Disable
+#define GLP_REGFILE_BIST_TIMECTRL_TIMEOUT_EN_DIS 0x00000000 */
+/** Enable */
+#define GLP_REGFILE_BIST_TIMECTRL_TIMEOUT_EN_EN 0x00000100
+/** Timeout counter value
+    Programs the counter value for the BIST to timeout on waiting for PHY ready. */
+#define GLP_REGFILE_BIST_TIMECTRL_TIMEOUTVAL_MASK 0x000000FF
+/** field offset */
+#define GLP_REGFILE_BIST_TIMECTRL_TIMEOUTVAL_OFFSET 0
+
+/* Fields of "Phase Lock Count Register" */
+/** Phase Lock Count
+    Programs the counter value for the BIST to achieve phase lock. */
+#define GLP_REGFILE_BIST_PHLOCK_COUNT_MASK 0x000003FF
+/** field offset */
+#define GLP_REGFILE_BIST_PHLOCK_COUNT_OFFSET 0
+
+/* Fields of "Bist Endcount Register" */
+/** Word Count
+    Programs the number of words for the BIST to check for errors. */
+#define GLP_REGFILE_BIST_END_COUNT_MASK 0x000003FF
+/** field offset */
+#define GLP_REGFILE_BIST_END_COUNT_OFFSET 0
+
+/* Fields of "BERT Termination Count Register" */
+/** Word Count
+    Read the number of words BERT receives at termination. */
+#define GLP_REGFILE_BERT_TERM_COUNT_MASK 0x000003FF
+/** field offset */
+#define GLP_REGFILE_BERT_TERM_COUNT_OFFSET 0
+
+/* Fields of "BERT Error Count Register" */
+/** Word Count
+    Read the number of accumulated bit errors. */
+#define GLP_REGFILE_BERT_ERR_COUNT_MASK 0x000003FF
+/** field offset */
+#define GLP_REGFILE_BERT_ERR_COUNT_OFFSET 0
+
+/* Fields of "BERT Reset Control Register" */
+/** BERT Error Count reset
+    Resets the BERT Error Count Register of the enabled BERT. */
+#define GLP_REGFILE_BERT_RST_ERR_RST 0x00000200
+/* No Reset
+#define GLP_REGFILE_BERT_RST_ERR_RST_NO_RST 0x00000000 */
+/** Reset */
+#define GLP_REGFILE_BERT_RST_ERR_RST_RST 0x00000200
+/** BERT Word Count reset
+    Resets the BERT Termination Count Register of the enabled BERT. */
+#define GLP_REGFILE_BERT_RST_WRD_RST 0x00000100
+/* No Reset
+#define GLP_REGFILE_BERT_RST_WRD_RST_NO_RST 0x00000000 */
+/** Reset */
+#define GLP_REGFILE_BERT_RST_WRD_RST_RST 0x00000100
+/** BERT RX Resets
+    Reset Bits (Active low) for each BERT RX. */
+#define GLP_REGFILE_BERT_RST_RX_RST_MASK 0x000000F0
+/** field offset */
+#define GLP_REGFILE_BERT_RST_RX_RST_OFFSET 4
+/** Reset */
+#define GLP_REGFILE_BERT_RST_RX_RST_RST 0x00000000
+/** No Reset */
+#define GLP_REGFILE_BERT_RST_RX_RST_NO_RST 0x00000010
+/** BERT TX Resets
+    Reset Bits (Active low) for each BERT TX. */
+#define GLP_REGFILE_BERT_RST_TX_RST_MASK 0x0000000F
+/** field offset */
+#define GLP_REGFILE_BERT_RST_TX_RST_OFFSET 0
+/** Reset */
+#define GLP_REGFILE_BERT_RST_TX_RST_RST 0x00000000
+/** No Reset */
+#define GLP_REGFILE_BERT_RST_TX_RST_NO_RST 0x00000001
+
+/* Fields of "BERT Control Register" */
+/** Scramble Enable
+    Data from BERTs will be used for scrambling data to PHY if enabled. */
+#define GLP_REGFILE_BERT_CTRL_SCR_EN 0x00000100
+/* Disable
+#define GLP_REGFILE_BERT_CTRL_SCR_EN_DIS 0x00000000 */
+/** Enable */
+#define GLP_REGFILE_BERT_CTRL_SCR_EN_EN 0x00000100
+/** Loopback Enables
+    Loopback enables for respective BERTs. */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_MASK 0x000000F0
+/** field offset */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_OFFSET 4
+/** BERTs loopback disabled */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_BERT_EN_NONE 0x00000000
+/** Enable Loopback in BERT 1 */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_BERT1_EN 0x00000010
+/** Enable Loopback in BERT 2 */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_BERT2_EN 0x00000020
+/** Enable Loopback in BERT 3 */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_BERT3_EN 0x00000040
+/** Enable Loopback in BERT 4 */
+#define GLP_REGFILE_BERT_CTRL_LOOPEN_BERT4_EN 0x00000080
+/** LFSR Enable
+    LSFR Data from BERTs will be used for scrambling data from PHY if enabled. */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_MASK 0x0000000F
+/** field offset */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_OFFSET 0
+/** BERTs Self Sync disabled */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_BERT_EN_NONE 0x00000000
+/** Enable Self Sync in BERT 1 */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_BERT1_EN 0x00000001
+/** Enable Self Sync in BERT 2 */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_BERT2_EN 0x00000002
+/** Enable Self Sync in BERT 3 */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_BERT3_EN 0x00000004
+/** Enable Self Sync in BERT 4 */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_BERT4_EN 0x00000008
+/** Reset value */
+#define GLP_REGFILE_BERT_CTRL_SELFSYNC_EN_RESET 0x0000000F
+
+/* Fields of "3GLP Control Register" */
+/** CRC value sent
+    This CRC value will be transmitted to core when 3GLP is not ready and MSK_EN is enabled. */
+#define GLP_REGFILE_GLP_CTRL_CRC_VAL 0x00000040
+/** Data masking enable
+    Enables data masking at core interface. A all-zeros data word will be transmitted when 3GLP is not ready. */
+#define GLP_REGFILE_GLP_CTRL_MSK_EN 0x00000020
+/* Disable
+#define GLP_REGFILE_GLP_CTRL_MSK_EN_DIS 0x00000000 */
+/** Enable */
+#define GLP_REGFILE_GLP_CTRL_MSK_EN_EN 0x00000020
+/** Clock switching enable
+    Enables clock switching at core interface. A 144MHz clock will be transmitted when 3GLP is not ready. */
+#define GLP_REGFILE_GLP_CTRL_CLK_SW 0x00000010
+/* Disable
+#define GLP_REGFILE_GLP_CTRL_CLK_SW_DIS 0x00000000 */
+/** Enable */
+#define GLP_REGFILE_GLP_CTRL_CLK_SW_EN 0x00000010
+/** Control
+    Selects Inband bits mapping to TX 2 CDR control. */
+#define GLP_REGFILE_GLP_CTRL_TX2_CDR_SEL_MASK 0x0000000C
+/** field offset */
+#define GLP_REGFILE_GLP_CTRL_TX2_CDR_SEL_OFFSET 2
+/** Selects RX1 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX2_CDR_SEL_SEL_1 0x00000000
+/** Selects RX2 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX2_CDR_SEL_SEL_2 0x00000004
+/** Selects RX3 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX2_CDR_SEL_SEL_3 0x00000008
+/** Selects RX4 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX2_CDR_SEL_SEL_4 0x0000000C
+/** Control
+    Selects Inband bits mapping to TX 1 CDR control. */
+#define GLP_REGFILE_GLP_CTRL_TX1_CDR_SEL_MASK 0x00000003
+/** field offset */
+#define GLP_REGFILE_GLP_CTRL_TX1_CDR_SEL_OFFSET 0
+/** Selects RX1 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX1_CDR_SEL_SEL_1 0x00000000
+/** Selects RX2 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX1_CDR_SEL_SEL_2 0x00000001
+/** Selects RX3 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX1_CDR_SEL_SEL_3 0x00000002
+/** Selects RX4 Inband Control */
+#define GLP_REGFILE_GLP_CTRL_TX1_CDR_SEL_SEL_4 0x00000003
+
+/* Fields of "3GLP Miscellaneous Register" */
+/** Status
+    Miscellaneous Status bits. */
+#define GLP_REGFILE_GLP_MISC_STATUS_2_MASK 0x0000F000
+/** field offset */
+#define GLP_REGFILE_GLP_MISC_STATUS_2_OFFSET 12
+/** Status
+    Miscellaneous Status bits. */
+#define GLP_REGFILE_GLP_MISC_STATUS_1_MASK 0x00000F00
+/** field offset */
+#define GLP_REGFILE_GLP_MISC_STATUS_1_OFFSET 8
+/** Control
+    Miscellaneous Control bits. */
+#define GLP_REGFILE_GLP_MISC_CTRL_MASK 0x000000FF
+/** field offset */
+#define GLP_REGFILE_GLP_MISC_CTRL_OFFSET 0
+
+/* Fields of "Start Up Control Register" */
+/** Skip Calibration
+    Skip Calibration bit. */
+#define PMA_REGFILE_STARTUP_CTRL_SKIP_CAL 0x00000400
+/** Startup Ready
+    Start up Ready bit. The PHY ready status is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_STARTUP_RDY 0x00000200
+/** CAL Enable
+    The Calibration Enable is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_CAL_EN 0x00000100
+/** CDR Enable
+    CDR Enable. The is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_CDR_EN 0x00000080
+/** Clock Enable
+    High Speed Clock Enable is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_CLK_EN 0x00000040
+/** Powerdown
+    Powerdown bit is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_PD 0x00000020
+/** Reset PMD
+    The PMD reset is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_RSTN_PMD 0x00000010
+/** Reset Digital
+    Digital reset to all blocks in PMA slices is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_RSTN_DIG 0x00000008
+/** PLL Powerdown
+    PLL powerdown is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_PLL_PD 0x00000004
+/** PLL reset
+    PLL reset bit. The PLL reset is overridden by this value when bypass is enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_PLL_RSTN 0x00000002
+/** Bypass
+    Register Bypass bit. Start-up state machine control outputs will be overridden by register values when enabled. */
+#define PMA_REGFILE_STARTUP_CTRL_BYPASS 0x00000001
+/* Disable
+#define PMA_REGFILE_STARTUP_CTRL_BYPASS_DIS 0x00000000 */
+/** Enable */
+#define PMA_REGFILE_STARTUP_CTRL_BYPASS_EN 0x00000001
+
+/* Fields of "State Register" */
+/** Start Up SM State
+    PMA Start-Up State Machine. */
+#define PMA_REGFILE_STATE_STATE_MASK 0x00000007
+/** field offset */
+#define PMA_REGFILE_STATE_STATE_OFFSET 0
+/** Power Up PLL */
+#define PMA_REGFILE_STATE_STATE_ST_POWERUP_PLL 0x00000000
+/** Release High Freqency Reset */
+#define PMA_REGFILE_STATE_STATE_ST_RELEASE_HF_RESET 0x00000001
+/** Release High Freqency Clocks */
+#define PMA_REGFILE_STATE_STATE_ST_RELEASE_HF_CLOCKS 0x00000002
+/** Release Digital Reset */
+#define PMA_REGFILE_STATE_STATE_ST_RELEASE_DIG_RESET 0x00000003
+/** Enable Calibration */
+#define PMA_REGFILE_STATE_STATE_ST_EN_CAL 0x00000004
+/** Finish */
+#define PMA_REGFILE_STATE_STATE_FINISH 0x00000005
+
+/* Fields of "Control 1 Register" */
+/** 16 LSBs of the CONST_SDM. */
+#define PLL_REGFILE_CTRL1_CONST_SDM_MASK 0x0000FFFF
+/** field offset */
+#define PLL_REGFILE_CTRL1_CONST_SDM_OFFSET 0
+
+/* Fields of "Control 2 Register" */
+/** plldigtest_r */
+#define PLL_REGFILE_CTRL2_PLLDIGTEST_MASK 0x0000F800
+/** field offset */
+#define PLL_REGFILE_CTRL2_PLLDIGTEST_OFFSET 11
+/** pll_enwavegen_r */
+#define PLL_REGFILE_CTRL2_PLL_ENWAVEGEN 0x00000400
+/* Disable
+#define PLL_REGFILE_CTRL2_PLL_ENWAVEGEN_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL2_PLL_ENWAVEGEN_EN 0x00000400
+/** pll_ensdm_r */
+#define PLL_REGFILE_CTRL2_PLL_ENSDM 0x00000200
+/* Disable
+#define PLL_REGFILE_CTRL2_PLL_ENSDM_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL2_PLL_ENSDM_EN 0x00000200
+/** en_const_sdm_r */
+#define PLL_REGFILE_CTRL2_EN_CONST_SDM 0x00000100
+/* Disable
+#define PLL_REGFILE_CTRL2_EN_CONST_SDM_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL2_EN_CONST_SDM_EN 0x00000100
+/** 8 MSBs of the CONST_SDM. */
+#define PLL_REGFILE_CTRL2_CONST_SDM_MASK 0x000000FF
+/** field offset */
+#define PLL_REGFILE_CTRL2_CONST_SDM_OFFSET 0
+
+/* Fields of "Control 3 Register" */
+/** en_ext_selvco_r */
+#define PLL_REGFILE_CTRL3_EXT_SELVCO_MASK 0x00003E00
+/** field offset */
+#define PLL_REGFILE_CTRL3_EXT_SELVCO_OFFSET 9
+/** ext_VCO_vctrl_mux_r */
+#define PLL_REGFILE_CTRL3_EXT_VCO_VCTRL_MUX_MASK 0x00000180
+/** field offset */
+#define PLL_REGFILE_CTRL3_EXT_VCO_VCTRL_MUX_OFFSET 7
+/** ext_MMD_div_ratio_r */
+#define PLL_REGFILE_CTRL3_EXT_MMD_DIV_RATIO_MASK 0x00000070
+/** field offset */
+#define PLL_REGFILE_CTRL3_EXT_MMD_DIV_RATIO_OFFSET 4
+/** en_ext_selvco_r */
+#define PLL_REGFILE_CTRL3_EN_EXT_SELVCO 0x00000008
+/* Disable
+#define PLL_REGFILE_CTRL3_EN_EXT_SELVCO_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL3_EN_EXT_SELVCO_EN 0x00000008
+/** en_ext_VCO_vctrl_mux_r */
+#define PLL_REGFILE_CTRL3_EN_EXT_VCO_VCTRL_MUX 0x00000004
+/* Disable
+#define PLL_REGFILE_CTRL3_EN_EXT_VCO_VCTRL_MUX_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL3_EN_EXT_VCO_VCTRL_MUX_EN 0x00000004
+/** en_ext_MMD_div_ratio_r */
+#define PLL_REGFILE_CTRL3_EN_EXT_MMD_DIV_RATIO 0x00000002
+/* Disable
+#define PLL_REGFILE_CTRL3_EN_EXT_MMD_DIV_RATIO_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL3_EN_EXT_MMD_DIV_RATIO_EN 0x00000002
+/** en_binary_cal_r */
+#define PLL_REGFILE_CTRL3_EN_BIN_CAL 0x00000001
+/* Disable
+#define PLL_REGFILE_CTRL3_EN_BIN_CAL_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_CTRL3_EN_BIN_CAL_EN 0x00000001
+
+/* Fields of "Control 4 Register" */
+/** pllmod_r
+    First (Least Significant) word of the PLLMOD. */
+#define PLL_REGFILE_CTRL4_PLLMOD_MASK 0x0000FFFF
+/** field offset */
+#define PLL_REGFILE_CTRL4_PLLMOD_OFFSET 0
+
+/* Fields of "Control 5 Register" */
+/** pllmod_r
+    Second word of the PLLMOD. */
+#define PLL_REGFILE_CTRL5_PLLMOD_MASK 0x0000FFFF
+/** field offset */
+#define PLL_REGFILE_CTRL5_PLLMOD_OFFSET 0
+
+/* Fields of "Control 6 Register" */
+/** pllmod_r
+    Third word of the PLLMOD. */
+#define PLL_REGFILE_CTRL6_PLLMOD_MASK 0x0000FFFF
+/** field offset */
+#define PLL_REGFILE_CTRL6_PLLMOD_OFFSET 0
+
+/* Fields of "Control 7 Register" */
+/** pllmod_r
+    Fourth (Most significant) word of the PLLMOD. */
+#define PLL_REGFILE_CTRL7_PLLMOD_MASK 0x0000FFFF
+/** field offset */
+#define PLL_REGFILE_CTRL7_PLLMOD_OFFSET 0
+
+/* Fields of "Analog Control 1 Register" */
+/** pfd_force_up_r */
+#define PLL_REGFILE_A_CTRL1_PFD_FORCE_UP 0x00008000
+/** pfd_force_dw_r */
+#define PLL_REGFILE_A_CTRL1_PFD_FORCE_DW 0x00004000
+/** cp_sel_r */
+#define PLL_REGFILE_A_CTRL1_CP_SEL_MASK 0x00003800
+/** field offset */
+#define PLL_REGFILE_A_CTRL1_CP_SEL_OFFSET 11
+/** cp_ref_sel_r */
+#define PLL_REGFILE_A_CTRL1_CP_REF_SEL_MASK 0x00000600
+/** field offset */
+#define PLL_REGFILE_A_CTRL1_CP_REF_SEL_OFFSET 9
+/** cp_force_fix_p_bias_r */
+#define PLL_REGFILE_A_CTRL1_CP_FORCE_FIX_P_BIAS 0x00000100
+/** biastrim */
+#define PLL_REGFILE_A_CTRL1_BIASTRIM_MASK 0x000000FF
+/** field offset */
+#define PLL_REGFILE_A_CTRL1_BIASTRIM_OFFSET 0
+
+/* Fields of "Analog Control 2 Register" */
+/** lf_mode_r */
+#define PLL_REGFILE_A_CTRL2_LF_MODE 0x00004000
+/** ldo_vref_sel_r */
+#define PLL_REGFILE_A_CTRL2_LDO_VREF_SEL_MASK 0x00003800
+/** field offset */
+#define PLL_REGFILE_A_CTRL2_LDO_VREF_SEL_OFFSET 11
+/** div_clk_o_mtr_en_r */
+#define PLL_REGFILE_A_CTRL2_DIV_CLK_O_MTR_EN 0x00000400
+/* Disable
+#define PLL_REGFILE_A_CTRL2_DIV_CLK_O_MTR_EN_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_A_CTRL2_DIV_CLK_O_MTR_EN_EN 0x00000400
+/** current_sel_ref_mux_r */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_REF_MUX_MASK 0x00000300
+/** field offset */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_REF_MUX_OFFSET 8
+/** current_sel_pi_r */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_PI_MASK 0x000000C0
+/** field offset */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_PI_OFFSET 6
+/** current_sel_lf_r */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_LF_MASK 0x00000030
+/** field offset */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_LF_OFFSET 4
+/** current_sel_ldo_r */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_LDO_MASK 0x0000000C
+/** field offset */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_LDO_OFFSET 2
+/** current_sel_div2_r */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_DIV2_MASK 0x00000003
+/** field offset */
+#define PLL_REGFILE_A_CTRL2_CURR_SEL_DIV2_OFFSET 0
+
+/* Fields of "Analog Control 3 Register" */
+/** vco_sel_r */
+#define PLL_REGFILE_A_CTRL3_VCO_SEL 0x00002000
+/** vco_vctrl_when_ct_r */
+#define PLL_REGFILE_A_CTRL3_VCO_VCTRL_WHEN_CT_MASK 0x00001800
+/** field offset */
+#define PLL_REGFILE_A_CTRL3_VCO_VCTRL_WHEN_CT_OFFSET 11
+/** test_ext_fd_in_en_r */
+#define PLL_REGFILE_A_CTRL3_TEST_EXT_FD_IN_EN 0x00000400
+/* Disable
+#define PLL_REGFILE_A_CTRL3_TEST_EXT_FD_IN_EN_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_A_CTRL3_TEST_EXT_FD_IN_EN_EN 0x00000400
+/** refclk_sel_r */
+#define PLL_REGFILE_A_CTRL3_REFCLK_SEL 0x00000200
+/** refclk_o_en_r */
+#define PLL_REGFILE_A_CTRL3_REFCLK_O_EN 0x00000100
+/* Disable
+#define PLL_REGFILE_A_CTRL3_REFCLK_O_EN_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_A_CTRL3_REFCLK_O_EN_EN 0x00000100
+/** ref_clk_o_mtr_en_r */
+#define PLL_REGFILE_A_CTRL3_REF_CLK_O_MTR_EN 0x00000080
+/* Disable
+#define PLL_REGFILE_A_CTRL3_REF_CLK_O_MTR_EN_DIS 0x00000000 */
+/** Enable */
+#define PLL_REGFILE_A_CTRL3_REF_CLK_O_MTR_EN_EN 0x00000080
+/** pwd_vrefs_r */
+#define PLL_REGFILE_A_CTRL3_PWD_VREFS 0x00000040
+/** pwd_lf_r */
+#define PLL_REGFILE_A_CTRL3_PWD_LF 0x00000020
+/** pwd_ldo_vco_r */
+#define PLL_REGFILE_A_CTRL3_PWD_LDO_VCO 0x00000010
+/** pwd_fd_in_buffer_r */
+#define PLL_REGFILE_A_CTRL3_PWD_FD_IN_BUFFER 0x00000008
+/** pwd_div2_r */
+#define PLL_REGFILE_A_CTRL3_PWD_DIV2 0x00000004
+/** pwd_cp_r */
+#define PLL_REGFILE_A_CTRL3_PWD_CP 0x00000002
+/** pwd_bias_r */
+#define PLL_REGFILE_A_CTRL3_PWD_BIAS 0x00000001
+
+/* Fields of "Analog Control 4 Register" */
+/** pwd_out_div8_r */
+#define PLL_REGFILE_A_CTRL4_PWD_OUT_DIV8 0x00002000
+/** pwd_out_div5_r */
+#define PLL_REGFILE_A_CTRL4_PWD_OUT_DIV5 0x00001000
+/** pwd_out_div_r */
+#define PLL_REGFILE_A_CTRL4_PWD_OUT_DIV 0x00000800
+/** pwd_fix_ph_core_f_r */
+#define PLL_REGFILE_A_CTRL4_PWD_FIX_PH_CORE_F 0x00000400
+/** current_sel_fixph_buf_r */
+#define PLL_REGFILE_A_CTRL4_CUR_SEL_FIXPH_BUF_MASK 0x00000300
+/** field offset */
+#define PLL_REGFILE_A_CTRL4_CUR_SEL_FIXPH_BUF_OFFSET 8
+/** current_sel_fd_prebuf_r */
+#define PLL_REGFILE_A_CTRL4_CUR_SEL_FD_PREBUF_MASK 0x000000C0
+/** field offset */
+#define PLL_REGFILE_A_CTRL4_CUR_SEL_FD_PREBUF_OFFSET 6
+/** mmd_r */
+#define PLL_REGFILE_A_CTRL4_MMD_MASK 0x0000003F
+/** field offset */
+#define PLL_REGFILE_A_CTRL4_MMD_OFFSET 0
+
+/* Fields of "PLL Status Register" */
+/** Startup Ready */
+#define PLL_REGFILE_STATUS_STARTUP_RDY 0x00000040
+/** Lock */
+#define PLL_REGFILE_STATUS_LOCK 0x00000020
+/** Ready */
+#define PLL_REGFILE_STATUS_READY 0x00000010
+/** Force Start */
+#define PLL_REGFILE_STATUS_FORCE_START 0x00000002
+/** Force Lock */
+#define PLL_REGFILE_STATUS_FORCE_LOCK 0x00000001
+
+/* Fields of "Control 1 Register" */
+/** ei_ovr_r
+    Override enable bit for EI_EN and EIN_EN. */
+#define TX_REGFILE_0_CTRL1_EI_OVR 0x00004000
+/* Override Disable
+#define TX_REGFILE_0_CTRL1_EI_OVR_DIS 0x00000000 */
+/** Override Enable */
+#define TX_REGFILE_0_CTRL1_EI_OVR_EN 0x00004000
+/** pi_ctrl_r
+    For pi_ctrl. */
+#define TX_REGFILE_0_CTRL1_PI_CTRL_MASK 0x00003F00
+/** field offset */
+#define TX_REGFILE_0_CTRL1_PI_CTRL_OFFSET 8
+/** ein_en_r
+    Used to select the sign of the SERIALIZER outputs when EI_EN is high. Pay attention that the signal of the serializer output is inverted into the offchip. */
+#define TX_REGFILE_0_CTRL1_EIN_EN 0x00000080
+/* Disable
+#define TX_REGFILE_0_CTRL1_EIN_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_CTRL1_EIN_EN_EN 0x00000080
+/** halfrate_r
+    Enable half rate data transmission. */
+#define TX_REGFILE_0_CTRL1_HALFRATE 0x00000040
+/** flip_r
+    Flip the data. */
+#define TX_REGFILE_0_CTRL1_FLIP 0x00000020
+/** load_r
+    For PI control circuit's loading of PI_CTRL value. */
+#define TX_REGFILE_0_CTRL1_LOAD 0x00000010
+/** force_r
+    Force farend detection. */
+#define TX_REGFILE_0_CTRL1_FORCE 0x00000008
+/** ei_en_r
+    Forces the ouptut of the SERIALIZER either to High or to Low depending on the value of the EIN_EN. */
+#define TX_REGFILE_0_CTRL1_EI_EN 0x00000004
+/* Disable
+#define TX_REGFILE_0_CTRL1_EI_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_CTRL1_EI_EN_EN 0x00000004
+/** Invert Enable
+    Enables the inversion of data. */
+#define TX_REGFILE_0_CTRL1_INV_EN 0x00000002
+/* Disable
+#define TX_REGFILE_0_CTRL1_INV_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_CTRL1_INV_EN_EN 0x00000002
+/** Enable
+    Enable bit. */
+#define TX_REGFILE_0_CTRL1_EN 0x00000001
+/* Disable
+#define TX_REGFILE_0_CTRL1_EN_DIS 0x00000000 */
+
+/* Fields of "TX Control 2 Register" */
+/** rterm_r
+    Configures termination resistors in PHY. */
+#define TX_REGFILE_0_CTRL2_RTERM_MASK 0x00003E00
+/** field offset */
+#define TX_REGFILE_0_CTRL2_RTERM_OFFSET 9
+/** Enable Programmable TX Data
+    Enable Programmable Data for TX. */
+#define TX_REGFILE_0_CTRL2_PRG_EN 0x00000100
+/* Disable
+#define TX_REGFILE_0_CTRL2_PRG_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_CTRL2_PRG_EN_EN 0x00000100
+/** Programmable TX Data
+    Programmable Data for TX to PHY. */
+#define TX_REGFILE_0_CTRL2_PRG_DATA_MASK 0x000000FF
+/** field offset */
+#define TX_REGFILE_0_CTRL2_PRG_DATA_OFFSET 0
+
+/* Fields of "Control 3 Register" */
+/** counter_limit_r
+    Counter limit for farend detection. */
+#define TX_REGFILE_0_CTRL3_CNTR_LIM_MASK 0x0000FFFF
+/** field offset */
+#define TX_REGFILE_0_CTRL3_CNTR_LIM_OFFSET 0
+
+/* Fields of "Analog Control 1 Register" */
+/** control_r
+    Control bits for TX slice. */
+#define TX_REGFILE_0_A_CTRL1_CTRL_MASK 0x0000FF00
+/** field offset */
+#define TX_REGFILE_0_A_CTRL1_CTRL_OFFSET 8
+/** diffout_en_r
+    Connects the drain of the differential input stage in the off-chip driver to the outputs tx_p_o and tx_n_o. */
+#define TX_REGFILE_0_A_CTRL1_DIFFOUT_EN 0x00000010
+/* Disable
+#define TX_REGFILE_0_A_CTRL1_DIFFOUT_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_A_CTRL1_DIFFOUT_EN_EN 0x00000010
+/** deemph_en_r
+    Activates the De-Emphasis Mode in the SERIALIZER. */
+#define TX_REGFILE_0_A_CTRL1_DEEMPH_EN 0x00000008
+/* Disable
+#define TX_REGFILE_0_A_CTRL1_DEEMPH_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_A_CTRL1_DEEMPH_EN_EN 0x00000008
+/** clkmode_en_r
+    Clock mode enable for PHY. */
+#define TX_REGFILE_0_A_CTRL1_CLKMODE_EN 0x00000004
+/* Disable
+#define TX_REGFILE_0_A_CTRL1_CLKMODE_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_A_CTRL1_CLKMODE_EN_EN 0x00000004
+/** clk_edge_sel_r
+    Clock edge select for PHY. */
+#define TX_REGFILE_0_A_CTRL1_CLK_EDGE_SEL 0x00000002
+/** clk_byp_en_r
+    Clock bypass enable for PHY. */
+#define TX_REGFILE_0_A_CTRL1_CLK_BYP_EN 0x00000001
+/* Disable
+#define TX_REGFILE_0_A_CTRL1_CLK_BYP_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_A_CTRL1_CLK_BYP_EN_EN 0x00000001
+
+/* Fields of "Analog Control 2 Register" */
+/** ser_en_r
+    Enables the SERIALIZER, Active High. */
+#define TX_REGFILE_0_A_CTRL2_SER_EN 0x00008000
+/** predrv_ser_en_r
+    Selects total width of NMOS FETs in series to PMOS in the the predriver outputs. They are used to regulate the high level of the predriver output signals. Numbers of activated fingers (each finger = 210n/50n). */
+#define TX_REGFILE_0_A_CTRL2_PREDRV_SER_EN_MASK 0x00007F00
+/** field offset */
+#define TX_REGFILE_0_A_CTRL2_PREDRV_SER_EN_OFFSET 8
+/** predrv_par_en_r
+    Selects total width of pull down NMOS FETs in parallel to the predriver outputs. Numbers of activated fingers (each finger = 110n/50n). */
+#define TX_REGFILE_0_A_CTRL2_PREDRV_PAR_EN_MASK 0x000000F0
+/** field offset */
+#define TX_REGFILE_0_A_CTRL2_PREDRV_PAR_EN_OFFSET 4
+/** iout_r
+    Programs the current value in the off-chip driver. */
+#define TX_REGFILE_0_A_CTRL2_IOUT_MASK 0x0000000F
+/** field offset */
+#define TX_REGFILE_0_A_CTRL2_IOUT_OFFSET 0
+
+/* Fields of "Modulation Configuration 1 Register" */
+/** skew_period_flip
+    if mod_out_flip_i = 0, skew_period_flip_i = 0 will add skew to down */
+#define TX_REGFILE_0_MOD1_SKEW_PERIOD_FLIP 0x00002000
+/** Mod_out_skew_en
+    Enable skew to CDR CTRL */
+#define TX_REGFILE_0_MOD1_SKEW_EN 0x00001000
+/** Mod_flip
+    Bit to flip the CDR CTRL to start modulation pulses with up or down */
+#define TX_REGFILE_0_MOD1_FLIP 0x00000800
+/** Modulation Period */
+#define TX_REGFILE_0_MOD1_PERIOD_MASK 0x000007FF
+/** field offset */
+#define TX_REGFILE_0_MOD1_PERIOD_OFFSET 0
+
+/* Fields of "Modulation Configuration 2 Register" */
+/** Skew Period
+    The user defined occurance period for skew. */
+#define TX_REGFILE_0_MOD2_SKEW_PERIOD_MASK 0x0000FFFF
+/** field offset */
+#define TX_REGFILE_0_MOD2_SKEW_PERIOD_OFFSET 0
+
+/* Fields of "Modulation Configuration 3 Register" */
+/** mod_en_r
+    Modulation enable for PHY. */
+#define TX_REGFILE_0_MOD3_MOD_EN 0x00000400
+/* Disable
+#define TX_REGFILE_0_MOD3_MOD_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_MOD3_MOD_EN_EN 0x00000400
+/** Modulation Override
+    Modulation override enable for PHY. */
+#define TX_REGFILE_0_MOD3_MOD_OVR 0x00000200
+/** BIST Modulation Enable
+    Bist modulation enable for PHY. */
+#define TX_REGFILE_0_MOD3_BIST_MOD_EN 0x00000100
+/* Disable
+#define TX_REGFILE_0_MOD3_BIST_MOD_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_0_MOD3_BIST_MOD_EN_EN 0x00000100
+/** Testbus Bist Enable
+    Enables the BIST loop in PMD. */
+#define TX_REGFILE_0_MOD3_TESTBUS_BIST_EN 0x00000080
+/** Testbus Enable
+    Enables Test bus in PMD. */
+#define TX_REGFILE_0_MOD3_TESTBUS_EN 0x00000040
+/** Modulation pulses
+    The number of up or down modulation pulses. */
+#define TX_REGFILE_0_MOD3_AMP_MASK 0x0000003F
+/** field offset */
+#define TX_REGFILE_0_MOD3_AMP_OFFSET 0
+
+/* Fields of "Control 1 Register" */
+/** ei_ovr_r
+    Override enable bit for EI_EN and EIN_EN. */
+#define TX_REGFILE_1_CTRL1_EI_OVR 0x00004000
+/* Override Disable
+#define TX_REGFILE_1_CTRL1_EI_OVR_DIS 0x00000000 */
+/** Override Enable */
+#define TX_REGFILE_1_CTRL1_EI_OVR_EN 0x00004000
+/** pi_ctrl_r
+    For pi_ctrl. */
+#define TX_REGFILE_1_CTRL1_PI_CTRL_MASK 0x00003F00
+/** field offset */
+#define TX_REGFILE_1_CTRL1_PI_CTRL_OFFSET 8
+/** ein_en_r
+    Used to select the sign of the SERIALIZER outputs when EI_EN is high. Pay attention that the signal of the serializer output is inverted into the offchip. */
+#define TX_REGFILE_1_CTRL1_EIN_EN 0x00000080
+/* Disable
+#define TX_REGFILE_1_CTRL1_EIN_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_CTRL1_EIN_EN_EN 0x00000080
+/** halfrate_r
+    Enable half rate data transmission. */
+#define TX_REGFILE_1_CTRL1_HALFRATE 0x00000040
+/** flip_r
+    Flip the data. */
+#define TX_REGFILE_1_CTRL1_FLIP 0x00000020
+/** load_r
+    For PI control circuit's loading of PI_CTRL value. */
+#define TX_REGFILE_1_CTRL1_LOAD 0x00000010
+/** force_r
+    Force farend detection. */
+#define TX_REGFILE_1_CTRL1_FORCE 0x00000008
+/** ei_en_r
+    Forces the ouptut of the SERIALIZER either to High or to Low depending on the value of the EIN_EN. */
+#define TX_REGFILE_1_CTRL1_EI_EN 0x00000004
+/* Disable
+#define TX_REGFILE_1_CTRL1_EI_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_CTRL1_EI_EN_EN 0x00000004
+/** Invert Enable
+    Enables the inversion of data. */
+#define TX_REGFILE_1_CTRL1_INV_EN 0x00000002
+/* Disable
+#define TX_REGFILE_1_CTRL1_INV_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_CTRL1_INV_EN_EN 0x00000002
+/** Enable
+    Enable bit. */
+#define TX_REGFILE_1_CTRL1_EN 0x00000001
+/* Disable
+#define TX_REGFILE_1_CTRL1_EN_DIS 0x00000000 */
+
+/* Fields of "TX Control 2 Register" */
+/** rterm_r
+    Configures termination resistors in PHY. */
+#define TX_REGFILE_1_CTRL2_RTERM_MASK 0x00003E00
+/** field offset */
+#define TX_REGFILE_1_CTRL2_RTERM_OFFSET 9
+/** Enable Programmable TX Data
+    Enable Programmable Data for TX. */
+#define TX_REGFILE_1_CTRL2_PRG_EN 0x00000100
+/* Disable
+#define TX_REGFILE_1_CTRL2_PRG_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_CTRL2_PRG_EN_EN 0x00000100
+/** Programmable TX Data
+    Programmable Data for TX to PHY. */
+#define TX_REGFILE_1_CTRL2_PRG_DATA_MASK 0x000000FF
+/** field offset */
+#define TX_REGFILE_1_CTRL2_PRG_DATA_OFFSET 0
+
+/* Fields of "Control 3 Register" */
+/** counter_limit_r
+    Counter limit for farend detection. */
+#define TX_REGFILE_1_CTRL3_CNTR_LIM_MASK 0x0000FFFF
+/** field offset */
+#define TX_REGFILE_1_CTRL3_CNTR_LIM_OFFSET 0
+
+/* Fields of "Analog Control 1 Register" */
+/** control_r
+    Control bits for TX slice. */
+#define TX_REGFILE_1_A_CTRL1_CTRL_MASK 0x0000FF00
+/** field offset */
+#define TX_REGFILE_1_A_CTRL1_CTRL_OFFSET 8
+/** diffout_en_r
+    Connects the drain of the differential input stage in the off-chip driver to the outputs tx_p_o and tx_n_o. */
+#define TX_REGFILE_1_A_CTRL1_DIFFOUT_EN 0x00000010
+/* Disable
+#define TX_REGFILE_1_A_CTRL1_DIFFOUT_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_A_CTRL1_DIFFOUT_EN_EN 0x00000010
+/** deemph_en_r
+    Activates the De-Emphasis Mode in the SERIALIZER. */
+#define TX_REGFILE_1_A_CTRL1_DEEMPH_EN 0x00000008
+/* Disable
+#define TX_REGFILE_1_A_CTRL1_DEEMPH_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_A_CTRL1_DEEMPH_EN_EN 0x00000008
+/** clkmode_en_r
+    Clock mode enable for PHY. */
+#define TX_REGFILE_1_A_CTRL1_CLKMODE_EN 0x00000004
+/* Disable
+#define TX_REGFILE_1_A_CTRL1_CLKMODE_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_A_CTRL1_CLKMODE_EN_EN 0x00000004
+/** clk_edge_sel_r
+    Clock edge select for PHY. */
+#define TX_REGFILE_1_A_CTRL1_CLK_EDGE_SEL 0x00000002
+/** clk_byp_en_r
+    Clock bypass enable for PHY. */
+#define TX_REGFILE_1_A_CTRL1_CLK_BYP_EN 0x00000001
+/* Disable
+#define TX_REGFILE_1_A_CTRL1_CLK_BYP_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_A_CTRL1_CLK_BYP_EN_EN 0x00000001
+
+/* Fields of "Analog Control 2 Register" */
+/** ser_en_r
+    Enables the SERIALIZER, Active High. */
+#define TX_REGFILE_1_A_CTRL2_SER_EN 0x00008000
+/** predrv_ser_en_r
+    Selects total width of NMOS FETs in series to PMOS in the the predriver outputs. They are used to regulate the high level of the predriver output signals. Numbers of activated fingers (each finger = 210n/50n). */
+#define TX_REGFILE_1_A_CTRL2_PREDRV_SER_EN_MASK 0x00007F00
+/** field offset */
+#define TX_REGFILE_1_A_CTRL2_PREDRV_SER_EN_OFFSET 8
+/** predrv_par_en_r
+    Selects total width of pull down NMOS FETs in parallel to the predriver outputs. Numbers of activated fingers (each finger = 110n/50n). */
+#define TX_REGFILE_1_A_CTRL2_PREDRV_PAR_EN_MASK 0x000000F0
+/** field offset */
+#define TX_REGFILE_1_A_CTRL2_PREDRV_PAR_EN_OFFSET 4
+/** iout_r
+    Programs the current value in the off-chip driver. */
+#define TX_REGFILE_1_A_CTRL2_IOUT_MASK 0x0000000F
+/** field offset */
+#define TX_REGFILE_1_A_CTRL2_IOUT_OFFSET 0
+
+/* Fields of "Modulation Configuration 1 Register" */
+/** skew_period_flip
+    if mod_out_flip_i = 0, skew_period_flip_i = 0 will add skew to down */
+#define TX_REGFILE_1_MOD1_SKEW_PERIOD_FLIP 0x00002000
+/** Mod_out_skew_en
+    Enable skew to CDR CTRL */
+#define TX_REGFILE_1_MOD1_SKEW_EN 0x00001000
+/** Mod_flip
+    Bit to flip the CDR CTRL to start modulation pulses with up or down */
+#define TX_REGFILE_1_MOD1_FLIP 0x00000800
+/** Modulation Period */
+#define TX_REGFILE_1_MOD1_PERIOD_MASK 0x000007FF
+/** field offset */
+#define TX_REGFILE_1_MOD1_PERIOD_OFFSET 0
+
+/* Fields of "Modulation Configuration 2 Register" */
+/** Skew Period
+    The user defined occurance period for skew. */
+#define TX_REGFILE_1_MOD2_SKEW_PERIOD_MASK 0x0000FFFF
+/** field offset */
+#define TX_REGFILE_1_MOD2_SKEW_PERIOD_OFFSET 0
+
+/* Fields of "Modulation Configuration 3 Register" */
+/** mod_en_r
+    Modulation enable for PHY. */
+#define TX_REGFILE_1_MOD3_MOD_EN 0x00000400
+/* Disable
+#define TX_REGFILE_1_MOD3_MOD_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_MOD3_MOD_EN_EN 0x00000400
+/** Modulation Override
+    Modulation override enable for PHY. */
+#define TX_REGFILE_1_MOD3_MOD_OVR 0x00000200
+/** BIST Modulation Enable
+    Bist modulation enable for PHY. */
+#define TX_REGFILE_1_MOD3_BIST_MOD_EN 0x00000100
+/* Disable
+#define TX_REGFILE_1_MOD3_BIST_MOD_EN_DIS 0x00000000 */
+/** Enable */
+#define TX_REGFILE_1_MOD3_BIST_MOD_EN_EN 0x00000100
+/** Testbus Bist Enable
+    Enables the BIST loop in PMD. */
+#define TX_REGFILE_1_MOD3_TESTBUS_BIST_EN 0x00000080
+/** Testbus Enable
+    Enables Test bus in PMD. */
+#define TX_REGFILE_1_MOD3_TESTBUS_EN 0x00000040
+/** Modulation pulses
+    The number of up or down modulation pulses. */
+#define TX_REGFILE_1_MOD3_AMP_MASK 0x0000003F
+/** field offset */
+#define TX_REGFILE_1_MOD3_AMP_OFFSET 0
+
+/* Fields of "RX Control 1 Register" */
+/** halfrate_r
+    Enable half rate data transmission. */
+#define RX_REGFILE_CTRL1_HALFRATE 0x00008000
+/** flip_r
+    Flip the data. */
+#define RX_REGFILE_CTRL1_FLIP 0x00004000
+/** pi_ctrl_r
+    PI control value for loading. */
+#define RX_REGFILE_CTRL1_PI_CTRL_MASK 0x00003F00
+/** field offset */
+#define RX_REGFILE_CTRL1_PI_CTRL_OFFSET 8
+/** sel_offset_r
+    Control bits for CML offset calibration. */
+#define RX_REGFILE_CTRL1_SEL_OFFSET_MASK 0x000000F0
+/** field offset */
+#define RX_REGFILE_CTRL1_SEL_OFFSET_OFFSET 4
+/** For bypassing SEL_OFFSET. */
+#define RX_REGFILE_CTRL1_BYPASS 0x00000008
+/* Disable
+#define RX_REGFILE_CTRL1_BYPASS_DIS 0x00000000 */
+/** Enable */
+#define RX_REGFILE_CTRL1_BYPASS_EN 0x00000008
+/** Invert Enable
+    Enables the inversion of RX data. */
+#define RX_REGFILE_CTRL1_INV_EN 0x00000004
+/** load_r
+    For PI control circuit's loading of PI_CTRL value. */
+#define RX_REGFILE_CTRL1_LOAD 0x00000002
+/** Enable
+    Enable bit. */
+#define RX_REGFILE_CTRL1_EN 0x00000001
+/* Disable
+#define RX_REGFILE_CTRL1_EN_DIS 0x00000000 */
+
+/* Fields of "RX Control 2 Register" */
+/** rterm_r
+    Configures termination resistors in PHY. */
+#define RX_REGFILE_CTRL2_RTERM_MASK 0x00003E00
+/** field offset */
+#define RX_REGFILE_CTRL2_RTERM_OFFSET 9
+/** Enable Programmable RX Data
+    Enable Programmable Data for RX. */
+#define RX_REGFILE_CTRL2_PRG_EN 0x00000100
+/* Disable
+#define RX_REGFILE_CTRL2_PRG_EN_DIS 0x00000000 */
+/** Enable */
+#define RX_REGFILE_CTRL2_PRG_EN_EN 0x00000100
+/** Programmable RX Data
+    Programmable Data for RX. */
+#define RX_REGFILE_CTRL2_DATA_MASK 0x000000FF
+/** field offset */
+#define RX_REGFILE_CTRL2_DATA_OFFSET 0
+
+/* Fields of "CDR Configuration Register" */
+/** sum_int
+    SUM_INT. */
+#define RX_REGFILE_CDR_SUM_INT 0x00000200
+/** xor_inv
+    XOR_INV. */
+#define RX_REGFILE_CDR_XOR_INV 0x00000100
+/** dumpint
+    dumpint. */
+#define RX_REGFILE_CDR_DUMPINT_MASK 0x00000070
+/** field offset */
+#define RX_REGFILE_CDR_DUMPINT_OFFSET 4
+/** comp
+    Comp. */
+#define RX_REGFILE_CDR_COMP_MASK 0x00000007
+/** field offset */
+#define RX_REGFILE_CDR_COMP_OFFSET 0
+
+/* Fields of "EI Register" */
+/** ei_endcount_r
+    End count for EI detection timeout. */
+#define RX_REGFILE_EI_ENDCNT_MASK 0x0000FFFF
+/** field offset */
+#define RX_REGFILE_EI_ENDCNT_OFFSET 0
+
+/* Fields of "CAL Register" */
+/** cal_fail_r
+    Status bit for calibration failure. */
+#define RX_REGFILE_CAL_CAL_FAIL 0x00000200
+/** inv_dir_r
+    For inverting direction of calibration (when data is inverted). */
+#define RX_REGFILE_CAL_INV_DIR 0x00000100
+/** comp_count_r
+    Limit for comparison -> hysteresis. */
+#define RX_REGFILE_CAL_COMP_CNT_MASK 0x000000F0
+/** field offset */
+#define RX_REGFILE_CAL_COMP_CNT_OFFSET 4
+/** smp_count_r
+    Number of samples to count. */
+#define RX_REGFILE_CAL_SMP_CNT_MASK 0x0000000F
+/** field offset */
+#define RX_REGFILE_CAL_SMP_CNT_OFFSET 0
+
+/* Fields of "Analog Control Register" */
+/** output_cm_sel_r
+    Set common mode level of levelshifter output. */
+#define RX_REGFILE_A_CTRL_OUTPUT_CM_SEL_MASK 0x00007000
+/** field offset */
+#define RX_REGFILE_A_CTRL_OUTPUT_CM_SEL_OFFSET 12
+/** RX Data Deemphasis Control. */
+#define RX_REGFILE_A_CTRL_EMP_MASK 0x00000C00
+/** field offset */
+#define RX_REGFILE_A_CTRL_EMP_OFFSET 10
+/** double_tailcur_r
+    Use double tailcurrent in cml amplifier. */
+#define RX_REGFILE_A_CTRL_DB_TAILCUR 0x00000200
+/** cdr_on_n_r
+    Edge detector control. */
+#define RX_REGFILE_A_CTRL_CDR_ON_N 0x00000100
+/** control_r
+    Control bits for RX slice. */
+#define RX_REGFILE_A_CTRL_CTRL_MASK 0x000000FF
+/** field offset */
+#define RX_REGFILE_A_CTRL_CTRL_OFFSET 0
+
+/* Fields of "Test Control Register" */
+/** Testbus Bist Enable
+    Enables the BIST loop in PMD. */
+#define RX_REGFILE_TEST_CTRL_TESTBUS_BIST_EN 0x00000002
+/* Disable
+#define RX_REGFILE_TEST_CTRL_TESTBUS_BIST_EN_DIS 0x00000000 */
+/** Enable */
+#define RX_REGFILE_TEST_CTRL_TESTBUS_BIST_EN_EN 0x00000002
+/** Testbus Enable
+    Enables Test bus in PMD. */
+#define RX_REGFILE_TEST_CTRL_TESTBUS_EN 0x00000001
+/* Disable
+#define RX_REGFILE_TEST_CTRL_TESTBUS_EN_DIS 0x00000000 */
+/** Enable */
+#define RX_REGFILE_TEST_CTRL_TESTBUS_EN_EN 0x00000001
+
+/*! @} */ /* SGMII_REGISTER */
+
+#endif /* _sgmii_reg_h */
diff --git a/drivers/net/falcon/sxgmii_reg.h b/drivers/net/falcon/sxgmii_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/falcon/sxgmii_reg.h
@@ -0,0 +1,572 @@
+/******************************************************************************
+
+                               Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _sxgmii_reg_h
+#define _sxgmii_reg_h
+
+/** \addtogroup SXGMII_REGISTER
+   @{
+*/
+/* access macros */
+#define sxgmii_r32(reg) reg_r32(&sxgmii->reg)
+#define sxgmii_w32(val, reg) reg_w32(val, &sxgmii->reg)
+#define sxgmii_w32_mask(clear, set, reg) reg_w32_mask(clear, set, &sxgmii->reg)
+#define sxgmii_r32_table(reg, idx) reg_r32_table(sxgmii->reg, idx)
+#define sxgmii_w32_table(val, reg, idx) reg_w32_table(val, sxgmii->reg, idx)
+#define sxgmii_w32_table_mask(clear, set, reg, idx) reg_w32_table_mask(clear, set, sxgmii->reg, idx)
+#define sxgmii_adr_table(reg, idx) adr_table(sxgmii->reg, idx)
+
+
+/** SXGMII register structure */
+struct gpon_reg_sxgmii
+{
+   /** TBI_PDI: TBI Submodule PDI Register File */
+   /** Transmit Register Autonegotiation Bit(15:8)
+       Not Specified */
+   unsigned int tbi_pdi_txanegh; /* 0x00000000 */
+   /** Transmit Register Autonegotiation Bit(7:0)
+       Not Specified */
+   unsigned int tbi_pdi_txanegl; /* 0x00000004 */
+   /** Receive Register Autonegotioation Bit(15:8)
+       Not Specified */
+   unsigned int tbi_pdi_rxanegh; /* 0x00000008 */
+   /** Receive Register Autonegotioation Bit(7:0)
+       Not Specified */
+   unsigned int tbi_pdi_rxanegl; /* 0x0000000C */
+   /** Autonegotioation Control Bits of TBI
+       Not Specified */
+   unsigned int tbi_pdi_anegctl; /* 0x00000010 */
+   /** TBI Control Bits
+       Not Specified */
+   unsigned int tbi_pdi_tbictl; /* 0x00000014 */
+   /** TBI Control Bits TX
+       Not Specified */
+   unsigned int tbi_pdi_tbictlt; /* 0x00000018 */
+   /** TBI TEST Control Bits
+       Not Specified */
+   unsigned int tbi_pdi_tbitest; /* 0x0000001C */
+   /** RX Error Counter
+       Not Specified */
+   unsigned int tbi_pdi_rxerr; /* 0x00000020 */
+   /** TBI Status Register
+       Not Specified */
+   unsigned int tbi_pdi_tbistat; /* 0x00000024 */
+   /** Link Partner Status Register
+       Not Specified */
+   unsigned int tbi_pdi_lpstat; /* 0x00000028 */
+   /** Interrupt Status Register
+       Not Specified */
+   unsigned int tbi_pdi_istat; /* 0x0000002C */
+   /** Interrupt Mask Register
+       Not Specified */
+   unsigned int tbi_pdi_imask; /* 0x00000030 */
+   /** S_SGMII_PCS_PDI: SGMII PCS PDI Register File */
+   /** Configuration Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_cfg; /* 0x00000034 */
+   /** Receive Buffer Control Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_rxbctrl; /* 0x00000038 */
+   /** Receive Buffer Configuration Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_rxbcfg; /* 0x0000003C */
+   /** Receive Buffer Status Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_rxbstat; /* 0x00000040 */
+   /** Transmit Buffer Control Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_txbctrl; /* 0x00000044 */
+   /** Transmit Buffer Configuration Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_txbcfg; /* 0x00000048 */
+   /** Transmit Buffer Status Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_txbstat; /* 0x0000004C */
+   /** Debug Control Register
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_dbgctl; /* 0x00000050 */
+   /** SCR1 LSFR Feeback Bit Select
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_scr1bs[4]; /* 0x00000054 */
+   /** SCR2 LSFR Feeback Bit Select
+       Not Specified */
+   unsigned int s_sgmii_pcs_pdi_scr2bs[39]; /* 0x00000064 */
+};
+
+
+/* Fields of "Transmit Register Autonegotiation Bit(15:8)" */
+/** Next Page
+    The NP bit is used by the Next Page function to indicate whether or not this is the last page to be transmitted */
+#define TXANEGH_NP 0x00000080
+/* Last Page
+#define TXANEGH_NP_LAST 0x00000000 */
+/** Additional next page to follow */
+#define TXANEGH_NP_NEXT 0x00000080
+/** Higher Data or Control Bits for Autonegotiation */
+#define TXANEGH_DATAH_MASK 0x0000003F
+/** field offset */
+#define TXANEGH_DATAH_OFFSET 0
+
+/* Fields of "Transmit Register Autonegotiation Bit(7:0)" */
+/** Lower Data or Control Bits for Autonegotiation
+    The TXANEGL must be written after TXANEGH. Writing to that register updates the TX Transmit Register. If Next Page is supported the Controler must write to that Register to go to NEXT_PAGE_WAIT state in ANEG FSM after ANEG Interrupt; */
+#define TXANEGL_DATAL_MASK 0x000000FF
+/** field offset */
+#define TXANEGL_DATAL_OFFSET 0
+
+/* Fields of "Receive Register Autonegotioation Bit(15:8)" */
+/** Next Page
+    The NP bit is used by the Next Page function to indicate whether or not this is the last page to be transmitted */
+#define RXANEGH_NP 0x00000080
+/* Last Page
+#define RXANEGH_NP_LAST 0x00000000 */
+/** Additional next page to follow */
+#define RXANEGH_NP_NEXT 0x00000080
+/** Acknowledge */
+#define RXANEGH_ACK 0x00000040
+/* No Acknowlegde received
+#define RXANEGH_ACK_NAK 0x00000000 */
+/** Higher Data or Control Bits for Autonegotiation */
+#define RXANEGH_DATAH_MASK 0x0000003F
+/** field offset */
+#define RXANEGH_DATAH_OFFSET 0
+
+/* Fields of "Receive Register Autonegotioation Bit(7:0)" */
+/** Lower Data or Control Bits for Autonegotiation */
+#define RXANEGL_DATAL_MASK 0x000000FF
+/** field offset */
+#define RXANEGL_DATAL_OFFSET 0
+
+/* Fields of "Autonegotioation Control Bits of TBI" */
+/** Override Ability */
+#define ANEGCTL_OVRANEG 0x00000020
+/* ANEGEN, RAENG are taken from Hardware Interface
+#define ANEGCTL_OVRANEG_HW_INT 0x00000000 */
+/** Override, ANEGEN RANEG are taken from Registerbits ANEGEN, RANEG */
+#define ANEGCTL_OVRANEG_OVERRIDE 0x00000020
+/** Override Ability
+    If OVRAB is 1 the TX values are taken from Register TXANEGH and TXANEGL */
+#define ANEGCTL_OVRABL 0x00000010
+/* Ability Values are taken from Hardware Interface
+#define ANEGCTL_OVRABL_HW_INT 0x00000000 */
+/** Override, Ability Values are taken from Registers TXANEGH and TXANEGL */
+#define ANEGCTL_OVRABL_OVERRIDE 0x00000010
+/** Restart Autonegotiation Process
+    Bit is cleared by Hardware after FSM Restarts */
+#define ANEGCTL_RANEG 0x00000008
+/* Normal Operation
+#define ANEGCTL_RANEG_NORMAL 0x00000000 */
+/** Restart Autonegotiation Process */
+#define ANEGCTL_RANEG_RESTART 0x00000008
+/** Auto-Negotiation Enable
+    Enable Autonegotiation for TBI Interface */
+#define ANEGCTL_ANEGEN 0x00000004
+/* Autonegotiation is disabled
+#define ANEGCTL_ANEGEN_DISABLE 0x00000000 */
+/** Autonegotiation is enabled */
+#define ANEGCTL_ANEGEN_ENABLE 0x00000004
+/** Link Timer Value
+    Link Timer Values for TBI ANEG FSM. Required Value for Standard TBI is 10 ms */
+#define ANEGCTL_LT_MASK 0x00000003
+/** field offset */
+#define ANEGCTL_LT_OFFSET 0
+/** Timer Delay is 10 us (Simulation) */
+#define ANEGCTL_LT_T_10US 0x00000000
+/** Timer Delay is 1.6 ms (SGMII) */
+#define ANEGCTL_LT_T_1_6MS 0x00000001
+/** Timer Delay is 5 ms */
+#define ANEGCTL_LT_T_5MS 0x00000002
+/** Timer Delay is 10 ms (TBI) */
+#define ANEGCTL_LT_T_10MS 0x00000003
+
+/* Fields of "TBI Control Bits" */
+/** Reverse Bit Order Output
+    Output of 10 Bit encoder is (9:0) or (0:9) */
+#define TBICTL_RVBO 0x00000080
+/* 10 Bit Output according to Standard
+#define TBICTL_RVBO_NORMAL 0x00000000 */
+/** 10 Bit Output with reversed Bit Order */
+#define TBICTL_RVBO_REVERS 0x00000080
+/** Reverse Bit Order Input
+    Input for 10 Bit decoder is (9:0) or (0:9) */
+#define TBICTL_RVBI 0x00000040
+/* 10 Bit Input according to Standard
+#define TBICTL_RVBI_NORMAL 0x00000000 */
+/** 10 Bit Input with reversed Bit Order */
+#define TBICTL_RVBI_REVERS 0x00000040
+/** Carrier Sense OFF
+    CRS Generation can be switched off especially for device which habe trouble with that in Half Duplex mode */
+#define TBICTL_CRSOFF 0x00000020
+/* Carrier Sense is always generated in HD and FD
+#define TBICTL_CRSOFF_ON 0x00000000 */
+/** Carrier Sense is never generated, forced to 0 */
+#define TBICTL_CRSOFF_OFF 0x00000020
+/** Carrier Sense Extension for Sequence T/R/R/
+    Select Generation of Carrier Extension in Case of TBI Sequence /T/R/R/K28.5 according to Figure 36-7b of IEEE Std 802.3 */
+#define TBICTL_CRSTRR 0x00000010
+/* No Generate Carrier Extension
+#define TBICTL_CRSTRR_NO 0x00000000 */
+/** Generate Carrier Extension */
+#define TBICTL_CRSTRR_YES 0x00000010
+/** Repeater Mode of TBI
+    Enable Repeater Operation for TBI Interface */
+#define TBICTL_RPM 0x00000008
+/* normal operation
+#define TBICTL_RPM_NORMAL 0x00000000 */
+/** repeater mode enabled */
+#define TBICTL_RPM_REPEATER 0x00000008
+/** Loopback Mode of TBI
+    Enable Loopback Operation for TBI Interface */
+#define TBICTL_LPB 0x00000004
+/* normal operation
+#define TBICTL_LPB_NORMAL 0x00000000 */
+/** loopback enabled */
+#define TBICTL_LPB_LOOPBACK 0x00000004
+/** Enable of TBI Interface
+    Set to 1 for normal operation, if DISABLE the interface clock is disabled */
+#define TBICTL_ENTBI 0x00000002
+/* TBI Interface is disabled
+#define TBICTL_ENTBI_DISABLE 0x00000000 */
+/** TBI Interface is enabled */
+#define TBICTL_ENTBI_ENABLE 0x00000002
+/** Reset of TBI FSM's
+    Reset TBI Interface */
+#define TBICTL_INITTBI 0x00000001
+/* normal operation
+#define TBICTL_INITTBI_NORMAL 0x00000000 */
+/** Initialisation of TBI */
+#define TBICTL_INITTBI_INIT 0x00000001
+
+/* Fields of "TBI Control Bits TX" */
+/** Transmit False Carrier Insertion
+    Select False Carrier Insertion in Case of Transmit according to Figure 36-5 of IEEE Std 802.3 in state XMI_DATA */
+#define TBICTLT_TXFS 0x00000001
+/* No False Carrier Insertion
+#define TBICTLT_TXFS_NO 0x00000000 */
+/** False Carrier Insertion */
+#define TBICTLT_TXFS_YES 0x00000001
+
+/* Fields of "TBI TEST Control Bits" */
+/** Enable RX Error Counter
+    IF enabled the errors from 8b10b Decoder are counted */
+#define TBITEST_RXEREN 0x00000004
+/* RX Error Counter is disabled
+#define TBITEST_RXEREN_DSIABLE 0x00000000 */
+/** RX Error Counter is enabled */
+#define TBITEST_RXEREN_ENABLE 0x00000004
+/** Jitter Test pattern for Transmit
+    IF set the tespattern according to IEEE Std 802.3 chapter 36 A are transmitted */
+#define TBITEST_JITE_MASK 0x00000003
+/** field offset */
+#define TBITEST_JITE_OFFSET 0
+/** Normal Function */
+#define TBITEST_JITE_NO 0x00000000
+/** Transmit High Freuency test pattern 36A.1 */
+#define TBITEST_JITE_HIGH 0x00000001
+/** Transmit Low Freuency test pattern 36A.2 */
+#define TBITEST_JITE_LOW 0x00000002
+/** Transmit Low Freuency test pattern 36A.2 */
+#define TBITEST_JITE_MIXED 0x00000003
+
+/* Fields of "RX Error Counter" */
+/** RX Error Counter
+    If enabled the recieve errors detected by the 8b10b Decoder are counted. The register is cleared by READ */
+#define RXERR_RXERRC_MASK 0x000000FF
+/** field offset */
+#define RXERR_RXERRC_OFFSET 0
+
+/* Fields of "TBI Status Register" */
+/** Sync Status of TBI
+    Sync status of TBI */
+#define TBISTAT_SSTAT 0x00000008
+/* Sync Status of TBI is not OK
+#define TBISTAT_SSTAT_NOK 0x00000000 */
+/** SYnc Status of TBI is OK */
+#define TBISTAT_SSTAT_OK 0x00000008
+/** Autonegotiation Error
+    Error Bit set if Abilities of local device and link partner do not match and connot be resolved this bit is set during Autonegotioation, if Autonegotiation is enabled */
+#define TBISTAT_ANEGERR 0x00000004
+/* No Autonegotiation Error
+#define TBISTAT_ANEGERR_NO_ERROR 0x00000000 */
+/** Autonegotiation Error */
+#define TBISTAT_ANEGERR_ERROR 0x00000004
+/** Link Status of TBI
+    ability match status, if Autonegotiation is enabled */
+#define TBISTAT_ABMSTAT 0x00000002
+/* Autonegotiation State Machine ability does not match
+#define TBISTAT_ABMSTAT_NOK 0x00000000 */
+/** Autonegotiation State Machine ability match */
+#define TBISTAT_ABMSTAT_OK 0x00000002
+/** Link Status of TBI
+    Autonegotiation State of TBI, if Autonegotiation is enabled */
+#define TBISTAT_LSTAT 0x00000001
+/* Autonegotiation State Machine is not in link_ok state
+#define TBISTAT_LSTAT_NOK 0x00000000 */
+/** Autonegotiation State Machine is in link_ok state */
+#define TBISTAT_LSTAT_OK 0x00000001
+
+/* Fields of "Link Partner Status Register" */
+/** SGMII DATA RATE
+    SGMII Data Rate at link partner, set by HW if OVRABL is DISABLED and ANEG is enabled by HW or SW, only valid in SGMII Mode */
+#define LPSTAT_DR_MASK 0x00000060
+/** field offset */
+#define LPSTAT_DR_OFFSET 5
+/** Data Rate is 10 Mb/s */
+#define LPSTAT_DR_DR10 0x00000000
+/** Data Rate is 100 Mb/s */
+#define LPSTAT_DR_DR100 0x00000020
+/** Data Rate is 1000 Mb/s */
+#define LPSTAT_DR_DR1000 0x00000040
+/** Not SGMII Mode */
+#define LPSTAT_DR_INVALID 0x00000060
+/** Remote Fault
+    Remote Fault Status at link partner, set by HW if OVRABL is DISABLED and ANEG is enabled by HW or SW */
+#define LPSTAT_RF_MASK 0x00000018
+/** field offset */
+#define LPSTAT_RF_OFFSET 3
+/** No Error, link OK */
+#define LPSTAT_RF_LINK_OK 0x00000000
+/** Link Failure, Link Down in SGMII Mode */
+#define LPSTAT_RF_LINK_FAIL 0x00000008
+/** Offline, not used in SGMII Mode */
+#define LPSTAT_RF_OFFLINE 0x00000010
+/** Autonegotiation_Error, not used in SGMII Mode */
+#define LPSTAT_RF_ANEG_ERROR 0x00000018
+/** Pause
+    Pause Status after Autonegotiation Priority Resolution at link partner,set by HW if OVRABL is DISABLED and ANEG is enabled by HW or SW */
+#define LPSTAT_PS_MASK 0x00000006
+/** field offset */
+#define LPSTAT_PS_OFFSET 1
+/** No Pause */
+#define LPSTAT_PS_NO 0x00000000
+/** Receive PAUSE */
+#define LPSTAT_PS_RECEIVE 0x00000002
+/** Transmit PAUSE */
+#define LPSTAT_PS_TRANSMIT 0x00000004
+/** Receive and Transmit PAUSE */
+#define LPSTAT_PS_BOTH 0x00000006
+/** Duplex Status
+    Duplex Status after Autonegotiation Priority Resolution, set by HW if OVRABL is DISABLED and ANEG is enabled by HW or SW */
+#define LPSTAT_DPX 0x00000001
+/* Half Duplex Mode
+#define LPSTAT_DPX_HD 0x00000000 */
+/** Full Duplex Mode */
+#define LPSTAT_DPX_FD 0x00000001
+
+/* Fields of "Interrupt Status Register" */
+/** Link Status Change
+    The current status of the link has changed either from OK to NOK or vice versa. The value in TBISTAT.LSTAT has been updated. */
+#define ISTAT_LKSC 0x00000004
+/** Autonegotiation Interrupt Next Page
+    Interrupt generated from Autonegotiation when in COMPLETE_ACKNOWLEDGE state and a next page has been transferred */
+#define ISTAT_ANEG_NP 0x00000002
+/** Autonegotiation Interrupt Base Page
+    Interrupt generated from Autonegotiation when in COMPLETE_ACKNOWLEDGE state and the base page has been transferred */
+#define ISTAT_ANEG_BP 0x00000001
+
+/* Fields of "Interrupt Mask Register" */
+/** Link Statsu change */
+#define IMASK_MLKSC 0x00000004
+/* Unmask LKSC Interrupt
+#define IMASK_MLKSC_UMASK 0x00000000 */
+/** Mask LKSC Interrupt */
+#define IMASK_MLKSC_MASK 0x00000004
+/** Mask Autonegotiation Next Page */
+#define IMASK_MANEG_NP 0x00000002
+/* Unmask Autonegotiation Interrupt
+#define IMASK_MANEG_NP_UMASK 0x00000000 */
+/** Mask Autonegotiation Interrupt */
+#define IMASK_MANEG_NP_MASK 0x00000002
+/** Mask Autonegotiation Base Page */
+#define IMASK_MANEG_BP 0x00000001
+/* Unmask Autonegotiation Interrupt
+#define IMASK_MANEG_BP_UMASK 0x00000000 */
+/** Mask Autonegotiation Interrupt */
+#define IMASK_MANEG_BP_MASK 0x00000001
+
+/* Fields of "Configuration Register" */
+/** Loop Back RX to TX PATH
+    Not Specified */
+#define CFG_LPB 0x00000040
+/* Normal Operation TX
+#define CFG_LPB_NORMAL 0x00000000 */
+/** Loop Back RX to TX Path */
+#define CFG_LPB_LOOP 0x00000040
+/** INIT SGMII RX PATH
+    Not Specified */
+#define CFG_INITRX 0x00000020
+/* Normal Operation TX
+#define CFG_INITRX_NORMAL 0x00000000 */
+/** Reset RX Path */
+#define CFG_INITRX_INIT 0x00000020
+/** INIT SGMII TX PATH
+    Not Specified */
+#define CFG_INITTX 0x00000010
+/* Normal Operation TX
+#define CFG_INITTX_NORMAL 0x00000000 */
+/** Reset TX Path */
+#define CFG_INITTX_INIT 0x00000010
+/** RTE Enable
+    Not Specified */
+#define CFG_RTE_EN 0x00000008
+/* Disable RTE
+#define CFG_RTE_EN_DISABLE 0x00000000 */
+/** Enable RTE */
+#define CFG_RTE_EN_ENABLE 0x00000008
+/** Disable LVDS pair O_N, O_P
+    Not Specified */
+#define CFG_D_DIS 0x00000004
+/* Enable LVDS pair
+#define CFG_D_DIS_ENABLE 0x00000000 */
+/** Disable LVDS pair */
+#define CFG_D_DIS_DISABLE 0x00000004
+/** Disable LVDS pair C_N, C_P
+    Not Specified */
+#define CFG_C_DIS 0x00000002
+/* Enable LVDS pair
+#define CFG_C_DIS_ENABLE 0x00000000 */
+/** Disable LVDS pair */
+#define CFG_C_DIS_DISABLE 0x00000002
+/** Clock Selection
+    Not Specified */
+#define CFG_CLKSEL 0x00000001
+/* Select TXC_LFCLK
+#define CFG_CLKSEL_TXC_LFCLK 0x00000000 */
+/** Select TXD_LFCLK */
+#define CFG_CLKSEL_TXD_LFCLK 0x00000001
+
+/* Fields of "Receive Buffer Control Register" */
+/** Initialize TXB
+    Not Specified */
+#define RXBCTRL_INIT 0x00000002
+/* TXB is normally operating
+#define RXBCTRL_INIT_NORMAL 0x00000000 */
+/** TXB is initialized */
+#define RXBCTRL_INIT_ACTIVE 0x00000002
+/** Enable RXB
+    If this control bit is disabled the RX Buffer will be disabled. */
+#define RXBCTRL_ENAB 0x00000001
+/* RXB is disabled
+#define RXBCTRL_ENAB_DISABLE 0x00000000 */
+/** RXB is enabled */
+#define RXBCTRL_ENAB_ENABLE 0x00000001
+
+/* Fields of "Receive Buffer Configuration Register" */
+/** Delay
+    This register is used to configure the initial delay of the READ POINTER in the RXB. */
+#define RXBCFG_DLY_RP_MASK 0x00000038
+/** field offset */
+#define RXBCFG_DLY_RP_OFFSET 3
+/** Delay
+    This register is used to configure the initial delay of the WRITE POINTER pointer in the RXB. */
+#define RXBCFG_DLY_WP_MASK 0x00000007
+/** field offset */
+#define RXBCFG_DLY_WP_OFFSET 0
+
+/* Fields of "Receive Buffer Status Register" */
+/** Underflow Indicator
+    Not Specified */
+#define RXBSTAT_UNFL 0x00000002
+/* Underflow never detected
+#define RXBSTAT_UNFL_NONE 0x00000000 */
+/** Underflow occurred at least once */
+#define RXBSTAT_UNFL_ONCE 0x00000002
+/** Overflow Indicator
+    Not Specified */
+#define RXBSTAT_OVFL 0x00000001
+/* Overflow never detected
+#define RXBSTAT_OVFL_NONE 0x00000000 */
+/** Overflow occurred at least once */
+#define RXBSTAT_OVFL_ONCE 0x00000001
+
+/* Fields of "Transmit Buffer Control Register" */
+/** Initialize TXB
+    Not Specified */
+#define TXBCTRL_INIT 0x00000002
+/* TXB is normally operating
+#define TXBCTRL_INIT_NORMAL 0x00000000 */
+/** TXB is initialized */
+#define TXBCTRL_INIT_ACTIVE 0x00000002
+/** Enable TXB
+    If this control bit is disabled the TX Buffer will be disabled. */
+#define TXBCTRL_ENAB 0x00000001
+/* TXB is disabled
+#define TXBCTRL_ENAB_DISABLE 0x00000000 */
+/** TXB is enabled */
+#define TXBCTRL_ENAB_ENABLE 0x00000001
+
+/* Fields of "Transmit Buffer Configuration Register" */
+/** Delay
+    This register is used to configure the initial delay of the READ POINTER in the TXB. */
+#define TXBCFG_DLY_RP_MASK 0x00000038
+/** field offset */
+#define TXBCFG_DLY_RP_OFFSET 3
+/** Delay
+    This register is used to configure the initial delay of the WRITE POINTER in the TXB. */
+#define TXBCFG_DLY_WP_MASK 0x00000007
+/** field offset */
+#define TXBCFG_DLY_WP_OFFSET 0
+
+/* Fields of "Transmit Buffer Status Register" */
+/** Underflow Indicator
+    Not Specified */
+#define TXBSTAT_UNFL 0x00000002
+/* Underflow never detected
+#define TXBSTAT_UNFL_NONE 0x00000000 */
+/** Underflow occurred at least once */
+#define TXBSTAT_UNFL_ONCE 0x00000002
+/** Overflow Indicator
+    Not Specified */
+#define TXBSTAT_OVFL 0x00000001
+/* Overflow never detected
+#define TXBSTAT_OVFL_NONE 0x00000000 */
+/** Overflow occurred at least once */
+#define TXBSTAT_OVFL_ONCE 0x00000001
+
+/* Fields of "Debug Control Register" */
+/** SRC1 Enable
+    Enable of SRC2 */
+#define DBGCTL_SRC2EN 0x00000004
+/* Disable SCR2 Mode
+#define DBGCTL_SRC2EN_DISABLE 0x00000000 */
+/** Enable SCR2 Mode */
+#define DBGCTL_SRC2EN_ENABLE 0x00000004
+/** SRC1 Enable
+    Enable of SRC1 */
+#define DBGCTL_SRC1EN 0x00000002
+/* Disable SCR1 Mode
+#define DBGCTL_SRC1EN_DISABLE 0x00000000 */
+/** Enable SCR1 Mode */
+#define DBGCTL_SRC1EN_ENABLE 0x00000002
+/** Debug Enable
+    Enable of DEBUG Mode */
+#define DBGCTL_DBGEN 0x00000001
+/* Disable Debug Mode
+#define DBGCTL_DBGEN_DISABLE 0x00000000 */
+/** Enable Debug Mode */
+#define DBGCTL_DBGEN_ENABLE 0x00000001
+
+/* Fields of "SCR1 LSFR Feeback Bit Select" */
+/** Bit Selection of Feedback Bit
+    Select of LSFR Feedback Bit between 10 to 32 for the 4 EXOR Gates */
+#define SCR1BS_BS_MASK 0x0000001F
+/** field offset */
+#define SCR1BS_BS_OFFSET 0
+
+/* Fields of "SCR2 LSFR Feeback Bit Select" */
+/** Bit Selection of Feedback Bit
+    Select of LSFR Feedback Bit between 10 to 32 for the 4 EXOR Gates */
+#define SCR2BS_BS_MASK 0x0000001F
+/** field offset */
+#define SCR2BS_BS_OFFSET 0
+
+/*! @} */ /* SXGMII_REGISTER */
+
+#endif /* _sxgmii_reg_h */
