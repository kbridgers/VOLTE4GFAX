--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -346,6 +346,11 @@ DESCRIPTION
 .#define bfd_mach_avr4		4
 .#define bfd_mach_avr5		5
 .#define bfd_mach_avr6		6
+.  bfd_arch_avr32,     {* Atmel AVR32 *}
+.#define bfd_mach_avr32_ap	7000
+.#define bfd_mach_avr32_uc	3000
+.#define bfd_mach_avr32_ucr1    3001
+.#define bfd_mach_avr32_ucr2    3002
 .  bfd_arch_bfin,        {* ADI Blackfin *}
 .#define bfd_mach_bfin          1
 .  bfd_arch_cr16,       {* National Semiconductor CompactRISC (ie CR16). *}
@@ -438,6 +443,7 @@ extern const bfd_arch_info_type bfd_alph
 extern const bfd_arch_info_type bfd_arc_arch;
 extern const bfd_arch_info_type bfd_arm_arch;
 extern const bfd_arch_info_type bfd_avr_arch;
+extern const bfd_arch_info_type bfd_avr32_arch;
 extern const bfd_arch_info_type bfd_bfin_arch;
 extern const bfd_arch_info_type bfd_cr16_arch;
 extern const bfd_arch_info_type bfd_cr16c_arch;
@@ -509,6 +515,7 @@ static const bfd_arch_info_type * const 
     &bfd_arc_arch,
     &bfd_arm_arch,
     &bfd_avr_arch,
+    &bfd_avr32_arch,
     &bfd_bfin_arch,
     &bfd_cr16_arch,
     &bfd_cr16c_arch,
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -335,6 +335,10 @@ case "${targ}" in
     targ_underscore=yes
     ;;
 
+  avr32-*-*)
+    targ_defvec=bfd_elf32_avr32_vec
+    ;;
+
   c30-*-*aout* | tic30-*-*aout*)
     targ_defvec=tic30_aout_vec
     ;;
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -619,6 +619,7 @@ do
     bfd_efi_app_ia64_vec)	tb="$tb efi-app-ia64.lo pepigen.lo cofflink.lo"; target_size=64 ;;
     bfd_elf32_am33lin_vec)	tb="$tb elf32-am33lin.lo elf32.lo $elf" ;;
     bfd_elf32_avr_vec)		tb="$tb elf32-avr.lo elf32.lo $elf" ;;
+    bfd_elf32_avr32_vec)	tb="$tb elf32-avr32.lo elf32.lo $elf" ;;
     bfd_elf32_bfin_vec)		tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_bfinfdpic_vec)	tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_big_generic_vec) 	tb="$tb elf32-gen.lo elf32.lo $elf" ;;
--- /dev/null
+++ b/bfd/cpu-avr32.c
@@ -0,0 +1,51 @@
+/* BFD library support routines for AVR32.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+#define N(machine, print, default, next)			\
+  {								\
+    32,				/* 32 bits in a word */		\
+    32,				/* 32 bits in an address */	\
+    8,				/* 8 bits in a byte */		\
+    bfd_arch_avr32,		/* architecture */		\
+    machine,			/* machine */			\
+    "avr32",			/* arch name */			\
+    print,			/* printable name */		\
+    1,				/* section align power */	\
+    default,			/* the default machine? */	\
+    bfd_default_compatible,					\
+    bfd_default_scan,						\
+    next,							\
+  }
+
+static const bfd_arch_info_type cpu_info[] =
+{
+  N(bfd_mach_avr32_ap, "avr32:ap", FALSE, &cpu_info[1]),
+  N(bfd_mach_avr32_uc, "avr32:uc", FALSE, &cpu_info[2]),
+  N(bfd_mach_avr32_ucr1, "avr32:ucr1", FALSE, &cpu_info[3]),
+  N(bfd_mach_avr32_ucr2, "avr32:ucr2", FALSE, NULL),
+};
+
+const bfd_arch_info_type bfd_avr32_arch =
+  N(bfd_mach_avr32_ap, "avr32", TRUE, &cpu_info[0]);
--- /dev/null
+++ b/bfd/elf32-avr32.c
@@ -0,0 +1,3915 @@
+/* AVR32-specific support for 32-bit ELF.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/avr32.h"
+#include "elf32-avr32.h"
+
+#define xDEBUG
+#define xRELAX_DEBUG
+
+#ifdef DEBUG
+# define pr_debug(fmt, args...) fprintf(stderr, fmt, ##args)
+#else
+# define pr_debug(fmt, args...) do { } while (0)
+#endif
+
+#ifdef RELAX_DEBUG
+# define RDBG(fmt, args...) fprintf(stderr, fmt, ##args)
+#else
+# define RDBG(fmt, args...) do { } while (0)
+#endif
+
+/* When things go wrong, we want it to blow up, damnit! */
+#undef BFD_ASSERT
+#undef abort
+#define BFD_ASSERT(expr)					\
+  do								\
+    {								\
+      if (!(expr))						\
+	{							\
+	  bfd_assert(__FILE__, __LINE__);			\
+	  abort();						\
+	}							\
+    }								\
+  while (0)
+
+/* The name of the dynamic interpreter. This is put in the .interp section. */
+#define ELF_DYNAMIC_INTERPRETER		"/lib/ld.so.1"
+
+#define AVR32_GOT_HEADER_SIZE		8
+#define AVR32_FUNCTION_STUB_SIZE	8
+
+#define ELF_R_INFO(x, y) ELF32_R_INFO(x, y)
+#define ELF_R_TYPE(x) ELF32_R_TYPE(x)
+#define ELF_R_SYM(x) ELF32_R_SYM(x)
+
+#define NOP_OPCODE 0xd703
+
+
+/* Mapping between BFD relocations and ELF relocations */
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup(bfd *abfd, bfd_reloc_code_real_type code);
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup(bfd *abfd, const char *r_name);
+
+static void
+avr32_info_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst);
+
+/* Generic HOWTO */
+#define GENH(name, align, size, bitsize, pcrel, bitpos, complain, mask)	\
+  HOWTO(name, align, size, bitsize, pcrel, bitpos,			\
+	complain_overflow_##complain, bfd_elf_generic_reloc, #name,	\
+	FALSE, 0, mask, pcrel)
+
+static reloc_howto_type elf_avr32_howto_table[] = {
+  /*   NAME		 ALN SZ BSZ PCREL  BP COMPLAIN  MASK	    */
+  GENH(R_AVR32_NONE,	  0, 0, 0,  FALSE, 0, dont,	0x00000000),
+
+  GENH(R_AVR32_32,	  0, 2, 32, FALSE, 0, dont,	0xffffffff),
+  GENH(R_AVR32_16,	  0, 1, 16, FALSE, 0, bitfield,	0x0000ffff),
+  GENH(R_AVR32_8,	  0, 0,  8, FALSE, 0, bitfield,	0x000000ff),
+  GENH(R_AVR32_32_PCREL,  0, 2, 32, TRUE,  0, signed,   0xffffffff),
+  GENH(R_AVR32_16_PCREL,  0, 1, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_8_PCREL,	  0, 0,  8, TRUE,  0, signed,   0x000000ff),
+
+  /* Difference between two symbol (sym2 - sym1).  The reloc encodes
+     the value of sym1.  The field contains the difference before any
+     relaxing is done.  */
+  GENH(R_AVR32_DIFF32,	  0, 2, 32, FALSE, 0, dont,	0xffffffff),
+  GENH(R_AVR32_DIFF16,	  0, 1, 16, FALSE, 0, signed,	0x0000ffff),
+  GENH(R_AVR32_DIFF8,	  0, 0,  8, FALSE, 0, signed,	0x000000ff),
+
+  GENH(R_AVR32_GOT32,	  0, 2, 32, FALSE, 0, signed,	0xffffffff),
+  GENH(R_AVR32_GOT16,	  0, 1, 16, FALSE, 0, signed,	0x0000ffff),
+  GENH(R_AVR32_GOT8,	  0, 0,  8, FALSE, 0, signed,	0x000000ff),
+
+  GENH(R_AVR32_21S,	  0, 2, 21, FALSE, 0, signed,	0x1e10ffff),
+  GENH(R_AVR32_16U,	  0, 2, 16, FALSE, 0, unsigned,	0x0000ffff),
+  GENH(R_AVR32_16S,	  0, 2, 16, FALSE, 0, signed,	0x0000ffff),
+  GENH(R_AVR32_8S,	  0, 1,  8, FALSE, 4, signed,	0x00000ff0),
+  GENH(R_AVR32_8S_EXT,	  0, 2,  8, FALSE, 0, signed,	0x000000ff),
+
+  GENH(R_AVR32_22H_PCREL, 1, 2, 21, TRUE,  0, signed,	0x1e10ffff),
+  GENH(R_AVR32_18W_PCREL, 2, 2, 16, TRUE,  0, signed,	0x0000ffff),
+  GENH(R_AVR32_16B_PCREL, 0, 2, 16, TRUE,  0, signed,	0x0000ffff),
+  GENH(R_AVR32_16N_PCREL, 0, 2, 16, TRUE,  0, signed,	0x0000ffff),
+  GENH(R_AVR32_14UW_PCREL, 2, 2, 12, TRUE, 0, unsigned, 0x0000f0ff),
+  GENH(R_AVR32_11H_PCREL, 1, 1, 10, TRUE,  4, signed,	0x00000ff3),
+  GENH(R_AVR32_10UW_PCREL, 2, 2, 8, TRUE,  0, unsigned, 0x000000ff),
+  GENH(R_AVR32_9H_PCREL,  1, 1,  8, TRUE,  4, signed,	0x00000ff0),
+  GENH(R_AVR32_9UW_PCREL, 2, 1,  7, TRUE,  4, unsigned,	0x000007f0),
+
+  GENH(R_AVR32_HI16,	 16, 2, 16, FALSE, 0, dont,	0x0000ffff),
+  GENH(R_AVR32_LO16,	  0, 2, 16, FALSE, 0, dont,	0x0000ffff),
+
+  GENH(R_AVR32_GOTPC,	  0, 2, 32, FALSE, 0, dont,	0xffffffff),
+  GENH(R_AVR32_GOTCALL,   2, 2, 21, FALSE, 0, signed,	0x1e10ffff),
+  GENH(R_AVR32_LDA_GOT,	  2, 2, 21, FALSE, 0, signed,	0x1e10ffff),
+  GENH(R_AVR32_GOT21S,	  0, 2, 21, FALSE, 0, signed,	0x1e10ffff),
+  GENH(R_AVR32_GOT18SW,	  2, 2, 16, FALSE, 0, signed,	0x0000ffff),
+  GENH(R_AVR32_GOT16S,	  0, 2, 16, FALSE, 0, signed,	0x0000ffff),
+  GENH(R_AVR32_GOT7UW,	  2, 1,  5, FALSE, 4, unsigned, 0x000001f0),
+
+  GENH(R_AVR32_32_CPENT,  0, 2, 32, FALSE, 0, dont,	0xffffffff),
+  GENH(R_AVR32_CPCALL,	  2, 2, 16, TRUE,  0, signed,	0x0000ffff),
+  GENH(R_AVR32_16_CP,	  0, 2, 16, TRUE,  0, signed,	0x0000ffff),
+  GENH(R_AVR32_9W_CP,	  2, 1,  7, TRUE,  4, unsigned, 0x000007f0),
+
+  GENH(R_AVR32_RELATIVE,  0, 2, 32, FALSE, 0, signed,	0xffffffff),
+  GENH(R_AVR32_GLOB_DAT,  0, 2, 32, FALSE, 0, dont,	0xffffffff),
+  GENH(R_AVR32_JMP_SLOT,  0, 2, 32, FALSE, 0, dont,	0xffffffff),
+
+  GENH(R_AVR32_ALIGN,	  0, 1, 0,  FALSE, 0, unsigned, 0x00000000),
+
+  GENH(R_AVR32_15S,	  2, 2, 15, FALSE, 0, signed,	0x00007fff),
+};
+
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned char elf_reloc_val;
+};
+
+static const struct elf_reloc_map avr32_reloc_map[] =
+{
+  { BFD_RELOC_NONE,			R_AVR32_NONE },
+
+  { BFD_RELOC_32,			R_AVR32_32 },
+  { BFD_RELOC_16,			R_AVR32_16 },
+  { BFD_RELOC_8,			R_AVR32_8 },
+  { BFD_RELOC_32_PCREL,			R_AVR32_32_PCREL },
+  { BFD_RELOC_16_PCREL,			R_AVR32_16_PCREL },
+  { BFD_RELOC_8_PCREL,			R_AVR32_8_PCREL },
+  { BFD_RELOC_AVR32_DIFF32,		R_AVR32_DIFF32 },
+  { BFD_RELOC_AVR32_DIFF16,		R_AVR32_DIFF16 },
+  { BFD_RELOC_AVR32_DIFF8,		R_AVR32_DIFF8 },
+  { BFD_RELOC_AVR32_GOT32,		R_AVR32_GOT32 },
+  { BFD_RELOC_AVR32_GOT16,		R_AVR32_GOT16 },
+  { BFD_RELOC_AVR32_GOT8,		R_AVR32_GOT8 },
+
+  { BFD_RELOC_AVR32_21S,		R_AVR32_21S },
+  { BFD_RELOC_AVR32_16U,		R_AVR32_16U },
+  { BFD_RELOC_AVR32_16S,		R_AVR32_16S },
+  { BFD_RELOC_AVR32_SUB5,		R_AVR32_16S },
+  { BFD_RELOC_AVR32_8S_EXT,		R_AVR32_8S_EXT },
+  { BFD_RELOC_AVR32_8S,			R_AVR32_8S },
+
+  { BFD_RELOC_AVR32_22H_PCREL,		R_AVR32_22H_PCREL },
+  { BFD_RELOC_AVR32_18W_PCREL,		R_AVR32_18W_PCREL },
+  { BFD_RELOC_AVR32_16B_PCREL,		R_AVR32_16B_PCREL },
+  { BFD_RELOC_AVR32_16N_PCREL,		R_AVR32_16N_PCREL },
+  { BFD_RELOC_AVR32_11H_PCREL,		R_AVR32_11H_PCREL },
+  { BFD_RELOC_AVR32_10UW_PCREL,		R_AVR32_10UW_PCREL },
+  { BFD_RELOC_AVR32_9H_PCREL,		R_AVR32_9H_PCREL },
+  { BFD_RELOC_AVR32_9UW_PCREL,		R_AVR32_9UW_PCREL },
+
+  { BFD_RELOC_HI16,			R_AVR32_HI16 },
+  { BFD_RELOC_LO16,			R_AVR32_LO16 },
+
+  { BFD_RELOC_AVR32_GOTPC,		R_AVR32_GOTPC },
+  { BFD_RELOC_AVR32_GOTCALL,		R_AVR32_GOTCALL },
+  { BFD_RELOC_AVR32_LDA_GOT,		R_AVR32_LDA_GOT },
+  { BFD_RELOC_AVR32_GOT21S,		R_AVR32_GOT21S },
+  { BFD_RELOC_AVR32_GOT18SW,		R_AVR32_GOT18SW },
+  { BFD_RELOC_AVR32_GOT16S,		R_AVR32_GOT16S },
+  /* GOT7UW should never be generated by the assembler */
+
+  { BFD_RELOC_AVR32_32_CPENT,		R_AVR32_32_CPENT },
+  { BFD_RELOC_AVR32_CPCALL,		R_AVR32_CPCALL },
+  { BFD_RELOC_AVR32_16_CP,		R_AVR32_16_CP },
+  { BFD_RELOC_AVR32_9W_CP,		R_AVR32_9W_CP },
+
+  { BFD_RELOC_AVR32_ALIGN,		R_AVR32_ALIGN },
+
+  { BFD_RELOC_AVR32_15S,		R_AVR32_15S },
+};
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				 bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof(avr32_reloc_map) / sizeof(struct elf_reloc_map); i++)
+    {
+      if (avr32_reloc_map[i].bfd_reloc_val == code)
+	return &elf_avr32_howto_table[avr32_reloc_map[i].elf_reloc_val];
+    }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                 const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (elf_avr32_howto_table) / sizeof (elf_avr32_howto_table[0]);
+       i++)
+    if (elf_avr32_howto_table[i].name != NULL
+    && strcasecmp (elf_avr32_howto_table[i].name, r_name) == 0)
+      return &elf_avr32_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an AVR32 ELF reloc.  */
+static void
+avr32_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+		     arelent *cache_ptr,
+		     Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_AVR32_max);
+  cache_ptr->howto = &elf_avr32_howto_table[r_type];
+}
+
+
+/* AVR32 ELF linker hash table and associated hash entries. */
+
+static struct bfd_hash_entry *
+avr32_elf_link_hash_newfunc(struct bfd_hash_entry *entry,
+			    struct bfd_hash_table *table,
+			    const char *string);
+static void
+avr32_elf_copy_indirect_symbol(struct bfd_link_info *info,
+			       struct elf_link_hash_entry *dir,
+			       struct elf_link_hash_entry *ind);
+static struct bfd_link_hash_table *
+avr32_elf_link_hash_table_create(bfd *abfd);
+
+/*
+  Try to limit memory usage to something reasonable when sorting the
+  GOT.  If just a couple of entries end up getting more references
+  than this, it won't affect performance at all, but if there are many
+  of them, we could end up with the wrong symbols being assigned the
+  first GOT entries.
+*/
+#define MAX_NR_GOT_HOLES	2048
+
+/*
+  AVR32 GOT entry.  We need to keep track of refcounts and offsets
+  simultaneously, since we need the offsets during relaxation, and we
+  also want to be able to drop GOT entries during relaxation. In
+  addition to this, we want to keep the list of GOT entries sorted so
+  that we can keep the most-used entries at the lowest offsets.
+*/
+struct got_entry
+{
+  struct got_entry *next;
+  struct got_entry **pprev;
+  int refcount;
+  bfd_signed_vma offset;
+};
+
+struct elf_avr32_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Number of runtime relocations against this symbol.  */
+  unsigned int possibly_dynamic_relocs;
+
+  /* If there are anything but R_AVR32_GOT18 relocations against this
+     symbol, it means that someone may be taking the address of the
+     function, and we should therefore not create a stub.  */
+  bfd_boolean no_fn_stub;
+
+  /* If there is a R_AVR32_32 relocation in a read-only section
+     against this symbol, we could be in trouble. If we're linking a
+     shared library or this symbol is defined in one, it means we must
+     emit a run-time reloc for it and that's not allowed in read-only
+     sections.  */
+  asection *readonly_reloc_sec;
+  bfd_vma readonly_reloc_offset;
+
+  /* Record which frag (if any) contains the symbol.  This is used
+     during relaxation in order to avoid having to update all symbols
+     whenever we move something.  For local symbols, this information
+     is in the local_sym_frag member of struct elf_obj_tdata.  */
+  struct fragment *sym_frag;
+};
+#define avr32_elf_hash_entry(ent) ((struct elf_avr32_link_hash_entry *)(ent))
+
+struct elf_avr32_link_hash_table
+{
+  struct elf_link_hash_table root;
+
+  /* Shortcuts to get to dynamic linker sections.  */
+  asection *sgot;
+  asection *srelgot;
+  asection *sstub;
+
+  /* We use a variation of Pigeonhole Sort to sort the GOT.  After the
+     initial refcounts have been determined, we initialize
+     nr_got_holes to the highest refcount ever seen and allocate an
+     array of nr_got_holes entries for got_hole.  Each GOT entry is
+     then stored in this array at the index given by its refcount.
+
+     When a GOT entry has its refcount decremented during relaxation,
+     it is moved to a lower index in the got_hole array.
+   */
+  struct got_entry **got_hole;
+  int nr_got_holes;
+
+  /* Dynamic relocations to local symbols.  Only used when linking a
+     shared library and -Bsymbolic is not given.  */
+  unsigned int local_dynamic_relocs;
+
+  bfd_boolean relocations_analyzed;
+  bfd_boolean symbols_adjusted;
+  bfd_boolean repeat_pass;
+  bfd_boolean direct_data_refs;
+  unsigned int relax_iteration;
+  unsigned int relax_pass;
+};
+#define avr32_elf_hash_table(p)				\
+  ((struct elf_avr32_link_hash_table *)((p)->hash))
+
+static struct bfd_hash_entry *
+avr32_elf_link_hash_newfunc(struct bfd_hash_entry *entry,
+			    struct bfd_hash_table *table,
+			    const char *string)
+{
+  struct elf_avr32_link_hash_entry *ret = avr32_elf_hash_entry(entry);
+
+  /* Allocate the structure if it hasn't already been allocated by a
+     subclass */
+  if (ret == NULL)
+    ret = (struct elf_avr32_link_hash_entry *)
+      bfd_hash_allocate(table, sizeof(struct elf_avr32_link_hash_entry));
+
+  if (ret == NULL)
+    return NULL;
+
+  memset(ret, 0, sizeof(struct elf_avr32_link_hash_entry));
+
+  /* Give the superclass a chance */
+  ret = (struct elf_avr32_link_hash_entry *)
+    _bfd_elf_link_hash_newfunc((struct bfd_hash_entry *)ret, table, string);
+
+  return (struct bfd_hash_entry *)ret;
+}
+
+/* Copy data from an indirect symbol to its direct symbol, hiding the
+   old indirect symbol.  Process additional relocation information.
+   Also called for weakdefs, in which case we just let
+   _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
+
+static void
+avr32_elf_copy_indirect_symbol(struct bfd_link_info *info,
+			       struct elf_link_hash_entry *dir,
+			       struct elf_link_hash_entry *ind)
+{
+  struct elf_avr32_link_hash_entry *edir, *eind;
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+
+  if (ind->root.type != bfd_link_hash_indirect)
+    return;
+
+  edir = (struct elf_avr32_link_hash_entry *)dir;
+  eind = (struct elf_avr32_link_hash_entry *)ind;
+
+  edir->possibly_dynamic_relocs += eind->possibly_dynamic_relocs;
+  edir->no_fn_stub = edir->no_fn_stub || eind->no_fn_stub;
+}
+
+static struct bfd_link_hash_table *
+avr32_elf_link_hash_table_create(bfd *abfd)
+{
+  struct elf_avr32_link_hash_table *ret;
+
+  ret = bfd_zmalloc(sizeof(*ret));
+  if (ret == NULL)
+    return NULL;
+
+  if (! _bfd_elf_link_hash_table_init(&ret->root, abfd,
+				      avr32_elf_link_hash_newfunc,
+                      sizeof (struct elf_avr32_link_hash_entry)))
+    {
+      free(ret);
+      return NULL;
+    }
+
+  /* Prevent the BFD core from creating bogus got_entry pointers */
+  ret->root.init_got_refcount.glist = NULL;
+  ret->root.init_plt_refcount.glist = NULL;
+  ret->root.init_got_offset.glist = NULL;
+  ret->root.init_plt_offset.glist = NULL;
+
+  return &ret->root.root;
+}
+
+
+/* Initial analysis and creation of dynamic sections and symbols */
+
+static asection *
+create_dynamic_section(bfd *dynobj, const char *name, flagword flags,
+		       unsigned int align_power);
+static struct elf_link_hash_entry *
+create_dynamic_symbol(bfd *dynobj, struct bfd_link_info *info,
+		      const char *name, asection *sec,
+		      bfd_vma offset);
+static bfd_boolean
+avr32_elf_create_got_section (bfd *dynobj, struct bfd_link_info *info);
+static bfd_boolean
+avr32_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info);
+static bfd_boolean
+avr32_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
+		    const Elf_Internal_Rela *relocs);
+static bfd_boolean
+avr32_elf_adjust_dynamic_symbol(struct bfd_link_info *info,
+				struct elf_link_hash_entry *h);
+
+static asection *
+create_dynamic_section(bfd *dynobj, const char *name, flagword flags,
+		       unsigned int align_power)
+{
+  asection *sec;
+
+  sec = bfd_make_section(dynobj, name);
+  if (!sec
+      || !bfd_set_section_flags(dynobj, sec, flags)
+      || !bfd_set_section_alignment(dynobj, sec, align_power))
+    return NULL;
+
+  return sec;
+}
+
+static struct elf_link_hash_entry *
+create_dynamic_symbol(bfd *dynobj, struct bfd_link_info *info,
+		      const char *name, asection *sec,
+		      bfd_vma offset)
+{
+  struct bfd_link_hash_entry *bh = NULL;
+  struct elf_link_hash_entry *h;
+  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+
+  if (!(_bfd_generic_link_add_one_symbol
+	(info, dynobj, name, BSF_GLOBAL, sec, offset, NULL, FALSE,
+	 bed->collect, &bh)))
+    return NULL;
+
+  h = (struct elf_link_hash_entry *)bh;
+  h->def_regular = 1;
+  h->type = STT_OBJECT;
+  h->other = STV_HIDDEN;
+
+  return h;
+}
+
+static bfd_boolean
+avr32_elf_create_got_section (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  flagword flags;
+  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+
+  htab = avr32_elf_hash_table(info);
+  flags = bed->dynamic_sec_flags;
+
+  if (htab->sgot)
+    return TRUE;
+
+  htab->sgot = create_dynamic_section(dynobj, ".got", flags, 2);
+  if (!htab->srelgot)
+    htab->srelgot = create_dynamic_section(dynobj, ".rela.got",
+					   flags | SEC_READONLY, 2);
+
+  if (!htab->sgot || !htab->srelgot)
+    return FALSE;
+
+  htab->root.hgot = create_dynamic_symbol(dynobj, info, "_GLOBAL_OFFSET_TABLE_",
+					  htab->sgot, 0);
+  if (!htab->root.hgot)
+    return FALSE;
+
+  /* Make room for the GOT header */
+  htab->sgot->size += bed->got_header_size;
+
+  return TRUE;
+}
+
+/* (1) Create all dynamic (i.e. linker generated) sections that we may
+   need during the link */
+
+static bfd_boolean
+avr32_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  flagword flags;
+  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+
+  pr_debug("(1) create dynamic sections\n");
+
+  htab = avr32_elf_hash_table(info);
+  flags = bed->dynamic_sec_flags;
+
+  if (!avr32_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  if (!htab->sstub)
+    htab->sstub = create_dynamic_section(dynobj, ".stub",
+					 flags | SEC_READONLY | SEC_CODE, 2);
+
+  if (!htab->sstub)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* (2) Go through all the relocs and count any potential GOT- or
+   PLT-references to each symbol */
+
+static bfd_boolean
+avr32_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
+		    const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_avr32_link_hash_table *htab;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel, *rel_end;
+  struct got_entry **local_got_ents;
+  struct got_entry *got;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  asection *sgot;
+  bfd *dynobj;
+
+  pr_debug("(2) check relocs for %s:<%s> (size 0x%lx)\n",
+	   abfd->filename, sec->name, sec->size);
+
+  if (info->relocatable)
+    return TRUE;
+
+  dynobj = elf_hash_table(info)->dynobj;
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes(abfd);
+  htab = avr32_elf_hash_table(info);
+  local_got_ents = elf_local_got_ents(abfd);
+  sgot = htab->sgot;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned long r_symndx, r_type;
+      struct elf_avr32_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM(rel->r_info);
+      r_type = ELF32_R_TYPE(rel->r_info);
+
+      /* Local symbols use local_got_ents, while others store the same
+	 information in the hash entry */
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  pr_debug("  (2a) processing local symbol %lu\n", r_symndx);
+	  h = NULL;
+	}
+      else
+	{
+	  h = (struct elf_avr32_link_hash_entry *)
+	    sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_avr32_link_hash_entry *)h->root.root.u.i.link;
+	  pr_debug("  (2a) processing symbol %s\n", h->root.root.root.string);
+	}
+
+      /* Some relocs require special sections to be created.  */
+      switch (r_type)
+	{
+	case R_AVR32_GOT32:
+	case R_AVR32_GOT16:
+	case R_AVR32_GOT8:
+	case R_AVR32_GOT21S:
+	case R_AVR32_GOT18SW:
+	case R_AVR32_GOT16S:
+	case R_AVR32_GOT7UW:
+	case R_AVR32_LDA_GOT:
+	case R_AVR32_GOTCALL:
+	  if (rel->r_addend)
+	    {
+	      if (info->callbacks->reloc_dangerous
+		  (info, _("Non-zero addend on GOT-relative relocation"),
+		   abfd, sec, rel->r_offset) == FALSE)
+		return FALSE;
+	    }
+	  /* fall through */
+	case R_AVR32_GOTPC:
+	  if (dynobj == NULL)
+	    elf_hash_table(info)->dynobj = dynobj = abfd;
+	  if (sgot == NULL && !avr32_elf_create_got_section(dynobj, info))
+	    return FALSE;
+	  break;
+	case R_AVR32_32:
+	  /* We may need to create .rela.dyn later on.  */
+	  if (dynobj == NULL
+	      && (info->shared || h != NULL)
+	      && (sec->flags & SEC_ALLOC))
+	    elf_hash_table(info)->dynobj = dynobj = abfd;
+	  break;
+	}
+
+      if (h != NULL && r_type != R_AVR32_GOT18SW)
+	h->no_fn_stub = TRUE;
+
+      switch (r_type)
+	{
+	case R_AVR32_GOT32:
+	case R_AVR32_GOT16:
+	case R_AVR32_GOT8:
+	case R_AVR32_GOT21S:
+	case R_AVR32_GOT18SW:
+	case R_AVR32_GOT16S:
+	case R_AVR32_GOT7UW:
+	case R_AVR32_LDA_GOT:
+	case R_AVR32_GOTCALL:
+	  if (h != NULL)
+	    {
+	      got = h->root.got.glist;
+	      if (!got)
+		{
+		  got = bfd_zalloc(abfd, sizeof(struct got_entry));
+		  if (!got)
+		    return FALSE;
+		  h->root.got.glist = got;
+		}
+	    }
+	  else
+	    {
+	      if (!local_got_ents)
+		{
+		  bfd_size_type size;
+		  bfd_size_type i;
+		  struct got_entry *tmp_entry;
+
+		  size = symtab_hdr->sh_info;
+		  size *= sizeof(struct got_entry *) + sizeof(struct got_entry);
+		  local_got_ents = bfd_zalloc(abfd, size);
+		  if (!local_got_ents)
+		    return FALSE;
+
+		  elf_local_got_ents(abfd) = local_got_ents;
+
+		  tmp_entry = (struct got_entry *)(local_got_ents
+						   + symtab_hdr->sh_info);
+		  for (i = 0; i < symtab_hdr->sh_info; i++)
+		    local_got_ents[i] = &tmp_entry[i];
+		}
+
+	      got = local_got_ents[r_symndx];
+	    }
+
+	  got->refcount++;
+	  if (got->refcount > htab->nr_got_holes)
+	    htab->nr_got_holes = got->refcount;
+	  break;
+
+	case R_AVR32_32:
+	  if ((info->shared || h != NULL)
+	      && (sec->flags & SEC_ALLOC))
+	    {
+	      if (htab->srelgot == NULL)
+		{
+		  htab->srelgot = create_dynamic_section(dynobj, ".rela.got",
+							 bed->dynamic_sec_flags
+							 | SEC_READONLY, 2);
+		  if (htab->srelgot == NULL)
+		    return FALSE;
+		}
+
+	      if (sec->flags & SEC_READONLY
+		  && !h->readonly_reloc_sec)
+		{
+		  h->readonly_reloc_sec = sec;
+		  h->readonly_reloc_offset = rel->r_offset;
+		}
+
+	      if (h != NULL)
+		{
+		  pr_debug("Non-GOT reference to symbol %s\n",
+			   h->root.root.root.string);
+		  h->possibly_dynamic_relocs++;
+		}
+	      else
+		{
+		  pr_debug("Non-GOT reference to local symbol %lu\n",
+			   r_symndx);
+		  htab->local_dynamic_relocs++;
+		}
+	    }
+
+	  break;
+
+	  /* TODO: GNU_VTINHERIT and GNU_VTENTRY */
+	}
+    }
+
+  return TRUE;
+}
+
+/* (3) Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+avr32_elf_adjust_dynamic_symbol(struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct elf_avr32_link_hash_entry *havr;
+  bfd *dynobj;
+
+  pr_debug("(3) adjust dynamic symbol %s\n", h->root.root.string);
+
+  htab = avr32_elf_hash_table(info);
+  havr = (struct elf_avr32_link_hash_entry *)h;
+  dynobj = elf_hash_table(info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->u.weakdef != NULL
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* We don't want dynamic relocations in read-only sections. */
+  if (havr->readonly_reloc_sec)
+    {
+      if (info->callbacks->reloc_dangerous
+	  (info, _("dynamic relocation in read-only section"),
+	   havr->readonly_reloc_sec->owner, havr->readonly_reloc_sec,
+	   havr->readonly_reloc_offset) == FALSE)
+	return FALSE;
+    }
+
+  /* If this is a function, create a stub if possible and set the
+     symbol to the stub location.  */
+  if (0 && !havr->no_fn_stub)
+    {
+      if (!h->def_regular)
+	{
+	  asection *s = htab->sstub;
+
+	  BFD_ASSERT(s != NULL);
+
+	  h->root.u.def.section = s;
+	  h->root.u.def.value = s->size;
+	  h->plt.offset = s->size;
+	  s->size += AVR32_FUNCTION_STUB_SIZE;
+
+	  return TRUE;
+	}
+    }
+  else if (h->type == STT_FUNC)
+    {
+      /* This will set the entry for this symbol in the GOT to 0, and
+	 the dynamic linker will take care of this. */
+      h->root.u.def.value = 0;
+      return TRUE;
+    }
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT(h->u.weakdef->root.type == bfd_link_hash_defined
+		 || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  return TRUE;
+}
+
+
+/* Garbage-collection of unused sections */
+
+static asection *
+avr32_elf_gc_mark_hook(asection *sec,
+		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
+		       Elf_Internal_Rela *rel,
+		       struct elf_link_hash_entry *h,
+		       Elf_Internal_Sym *sym)
+{
+  if (h)
+    {
+      switch (ELF32_R_TYPE(rel->r_info))
+	{
+	  /* TODO: VTINHERIT/VTENTRY */
+	default:
+	  switch (h->root.type)
+	    {
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      return h->root.u.def.section;
+
+	    case bfd_link_hash_common:
+	      return h->root.u.c.p->section;
+
+	    default:
+	      break;
+	    }
+	}
+    }
+  else
+    return bfd_section_from_elf_index(sec->owner, sym->st_shndx);
+
+  return NULL;
+}
+
+/* Update the GOT entry reference counts for the section being removed. */
+static bfd_boolean
+avr32_elf_gc_sweep_hook(bfd *abfd,
+			struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			asection *sec,
+			const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_avr32_link_hash_entry **sym_hashes;
+  struct got_entry **local_got_ents;
+  const Elf_Internal_Rela *rel, *relend;
+
+  if (!(sec->flags & SEC_ALLOC))
+    return TRUE;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  sym_hashes = (struct elf_avr32_link_hash_entry **)elf_sym_hashes(abfd);
+  local_got_ents = elf_local_got_ents(abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_avr32_link_hash_entry *h = NULL;
+
+      r_symndx = ELF32_R_SYM(rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.root.type == bfd_link_hash_indirect
+		 || h->root.root.type == bfd_link_hash_warning)
+	    h = (struct elf_avr32_link_hash_entry *)h->root.root.u.i.link;
+	}
+
+      r_type = ELF32_R_TYPE(rel->r_info);
+
+      switch (r_type)
+	{
+	case R_AVR32_GOT32:
+	case R_AVR32_GOT16:
+	case R_AVR32_GOT8:
+	case R_AVR32_GOT21S:
+	case R_AVR32_GOT18SW:
+	case R_AVR32_GOT16S:
+	case R_AVR32_GOT7UW:
+	case R_AVR32_LDA_GOT:
+	case R_AVR32_GOTCALL:
+	  if (h)
+	    h->root.got.glist->refcount--;
+	  else
+	    local_got_ents[r_symndx]->refcount--;
+	  break;
+
+	case R_AVR32_32:
+	  if (info->shared || h)
+	    {
+	      if (h)
+		h->possibly_dynamic_relocs--;
+	      else
+		avr32_elf_hash_table(info)->local_dynamic_relocs--;
+	    }
+
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Sizing and refcounting of dynamic sections */
+
+static void
+insert_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got);
+static void
+unref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got);
+static void
+ref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got);
+static bfd_boolean
+assign_got_offsets(struct elf_avr32_link_hash_table *htab);
+static bfd_boolean
+allocate_dynrelocs(struct elf_link_hash_entry *h, void *_info);
+static bfd_boolean
+avr32_elf_size_dynamic_sections (bfd *output_bfd,
+				 struct bfd_link_info *info);
+
+static void
+insert_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
+{
+  /* Any entries with got_refcount > htab->nr_got_holes end up in the
+   * last pigeonhole without any sorting. We expect the number of such
+   * entries to be small, so it is very unlikely to affect
+   * performance.  */
+  int entry = got->refcount;
+
+  if (entry > htab->nr_got_holes)
+    entry = htab->nr_got_holes;
+
+  got->pprev = &htab->got_hole[entry];
+  got->next = htab->got_hole[entry];
+
+  if (got->next)
+    got->next->pprev = &got->next;
+
+  htab->got_hole[entry] = got;
+}
+
+/* Decrement the refcount of a GOT entry and update its position in
+   the pigeonhole array.  */
+static void
+unref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
+{
+  BFD_ASSERT(got->refcount > 0);
+
+  if (got->next)
+    got->next->pprev = got->pprev;
+
+  *(got->pprev) = got->next;
+  got->refcount--;
+  insert_got_entry(htab, got);
+}
+
+static void
+ref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
+{
+  if (got->next)
+    got->next->pprev = got->pprev;
+
+  *(got->pprev) = got->next;
+  got->refcount++;
+  insert_got_entry(htab, got);
+
+  BFD_ASSERT(got->refcount > 0);
+}
+
+/* Assign offsets to all GOT entries we intend to keep.  The entries
+   that are referenced most often are placed at low offsets so that we
+   can use compact instructions as much as possible.
+
+   Returns TRUE if any offsets or the total size of the GOT changed.  */
+
+static bfd_boolean
+assign_got_offsets(struct elf_avr32_link_hash_table *htab)
+{
+  struct got_entry *got;
+  bfd_size_type got_size = 0;
+  bfd_boolean changed = FALSE;
+  bfd_signed_vma offset;
+  int i;
+
+  /* The GOT header provides the address of the DYNAMIC segment, so
+     we need that even if the GOT is otherwise empty.  */
+  if (htab->root.dynamic_sections_created)
+    got_size = AVR32_GOT_HEADER_SIZE;
+
+  for (i = htab->nr_got_holes; i > 0; i--)
+    {
+      got = htab->got_hole[i];
+      while (got)
+	{
+	  if (got->refcount > 0)
+	    {
+	      offset = got_size;
+	      if (got->offset != offset)
+		{
+		  RDBG("GOT offset changed: %ld -> %ld\n",
+		       got->offset, offset);
+		  changed = TRUE;
+		}
+	      got->offset = offset;
+	      got_size += 4;
+	    }
+	  got = got->next;
+	}
+    }
+
+  if (htab->sgot->size != got_size)
+    {
+      RDBG("GOT size changed: %lu -> %lu\n", htab->sgot->size,
+	   got_size);
+      changed = TRUE;
+    }
+  htab->sgot->size = got_size;
+
+  RDBG("assign_got_offsets: total size %lu (%s)\n",
+       got_size, changed ? "changed" : "no change");
+
+  return changed;
+}
+
+static bfd_boolean
+allocate_dynrelocs(struct elf_link_hash_entry *h, void *_info)
+{
+  struct bfd_link_info *info = _info;
+  struct elf_avr32_link_hash_table *htab;
+  struct elf_avr32_link_hash_entry *havr;
+  struct got_entry *got;
+
+  pr_debug("  (4b) allocate_dynrelocs: %s\n", h->root.root.string);
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    /* When warning symbols are created, they **replace** the "real"
+       entry in the hash table, thus we never get to see the real
+       symbol in a hash traversal.  So look at it now.  */
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  htab = avr32_elf_hash_table(info);
+  havr = (struct elf_avr32_link_hash_entry *)h;
+
+  got = h->got.glist;
+
+  /* If got is NULL, the symbol is never referenced through the GOT */
+  if (got && got->refcount > 0)
+    {
+      insert_got_entry(htab, got);
+
+      /* Shared libraries need relocs for all GOT entries unless the
+	 symbol is forced local or -Bsymbolic is used.  Others need
+	 relocs for everything that is not guaranteed to be defined in
+	 a regular object.  */
+      if ((info->shared
+	   && !info->symbolic
+	   && h->dynindx != -1)
+	  || (htab->root.dynamic_sections_created
+	      && h->def_dynamic
+	      && !h->def_regular))
+	htab->srelgot->size += sizeof(Elf32_External_Rela);
+    }
+
+  if (havr->possibly_dynamic_relocs
+      && (info->shared
+	  || (elf_hash_table(info)->dynamic_sections_created
+	      && h->def_dynamic
+	      && !h->def_regular)))
+    {
+      pr_debug("Allocating %d dynamic reloc against symbol %s...\n",
+	       havr->possibly_dynamic_relocs, h->root.root.string);
+      htab->srelgot->size += (havr->possibly_dynamic_relocs
+			      * sizeof(Elf32_External_Rela));
+    }
+
+  return TRUE;
+}
+
+/* (4) Calculate the sizes of the linker-generated sections and
+   allocate memory for them.  */
+
+static bfd_boolean
+avr32_elf_size_dynamic_sections (bfd *output_bfd,
+				 struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd *ibfd;
+  bfd_boolean relocs;
+
+  pr_debug("(4) size dynamic sections\n");
+
+  htab = avr32_elf_hash_table(info);
+  dynobj = htab->root.dynobj;
+  BFD_ASSERT(dynobj != NULL);
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Initialize the contents of the .interp section to the name of
+	 the dynamic loader */
+      if (info->executable)
+	{
+	  s = bfd_get_section_by_name(dynobj, ".interp");
+	  BFD_ASSERT(s != NULL);
+	  s->size = sizeof(ELF_DYNAMIC_INTERPRETER);
+	  s->contents = (unsigned char *)ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  if (htab->nr_got_holes > 0)
+    {
+      /* Allocate holes for the pigeonhole sort algorithm */
+      pr_debug("Highest GOT refcount: %d\n", htab->nr_got_holes);
+
+      /* Limit the memory usage by clipping the number of pigeonholes
+       * at a predefined maximum. All entries with a higher refcount
+       * will end up in the last pigeonhole.  */
+    if (htab->nr_got_holes >= MAX_NR_GOT_HOLES)
+    {
+        htab->nr_got_holes = MAX_NR_GOT_HOLES - 1;
+
+        pr_debug("Limiting maximum number of GOT pigeonholes to %u\n",
+                    htab->nr_got_holes);
+    }
+      htab->got_hole = bfd_zalloc(output_bfd,
+				  sizeof(struct got_entry *)
+				  * (htab->nr_got_holes + 1));
+      if (!htab->got_hole)
+	return FALSE;
+
+      /* Set up .got offsets for local syms.  */
+      for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+	{
+	  struct got_entry **local_got;
+	  struct got_entry **end_local_got;
+	  Elf_Internal_Shdr *symtab_hdr;
+	  bfd_size_type locsymcount;
+
+	  pr_debug("  (4a) processing file %s...\n", ibfd->filename);
+
+	  BFD_ASSERT(bfd_get_flavour(ibfd) == bfd_target_elf_flavour);
+
+	  local_got = elf_local_got_ents(ibfd);
+	  if (!local_got)
+	    continue;
+
+	  symtab_hdr = &elf_tdata(ibfd)->symtab_hdr;
+	  locsymcount = symtab_hdr->sh_info;
+	  end_local_got = local_got + locsymcount;
+
+	  for (; local_got < end_local_got; ++local_got)
+	    insert_got_entry(htab, *local_got);
+	}
+    }
+
+  /* Allocate global sym .got entries and space for global sym
+     dynamic relocs */
+  elf_link_hash_traverse(&htab->root, allocate_dynrelocs, info);
+
+  /* Now that we have sorted the GOT entries, we are ready to
+     assign offsets and determine the initial size of the GOT. */
+  if (htab->sgot)
+    assign_got_offsets(htab);
+
+  /* Allocate space for local sym dynamic relocs */
+  BFD_ASSERT(htab->local_dynamic_relocs == 0 || info->shared);
+  if (htab->local_dynamic_relocs)
+    htab->srelgot->size += (htab->local_dynamic_relocs
+			    * sizeof(Elf32_External_Rela));
+
+  /* We now have determined the sizes of the various dynamic
+     sections. Allocate memory for them. */
+  relocs = FALSE;
+  for (s = dynobj->sections; s; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->sgot
+	  || s == htab->sstub)
+	{
+	  /* Strip this section if we don't need it */
+	}
+      else if (strncmp (bfd_get_section_name(dynobj, s), ".rela", 5) == 0)
+	{
+	  if (s->size != 0)
+	    relocs = TRUE;
+
+	  s->reloc_count = 0;
+	}
+      else
+	{
+	  /* It's not one of our sections */
+	  continue;
+	}
+
+      if (s->size == 0)
+	{
+	  /* Strip unneeded sections */
+	  pr_debug("Stripping section %s from output...\n", s->name);
+	  /* deleted function in 2.17
+      _bfd_strip_section_from_output(info, s);
+      */
+	  continue;
+	}
+
+      s->contents = bfd_zalloc(dynobj, s->size);
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in sh_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) _bfd_elf_add_dynamic_entry(info, TAG, VAL)
+
+      if (!add_dynamic_entry(DT_PLTGOT, 0))
+	return FALSE;
+      if (!add_dynamic_entry(DT_AVR32_GOTSZ, 0))
+	return FALSE;
+
+      if (info->executable)
+	{
+	  if (!add_dynamic_entry(DT_DEBUG, 0))
+	    return FALSE;
+	}
+      if (relocs)
+	{
+	  if (!add_dynamic_entry(DT_RELA, 0)
+	      || !add_dynamic_entry(DT_RELASZ, 0)
+	      || !add_dynamic_entry(DT_RELAENT,
+				    sizeof(Elf32_External_Rela)))
+	    return FALSE;
+	}
+    }
+#undef add_dynamic_entry
+
+  return TRUE;
+}
+
+
+/* Access to internal relocations, section contents and symbols.
+   (stolen from the xtensa port)  */
+
+static Elf_Internal_Rela *
+retrieve_internal_relocs (bfd *abfd, asection *sec, bfd_boolean keep_memory);
+static void
+pin_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs);
+static void
+release_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs);
+static bfd_byte *
+retrieve_contents (bfd *abfd, asection *sec, bfd_boolean keep_memory);
+/*
+static void
+pin_contents (asection *sec, bfd_byte *contents);
+*/
+static void
+release_contents (asection *sec, bfd_byte *contents);
+static Elf_Internal_Sym *
+retrieve_local_syms (bfd *input_bfd, bfd_boolean keep_memory);
+/*
+static void
+pin_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf);
+*/
+static void
+release_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf);
+
+/* During relaxation, we need to modify relocations, section contents,
+   and symbol definitions, and we need to keep the original values from
+   being reloaded from the input files, i.e., we need to "pin" the
+   modified values in memory.  We also want to continue to observe the
+   setting of the "keep-memory" flag.  The following functions wrap the
+   standard BFD functions to take care of this for us.  */
+
+static Elf_Internal_Rela *
+retrieve_internal_relocs (bfd *abfd, asection *sec, bfd_boolean keep_memory)
+{
+  /* _bfd_elf_link_read_relocs knows about caching, so no need for us
+     to be clever here.  */
+  return _bfd_elf_link_read_relocs(abfd, sec, NULL, NULL, keep_memory);
+}
+
+static void
+pin_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs)
+{
+  elf_section_data (sec)->relocs = internal_relocs;
+}
+
+static void
+release_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs)
+{
+  if (internal_relocs
+      && elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+}
+
+static bfd_byte *
+retrieve_contents (bfd *abfd, asection *sec, bfd_boolean keep_memory)
+{
+  bfd_byte *contents;
+  bfd_size_type sec_size;
+
+  sec_size = bfd_get_section_limit (abfd, sec);
+  contents = elf_section_data (sec)->this_hdr.contents;
+
+  if (contents == NULL && sec_size != 0)
+    {
+      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+	{
+	  if (contents)
+	    free (contents);
+	  return NULL;
+	}
+      if (keep_memory)
+	elf_section_data (sec)->this_hdr.contents = contents;
+    }
+  return contents;
+}
+
+/*
+static void
+pin_contents (asection *sec, bfd_byte *contents)
+{
+  elf_section_data (sec)->this_hdr.contents = contents;
+}
+*/
+static void
+release_contents (asection *sec, bfd_byte *contents)
+{
+  if (contents && elf_section_data (sec)->this_hdr.contents != contents)
+    free (contents);
+}
+
+static Elf_Internal_Sym *
+retrieve_local_syms (bfd *input_bfd, bfd_boolean keep_memory)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Sym *isymbuf;
+  size_t locsymcount;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  locsymcount = symtab_hdr->sh_info;
+
+  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+  if (isymbuf == NULL && locsymcount != 0)
+    {
+      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
+				      NULL, NULL, NULL);
+      if (isymbuf && keep_memory)
+	symtab_hdr->contents = (unsigned char *) isymbuf;
+    }
+
+  return isymbuf;
+}
+
+/*
+static void
+pin_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf)
+{
+  elf_tdata (input_bfd)->symtab_hdr.contents = (unsigned char *)isymbuf;
+}
+
+*/
+static void
+release_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf)
+{
+  if (isymbuf && (elf_tdata (input_bfd)->symtab_hdr.contents
+		  != (unsigned char *)isymbuf))
+    free (isymbuf);
+}
+
+/* Data structures used during relaxation. */
+
+enum relax_state_id {
+  RS_ERROR = -1,
+  RS_NONE = 0,
+  RS_ALIGN,
+  RS_CPENT,
+  RS_PIC_CALL,
+  RS_PIC_MCALL,
+  RS_PIC_RCALL2,
+  RS_PIC_RCALL1,
+  RS_PIC_LDA,
+  RS_PIC_LDW4,
+  RS_PIC_LDW3,
+  RS_PIC_SUB5,
+  RS_NOPIC_MCALL,
+  RS_NOPIC_RCALL2,
+  RS_NOPIC_RCALL1,
+  RS_NOPIC_LDW4,
+  RS_NOPIC_LDDPC,
+  RS_NOPIC_SUB5,
+  RS_NOPIC_MOV2,
+  RS_NOPIC_MOV1,
+  RS_RCALL2,
+  RS_RCALL1,
+  RS_BRC2,
+  RS_BRC1,
+  RS_BRAL,
+  RS_RJMP,
+  RS_MAX,
+};
+
+enum reference_type {
+  REF_ABSOLUTE,
+  REF_PCREL,
+  REF_CPOOL,
+  REF_GOT,
+};
+
+struct relax_state
+{
+  const char *name;
+  enum relax_state_id id;
+  enum relax_state_id direct;
+  enum relax_state_id next;
+  enum relax_state_id prev;
+
+  enum reference_type reftype;
+
+  unsigned int r_type;
+
+  bfd_vma opcode;
+  bfd_vma opcode_mask;
+
+  bfd_signed_vma range_min;
+  bfd_signed_vma range_max;
+
+  bfd_size_type size;
+};
+
+/*
+ * This is for relocs that
+ *   a) has an addend or is of type R_AVR32_DIFF32, and
+ *   b) references a different section than it's in, and
+ *   c) references a section that is relaxable
+ *
+ * as well as relocs that references the constant pool, in which case
+ * the add_frag member points to the frag containing the constant pool
+ * entry.
+ *
+ * Such relocs must be fixed up whenever we delete any code. Sections
+ * that don't have any relocs with all of the above properties don't
+ * have any additional reloc data, but sections that do will have
+ * additional data for all its relocs.
+ */
+struct avr32_reloc_data
+{
+  struct fragment *add_frag;
+  struct fragment *sub_frag;
+};
+
+/*
+ * A 'fragment' is a relaxable entity, that is, code may be added or
+ * deleted at the end of a fragment. When this happens, all subsequent
+ * fragments in the list will have their offsets updated.
+ */
+struct fragment
+{
+  enum relax_state_id state;
+  enum relax_state_id initial_state;
+
+  Elf_Internal_Rela *rela;
+  bfd_size_type size;
+  bfd_vma offset;
+  int size_adjust;
+  int offset_adjust;
+  bfd_boolean has_grown;
+
+  /* Only used by constant pool entries.  When this drops to zero, the
+     frag is discarded (i.e. size_adjust is set to -4.)  */
+  int refcount;
+};
+
+struct avr32_relax_data
+{
+  unsigned int frag_count;
+  struct fragment *frag;
+  struct avr32_reloc_data *reloc_data;
+
+  /* TRUE if this section has one or more relaxable relocations */
+  bfd_boolean is_relaxable;
+  unsigned int iteration;
+};
+
+struct avr32_section_data
+{
+  struct bfd_elf_section_data elf;
+  struct avr32_relax_data relax_data;
+};
+
+/* Relax state definitions */
+
+#define PIC_MOV2_OPCODE		0xe0600000
+#define PIC_MOV2_MASK		0xe1e00000
+#define PIC_MOV2_RANGE_MIN	(-1048576 * 4)
+#define PIC_MOV2_RANGE_MAX	(1048575 * 4)
+#define PIC_MCALL_OPCODE	0xf0160000
+#define PIC_MCALL_MASK		0xffff0000
+#define PIC_MCALL_RANGE_MIN	(-131072)
+#define PIC_MCALL_RANGE_MAX	(131068)
+#define RCALL2_OPCODE		0xe0a00000
+#define RCALL2_MASK		0xe1ef0000
+#define RCALL2_RANGE_MIN	(-2097152)
+#define RCALL2_RANGE_MAX	(2097150)
+#define RCALL1_OPCODE		0xc00c0000
+#define RCALL1_MASK		0xf00c0000
+#define RCALL1_RANGE_MIN	(-1024)
+#define RCALL1_RANGE_MAX	(1022)
+#define PIC_LDW4_OPCODE		0xecf00000
+#define PIC_LDW4_MASK		0xfff00000
+#define PIC_LDW4_RANGE_MIN	(-32768)
+#define PIC_LDW4_RANGE_MAX	(32767)
+#define PIC_LDW3_OPCODE		0x6c000000
+#define PIC_LDW3_MASK		0xfe000000
+#define PIC_LDW3_RANGE_MIN	(0)
+#define PIC_LDW3_RANGE_MAX	(124)
+#define SUB5_PC_OPCODE		0xfec00000
+#define SUB5_PC_MASK		0xfff00000
+#define SUB5_PC_RANGE_MIN	(-32768)
+#define SUB5_PC_RANGE_MAX	(32767)
+#define NOPIC_MCALL_OPCODE	0xf01f0000
+#define NOPIC_MCALL_MASK	0xffff0000
+#define NOPIC_MCALL_RANGE_MIN	PIC_MCALL_RANGE_MIN
+#define NOPIC_MCALL_RANGE_MAX	PIC_MCALL_RANGE_MAX
+#define NOPIC_LDW4_OPCODE	0xfef00000
+#define NOPIC_LDW4_MASK		0xfff00000
+#define NOPIC_LDW4_RANGE_MIN	PIC_LDW4_RANGE_MIN
+#define NOPIC_LDW4_RANGE_MAX	PIC_LDW4_RANGE_MAX
+#define LDDPC_OPCODE		0x48000000
+#define LDDPC_MASK		0xf8000000
+#define LDDPC_RANGE_MIN		0
+#define LDDPC_RANGE_MAX		508
+
+#define NOPIC_MOV2_OPCODE  0xe0600000
+#define NOPIC_MOV2_MASK        0xe1e00000
+#define NOPIC_MOV2_RANGE_MIN   (-1048576)
+#define NOPIC_MOV2_RANGE_MAX   (1048575)
+#define NOPIC_MOV1_OPCODE  0x30000000
+#define NOPIC_MOV1_MASK        0xf0000000
+#define NOPIC_MOV1_RANGE_MIN   (-128)
+#define NOPIC_MOV1_RANGE_MAX   (127)
+
+/* Only brc2 variants with cond[3] == 0 is considered, since the
+   others are not relaxable.  bral is a special case and is handled
+   separately.  */
+#define BRC2_OPCODE		0xe0800000
+#define BRC2_MASK		0xe1e80000
+#define BRC2_RANGE_MIN		(-2097152)
+#define BRC2_RANGE_MAX		(2097150)
+#define BRC1_OPCODE		0xc0000000
+#define BRC1_MASK		0xf0080000
+#define BRC1_RANGE_MIN		(-256)
+#define BRC1_RANGE_MAX		(254)
+#define BRAL_OPCODE		0xe08f0000
+#define BRAL_MASK		0xe1ef0000
+#define BRAL_RANGE_MIN		BRC2_RANGE_MIN
+#define BRAL_RANGE_MAX		BRC2_RANGE_MAX
+#define RJMP_OPCODE		0xc0080000
+#define RJMP_MASK		0xf00c0000
+#define RJMP_RANGE_MIN		(-1024)
+#define RJMP_RANGE_MAX		(1022)
+
+/* Define a relax state using the GOT  */
+#define RG(id, dir, next, prev, r_type, opc, size)			\
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_GOT,		\
+      R_AVR32_##r_type,	opc##_OPCODE, opc##_MASK,			\
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+/* Define a relax state using the Constant Pool  */
+#define RC(id, dir, next, prev, r_type, opc, size)			\
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_CPOOL,	\
+      R_AVR32_##r_type,	opc##_OPCODE, opc##_MASK,			\
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+
+/* Define a relax state using pc-relative direct reference  */
+#define RP(id, dir, next, prev, r_type, opc, size)			\
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_PCREL,	\
+      R_AVR32_##r_type,	opc##_OPCODE, opc##_MASK,			\
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+
+/* Define a relax state using non-pc-relative direct reference */
+#define RD(id, dir, next, prev, r_type, opc, size)         \
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_ABSOLUTE,   \
+      R_AVR32_##r_type,    opc##_OPCODE, opc##_MASK,           \
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+
+/* Define a relax state that will be handled specially  */
+#define RS(id, r_type, size)						\
+  { "RS_"#id, RS_##id, RS_NONE, RS_NONE, RS_NONE, REF_ABSOLUTE,		\
+      R_AVR32_##r_type, 0, 0, 0, 0, size }
+
+const struct relax_state relax_state[RS_MAX] = {
+  RS(NONE, NONE, 0),
+  RS(ALIGN, ALIGN, 0),
+  RS(CPENT, 32_CPENT, 4),
+
+  RG(PIC_CALL, PIC_RCALL1, PIC_MCALL, NONE, GOTCALL, PIC_MOV2, 10),
+  RG(PIC_MCALL, PIC_RCALL1, NONE, PIC_CALL, GOT18SW, PIC_MCALL, 4),
+  RP(PIC_RCALL2, NONE, PIC_RCALL1, PIC_MCALL, 22H_PCREL, RCALL2, 4),
+  RP(PIC_RCALL1, NONE, NONE, PIC_RCALL2, 11H_PCREL, RCALL1, 2),
+
+  RG(PIC_LDA, PIC_SUB5, PIC_LDW4, NONE, LDA_GOT, PIC_MOV2, 8),
+  RG(PIC_LDW4, PIC_SUB5, PIC_LDW3, PIC_LDA, GOT16S, PIC_LDW4, 4),
+  RG(PIC_LDW3, PIC_SUB5, NONE, PIC_LDW4, GOT7UW, PIC_LDW3, 2),
+  RP(PIC_SUB5, NONE, NONE, PIC_LDW3, 16N_PCREL, SUB5_PC, 4),
+
+  RC(NOPIC_MCALL, NOPIC_RCALL1, NONE, NONE, CPCALL, NOPIC_MCALL, 4),
+  RP(NOPIC_RCALL2, NONE, NOPIC_RCALL1, NOPIC_MCALL, 22H_PCREL, RCALL2, 4),
+  RP(NOPIC_RCALL1, NONE, NONE, NOPIC_RCALL2, 11H_PCREL, RCALL1, 2),
+
+  RC(NOPIC_LDW4, NOPIC_MOV1, NOPIC_LDDPC, NONE, 16_CP, NOPIC_LDW4, 4),
+  RC(NOPIC_LDDPC, NOPIC_MOV1, NONE, NOPIC_LDW4, 9W_CP, LDDPC, 2),
+  RP(NOPIC_SUB5, NOPIC_MOV1, NONE, NOPIC_LDDPC, 16N_PCREL, SUB5_PC, 4),
+  RD(NOPIC_MOV2, NONE, NOPIC_MOV1, NOPIC_SUB5, 21S, NOPIC_MOV2, 4),
+  RD(NOPIC_MOV1, NONE, NONE, NOPIC_MOV2, 8S, NOPIC_MOV1, 2),
+
+  RP(RCALL2, NONE, RCALL1, NONE, 22H_PCREL, RCALL2, 4),
+  RP(RCALL1, NONE, NONE, RCALL2, 11H_PCREL, RCALL1, 2),
+  RP(BRC2, NONE, BRC1, NONE, 22H_PCREL, BRC2, 4),
+  RP(BRC1, NONE, NONE, BRC2, 9H_PCREL, BRC1, 2),
+  RP(BRAL, NONE, RJMP, NONE, 22H_PCREL, BRAL, 4),
+  RP(RJMP, NONE, NONE, BRAL, 11H_PCREL, RJMP, 2),
+};
+
+static bfd_boolean
+avr32_elf_new_section_hook(bfd *abfd, asection *sec)
+{
+  struct avr32_section_data *sdata;
+
+  sdata = bfd_zalloc(abfd, sizeof(struct avr32_section_data));
+  if (!sdata)
+    return FALSE;
+
+  sec->used_by_bfd = sdata;
+  return _bfd_elf_new_section_hook(abfd, sec);
+}
+
+static struct avr32_relax_data *
+avr32_relax_data(asection *sec)
+{
+  struct avr32_section_data *sdata;
+
+  BFD_ASSERT(sec->used_by_bfd);
+
+  sdata = (struct avr32_section_data *)elf_section_data(sec);
+  return &sdata->relax_data;
+}
+
+/* Link-time relaxation */
+
+static bfd_boolean
+avr32_elf_relax_section(bfd *abfd, asection *sec,
+			struct bfd_link_info *info, bfd_boolean *again);
+
+enum relax_pass_id {
+  RELAX_PASS_SIZE_FRAGS,
+  RELAX_PASS_MOVE_DATA,
+};
+
+/* Stolen from the xtensa port */
+static int
+internal_reloc_compare (const void *ap, const void *bp)
+{
+  const Elf_Internal_Rela *a = (const Elf_Internal_Rela *) ap;
+  const Elf_Internal_Rela *b = (const Elf_Internal_Rela *) bp;
+
+  if (a->r_offset != b->r_offset)
+    return (a->r_offset - b->r_offset);
+
+  /* We don't need to sort on these criteria for correctness,
+     but enforcing a more strict ordering prevents unstable qsort
+     from behaving differently with different implementations.
+     Without the code below we get correct but different results
+     on Solaris 2.7 and 2.8.  We would like to always produce the
+     same results no matter the host.  */
+
+  if (a->r_info != b->r_info)
+    return (a->r_info - b->r_info);
+
+  return (a->r_addend - b->r_addend);
+}
+
+static enum relax_state_id
+get_pcrel22_relax_state(bfd *abfd, asection *sec, struct bfd_link_info *info,
+			const Elf_Internal_Rela *rela)
+{
+  bfd_byte *contents;
+  bfd_vma insn;
+  enum relax_state_id rs = RS_NONE;
+
+  contents = retrieve_contents(abfd, sec, info->keep_memory);
+  if (!contents)
+    return RS_ERROR;
+
+  insn = bfd_get_32(abfd, contents + rela->r_offset);
+  if ((insn & RCALL2_MASK) == RCALL2_OPCODE)
+    rs = RS_RCALL2;
+  else if ((insn & BRAL_MASK) == BRAL_OPCODE)
+    /* Optimizing bral -> rjmp gets us into all kinds of
+       trouble with jump tables. Better not do it.  */
+    rs = RS_NONE;
+  else if ((insn & BRC2_MASK) == BRC2_OPCODE)
+    rs = RS_BRC2;
+
+  release_contents(sec, contents);
+
+  return rs;
+}
+
+static enum relax_state_id
+get_initial_relax_state(bfd *abfd, asection *sec, struct bfd_link_info *info,
+			const Elf_Internal_Rela *rela)
+{
+  switch (ELF_R_TYPE(rela->r_info))
+    {
+    case R_AVR32_GOTCALL:
+      return RS_PIC_CALL;
+    case R_AVR32_GOT18SW:
+      return RS_PIC_MCALL;
+    case R_AVR32_LDA_GOT:
+      return RS_PIC_LDA;
+    case R_AVR32_GOT16S:
+      return RS_PIC_LDW4;
+    case R_AVR32_CPCALL:
+      return RS_NOPIC_MCALL;
+    case R_AVR32_16_CP:
+      return RS_NOPIC_LDW4;
+    case R_AVR32_9W_CP:
+      return RS_NOPIC_LDDPC;
+    case R_AVR32_ALIGN:
+      return RS_ALIGN;
+    case R_AVR32_32_CPENT:
+      return RS_CPENT;
+    case R_AVR32_22H_PCREL:
+      return get_pcrel22_relax_state(abfd, sec, info, rela);
+    case R_AVR32_9H_PCREL:
+      return RS_BRC1;
+    default:
+      return RS_NONE;
+    }
+}
+
+static bfd_boolean
+reloc_is_cpool_ref(const Elf_Internal_Rela *rela)
+{
+  switch (ELF_R_TYPE(rela->r_info))
+    {
+    case R_AVR32_CPCALL:
+    case R_AVR32_16_CP:
+    case R_AVR32_9W_CP:
+      return TRUE;
+    default:
+      return FALSE;
+    }
+}
+
+static struct fragment *
+new_frag(bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
+	 struct avr32_relax_data *rd, enum relax_state_id state,
+	 Elf_Internal_Rela *rela)
+{
+  struct fragment *frag;
+  bfd_size_type r_size;
+  bfd_vma r_offset;
+  unsigned int i = rd->frag_count;
+
+  BFD_ASSERT(state >= RS_NONE && state < RS_MAX);
+
+  rd->frag_count++;
+  frag = bfd_realloc(rd->frag, sizeof(struct fragment) * rd->frag_count);
+  if (!frag)
+    return NULL;
+  rd->frag = frag;
+
+  frag += i;
+  memset(frag, 0, sizeof(struct fragment));
+
+  if (state == RS_ALIGN)
+    r_size = (((rela->r_offset + (1 << rela->r_addend) - 1)
+	       & ~((1 << rela->r_addend) - 1)) - rela->r_offset);
+  else
+    r_size = relax_state[state].size;
+
+  if (rela)
+    r_offset = rela->r_offset;
+  else
+    r_offset = sec->size;
+
+  if (i == 0)
+    {
+      frag->offset = 0;
+      frag->size = r_offset + r_size;
+    }
+  else
+    {
+      frag->offset = rd->frag[i - 1].offset + rd->frag[i - 1].size;
+      frag->size = r_offset + r_size - frag->offset;
+    }
+
+  if (state != RS_CPENT)
+    /* Make sure we don't discard this frag */
+    frag->refcount = 1;
+
+  frag->initial_state = frag->state = state;
+  frag->rela = rela;
+
+  return frag;
+}
+
+static struct fragment *
+find_frag(asection *sec, bfd_vma offset)
+{
+  struct fragment *first, *last;
+  struct avr32_relax_data *rd = avr32_relax_data(sec);
+
+  if (rd->frag_count == 0)
+    return NULL;
+
+  first = &rd->frag[0];
+  last = &rd->frag[rd->frag_count - 1];
+
+  /* This may be a reloc referencing the end of a section.  The last
+     frag will never have a reloc associated with it, so its size will
+     never change, thus the offset adjustment of the last frag will
+     always be the same as the offset adjustment of the end of the
+     section.  */
+  if (offset == sec->size)
+    {
+      BFD_ASSERT(last->offset + last->size == sec->size);
+      BFD_ASSERT(!last->rela);
+      return last;
+    }
+
+  while (first <= last)
+    {
+      struct fragment *mid;
+
+      mid = (last - first) / 2 + first;
+      if ((mid->offset + mid->size) <= offset)
+	first = mid + 1;
+      else if (mid->offset > offset)
+	last = mid - 1;
+      else
+	return mid;
+    }
+
+  return NULL;
+}
+
+/* Look through all relocs in a section and determine if any relocs
+   may be affected by relaxation in other sections.  If so, allocate
+   an array of additional relocation data which links the affected
+   relocations to the frag(s) where the relaxation may occur.
+
+   This function also links cpool references to cpool entries and
+   increments the refcount of the latter when this happens.  */
+
+static bfd_boolean
+allocate_reloc_data(bfd *abfd, asection *sec, Elf_Internal_Rela *relocs,
+		    struct bfd_link_info *info)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Sym *isymbuf = NULL;
+  struct avr32_relax_data *rd;
+  unsigned int i;
+  bfd_boolean ret = FALSE;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  rd = avr32_relax_data(sec);
+
+  RDBG("%s<%s>: allocate_reloc_data\n", abfd->filename, sec->name);
+
+  for (i = 0; i < sec->reloc_count; i++)
+    {
+      Elf_Internal_Rela *rel = &relocs[i];
+      asection *sym_sec;
+      unsigned long r_symndx;
+      bfd_vma sym_value;
+
+      if (!rel->r_addend && ELF_R_TYPE(rel->r_info) != R_AVR32_DIFF32
+	  && !reloc_is_cpool_ref(rel))
+	continue;
+
+      r_symndx = ELF_R_SYM(rel->r_info);
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  Elf_Internal_Sym *isym;
+
+	  if (!isymbuf)
+	    isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+	  if (!isymbuf)
+	    return FALSE;
+
+	  isym = &isymbuf[r_symndx];
+	  sym_sec = bfd_section_from_elf_index(abfd, isym->st_shndx);
+	  sym_value = isym->st_value;
+	}
+      else
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = elf_sym_hashes(abfd)[r_symndx - symtab_hdr->sh_info];
+
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+	  if (h->root.type != bfd_link_hash_defined
+	      && h->root.type != bfd_link_hash_defweak)
+	    continue;
+
+	  sym_sec = h->root.u.def.section;
+	  sym_value = h->root.u.def.value;
+	}
+
+      if (sym_sec && avr32_relax_data(sym_sec)->is_relaxable)
+	{
+	  bfd_size_type size;
+	  struct fragment *frag;
+
+	  if (!rd->reloc_data)
+	    {
+	      size = sizeof(struct avr32_reloc_data) * sec->reloc_count;
+	      rd->reloc_data = bfd_zalloc(abfd, size);
+	      if (!rd->reloc_data)
+		goto out;
+	    }
+
+	  RDBG("[%3d] 0x%04lx: target: 0x%lx + 0x%lx",
+	       i, rel->r_offset, sym_value, rel->r_addend);
+
+	  frag = find_frag(sym_sec, sym_value + rel->r_addend);
+	  BFD_ASSERT(frag);
+	  rd->reloc_data[i].add_frag = frag;
+
+	  RDBG(" -> %s<%s>:%04lx\n", sym_sec->owner->filename, sym_sec->name,
+	       frag->rela ? frag->rela->r_offset : sym_sec->size);
+
+	  if (reloc_is_cpool_ref(rel))
+	    {
+	      BFD_ASSERT(ELF_R_TYPE(frag->rela->r_info) == R_AVR32_32_CPENT);
+	      frag->refcount++;
+	    }
+
+	  if (ELF_R_TYPE(rel->r_info) == R_AVR32_DIFF32)
+	    {
+	      bfd_byte *contents;
+	      bfd_signed_vma diff;
+
+	      contents = retrieve_contents(abfd, sec, info->keep_memory);
+	      if (!contents)
+		goto out;
+
+	      diff = bfd_get_signed_32(abfd, contents + rel->r_offset);
+	      frag = find_frag(sym_sec, sym_value + rel->r_addend + diff);
+	      BFD_ASSERT(frag);
+	      rd->reloc_data[i].sub_frag = frag;
+
+	      release_contents(sec, contents);
+	    }
+	}
+    }
+
+  ret = TRUE;
+
+ out:
+  release_local_syms(abfd, isymbuf);
+  return ret;
+}
+
+static bfd_boolean
+global_sym_set_frag(struct elf_avr32_link_hash_entry *havr,
+		    struct bfd_link_info *info ATTRIBUTE_UNUSED)
+{
+  struct fragment *frag;
+  asection *sec;
+
+  if (havr->root.root.type != bfd_link_hash_defined
+      && havr->root.root.type != bfd_link_hash_defweak)
+    return TRUE;
+
+  sec = havr->root.root.u.def.section;
+  if (bfd_is_const_section(sec)
+      || !avr32_relax_data(sec)->is_relaxable)
+    return TRUE;
+
+  frag = find_frag(sec, havr->root.root.u.def.value);
+  if (!frag)
+    {
+      unsigned int i;
+      struct avr32_relax_data *rd = avr32_relax_data(sec);
+
+      RDBG("In %s: No frag for %s <%s+%lu> (limit %lu)\n",
+	   sec->owner->filename, havr->root.root.root.string,
+	   sec->name, havr->root.root.u.def.value, sec->size);
+      for (i = 0; i < rd->frag_count; i++)
+	RDBG("    %8lu - %8lu\n", rd->frag[i].offset,
+	     rd->frag[i].offset + rd->frag[i].size);
+    }
+  BFD_ASSERT(frag);
+
+  havr->sym_frag = frag;
+  return TRUE;
+}
+
+static bfd_boolean
+analyze_relocations(struct bfd_link_info *info)
+{
+  bfd *abfd;
+  asection *sec;
+
+  /* Divide all relaxable sections into fragments */
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    {
+      if (!(elf_elfheader(abfd)->e_flags & EF_AVR32_LINKRELAX))
+	{
+	  if (!(*info->callbacks->warning)
+	      (info, _("input is not relaxable"), NULL, abfd, NULL, 0))
+	    return FALSE;
+	  continue;
+	}
+
+      for (sec = abfd->sections; sec; sec = sec->next)
+	{
+	  struct avr32_relax_data *rd;
+	  struct fragment *frag;
+	  Elf_Internal_Rela *relocs;
+	  unsigned int i;
+	  bfd_boolean ret = TRUE;
+
+	  if (!(sec->flags & SEC_RELOC) || sec->reloc_count == 0)
+	    continue;
+
+	  rd = avr32_relax_data(sec);
+
+	  relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+	  if (!relocs)
+	    return FALSE;
+
+	  qsort(relocs, sec->reloc_count, sizeof(Elf_Internal_Rela),
+		internal_reloc_compare);
+
+	  for (i = 0; i < sec->reloc_count; i++)
+	    {
+	      enum relax_state_id state;
+
+	      ret = FALSE;
+	      state = get_initial_relax_state(abfd, sec, info, &relocs[i]);
+	      if (state == RS_ERROR)
+		break;
+
+	      if (state)
+		{
+		  frag = new_frag(abfd, sec, rd, state, &relocs[i]);
+		  if (!frag)
+		    break;
+
+		  pin_internal_relocs(sec, relocs);
+		  rd->is_relaxable = TRUE;
+		}
+
+	      ret = TRUE;
+	    }
+
+	  release_internal_relocs(sec, relocs);
+	  if (!ret)
+	    return ret;
+
+	  if (rd->is_relaxable)
+	    {
+	      frag = new_frag(abfd, sec, rd, RS_NONE, NULL);
+	      if (!frag)
+		return FALSE;
+	    }
+	}
+    }
+
+  /* Link each global symbol to the fragment where it's defined.  */
+  elf_link_hash_traverse(elf_hash_table(info), global_sym_set_frag, info);
+
+  /* Do the same for local symbols. */
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    {
+      Elf_Internal_Sym *isymbuf, *isym;
+      struct fragment **local_sym_frag;
+      unsigned int i, sym_count;
+
+      sym_count = elf_tdata(abfd)->symtab_hdr.sh_info;
+      if (sym_count == 0)
+	continue;
+
+      local_sym_frag = bfd_zalloc(abfd, sym_count * sizeof(struct fragment *));
+      if (!local_sym_frag)
+	return FALSE;
+      elf_tdata(abfd)->local_sym_frag = local_sym_frag;
+
+      isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+      if (!isymbuf)
+	return FALSE;
+
+      for (i = 0; i < sym_count; i++)
+	{
+	  struct avr32_relax_data *rd;
+	  struct fragment *frag;
+	  asection *sec;
+
+	  isym = &isymbuf[i];
+
+	  sec = bfd_section_from_elf_index(abfd, isym->st_shndx);
+	  if (!sec)
+	    continue;
+
+	  rd = avr32_relax_data(sec);
+	  if (!rd->is_relaxable)
+	    continue;
+
+	  frag = find_frag(sec, isym->st_value);
+	  BFD_ASSERT(frag);
+
+	  local_sym_frag[i] = frag;
+	}
+
+      release_local_syms(abfd, isymbuf);
+    }
+
+  /* And again for relocs with addends and constant pool references */
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    for (sec = abfd->sections; sec; sec = sec->next)
+      {
+	Elf_Internal_Rela *relocs;
+	bfd_boolean ret;
+
+	if (!(sec->flags & SEC_RELOC) || sec->reloc_count == 0)
+	  continue;
+
+	relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+	if (!relocs)
+	  return FALSE;
+
+	ret = allocate_reloc_data(abfd, sec, relocs, info);
+
+	release_internal_relocs(sec, relocs);
+	if (ret == FALSE)
+	  return ret;
+      }
+
+  return TRUE;
+}
+
+static bfd_boolean
+rs_is_good_enough(const struct relax_state *rs, struct fragment *frag,
+		  bfd_vma symval, bfd_vma addr, struct got_entry *got,
+		  struct avr32_reloc_data *ind_data,
+		  bfd_signed_vma offset_adjust)
+{
+  bfd_signed_vma target = 0;
+
+  switch (rs->reftype)
+    {
+    case REF_ABSOLUTE:
+      target = symval;
+      break;
+    case REF_PCREL:
+      target = symval - addr;
+      break;
+    case REF_CPOOL:
+      /* cpool frags are always in the same section and always after
+	 all frags referring to it.  So it's always correct to add in
+	 offset_adjust here.  */
+      target = (ind_data->add_frag->offset + ind_data->add_frag->offset_adjust
+		+ offset_adjust - frag->offset - frag->offset_adjust);
+      break;
+    case REF_GOT:
+      target = got->offset;
+      break;
+    default:
+      abort();
+    }
+
+  if (target >= rs->range_min && target <= rs->range_max)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+static bfd_boolean
+avr32_size_frags(bfd *abfd, asection *sec, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct avr32_relax_data *rd;
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *relocs = NULL;
+  Elf_Internal_Sym *isymbuf = NULL;
+  struct got_entry **local_got_ents;
+  struct fragment **local_sym_frag;
+  bfd_boolean ret = FALSE;
+  bfd_signed_vma delta = 0;
+  unsigned int i;
+
+  htab = avr32_elf_hash_table(info);
+  rd = avr32_relax_data(sec);
+
+  if (sec == htab->sgot)
+    {
+      RDBG("Relaxing GOT section (vma: 0x%lx)\n",
+	   sec->output_section->vma + sec->output_offset);
+      if (assign_got_offsets(htab))
+	htab->repeat_pass = TRUE;
+      return TRUE;
+    }
+
+  if (!rd->is_relaxable)
+    return TRUE;
+
+  if (!sec->rawsize)
+    sec->rawsize = sec->size;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+  if (!relocs)
+    goto out;
+
+  isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+  if (!isymbuf)
+    goto out;
+
+  local_got_ents = elf_local_got_ents(abfd);
+  local_sym_frag = elf_tdata(abfd)->local_sym_frag;
+
+  RDBG("size_frags: %s<%s>\n  vma: 0x%08lx, size: 0x%08lx\n",
+       abfd->filename, sec->name,
+       sec->output_section->vma + sec->output_offset, sec->size);
+
+  for (i = 0; i < rd->frag_count; i++)
+    {
+      struct fragment *frag = &rd->frag[i];
+      struct avr32_reloc_data *r_data = NULL, *ind_data = NULL;
+      const struct relax_state *state, *next_state;
+      struct fragment *target_frag = NULL;
+      asection *sym_sec = NULL;
+      Elf_Internal_Rela *rela;
+      struct got_entry *got;
+      bfd_vma symval, r_offset, addend, addr;
+      bfd_signed_vma size_adjust = 0, distance;
+      unsigned long r_symndx;
+      bfd_boolean defined = TRUE, dynamic = FALSE;
+      unsigned char sym_type;
+
+      frag->offset_adjust += delta;
+      state = next_state = &relax_state[frag->state];
+      rela = frag->rela;
+
+      BFD_ASSERT(state->id == frag->state);
+
+      RDBG("  0x%04lx%c%d: %s [size %ld]", rela ? rela->r_offset : sec->rawsize,
+	   (frag->offset_adjust < 0)?'-':'+',
+	   abs(frag->offset_adjust), state->name, state->size);
+
+      if (!rela)
+	{
+	  RDBG(": no reloc, ignoring\n");
+	  continue;
+	}
+
+      BFD_ASSERT((unsigned int)(rela - relocs) < sec->reloc_count);
+      BFD_ASSERT(state != RS_NONE);
+
+      r_offset = rela->r_offset + frag->offset_adjust;
+      addr = sec->output_section->vma + sec->output_offset + r_offset;
+
+      switch (frag->state)
+	{
+	case RS_ALIGN:
+	  size_adjust = ((addr + (1 << rela->r_addend) - 1)
+			 & ~((1 << rela->r_addend) - 1));
+	  size_adjust -= (sec->output_section->vma + sec->output_offset
+			  + frag->offset + frag->offset_adjust
+			  + frag->size + frag->size_adjust);
+
+	  RDBG(": adjusting size %lu -> %lu\n", frag->size + frag->size_adjust,
+	       frag->size + frag->size_adjust + size_adjust);
+	  break;
+
+	case RS_CPENT:
+	  if (frag->refcount == 0 && frag->size_adjust == 0)
+	    {
+	      RDBG(": discarding frag\n");
+	      size_adjust = -4;
+	    }
+	  else if (frag->refcount > 0 && frag->size_adjust < 0)
+	    {
+	      RDBG(": un-discarding frag\n");
+	      size_adjust = 4;
+	    }
+	  break;
+
+	default:
+	  if (rd->reloc_data)
+	    r_data = &rd->reloc_data[frag->rela - relocs];
+
+	  /* If this is a cpool reference, we want the symbol that the
+	     cpool entry refers to, not the symbol for the cpool entry
+	     itself, as we already know what frag it's in.  */
+	  if (relax_state[frag->initial_state].reftype == REF_CPOOL)
+	    {
+	      Elf_Internal_Rela *irela = r_data->add_frag->rela;
+
+	      r_symndx = ELF_R_SYM(irela->r_info);
+	      addend = irela->r_addend;
+
+	      /* The constant pool must be in the same section as the
+		 reloc referring to it.  */
+	      BFD_ASSERT((unsigned long)(irela - relocs) < sec->reloc_count);
+
+	      ind_data = r_data;
+	      r_data = &rd->reloc_data[irela - relocs];
+	    }
+	  else
+	    {
+	      r_symndx = ELF_R_SYM(rela->r_info);
+	      addend = rela->r_addend;
+	    }
+
+	  /* Get the value of the symbol referred to by the reloc.  */
+	  if (r_symndx < symtab_hdr->sh_info)
+	    {
+	      Elf_Internal_Sym *isym;
+
+	      isym = isymbuf + r_symndx;
+	      symval = 0;
+
+	      RDBG(" local sym %lu: ", r_symndx);
+
+	      if (isym->st_shndx == SHN_UNDEF)
+		defined = FALSE;
+	      else if (isym->st_shndx == SHN_ABS)
+		sym_sec = bfd_abs_section_ptr;
+	      else if (isym->st_shndx == SHN_COMMON)
+		sym_sec = bfd_com_section_ptr;
+	      else
+		sym_sec = bfd_section_from_elf_index(abfd, isym->st_shndx);
+
+	      symval = isym->st_value;
+	      sym_type = ELF_ST_TYPE(isym->st_info);
+	      target_frag = local_sym_frag[r_symndx];
+
+	      if (local_got_ents)
+		got = local_got_ents[r_symndx];
+	      else
+		got = NULL;
+	    }
+	  else
+	    {
+	      /* Global symbol */
+	      unsigned long index;
+	      struct elf_link_hash_entry *h;
+	      struct elf_avr32_link_hash_entry *havr;
+
+	      index = r_symndx - symtab_hdr->sh_info;
+	      h = elf_sym_hashes(abfd)[index];
+	      BFD_ASSERT(h != NULL);
+
+	      while (h->root.type == bfd_link_hash_indirect
+		     || h->root.type == bfd_link_hash_warning)
+		h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+	      havr = (struct elf_avr32_link_hash_entry *)h;
+	      got = h->got.glist;
+
+	      symval = 0;
+
+	      RDBG(" %s: ", h->root.root.string);
+
+	      if (h->root.type != bfd_link_hash_defined
+		  && h->root.type != bfd_link_hash_defweak)
+		{
+		  RDBG("(undef)");
+		  defined = FALSE;
+		}
+	      else if ((info->shared && !info->symbolic && h->dynindx != -1)
+		       || (htab->root.dynamic_sections_created
+			   && h->def_dynamic && !h->def_regular))
+		{
+		  RDBG("(dynamic)");
+		  dynamic = TRUE;
+		  sym_sec = h->root.u.def.section;
+		}
+	      else
+		{
+		  sym_sec = h->root.u.def.section;
+		  symval = h->root.u.def.value;
+		  target_frag = havr->sym_frag;
+		}
+
+	      sym_type = h->type;
+	    }
+
+	  /* Thanks to elf32-ppc for this one.  */
+	  if (sym_sec && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
+	    {
+	      /* At this stage in linking, no SEC_MERGE symbol has been
+		 adjusted, so all references to such symbols need to be
+		 passed through _bfd_merged_section_offset.  (Later, in
+		 relocate_section, all SEC_MERGE symbols *except* for
+		 section symbols have been adjusted.)
+
+	         SEC_MERGE sections are not relaxed by us, as they
+	         shouldn't contain any code.  */
+
+	      BFD_ASSERT(!target_frag && !(r_data && r_data->add_frag));
+
+	      /* gas may reduce relocations against symbols in SEC_MERGE
+		 sections to a relocation against the section symbol when
+		 the original addend was zero.  When the reloc is against
+		 a section symbol we should include the addend in the
+		 offset passed to _bfd_merged_section_offset, since the
+		 location of interest is the original symbol.  On the
+		 other hand, an access to "sym+addend" where "sym" is not
+		 a section symbol should not include the addend;  Such an
+		 access is presumed to be an offset from "sym";  The
+		 location of interest is just "sym".  */
+	      RDBG("\n    MERGE: %s: 0x%lx+0x%lx+0x%lx -> ",
+		   (sym_type == STT_SECTION)?"section":"not section",
+		   sym_sec->output_section->vma + sym_sec->output_offset,
+		   symval, addend);
+
+	      if (sym_type == STT_SECTION)
+		symval += addend;
+
+	      symval = (_bfd_merged_section_offset
+			(abfd, &sym_sec,
+			 elf_section_data(sym_sec)->sec_info, symval));
+
+	      if (sym_type != STT_SECTION)
+		symval += addend;
+	    }
+	  else
+	    symval += addend;
+
+	  if (defined && !dynamic)
+	    {
+	      RDBG("0x%lx+0x%lx",
+		   sym_sec->output_section->vma + sym_sec->output_offset,
+		   symval);
+	      symval += sym_sec->output_section->vma + sym_sec->output_offset;
+	    }
+
+	  if (r_data && r_data->add_frag)
+	    /* If the add_frag pointer is set, it means that this reloc
+	       has an addend that may be affected by relaxation.  */
+	    target_frag = r_data->add_frag;
+
+	  if (target_frag)
+	    {
+	      symval += target_frag->offset_adjust;
+
+	      /* If target_frag comes after this frag in the same
+		 section, we should assume that it will be moved by
+		 the same amount we are.  */
+	      if ((target_frag - rd->frag) < (int)rd->frag_count
+		  && target_frag > frag)
+		symval += delta;
+	    }
+
+	  distance = symval - addr;
+
+	  /* First, try to make a direct reference.  If the symbol is
+	     dynamic or undefined, we must take care not to change its
+	     reference type, that is, we can't make it direct.
+
+	     Also, it seems like some sections may actually be resized
+	     after the relaxation code is done, so we can't really
+	     trust that our "distance" is correct.  There's really no
+	     easy solution to this problem, so we'll just disallow
+	     direct references to SEC_DATA sections.
+
+	     Oh, and .bss isn't actually SEC_DATA, so we disallow
+	     !SEC_HAS_CONTENTS as well. */
+	  if (!dynamic && defined
+	      && (htab->direct_data_refs
+		  || (!(sym_sec->flags & SEC_DATA)
+		      && (sym_sec->flags & SEC_HAS_CONTENTS)))
+	      && next_state->direct)
+	    {
+	      next_state = &relax_state[next_state->direct];
+	      RDBG(" D-> %s", next_state->name);
+	    }
+
+	  /* Iterate backwards until we find a state that fits.  */
+	  while (next_state->prev
+		 && !rs_is_good_enough(next_state, frag, symval, addr,
+				       got, ind_data, delta))
+	    {
+	      next_state = &relax_state[next_state->prev];
+	      RDBG(" P-> %s", next_state->name);
+	    }
+
+	  /* Then try to find the best possible state.  */
+	  while (next_state->next)
+	    {
+	      const struct relax_state *candidate;
+
+	      candidate = &relax_state[next_state->next];
+	      if (!rs_is_good_enough(candidate, frag, symval, addr, got,
+				     ind_data, delta))
+		break;
+
+	      next_state = candidate;
+	      RDBG(" N-> %s", next_state->name);
+	    }
+
+	  RDBG(" [size %ld]\n", next_state->size);
+
+	  BFD_ASSERT(next_state->id);
+	  BFD_ASSERT(!dynamic || next_state->reftype == REF_GOT);
+
+	  size_adjust = next_state->size - state->size;
+
+	  /* There's a theoretical possibility that shrinking one frag
+	     may cause another to grow, which may cause the first one to
+	     grow as well, and we're back where we started.  Avoid this
+	     scenario by disallowing a frag that has grown to ever
+	     shrink again.  */
+	  if (state->reftype == REF_GOT && next_state->reftype != REF_GOT)
+	    {
+	      if (frag->has_grown)
+		next_state = state;
+	      else
+		unref_got_entry(htab, got);
+	    }
+	  else if (state->reftype != REF_GOT && next_state->reftype == REF_GOT)
+	    {
+	      ref_got_entry(htab, got);
+	      frag->has_grown = TRUE;
+	    }
+	  else if (state->reftype == REF_CPOOL
+		   && next_state->reftype != REF_CPOOL)
+	    {
+	      if (frag->has_grown)
+		next_state = state;
+	      else
+		ind_data->add_frag->refcount--;
+	    }
+	  else if (state->reftype != REF_CPOOL
+		   && next_state->reftype == REF_CPOOL)
+	    {
+	      ind_data->add_frag->refcount++;
+	      frag->has_grown = TRUE;
+	    }
+	  else
+	    {
+	      if (frag->has_grown && size_adjust < 0)
+		next_state = state;
+	      else if (size_adjust > 0)
+		frag->has_grown = TRUE;
+	    }
+
+	  size_adjust = next_state->size - state->size;
+	  frag->state = next_state->id;
+
+	  break;
+	}
+
+      if (size_adjust)
+	htab->repeat_pass = TRUE;
+
+      frag->size_adjust += size_adjust;
+      sec->size += size_adjust;
+      delta += size_adjust;
+
+      BFD_ASSERT((frag->offset + frag->offset_adjust
+		  + frag->size + frag->size_adjust)
+		 == (frag[1].offset + frag[1].offset_adjust + delta));
+    }
+
+  ret = TRUE;
+
+ out:
+  release_local_syms(abfd, isymbuf);
+  release_internal_relocs(sec, relocs);
+  return ret;
+}
+
+static bfd_boolean
+adjust_global_symbol(struct elf_avr32_link_hash_entry *havr,
+		     struct bfd_link_info *info ATTRIBUTE_UNUSED)
+{
+  struct elf_link_hash_entry *h = &havr->root;
+
+  if (havr->sym_frag && (h->root.type == bfd_link_hash_defined
+			 || h->root.type == bfd_link_hash_defweak))
+    {
+      RDBG("adjust_global_symbol: %s 0x%08lx -> 0x%08lx\n",
+	   h->root.root.string, h->root.u.def.value,
+	   h->root.u.def.value + havr->sym_frag->offset_adjust);
+      h->root.u.def.value += havr->sym_frag->offset_adjust;
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+adjust_syms(struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  bfd *abfd;
+
+  htab = avr32_elf_hash_table(info);
+  elf_link_hash_traverse(&htab->root, adjust_global_symbol, info);
+
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    {
+      Elf_Internal_Sym *isymbuf;
+      struct fragment **local_sym_frag, *frag;
+      unsigned int i, sym_count;
+
+      sym_count = elf_tdata(abfd)->symtab_hdr.sh_info;
+      if (sym_count == 0)
+	continue;
+
+      isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+      if (!isymbuf)
+	return FALSE;
+
+      local_sym_frag = elf_tdata(abfd)->local_sym_frag;
+
+      for (i = 0; i < sym_count; i++)
+	{
+	  frag = local_sym_frag[i];
+	  if (frag)
+	    {
+	      RDBG("adjust_local_symbol: %s[%u] 0x%08lx -> 0x%08lx\n",
+		   abfd->filename, i, isymbuf[i].st_value,
+		   isymbuf[i].st_value + frag->offset_adjust);
+	      isymbuf[i].st_value += frag->offset_adjust;
+	    }
+	}
+
+      release_local_syms(abfd, isymbuf);
+    }
+
+  htab->symbols_adjusted = TRUE;
+  return TRUE;
+}
+
+static bfd_boolean
+adjust_relocs(bfd *abfd, asection *sec, struct bfd_link_info *info)
+{
+  struct avr32_relax_data *rd;
+  Elf_Internal_Rela *relocs;
+  Elf_Internal_Shdr *symtab_hdr;
+  unsigned int i;
+  bfd_boolean ret = FALSE;
+
+  rd = avr32_relax_data(sec);
+  if (!rd->reloc_data)
+    return TRUE;
+
+  RDBG("adjust_relocs: %s<%s> (count: %u)\n", abfd->filename, sec->name,
+       sec->reloc_count);
+
+  relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+  if (!relocs)
+    return FALSE;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+
+  for (i = 0; i < sec->reloc_count; i++)
+    {
+      Elf_Internal_Rela *rela = &relocs[i];
+      struct avr32_reloc_data *r_data = &rd->reloc_data[i];
+      struct fragment *sym_frag;
+      unsigned long r_symndx;
+
+      if (r_data->add_frag)
+	{
+	  r_symndx = ELF_R_SYM(rela->r_info);
+
+	  if (r_symndx < symtab_hdr->sh_info)
+	    sym_frag = elf_tdata(abfd)->local_sym_frag[r_symndx];
+	  else
+	    {
+	      struct elf_link_hash_entry *h;
+
+	      h = elf_sym_hashes(abfd)[r_symndx - symtab_hdr->sh_info];
+
+	      while (h->root.type == bfd_link_hash_indirect
+		     || h->root.type == bfd_link_hash_warning)
+		h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+	      BFD_ASSERT(h->root.type == bfd_link_hash_defined
+			 || h->root.type == bfd_link_hash_defweak);
+
+	      sym_frag = ((struct elf_avr32_link_hash_entry *)h)->sym_frag;
+	    }
+
+	  RDBG("    addend: 0x%08lx -> 0x%08lx\n",
+	       rela->r_addend,
+	       rela->r_addend + r_data->add_frag->offset_adjust
+	       - (sym_frag ? sym_frag->offset_adjust : 0));
+
+	  /* If this is against a section symbol, we won't find any
+	     sym_frag, so we'll just adjust the addend.  */
+	  rela->r_addend += r_data->add_frag->offset_adjust;
+	  if (sym_frag)
+	    rela->r_addend -= sym_frag->offset_adjust;
+
+	  if (r_data->sub_frag)
+	    {
+	      bfd_byte *contents;
+	      bfd_signed_vma diff;
+
+	      contents = retrieve_contents(abfd, sec, info->keep_memory);
+	      if (!contents)
+		goto out;
+
+	      /* I realize now that sub_frag is misnamed.  It's
+		 actually add_frag which is subtracted in this
+		 case...  */
+	      diff = bfd_get_signed_32(abfd, contents + rela->r_offset);
+	      diff += (r_data->sub_frag->offset_adjust
+		       - r_data->add_frag->offset_adjust);
+	      bfd_put_32(abfd, diff, contents + rela->r_offset);
+
+	      RDBG("   0x%lx: DIFF32 updated: 0x%lx\n", rela->r_offset, diff);
+
+	      release_contents(sec, contents);
+	    }
+	}
+      else
+	BFD_ASSERT(!r_data->sub_frag);
+    }
+
+  ret = TRUE;
+
+ out:
+  release_internal_relocs(sec, relocs);
+  return ret;
+}
+
+static bfd_boolean
+avr32_move_data(bfd *abfd, asection *sec, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct avr32_relax_data *rd;
+  struct fragment *frag, *fragend;
+  Elf_Internal_Rela *relocs = NULL;
+  bfd_byte *contents = NULL;
+  unsigned int i;
+  bfd_boolean ret = FALSE;
+
+  htab = avr32_elf_hash_table(info);
+  rd = avr32_relax_data(sec);
+
+  if (!htab->symbols_adjusted)
+    if (!adjust_syms(info))
+      return FALSE;
+
+  if (rd->is_relaxable)
+    {
+      /* Resize the section first, so that we can be sure that enough
+	 memory is allocated in case the section has grown.  */
+      if (sec->size > sec->rawsize
+	  && elf_section_data(sec)->this_hdr.contents)
+	{
+	  /* We must not use cached data if the section has grown.  */
+	  free(elf_section_data(sec)->this_hdr.contents);
+	  elf_section_data(sec)->this_hdr.contents = NULL;
+	}
+
+      relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+      if (!relocs)
+	goto out;
+      contents = retrieve_contents(abfd, sec, info->keep_memory);
+      if (!contents)
+	goto out;
+
+      fragend = rd->frag + rd->frag_count;
+
+      RDBG("move_data: %s<%s>: relocs=%p, contents=%p\n",
+	   abfd->filename, sec->name, relocs, contents);
+
+      /* First, move the data into place. We must take care to move
+	 frags in the right order so that we don't accidentally
+	 overwrite parts of the next frag.  */
+      for (frag = rd->frag; frag < fragend; frag++)
+	{
+	  RDBG("    0x%08lx%c0x%x: size 0x%lx%c0x%x\n",
+	       frag->offset, frag->offset_adjust >= 0 ? '+' : '-',
+	       abs(frag->offset_adjust),
+	       frag->size, frag->size_adjust >= 0 ? '+' : '-',
+	       abs(frag->size_adjust));
+	  if (frag->offset_adjust > 0)
+	    {
+	      struct fragment *prev = frag - 1;
+	      struct fragment *last;
+
+	      for (last = frag; last < fragend && last->offset_adjust > 0;
+		   last++) ;
+
+	      if (last == fragend)
+		last--;
+
+	      for (frag = last; frag != prev; frag--)
+		{
+		  if (frag->offset_adjust
+		      && frag->size + frag->size_adjust > 0)
+		    {
+		      RDBG("memmove 0x%lx -> 0x%lx (size %lu)\n",
+			   frag->offset, frag->offset + frag->offset_adjust,
+			   frag->size + frag->size_adjust);
+		      memmove(contents + frag->offset + frag->offset_adjust,
+			      contents + frag->offset,
+			      frag->size + frag->size_adjust);
+		    }
+		}
+	      frag = last;
+	    }
+	  else if (frag->offset_adjust && frag->size + frag->size_adjust > 0)
+	    {
+	      RDBG("memmove 0x%lx -> 0x%lx (size %lu)\n",
+		   frag->offset, frag->offset + frag->offset_adjust,
+		   frag->size + frag->size_adjust);
+	      memmove(contents + frag->offset + frag->offset_adjust,
+		      contents + frag->offset,
+		      frag->size + frag->size_adjust);
+	    }
+	}
+
+      i = 0;
+
+      for (frag = rd->frag; frag < fragend; frag++)
+	{
+	  const struct relax_state *state, *istate;
+	  struct avr32_reloc_data *r_data = NULL;
+
+	  istate = &relax_state[frag->initial_state];
+	  state = &relax_state[frag->state];
+
+	  if (rd->reloc_data)
+	    r_data = &rd->reloc_data[frag->rela - relocs];
+
+	  BFD_ASSERT((long)(frag->size + frag->size_adjust) >= 0);
+	  BFD_ASSERT(state->reftype != REF_CPOOL
+		     || r_data->add_frag->refcount > 0);
+
+	  if (istate->reftype == REF_CPOOL && state->reftype != REF_CPOOL)
+	    {
+	      struct fragment *ifrag;
+
+	      /* An indirect reference through the cpool has been
+		 converted to a direct reference.  We must update the
+		 reloc to point to the symbol itself instead of the
+		 constant pool entry.  The reloc type will be updated
+		 later.  */
+	      ifrag = r_data->add_frag;
+	      frag->rela->r_info = ifrag->rela->r_info;
+	      frag->rela->r_addend = ifrag->rela->r_addend;
+
+	      /* Copy the reloc data so the addend will be adjusted
+		 correctly later.  */
+	      *r_data = rd->reloc_data[ifrag->rela - relocs];
+	    }
+
+	  /* Move all relocs covered by this frag.  */
+	  if (frag->rela)
+	    BFD_ASSERT(&relocs[i] <= frag->rela);
+	  else
+	    BFD_ASSERT((frag + 1) == fragend && frag->state == RS_NONE);
+
+	  if (frag == rd->frag)
+	    BFD_ASSERT(i == 0);
+	  else
+	    BFD_ASSERT(&relocs[i] > frag[-1].rela);
+
+	  /* If non-null, frag->rela is the last relocation in the
+	     fragment.  frag->rela can only be null in the last
+	     fragment, so in that case, we'll just do the rest.  */
+	  for (; (i < sec->reloc_count
+		  && (!frag->rela || &relocs[i] <= frag->rela)); i++)
+	    {
+	      RDBG("[%4u] r_offset 0x%08lx -> 0x%08lx\n", i, relocs[i].r_offset,
+		   relocs[i].r_offset + frag->offset_adjust);
+	      relocs[i].r_offset += frag->offset_adjust;
+	    }
+
+	  if (frag->refcount == 0)
+	    {
+	      /* If this frag is to be discarded, make sure we won't
+		 relocate it later on.  */
+	      BFD_ASSERT(frag->state == RS_CPENT);
+	      frag->rela->r_info = ELF_R_INFO(ELF_R_SYM(frag->rela->r_info),
+					    R_AVR32_NONE);
+	    }
+	  else if (frag->state == RS_ALIGN)
+	    {
+	      bfd_vma addr, addr_end;
+
+	      addr = frag->rela->r_offset;
+	      addr_end = (frag->offset + frag->offset_adjust
+			  + frag->size + frag->size_adjust);
+
+	      /* If the section is executable, insert NOPs.
+		 Otherwise, insert zeroes.  */
+	      if (sec->flags & SEC_CODE)
+		{
+		  if (addr & 1)
+		    {
+		      bfd_put_8(abfd, 0, contents + addr);
+		      addr++;
+		    }
+
+		  BFD_ASSERT(!((addr_end - addr) & 1));
+
+		  while (addr < addr_end)
+		    {
+		      bfd_put_16(abfd, NOP_OPCODE, contents + addr);
+		      addr += 2;
+		    }
+		}
+	      else
+		memset(contents + addr, 0, addr_end - addr);
+	    }
+	  else if (state->opcode_mask)
+	    {
+	      bfd_vma insn;
+
+	      /* Update the opcode and the relocation type unless it's a
+		 "special" relax state (i.e. RS_NONE, RS_ALIGN or
+		 RS_CPENT.), in which case the opcode mask is zero.  */
+	      insn = bfd_get_32(abfd, contents + frag->rela->r_offset);
+	      insn &= ~state->opcode_mask;
+	      insn |= state->opcode;
+	      RDBG("    0x%lx: inserting insn %08lx\n",
+		   frag->rela->r_offset, insn);
+	      bfd_put_32(abfd, insn, contents + frag->rela->r_offset);
+
+	      frag->rela->r_info = ELF_R_INFO(ELF_R_SYM(frag->rela->r_info),
+					      state->r_type);
+	    }
+
+	  if ((frag + 1) == fragend)
+	    BFD_ASSERT((frag->offset + frag->size + frag->offset_adjust
+			+ frag->size_adjust) == sec->size);
+	  else
+	    BFD_ASSERT((frag->offset + frag->size + frag->offset_adjust
+			+ frag->size_adjust)
+		       == (frag[1].offset + frag[1].offset_adjust));
+	}
+    }
+
+  /* Adjust reloc addends and DIFF32 differences */
+  if (!adjust_relocs(abfd, sec, info))
+    return FALSE;
+
+  ret = TRUE;
+
+ out:
+  release_contents(sec, contents);
+  release_internal_relocs(sec, relocs);
+  return ret;
+}
+
+static bfd_boolean
+avr32_elf_relax_section(bfd *abfd, asection *sec,
+			struct bfd_link_info *info, bfd_boolean *again)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct avr32_relax_data *rd;
+
+  *again = FALSE;
+  if (info->relocatable)
+    return TRUE;
+
+  htab = avr32_elf_hash_table(info);
+  if ((!(sec->flags & SEC_RELOC) || sec->reloc_count == 0)
+      && sec != htab->sgot)
+    return TRUE;
+
+  if (!htab->relocations_analyzed)
+    {
+      if (!analyze_relocations(info))
+	return FALSE;
+      htab->relocations_analyzed = TRUE;
+    }
+
+  rd = avr32_relax_data(sec);
+
+  if (rd->iteration != htab->relax_iteration)
+    {
+      if (!htab->repeat_pass)
+	htab->relax_pass++;
+      htab->relax_iteration++;
+      htab->repeat_pass = FALSE;
+    }
+
+  rd->iteration++;
+
+  switch (htab->relax_pass)
+    {
+    case RELAX_PASS_SIZE_FRAGS:
+      if (!avr32_size_frags(abfd, sec, info))
+	return FALSE;
+      *again = TRUE;
+      break;
+    case RELAX_PASS_MOVE_DATA:
+      if (!avr32_move_data(abfd, sec, info))
+	return FALSE;
+      break;
+  }
+
+  return TRUE;
+}
+
+
+/* Relocation */
+
+static bfd_reloc_status_type
+avr32_check_reloc_value(asection *sec, Elf_Internal_Rela *rela,
+			bfd_signed_vma relocation, reloc_howto_type *howto);
+static bfd_reloc_status_type
+avr32_final_link_relocate(reloc_howto_type *howto, bfd *input_bfd,
+			  asection *input_section, bfd_byte *contents,
+			  Elf_Internal_Rela *rel, bfd_vma value);
+static bfd_boolean
+avr32_elf_relocate_section(bfd *output_bfd, struct bfd_link_info *info,
+			   bfd *input_bfd, asection *input_section,
+			   bfd_byte *contents, Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections);
+
+
+#define symbol_address(symbol) \
+  symbol->value + symbol->section->output_section->vma \
+  + symbol->section->output_offset
+
+#define avr32_elf_insert_field(size, field, abfd, reloc_entry, data)	\
+  do									\
+    {									\
+      unsigned long x;							\
+      x = bfd_get_##size (abfd, data + reloc_entry->address);		\
+      x &= ~reloc_entry->howto->dst_mask;				\
+      x |= field & reloc_entry->howto->dst_mask;			\
+      bfd_put_##size (abfd, (bfd_vma) x, data + reloc_entry->address);	\
+    }									\
+  while(0)
+
+static bfd_reloc_status_type
+avr32_check_reloc_value(asection *sec ATTRIBUTE_UNUSED,
+			Elf_Internal_Rela *rela ATTRIBUTE_UNUSED,
+			bfd_signed_vma relocation,
+			reloc_howto_type *howto)
+{
+  bfd_vma reloc_u;
+
+  /* We take "complain_overflow_dont" to mean "don't complain on
+     alignment either". This way, we don't have to special-case
+     R_AVR32_HI16 */
+  if (howto->complain_on_overflow == complain_overflow_dont)
+    return bfd_reloc_ok;
+
+  /* Check if the value is correctly aligned */
+  if (relocation & ((1 << howto->rightshift) - 1))
+    {
+      RDBG("misaligned: %s<%s+%lx>: %s: 0x%lx (align %u)\n",
+	   sec->owner->filename, sec->name, rela->r_offset,
+	   howto->name, relocation, howto->rightshift);
+      return bfd_reloc_overflow;
+    }
+
+  /* Now, get rid of the unnecessary bits */
+  relocation >>= howto->rightshift;
+  reloc_u = (bfd_vma)relocation;
+
+  switch (howto->complain_on_overflow)
+    {
+    case complain_overflow_unsigned:
+    case complain_overflow_bitfield:
+      if (reloc_u > (unsigned long)((1 << howto->bitsize) - 1))
+	{
+	  RDBG("unsigned overflow: %s<%s+%lx>: %s: 0x%lx (size %u)\n",
+	       sec->owner->filename, sec->name, rela->r_offset,
+	       howto->name, reloc_u, howto->bitsize);
+	  RDBG("reloc vma: 0x%lx\n",
+	       sec->output_section->vma + sec->output_offset + rela->r_offset);
+
+	  return bfd_reloc_overflow;
+	}
+      break;
+    case complain_overflow_signed:
+      if (relocation > (1 << (howto->bitsize - 1)) - 1)
+	{
+	  RDBG("signed overflow: %s<%s+%lx>: %s: 0x%lx (size %u)\n",
+	       sec->owner->filename, sec->name, rela->r_offset,
+	       howto->name, reloc_u, howto->bitsize);
+	  RDBG("reloc vma: 0x%lx\n",
+	       sec->output_section->vma + sec->output_offset + rela->r_offset);
+
+	  return bfd_reloc_overflow;
+	}
+      if (relocation < -(1 << (howto->bitsize - 1)))
+	{
+	  RDBG("signed overflow: %s<%s+%lx>: %s: -0x%lx (size %u)\n",
+	       sec->owner->filename, sec->name, rela->r_offset,
+	       howto->name, -relocation, howto->bitsize);
+	  RDBG("reloc vma: 0x%lx\n",
+	       sec->output_section->vma + sec->output_offset + rela->r_offset);
+
+	  return bfd_reloc_overflow;
+	}
+      break;
+    default:
+      abort();
+    }
+
+  return bfd_reloc_ok;
+}
+
+
+static bfd_reloc_status_type
+avr32_final_link_relocate(reloc_howto_type *howto,
+			  bfd *input_bfd,
+			  asection *input_section,
+			  bfd_byte *contents,
+			  Elf_Internal_Rela *rel,
+			  bfd_vma value)
+{
+  bfd_vma field;
+  bfd_vma relocation;
+  bfd_reloc_status_type status;
+  bfd_byte *p = contents + rel->r_offset;
+  unsigned long x;
+
+  pr_debug("  (6b) final link relocate\n");
+
+  /* Sanity check the address */
+  if (rel->r_offset > input_section->size)
+    {
+      (*_bfd_error_handler)
+	("%B: %A+0x%lx: offset out of range (section size: 0x%lx)",
+	 input_bfd, input_section, rel->r_offset, input_section->size);
+      return bfd_reloc_outofrange;
+    }
+
+  relocation = value + rel->r_addend;
+
+  if (howto->pc_relative)
+    {
+      bfd_vma addr;
+
+      addr = input_section->output_section->vma
+	+ input_section->output_offset + rel->r_offset;
+      addr &= ~0UL << howto->rightshift;
+      relocation -= addr;
+    }
+
+  switch (ELF32_R_TYPE(rel->r_info))
+    {
+    case R_AVR32_16N_PCREL:
+      /* sub reg, pc, . - (sym + addend) */
+      relocation = -relocation;
+      break;
+    }
+
+  status = avr32_check_reloc_value(input_section, rel, relocation, howto);
+
+  relocation >>= howto->rightshift;
+  if (howto->bitsize == 21)
+    field = (relocation & 0xffff)
+      | ((relocation & 0x10000) << 4)
+      | ((relocation & 0x1e0000) << 8);
+  else if (howto->bitsize == 12)
+    field = (relocation & 0xff) | ((relocation & 0xf00) << 4);
+  else if (howto->bitsize == 10)
+    field = ((relocation & 0xff) << 4)
+      | ((relocation & 0x300) >> 8);
+  else
+    field = relocation << howto->bitpos;
+
+  switch (howto->size)
+    {
+    case 0:
+      x = bfd_get_8 (input_bfd, p);
+      x &= ~howto->dst_mask;
+      x |= field & howto->dst_mask;
+      bfd_put_8 (input_bfd, (bfd_vma) x, p);
+      break;
+    case 1:
+      x = bfd_get_16 (input_bfd, p);
+      x &= ~howto->dst_mask;
+      x |= field & howto->dst_mask;
+      bfd_put_16 (input_bfd, (bfd_vma) x, p);
+      break;
+    case 2:
+      x = bfd_get_32 (input_bfd, p);
+      x &= ~howto->dst_mask;
+      x |= field & howto->dst_mask;
+      bfd_put_32 (input_bfd, (bfd_vma) x, p);
+      break;
+    default:
+      abort();
+    }
+
+  return status;
+}
+
+/* (6) Apply relocations to the normal (non-dynamic) sections */
+
+static bfd_boolean
+avr32_elf_relocate_section(bfd *output_bfd, struct bfd_link_info *info,
+			   bfd *input_bfd, asection *input_section,
+			   bfd_byte *contents, Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections)
+{
+  struct elf_avr32_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *rel, *relend;
+  struct elf_link_hash_entry **sym_hashes;
+  struct got_entry **local_got_ents;
+  asection *sgot;
+  asection *srelgot;
+
+  pr_debug("(6) relocate section %s:<%s> (size 0x%lx)\n",
+	   input_bfd->filename, input_section->name, input_section->size);
+
+  /* If we're doing a partial link, we don't have to do anything since
+     we're using RELA relocations */
+  if (info->relocatable)
+    return TRUE;
+
+  htab = avr32_elf_hash_table(info);
+  symtab_hdr = &elf_tdata(input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes(input_bfd);
+  local_got_ents = elf_local_got_ents(input_bfd);
+  sgot = htab->sgot;
+  srelgot = htab->srelgot;
+
+  relend = relocs + input_section->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_type, r_symndx;
+      reloc_howto_type *howto;
+      Elf_Internal_Sym *sym = NULL;
+      struct elf_link_hash_entry *h = NULL;
+      asection *sec = NULL;
+      bfd_vma value;
+      bfd_vma offset;
+      bfd_reloc_status_type status;
+
+      r_type = ELF32_R_TYPE(rel->r_info);
+      r_symndx = ELF32_R_SYM(rel->r_info);
+
+      if (r_type == R_AVR32_NONE
+	  || r_type == R_AVR32_ALIGN
+	  || r_type == R_AVR32_DIFF32
+	  || r_type == R_AVR32_DIFF16
+	  || r_type == R_AVR32_DIFF8)
+	continue;
+
+      /* Sanity check */
+      if (r_type > R_AVR32_max)
+	{
+	  bfd_set_error(bfd_error_bad_value);
+	  return FALSE;
+	}
+
+      howto = &elf_avr32_howto_table[r_type];
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+
+	  pr_debug("  (6a) processing %s against local symbol %lu\n",
+		   howto->name, r_symndx);
+
+	  /* The following function changes rel->r_addend behind our back. */
+	  value = _bfd_elf_rela_local_sym(output_bfd, sym, &sec, rel);
+	  pr_debug("    => value: %lx, addend: %lx\n", value, rel->r_addend);
+	}
+      else
+	{
+	  if (sym_hashes == NULL)
+	    return FALSE;
+
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+	  pr_debug("  (6a) processing %s against symbol %s\n",
+		   howto->name, h->root.root.string);
+
+	  if (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak)
+	    {
+	      bfd_boolean dyn;
+
+	      dyn = htab->root.dynamic_sections_created;
+	      sec = h->root.u.def.section;
+
+	      if (sec->output_section)
+		value = (h->root.u.def.value
+			 + sec->output_section->vma
+			 + sec->output_offset);
+	      else
+		value = h->root.u.def.value;
+	    }
+	  else if (h->root.type == bfd_link_hash_undefweak)
+	    value = 0;
+	  else if (info->unresolved_syms_in_objects == RM_IGNORE
+		   && ELF_ST_VISIBILITY(h->other) == STV_DEFAULT)
+	    value = 0;
+	  else
+	    {
+	      bfd_boolean err;
+	      err = (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
+		     || ELF_ST_VISIBILITY(h->other) != STV_DEFAULT);
+	      if (!info->callbacks->undefined_symbol
+		  (info, h->root.root.string, input_bfd,
+		   input_section, rel->r_offset, err))
+		return FALSE;
+	      value = 0;
+	    }
+
+	  pr_debug("    => value: %lx, addend: %lx\n", value, rel->r_addend);
+	}
+
+      switch (r_type)
+	{
+	case R_AVR32_GOT32:
+	case R_AVR32_GOT16:
+	case R_AVR32_GOT8:
+	case R_AVR32_GOT21S:
+	case R_AVR32_GOT18SW:
+	case R_AVR32_GOT16S:
+	case R_AVR32_GOT7UW:
+	case R_AVR32_LDA_GOT:
+	case R_AVR32_GOTCALL:
+	  BFD_ASSERT(sgot != NULL);
+
+	  if (h != NULL)
+	    {
+	      BFD_ASSERT(h->got.glist->refcount > 0);
+	      offset = h->got.glist->offset;
+
+	      BFD_ASSERT(offset < sgot->size);
+	      if (!elf_hash_table(info)->dynamic_sections_created
+		  || (h->def_regular
+		      && (!info->shared
+			  || info->symbolic
+			  || h->dynindx == -1)))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local.  */
+		  bfd_put_32(output_bfd, value, sgot->contents + offset);
+		}
+	    }
+	  else
+	    {
+	      BFD_ASSERT(local_got_ents &&
+			 local_got_ents[r_symndx]->refcount > 0);
+	      offset = local_got_ents[r_symndx]->offset;
+
+	      /* Local GOT entries don't have relocs.  If this is a
+		 shared library, the dynamic linker will add the load
+		 address to the initial value at startup.  */
+	      BFD_ASSERT(offset < sgot->size);
+	      pr_debug("Initializing GOT entry at offset %lu: 0x%lx\n",
+		       offset, value);
+	      bfd_put_32 (output_bfd, value, sgot->contents + offset);
+	    }
+
+	  value = sgot->output_offset + offset;
+	  pr_debug("GOT reference: New value %lx\n", value);
+	  break;
+
+	case R_AVR32_GOTPC:
+	  /* This relocation type is for constant pool entries used in
+	     the calculation "Rd = PC - (PC - GOT)", where the
+	     constant pool supplies the constant (PC - GOT)
+	     offset. The symbol value + addend indicates where the
+	     value of PC is taken. */
+	  value -= sgot->output_section->vma;
+	  break;
+
+	case R_AVR32_32_PCREL:
+	  /* We must adjust r_offset to account for discarded data in
+	     the .eh_frame section.  This is probably not the right
+	     way to do this, since AFAICS all other architectures do
+	     it some other way.  I just can't figure out how...  */
+	  {
+	    bfd_vma r_offset;
+
+	    r_offset = _bfd_elf_section_offset(output_bfd, info,
+					       input_section,
+					       rel->r_offset);
+	    if (r_offset == (bfd_vma)-1
+		|| r_offset == (bfd_vma)-2)
+	      continue;
+	    rel->r_offset = r_offset;
+	  }
+	  break;
+
+	case R_AVR32_32:
+	  /* We need to emit a run-time relocation in the following cases:
+	       - we're creating a shared library
+	       - the symbol is not defined in any regular objects
+
+	     Of course, sections that aren't going to be part of the
+	     run-time image will not get any relocs, and undefined
+	     symbols won't have any either (only weak undefined
+	     symbols should get this far).  */
+	  if ((info->shared
+	       || (elf_hash_table(info)->dynamic_sections_created
+		   && h != NULL
+		   && h->def_dynamic
+		   && !h->def_regular))
+	      && r_symndx != 0
+	      && (input_section->flags & SEC_ALLOC))
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      bfd_boolean skip, relocate;
+	      struct elf_avr32_link_hash_entry *avrh;
+
+	      pr_debug("Going to generate dynamic reloc...\n");
+
+	      skip = FALSE;
+	      relocate = FALSE;
+
+	      outrel.r_offset = _bfd_elf_section_offset(output_bfd, info,
+							input_section,
+							rel->r_offset);
+	      if (outrel.r_offset == (bfd_vma)-1)
+		skip = TRUE;
+	      else if (outrel.r_offset == (bfd_vma)-2)
+		skip = TRUE, relocate = TRUE;
+
+	      outrel.r_offset += (input_section->output_section->vma
+				  + input_section->output_offset);
+
+	      pr_debug("    ... offset %lx, dynindx %ld\n",
+		       outrel.r_offset, h ? h->dynindx : -1);
+
+	      if (skip)
+		memset(&outrel, 0, sizeof(outrel));
+	      else
+		{
+		  avrh = (struct elf_avr32_link_hash_entry *)h;
+		  /* h->dynindx may be -1 if this symbol was marked to
+		     become local.  */
+		  if (h == NULL
+		      || ((info->symbolic || h->dynindx == -1)
+			  && h->def_regular))
+		    {
+		      relocate = TRUE;
+		      outrel.r_info = ELF32_R_INFO(0, R_AVR32_RELATIVE);
+		      outrel.r_addend = value + rel->r_addend;
+		      pr_debug("    ... R_AVR32_RELATIVE\n");
+		    }
+		  else
+		    {
+		      BFD_ASSERT(h->dynindx != -1);
+		      relocate = TRUE;
+		      outrel.r_info = ELF32_R_INFO(h->dynindx, R_AVR32_GLOB_DAT);
+		      outrel.r_addend = rel->r_addend;
+		      pr_debug("    ... R_AVR32_GLOB_DAT\n");
+		    }
+		}
+
+	      pr_debug("srelgot reloc_count: %d, size %lu\n",
+		       srelgot->reloc_count, srelgot->size);
+
+	      loc = srelgot->contents;
+	      loc += srelgot->reloc_count++ * sizeof(Elf32_External_Rela);
+	      bfd_elf32_swap_reloca_out(output_bfd, &outrel, loc);
+
+	      BFD_ASSERT(srelgot->reloc_count * sizeof(Elf32_External_Rela)
+			 <= srelgot->size);
+
+	      if (!relocate)
+		continue;
+	    }
+	  break;
+	}
+
+      status = avr32_final_link_relocate(howto, input_bfd, input_section,
+					 contents, rel, value);
+
+      switch (status)
+	{
+	case bfd_reloc_ok:
+	  break;
+
+	case bfd_reloc_overflow:
+	  {
+	    const char *name;
+
+	    if (h != NULL)
+	      name = h->root.root.string;
+	    else
+	      {
+		name = bfd_elf_string_from_elf_section(input_bfd,
+						       symtab_hdr->sh_link,
+						       sym->st_name);
+		if (name == NULL)
+		  return FALSE;
+		if (*name == '\0')
+		  name = bfd_section_name(input_bfd, sec);
+	      }
+	    if (!((*info->callbacks->reloc_overflow)
+		  (info, (h ? &h->root : NULL), name, howto->name,
+		   rel->r_addend, input_bfd, input_section, rel->r_offset)))
+	      return FALSE;
+	  }
+	  break;
+
+	case bfd_reloc_outofrange:
+	default:
+	  abort();
+	}
+    }
+
+  return TRUE;
+}
+
+
+/* Additional processing of dynamic sections after relocation */
+
+static bfd_boolean
+avr32_elf_finish_dynamic_symbol(bfd *output_bfd, struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym);
+static bfd_boolean
+avr32_elf_finish_dynamic_sections(bfd *output_bfd, struct bfd_link_info *info);
+
+
+/* (7) Initialize the contents of a dynamic symbol and/or emit
+   relocations for it */
+
+static bfd_boolean
+avr32_elf_finish_dynamic_symbol(bfd *output_bfd, struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct got_entry *got;
+
+  pr_debug("(7) finish dynamic symbol: %s\n", h->root.root.string);
+
+  htab = avr32_elf_hash_table(info);
+  got = h->got.glist;
+
+  if (got && got->refcount > 0)
+    {
+      asection *sgot;
+      asection *srelgot;
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol has an entry in the GOT. Set it up. */
+      sgot = htab->sgot;
+      srelgot = htab->srelgot;
+      BFD_ASSERT(sgot && srelgot);
+
+      rel.r_offset = (sgot->output_section->vma
+		      + sgot->output_offset
+		      + got->offset);
+
+      /* If this is a static link, or it is a -Bsymbolic link and the
+	 symbol is defined locally or was forced to be local because
+	 of a version file, we just want to emit a RELATIVE reloc. The
+	 entry in the global offset table will already have been
+	 initialized in the relocate_section function. */
+      if ((info->shared
+	   && !info->symbolic
+	   && h->dynindx != -1)
+	  || (htab->root.dynamic_sections_created
+	      && h->def_dynamic
+	      && !h->def_regular))
+	{
+	  bfd_put_32(output_bfd, 0, sgot->contents + got->offset);
+	  rel.r_info = ELF32_R_INFO(h->dynindx, R_AVR32_GLOB_DAT);
+	  rel.r_addend = 0;
+
+	  pr_debug("GOT reloc R_AVR32_GLOB_DAT, dynindx: %ld\n", h->dynindx);
+	  pr_debug("    srelgot reloc_count: %d, size: %lu\n",
+		   srelgot->reloc_count, srelgot->size);
+
+	  loc = (srelgot->contents
+		 + srelgot->reloc_count++ * sizeof(Elf32_External_Rela));
+	  bfd_elf32_swap_reloca_out(output_bfd, &rel, loc);
+
+	  BFD_ASSERT(srelgot->reloc_count * sizeof(Elf32_External_Rela)
+		     <= srelgot->size);
+	}
+    }
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute */
+  if (strcmp(h->root.root.string, "_DYNAMIC") == 0
+      || strcmp(h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+/* (8) Do any remaining initialization of the dynamic sections */
+
+static bfd_boolean
+avr32_elf_finish_dynamic_sections(bfd *output_bfd, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  asection *sgot, *sdyn;
+
+  pr_debug("(8) finish dynamic sections\n");
+
+  htab = avr32_elf_hash_table(info);
+  sgot = htab->sgot;
+  sdyn = bfd_get_section_by_name(htab->root.dynobj, ".dynamic");
+
+  if (htab->root.dynamic_sections_created)
+    {
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT(sdyn && sgot && sgot->size >= AVR32_GOT_HEADER_SIZE);
+
+      dyncon = (Elf32_External_Dyn *)sdyn->contents;
+      dynconend = (Elf32_External_Dyn *)(sdyn->contents + sdyn->size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  asection *s;
+
+	  bfd_elf32_swap_dyn_in(htab->root.dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+
+	    case DT_PLTGOT:
+	      s = sgot->output_section;
+	      BFD_ASSERT(s != NULL);
+	      dyn.d_un.d_ptr = s->vma;
+	      bfd_elf32_swap_dyn_out(output_bfd, &dyn, dyncon);
+	      break;
+
+	    case DT_AVR32_GOTSZ:
+	      s = sgot->output_section;
+	      BFD_ASSERT(s != NULL);
+	      dyn.d_un.d_val = s->size;
+	      bfd_elf32_swap_dyn_out(output_bfd, &dyn, dyncon);
+	      break;
+	    }
+	}
+
+      /* Fill in the first two entries in the global offset table */
+      bfd_put_32(output_bfd,
+		 sdyn->output_section->vma + sdyn->output_offset,
+		 sgot->contents);
+
+      /* The runtime linker will fill this one in with the address of
+	 the run-time link map */
+      bfd_put_32(output_bfd, 0, sgot->contents + 4);
+    }
+
+  if (sgot)
+    elf_section_data(sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+
+/* AVR32-specific private ELF data */
+
+static bfd_boolean
+avr32_elf_set_private_flags(bfd *abfd, flagword flags);
+static bfd_boolean
+avr32_elf_copy_private_bfd_data(bfd *ibfd, bfd *obfd);
+static bfd_boolean
+avr32_elf_merge_private_bfd_data(bfd *ibfd, bfd *obfd);
+static bfd_boolean
+avr32_elf_print_private_bfd_data(bfd *abfd, void *ptr);
+
+static bfd_boolean
+avr32_elf_set_private_flags(bfd *abfd, flagword flags)
+{
+  elf_elfheader(abfd)->e_flags = flags;
+  elf_flags_init(abfd) = TRUE;
+
+  return TRUE;
+}
+
+/* Copy backend specific data from one object module to another.  */
+
+static bfd_boolean
+avr32_elf_copy_private_bfd_data(bfd *ibfd, bfd *obfd)
+{
+  elf_elfheader(obfd)->e_flags = elf_elfheader(ibfd)->e_flags;
+  return TRUE;
+}
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+
+static bfd_boolean
+avr32_elf_merge_private_bfd_data(bfd *ibfd, bfd *obfd)
+{
+  flagword out_flags, in_flags;
+
+  pr_debug("(0) merge_private_bfd_data: %s -> %s\n",
+	   ibfd->filename, obfd->filename);
+
+  in_flags = elf_elfheader(ibfd)->e_flags;
+  out_flags = elf_elfheader(obfd)->e_flags;
+
+  if (elf_flags_init(obfd))
+    {
+      /* If one of the inputs are non-PIC, the output must be
+	 considered non-PIC.  The same applies to linkrelax.  */
+      if (!(in_flags & EF_AVR32_PIC))
+	out_flags &= ~EF_AVR32_PIC;
+      if (!(in_flags & EF_AVR32_LINKRELAX))
+	out_flags &= ~EF_AVR32_LINKRELAX;
+    }
+  else
+    {
+      elf_flags_init(obfd) = TRUE;
+      out_flags = in_flags;
+    }
+
+  elf_elfheader(obfd)->e_flags = out_flags;
+
+  return TRUE;
+}
+
+static bfd_boolean
+avr32_elf_print_private_bfd_data(bfd *abfd, void *ptr)
+{
+  FILE *file = (FILE *)ptr;
+  unsigned long flags;
+
+  BFD_ASSERT(abfd != NULL && ptr != NULL);
+
+  _bfd_elf_print_private_bfd_data(abfd, ptr);
+
+  flags = elf_elfheader(abfd)->e_flags;
+
+  fprintf(file, _("private flags = %lx:"), elf_elfheader(abfd)->e_flags);
+
+  if (flags & EF_AVR32_PIC)
+    fprintf(file, " [PIC]");
+  if (flags & EF_AVR32_LINKRELAX)
+    fprintf(file, " [linker relaxable]");
+
+  flags &= ~(EF_AVR32_PIC | EF_AVR32_LINKRELAX);
+
+  if (flags)
+    fprintf(file, _("<Unrecognized flag bits set>"));
+
+  fputc('\n', file);
+
+  return TRUE;
+}
+
+/* Set avr32-specific linker options.  */
+void bfd_elf32_avr32_set_options(struct bfd_link_info *info,
+				 int direct_data_refs)
+{
+  struct elf_avr32_link_hash_table *htab;
+
+  htab = avr32_elf_hash_table (info);
+  htab->direct_data_refs = !!direct_data_refs;
+}
+
+
+
+/* Understanding core dumps */
+
+static bfd_boolean
+avr32_elf_grok_prstatus(bfd *abfd, Elf_Internal_Note *note);
+static bfd_boolean
+avr32_elf_grok_psinfo(bfd *abfd, Elf_Internal_Note *note);
+
+static bfd_boolean
+avr32_elf_grok_prstatus(bfd *abfd, Elf_Internal_Note *note)
+{
+  /* Linux/AVR32B elf_prstatus */
+  if (note->descsz != 148)
+    return FALSE;
+
+  /* pr_cursig */
+  elf_tdata(abfd)->core_signal = bfd_get_16(abfd, note->descdata + 12);
+
+  /* pr_pid */
+  elf_tdata(abfd)->core_pid = bfd_get_32(abfd, note->descdata + 24);
+
+  /* Make a ".reg/999" section for pr_reg. The size is for 16
+     general-purpose registers, SR and r12_orig (18 * 4 = 72).  */
+  return _bfd_elfcore_make_pseudosection(abfd, ".reg", 72,
+					 note->descpos + 72);
+}
+
+static bfd_boolean
+avr32_elf_grok_psinfo(bfd *abfd, Elf_Internal_Note *note)
+{
+  /* Linux/AVR32B elf_prpsinfo */
+  if (note->descsz != 128)
+    return FALSE;
+
+  elf_tdata(abfd)->core_program
+    = _bfd_elfcore_strndup(abfd, note->descdata + 32, 16);
+  elf_tdata(abfd)->core_command
+    = _bfd_elfcore_strndup(abfd, note->descdata + 48, 80);
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+
+#define ELF_ARCH			bfd_arch_avr32
+#define ELF_MACHINE_CODE		EM_AVR32
+#define ELF_MAXPAGESIZE			0x1000
+
+#define TARGET_BIG_SYM			bfd_elf32_avr32_vec
+#define TARGET_BIG_NAME			"elf32-avr32"
+
+#define elf_backend_grok_prstatus	avr32_elf_grok_prstatus
+#define elf_backend_grok_psinfo		avr32_elf_grok_psinfo
+
+/* Only RELA relocations are used */
+#define elf_backend_may_use_rel_p	0
+#define elf_backend_may_use_rela_p	1
+#define elf_backend_default_use_rela_p	1
+#define elf_backend_rela_normal		1
+#define elf_info_to_howto_rel		NULL
+#define elf_info_to_howto		avr32_info_to_howto
+
+#define bfd_elf32_bfd_copy_private_bfd_data	avr32_elf_copy_private_bfd_data
+#define bfd_elf32_bfd_merge_private_bfd_data	avr32_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags		avr32_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data	avr32_elf_print_private_bfd_data
+#define bfd_elf32_new_section_hook		avr32_elf_new_section_hook
+
+#define elf_backend_gc_mark_hook		avr32_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook		avr32_elf_gc_sweep_hook
+#define elf_backend_relocate_section	avr32_elf_relocate_section
+#define elf_backend_copy_indirect_symbol avr32_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections avr32_elf_create_dynamic_sections
+#define bfd_elf32_bfd_link_hash_table_create avr32_elf_link_hash_table_create
+#define elf_backend_adjust_dynamic_symbol avr32_elf_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections avr32_elf_size_dynamic_sections
+#define elf_backend_finish_dynamic_symbol avr32_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections avr32_elf_finish_dynamic_sections
+
+#define bfd_elf32_bfd_relax_section	avr32_elf_relax_section
+
+/* Find out which symbols need an entry in .got. */
+#define elf_backend_check_relocs	avr32_check_relocs
+#define elf_backend_can_refcount	1
+#define elf_backend_can_gc_sections	1
+#define elf_backend_plt_readonly	1
+#define elf_backend_plt_not_loaded	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_plt_alignment	2
+#define elf_backend_want_dynbss		0
+#define elf_backend_want_got_plt	0
+#define elf_backend_want_got_sym	1
+#define elf_backend_got_header_size	AVR32_GOT_HEADER_SIZE
+
+#include "elf32-target.h"
--- /dev/null
+++ b/bfd/elf32-avr32.h
@@ -0,0 +1,23 @@
+/* AVR32-specific support for 32-bit ELF.
+   Copyright 2007 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+void bfd_elf32_avr32_set_options(struct bfd_link_info *info,
+				 int direct_data_refs);
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -1400,6 +1400,10 @@ struct elf_obj_tdata
      find_nearest_line.  */
   struct mips_elf_find_line *find_line_info;
 
+  /* Used by AVR32 ELF relaxation code.  Contains an array of pointers
+     for each local symbol to the fragment where it is defined.  */
+  struct fragment **local_sym_frag;
+
   /* A place to stash dwarf1 info for this bfd.  */
   struct dwarf1_debug *dwarf1_find_line_info;
 
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -63,6 +63,7 @@ ALL_MACHINES = \
 	cpu-arc.lo \
 	cpu-arm.lo \
 	cpu-avr.lo \
+	cpu-avr32.lo \
 	cpu-bfin.lo \
 	cpu-cr16.lo \
 	cpu-cr16c.lo \
@@ -243,6 +244,7 @@ BFD32_BACKENDS = \
 	elf32-arc.lo \
 	elf32-arm.lo \
 	elf32-avr.lo \
+	elf32-avr32.lo \
 	elf32-bfin.lo \
 	elf32-cr16.lo \
 	elf32-cr16c.lo \
@@ -1328,6 +1330,10 @@ elf32-cr16.lo: elf32-cr16.c $(INCDIR)/fi
   $(INCDIR)/hashtab.h $(INCDIR)/libiberty.h elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/elf/cr16.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
+elf32-avr32.lo: elf32-avr32.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/avr32.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-cr16c.lo: elf32-cr16c.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/cr16c.h \
   $(INCDIR)/elf/reloc-macros.h elf-bfd.h $(INCDIR)/elf/common.h \
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -3948,6 +3948,131 @@ ENUMDOC
   instructions
 
 ENUM
+  BFD_RELOC_AVR32_DIFF32
+ENUMX
+  BFD_RELOC_AVR32_DIFF16
+ENUMX
+  BFD_RELOC_AVR32_DIFF8
+ENUMDOC
+  Difference between two labels: L2 - L1. The value of L1 is encoded
+  as sym + addend, while the initial difference after assembly is
+  inserted into the object file by the assembler.
+ENUM
+  BFD_RELOC_AVR32_GOT32
+ENUMX
+  BFD_RELOC_AVR32_GOT16
+ENUMX
+  BFD_RELOC_AVR32_GOT8
+ENUMDOC
+  Reference to a symbol through the Global Offset Table. The linker
+  will allocate an entry for symbol in the GOT and insert the offset
+  of this entry as the relocation value.
+ENUM
+  BFD_RELOC_AVR32_21S
+ENUMX
+  BFD_RELOC_AVR32_16U
+ENUMX
+  BFD_RELOC_AVR32_16S
+ENUMX
+  BFD_RELOC_AVR32_SUB5
+ENUMX
+  BFD_RELOC_AVR32_8S_EXT
+ENUMX
+  BFD_RELOC_AVR32_8S
+ENUMX
+  BFD_RELOC_AVR32_15S
+ENUMDOC
+  Normal (non-pc-relative) code relocations. Alignment and signedness
+  is indicated by the suffixes. S means signed, U means unsigned. W
+  means word-aligned, H means halfword-aligned, neither means
+  byte-aligned (no alignment.) SUB5 is the same relocation as 16S.
+ENUM
+  BFD_RELOC_AVR32_22H_PCREL
+ENUMX
+  BFD_RELOC_AVR32_18W_PCREL
+ENUMX
+  BFD_RELOC_AVR32_16B_PCREL
+ENUMX
+  BFD_RELOC_AVR32_16N_PCREL
+ENUMX
+  BFD_RELOC_AVR32_14UW_PCREL
+ENUMX
+  BFD_RELOC_AVR32_11H_PCREL
+ENUMX
+  BFD_RELOC_AVR32_10UW_PCREL
+ENUMX
+  BFD_RELOC_AVR32_9H_PCREL
+ENUMX
+  BFD_RELOC_AVR32_9UW_PCREL
+ENUMDOC
+  PC-relative relocations are signed if neither 'U' nor 'S' is
+  specified. However, we explicitly tack on a 'B' to indicate no
+  alignment, to avoid confusion with data relocs. All of these resolve
+  to sym + addend - offset, except the one with 'N' (negated) suffix.
+  This particular one resolves to offset - sym - addend.
+ENUM
+  BFD_RELOC_AVR32_GOTPC
+ENUMDOC
+  Subtract the link-time address of the GOT from (symbol + addend)
+  and insert the result.
+ENUM
+  BFD_RELOC_AVR32_GOTCALL
+ENUMX
+  BFD_RELOC_AVR32_LDA_GOT
+ENUMX
+  BFD_RELOC_AVR32_GOT21S
+ENUMX
+  BFD_RELOC_AVR32_GOT18SW
+ENUMX
+  BFD_RELOC_AVR32_GOT16S
+ENUMDOC
+  Reference to a symbol through the GOT. The linker will allocate an
+  entry for symbol in the GOT and insert the offset of this entry as
+  the relocation value. addend must be zero. As usual, 'S' means
+  signed, 'W' means word-aligned, etc.
+ENUM
+  BFD_RELOC_AVR32_32_CPENT
+ENUMDOC
+  32-bit constant pool entry. I don't think 8- and 16-bit entries make
+  a whole lot of sense.
+ENUM
+  BFD_RELOC_AVR32_CPCALL
+ENUMX
+  BFD_RELOC_AVR32_16_CP
+ENUMX
+  BFD_RELOC_AVR32_9W_CP
+ENUMDOC
+  Constant pool references. Some of these relocations are signed,
+  others are unsigned. It doesn't really matter, since the constant
+  pool always comes after the code that references it.
+ENUM
+  BFD_RELOC_AVR32_ALIGN
+ENUMDOC
+  sym must be the absolute symbol. The addend specifies the alignment
+  order, e.g. if addend is 2, the linker must add padding so that the
+  next address is aligned to a 4-byte boundary.
+ENUM
+  BFD_RELOC_AVR32_14UW
+ENUMX
+  BFD_RELOC_AVR32_10UW
+ENUMX
+  BFD_RELOC_AVR32_10SW
+ENUMX
+  BFD_RELOC_AVR32_STHH_W
+ENUMX
+  BFD_RELOC_AVR32_7UW
+ENUMX
+  BFD_RELOC_AVR32_6S
+ENUMX
+  BFD_RELOC_AVR32_6UW
+ENUMX
+  BFD_RELOC_AVR32_4UH
+ENUMX
+  BFD_RELOC_AVR32_3U
+ENUMDOC
+  Code relocations that will never make it to the output file.
+
+ENUM
   BFD_RELOC_390_12
 ENUMDOC
    Direct 12 bit.
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -564,6 +564,7 @@ extern const bfd_target bfd_efi_app_ia32
 extern const bfd_target bfd_efi_app_x86_64_vec;
 extern const bfd_target bfd_efi_app_ia64_vec;
 extern const bfd_target bfd_elf32_avr_vec;
+extern const bfd_target bfd_elf32_avr32_vec;
 extern const bfd_target bfd_elf32_bfin_vec;
 extern const bfd_target bfd_elf32_bfinfdpic_vec;
 extern const bfd_target bfd_elf32_big_generic_vec;
@@ -884,6 +885,7 @@ static const bfd_target * const _bfd_tar
 	&bfd_efi_app_ia64_vec,
 #endif
 	&bfd_elf32_avr_vec,
+	&bfd_elf32_avr32_vec,
 	&bfd_elf32_bfin_vec,
 	&bfd_elf32_bfinfdpic_vec,
 
--- a/binutils/Makefile.am
+++ b/binutils/Makefile.am
@@ -577,7 +577,7 @@ readelf.o: readelf.c sysdep.h $(INCDIR)/
   $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h bucomm.h dwarf.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/h8.h $(INCDIR)/elf/reloc-macros.h $(INCDIR)/elf/alpha.h \
-  $(INCDIR)/elf/arc.h $(INCDIR)/elf/arm.h $(INCDIR)/elf/avr.h \
+  $(INCDIR)/elf/arc.h $(INCDIR)/elf/arm.h $(INCDIR)/elf/avr.h $(INCDIR)/elf/avr32.h\
   $(INCDIR)/elf/bfin.h $(INCDIR)/elf/cris.h $(INCDIR)/elf/crx.h \
   $(INCDIR)/elf/d10v.h $(INCDIR)/elf/d30v.h $(INCDIR)/elf/dlx.h \
   $(INCDIR)/elf/fr30.h $(INCDIR)/elf/frv.h $(INCDIR)/elf/hppa.h \
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -21,7 +21,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
    02110-1301, USA.  */
-
+
 /* The difference between readelf and objdump:
 
   Both programs are capable of displaying the contents of ELF format files,
@@ -40,7 +40,7 @@
   There is also the case that readelf can provide more information about an
   ELF file than is provided by objdump.  In particular it can display DWARF
   debugging information which (at the moment) objdump cannot.  */
-
+
 #include "sysdep.h"
 #include <assert.h>
 #include <sys/stat.h>
@@ -109,6 +109,7 @@
 #include "elf/arc.h"
 #include "elf/arm.h"
 #include "elf/avr.h"
+#include "elf/avr32.h"
 #include "elf/bfin.h"
 #include "elf/cr16.h"
 #include "elf/cris.h"
@@ -303,7 +304,7 @@ static void (*byte_put) (unsigned char *
 #define streq(a,b)	  (strcmp ((a), (b)) == 0)
 #define strneq(a,b,n)	  (strncmp ((a), (b), (n)) == 0)
 #define const_strneq(a,b) (strncmp ((a), (b), sizeof (b) - 1) == 0)
-
+
 static void *
 get_data (void *var, FILE *file, long offset, size_t size, size_t nmemb,
 	  const char *reason)
@@ -614,6 +615,7 @@ guess_is_rela (unsigned long e_machine)
     case EM_ALPHA:
     case EM_ALTERA_NIOS2:
     case EM_AVR:
+    case EM_AVR32:
     case EM_AVR_OLD:
     case EM_BLACKFIN:
     case EM_CR16:
@@ -1006,6 +1008,10 @@ dump_relocations (FILE *file,
 	  rtype = elf_avr_reloc_type (type);
 	  break;
 
+	case EM_AVR32:
+	  rtype = elf_avr32_reloc_type (type);
+	  break;
+
 	case EM_OLD_SPARCV9:
 	case EM_SPARC32PLUS:
 	case EM_SPARCV9:
@@ -1763,6 +1769,7 @@ get_machine_name (unsigned e_machine)
     case EM_VAX:		return "Digital VAX";
     case EM_AVR_OLD:
     case EM_AVR:		return "Atmel AVR 8-bit microcontroller";
+    case EM_AVR32:		return "Atmel AVR32";
     case EM_CRIS:		return "Axis Communications 32-bit embedded processor";
     case EM_JAVELIN:		return "Infineon Technologies 32-bit embedded cpu";
     case EM_FIREPATH:		return "Element 14 64-bit DSP processor";
--- a/gas/as.c
+++ b/gas/as.c
@@ -441,10 +441,10 @@ parse_args (int * pargc, char *** pargv)
        the end of the preceeding line so that it is simpler to
        selectively add and remove lines from this list.  */
     {"alternate", no_argument, NULL, OPTION_ALTERNATE}
-    /* The entry for "a" is here to prevent getopt_long_only() from
-       considering that -a is an abbreviation for --alternate.  This is
-       necessary because -a=<FILE> is a valid switch but getopt would
-       normally reject it since --alternate does not take an argument.  */
+    /* The next two entries are here to prevent getopt_long_only() from
+       considering that -a or -al is an abbreviation for --alternate.
+       This is necessary because -a=<FILE> is a valid switch but getopt
+       would normally reject it since --alternate does not take an argument.  */
     ,{"a", optional_argument, NULL, 'a'}
     /* Handle -al=<FILE>.  */
     ,{"al", optional_argument, NULL, OPTION_AL}
@@ -803,8 +803,15 @@ This program has absolutely no warranty.
 	case 'a':
 	  if (optarg)
 	    {
-	      if (optarg != old_argv[optind] && optarg[-1] == '=')
-		--optarg;
+	      /* If optarg is part of the -a switch and not a separate argument
+		 in its own right, then scan backwards to the just after the -a.
+		 This means skipping over both '=' and 'l' which might have been
+		 taken to be part of the -a switch itself.  */
+	      if (optarg != old_argv[optind])
+		{
+		  while (optarg[-1] == '=' || optarg[-1] == 'l')
+		    --optarg;
+		}
 
 	      if (md_parse_option (optc, optarg) != 0)
 		break;
@@ -1234,7 +1241,7 @@ main (int argc, char ** argv)
     keep_it = 0;
 
   if (!keep_it)
-    unlink_if_ordinary (out_file_name);
+    unlink (out_file_name);
 
   input_scrub_end ();
 
--- /dev/null
+++ b/gas/config/tc-avr32.c
@@ -0,0 +1,4806 @@
+/* Assembler implementation for AVR32.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include <stdio.h>
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "symcat.h"
+#include "opcodes/avr32-opc.h"
+#include "opcodes/avr32-asm.h"
+#include "elf/avr32.h"
+#include "dwarf2dbg.h"
+
+#define xDEBUG
+#define xOPC_CONSISTENCY_CHECK
+
+#ifdef DEBUG
+# define pr_debug(fmt, args...) fprintf(stderr, fmt, ##args)
+#else
+# define pr_debug(fmt, args...)
+#endif
+
+/* 3 MSB of instruction word indicate group. Group 7 -> extended */
+#define AVR32_COMPACT_P(opcode) ((opcode[0] & 0xe0) != 0xe0)
+
+#define streq(a, b)		(strcmp(a, b) == 0)
+#define skip_whitespace(str)	do { while(*(str) == ' ') ++(str); } while(0)
+
+/* Flags given on the command line */
+static int avr32_pic	= FALSE;
+int linkrelax	= FALSE;
+int avr32_iarcompat	= FALSE;
+
+/* This array holds the chars that always start a comment. */
+const char comment_chars[]		= "#";
+
+/* This array holds the chars that only start a comment at the
+   beginning of a line.  We must include '#' here because the compiler
+   may produce #APP and #NO_APP in its output.  */
+const char line_comment_chars[]		= "#";
+
+/* These may be used instead of newline (same as ';' in C).  */
+const char line_separator_chars[]	= ";";
+
+/* Chars that can be used to separate mantissa from exponent in
+   floating point numbers.  */
+const char EXP_CHARS[]			= "eE";
+
+/* Chars that mean this number is a floating point constant.  */
+const char FLT_CHARS[]			= "dD";
+
+/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
+symbolS *GOT_symbol;
+
+static struct hash_control *avr32_mnemonic_htab;
+
+struct avr32_ifield_data
+{
+  bfd_vma value;
+  /* FIXME: Get rid of align_order and complain. complain is never
+     used, align_order is used in one place.  Try to use the relax
+     table instead.  */
+  unsigned int align_order;
+};
+
+struct avr32_insn
+{
+  const struct avr32_syntax *syntax;
+  expressionS immediate;
+  int pcrel;
+  int force_extended;
+  unsigned int next_slot;
+  bfd_reloc_code_real_type r_type;
+  struct avr32_ifield_data field_value[AVR32_MAX_FIELDS];
+};
+
+static struct avr32_insn current_insn;
+
+/* The target specific pseudo-ops we support. */
+static void s_rseg (int);
+static void s_cpool(int);
+
+const pseudo_typeS md_pseudo_table[] =
+{
+  /* Make sure that .word is 32 bits */
+  { "word", cons, 4 },
+  { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
+  { "loc", dwarf2_directive_loc, 0 },
+
+  /* .lcomm requires an explicit alignment parameter */
+  { "lcomm", s_lcomm, 1 },
+
+  /* AVR32-specific pseudo-ops */
+  { "cpool", s_cpool, 0},
+
+  /* IAR compatible pseudo-ops */
+  { "program", s_ignore, 0 },
+  { "public", s_globl, 0 },
+  { "extern", s_ignore, 0 },
+  { "module", s_ignore, 0 },
+  { "rseg", s_rseg, 0 },
+  { "dc8", cons, 1 },
+  { "dc16", cons, 2 },
+  { "dc32", cons, 4 },
+
+  { NULL, NULL, 0 }
+};
+
+/* Questionable stuff starts here */
+
+enum avr32_opinfo {
+  AVR32_OPINFO_NONE = BFD_RELOC_NONE,
+  AVR32_OPINFO_GOT,
+  AVR32_OPINFO_TLSGD,
+  AVR32_OPINFO_HI,
+  AVR32_OPINFO_LO,
+};
+
+enum avr32_arch {
+  ARCH_TYPE_AP,
+  ARCH_TYPE_UCR1,
+  ARCH_TYPE_UCR2,
+};
+
+struct arch_type_s
+{
+  /* Architecture name */
+  char *name;
+  /* Instruction Set Architecture Flags */
+  unsigned long isa_flags;
+};
+
+struct part_type_s
+{
+  /* Part name */
+  char *name;
+  /* Architecture type */
+  unsigned int arch;
+};
+
+static struct arch_type_s arch_types[] =
+{
+  {"ap", AVR32_V1 | AVR32_SIMD | AVR32_DSP | AVR32_PICO},
+  {"ucr1", AVR32_V1 | AVR32_DSP | AVR32_RMW},
+  {"ucr2", AVR32_V1 | AVR32_V2 | AVR32_DSP | AVR32_RMW},
+  {"all-insn", AVR32_V1 | AVR32_V2 | AVR32_SIMD | AVR32_DSP | AVR32_RMW | AVR32_FP | AVR32_PICO},
+  {NULL, 0}
+};
+
+static struct part_type_s part_types[] = {
+  {"ap7000", ARCH_TYPE_AP},
+  {"ap7001", ARCH_TYPE_AP},
+  {"ap7002", ARCH_TYPE_AP},
+  {"ap7200", ARCH_TYPE_AP},
+  {"uc3a0128", ARCH_TYPE_UCR2},
+  {"uc3a0256", ARCH_TYPE_UCR2},
+  {"uc3a0512es", ARCH_TYPE_UCR1},
+  {"uc3a0512", ARCH_TYPE_UCR2},
+  {"uc3a1128", ARCH_TYPE_UCR2},
+  {"uc3a1256es", ARCH_TYPE_UCR1},
+  {"uc3a1256", ARCH_TYPE_UCR2},
+  {"uc3a1512es", ARCH_TYPE_UCR1},
+  {"uc3a1512", ARCH_TYPE_UCR2},
+  {"uc3a364", ARCH_TYPE_UCR2},
+  {"uc3a364s", ARCH_TYPE_UCR2},
+  {"uc3a3128", ARCH_TYPE_UCR2},
+  {"uc3a3128s", ARCH_TYPE_UCR2},
+  {"uc3a3256", ARCH_TYPE_UCR2},
+  {"uc3a3256s", ARCH_TYPE_UCR2},
+  {"uc3b064", ARCH_TYPE_UCR1},
+  {"uc3b0128", ARCH_TYPE_UCR1},
+  {"uc3b0256es", ARCH_TYPE_UCR1},
+  {"uc3b0256", ARCH_TYPE_UCR1},
+  {"uc3b164", ARCH_TYPE_UCR1},
+  {"uc3b1128", ARCH_TYPE_UCR1},
+  {"uc3b1256es", ARCH_TYPE_UCR1},
+  {"uc3b1256", ARCH_TYPE_UCR1},
+  {NULL, 0}
+};
+
+/* Current architecture type.  */
+static struct arch_type_s default_arch = {"all-insn", AVR32_V1 | AVR32_V2 | AVR32_SIMD | AVR32_DSP | AVR32_RMW | AVR32_FP | AVR32_PICO };
+static struct arch_type_s *avr32_arch = &default_arch;
+
+/* Display nicely formatted list of known part- and architecture names.  */
+
+static void
+show_arch_list (FILE *stream)
+{
+  int i, x;
+
+  fprintf (stream, _("Known architecture names:"));
+  x = 1000;
+
+  for (i = 0; arch_types[i].name; i++)
+    {
+      int len = strlen (arch_types[i].name);
+
+      x += len + 1;
+
+      if (x < 75)
+	fprintf (stream, " %s", arch_types[i].name);
+      else
+	{
+	  fprintf (stream, "\n  %s", arch_types[i].name);
+	  x = len + 2;
+	}
+    }
+
+  fprintf (stream, "\n");
+}
+
+static void
+show_part_list (FILE *stream)
+{
+  int i, x;
+
+  fprintf (stream, _("Known part names:"));
+  x = 1000;
+
+  for (i = 0; part_types[i].name; i++)
+    {
+      int len = strlen(part_types[i].name);
+
+      x += len + 1;
+
+      if (x < 75)
+	fprintf (stream, " %s", part_types[i].name);
+      else
+	{
+	  fprintf(stream, "\n  %s", part_types[i].name);
+	  x = len + 2;
+	}
+    }
+
+  fprintf (stream, "\n");
+}
+
+const char *md_shortopts = "";
+struct option md_longopts[] =
+{
+#define OPTION_ARCH		(OPTION_MD_BASE)
+#define OPTION_PART		(OPTION_ARCH + 1)
+#define OPTION_IAR		(OPTION_PART + 1)
+#define OPTION_PIC		(OPTION_IAR + 1)
+#define OPTION_NOPIC		(OPTION_PIC + 1)
+#define OPTION_LINKRELAX	(OPTION_NOPIC + 1)
+#define OPTION_NOLINKRELAX	(OPTION_LINKRELAX + 1)
+#define OPTION_DIRECT_DATA_REFS (OPTION_NOLINKRELAX + 1)
+  {"march",		required_argument, NULL, OPTION_ARCH},
+  {"mpart",		required_argument, NULL, OPTION_PART},
+  {"iar",		no_argument, NULL, OPTION_IAR},
+  {"pic",		no_argument, NULL, OPTION_PIC},
+  {"no-pic",		no_argument, NULL, OPTION_NOPIC},
+  {"linkrelax",		no_argument, NULL, OPTION_LINKRELAX},
+  {"no-linkrelax",	no_argument, NULL, OPTION_NOLINKRELAX},
+  /* deprecated alias for -mpart=xxx */
+  {"mcpu",		required_argument, NULL, OPTION_PART},
+  {NULL,		no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream, _("\
+AVR32 options:\n\
+  -march=[arch-name]      Select cpu architecture. [Default `all-insn']\n\
+  -mpart=[part-name]      Select specific part. [Default `none']\n\
+  --pic                   Produce Position-Independent Code\n\
+  --no-pic                Don't produce Position-Independent Code\n\
+  --linkrelax             Produce output suitable for linker relaxing\n\
+  --no-linkrelax          Don't produce output suitable for linker relaxing\n"));
+  show_arch_list(stream);
+}
+
+int
+md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
+{
+  switch (c)
+    {
+    case OPTION_ARCH:
+      {
+	int i;
+	char *s = alloca (strlen (arg) + 1);
+
+	{
+	  char *t = s;
+	  char *arg1 = arg;
+
+	  do
+	    *t = TOLOWER (*arg1++);
+	  while (*t++);
+	}
+
+        /* Add backward compability */
+        if (strcmp ("uc", s)== 0)
+          {
+            as_warn("Deprecated arch `%s' specified. "
+                    "Please use '-march=ucr1' instead. "
+                    "Converting to arch 'ucr1'\n",
+                     s);
+            s="ucr1";
+          }
+
+	for (i = 0; arch_types[i].name; ++i)
+	  if (strcmp (arch_types[i].name, s) == 0)
+	    break;
+
+	if (!arch_types[i].name)
+	  {
+	    show_arch_list (stderr);
+	    as_fatal (_("unknown architecture: %s\n"), arg);
+	  }
+
+        avr32_arch = &arch_types[i];
+	break;
+      }
+    case OPTION_PART:
+      {
+	int i;
+	char *s = alloca (strlen (arg) + 1);
+	char *t = s;
+	char *p = arg;
+
+	/* If arch type has already been set, don't bother.
+	   -march= always overrides -mpart=  */
+	if (avr32_arch != &default_arch)
+	  break;
+
+	do
+	  *t = TOLOWER (*p++);
+	while (*t++);
+
+	for (i = 0; part_types[i].name; ++i)
+	  if (strcmp (part_types[i].name, s) == 0)
+	    break;
+
+	if (!part_types[i].name)
+	  {
+	    show_part_list (stderr);
+	    as_fatal (_("unknown part: %s\n"), arg);
+	  }
+
+	avr32_arch = &arch_types[part_types[i].arch];
+	break;
+      }
+    case OPTION_IAR:
+      avr32_iarcompat = 1;
+      break;
+    case OPTION_PIC:
+      avr32_pic = 1;
+      break;
+    case OPTION_NOPIC:
+      avr32_pic = 0;
+      break;
+    case OPTION_LINKRELAX:
+      linkrelax = 1;
+      break;
+    case OPTION_NOLINKRELAX:
+      linkrelax = 0;
+      break;
+    default:
+      return 0;
+    }
+  return 1;
+}
+
+/* Can't use symbol_new here, so have to create a symbol and then at
+   a later date assign it a value. Thats what these functions do.
+
+   Shamelessly stolen from ARM.  */
+
+static void
+symbol_locate (symbolS *    symbolP,
+	       const char * name,	/* It is copied, the caller can modify.  */
+	       segT         segment,	/* Segment identifier (SEG_<something>).  */
+	       valueT       valu,	/* Symbol value.  */
+	       fragS *      frag)	/* Associated fragment.  */
+{
+  unsigned int name_length;
+  char * preserved_copy_of_name;
+
+  name_length = strlen (name) + 1;   /* +1 for \0.  */
+  obstack_grow (&notes, name, name_length);
+  preserved_copy_of_name = obstack_finish (&notes);
+#ifdef STRIP_UNDERSCORE
+  if (preserved_copy_of_name[0] == '_')
+    preserved_copy_of_name++;
+#endif
+
+#ifdef tc_canonicalize_symbol_name
+  preserved_copy_of_name =
+    tc_canonicalize_symbol_name (preserved_copy_of_name);
+#endif
+
+  S_SET_NAME (symbolP, preserved_copy_of_name);
+
+  S_SET_SEGMENT (symbolP, segment);
+  S_SET_VALUE (symbolP, valu);
+  symbol_clear_list_pointers (symbolP);
+
+  symbol_set_frag (symbolP, frag);
+
+  /* Link to end of symbol chain.  */
+  {
+    extern int symbol_table_frozen;
+
+    if (symbol_table_frozen)
+      abort ();
+  }
+
+  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
+
+  obj_symbol_new_hook (symbolP);
+
+#ifdef tc_symbol_new_hook
+  tc_symbol_new_hook (symbolP);
+#endif
+
+#ifdef DEBUG_SYMS
+  verify_symbol_chain (symbol_rootP, symbol_lastP);
+#endif /* DEBUG_SYMS  */
+}
+
+struct cpool_entry
+{
+  int			refcount;
+  offsetT		offset;
+  expressionS		exp;
+};
+
+struct cpool
+{
+  struct cpool		*next;
+  int			used;
+  struct cpool_entry	*literals;
+  unsigned int		padding;
+  unsigned int		next_free_entry;
+  unsigned int		id;
+  symbolS		*symbol;
+  segT			section;
+  subsegT		sub_section;
+};
+
+struct cpool *cpool_list = NULL;
+
+static struct cpool *
+find_cpool(segT section, subsegT sub_section)
+{
+  struct cpool *pool;
+
+  for (pool = cpool_list; pool != NULL; pool = pool->next)
+    {
+      if (!pool->used
+	  && pool->section == section
+	  && pool->sub_section == sub_section)
+	break;
+    }
+
+  return pool;
+}
+
+static struct cpool *
+find_or_make_cpool(segT section, subsegT sub_section)
+{
+  static unsigned int next_cpool_id = 0;
+  struct cpool *pool;
+
+  pool = find_cpool(section, sub_section);
+
+  if (!pool)
+    {
+      pool = xmalloc(sizeof(*pool));
+      if (!pool)
+	return NULL;
+
+      pool->used = 0;
+      pool->literals = NULL;
+      pool->padding = 0;
+      pool->next_free_entry = 0;
+      pool->section = section;
+      pool->sub_section = sub_section;
+      pool->next = cpool_list;
+      pool->symbol = NULL;
+
+      cpool_list = pool;
+    }
+
+  /* NULL symbol means that the pool is new or has just been emptied.  */
+  if (!pool->symbol)
+    {
+      pool->symbol = symbol_create(FAKE_LABEL_NAME, undefined_section,
+				   0, &zero_address_frag);
+      pool->id = next_cpool_id++;
+    }
+
+  return pool;
+}
+
+static struct cpool *
+add_to_cpool(expressionS *exp, unsigned int *index, int ref)
+{
+  struct cpool *pool;
+  unsigned int entry;
+
+  pool = find_or_make_cpool(now_seg, now_subseg);
+
+  /* Check if this constant is already in the pool.  */
+  for (entry = 0; entry < pool->next_free_entry; entry++)
+    {
+      if ((pool->literals[entry].exp.X_op == exp->X_op)
+	  && (exp->X_op == O_constant)
+	  && (pool->literals[entry].exp.X_add_number
+	      == exp->X_add_number)
+	  && (pool->literals[entry].exp.X_unsigned
+	      == exp->X_unsigned))
+	break;
+
+      if ((pool->literals[entry].exp.X_op == exp->X_op)
+	  && (exp->X_op == O_symbol)
+	  && (pool->literals[entry].exp.X_add_number
+	      == exp->X_add_number)
+	  && (pool->literals[entry].exp.X_add_symbol
+	      == exp->X_add_symbol)
+	  && (pool->literals[entry].exp.X_op_symbol
+	      == exp->X_op_symbol))
+	break;
+    }
+
+  /* Create an entry if we didn't find a match */
+  if (entry == pool->next_free_entry)
+    {
+      pool->literals = xrealloc(pool->literals,
+				sizeof(struct cpool_entry) * (entry + 1));
+      pool->literals[entry].exp = *exp;
+      pool->literals[entry].refcount = 0;
+      pool->next_free_entry++;
+    }
+
+  if (index)
+    *index = entry;
+  if (ref)
+    pool->literals[entry].refcount++;
+
+  return pool;
+}
+
+struct avr32_operand
+{
+  int id;
+  int is_signed;
+  int is_pcrel;
+  int align_order;
+  int (*match)(char *str);
+  void (*parse)(const struct avr32_operand *op, char *str, int opindex);
+};
+
+static int
+match_anything(char *str ATTRIBUTE_UNUSED)
+{
+  return 1;
+}
+
+static int
+match_intreg(char *str)
+{
+  int regid, ret = 1;
+
+  regid = avr32_parse_intreg(str);
+  if (regid < 0)
+    ret = 0;
+
+  pr_debug("match_intreg: `%s': %d\n", str, ret);
+
+  return ret;
+}
+
+static int
+match_intreg_predec(char *str)
+{
+  int regid;
+
+  if (str[0] != '-' || str[1] != '-')
+    return 0;
+
+  regid = avr32_parse_intreg(str + 2);
+  if (regid < 0)
+    return 0;
+
+  return 1;
+}
+
+static int
+match_intreg_postinc(char *str)
+{
+  int regid, ret = 1;
+  char *p, c;
+
+  for (p = str; *p; p++)
+    if (*p == '+')
+      break;
+
+  if (p[0] != '+' || p[1] != '+')
+    return 0;
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  if (regid < 0)
+    ret = 0;
+
+  *p = c;
+  return ret;
+}
+
+static int
+match_intreg_lsl(char *str)
+{
+  int regid, ret = 1;
+  char *p, c;
+
+  for (p = str; *p; p++)
+    if (*p == '<')
+      break;
+
+  if (p[0] && p[1] != '<')
+    return 0;
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  if (regid < 0)
+    ret = 0;
+
+  *p = c;
+  return ret;
+}
+
+static int
+match_intreg_lsr(char *str)
+{
+  int regid, ret = 1;
+  char *p, c;
+
+  for (p = str; *p; p++)
+    if (*p == '>')
+      break;
+
+  if (p[0] && p[1] != '>')
+    return 0;
+
+  c = *p, *p = 0;
+
+  regid = avr32_parse_intreg(str);
+  if (regid < 0)
+    ret = 0;
+
+  *p = c;
+  return ret;
+}
+
+static int
+match_intreg_part(char *str)
+{
+  int regid, ret = 1;
+  char *p, c;
+
+  for (p = str; *p; p++)
+    if (*p == ':')
+      break;
+
+  if (p[0] != ':' || !ISPRINT(p[1]) || p[2] != '\0')
+    return 0;
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  if (regid < 0)
+    ret = 0;
+
+  *p = c;
+
+  return ret;
+}
+
+#define match_intreg_disp match_anything
+
+static int
+match_intreg_index(char *str)
+{
+  int regid, ret = 1;
+  char *p, *end, c;
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  /* don't allow empty displacement here (it makes no sense) */
+  if (p[0] != '[')
+    return 0;
+
+  for (end = p + 1; *end; end++) ;
+  if (*(--end) != ']')
+    return 0;
+
+  c = *end, *end = 0;
+  if (!match_intreg_lsl(p + 1))
+    ret = 0;
+  *end = c;
+
+  if (ret)
+    {
+      c = *p, *p = 0;
+      regid = avr32_parse_intreg(str);
+      if (regid < 0)
+	ret = 0;
+      *p = c;
+    }
+
+  return ret;
+}
+
+static int
+match_intreg_xindex(char *str)
+{
+  int regid, ret = 1;
+  char *p, *end, c;
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  /* empty displacement makes no sense here either */
+  if (p[0] != '[')
+    return 0;
+
+  for (end = p + 1; *end; end++)
+    if (*end == '<')
+      break;
+
+  if (!streq(end, "<<2]"))
+    return 0;
+
+  c = *end, *end = 0;
+  if (!match_intreg_part(p + 1))
+    ret = 0;
+  *end = c;
+
+  if (ret)
+    {
+      c = *p, *p = 0;
+      regid = avr32_parse_intreg(str);
+      if (regid < 0)
+	ret = 0;
+      *p = c;
+    }
+
+  return ret;
+}
+
+/* The PC_UDISP_W operator may show up as a label or as a pc[disp]
+   expression.  So there's no point in attempting to match this...  */
+#define match_pc_disp	match_anything
+
+static int
+match_sp(char *str)
+{
+  /* SP in any form will do */
+  return avr32_parse_intreg(str) == AVR32_REG_SP;
+}
+
+static int
+match_sp_disp(char *str)
+{
+  int regid, ret = 1;
+  char *p, c;
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  /* allow empty displacement, meaning zero */
+  if (p[0] == '[')
+    {
+      char *end;
+      for (end = p + 1; *end; end++) ;
+      if (end[-1] != ']')
+	return 0;
+    }
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  if (regid != AVR32_REG_SP)
+    ret = 0;
+
+  *p = c;
+  return ret;
+}
+
+static int
+match_cpno(char *str)
+{
+  if (strncasecmp(str, "cp", 2) != 0)
+    return 0;
+  return 1;
+}
+
+static int
+match_cpreg(char *str)
+{
+  if (strncasecmp(str, "cr", 2) != 0)
+    return 0;
+  return 1;
+}
+
+/* We allow complex expressions, and register names may show up as
+   symbols.  Just make sure immediate expressions are always matched
+   last.  */
+#define match_const		match_anything
+#define match_jmplabel		match_anything
+#define match_number		match_anything
+
+/* Mnemonics that take reglists never accept anything else */
+#define match_reglist8		match_anything
+#define match_reglist9		match_anything
+#define match_reglist16		match_anything
+#define match_reglist_ldm	match_anything
+#define match_reglist_cp8	match_anything
+#define match_reglist_cpd8	match_anything
+
+/* Ditto for retval, jospinc and mcall */
+#define match_retval		match_anything
+#define match_jospinc		match_anything
+#define match_mcall		match_anything
+
+/* COH is used to select between two different syntaxes */
+static int
+match_coh(char *str)
+{
+  return strcasecmp(str, "coh") == 0;
+}
+
+static int
+match_fpreg(char *str)
+{
+  unsigned long regid;
+  char *endptr;
+
+  if ((str[0] != 'f' && str[0] != 'F')
+      || (str[1] != 'r' && str[1] != 'R'))
+    return 0;
+
+  str += 2;
+  regid = strtoul(str, &endptr, 10);
+  if (!*str || *endptr)
+    return 0;
+
+  return 1;
+}
+
+static int
+match_picoreg(char *str)
+{
+  int regid;
+
+  regid = avr32_parse_picoreg(str);
+  if (regid < 0)
+    return 0;
+  return 1;
+}
+
+#define match_pico_reglist_w	match_anything
+#define match_pico_reglist_d	match_anything
+
+static int
+match_pico_in(char *str)
+{
+  unsigned long regid;
+  char *end;
+
+  if (strncasecmp(str, "in", 2) != 0)
+    return 0;
+
+  str += 2;
+  regid = strtoul(str, &end, 10);
+  if (!*str || *end)
+    return 0;
+
+  return 1;
+}
+
+static int
+match_pico_out0(char *str)
+{
+  if (strcasecmp(str, "out0") != 0)
+    return 0;
+  return 1;
+}
+
+static int
+match_pico_out1(char *str)
+{
+  if (strcasecmp(str, "out1") != 0)
+    return 0;
+  return 1;
+}
+
+static int
+match_pico_out2(char *str)
+{
+  if (strcasecmp(str, "out2") != 0)
+    return 0;
+  return 1;
+}
+
+static int
+match_pico_out3(char *str)
+{
+  if (strcasecmp(str, "out3") != 0)
+    return 0;
+  return 1;
+}
+
+static void parse_nothing(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+			  char *str ATTRIBUTE_UNUSED,
+			  int opindex ATTRIBUTE_UNUSED)
+{
+  /* Do nothing (this is used for "match-only" operands like COH) */
+}
+
+static void
+parse_const(const struct avr32_operand *op, char *str,
+	    int opindex ATTRIBUTE_UNUSED)
+{
+  expressionS *exp = &current_insn.immediate;
+  expressionS *sym_exp;
+  int slot;
+  char *save;
+
+  pr_debug("parse_const: `%s' (signed: %d, pcrel: %d, align: %d)\n",
+	   str, op->is_signed, op->is_pcrel, op->align_order);
+
+  save = input_line_pointer;
+  input_line_pointer = str;
+
+  expression(exp);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].align_order = op->align_order;
+  current_insn.pcrel = op->is_pcrel;
+
+  switch (exp->X_op)
+    {
+    case O_illegal:
+      as_bad(_("illegal operand"));
+      break;
+    case O_absent:
+      as_bad(_("missing operand"));
+      break;
+    case O_constant:
+      pr_debug("  -> constant: %ld\n", (long)exp->X_add_number);
+      current_insn.field_value[slot].value = exp->X_add_number;
+      break;
+    case O_uminus:
+      pr_debug("  -> uminus\n");
+      sym_exp = symbol_get_value_expression(exp->X_add_symbol);
+      switch (sym_exp->X_op) {
+      case O_subtract:
+	pr_debug("     -> subtract: switching operands\n");
+	exp->X_op_symbol = sym_exp->X_add_symbol;
+	exp->X_add_symbol = sym_exp->X_op_symbol;
+	exp->X_op = O_subtract;
+	/* TODO: Remove the old X_add_symbol */
+	break;
+      default:
+	as_bad(_("Expression too complex\n"));
+	break;
+      }
+      break;
+#if 0
+    case O_subtract:
+      /* Any expression subtracting a symbol from the current section
+	 can be made PC-relative by adding the right offset.  */
+      if (S_GET_SEGMENT(exp->X_op_symbol) == now_seg)
+	current_insn.pcrel = TRUE;
+      pr_debug("  -> subtract: pcrel? %s\n",
+	       current_insn.pcrel ? "yes" : "no");
+      /* fall through */
+#endif
+    default:
+      pr_debug("  -> (%p <%d> %p + %d)\n",
+	       exp->X_add_symbol, exp->X_op, exp->X_op_symbol,
+	       exp->X_add_number);
+      current_insn.field_value[slot].value = 0;
+      break;
+    }
+
+  input_line_pointer = save;
+}
+
+static void
+parse_jmplabel(const struct avr32_operand *op, char *str,
+	       int opindex ATTRIBUTE_UNUSED)
+{
+  expressionS *exp = &current_insn.immediate;
+  int slot;
+  char *save;
+
+  pr_debug("parse_jmplabel: `%s' (signed: %d, pcrel: %d, align: %d)\n",
+	   str, op->is_signed, op->is_pcrel, op->align_order);
+
+  save = input_line_pointer;
+  input_line_pointer = str;
+
+  expression(exp);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].align_order = op->align_order;
+  current_insn.pcrel = TRUE;
+
+  switch (exp->X_op)
+    {
+    case O_illegal:
+      as_bad(_("illegal operand"));
+      break;
+    case O_absent:
+      as_bad(_("missing operand"));
+      break;
+    case O_constant:
+      pr_debug("  -> constant: %ld\n", (long)exp->X_add_number);
+      current_insn.field_value[slot].value = exp->X_add_number;
+      current_insn.pcrel = 0;
+      break;
+    default:
+      pr_debug("  -> (%p <%d> %p + %d)\n",
+	       exp->X_add_symbol, exp->X_op, exp->X_op_symbol,
+	       exp->X_add_number);
+      current_insn.field_value[slot].value = 0;
+      break;
+    }
+
+  input_line_pointer = save;
+}
+
+static void
+parse_intreg(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+	     char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  int regid, slot;
+
+  pr_debug("parse_intreg: `%s'\n", str);
+
+  regid = avr32_parse_intreg(str);
+  assert(regid >= 0);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+  current_insn.field_value[slot].align_order = op->align_order;
+}
+
+static void
+parse_intreg_predec(const struct avr32_operand *op, char *str, int opindex)
+{
+  parse_intreg(op, str + 2, opindex);
+}
+
+static void
+parse_intreg_postinc(const struct avr32_operand *op, char *str, int opindex)
+{
+  char *p, c;
+
+  pr_debug("parse_intreg_postinc: `%s'\n", str);
+
+  for (p = str; *p != '+'; p++) ;
+
+  c = *p, *p = 0;
+  parse_intreg(op, str, opindex);
+  *p = c;
+}
+
+static void
+parse_intreg_shift(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  int regid, slot, shift = 0;
+  char *p, c;
+  char shiftop;
+
+  pr_debug("parse Ry<<sa: `%s'\n", str);
+
+  for (p = str; *p; p++)
+    if (*p == '<' || *p == '>')
+      break;
+
+  shiftop = *p;
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  assert(regid >= 0);
+  *p = c;
+
+  if (c)
+    {
+      if (p[0] != shiftop || p[1] != shiftop)
+	as_bad(_("expected shift operator in `%s'"), p);
+      else
+	{
+	  expressionS exp;
+	  char *saved;
+
+	  saved = input_line_pointer;
+	  input_line_pointer = p + 2;
+	  expression(&exp);
+	  input_line_pointer = saved;
+
+	  if (exp.X_op != O_constant)
+	    as_bad(_("shift amount must be a numeric constant"));
+	  else
+	    shift = exp.X_add_number;
+	}
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = shift;
+}
+
+/* The match() function selected the right opcode, so it doesn't
+   matter which way we shift any more.  */
+#define parse_intreg_lsl	parse_intreg_shift
+#define parse_intreg_lsr	parse_intreg_shift
+
+static void
+parse_intreg_part(const struct avr32_operand *op, char *str,
+		  int opindex ATTRIBUTE_UNUSED)
+{
+  static const char bparts[] = { 'b', 'l', 'u', 't' };
+  static const char hparts[] = { 'b', 't' };
+  unsigned int slot, sel;
+  int regid;
+  char *p, c;
+
+  pr_debug("parse reg:part `%s'\n", str);
+
+  for (p = str; *p; p++)
+    if (*p == ':')
+      break;
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  assert(regid >= 0);
+  *p = c;
+
+  assert(c == ':');
+
+  if (op->align_order)
+    {
+      for (sel = 0; sel < sizeof(hparts); sel++)
+	if (TOLOWER(p[1]) == hparts[sel])
+	  break;
+
+      if (sel >= sizeof(hparts))
+	{
+	  as_bad(_("invalid halfword selector `%c' (must be either b or t)"),
+		 p[1]);
+	  sel = 0;
+	}
+    }
+  else
+    {
+      for (sel = 0; sel < sizeof(bparts); sel++)
+	if (TOLOWER(p[1]) == bparts[sel])
+	  break;
+
+      if (sel >= sizeof(bparts))
+	{
+	  as_bad(_("invalid byte selector `%c' (must be one of b,l,u,t)"),
+		 p[1]);
+	  sel = 0;
+	}
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = sel;
+}
+
+/* This is the parser for "Rp[displacement]" expressions.  In addition
+   to the "official" syntax, we accept a label as a replacement for
+   the register expression.  This syntax implies Rp=PC and the
+   displacement is the pc-relative distance to the label.  */
+static void
+parse_intreg_disp(const struct avr32_operand *op, char *str, int opindex)
+{
+  expressionS *exp = &current_insn.immediate;
+  int slot, regid;
+  char *save, *p, c;
+
+  pr_debug("parse_intreg_disp: `%s' (signed: %d, pcrel: %d, align: %d)\n",
+	   str, op->is_signed, op->is_pcrel, op->align_order);
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  slot = current_insn.next_slot++;
+
+  /* First, check if we have a valid register either before '[' or as
+     the sole expression.  If so, we use the Rp[disp] syntax.  */
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  *p = c;
+
+  if (regid >= 0)
+    {
+      current_insn.field_value[slot].value = regid;
+
+      slot = current_insn.next_slot++;
+      current_insn.field_value[slot].align_order = op->align_order;
+
+      if (c == '[')
+	{
+	  save = input_line_pointer;
+	  input_line_pointer = p + 1;
+
+	  expression(exp);
+
+	  if (*input_line_pointer != ']')
+	    as_bad(_("junk after displacement expression"));
+
+	  input_line_pointer = save;
+
+	  switch (exp->X_op)
+	    {
+	    case O_illegal:
+	      as_bad(_("illegal displacement expression"));
+	      break;
+	    case O_absent:
+	      as_bad(_("missing displacement expression"));
+	      break;
+	    case O_constant:
+	      pr_debug("  -> constant: %ld\n", exp->X_add_number);
+	      current_insn.field_value[slot].value = exp->X_add_number;
+	      break;
+#if 0
+	    case O_subtract:
+	      if (S_GET_SEGMENT(exp->X_op_symbol) == now_seg)
+		current_insn.pcrel = TRUE;
+	      pr_debug("  -> subtract: pcrel? %s\n",
+		       current_insn.pcrel ? "yes" : "no");
+	      /* fall through */
+#endif
+	    default:
+	      pr_debug("  -> (%p <%d> %p + %d)\n",
+		       exp->X_add_symbol, exp->X_op, exp->X_op_symbol,
+		       exp->X_add_number);
+	      current_insn.field_value[slot].value = 0;
+	    }
+	}
+      else
+	{
+	  exp->X_op = O_constant;
+	  exp->X_add_number = 0;
+	  current_insn.field_value[slot].value = 0;
+	}
+    }
+  else
+    {
+      /* Didn't find a valid register.  Try parsing it as a label.  */
+      current_insn.field_value[slot].value = AVR32_REG_PC;
+      parse_jmplabel(op, str, opindex);
+    }
+}
+
+static void
+parse_intreg_index(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  int slot, regid;
+  char *p, *end, c;
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  assert(*p);
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  assert(regid >= 0);
+  *p = c;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+
+  p++;
+  for (end = p; *end; end++)
+    if (*end == ']' || *end == '<')
+      break;
+
+  assert(*end);
+
+  c = *end, *end = 0;
+  regid = avr32_parse_intreg(p);
+  assert(regid >= 0);
+  *end = c;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = 0;
+
+  if (*end == '<')
+    {
+      expressionS exp;
+      char *save;
+
+      p = end + 2;
+      for (end = p; *end; end++)
+	if (*end == ']')
+	  break;
+
+      assert(*end == ']');
+
+      c = *end, *end = 0;
+      save = input_line_pointer;
+      input_line_pointer = p;
+      expression(&exp);
+
+      if (*input_line_pointer)
+	as_bad(_("junk after shift expression"));
+
+      *end = c;
+      input_line_pointer = save;
+
+      if (exp.X_op == O_constant)
+	current_insn.field_value[slot].value = exp.X_add_number;
+      else
+	as_bad(_("shift expression too complex"));
+    }
+}
+
+static void
+parse_intreg_xindex(const struct avr32_operand *op, char *str, int opindex)
+{
+  int slot, regid;
+  char *p, *end, c;
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  assert(*p);
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  assert(regid >= 0);
+  *p = c;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+
+  p++;
+  for (end = p; *end; end++)
+    if (*end == '<')
+      break;
+
+  assert(*end);
+
+  c = *end, *end = 0;
+  parse_intreg_part(op, p, opindex);
+  *end = c;
+}
+
+static void
+parse_pc_disp(const struct avr32_operand *op, char *str, int opindex)
+{
+  char *p, c;
+
+  for (p = str; *p; p++)
+    if (*p == '[')
+      break;
+
+  /* The lddpc instruction comes in two different syntax variants:
+       lddpc reg, expression
+       lddpc reg, pc[disp]
+     If the operand contains a '[', we use the second form.  */
+  if (*p)
+    {
+      int regid;
+
+      c = *p, *p = 0;
+      regid = avr32_parse_intreg(str);
+      *p = c;
+      if (regid == AVR32_REG_PC)
+	{
+	  char *end;
+
+	  for (end = ++p; *end; end++) ;
+	  if (*(--end) != ']')
+	    as_bad(_("unrecognized form of instruction: `%s'"), str);
+	  else
+	    {
+	      c = *end, *end = 0;
+	      parse_const(op, p, opindex);
+	      *end = c;
+	      current_insn.pcrel = 0;
+	    }
+	}
+      else
+	as_bad(_("unrecognized form of instruction: `%s'"), str);
+    }
+  else
+    {
+      parse_jmplabel(op, str, opindex);
+    }
+}
+
+static void parse_sp(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		     char *str ATTRIBUTE_UNUSED,
+		     int opindex ATTRIBUTE_UNUSED)
+{
+  int slot;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = AVR32_REG_SP;
+}
+
+static void
+parse_sp_disp(const struct avr32_operand *op, char *str, int opindex)
+{
+  char *p, c;
+
+  for (; *str; str++)
+    if (*str == '[')
+      break;
+
+  assert(*str);
+
+  for (p = ++str; *p; p++)
+    if (*p == ']')
+      break;
+
+  c = *p, *p = 0;
+  parse_const(op, str, opindex);
+  *p = c;
+}
+
+static void
+parse_cpno(const struct avr32_operand *op ATTRIBUTE_UNUSED, char *str,
+	   int opindex ATTRIBUTE_UNUSED)
+{
+  int slot;
+
+  str += 2;
+  if (*str == '#')
+    str++;
+  if (*str < '0' || *str > '7' || str[1])
+    as_bad(_("invalid coprocessor `%s'"), str);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = *str - '0';
+}
+
+static void
+parse_cpreg(const struct avr32_operand *op, char *str,
+	    int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned int crid;
+  int slot;
+  char *endptr;
+
+  str += 2;
+  crid = strtoul(str, &endptr, 10);
+  if (*endptr || crid > 15 || crid & ((1 << op->align_order) - 1))
+    as_bad(_("invalid coprocessor register `%s'"), str);
+
+  crid >>= op->align_order;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = crid;
+}
+
+static void
+parse_number(const struct avr32_operand *op, char *str,
+	     int opindex ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  int slot;
+  char *save;
+
+  save = input_line_pointer;
+  input_line_pointer = str;
+  expression(&exp);
+  input_line_pointer = save;
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].align_order = op->align_order;
+
+  if (exp.X_op == O_constant)
+      current_insn.field_value[slot].value = exp.X_add_number;
+  else
+      as_bad(_("invalid numeric expression `%s'"), str);
+}
+
+static void
+parse_reglist8(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+	       char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask;
+  unsigned long value = 0;
+  int slot;
+  char *tail;
+
+  regmask = avr32_parse_reglist(str, &tail);
+  if (*tail)
+    as_bad(_("invalid register list `%s'"), str);
+  else
+    {
+      if (avr32_make_regmask8(regmask, &value))
+	as_bad(_("register list `%s' doesn't fit"), str);
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = value;
+}
+
+static int
+parse_reglist_tail(char *str, unsigned long regmask)
+{
+  expressionS exp;
+  char *save, *p, c;
+  int regid;
+
+  for (p = str + 1; *p; p++)
+    if (*p == '=')
+      break;
+
+  if (!*p)
+    {
+      as_bad(_("invalid register list `%s'"), str);
+      return -2;
+    }
+
+  c = *p, *p = 0;
+  regid = avr32_parse_intreg(str);
+  *p = c;
+
+  if (regid != 12)
+    {
+      as_bad(_("invalid register list `%s'"), str);
+      return -2;
+    }
+
+  /* If we have an assignment, we must pop PC and we must _not_
+     pop LR or R12 */
+  if (!(regmask & (1 << AVR32_REG_PC)))
+    {
+      as_bad(_("return value specified for non-return instruction"));
+      return -2;
+    }
+  else if (regmask & ((1 << AVR32_REG_R12) | (1 << AVR32_REG_LR)))
+    {
+      as_bad(_("can't pop LR or R12 when specifying return value"));
+      return -2;
+    }
+
+  save = input_line_pointer;
+  input_line_pointer = p + 1;
+  expression(&exp);
+  input_line_pointer = save;
+
+  if (exp.X_op != O_constant
+      || exp.X_add_number < -1
+      || exp.X_add_number > 1)
+    {
+      as_bad(_("invalid return value `%s'"), str);
+      return -2;
+    }
+
+  return exp.X_add_number;
+}
+
+static void
+parse_reglist9(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+	       char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask;
+  unsigned long value = 0, kbit = 0;
+  int slot;
+  char *tail;
+
+  regmask = avr32_parse_reglist(str, &tail);
+  /* printf("parsed reglist16: %04lx, tail: `%s'\n", regmask, tail); */
+  if (*tail)
+    {
+      int retval;
+
+      retval = parse_reglist_tail(tail, regmask);
+
+      switch (retval)
+	{
+	case -1:
+	  regmask |= 1 << AVR32_REG_LR;
+	  break;
+	case 0:
+	  break;
+	case 1:
+	  regmask |= 1 << AVR32_REG_R12;
+	  break;
+	default:
+	  break;
+	}
+
+      kbit = 1;
+    }
+
+  if (avr32_make_regmask8(regmask, &value))
+    as_bad(_("register list `%s' doesn't fit"), str);
+
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = (value << 1) | kbit;
+}
+
+static void
+parse_reglist16(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask;
+  int slot;
+  char *tail;
+
+  regmask = avr32_parse_reglist(str, &tail);
+  if (*tail)
+    as_bad(_("invalid register list `%s'"), str);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regmask;
+}
+
+static void
+parse_reglist_ldm(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		  char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask;
+  int slot, rp, w_bit = 0;
+  char *tail, *p, c;
+
+  for (p = str; *p && *p != ','; p++)
+    if (*p == '+')
+      break;
+
+  c = *p, *p = 0;
+  rp = avr32_parse_intreg(str);
+  *p = c;
+  if (rp < 0)
+    {
+      as_bad(_("invalid destination register in `%s'"), str);
+      return;
+    }
+
+  if (p[0] == '+' && p[1] == '+')
+    {
+      w_bit = 1;
+      p += 2;
+    }
+
+  if (*p != ',')
+    {
+      as_bad(_("expected `,' after destination register in `%s'"), str);
+      return;
+    }
+
+  str = p + 1;
+  regmask = avr32_parse_reglist(str, &tail);
+  if (*tail)
+    {
+      int retval;
+
+      if (rp != AVR32_REG_SP)
+	{
+	  as_bad(_("junk at end of line: `%s'"), tail);
+	  return;
+	}
+
+      rp = AVR32_REG_PC;
+
+      retval = parse_reglist_tail(tail, regmask);
+
+      switch (retval)
+	{
+	case -1:
+	  regmask |= 1 << AVR32_REG_LR;
+	  break;
+	case 0:
+	  break;
+	case 1:
+	  regmask |= 1 << AVR32_REG_R12;
+	  break;
+	default:
+	  return;
+	}
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = rp;
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = w_bit;
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regmask;
+}
+
+static void
+parse_reglist_cp8(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		  char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask;
+  int slot, h_bit = 0;
+  char *tail;
+
+  regmask = avr32_parse_cpreglist(str, &tail);
+  if (*tail)
+    as_bad(_("junk at end of line: `%s'"), tail);
+  else if (regmask & 0xffUL)
+    {
+      if (regmask & 0xff00UL)
+	as_bad(_("register list `%s' doesn't fit"), str);
+      regmask &= 0xff;
+    }
+  else if (regmask & 0xff00UL)
+    {
+      regmask >>= 8;
+      h_bit = 1;
+    }
+  else
+    as_warn(_("register list is empty"));
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regmask;
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = h_bit;
+}
+
+static void
+parse_reglist_cpd8(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask, regmask_d = 0;
+  int slot, i;
+  char *tail;
+
+  regmask = avr32_parse_cpreglist(str, &tail);
+  if (*tail)
+    as_bad(_("junk at end of line: `%s'"), tail);
+
+  for (i = 0; i < 8; i++)
+    {
+      if (regmask & 1)
+	{
+	  if (!(regmask & 2))
+	    {
+	      as_bad(_("register list `%s' doesn't fit"), str);
+	      break;
+	    }
+	  regmask_d |= 1 << i;
+	}
+      else if (regmask & 2)
+	{
+	  as_bad(_("register list `%s' doesn't fit"), str);
+	  break;
+	}
+
+      regmask >>= 2;
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regmask_d;
+}
+
+static void
+parse_retval(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+	     char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  int regid, slot;
+
+  regid = avr32_parse_intreg(str);
+  if (regid < 0)
+    {
+      expressionS exp;
+      char *save;
+
+      regid = 0;
+
+      save = input_line_pointer;
+      input_line_pointer = str;
+      expression(&exp);
+      input_line_pointer = save;
+
+      if (exp.X_op != O_constant)
+	as_bad(_("invalid return value `%s'"), str);
+      else
+	switch (exp.X_add_number)
+	  {
+	  case -1:
+	    regid = AVR32_REG_LR;
+	    break;
+	  case 0:
+	    regid = AVR32_REG_SP;
+	    break;
+	  case 1:
+	    regid = AVR32_REG_PC;
+	    break;
+	  default:
+	    as_bad(_("invalid return value `%s'"), str);
+	    break;
+	  }
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+}
+
+#define parse_mcall parse_intreg_disp
+
+static void
+parse_jospinc(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+	      char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  int slot;
+  char *save;
+
+  save = input_line_pointer;
+  input_line_pointer = str;
+  expression(&exp);
+  input_line_pointer = save;
+
+  slot = current_insn.next_slot++;
+
+  if (exp.X_op == O_constant)
+    {
+      if (exp.X_add_number > 0)
+	exp.X_add_number--;
+      current_insn.field_value[slot].value = exp.X_add_number;
+    }
+  else
+    as_bad(_("invalid numeric expression `%s'"), str);
+}
+
+#define parse_coh		parse_nothing
+
+static void
+parse_fpreg(const struct avr32_operand *op,
+	    char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regid;
+  int slot;
+
+  regid = strtoul(str + 2, NULL, 10);
+
+  if ((regid >= 16) || (regid & ((1 << op->align_order) - 1)))
+    as_bad(_("invalid floating-point register `%s'"), str);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+  current_insn.field_value[slot].align_order = op->align_order;
+}
+
+static void
+parse_picoreg(const struct avr32_operand *op,
+	      char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regid;
+  int slot;
+
+  regid = avr32_parse_picoreg(str);
+  if (regid & ((1 << op->align_order) - 1))
+    as_bad(_("invalid double-word PiCo register `%s'"), str);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+  current_insn.field_value[slot].align_order = op->align_order;
+}
+
+static void
+parse_pico_reglist_w(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		     char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask;
+  int slot, h_bit = 0;
+  char *tail;
+
+  regmask = avr32_parse_pico_reglist(str, &tail);
+  if (*tail)
+    as_bad(_("junk at end of line: `%s'"), tail);
+
+  if (regmask & 0x00ffUL)
+    {
+      if (regmask & 0xff00UL)
+	as_bad(_("register list `%s' doesn't fit"), str);
+      regmask &= 0x00ffUL;
+    }
+  else if (regmask & 0xff00UL)
+    {
+      regmask >>= 8;
+      h_bit = 1;
+    }
+  else
+    as_warn(_("register list is empty"));
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regmask;
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = h_bit;
+}
+
+static void
+parse_pico_reglist_d(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+		     char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regmask, regmask_d = 0;
+  int slot, i;
+  char *tail;
+
+  regmask = avr32_parse_pico_reglist(str, &tail);
+  if (*tail)
+    as_bad(_("junk at end of line: `%s'"), tail);
+
+  for (i = 0; i < 8; i++)
+    {
+      if (regmask & 1)
+	{
+	  if (!(regmask & 2))
+	    {
+	      as_bad(_("register list `%s' doesn't fit"), str);
+	      break;
+	    }
+	  regmask_d |= 1 << i;
+	}
+      else if (regmask & 2)
+	{
+	  as_bad(_("register list `%s' doesn't fit"), str);
+	  break;
+	}
+
+      regmask >>= 2;
+    }
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regmask_d;
+}
+
+static void
+parse_pico_in(const struct avr32_operand *op ATTRIBUTE_UNUSED,
+	      char *str, int opindex ATTRIBUTE_UNUSED)
+{
+  unsigned long regid;
+  int slot;
+
+  regid = strtoul(str + 2, NULL, 10);
+
+  if (regid >= 12)
+    as_bad(_("invalid PiCo IN register `%s'"), str);
+
+  slot = current_insn.next_slot++;
+  current_insn.field_value[slot].value = regid;
+  current_insn.field_value[slot].align_order = 0;
+}
+
+#define parse_pico_out0		parse_nothing
+#define parse_pico_out1		parse_nothing
+#define parse_pico_out2		parse_nothing
+#define parse_pico_out3		parse_nothing
+
+#define OP(name, sgn, pcrel, align, func) \
+  { AVR32_OPERAND_##name, sgn, pcrel, align, match_##func, parse_##func }
+
+struct avr32_operand avr32_operand_table[] = {
+  OP(INTREG, 0, 0, 0, intreg),
+  OP(INTREG_PREDEC, 0, 0, 0, intreg_predec),
+  OP(INTREG_POSTINC, 0, 0, 0, intreg_postinc),
+  OP(INTREG_LSL, 0, 0, 0, intreg_lsl),
+  OP(INTREG_LSR, 0, 0, 0, intreg_lsr),
+  OP(INTREG_BSEL, 0, 0, 0, intreg_part),
+  OP(INTREG_HSEL, 0, 0, 1, intreg_part),
+  OP(INTREG_SDISP, 1, 0, 0, intreg_disp),
+  OP(INTREG_SDISP_H, 1, 0, 1, intreg_disp),
+  OP(INTREG_SDISP_W, 1, 0, 2, intreg_disp),
+  OP(INTREG_UDISP, 0, 0, 0, intreg_disp),
+  OP(INTREG_UDISP_H, 0, 0, 1, intreg_disp),
+  OP(INTREG_UDISP_W, 0, 0, 2, intreg_disp),
+  OP(INTREG_INDEX, 0, 0, 0, intreg_index),
+  OP(INTREG_XINDEX, 0, 0, 0, intreg_xindex),
+  OP(DWREG, 0, 0, 1, intreg),
+  OP(PC_UDISP_W, 0, 1, 2, pc_disp),
+  OP(SP, 0, 0, 0, sp),
+  OP(SP_UDISP_W, 0, 0, 2, sp_disp),
+  OP(CPNO, 0, 0, 0, cpno),
+  OP(CPREG, 0, 0, 0, cpreg),
+  OP(CPREG_D, 0, 0, 1, cpreg),
+  OP(UNSIGNED_CONST, 0, 0, 0, const),
+  OP(UNSIGNED_CONST_W, 0, 0, 2, const),
+  OP(SIGNED_CONST, 1, 0, 0, const),
+  OP(SIGNED_CONST_W, 1, 0, 2, const),
+  OP(JMPLABEL, 1, 1, 1, jmplabel),
+  OP(UNSIGNED_NUMBER, 0, 0, 0, number),
+  OP(UNSIGNED_NUMBER_W, 0, 0, 2, number),
+  OP(REGLIST8, 0, 0, 0, reglist8),
+  OP(REGLIST9, 0, 0, 0, reglist9),
+  OP(REGLIST16, 0, 0, 0, reglist16),
+  OP(REGLIST_LDM, 0, 0, 0, reglist_ldm),
+  OP(REGLIST_CP8, 0, 0, 0, reglist_cp8),
+  OP(REGLIST_CPD8, 0, 0, 0, reglist_cpd8),
+  OP(RETVAL, 0, 0, 0, retval),
+  OP(MCALL, 1, 0, 2, mcall),
+  OP(JOSPINC, 0, 0, 0, jospinc),
+  OP(COH, 0, 0, 0, coh),
+  OP(FPREG_S, 0, 0, 0, fpreg),
+  OP(FPREG_D, 0, 0, 1, fpreg),
+  OP(PICO_REG_W, 0, 0, 0, picoreg),
+  OP(PICO_REG_D, 0, 0, 1, picoreg),
+  OP(PICO_REGLIST_W, 0, 0, 0, pico_reglist_w),
+  OP(PICO_REGLIST_D, 0, 0, 0, pico_reglist_d),
+  OP(PICO_IN, 0, 0, 0, pico_in),
+  OP(PICO_OUT0, 0, 0, 0, pico_out0),
+  OP(PICO_OUT1, 0, 0, 0, pico_out1),
+  OP(PICO_OUT2, 0, 0, 0, pico_out2),
+  OP(PICO_OUT3, 0, 0, 0, pico_out3),
+};
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  pr_debug("md_undefined_symbol: %s\n", name);
+  return 0;
+}
+
+struct avr32_relax_type
+{
+  long lower_bound;
+  long upper_bound;
+  unsigned char align;
+  unsigned char length;
+  signed short next;
+};
+
+#define EMPTY { 0, 0, 0, 0, -1 }
+#define C(lower, upper, align, next)			\
+  { (lower), (upper), (align), 2, AVR32_OPC_##next }
+#define E(lower, upper, align)				\
+  { (lower), (upper), (align), 4, -1 }
+
+static const struct avr32_relax_type avr32_relax_table[] =
+  {
+    /* 0 */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY,
+    E(0, 65535, 0), E(0, 65535, 0), E(0, 65535, 0), E(0, 65535, 0),
+    EMPTY,
+    /* 16 */
+    EMPTY, EMPTY, EMPTY, EMPTY,
+
+    C(-256, 254, 1, BREQ2), C(-256, 254, 1, BRNE2),
+    C(-256, 254, 1, BRCC2), C(-256, 254, 1, BRCS2),
+    C(-256, 254, 1, BRGE2), C(-256, 254, 1, BRLT2),
+    C(-256, 254, 1, BRMI2), C(-256, 254, 1, BRPL2),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    /* 32 */
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+    E(-2097152, 2097150, 1), E(-2097152, 2097150, 1),
+
+    EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 48 */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY,
+
+    C(-32, 31, 0, CP_W3), E(-1048576, 1048575, 0),
+
+    EMPTY, EMPTY, EMPTY,
+    /* 64: csrfcz */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    E(0, 65535, 0), E(0, 65535, 0),
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    E(-32768, 32767, 0),
+    /* 80: LD_SB2 */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+
+    C(0, 7, 0, LD_UB4), E(-32768, 32767, 0),
+
+    EMPTY,
+    EMPTY, EMPTY,
+
+    C(0, 14, 1, LD_SH4), E(-32768, 32767, 0),
+
+    EMPTY, EMPTY, EMPTY,
+
+    C(0, 14, 1, LD_UH4),
+
+    /* 96: LD_UH4 */
+    E(-32768, 32767, 0),
+
+    EMPTY, EMPTY, EMPTY, EMPTY,
+
+    C(0, 124, 2, LD_W4), E(-32768, 32767, 0),
+
+    E(0, 1020, 2),	/* LDC_D1 */
+    EMPTY, EMPTY,
+    E(0, 1020, 2),	/* LDC_W1 */
+    EMPTY, EMPTY,
+    E(0, 16380, 2),	/* LDC0_D */
+    E(0, 16380, 2),	/* LDC0_W */
+    EMPTY,
+
+    /* 112: LDCM_D_PU */
+    EMPTY, EMPTY, EMPTY,
+
+    C(0, 508, 2, LDDPC_EXT), E(-32768, 32767, 0),
+
+    EMPTY,EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 134: MACHH_W */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    E(-131072, 131068, 2),	/* MCALL */
+    E(0, 1020, 2),		/* MFDR */
+    E(0, 1020, 2),		/* MFSR */
+    EMPTY, EMPTY,
+
+    C(-128, 127, 0, MOV2), E(-1048576, 1048575, 0),
+
+    EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+
+    E(-128, 127, 0),		/* MOVEQ2 */
+    E(-128, 127, 0),		/* MOVNE2 */
+    E(-128, 127, 0),		/* MOVCC2 */
+    E(-128, 127, 0),		/* 166: MOVCS2 */
+    E(-128, 127, 0),		/* MOVGE2 */
+    E(-128, 127, 0),		/* MOVLT2 */
+    E(-128, 127, 0),		/* MOVMI2 */
+    E(-128, 127, 0),		/* MOVPL2 */
+    E(-128, 127, 0),		/* MOVLS2 */
+    E(-128, 127, 0),		/* MOVGT2 */
+    E(-128, 127, 0),		/* MOVLE2 */
+    E(-128, 127, 0),		/* MOVHI2 */
+    E(-128, 127, 0),		/* MOVVS2 */
+    E(-128, 127, 0),		/* MOVVC2 */
+    E(-128, 127, 0),		/* MOVQS2 */
+    E(-128, 127, 0),		/* MOVAL2 */
+
+    E(0, 1020, 2),		/* MTDR */
+    E(0, 1020, 2),		/* MTSR */
+    EMPTY,
+    EMPTY,
+    E(-128, 127, 0),		/* MUL3 */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 198: MVCR_W */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    E(0, 65535, 0), E(0, 65535, 0),
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 230: PASR_H */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 262: PUNPCKSB_H */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+
+    C(-1024, 1022, 1, RCALL2), E(-2097152, 2097150, 1),
+
+    EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY,
+
+    C(-1024, 1022, 1, BRAL),
+
+    EMPTY, EMPTY, EMPTY,
+    E(-128, 127, 0),		/* RSUB2 */
+    /* 294: SATADD_H */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    E(0, 255, 0),		/* SLEEP */
+    EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 326: ST_B2 */
+    EMPTY, EMPTY,
+    C(0, 7, 0, ST_B4), E(-32768, 32767, 0),
+    EMPTY, EMPTY, EMPTY, EMPTY,
+    E(-32768, 32767, 0),
+    EMPTY, EMPTY, EMPTY,
+    C(0, 14, 1, ST_H4), E(-32768, 32767, 0),
+    EMPTY, EMPTY,
+    EMPTY,
+    C(0, 60, 2, ST_W4), E(-32768, 32767, 0),
+    E(0, 1020, 2),	/* STC_D1 */
+    EMPTY, EMPTY,
+    E(0, 1020, 2),	/* STC_W1 */
+    EMPTY, EMPTY,
+    E(0, 16380, 2),	/* STC0_D */
+    E(0, 16380, 2),	/* STC0_W */
+
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 358: STDSP */
+    EMPTY, EMPTY,
+    E(0, 1020, 2),	/* STHH_W1 */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY,
+    E(-32768, 32767, 0),
+    C(-512, 508, 2, SUB4),
+    C(-128, 127, 0, SUB4), E(-1048576, 1048576, 0),
+    /* SUB{cond} */
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    /* SUBF{cond} */
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    EMPTY,
+
+    /* 406: SWAP_B */
+    EMPTY, EMPTY, EMPTY,
+    E(0, 255, 0),	/* SYNC */
+    EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 414: TST */
+    EMPTY, EMPTY, E(-65536, 65535, 2), E(-65536, 65535, 2), E(-65536, 65535, 2), EMPTY, EMPTY, EMPTY,
+    /* 422: RSUB{cond} */
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0), E(-128, 127, 0),
+    /* 436: ADD{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 454: SUB{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 472: AND{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 486: OR{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 502: EOR{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 518: LD.w{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 534: LD.sh{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 550: LD.uh{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 566: LD.sb{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 582: LD.ub{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 596: ST.w{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 614: ST.h{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 630: ST.b{cond} */
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
+    /* 646: movh */
+    E(0, 65535, 0)
+  };
+
+#undef E
+#undef C
+#undef EMPTY
+
+#define AVR32_RS_NONE (-1)
+
+#define avr32_rs_size(state) (avr32_relax_table[(state)].length)
+#define avr32_rs_align(state) (avr32_relax_table[(state)].align)
+#define relax_more(state) (avr32_relax_table[(state)].next)
+
+#define opc_initial_substate(opc) ((opc)->id)
+
+static int need_relax(int subtype, offsetT distance)
+{
+  offsetT upper_bound, lower_bound;
+
+  upper_bound = avr32_relax_table[subtype].upper_bound;
+  lower_bound = avr32_relax_table[subtype].lower_bound;
+
+  if (distance & ((1 << avr32_rs_align(subtype)) - 1))
+    return 1;
+  if ((distance > upper_bound) || (distance < lower_bound))
+    return 1;
+
+  return 0;
+}
+
+enum {
+  LDA_SUBTYPE_MOV1,
+  LDA_SUBTYPE_MOV2,
+  LDA_SUBTYPE_SUB,
+  LDA_SUBTYPE_LDDPC,
+  LDA_SUBTYPE_LDW,
+  LDA_SUBTYPE_GOTLOAD,
+  LDA_SUBTYPE_GOTLOAD_LARGE,
+};
+
+enum {
+  CALL_SUBTYPE_RCALL1,
+  CALL_SUBTYPE_RCALL2,
+  CALL_SUBTYPE_MCALL_CP,
+  CALL_SUBTYPE_MCALL_GOT,
+  CALL_SUBTYPE_MCALL_LARGE,
+};
+
+#define LDA_INITIAL_SIZE	(avr32_pic ? 4 : 2)
+#define CALL_INITIAL_SIZE	2
+
+#define need_reloc(sym, seg, pcrel)					\
+  (!(S_IS_DEFINED(sym)							\
+     && ((pcrel && S_GET_SEGMENT(sym) == seg)				\
+	 || (!pcrel && S_GET_SEGMENT(sym) == absolute_section)))	\
+   || S_FORCE_RELOC(sym, 1))
+
+/* Return an initial guess of the length by which a fragment must grow to
+   hold a branch to reach its destination.
+   Also updates fr_type/fr_subtype as necessary.
+
+   Called just before doing relaxation.
+   Any symbol that is now undefined will not become defined.
+   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
+   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
+   Although it may not be explicit in the frag, pretend fr_var starts with a
+   0 value.  */
+
+static int
+avr32_default_estimate_size_before_relax (fragS *fragP, segT segment)
+{
+  int growth = 0;
+
+  assert(fragP);
+  assert(fragP->fr_symbol);
+
+  if (fragP->tc_frag_data.force_extended
+      || need_reloc(fragP->fr_symbol, segment, fragP->tc_frag_data.pcrel))
+    {
+      int largest_state = fragP->fr_subtype;
+      while (relax_more(largest_state) != AVR32_RS_NONE)
+	largest_state = relax_more(largest_state);
+      growth = avr32_rs_size(largest_state) - fragP->fr_var;
+    }
+  else
+    {
+      growth = avr32_rs_size(fragP->fr_subtype) - fragP->fr_var;
+    }
+
+  pr_debug("%s:%d: md_estimate_size_before_relax: %d\n",
+	   fragP->fr_file, fragP->fr_line, growth);
+
+  return growth;
+}
+
+static int
+avr32_lda_estimate_size_before_relax(fragS *fragP, segT segment ATTRIBUTE_UNUSED)
+{
+  return fragP->fr_var - LDA_INITIAL_SIZE;
+}
+
+static int
+avr32_call_estimate_size_before_relax(fragS *fragP, segT segment ATTRIBUTE_UNUSED)
+{
+  return fragP->fr_var - CALL_INITIAL_SIZE;
+}
+
+static int
+avr32_cpool_estimate_size_before_relax(fragS *fragP,
+				       segT segment ATTRIBUTE_UNUSED)
+{
+  return fragP->fr_var;
+}
+
+/* This macro may be defined to relax a frag. GAS will call this with the
+ * segment, the frag, and the change in size of all previous frags;
+ * md_relax_frag should return the change in size of the frag. */
+static long
+avr32_default_relax_frag (segT segment, fragS *fragP, long stretch)
+{
+  int state, next_state;
+  symbolS *symbolP;	/* The target symbol */
+  long growth = 0;
+
+  state = next_state = fragP->fr_subtype;
+
+  symbolP = fragP->fr_symbol;
+
+  if (fragP->tc_frag_data.force_extended
+      || need_reloc(symbolP, segment, fragP->tc_frag_data.pcrel))
+    {
+      /* Symbol must be resolved by the linker. Emit the largest
+	 possible opcode. */
+      while (relax_more(next_state) != AVR32_RS_NONE)
+	next_state = relax_more(next_state);
+    }
+  else
+    {
+      addressT address;	/* The address of fragP */
+      addressT target;	/* The address of the target symbol */
+      offsetT distance;	/* The distance between the insn and the symbol */
+      fragS *sym_frag;
+
+      address = fragP->fr_address;
+      target = fragP->fr_offset;
+      symbolP = fragP->fr_symbol;
+      sym_frag = symbol_get_frag(symbolP);
+
+      address += fragP->fr_fix - fragP->fr_var;
+      target += S_GET_VALUE(symbolP);
+
+      if (stretch != 0
+	  && sym_frag->relax_marker != fragP->relax_marker
+	  && S_GET_SEGMENT(symbolP) == segment)
+	/* if it was correctly aligned before, make sure it stays aligned */
+	target += stretch & (~0UL << avr32_rs_align(state));
+
+      if (fragP->tc_frag_data.pcrel)
+	distance = target - (address & (~0UL << avr32_rs_align(state)));
+      else
+	distance = target;
+
+      pr_debug("%s:%d: relax more? 0x%x - 0x%x = 0x%x (%d), align %d\n",
+	       fragP->fr_file, fragP->fr_line, target, address,
+	       distance, distance, avr32_rs_align(state));
+
+      if (need_relax(state, distance))
+	{
+	  if (relax_more(state) != AVR32_RS_NONE)
+	    next_state = relax_more(state);
+	  pr_debug("%s:%d: relax more %d -> %d (%d - %d, align %d)\n",
+		   fragP->fr_file, fragP->fr_line, state, next_state,
+		   target, address, avr32_rs_align(state));
+	}
+    }
+
+  growth = avr32_rs_size(next_state) - avr32_rs_size(state);
+  fragP->fr_subtype = next_state;
+
+  pr_debug("%s:%d: md_relax_frag: growth=%d, subtype=%d, opc=0x%08lx\n",
+	   fragP->fr_file, fragP->fr_line, growth, fragP->fr_subtype,
+	   avr32_opc_table[next_state].value);
+
+  return growth;
+}
+
+static long
+avr32_lda_relax_frag(segT segment, fragS *fragP, long stretch)
+{
+  struct cpool *pool= NULL;
+  unsigned int entry = 0;
+  addressT address, target;
+  offsetT distance;
+  symbolS *symbolP;
+  fragS *sym_frag;
+  long old_size, new_size;
+
+  symbolP = fragP->fr_symbol;
+  old_size = fragP->fr_var;
+  if (!avr32_pic)
+    {
+      pool = fragP->tc_frag_data.pool;
+      entry = fragP->tc_frag_data.pool_entry;
+    }
+
+  address = fragP->fr_address;
+  address += fragP->fr_fix - LDA_INITIAL_SIZE;
+
+  if (!S_IS_DEFINED(symbolP) || S_FORCE_RELOC(symbolP, 1))
+    goto relax_max;
+
+  target = fragP->fr_offset;
+  sym_frag = symbol_get_frag(symbolP);
+  target += S_GET_VALUE(symbolP);
+
+  if (sym_frag->relax_marker != fragP->relax_marker
+      && S_GET_SEGMENT(symbolP) == segment)
+    target += stretch;
+
+  distance = target - address;
+
+  pr_debug("lda_relax_frag: target: %d, address: %d, var: %d\n",
+	   target, address, fragP->fr_var);
+
+  if (!avr32_pic && S_GET_SEGMENT(symbolP) == absolute_section
+      && target <= 127 && (offsetT)target >= -128)
+    {
+      if (fragP->fr_subtype == LDA_SUBTYPE_LDDPC
+	  || fragP->fr_subtype == LDA_SUBTYPE_LDW)
+	pool->literals[entry].refcount--;
+      new_size = 2;
+      fragP->fr_subtype = LDA_SUBTYPE_MOV1;
+    }
+  else if (!avr32_pic && S_GET_SEGMENT(symbolP) == absolute_section
+	   && target <= 1048575 && (offsetT)target >= -1048576)
+    {
+      if (fragP->fr_subtype == LDA_SUBTYPE_LDDPC
+	  || fragP->fr_subtype == LDA_SUBTYPE_LDW)
+	pool->literals[entry].refcount--;
+      new_size = 4;
+      fragP->fr_subtype = LDA_SUBTYPE_MOV2;
+    }
+  else if (!linkrelax && S_GET_SEGMENT(symbolP) == segment
+	   /* the field will be negated, so this is really -(-32768)
+	      and -(32767) */
+	   && distance <= 32768 && distance >= -32767)
+    {
+      if (!avr32_pic
+	  && (fragP->fr_subtype == LDA_SUBTYPE_LDDPC
+	      || fragP->fr_subtype == LDA_SUBTYPE_LDW))
+	pool->literals[entry].refcount--;
+      new_size = 4;
+      fragP->fr_subtype = LDA_SUBTYPE_SUB;
+    }
+  else
+    {
+    relax_max:
+      if (avr32_pic)
+	{
+	  if (linkrelax)
+	    {
+	      new_size = 8;
+	      fragP->fr_subtype = LDA_SUBTYPE_GOTLOAD_LARGE;
+	    }
+	  else
+	    {
+	      new_size = 4;
+	      fragP->fr_subtype = LDA_SUBTYPE_GOTLOAD;
+	    }
+	}
+      else
+	{
+	  if (fragP->fr_subtype != LDA_SUBTYPE_LDDPC
+	      && fragP->fr_subtype != LDA_SUBTYPE_LDW)
+	    pool->literals[entry].refcount++;
+
+	  sym_frag = symbol_get_frag(pool->symbol);
+	  target = (sym_frag->fr_address + sym_frag->fr_fix
+		    + pool->padding + pool->literals[entry].offset);
+
+	  pr_debug("cpool sym address: 0x%lx\n",
+		   sym_frag->fr_address + sym_frag->fr_fix);
+
+	  know(pool->section == segment);
+
+	  if (sym_frag->relax_marker != fragP->relax_marker)
+	    target += stretch;
+
+	  distance = target - address;
+	  if (distance <= 508 && distance >= 0)
+	    {
+	      new_size = 2;
+	      fragP->fr_subtype = LDA_SUBTYPE_LDDPC;
+	    }
+	  else
+	    {
+	      new_size = 4;
+	      fragP->fr_subtype = LDA_SUBTYPE_LDW;
+	    }
+
+	  pr_debug("lda_relax_frag (cpool): target=0x%lx, address=0x%lx, refcount=%d\n",
+		   target, address, pool->literals[entry].refcount);
+	}
+    }
+
+  fragP->fr_var = new_size;
+
+  pr_debug("%s:%d: lda: relax pass done. subtype: %d, growth: %ld\n",
+	   fragP->fr_file, fragP->fr_line,
+	   fragP->fr_subtype, new_size - old_size);
+
+  return new_size - old_size;
+}
+
+static long
+avr32_call_relax_frag(segT segment, fragS *fragP, long stretch)
+{
+  struct cpool *pool = NULL;
+  unsigned int entry = 0;
+  addressT address, target;
+  offsetT distance;
+  symbolS *symbolP;
+  fragS *sym_frag;
+  long old_size, new_size;
+
+  symbolP = fragP->fr_symbol;
+  old_size = fragP->fr_var;
+  if (!avr32_pic)
+    {
+      pool = fragP->tc_frag_data.pool;
+      entry = fragP->tc_frag_data.pool_entry;
+    }
+
+  address = fragP->fr_address;
+  address += fragP->fr_fix - CALL_INITIAL_SIZE;
+
+  if (need_reloc(symbolP, segment, 1))
+    {
+      pr_debug("call: must emit reloc\n");
+      goto relax_max;
+    }
+
+  target = fragP->fr_offset;
+  sym_frag = symbol_get_frag(symbolP);
+  target += S_GET_VALUE(symbolP);
+
+  if (sym_frag->relax_marker != fragP->relax_marker
+      && S_GET_SEGMENT(symbolP) == segment)
+    target += stretch;
+
+  distance = target - address;
+
+  if (distance <= 1022 && distance >= -1024)
+    {
+      pr_debug("call: distance is %d, emitting short rcall\n", distance);
+      if (!avr32_pic && fragP->fr_subtype == CALL_SUBTYPE_MCALL_CP)
+	pool->literals[entry].refcount--;
+      new_size = 2;
+      fragP->fr_subtype = CALL_SUBTYPE_RCALL1;
+    }
+  else if (distance <= 2097150 && distance >= -2097152)
+    {
+      pr_debug("call: distance is %d, emitting long rcall\n", distance);
+      if (!avr32_pic && fragP->fr_subtype == CALL_SUBTYPE_MCALL_CP)
+	pool->literals[entry].refcount--;
+      new_size = 4;
+      fragP->fr_subtype = CALL_SUBTYPE_RCALL2;
+    }
+  else
+    {
+      pr_debug("call: distance %d too far, emitting something big\n", distance);
+
+    relax_max:
+      if (avr32_pic)
+	{
+	  if (linkrelax)
+	    {
+	      new_size = 10;
+	      fragP->fr_subtype = CALL_SUBTYPE_MCALL_LARGE;
+	    }
+	  else
+	    {
+	      new_size = 4;
+	      fragP->fr_subtype = CALL_SUBTYPE_MCALL_GOT;
+	    }
+	}
+      else
+	{
+	  if (fragP->fr_subtype != CALL_SUBTYPE_MCALL_CP)
+	    pool->literals[entry].refcount++;
+
+	  new_size = 4;
+	  fragP->fr_subtype = CALL_SUBTYPE_MCALL_CP;
+	}
+    }
+
+  fragP->fr_var = new_size;
+
+  pr_debug("%s:%d: call: relax pass done, growth: %d, fr_var: %d\n",
+	   fragP->fr_file, fragP->fr_line,
+	   new_size - old_size, fragP->fr_var);
+
+  return new_size - old_size;
+}
+
+static long
+avr32_cpool_relax_frag(segT segment ATTRIBUTE_UNUSED,
+		       fragS *fragP,
+		       long stretch ATTRIBUTE_UNUSED)
+{
+  struct cpool *pool;
+  addressT address;
+  long old_size, new_size;
+  unsigned int entry;
+
+  pool = fragP->tc_frag_data.pool;
+  address = fragP->fr_address + fragP->fr_fix;
+  old_size = fragP->fr_var;
+  new_size = 0;
+
+  for (entry = 0; entry < pool->next_free_entry; entry++)
+    {
+      if (pool->literals[entry].refcount > 0)
+	{
+	  pool->literals[entry].offset = new_size;
+	  new_size += 4;
+	}
+    }
+
+  fragP->fr_var = new_size;
+
+  return new_size - old_size;
+}
+
+/* *fragP has been relaxed to its final size, and now needs to have
+   the bytes inside it modified to conform to the new size.
+
+   Called after relaxation is finished.
+   fragP->fr_type == rs_machine_dependent.
+   fragP->fr_subtype is the subtype of what the address relaxed to.  */
+
+static void
+avr32_default_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
+			    segT segment ATTRIBUTE_UNUSED,
+			    fragS *fragP)
+{
+  const struct avr32_opcode *opc;
+  const struct avr32_ifield *ifield;
+  bfd_reloc_code_real_type r_type;
+  symbolS *symbolP;
+  fixS *fixP;
+  bfd_vma value;
+  int subtype;
+
+  opc = &avr32_opc_table[fragP->fr_subtype];
+  ifield = opc->fields[opc->var_field];
+  symbolP = fragP->fr_symbol;
+  subtype = fragP->fr_subtype;
+  r_type = opc->reloc_type;
+
+  /* Clear the opcode bits and the bits belonging to the relaxed
+     field.  We assume all other fields stay the same.  */
+  value = bfd_getb32(fragP->fr_opcode);
+  value &= ~(opc->mask | ifield->mask);
+
+  /* Insert the new opcode */
+  value |= opc->value;
+  bfd_putb32(value, fragP->fr_opcode);
+
+  fragP->fr_fix += opc->size - fragP->fr_var;
+
+  if (fragP->tc_frag_data.reloc_info != AVR32_OPINFO_NONE)
+    {
+      switch (fragP->tc_frag_data.reloc_info)
+	{
+	case AVR32_OPINFO_HI:
+	  r_type = BFD_RELOC_HI16;
+	  break;
+	case AVR32_OPINFO_LO:
+	  r_type = BFD_RELOC_LO16;
+	  break;
+	case AVR32_OPINFO_GOT:
+	  switch (r_type)
+	    {
+	    case BFD_RELOC_AVR32_18W_PCREL:
+	      r_type = BFD_RELOC_AVR32_GOT18SW;
+	      break;
+	    case BFD_RELOC_AVR32_16S:
+	      r_type = BFD_RELOC_AVR32_GOT16S;
+	      break;
+	    default:
+	      BAD_CASE(r_type);
+	      break;
+	    }
+	  break;
+	default:
+	  BAD_CASE(fragP->tc_frag_data.reloc_info);
+	  break;
+	}
+    }
+
+  pr_debug("%s:%d: convert_frag: new %s fixup\n",
+	   fragP->fr_file, fragP->fr_line,
+	   bfd_get_reloc_code_name(r_type));
+
+#if 1
+  fixP = fix_new_exp(fragP, fragP->fr_fix - opc->size, opc->size,
+		     &fragP->tc_frag_data.exp,
+		     fragP->tc_frag_data.pcrel, r_type);
+#else
+  fixP = fix_new(fragP, fragP->fr_fix - opc->size, opc->size, symbolP,
+		 fragP->fr_offset, fragP->tc_frag_data.pcrel, r_type);
+#endif
+
+  /* Revert fix_new brain damage. "dot_value" is the value of PC at
+     the point of the fixup, relative to the frag address.  fix_new()
+     and friends think they are only being called during the assembly
+     pass, not during relaxation or similar, so fx_dot_value, fx_file
+     and fx_line are all initialized to the wrong value.  But we don't
+     know the size of the fixup until now, so we really can't live up
+     to the assumptions these functions make about the target.  What
+     do these functions think the "where" and "frag" argument mean
+     anyway?  */
+  fixP->fx_dot_value = fragP->fr_fix - opc->size;
+  fixP->fx_file = fragP->fr_file;
+  fixP->fx_line = fragP->fr_line;
+
+  fixP->tc_fix_data.ifield = ifield;
+  fixP->tc_fix_data.align = avr32_rs_align(subtype);
+  fixP->tc_fix_data.min = avr32_relax_table[subtype].lower_bound;
+  fixP->tc_fix_data.max = avr32_relax_table[subtype].upper_bound;
+}
+
+static void
+avr32_lda_convert_frag(bfd *abfd ATTRIBUTE_UNUSED,
+		       segT segment ATTRIBUTE_UNUSED,
+		       fragS *fragP)
+{
+  const struct avr32_opcode *opc;
+  const struct avr32_ifield *ifield;
+  bfd_reloc_code_real_type r_type;
+  expressionS exp;
+  struct cpool *pool;
+  fixS *fixP;
+  bfd_vma value;
+  int regid, pcrel = 0, align = 0;
+  char *p;
+
+  r_type = BFD_RELOC_NONE;
+  regid = fragP->tc_frag_data.reloc_info;
+  p = fragP->fr_opcode;
+  exp.X_add_symbol = fragP->fr_symbol;
+  exp.X_add_number = fragP->fr_offset;
+  exp.X_op = O_symbol;
+
+  pr_debug("%s:%d: lda_convert_frag, subtype: %d, fix: %d, var: %d, regid: %d\n",
+	   fragP->fr_file, fragP->fr_line,
+	   fragP->fr_subtype, fragP->fr_fix, fragP->fr_var, regid);
+
+  switch (fragP->fr_subtype)
+    {
+    case LDA_SUBTYPE_MOV1:
+      opc = &avr32_opc_table[AVR32_OPC_MOV1];
+      opc->fields[0]->insert(opc->fields[0], p, regid);
+      ifield = opc->fields[1];
+      r_type = opc->reloc_type;
+      break;
+    case LDA_SUBTYPE_MOV2:
+      opc = &avr32_opc_table[AVR32_OPC_MOV2];
+      opc->fields[0]->insert(opc->fields[0], p, regid);
+      ifield = opc->fields[1];
+      r_type = opc->reloc_type;
+      break;
+    case LDA_SUBTYPE_SUB:
+      opc = &avr32_opc_table[AVR32_OPC_SUB5];
+      opc->fields[0]->insert(opc->fields[0], p, regid);
+      opc->fields[1]->insert(opc->fields[1], p, AVR32_REG_PC);
+      ifield = opc->fields[2];
+      r_type = BFD_RELOC_AVR32_16N_PCREL;
+
+      /* Pretend that SUB5 isn't a "negated" pcrel expression for now.
+	 We'll have to fix it up later when we know whether to
+	 generate a reloc for it (in which case the linker will negate
+	 it, so we shouldn't). */
+      pcrel = 1;
+      break;
+    case LDA_SUBTYPE_LDDPC:
+      opc = &avr32_opc_table[AVR32_OPC_LDDPC];
+      align = 2;
+      r_type = BFD_RELOC_AVR32_9W_CP;
+      goto cpool_common;
+    case LDA_SUBTYPE_LDW:
+      opc = &avr32_opc_table[AVR32_OPC_LDDPC_EXT];
+      r_type = BFD_RELOC_AVR32_16_CP;
+    cpool_common:
+      opc->fields[0]->insert(opc->fields[0], p, regid);
+      ifield = opc->fields[1];
+      pool = fragP->tc_frag_data.pool;
+      exp.X_add_symbol = pool->symbol;
+      exp.X_add_number = pool->literals[fragP->tc_frag_data.pool_entry].offset;
+      pcrel = 1;
+      break;
+    case LDA_SUBTYPE_GOTLOAD_LARGE:
+      /* ld.w Rd, r6[Rd << 2] (last) */
+      opc = &avr32_opc_table[AVR32_OPC_LD_W5];
+      bfd_putb32(opc->value, p + 4);
+      opc->fields[0]->insert(opc->fields[0], p + 4, regid);
+      opc->fields[1]->insert(opc->fields[1], p + 4, 6);
+      opc->fields[2]->insert(opc->fields[2], p + 4, regid);
+      opc->fields[3]->insert(opc->fields[3], p + 4, 2);
+
+      /* mov Rd, (got_offset / 4) */
+      opc = &avr32_opc_table[AVR32_OPC_MOV2];
+      opc->fields[0]->insert(opc->fields[0], p, regid);
+      ifield = opc->fields[1];
+      r_type = BFD_RELOC_AVR32_LDA_GOT;
+      break;
+    case LDA_SUBTYPE_GOTLOAD:
+      opc = &avr32_opc_table[AVR32_OPC_LD_W4];
+      opc->fields[0]->insert(opc->fields[0], p, regid);
+      opc->fields[1]->insert(opc->fields[1], p, 6);
+      ifield = opc->fields[2];
+      if (r_type == BFD_RELOC_NONE)
+	r_type = BFD_RELOC_AVR32_GOT16S;
+      break;
+    default:
+      BAD_CASE(fragP->fr_subtype);
+    }
+
+  value = bfd_getb32(p);
+  value &= ~(opc->mask | ifield->mask);
+  value |= opc->value;
+  bfd_putb32(value, p);
+
+  fragP->fr_fix += fragP->fr_var - LDA_INITIAL_SIZE;
+
+  if (fragP->fr_next
+      && ((offsetT)(fragP->fr_next->fr_address - fragP->fr_address)
+	  != fragP->fr_fix))
+    {
+      fprintf(stderr, "LDA frag: fr_fix is wrong! fragP->fr_var = %ld, r_type = %s\n",
+	      fragP->fr_var, bfd_get_reloc_code_name(r_type));
+      abort();
+    }
+
+  fixP = fix_new_exp(fragP, fragP->fr_fix - fragP->fr_var, fragP->fr_var,
+		     &exp, pcrel, r_type);
+
+  /* Revert fix_new brain damage. "dot_value" is the value of PC at
+     the point of the fixup, relative to the frag address.  fix_new()
+     and friends think they are only being called during the assembly
+     pass, not during relaxation or similar, so fx_dot_value, fx_file
+     and fx_line are all initialized to the wrong value.  But we don't
+     know the size of the fixup until now, so we really can't live up
+     to the assumptions these functions make about the target.  What
+     do these functions think the "where" and "frag" argument mean
+     anyway?  */
+  fixP->fx_dot_value = fragP->fr_fix - opc->size;
+  fixP->fx_file = fragP->fr_file;
+  fixP->fx_line = fragP->fr_line;
+
+  fixP->tc_fix_data.ifield = ifield;
+  fixP->tc_fix_data.align = align;
+  /* these are only used if the fixup can actually be resolved */
+  fixP->tc_fix_data.min = -32768;
+  fixP->tc_fix_data.max = 32767;
+}
+
+static void
+avr32_call_convert_frag(bfd *abfd ATTRIBUTE_UNUSED,
+		       segT segment ATTRIBUTE_UNUSED,
+		       fragS *fragP)
+{
+  const struct avr32_opcode *opc = NULL;
+  const struct avr32_ifield *ifield;
+  bfd_reloc_code_real_type r_type;
+  symbolS *symbol;
+  offsetT offset;
+  fixS *fixP;
+  bfd_vma value;
+  int pcrel = 0, align = 0;
+  char *p;
+
+  symbol = fragP->fr_symbol;
+  offset = fragP->fr_offset;
+  r_type = BFD_RELOC_NONE;
+  p = fragP->fr_opcode;
+
+  pr_debug("%s:%d: call_convert_frag, subtype: %d, fix: %d, var: %d\n",
+	   fragP->fr_file, fragP->fr_line,
+	   fragP->fr_subtype, fragP->fr_fix, fragP->fr_var);
+
+  switch (fragP->fr_subtype)
+    {
+    case CALL_SUBTYPE_RCALL1:
+      opc = &avr32_opc_table[AVR32_OPC_RCALL1];
+      /* fall through */
+    case CALL_SUBTYPE_RCALL2:
+      if (!opc)
+	opc = &avr32_opc_table[AVR32_OPC_RCALL2];
+      ifield = opc->fields[0];
+      r_type = opc->reloc_type;
+      pcrel = 1;
+      align = 1;
+      break;
+    case CALL_SUBTYPE_MCALL_CP:
+      opc = &avr32_opc_table[AVR32_OPC_MCALL];
+      opc->fields[0]->insert(opc->fields[0], p, AVR32_REG_PC);
+      ifield = opc->fields[1];
+      r_type = BFD_RELOC_AVR32_CPCALL;
+      symbol = fragP->tc_frag_data.pool->symbol;
+      offset = fragP->tc_frag_data.pool->literals[fragP->tc_frag_data.pool_entry].offset;
+      assert(fragP->tc_frag_data.pool->literals[fragP->tc_frag_data.pool_entry].refcount > 0);
+      pcrel = 1;
+      align = 2;
+      break;
+    case CALL_SUBTYPE_MCALL_GOT:
+      opc = &avr32_opc_table[AVR32_OPC_MCALL];
+      opc->fields[0]->insert(opc->fields[0], p, 6);
+      ifield = opc->fields[1];
+      r_type = BFD_RELOC_AVR32_GOT18SW;
+      break;
+    case CALL_SUBTYPE_MCALL_LARGE:
+      assert(fragP->fr_var == 10);
+      /* ld.w lr, r6[lr << 2] */
+      opc = &avr32_opc_table[AVR32_OPC_LD_W5];
+      bfd_putb32(opc->value, p + 4);
+      opc->fields[0]->insert(opc->fields[0], p + 4, AVR32_REG_LR);
+      opc->fields[1]->insert(opc->fields[1], p + 4, 6);
+      opc->fields[2]->insert(opc->fields[2], p + 4, AVR32_REG_LR);
+      opc->fields[3]->insert(opc->fields[3], p + 4, 2);
+
+      /* icall lr */
+      opc = &avr32_opc_table[AVR32_OPC_ICALL];
+      bfd_putb16(opc->value >> 16, p + 8);
+      opc->fields[0]->insert(opc->fields[0], p + 8, AVR32_REG_LR);
+
+      /* mov lr, (got_offset / 4) */
+      opc = &avr32_opc_table[AVR32_OPC_MOV2];
+      opc->fields[0]->insert(opc->fields[0], p, AVR32_REG_LR);
+      ifield = opc->fields[1];
+      r_type = BFD_RELOC_AVR32_GOTCALL;
+      break;
+    default:
+      BAD_CASE(fragP->fr_subtype);
+    }
+
+  /* Insert the opcode and clear the variable ifield */
+  value = bfd_getb32(p);
+  value &= ~(opc->mask | ifield->mask);
+  value |= opc->value;
+  bfd_putb32(value, p);
+
+  fragP->fr_fix += fragP->fr_var - CALL_INITIAL_SIZE;
+
+  if (fragP->fr_next
+      && ((offsetT)(fragP->fr_next->fr_address - fragP->fr_address)
+	  != fragP->fr_fix))
+    {
+      fprintf(stderr, "%s:%d: fr_fix %lu is wrong! fr_var=%lu, r_type=%s\n",
+	      fragP->fr_file, fragP->fr_line,
+	      fragP->fr_fix, fragP->fr_var, bfd_get_reloc_code_name(r_type));
+      fprintf(stderr, "fr_fix should be %ld. next frag is %s:%d\n",
+	      (offsetT)(fragP->fr_next->fr_address - fragP->fr_address),
+	      fragP->fr_next->fr_file, fragP->fr_next->fr_line);
+    }
+
+  fixP = fix_new(fragP, fragP->fr_fix - fragP->fr_var, fragP->fr_var,
+		 symbol, offset, pcrel, r_type);
+
+  /* Revert fix_new brain damage. "dot_value" is the value of PC at
+     the point of the fixup, relative to the frag address.  fix_new()
+     and friends think they are only being called during the assembly
+     pass, not during relaxation or similar, so fx_dot_value, fx_file
+     and fx_line are all initialized to the wrong value.  But we don't
+     know the size of the fixup until now, so we really can't live up
+     to the assumptions these functions make about the target.  What
+     do these functions think the "where" and "frag" argument mean
+     anyway?  */
+  fixP->fx_dot_value = fragP->fr_fix - opc->size;
+  fixP->fx_file = fragP->fr_file;
+  fixP->fx_line = fragP->fr_line;
+
+  fixP->tc_fix_data.ifield = ifield;
+  fixP->tc_fix_data.align = align;
+  /* these are only used if the fixup can actually be resolved */
+  fixP->tc_fix_data.min = -2097152;
+  fixP->tc_fix_data.max = 2097150;
+}
+
+static void
+avr32_cpool_convert_frag(bfd *abfd ATTRIBUTE_UNUSED,
+			 segT segment ATTRIBUTE_UNUSED,
+			 fragS *fragP)
+{
+  struct cpool *pool;
+  addressT address;
+  unsigned int entry;
+  char *p;
+  char sym_name[20];
+
+  /* Did we get rid of the frag altogether? */
+  if (!fragP->fr_var)
+    return;
+
+  pool = fragP->tc_frag_data.pool;
+  address = fragP->fr_address + fragP->fr_fix;
+  p = fragP->fr_literal + fragP->fr_fix;
+
+  sprintf(sym_name, "$$cp_\002%x", pool->id);
+  symbol_locate(pool->symbol, sym_name, pool->section, fragP->fr_fix, fragP);
+  symbol_table_insert(pool->symbol);
+
+  for (entry = 0; entry < pool->next_free_entry; entry++)
+    {
+      if (pool->literals[entry].refcount > 0)
+	{
+	  fix_new_exp(fragP, fragP->fr_fix, 4, &pool->literals[entry].exp,
+		      FALSE, BFD_RELOC_AVR32_32_CPENT);
+	  fragP->fr_fix += 4;
+	}
+    }
+}
+
+static struct avr32_relaxer avr32_default_relaxer = {
+  .estimate_size	= avr32_default_estimate_size_before_relax,
+  .relax_frag		= avr32_default_relax_frag,
+  .convert_frag		= avr32_default_convert_frag,
+};
+static struct avr32_relaxer avr32_lda_relaxer = {
+  .estimate_size	= avr32_lda_estimate_size_before_relax,
+  .relax_frag		= avr32_lda_relax_frag,
+  .convert_frag		= avr32_lda_convert_frag,
+};
+static struct avr32_relaxer avr32_call_relaxer = {
+  .estimate_size	= avr32_call_estimate_size_before_relax,
+  .relax_frag		= avr32_call_relax_frag,
+  .convert_frag		= avr32_call_convert_frag,
+};
+static struct avr32_relaxer avr32_cpool_relaxer = {
+  .estimate_size	= avr32_cpool_estimate_size_before_relax,
+  .relax_frag		= avr32_cpool_relax_frag,
+  .convert_frag		= avr32_cpool_convert_frag,
+};
+
+static void s_cpool(int arg ATTRIBUTE_UNUSED)
+{
+  struct cpool *pool;
+  unsigned int max_size;
+  char *buf;
+
+  pool = find_cpool(now_seg, now_subseg);
+  if (!pool || !pool->symbol || pool->next_free_entry == 0)
+    return;
+
+  /* Make sure the constant pool is properly aligned */
+  frag_align_code(2, 0);
+  if (bfd_get_section_alignment(stdoutput, pool->section) < 2)
+    bfd_set_section_alignment(stdoutput, pool->section, 2);
+
+  /* Assume none of the entries are discarded, and that we need the
+     maximum amount of alignment.  But we're not going to allocate
+     anything up front. */
+  max_size = pool->next_free_entry * 4 + 2;
+  frag_grow(max_size);
+  buf = frag_more(0);
+
+  frag_now->tc_frag_data.relaxer = &avr32_cpool_relaxer;
+  frag_now->tc_frag_data.pool = pool;
+
+  symbol_set_frag(pool->symbol, frag_now);
+
+  /* Assume zero initial size, allowing other relaxers to be
+     optimistic about things.  */
+  frag_var(rs_machine_dependent, max_size, 0,
+	   0, pool->symbol, 0, NULL);
+
+  /* Mark the pool as empty.  */
+  pool->used = 1;
+}
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+
+long
+md_pcrel_from_section (fixS *fixP, segT sec)
+{
+  pr_debug("pcrel_from_section, fx_offset = %d\n", fixP->fx_offset);
+
+  if (fixP->fx_addsy != NULL
+      && (! S_IS_DEFINED (fixP->fx_addsy)
+          || S_GET_SEGMENT (fixP->fx_addsy) != sec
+	  || S_FORCE_RELOC(fixP->fx_addsy, 1)))
+    {
+      pr_debug("Unknown pcrel symbol: %s\n", S_GET_NAME(fixP->fx_addsy));
+
+      /* The symbol is undefined (or is defined but not in this section).
+	 Let the linker figure it out.  */
+      return 0;
+    }
+
+  pr_debug("pcrel from %x + %x, symbol: %s (%x)\n",
+	   fixP->fx_frag->fr_address, fixP->fx_where,
+	   fixP->fx_addsy?S_GET_NAME(fixP->fx_addsy):"(null)",
+	   fixP->fx_addsy?S_GET_VALUE(fixP->fx_addsy):0);
+
+  return ((fixP->fx_frag->fr_address + fixP->fx_where)
+	  & (~0UL << fixP->tc_fix_data.align));
+}
+
+valueT
+md_section_align (segT segment, valueT size)
+{
+  int align = bfd_get_section_alignment (stdoutput, segment);
+  return ((size + (1 << align) - 1) & (-1 << align));
+}
+
+static int syntax_matches(const struct avr32_syntax *syntax,
+			  char *str)
+{
+  int i;
+
+  pr_debug("syntax %d matches `%s'?\n", syntax->id, str);
+
+  if (syntax->nr_operands < 0)
+    {
+      struct avr32_operand *op;
+      int optype;
+
+      for (i = 0; i < (-syntax->nr_operands - 1); i++)
+	{
+	  char *p;
+	  char c;
+
+	  optype = syntax->operand[i];
+	  assert(optype < AVR32_NR_OPERANDS);
+	  op = &avr32_operand_table[optype];
+
+	  for (p = str; *p; p++)
+	    if (*p == ',')
+	      break;
+
+	  if (p == str)
+	    return 0;
+
+	  c = *p;
+	  *p = 0;
+
+	  if (!op->match(str))
+	    {
+	      *p = c;
+	      return 0;
+	    }
+
+	  str = p;
+	  *p = c;
+	  if (c)
+	    str++;
+	}
+
+      optype = syntax->operand[i];
+      assert(optype < AVR32_NR_OPERANDS);
+      op = &avr32_operand_table[optype];
+
+      if (!op->match(str))
+	return 0;
+      return 1;
+    }
+
+  for (i = 0; i < syntax->nr_operands; i++)
+    {
+      struct avr32_operand *op;
+      int optype = syntax->operand[i];
+      char *p;
+      char c;
+
+      assert(optype < AVR32_NR_OPERANDS);
+      op = &avr32_operand_table[optype];
+
+      for (p = str; *p; p++)
+	if (*p == ',')
+	  break;
+
+      if (p == str)
+	return 0;
+
+      c = *p;
+      *p = 0;
+
+      if (!op->match(str))
+	{
+	  *p = c;
+	  return 0;
+	}
+
+      str = p;
+      *p = c;
+      if (c)
+	str++;
+    }
+
+  if (*str == '\0')
+    return 1;
+
+  if ((*str == 'e' || *str == 'E') && !str[1])
+    return 1;
+
+  return 0;
+}
+
+static int parse_operands(char *str)
+{
+  int i;
+
+  if (current_insn.syntax->nr_operands < 0)
+    {
+      int optype;
+      struct avr32_operand *op;
+
+      for (i = 0; i < (-current_insn.syntax->nr_operands - 1); i++)
+	{
+	  char *p;
+	  char c;
+
+	  optype = current_insn.syntax->operand[i];
+	  op = &avr32_operand_table[optype];
+
+	  for (p = str; *p; p++)
+	    if (*p == ',')
+	      break;
+
+	  assert(p != str);
+
+	  c = *p, *p = 0;
+	  op->parse(op, str, i);
+	  *p = c;
+
+	  str = p;
+	  if (c) str++;
+	}
+
+      /* give the rest of the line to the last operand */
+      optype = current_insn.syntax->operand[i];
+      op = &avr32_operand_table[optype];
+      op->parse(op, str, i);
+    }
+  else
+    {
+      for (i = 0; i < current_insn.syntax->nr_operands; i++)
+	{
+	  int optype = current_insn.syntax->operand[i];
+	  struct avr32_operand *op = &avr32_operand_table[optype];
+	  char *p;
+	  char c;
+
+	  skip_whitespace(str);
+
+	  for (p = str; *p; p++)
+	    if (*p == ',')
+	      break;
+
+	  assert(p != str);
+
+	  c = *p, *p = 0;
+	  op->parse(op, str, i);
+	  *p = c;
+
+	  str = p;
+	  if (c) str++;
+	}
+
+      if (*str == 'E' || *str == 'e')
+	current_insn.force_extended = 1;
+    }
+
+  return 0;
+}
+
+static const char *
+finish_insn(const struct avr32_opcode *opc)
+{
+  expressionS *exp = &current_insn.immediate;
+  unsigned int i;
+  int will_relax = 0;
+  char *buf;
+
+  assert(current_insn.next_slot == opc->nr_fields);
+
+  pr_debug("%s:%d: finish_insn: trying opcode %d\n",
+	   frag_now->fr_file, frag_now->fr_line, opc->id);
+
+  /* Go through the relaxation stage for all instructions that can
+     possibly take a symbolic immediate.  The relax code will take
+     care of range checking and alignment.  */
+  if (opc->var_field != -1)
+    {
+      int substate, largest_substate;
+      symbolS *sym;
+      offsetT off;
+
+      will_relax = 1;
+      substate = largest_substate = opc_initial_substate(opc);
+
+      while (relax_more(largest_substate) != AVR32_RS_NONE)
+	largest_substate = relax_more(largest_substate);
+
+      pr_debug("will relax. initial substate: %d (size %d), largest substate: %d (size %d)\n",
+	       substate, avr32_rs_size(substate),
+	       largest_substate, avr32_rs_size(largest_substate));
+
+      /* make sure we have enough room for the largest possible opcode */
+      frag_grow(avr32_rs_size(largest_substate));
+      buf = frag_more(opc->size);
+
+      dwarf2_emit_insn(opc->size);
+
+      frag_now->tc_frag_data.reloc_info = AVR32_OPINFO_NONE;
+      frag_now->tc_frag_data.pcrel = current_insn.pcrel;
+      frag_now->tc_frag_data.force_extended = current_insn.force_extended;
+      frag_now->tc_frag_data.relaxer = &avr32_default_relaxer;
+
+      if (exp->X_op == O_hi)
+	{
+	  frag_now->tc_frag_data.reloc_info = AVR32_OPINFO_HI;
+	  exp->X_op = exp->X_md;
+	}
+      else if (exp->X_op == O_lo)
+	{
+	  frag_now->tc_frag_data.reloc_info = AVR32_OPINFO_LO;
+	  exp->X_op = exp->X_md;
+	}
+      else if (exp->X_op == O_got)
+	{
+	  frag_now->tc_frag_data.reloc_info = AVR32_OPINFO_GOT;
+	  exp->X_op = O_symbol;
+	}
+
+#if 0
+      if ((opc->reloc_type == BFD_RELOC_AVR32_SUB5)
+	  && exp->X_op == O_subtract)
+	{
+	  symbolS *tmp;
+	  tmp = exp->X_add_symbol;
+	  exp->X_add_symbol = exp->X_op_symbol;
+	  exp->X_op_symbol = tmp;
+	}
+#endif
+
+      frag_now->tc_frag_data.exp = current_insn.immediate;
+
+      sym = exp->X_add_symbol;
+      off = exp->X_add_number;
+      if (exp->X_op != O_symbol)
+	{
+	  sym = make_expr_symbol(exp);
+	  off = 0;
+	}
+
+      frag_var(rs_machine_dependent,
+	       avr32_rs_size(largest_substate) - opc->size,
+	       opc->size,
+	       substate, sym, off, buf);
+    }
+  else
+    {
+      assert(avr32_rs_size(opc_initial_substate(opc)) == 0);
+
+      /* Make sure we always have room for another whole word, as the ifield
+	 inserters can only write words. */
+      frag_grow(4);
+      buf = frag_more(opc->size);
+      dwarf2_emit_insn(opc->size);
+    }
+
+  assert(!(opc->value & ~opc->mask));
+
+  pr_debug("inserting opcode: 0x%lx\n", opc->value);
+  bfd_putb32(opc->value, buf);
+
+  for (i = 0; i < opc->nr_fields; i++)
+    {
+      const struct avr32_ifield *f = opc->fields[i];
+      const struct avr32_ifield_data *fd = &current_insn.field_value[i];
+
+      pr_debug("inserting field: 0x%lx & 0x%lx\n",
+	       fd->value >> fd->align_order, f->mask);
+
+      f->insert(f, buf, fd->value >> fd->align_order);
+    }
+
+  assert(will_relax || !current_insn.immediate.X_add_symbol);
+  return NULL;
+}
+
+static const char *
+finish_alias(const struct avr32_alias *alias)
+{
+  const struct avr32_opcode *opc;
+  struct {
+    unsigned long value;
+    unsigned long align;
+  } mapped_operand[AVR32_MAX_OPERANDS];
+  unsigned int i;
+
+  opc = alias->opc;
+
+  /* Remap the operands from the alias to the real opcode */
+  for (i = 0; i < opc->nr_fields; i++)
+    {
+      if (alias->operand_map[i].is_opindex)
+	{
+	  struct avr32_ifield_data *fd;
+	  fd = &current_insn.field_value[alias->operand_map[i].value];
+	  mapped_operand[i].value = fd->value;
+	  mapped_operand[i].align = fd->align_order;
+	}
+      else
+	{
+	  mapped_operand[i].value = alias->operand_map[i].value;
+	  mapped_operand[i].align = 0;
+	}
+    }
+
+  for (i = 0; i < opc->nr_fields; i++)
+    {
+      current_insn.field_value[i].value = mapped_operand[i].value;
+      if (opc->id == AVR32_OPC_COP)
+	current_insn.field_value[i].align_order = 0;
+      else
+	current_insn.field_value[i].align_order
+	  = mapped_operand[i].align;
+    }
+
+  current_insn.next_slot = opc->nr_fields;
+
+  return finish_insn(opc);
+}
+
+static const char *
+finish_lda(const struct avr32_syntax *syntax ATTRIBUTE_UNUSED)
+{
+  expressionS *exp = &current_insn.immediate;
+  relax_substateT initial_subtype;
+  symbolS *sym;
+  offsetT off;
+  int initial_size, max_size;
+  char *buf;
+
+  initial_size = LDA_INITIAL_SIZE;
+
+  if (avr32_pic)
+    {
+      initial_subtype = LDA_SUBTYPE_SUB;
+      if (linkrelax)
+	max_size = 8;
+      else
+	max_size = 4;
+    }
+  else
+    {
+      initial_subtype = LDA_SUBTYPE_MOV1;
+      max_size = 4;
+    }
+
+  frag_grow(max_size);
+  buf = frag_more(initial_size);
+  dwarf2_emit_insn(initial_size);
+
+  if (exp->X_op == O_symbol)
+    {
+      sym = exp->X_add_symbol;
+      off = exp->X_add_number;
+    }
+  else
+    {
+      sym = make_expr_symbol(exp);
+      off = 0;
+    }
+
+  frag_now->tc_frag_data.reloc_info = current_insn.field_value[0].value;
+  frag_now->tc_frag_data.relaxer = &avr32_lda_relaxer;
+
+  if (!avr32_pic)
+    {
+      /* The relaxer will bump the refcount if necessary */
+      frag_now->tc_frag_data.pool
+	= add_to_cpool(exp, &frag_now->tc_frag_data.pool_entry, 0);
+    }
+
+  frag_var(rs_machine_dependent, max_size - initial_size,
+	   initial_size, initial_subtype, sym, off, buf);
+
+  return NULL;
+}
+
+static const char *
+finish_call(const struct avr32_syntax *syntax ATTRIBUTE_UNUSED)
+{
+  expressionS *exp = &current_insn.immediate;
+  symbolS *sym;
+  offsetT off;
+  int initial_size, max_size;
+  char *buf;
+
+  initial_size = CALL_INITIAL_SIZE;
+
+  if (avr32_pic)
+    {
+      if (linkrelax)
+	max_size = 10;
+      else
+	max_size = 4;
+    }
+  else
+    max_size = 4;
+
+  frag_grow(max_size);
+  buf = frag_more(initial_size);
+  dwarf2_emit_insn(initial_size);
+
+  frag_now->tc_frag_data.relaxer = &avr32_call_relaxer;
+
+  if (exp->X_op == O_symbol)
+    {
+      sym = exp->X_add_symbol;
+      off = exp->X_add_number;
+    }
+  else
+    {
+      sym = make_expr_symbol(exp);
+      off = 0;
+    }
+
+  if (!avr32_pic)
+    {
+      /* The relaxer will bump the refcount if necessary */
+      frag_now->tc_frag_data.pool
+	= add_to_cpool(exp, &frag_now->tc_frag_data.pool_entry, 0);
+    }
+
+  frag_var(rs_machine_dependent, max_size - initial_size,
+	   initial_size, CALL_SUBTYPE_RCALL1, sym, off, buf);
+
+  return NULL;
+}
+
+void
+md_begin (void)
+{
+  unsigned long flags = 0;
+  int i;
+
+  avr32_mnemonic_htab = hash_new();
+
+  if (!avr32_mnemonic_htab)
+    as_fatal(_("virtual memory exhausted"));
+
+  for (i = 0; i < AVR32_NR_MNEMONICS; i++)
+    {
+      hash_insert(avr32_mnemonic_htab, avr32_mnemonic_table[i].name,
+		  (void *)&avr32_mnemonic_table[i]);
+    }
+
+  if (linkrelax)
+    flags |= EF_AVR32_LINKRELAX;
+  if (avr32_pic)
+    flags |= EF_AVR32_PIC;
+
+  bfd_set_private_flags(stdoutput, flags);
+
+#ifdef OPC_CONSISTENCY_CHECK
+  if (sizeof(avr32_operand_table)/sizeof(avr32_operand_table[0])
+      < AVR32_NR_OPERANDS)
+    as_fatal(_("operand table is incomplete"));
+
+  for (i = 0; i < AVR32_NR_OPERANDS; i++)
+    if (avr32_operand_table[i].id != i)
+      as_fatal(_("operand table inconsistency found at index %d\n"), i);
+  pr_debug("%d operands verified\n", AVR32_NR_OPERANDS);
+
+  for (i = 0; i < AVR32_NR_IFIELDS; i++)
+    if (avr32_ifield_table[i].id != i)
+      as_fatal(_("ifield table inconsistency found at index %d\n"), i);
+  pr_debug("%d instruction fields verified\n", AVR32_NR_IFIELDS);
+
+  for (i = 0; i < AVR32_NR_OPCODES; i++)
+    {
+      if (avr32_opc_table[i].id != i)
+	as_fatal(_("opcode table inconsistency found at index %d\n"), i);
+      if ((avr32_opc_table[i].var_field == -1
+	   && avr32_relax_table[i].length != 0)
+	  || (avr32_opc_table[i].var_field != -1
+	      && avr32_relax_table[i].length == 0))
+	as_fatal(_("relax table inconsistency found at index %d\n"), i);
+    }
+  pr_debug("%d opcodes verified\n", AVR32_NR_OPCODES);
+
+  for (i = 0; i < AVR32_NR_SYNTAX; i++)
+    if (avr32_syntax_table[i].id != i)
+      as_fatal(_("syntax table inconsistency found at index %d\n"), i);
+  pr_debug("%d syntax variants verified\n", AVR32_NR_SYNTAX);
+
+  for (i = 0; i < AVR32_NR_ALIAS; i++)
+    if (avr32_alias_table[i].id != i)
+      as_fatal(_("alias table inconsistency found at index %d\n"), i);
+  pr_debug("%d aliases verified\n", AVR32_NR_ALIAS);
+
+  for (i = 0; i < AVR32_NR_MNEMONICS; i++)
+    if (avr32_mnemonic_table[i].id != i)
+      as_fatal(_("mnemonic table inconsistency found at index %d\n"), i);
+  pr_debug("%d mnemonics verified\n", AVR32_NR_MNEMONICS);
+#endif
+}
+
+void
+md_assemble (char *str)
+{
+  struct avr32_mnemonic *mnemonic;
+  char *p, c;
+
+  memset(&current_insn, 0, sizeof(current_insn));
+  current_insn.immediate.X_op = O_constant;
+
+  skip_whitespace(str);
+  for (p = str; *p; p++)
+    if (*p == ' ')
+      break;
+  c = *p;
+  *p = 0;
+
+  mnemonic = hash_find(avr32_mnemonic_htab, str);
+  *p = c;
+  if (c) p++;
+
+  if (mnemonic)
+    {
+      const struct avr32_syntax *syntax;
+
+      for (syntax = mnemonic->syntax; syntax; syntax = syntax->next)
+	{
+	  const char *errmsg = NULL;
+
+	  if (syntax_matches(syntax, p))
+	    {
+	      if (!(syntax->isa_flags & avr32_arch->isa_flags))
+		{
+		  as_bad(_("Selected architecture `%s'  does not support `%s'"),
+			 avr32_arch->name, str);
+		  return;
+		}
+
+	      current_insn.syntax = syntax;
+	      parse_operands(p);
+
+	      switch (syntax->type)
+		{
+		case AVR32_PARSER_NORMAL:
+		  errmsg = finish_insn(syntax->u.opc);
+		  break;
+		case AVR32_PARSER_ALIAS:
+		  errmsg = finish_alias(syntax->u.alias);
+		  break;
+		case AVR32_PARSER_LDA:
+		  errmsg = finish_lda(syntax);
+		  break;
+		case AVR32_PARSER_CALL:
+		  errmsg = finish_call(syntax);
+		  break;
+		default:
+		  BAD_CASE(syntax->type);
+		  break;
+		}
+
+	      if (errmsg)
+		as_bad("%s in `%s'", errmsg, str);
+
+	      return;
+	    }
+	}
+
+      as_bad(_("unrecognized form of instruction: `%s'"), str);
+    }
+  else
+    as_bad(_("unrecognized instruction `%s'"), str);
+}
+
+void avr32_cleanup(void)
+{
+  struct cpool *pool;
+
+  /* Emit any constant pools that haven't been explicitly flushed with
+     a .cpool directive. */
+  for (pool = cpool_list; pool; pool = pool->next)
+    {
+      subseg_set(pool->section, pool->sub_section);
+      s_cpool(0);
+    }
+}
+
+/* Handle any PIC-related operands in data allocation pseudo-ops */
+void
+avr32_cons_fix_new (fragS *frag, int off, int size, expressionS *exp)
+{
+  bfd_reloc_code_real_type r_type = BFD_RELOC_UNUSED;
+  int pcrel = 0;
+
+  pr_debug("%s:%u: cons_fix_new, add_sym: %s, op_sym: %s, op: %d, add_num: %d\n",
+	   frag->fr_file, frag->fr_line,
+	   exp->X_add_symbol?S_GET_NAME(exp->X_add_symbol):"(none)",
+	   exp->X_op_symbol?S_GET_NAME(exp->X_op_symbol):"(none)",
+	   exp->X_op, exp->X_add_number);
+
+  if (exp->X_op == O_subtract && exp->X_op_symbol)
+    {
+      if (exp->X_op_symbol == GOT_symbol)
+	{
+	  if (size != 4)
+	    goto bad_size;
+	  r_type = BFD_RELOC_AVR32_GOTPC;
+	  exp->X_op = O_symbol;
+	  exp->X_op_symbol = NULL;
+	}
+    }
+  else if (exp->X_op == O_got)
+    {
+      switch (size)
+	{
+	case 1:
+	  r_type = BFD_RELOC_AVR32_GOT8;
+	  break;
+	case 2:
+	  r_type = BFD_RELOC_AVR32_GOT16;
+	  break;
+	case 4:
+	  r_type = BFD_RELOC_AVR32_GOT32;
+	  break;
+	default:
+	  goto bad_size;
+	}
+
+      exp->X_op = O_symbol;
+    }
+
+  if (r_type == BFD_RELOC_UNUSED)
+    switch (size)
+      {
+      case 1:
+	r_type = BFD_RELOC_8;
+	break;
+      case 2:
+	r_type = BFD_RELOC_16;
+	break;
+      case 4:
+	r_type = BFD_RELOC_32;
+	break;
+      default:
+	goto bad_size;
+      }
+  else if (size != 4)
+    {
+    bad_size:
+      as_bad(_("unsupported BFD relocation size %u"), size);
+      r_type = BFD_RELOC_UNUSED;
+    }
+
+  fix_new_exp (frag, off, size, exp, pcrel, r_type);
+}
+
+static void
+avr32_frob_section(bfd *abfd ATTRIBUTE_UNUSED, segT sec,
+		   void *ignore ATTRIBUTE_UNUSED)
+{
+  segment_info_type *seginfo;
+  fixS *fix;
+
+  seginfo = seg_info(sec);
+  if (!seginfo)
+    return;
+
+  for (fix = seginfo->fix_root; fix; fix = fix->fx_next)
+    {
+      if (fix->fx_done)
+	continue;
+
+      if (fix->fx_r_type == BFD_RELOC_AVR32_SUB5
+	  && fix->fx_addsy && fix->fx_subsy)
+	{
+	  if (S_GET_SEGMENT(fix->fx_addsy) != S_GET_SEGMENT(fix->fx_subsy)
+	      || linkrelax)
+	    {
+	      symbolS *tmp;
+#ifdef DEBUG
+	      fprintf(stderr, "Swapping symbols in fixup:\n");
+	      print_fixup(fix);
+#endif
+	      tmp = fix->fx_addsy;
+	      fix->fx_addsy = fix->fx_subsy;
+	      fix->fx_subsy = tmp;
+	      fix->fx_offset = -fix->fx_offset;
+	    }
+	}
+    }
+}
+
+/* We need to look for SUB5 instructions with expressions that will be
+   made PC-relative and switch fx_addsy with fx_subsy.  This has to be
+   done before adjustment or the wrong symbol might be adjusted.
+
+   This applies to fixups that are a result of expressions like -(sym
+   - .) and that will make it all the way to md_apply_fix3().  LDA
+   does the right thing in convert_frag, so we must not convert
+   those. */
+void
+avr32_frob_file(void)
+{
+  /* if (1 || !linkrelax)
+     return; */
+
+  bfd_map_over_sections(stdoutput, avr32_frob_section, NULL);
+}
+
+static bfd_boolean
+convert_to_diff_reloc(fixS *fixP)
+{
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_32:
+      fixP->fx_r_type = BFD_RELOC_AVR32_DIFF32;
+      break;
+    case BFD_RELOC_16:
+      fixP->fx_r_type = BFD_RELOC_AVR32_DIFF16;
+      break;
+    case BFD_RELOC_8:
+      fixP->fx_r_type = BFD_RELOC_AVR32_DIFF8;
+      break;
+    default:
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Simplify a fixup.  If possible, the fixup is reduced to a single
+   constant which is written to the output file.  Otherwise, a
+   relocation is generated so that the linker can take care of the
+   rest.
+
+   ELF relocations have certain constraints: They can only take a
+   single symbol and a single addend.  This means that for difference
+   expressions, we _must_ get rid of the fx_subsy symbol somehow.
+
+   The difference between two labels in the same section can be
+   calculated directly unless 'linkrelax' is set, or a relocation is
+   forced.  If so, we must emit a R_AVR32_DIFFxx relocation.  If there
+   are addends involved at this point, we must be especially careful
+   as the relocation must point exactly to the symbol being
+   subtracted.
+
+   When subtracting a symbol defined in the same section as the fixup,
+   we might be able to convert it to a PC-relative expression, unless
+   linkrelax is set. If this is the case, there's no way we can make
+   sure that the difference between the fixup and fx_subsy stays
+   constant.  So for now, we're just going to disallow that.
+   */
+void
+avr32_process_fixup(fixS *fixP, segT this_segment)
+{
+  segT add_symbol_segment = absolute_section;
+  segT sub_symbol_segment = absolute_section;
+  symbolS *fx_addsy, *fx_subsy;
+  offsetT value = 0, fx_offset;
+  bfd_boolean apply = FALSE;
+
+  assert(this_segment != absolute_section);
+
+  if (fixP->fx_r_type >= BFD_RELOC_UNUSED)
+    {
+      as_bad_where(fixP->fx_file, fixP->fx_line,
+		   _("Bad relocation type %d\n"), fixP->fx_r_type);
+      return;
+    }
+
+  /* BFD_RELOC_AVR32_SUB5 fixups have been swapped by avr32_frob_section() */
+  fx_addsy = fixP->fx_addsy;
+  fx_subsy = fixP->fx_subsy;
+  fx_offset = fixP->fx_offset;
+
+  if (fx_addsy)
+    add_symbol_segment = S_GET_SEGMENT(fx_addsy);
+
+  if (fx_subsy)
+    {
+      resolve_symbol_value(fx_subsy);
+      sub_symbol_segment = S_GET_SEGMENT(fx_subsy);
+
+      if (sub_symbol_segment == this_segment
+	  && (!linkrelax
+	      || S_GET_VALUE(fx_subsy) == (fixP->fx_frag->fr_address
+					   + fixP->fx_where)))
+	{
+	  fixP->fx_pcrel = TRUE;
+	  fx_offset += (fixP->fx_frag->fr_address + fixP->fx_where
+			- S_GET_VALUE(fx_subsy));
+	  fx_subsy = NULL;
+	}
+      else if (sub_symbol_segment == absolute_section)
+	{
+	  /* The symbol is really a constant.  */
+	  fx_offset -= S_GET_VALUE(fx_subsy);
+	  fx_subsy = NULL;
+	}
+      else if (SEG_NORMAL(add_symbol_segment)
+	       && sub_symbol_segment == add_symbol_segment
+	       && (!linkrelax || convert_to_diff_reloc(fixP)))
+	{
+	  /* Difference between two labels in the same section.  */
+	  if (linkrelax)
+	    {
+	      /* convert_to_diff() has ensured that the reloc type is
+		 either DIFF32, DIFF16 or DIFF8.  */
+	      value = (S_GET_VALUE(fx_addsy) + fixP->fx_offset
+		       - S_GET_VALUE(fx_subsy));
+
+	      /* Try to convert it to a section symbol if possible  */
+	      if (!S_FORCE_RELOC(fx_addsy, 1)
+		  && !(sub_symbol_segment->flags & SEC_THREAD_LOCAL))
+		{
+		  fx_offset = S_GET_VALUE(fx_subsy);
+		  fx_addsy = section_symbol(sub_symbol_segment);
+		}
+	      else
+		{
+		  fx_addsy = fx_subsy;
+		  fx_offset = 0;
+		}
+
+	      fx_subsy = NULL;
+	      apply = TRUE;
+	    }
+	  else
+	    {
+	      fx_offset += S_GET_VALUE(fx_addsy);
+	      fx_offset -= S_GET_VALUE(fx_subsy);
+	      fx_addsy = NULL;
+	      fx_subsy = NULL;
+	    }
+	}
+      else
+	{
+	  as_bad_where(fixP->fx_file, fixP->fx_line,
+		       _("can't resolve `%s' {%s section} - `%s' {%s section}"),
+		       fx_addsy ? S_GET_NAME (fx_addsy) : "0",
+		       segment_name (add_symbol_segment),
+		       S_GET_NAME (fx_subsy),
+		       segment_name (sub_symbol_segment));
+	  return;
+	}
+    }
+
+  if (fx_addsy && !TC_FORCE_RELOCATION(fixP))
+    {
+      if (add_symbol_segment == this_segment
+	  && fixP->fx_pcrel)
+	{
+	  value += S_GET_VALUE(fx_addsy);
+	  value -= md_pcrel_from_section(fixP, this_segment);
+	  fx_addsy = NULL;
+	  fixP->fx_pcrel = FALSE;
+	}
+      else if (add_symbol_segment == absolute_section)
+	{
+	  fx_offset += S_GET_VALUE(fixP->fx_addsy);
+	  fx_addsy = NULL;
+	}
+    }
+
+  if (!fx_addsy)
+    fixP->fx_done = TRUE;
+
+  if (fixP->fx_pcrel)
+    {
+      if (fx_addsy != NULL
+	  && S_IS_DEFINED(fx_addsy)
+	  && S_GET_SEGMENT(fx_addsy) != this_segment)
+	value += md_pcrel_from_section(fixP, this_segment);
+
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_32:
+	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
+	  break;
+	case BFD_RELOC_16:
+	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
+	  break;
+	case BFD_RELOC_8:
+	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
+	  break;
+	case BFD_RELOC_AVR32_SUB5:
+	  fixP->fx_r_type = BFD_RELOC_AVR32_16N_PCREL;
+	  break;
+	case BFD_RELOC_AVR32_16S:
+	  fixP->fx_r_type = BFD_RELOC_AVR32_16B_PCREL;
+	  break;
+	case BFD_RELOC_AVR32_14UW:
+	  fixP->fx_r_type = BFD_RELOC_AVR32_14UW_PCREL;
+	  break;
+	case BFD_RELOC_AVR32_10UW:
+	  fixP->fx_r_type = BFD_RELOC_AVR32_10UW_PCREL;
+	  break;
+	default:
+	  /* Should have been taken care of already */
+	  break;
+	}
+    }
+
+  if (fixP->fx_done || apply)
+    {
+      const struct avr32_ifield *ifield;
+      char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+
+      if (fixP->fx_done)
+	value += fx_offset;
+
+      /* For hosts with longs bigger than 32-bits make sure that the top
+         bits of a 32-bit negative value read in by the parser are set,
+         so that the correct comparisons are made.  */
+      if (value & 0x80000000)
+        value |= (-1L << 31);
+
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_32:
+	case BFD_RELOC_16:
+	case BFD_RELOC_8:
+	case BFD_RELOC_AVR32_DIFF32:
+	case BFD_RELOC_AVR32_DIFF16:
+	case BFD_RELOC_AVR32_DIFF8:
+	  md_number_to_chars(buf, value, fixP->fx_size);
+	  break;
+	case BFD_RELOC_HI16:
+	  value >>= 16;
+	case BFD_RELOC_LO16:
+	  value &= 0xffff;
+	  md_number_to_chars(buf + 2, value, 2);
+	  break;
+	case BFD_RELOC_AVR32_16N_PCREL:
+	  value = -value;
+	  /* fall through */
+	case BFD_RELOC_AVR32_22H_PCREL:
+	case BFD_RELOC_AVR32_18W_PCREL:
+	case BFD_RELOC_AVR32_16B_PCREL:
+	case BFD_RELOC_AVR32_11H_PCREL:
+	case BFD_RELOC_AVR32_9H_PCREL:
+	case BFD_RELOC_AVR32_9UW_PCREL:
+	case BFD_RELOC_AVR32_3U:
+	case BFD_RELOC_AVR32_4UH:
+	case BFD_RELOC_AVR32_6UW:
+	case BFD_RELOC_AVR32_6S:
+	case BFD_RELOC_AVR32_7UW:
+	case BFD_RELOC_AVR32_8S_EXT:
+	case BFD_RELOC_AVR32_8S:
+	case BFD_RELOC_AVR32_10UW:
+	case BFD_RELOC_AVR32_10SW:
+	case BFD_RELOC_AVR32_STHH_W:
+	case BFD_RELOC_AVR32_14UW:
+	case BFD_RELOC_AVR32_16S:
+	case BFD_RELOC_AVR32_16U:
+	case BFD_RELOC_AVR32_21S:
+	case BFD_RELOC_AVR32_SUB5:
+	case BFD_RELOC_AVR32_CPCALL:
+	case BFD_RELOC_AVR32_16_CP:
+	case BFD_RELOC_AVR32_9W_CP:
+	case BFD_RELOC_AVR32_15S:
+	  ifield = fixP->tc_fix_data.ifield;
+	  pr_debug("insert field: %ld <= %ld <= %ld (align %u)\n",
+		   fixP->tc_fix_data.min, value, fixP->tc_fix_data.max,
+		   fixP->tc_fix_data.align);
+	  if (value < fixP->tc_fix_data.min || value > fixP->tc_fix_data.max)
+	    as_bad_where(fixP->fx_file, fixP->fx_line,
+			 _("operand out of range (%ld not between %ld and %ld)"),
+			 value, fixP->tc_fix_data.min, fixP->tc_fix_data.max);
+	  if (value & ((1 << fixP->tc_fix_data.align) - 1))
+	    as_bad_where(fixP->fx_file, fixP->fx_line,
+			 _("misaligned operand (required alignment: %d)"),
+			 1 << fixP->tc_fix_data.align);
+	  ifield->insert(ifield, buf, value >> fixP->tc_fix_data.align);
+	  break;
+	case BFD_RELOC_AVR32_ALIGN:
+	  /* Nothing to do */
+	  fixP->fx_done = FALSE;
+	  break;
+	default:
+	  as_fatal("reloc type %s not handled\n",
+		   bfd_get_reloc_code_name(fixP->fx_r_type));
+	}
+    }
+
+  fixP->fx_addsy = fx_addsy;
+  fixP->fx_subsy = fx_subsy;
+  fixP->fx_offset = fx_offset;
+
+  if (!fixP->fx_done)
+    {
+      if (!fixP->fx_addsy)
+	fixP->fx_addsy = abs_section_sym;
+
+      symbol_mark_used_in_reloc(fixP->fx_addsy);
+      if (fixP->fx_subsy)
+	abort();
+    }
+}
+
+#if 0
+void
+md_apply_fix3 (fixS *fixP, valueT *valP, segT seg)
+{
+  const struct avr32_ifield *ifield;
+  offsetT	value = *valP;
+  char		*buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+  bfd_boolean	apply;
+
+  pr_debug("%s:%u: apply_fix3: r_type=%d value=%lx offset=%lx\n",
+	   fixP->fx_file, fixP->fx_line, fixP->fx_r_type, *valP,
+	   fixP->fx_offset);
+
+  if (fixP->fx_r_type >= BFD_RELOC_UNUSED)
+    {
+      as_bad_where(fixP->fx_file, fixP->fx_line,
+		   _("Bad relocation type %d\n"), fixP->fx_r_type);
+      return;
+    }
+
+  if (!fixP->fx_addsy && !fixP->fx_subsy)
+    fixP->fx_done = 1;
+
+  if (fixP->fx_pcrel)
+    {
+      if (fixP->fx_addsy != NULL
+	  && S_IS_DEFINED(fixP->fx_addsy)
+	  && S_GET_SEGMENT(fixP->fx_addsy) != seg)
+	value += md_pcrel_from_section(fixP, seg);
+
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_32:
+	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
+	  break;
+	case BFD_RELOC_16:
+	case BFD_RELOC_8:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("8- and 16-bit PC-relative relocations not supported"));
+	  break;
+	case BFD_RELOC_AVR32_SUB5:
+	  fixP->fx_r_type = BFD_RELOC_AVR32_PCREL_SUB5;
+	  break;
+	case BFD_RELOC_AVR32_16S:
+	  fixP->fx_r_type = BFD_RELOC_AVR32_16_PCREL;
+	  break;
+	default:
+	  /* Should have been taken care of already */
+	  break;
+	}
+    }
+
+  if (fixP->fx_r_type == BFD_RELOC_32
+      && fixP->fx_subsy)
+    {
+      fixP->fx_r_type = BFD_RELOC_AVR32_DIFF32;
+
+      /* Offsets are only allowed if it's a result of adjusting a
+	 local symbol into a section-relative offset.
+	 tc_fix_adjustable() should prevent any adjustment if there
+	 was an offset involved before.  */
+      if (fixP->fx_offset && !symbol_section_p(fixP->fx_addsy))
+	as_bad_where(fixP->fx_file, fixP->fx_line,
+		     _("cannot represent symbol difference with an offset"));
+
+      value = (S_GET_VALUE(fixP->fx_addsy) + fixP->fx_offset
+	       - S_GET_VALUE(fixP->fx_subsy));
+
+      /* The difference before any relaxing takes place is written
+	 out, and the DIFF32 reloc identifies the address of the first
+	 symbol (i.e. the on that's subtracted.)  */
+      *valP = value;
+      fixP->fx_offset -= value;
+      fixP->fx_subsy = NULL;
+
+      md_number_to_chars(buf, value, fixP->fx_size);
+    }
+
+  if (fixP->fx_done)
+    {
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_8:
+	case BFD_RELOC_16:
+	case BFD_RELOC_32:
+	  md_number_to_chars(buf, value, fixP->fx_size);
+	  break;
+	case BFD_RELOC_HI16:
+	  value >>= 16;
+	case BFD_RELOC_LO16:
+	  value &= 0xffff;
+	  *valP = value;
+	  md_number_to_chars(buf + 2, value, 2);
+	  break;
+	case BFD_RELOC_AVR32_PCREL_SUB5:
+	  value = -value;
+	  /* fall through */
+	case BFD_RELOC_AVR32_9_PCREL:
+	case BFD_RELOC_AVR32_11_PCREL:
+	case BFD_RELOC_AVR32_16_PCREL:
+	case BFD_RELOC_AVR32_18_PCREL:
+	case BFD_RELOC_AVR32_22_PCREL:
+	case BFD_RELOC_AVR32_3U:
+	case BFD_RELOC_AVR32_4UH:
+	case BFD_RELOC_AVR32_6UW:
+	case BFD_RELOC_AVR32_6S:
+	case BFD_RELOC_AVR32_7UW:
+	case BFD_RELOC_AVR32_8S:
+	case BFD_RELOC_AVR32_10UW:
+	case BFD_RELOC_AVR32_10SW:
+	case BFD_RELOC_AVR32_14UW:
+	case BFD_RELOC_AVR32_16S:
+	case BFD_RELOC_AVR32_16U:
+	case BFD_RELOC_AVR32_21S:
+	case BFD_RELOC_AVR32_BRC1:
+	case BFD_RELOC_AVR32_SUB5:
+	case BFD_RELOC_AVR32_CPCALL:
+	case BFD_RELOC_AVR32_16_CP:
+	case BFD_RELOC_AVR32_9_CP:
+	case BFD_RELOC_AVR32_15S:
+	  ifield = fixP->tc_fix_data.ifield;
+	  pr_debug("insert field: %ld <= %ld <= %ld (align %u)\n",
+		   fixP->tc_fix_data.min, value, fixP->tc_fix_data.max,
+		   fixP->tc_fix_data.align);
+	  if (value < fixP->tc_fix_data.min || value > fixP->tc_fix_data.max)
+	    as_bad_where(fixP->fx_file, fixP->fx_line,
+			 _("operand out of range (%ld not between %ld and %ld)"),
+			 value, fixP->tc_fix_data.min, fixP->tc_fix_data.max);
+	  if (value & ((1 << fixP->tc_fix_data.align) - 1))
+	    as_bad_where(fixP->fx_file, fixP->fx_line,
+			 _("misaligned operand (required alignment: %d)"),
+			 1 << fixP->tc_fix_data.align);
+	  ifield->insert(ifield, buf, value >> fixP->tc_fix_data.align);
+	  break;
+	case BFD_RELOC_AVR32_ALIGN:
+	  /* Nothing to do */
+	  fixP->fx_done = FALSE;
+	  break;
+	default:
+	  as_fatal("reloc type %s not handled\n",
+		   bfd_get_reloc_code_name(fixP->fx_r_type));
+	}
+    }
+}
+#endif
+
+arelent *
+tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
+	      fixS *fixp)
+{
+  arelent *reloc;
+  bfd_reloc_code_real_type code;
+
+  reloc = xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->addend = fixp->fx_offset;
+  code = fixp->fx_r_type;
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("cannot represent relocation %s in this object file format"),
+		    bfd_get_reloc_code_name (code));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+bfd_boolean
+avr32_force_reloc(fixS *fixP)
+{
+  if (linkrelax && fixP->fx_addsy
+      && !(S_GET_SEGMENT(fixP->fx_addsy)->flags & SEC_DEBUGGING)
+      && S_GET_SEGMENT(fixP->fx_addsy) != absolute_section)
+    {
+      pr_debug(stderr, "force reloc: addsy=%p, r_type=%d, sec=%s\n",
+	       fixP->fx_addsy, fixP->fx_r_type, S_GET_SEGMENT(fixP->fx_addsy)->name);
+      return 1;
+    }
+
+  return generic_force_reloc(fixP);
+}
+
+bfd_boolean
+avr32_fix_adjustable(fixS *fixP)
+{
+  switch (fixP->fx_r_type)
+    {
+      /* GOT relocations can't have addends since BFD treats all
+	 references to a given symbol the same. This means that we
+	 must avoid section-relative references to local symbols when
+	 dealing with these kinds of relocs */
+    case BFD_RELOC_AVR32_GOT32:
+    case BFD_RELOC_AVR32_GOT16:
+    case BFD_RELOC_AVR32_GOT8:
+    case BFD_RELOC_AVR32_GOT21S:
+    case BFD_RELOC_AVR32_GOT18SW:
+    case BFD_RELOC_AVR32_GOT16S:
+    case BFD_RELOC_AVR32_LDA_GOT:
+    case BFD_RELOC_AVR32_GOTCALL:
+      pr_debug("fix not adjustable\n");
+      return 0;
+
+    default:
+      break;
+    }
+
+  return 1;
+}
+
+/* When we want the linker to be able to relax the code, we need to
+   output a reloc for every .align directive requesting an alignment
+   to a four byte boundary or larger.  If we don't do this, the linker
+   can't guarantee that the alignment is actually maintained in the
+   linker output.
+
+   TODO: Might as well insert proper NOPs while we're at it... */
+void
+avr32_handle_align(fragS *frag)
+{
+  if (linkrelax
+      && frag->fr_type == rs_align_code
+      && frag->fr_address + frag->fr_fix > 0
+      && frag->fr_offset > 0)
+    {
+      /* The alignment order (fr_offset) is stored in the addend. */
+      fix_new(frag, frag->fr_fix, 2, &abs_symbol, frag->fr_offset,
+	      FALSE, BFD_RELOC_AVR32_ALIGN);
+    }
+}
+
+/* Relax_align. Advance location counter to next address that has 'alignment'
+   lowest order bits all 0s, return size of adjustment made.  */
+relax_addressT
+avr32_relax_align(segT segment ATTRIBUTE_UNUSED,
+		  fragS *fragP,
+		  relax_addressT address)
+{
+  relax_addressT mask;
+  relax_addressT new_address;
+  int alignment;
+
+  alignment = fragP->fr_offset;
+  mask = ~((~0) << alignment);
+  new_address = (address + mask) & (~mask);
+
+  return new_address - address;
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type type, and store the appropriate bytes in *litP.  The number
+   of LITTLENUMS emitted is stored in *sizeP .  An error message is
+   returned, or NULL on OK. */
+
+/* Equal to MAX_PRECISION in atof-ieee.c */
+#define MAX_LITTLENUMS 6
+
+char *
+md_atof (type, litP, sizeP)
+char   type;
+char * litP;
+int *  sizeP;
+{
+  int              i;
+  int              prec;
+  LITTLENUM_TYPE   words [MAX_LITTLENUMS];
+  char *           t;
+
+  switch (type)
+  {
+    case 'f':
+    case 'F':
+    case 's':
+    case 'S':
+      prec = 2;
+      break;
+
+    case 'd':
+    case 'D':
+    case 'r':
+    case 'R':
+      prec = 4;
+      break;
+
+      /* FIXME: Some targets allow other format chars for bigger sizes here.  */
+
+    default:
+      * sizeP = 0;
+      return _("Bad call to md_atof()");
+  }
+
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+  * sizeP = prec * sizeof (LITTLENUM_TYPE);
+
+  for (i = 0; i < prec; i++)
+  {
+    md_number_to_chars (litP, (valueT) words[i],
+                        sizeof (LITTLENUM_TYPE));
+    litP += sizeof (LITTLENUM_TYPE);
+  }
+
+  return 0;
+}
+
+static char *avr32_end_of_match(char *cont, char *what)
+{
+  int len = strlen (what);
+
+  if (! is_part_of_name (cont[len])
+      && strncasecmp (cont, what, len) == 0)
+    return cont + len;
+
+  return NULL;
+}
+
+int
+avr32_parse_name (char const *name, expressionS *exp, char *nextchar)
+{
+  char *next = input_line_pointer;
+  char *next_end;
+
+  pr_debug("parse_name: %s, nextchar=%c (%02x)\n", name, *nextchar, *nextchar);
+
+  if (*nextchar == '(')
+    {
+      if (strcasecmp(name, "hi") == 0)
+	{
+	  *next = *nextchar;
+
+	  expression(exp);
+
+	  if (exp->X_op == O_constant)
+	    {
+	      pr_debug("  -> constant hi(0x%08lx) -> 0x%04lx\n",
+		       exp->X_add_number, exp->X_add_number >> 16);
+	      exp->X_add_number = (exp->X_add_number >> 16) & 0xffff;
+	    }
+	  else
+	    {
+	      exp->X_md = exp->X_op;
+	      exp->X_op = O_hi;
+	    }
+
+	  return 1;
+	}
+      else if (strcasecmp(name, "lo") == 0)
+	{
+	  *next = *nextchar;
+
+	  expression(exp);
+
+	  if (exp->X_op == O_constant)
+	    exp->X_add_number &= 0xffff;
+	  else
+	    {
+	      exp->X_md = exp->X_op;
+	      exp->X_op = O_lo;
+	    }
+
+	  return 1;
+	}
+    }
+  else if (*nextchar == '@')
+    {
+      exp->X_md = exp->X_op;
+
+      if ((next_end = avr32_end_of_match (next + 1, "got")))
+	exp->X_op = O_got;
+      else if ((next_end = avr32_end_of_match (next + 1, "tlsgd")))
+	exp->X_op = O_tlsgd;
+      /* Add more as needed */
+      else
+	{
+	  char c;
+	  input_line_pointer++;
+	  c = get_symbol_end();
+	  as_bad (_("unknown relocation override `%s'"), next + 1);
+	  *input_line_pointer = c;
+	  input_line_pointer = next;
+	  return 0;
+	}
+
+      exp->X_op_symbol = NULL;
+      exp->X_add_symbol = symbol_find_or_make (name);
+      exp->X_add_number = 0;
+
+      *input_line_pointer = *nextchar;
+      input_line_pointer = next_end;
+      *nextchar = *input_line_pointer;
+      *input_line_pointer = '\0';
+      return 1;
+    }
+  else if (strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
+    {
+      if (!GOT_symbol)
+	GOT_symbol = symbol_find_or_make(name);
+
+      exp->X_add_symbol = GOT_symbol;
+      exp->X_op = O_symbol;
+      exp->X_add_number = 0;
+      return 1;
+    }
+
+  return 0;
+}
+
+static void
+s_rseg (int value ATTRIBUTE_UNUSED)
+{
+  /* Syntax: RSEG segment_name [:type] [NOROOT|ROOT] [(align)]
+   * Defaults:
+   *  - type: undocumented ("typically CODE or DATA")
+   *  - ROOT
+   *  - align: 1 for code, 0 for others
+   *
+   * TODO: NOROOT is ignored. If gas supports discardable segments, it should
+   * be implemented.
+   */
+  char *name, *end;
+  int length, type, attr;
+  int align = 0;
+
+  SKIP_WHITESPACE();
+
+  end = input_line_pointer;
+  while (0 == strchr ("\n\t;:( ", *end))
+    end++;
+  if (end == input_line_pointer)
+    {
+      as_warn (_("missing name"));
+      ignore_rest_of_line();
+      return;
+    }
+
+  name = xmalloc (end - input_line_pointer + 1);
+  memcpy (name, input_line_pointer, end - input_line_pointer);
+  name[end - input_line_pointer] = '\0';
+  input_line_pointer = end;
+
+  SKIP_WHITESPACE();
+
+  type = SHT_NULL;
+  attr = 0;
+
+  if (*input_line_pointer == ':')
+    {
+      /* Skip the colon */
+      ++input_line_pointer;
+      SKIP_WHITESPACE();
+
+      /* Possible options at this point:
+       *   - flag (ROOT or NOROOT)
+       *   - a segment type
+       */
+      end = input_line_pointer;
+      while (0 == strchr ("\n\t;:( ", *end))
+	end++;
+      length = end - input_line_pointer;
+      if (((length == 4) && (0 == strncasecmp( input_line_pointer, "ROOT", 4))) ||
+	  ((length == 6) && (0 == strncasecmp( input_line_pointer, "NOROOT", 6))))
+	{
+	  /* Ignore ROOT/NOROOT */
+	  input_line_pointer = end;
+	}
+      else
+	{
+	  /* Must be a segment type */
+	  switch (*input_line_pointer)
+	    {
+	    case 'C':
+	    case 'c':
+	      if ((length == 4) &&
+		  (0 == strncasecmp (input_line_pointer, "CODE", 4)))
+		{
+		  attr |= SHF_ALLOC | SHF_EXECINSTR;
+		  type = SHT_PROGBITS;
+		  align = 1;
+		  break;
+		}
+	      if ((length == 5) &&
+		  (0 == strncasecmp (input_line_pointer, "CONST", 5)))
+		{
+		  attr |= SHF_ALLOC;
+		  type = SHT_PROGBITS;
+		  break;
+		}
+	      goto de_fault;
+
+	    case 'D':
+	    case 'd':
+	      if ((length == 4) &&
+		  (0 == strncasecmp (input_line_pointer, "DATA", 4)))
+		{
+		  attr |= SHF_ALLOC | SHF_WRITE;
+		  type = SHT_PROGBITS;
+		  break;
+		}
+	      goto de_fault;
+
+	      /* TODO: Add FAR*, HUGE*, IDATA and NEAR* if necessary */
+
+	    case 'U':
+	    case 'u':
+	      if ((length == 7) &&
+		  (0 == strncasecmp (input_line_pointer, "UNTYPED", 7)))
+		break;
+	      goto de_fault;
+
+	      /* TODO: Add XDATA and ZPAGE if necessary */
+
+	    de_fault:
+	    default:
+	      as_warn (_("unrecognized segment type"));
+	    }
+
+	  input_line_pointer = end;
+	  SKIP_WHITESPACE();
+
+	  if (*input_line_pointer == ':')
+	    {
+	      /*  ROOT/NOROOT */
+	      ++input_line_pointer;
+	      SKIP_WHITESPACE();
+
+	      end = input_line_pointer;
+	      while (0 == strchr ("\n\t;:( ", *end))
+		end++;
+	      length = end - input_line_pointer;
+	      if (! ((length == 4) &&
+		     (0 == strncasecmp( input_line_pointer, "ROOT", 4))) &&
+		  ! ((length == 6) &&
+		     (0 == strncasecmp( input_line_pointer, "NOROOT", 6))))
+		{
+		  as_warn (_("unrecognized segment flag"));
+		}
+
+	      input_line_pointer = end;
+	      SKIP_WHITESPACE();
+	    }
+	}
+    }
+
+  if (*input_line_pointer == '(')
+    {
+      align = get_absolute_expression ();
+    }
+
+  demand_empty_rest_of_line();
+
+  obj_elf_change_section (name, type, attr, 0, NULL, 0, 0);
+#ifdef AVR32_DEBUG
+  fprintf( stderr, "RSEG: Changed section to %s, type: 0x%x, attr: 0x%x\n",
+      name, type, attr );
+  fprintf( stderr, "RSEG: Aligning to 2**%d\n", align );
+#endif
+
+  if (align > 15)
+    {
+      align = 15;
+      as_warn (_("alignment too large: %u assumed"), align);
+    }
+
+  /* Hope not, that is */
+  assert (now_seg != absolute_section);
+
+  /* Only make a frag if we HAVE to... */
+  if (align != 0 && !need_pass_2)
+    {
+      if (subseg_text_p (now_seg))
+	frag_align_code (align, 0);
+      else
+	frag_align (align, 0, 0);
+    }
+
+  record_alignment (now_seg, align - OCTETS_PER_BYTE_POWER);
+}
+
+/* vim: syntax=c sw=2
+ */
--- /dev/null
+++ b/gas/config/tc-avr32.h
@@ -0,0 +1,325 @@
+/* Assembler definitions for AVR32.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#if 0
+#define DEBUG
+#define DEBUG1
+#define DEBUG2
+#define DEBUG3
+#define DEBUG4
+#define DEBUG5
+#endif
+
+/* Are we trying to be compatible with the IAR assembler? (--iar) */
+extern int avr32_iarcompat;
+
+/* By convention, you should define this macro in the `.h' file.  For
+   example, `tc-m68k.h' defines `TC_M68K'.  You might have to use this
+   if it is necessary to add CPU specific code to the object format
+   file.  */
+#define TC_AVR32
+
+/* This macro is the BFD target name to use when creating the output
+   file.  This will normally depend upon the `OBJ_FMT' macro.  */
+#define TARGET_FORMAT "elf32-avr32"
+
+/* This macro is the BFD architecture to pass to `bfd_set_arch_mach'.  */
+#define TARGET_ARCH bfd_arch_avr32
+
+/* This macro is the BFD machine number to pass to
+   `bfd_set_arch_mach'.  If it is not defined, GAS will use 0.  */
+#define TARGET_MACH 0
+
+/* UNDOCUMENTED: Allow //-style comments */
+#define DOUBLESLASH_LINE_COMMENTS
+
+/* You should define this macro to be non-zero if the target is big
+   endian, and zero if the target is little endian.  */
+#define TARGET_BYTES_BIG_ENDIAN 1
+
+/* FIXME: It seems that GAS only expects a one-byte opcode...
+   #define NOP_OPCODE 0xd703 */
+
+/* If you define this macro, GAS will warn about the use of
+   nonstandard escape sequences in a string.  */
+#undef ONLY_STANDARD_ESCAPES
+
+#define DWARF2_FORMAT() dwarf2_format_32bit
+
+/* Instructions are either 2 or 4 bytes long */
+/* #define DWARF2_LINE_MIN_INSN_LENGTH 2 */
+
+/* GAS will call this function for any expression that can not be
+   recognized.  When the function is called, `input_line_pointer'
+   will point to the start of the expression.  */
+#define md_operand(x)
+
+#define md_parse_name(name, expr, mode, c) avr32_parse_name(name, expr, c)
+extern int avr32_parse_name(const char *, struct expressionS *, char *);
+
+/* You may define this macro to generate a fixup for a data
+   allocation pseudo-op.  */
+#define TC_CONS_FIX_NEW(FRAG, OFF, LEN, EXP)	\
+  avr32_cons_fix_new(FRAG, OFF, LEN, EXP)
+void avr32_cons_fix_new (fragS *, int, int, expressionS *);
+
+/* `extsym - .' expressions can be emitted using PC-relative relocs */
+#define DIFF_EXPR_OK
+
+/* This is used to construct expressions out of @gotoff, etc. The
+   relocation type is stored in X_md */
+#define O_got		O_md1
+#define O_hi		O_md2
+#define O_lo		O_md3
+#define O_tlsgd		O_md4
+
+/* You may define this macro to parse an expression used in a data
+   allocation pseudo-op such as `.word'.  You can use this to
+   recognize relocation directives that may appear in such directives.  */
+/* #define TC_PARSE_CONS_EXPRESSION(EXPR,N) avr_parse_cons_expression (EXPR,N)
+   void avr_parse_cons_expression (expressionS *exp, int nbytes); */
+
+/* This should just call either `number_to_chars_bigendian' or
+   `number_to_chars_littleendian', whichever is appropriate.  On
+   targets like the MIPS which support options to change the
+   endianness, which function to call is a runtime decision.  On
+   other targets, `md_number_to_chars' can be a simple macro.  */
+#define md_number_to_chars number_to_chars_bigendian
+
+/* `md_short_jump_size'
+   `md_long_jump_size'
+   `md_create_short_jump'
+   `md_create_long_jump'
+   If `WORKING_DOT_WORD' is defined, GAS will not do broken word
+   processing (*note Broken words::.).  Otherwise, you should set
+   `md_short_jump_size' to the size of a short jump (a jump that is
+   just long enough to jump around a long jmp) and
+   `md_long_jump_size' to the size of a long jump (a jump that can go
+   anywhere in the function), You should define
+   `md_create_short_jump' to create a short jump around a long jump,
+   and define `md_create_long_jump' to create a long jump.  */
+#define WORKING_DOT_WORD
+
+/* If you define this macro, it means that `tc_gen_reloc' may return
+   multiple relocation entries for a single fixup.  In this case, the
+   return value of `tc_gen_reloc' is a pointer to a null terminated
+   array.  */
+#undef RELOC_EXPANSION_POSSIBLE
+
+/* If you define this macro, GAS will not require pseudo-ops to start with a .
+   character. */
+#define NO_PSEUDO_DOT (avr32_iarcompat)
+
+/* The IAR assembler uses $ as the location counter. Unfortunately, we
+   can't make this dependent on avr32_iarcompat... */
+#define DOLLAR_DOT
+
+/* Values passed to md_apply_fix3 don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+/* The number of bytes to put into a word in a listing.  This affects
+   the way the bytes are clumped together in the listing.  For
+   example, a value of 2 might print `1234 5678' where a value of 1
+   would print `12 34 56 78'.  The default value is 4.  */
+#define LISTING_WORD_SIZE 4
+
+/* extern const struct relax_type md_relax_table[];
+#define TC_GENERIC_RELAX_TABLE md_relax_table */
+
+/*
+  An `.lcomm' directive with no explicit alignment parameter will use
+  this macro to set P2VAR to the alignment that a request for SIZE
+  bytes will have.  The alignment is expressed as a power of two.  If
+  no alignment should take place, the macro definition should do
+  nothing.  Some targets define a `.bss' directive that is also
+  affected by this macro.  The default definition will set P2VAR to
+  the truncated power of two of sizes up to eight bytes.
+
+  We want doublewords to be word-aligned, so we're going to modify the
+  default definition a tiny bit.
+*/
+#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)	\
+  do							\
+    {							\
+      if ((SIZE) >= 4)					\
+	(P2VAR) = 2;					\
+      else if ((SIZE) >= 2)				\
+	(P2VAR) = 1;					\
+      else						\
+	(P2VAR) = 0;					\
+    }							\
+  while (0)
+
+/* When relaxing, we need to generate relocations for alignment
+   directives.  */
+#define HANDLE_ALIGN(frag) avr32_handle_align(frag)
+extern void avr32_handle_align(fragS *);
+
+/* See internals doc for explanation. Oh wait...
+   Now, can you guess where "alignment" comes from? ;-) */
+#define MAX_MEM_FOR_RS_ALIGN_CODE ((1 << alignment) - 1)
+
+/* We need to stop gas from reducing certain expressions (e.g. GOT
+   references) */
+#define tc_fix_adjustable(fix) avr32_fix_adjustable(fix)
+extern bfd_boolean avr32_fix_adjustable(struct fix *);
+
+/* The linker needs to be passed a little more information when relaxing. */
+#define TC_FORCE_RELOCATION(fix) avr32_force_reloc(fix)
+extern bfd_boolean avr32_force_reloc(struct fix *);
+
+/* I'm tired of working around all the madness in fixup_segment().
+   This hook will do basically the same things as the generic code,
+   and then it will "goto" right past it.  */
+#define TC_VALIDATE_FIX(FIX, SEG, SKIP)		\
+  do						\
+    {						\
+      avr32_process_fixup(FIX, SEG);		\
+      if (!(FIX)->fx_done)			\
+	++seg_reloc_count;			\
+      goto SKIP;				\
+    }						\
+  while (0)
+extern void avr32_process_fixup(struct fix *fixP, segT this_segment);
+
+/* Positive values of TC_FX_SIZE_SLACK allow a target to define
+   fixups that far past the end of a frag.  Having such fixups
+   is of course most most likely a bug in setting fx_size correctly.
+   A negative value disables the fixup check entirely, which is
+   appropriate for something like the Renesas / SuperH SH_COUNT
+   reloc.  */
+/* This target is buggy, and sets fix size too large.  */
+#define TC_FX_SIZE_SLACK(FIX) -1
+
+/* We don't want the gas core to make any assumptions about our way of
+   doing linkrelaxing.  */
+#define TC_LINKRELAX_FIXUP(SEG)			0
+
+/* ... but we do want it to insert lots of padding. */
+#define LINKER_RELAXING_SHRINKS_ONLY
+
+/* Better do it ourselves, really... */
+#define TC_RELAX_ALIGN(SEG, FRAG, ADDR)	avr32_relax_align(SEG, FRAG, ADDR)
+extern relax_addressT
+avr32_relax_align(segT segment, fragS *fragP, relax_addressT address);
+
+/* Use line number format that is amenable to linker relaxation.  */
+#define DWARF2_USE_FIXED_ADVANCE_PC (linkrelax != 0)
+
+/* This is called by write_object_file() just before symbols are
+   attempted converted into section symbols.  */
+#define tc_frob_file_before_adjust()	avr32_frob_file()
+extern void avr32_frob_file(void);
+
+/* If you define this macro, GAS will call it at the end of each input
+   file.  */
+#define md_cleanup() avr32_cleanup()
+extern void avr32_cleanup(void);
+
+/* There's an AVR32-specific hack in operand() which creates O_md
+   expressions when encountering HWRD or LWRD. We need to generate
+   proper relocs for them */
+/* #define md_cgen_record_fixup_exp avr32_cgen_record_fixup_exp */
+
+/* I needed to add an extra hook in gas_cgen_finish_insn() for
+   conversion of O_md* operands because md_cgen_record_fixup_exp()
+   isn't called for relaxable insns */
+/* #define md_cgen_convert_expr(exp, opinfo) avr32_cgen_convert_expr(exp, opinfo)
+   int avr32_cgen_convert_expr(expressionS *, int); */
+
+/* #define tc_gen_reloc gas_cgen_tc_gen_reloc */
+
+/* If you define this macro, it should return the position from which
+   the PC relative adjustment for a PC relative fixup should be
+   made. On many processors, the base of a PC relative instruction is
+   the next instruction, so this macro would return the length of an
+   instruction, plus the address of the PC relative fixup. The latter
+   can be calculated as fixp->fx_where + fixp->fx_frag->fr_address. */
+extern long md_pcrel_from_section (struct fix *, segT);
+#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
+
+#define LOCAL_LABEL(name) (name[0] == '.' && (name[1] == 'L'))
+#define LOCAL_LABELS_FB		1
+
+struct avr32_relaxer
+{
+  int (*estimate_size)(fragS *, segT);
+  long (*relax_frag)(segT, fragS *, long);
+  void (*convert_frag)(bfd *, segT, fragS *);
+};
+
+/* AVR32 has quite complex instruction coding, which means we need
+ * lots of information in order to do the right thing during relaxing
+ * (basically, we need to be able to reconstruct a whole new opcode if
+ * necessary) */
+#define TC_FRAG_TYPE struct avr32_frag_data
+
+struct cpool;
+
+struct avr32_frag_data
+{
+  /* TODO: Maybe add an expression object here so that we can use
+     fix_new_exp() in md_convert_frag?  We may have to decide
+     pcrel-ness in md_estimate_size_before_relax() as well...or we
+     might do it when parsing.  Doing it while parsing may fail
+     because the sub_symbol is undefined then... */
+  int pcrel;
+  int force_extended;
+  int reloc_info;
+  struct avr32_relaxer *relaxer;
+  expressionS exp;
+
+  /* Points to associated constant pool, for use by LDA and CALL in
+     non-pic mode, and when relaxing the .cpool directive */
+  struct cpool *pool;
+  unsigned int pool_entry;
+};
+
+/* We will have to initialize the fields explicitly when needed */
+#define TC_FRAG_INIT(fragP)
+
+#define md_estimate_size_before_relax(fragP, segT)			\
+  ((fragP)->tc_frag_data.relaxer->estimate_size(fragP, segT))
+#define md_relax_frag(segment, fragP, stretch)				\
+  ((fragP)->tc_frag_data.relaxer->relax_frag(segment, fragP, stretch))
+#define md_convert_frag(abfd, segment, fragP)				\
+  ((fragP)->tc_frag_data.relaxer->convert_frag(abfd, segment, fragP))
+
+#define TC_FIX_TYPE struct avr32_fix_data
+
+struct avr32_fix_data
+{
+  const struct avr32_ifield *ifield;
+  unsigned int align;
+  long min;
+  long max;
+};
+
+#define TC_INIT_FIX_DATA(fixP)			\
+  do						\
+    {						\
+      (fixP)->tc_fix_data.ifield = NULL;	\
+      (fixP)->tc_fix_data.align = 0;		\
+      (fixP)->tc_fix_data.min = 0;		\
+      (fixP)->tc_fix_data.max = 0;		\
+    }						\
+  while (0)
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -33,6 +33,7 @@ case ${cpu} in
   am33_2.0)		cpu_type=mn10300 endian=little ;;
   arm*be|arm*b)		cpu_type=arm endian=big ;;
   arm*)			cpu_type=arm endian=little ;;
+  avr32*)		cpu_type=avr32 endian=big ;;
   bfin*)		cpu_type=bfin endian=little ;;
   c4x*)			cpu_type=tic4x ;;
   cr16*)		cpu_type=cr16 endian=little ;;
@@ -129,6 +130,9 @@ case ${generic_target} in
   bfin-*elf)				fmt=elf ;;
   cr16-*-elf*)	    			fmt=elf ;;
 
+  avr32-*-linux*)			fmt=elf  em=linux bfd_gas=yes ;;
+  avr32*)				fmt=elf  bfd_gas=yes ;;
+
   cris-*-linux-* | crisv32-*-linux-*)
 					fmt=multi em=linux ;;
   cris-*-* | crisv32-*-*)		fmt=multi ;;
--- a/gas/doc/all.texi
+++ b/gas/doc/all.texi
@@ -30,6 +30,7 @@
 @set ARC
 @set ARM
 @set AVR
+@set AVR32
 @set BFIN
 @set CR16
 @set CRIS
--- a/gas/doc/as.texinfo
+++ b/gas/doc/as.texinfo
@@ -6353,6 +6353,9 @@ subject, see the hardware manufacturer's
 @ifset AVR
 * AVR-Dependent::               AVR Dependent Features
 @end ifset
+@ifset AVR32
+* AVR32-Dependent::             AVR32 Dependent Features
+@end ifset
 @ifset BFIN
 * BFIN-Dependent::		BFIN Dependent Features
 @end ifset
@@ -6476,6 +6479,10 @@ subject, see the hardware manufacturer's
 @include c-avr.texi
 @end ifset
 
+@ifset AVR32
+@include c-avr32.texi
+@end ifset
+
 @ifset BFIN
 @include c-bfin.texi
 @end ifset
--- /dev/null
+++ b/gas/doc/c-avr32.texi
@@ -0,0 +1,247 @@
+@c Copyright 2005, 2006
+@c Atmel Corporation
+@c This is part of the GAS manual.
+@c For copying conditions, see the file as.texinfo.
+
+@ifset GENERIC
+@page
+@node AVR32-Dependent
+@chapter AVR32 Dependent Features
+@end ifset
+
+@ifclear GENERIC
+@node Machine Dependencies
+@chapter AVR32 Dependent Features
+@end ifclear
+
+@cindex AVR32 support
+@menu
+* AVR32 Options::               Options
+* AVR32 Syntax::                Syntax
+* AVR32 Directives::            Directives
+* AVR32 Opcodes::               Opcodes
+@end menu
+
+@node AVR32 Options
+@section Options
+@cindex AVR32 options
+@cindex options for AVR32
+
+There are currently no AVR32-specific options.  However, the following
+options are planned:
+
+@table @code
+
+@cindex @code{--pic} command line option, AVR32
+@cindex PIC code generation for AVR32
+@item --pic
+This option specifies that the output of the assembler should be marked
+as position-independent code (PIC).  It will also ensure that
+pseudo-instructions that deal with address calculation are output as
+PIC, and that all absolute address references in the code are marked as
+such.
+
+@cindex @code{--linkrelax} command line option, AVR32
+@item --linkrelax
+This option specifies that the output of the assembler should be marked
+as linker-relaxable.  It will also ensure that all PC-relative operands
+that may change during linker relaxation get appropriate relocations.
+
+@end table
+
+
+@node AVR32 Syntax
+@section Syntax
+@menu
+* AVR32-Chars::              Special Characters
+* AVR32-Symrefs::            Symbol references
+@end menu
+
+@node AVR32-Chars
+@subsection Special Characters
+
+@cindex line comment character, AVR32
+@cindex AVR32 line comment character
+The presence of a @samp{//} on a line indicates the start of a comment
+that extends to the end of the current line.  If a @samp{#} appears as
+the first character of a line, the whole line is treated as a comment.
+
+@cindex line separator, AVR32
+@cindex statement separator, AVR32
+@cindex AVR32 line separator
+The @samp{;} character can be used instead of a newline to separate
+statements.
+
+@node AVR32-Symrefs
+@subsection Symbol references
+
+The absolute value of a symbol can be obtained by simply naming the
+symbol.  However, as AVR32 symbols have 32-bit values, most symbols have
+values that are outside the range of any instructions.
+
+Instructions that take a PC-relative offset, e.g. @code{lddpc} or
+@code{rcall}, can also reference a symbol by simply naming the symbol
+(no explicit calculations necessary).  In this case, the assembler or
+linker subtracts the address of the instruction from the symbol's value
+and inserts the result into the instruction.  Note that even though an
+overflow is less likely to happen for a relative reference than for an
+absolute reference, the assembler or linker will generate an error if
+the referenced symbol is too far away from the current location.
+
+Relative references can be used for data as well.  For example:
+
+@smallexample
+        lddpc   r0, 2f
+1:      add     r0, pc
+        ...
+        .align  2
+2:      .int    @var{some_symbol} - 1b
+@end smallexample
+
+Here, r0 will end up with the run-time address of @var{some_symbol} even
+if the program was loaded at a different address than it was linked
+(position-independent code).
+
+@subsubsection Symbol modifiers
+
+@table @code
+
+@item @code{hi(@var{symbol})}
+Evaluates to the value of the symbol shifted right 16 bits.  This will
+work even if @var{symbol} is defined in a different module.
+
+@item @code{lo(@var{symbol})}
+Evaluates to the low 16 bits of the symbol's value.  This will work even
+if @var{symbol} is defined in a different module.
+
+@item @code{@var{symbol}@@got}
+Create a GOT entry for @var{symbol} and return the offset of that entry
+relative to the GOT base.
+
+@end table
+
+
+@node AVR32 Directives
+@section Directives
+@cindex machine directives, AVR32
+@cindex AVR32 directives
+
+@table @code
+
+@cindex @code{.cpool} directive, AVR32
+@item .cpool
+This directive causes the current contents of the constant pool to be
+dumped into the current section at the current location (aligned to a
+word boundary).  @code{GAS} maintains a separate constant pool for each
+section and each sub-section.  The @code{.cpool} directive will only
+affect the constant pool of the current section and sub-section.  At the
+end of assembly, all remaining, non-empty constant pools will
+automatically be dumped.
+
+@end table
+
+
+@node AVR32 Opcodes
+@section Opcodes
+@cindex AVR32 opcodes
+@cindex opcodes for AVR32
+
+@code{@value{AS}} implements all the standard AVR32 opcodes.  It also
+implements several pseudo-opcodes, which are recommended to use wherever
+possible because they give the tool chain better freedom to generate
+optimal code.
+
+@table @code
+
+@cindex @code{LDA.W reg, symbol} pseudo op, AVR32
+@item LDA.W
+@smallexample
+        lda.w   @var{reg}, @var{symbol}
+@end smallexample
+
+This instruction will load the address of @var{symbol} into
+@var{reg}. The instruction will evaluate to one of the following,
+depending on the relative distance to the symbol, the relative distance
+to the constant pool and whether the @code{--pic} option has been
+specified. If the @code{--pic} option has not been specified, the
+alternatives are as follows:
+@smallexample
+        /* @var{symbol} evaluates to a small enough value */
+        mov     @var{reg}, @var{symbol}
+
+        /* (. - @var{symbol}) evaluates to a small enough value */
+        sub     @var{reg}, pc, . - @var{symbol}
+
+        /* Constant pool is close enough */
+        lddpc   @var{reg}, @var{cpent}
+        ...
+@var{cpent}:
+        .long   @var{symbol}
+
+        /* Otherwise (not implemented yet, probably not necessary) */
+        mov     @var{reg}, lo(@var{symbol})
+        orh     @var{reg}, hi(@var{symbol})
+@end smallexample
+
+If the @code{--pic} option has been specified, the alternatives are as
+follows:
+@smallexample
+        /* (. - @var{symbol}) evaluates to a small enough value */
+        sub     @var{reg}, pc, . - @var{symbol}
+
+        /* If @code{--linkrelax} not specified */
+        ld.w    @var{reg}, r6[@var{symbol}@@got]
+
+        /* Otherwise */
+        mov     @var{reg}, @var{symbol}@@got / 4
+        ld.w    @var{reg}, r6[@var{reg} << 2]
+@end smallexample
+
+If @var{symbol} is not defined in the same file and section as the
+@code{LDA.W} instruction, the most pessimistic alternative of the
+above is selected. The linker may convert it back into the most
+optimal alternative when the final value of all symbols is known.
+
+@cindex @code{CALL symbol} pseudo op, AVR32
+@item CALL
+@smallexample
+        call    @var{symbol}
+@end smallexample
+
+This instruction will insert code to call the subroutine identified by
+@var{symbol}. It will evaluate to one of the following, depending on
+the relative distance to the symbol as well as the @code{--linkrelax}
+and @code{--pic} command-line options.
+
+If @var{symbol} is defined in the same section and input file, and the
+distance is small enough, an @code{rcall} instruction is inserted:
+@smallexample
+        rcall   @var{symbol}
+@end smallexample
+
+Otherwise, if the @code{--pic} option has not been specified:
+@smallexample
+        mcall   @var{cpent}
+        ...
+@var{cpent}:
+        .long   @var{symbol}
+@end smallexample
+
+Finally, if nothing else fits and the @code{--pic} option has been
+specified, the assembler will indirect the call through the Global
+Offset Table:
+@smallexample
+        /* If @code{--linkrelax} not specified */
+        mcall   r6[@var{symbol}@@got]
+
+        /* If @code{--linkrelax} specified */
+        mov     lr, @var{symbol}@@got / 4
+        ld.w    lr, r6[lr << 2]
+        icall   lr
+@end smallexample
+
+The linker, after determining the final value of @var{symbol}, may
+convert any of these into more optimal alternatives. This includes
+deleting any superfluous constant pool- and GOT-entries.
+
+@end table
--- a/gas/doc/Makefile.am
+++ b/gas/doc/Makefile.am
@@ -33,6 +33,7 @@ CPU_DOCS = \
 	c-arc.texi \
 	c-arm.texi \
 	c-avr.texi \
+    c-avr32.texi \
 	c-bfin.texi \
 	c-cr16.texi \
 	c-d10v.texi \
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -47,6 +47,7 @@ CPU_TYPES = \
 	arc \
 	arm \
 	avr \
+	avr32 \
 	bfin \
 	cr16 \
 	cris \
@@ -241,6 +242,7 @@ TARGET_CPU_CFILES = \
 	config/tc-arc.c \
 	config/tc-arm.c \
 	config/tc-avr.c \
+	config/tc-avr32.c \
 	config/tc-bfin.c \
 	config/tc-cr16.c \
 	config/tc-cris.c \
@@ -296,6 +298,7 @@ TARGET_CPU_HFILES = \
 	config/tc-arc.h \
 	config/tc-arm.h \
 	config/tc-avr.h \
+	config/tc-avr32.h \
 	config/tc-bfin.h \
 	config/tc-cr16.h \
 	config/tc-cris.h \
@@ -1050,6 +1053,11 @@ DEPTC_avr_elf = $(srcdir)/config/obj-elf
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-avr.h dwarf2dbg.h \
   $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
   $(INCDIR)/opcode/avr.h
+DEPTC_avr32_elf = $(INCDIR)/symcat.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-avr32.h \
+  $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
+  $(srcdir)/../opcodes/avr32-opc.h $(srcdir)/../opcodes/avr32-asm.h
 DEPTC_bfin_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-bfin.h dwarf2dbg.h \
@@ -1487,6 +1495,11 @@ DEPOBJ_avr_elf = $(srcdir)/config/obj-el
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-avr.h dwarf2dbg.h \
   $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
   $(INCDIR)/obstack.h struc-symbol.h dwarf2dbg.h $(INCDIR)/aout/aout64.h
+DEPOBJ_avr32_elf = $(INCDIR)/symcat.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-avr32.h \
+  $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
+  struc-symbol.h dwarf2dbg.h
 DEPOBJ_bfin_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-bfin.h dwarf2dbg.h \
@@ -1858,6 +1871,9 @@ DEP_cr16_elf = $(srcdir)/config/obj-elf.
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-cr16.h dwarf2dbg.h \
   $(srcdir)/config/obj-coff.h $(INCDIR)/coff/internal.h \
   $(BFDDIR)/libcoff.h
+DEP_avr32_elf = $(srcdir)/config/obj-elf.h $(INCDIR)/symcat.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-avr32.h
 DEP_cris_aout = $(srcdir)/config/obj-aout.h $(srcdir)/config/tc-cris.h \
   $(BFDDIR)/libaout.h $(INCDIR)/bfdlink.h
 DEP_cris_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
--- /dev/null
+++ b/gas/testsuite/gas/avr32/aliases.d
@@ -0,0 +1,19 @@
+#as:
+#objdump: -dr
+#name: aliases
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <ld_nodisp>:
+   0:	19 80      [ \t]+ld\.ub r0,r12\[0x0\]
+   2:	f9 20 00 00[ \t]+ld\.sb r0,r12\[0\]
+   6:	98 80      [ \t]+ld\.uh r0,r12\[0x0\]
+   8:	98 00      [ \t]+ld\.sh r0,r12\[0x0\]
+   a:	78 00      [ \t]+ld\.w r0,r12\[0x0\]
+
+0000000c <st_nodisp>:
+   c:	b8 80      [ \t]+st\.b r12\[0x0\],r0
+   e:	b8 00      [ \t]+st\.h r12\[0x0\],r0
+  10:	99 00      [ \t]+st\.w r12\[0x0\],r0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/aliases.s
@@ -0,0 +1,14 @@
+	.text
+	.global	ld_nodisp
+ld_nodisp:
+	ld.ub	r0, r12
+	ld.sb	r0, r12
+	ld.uh	r0, r12
+	ld.sh	r0, r12
+	ld.w	r0, r12
+
+	.global st_nodisp
+st_nodisp:
+	st.b	r12, r0
+	st.h	r12, r0
+	st.w	r12, r0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/allinsn.d
@@ -0,0 +1,2987 @@
+#as:
+#objdump: -dr
+#name: allinsn
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+[0-9a-f]* <ld_d5>:
+ *[0-9a-f]*:	fe 0f 02 3e 	ld\.d lr,pc\[pc<<0x3\]
+ *[0-9a-f]*:	e0 00 02 00 	ld\.d r0,r0\[r0\]
+ *[0-9a-f]*:	ea 05 02 26 	ld\.d r6,r5\[r5<<0x2\]
+ *[0-9a-f]*:	e8 04 02 14 	ld\.d r4,r4\[r4<<0x1\]
+ *[0-9a-f]*:	fc 0e 02 1e 	ld\.d lr,lr\[lr<<0x1\]
+ *[0-9a-f]*:	e6 0d 02 2a 	ld\.d r10,r3\[sp<<0x2\]
+ *[0-9a-f]*:	f4 06 02 28 	ld\.d r8,r10\[r6<<0x2\]
+ *[0-9a-f]*:	ee 09 02 02 	ld\.d r2,r7\[r9\]
+
+[0-9a-f]* <ld_w5>:
+ *[0-9a-f]*:	fe 0f 03 0f 	ld\.w pc,pc\[pc\]
+ *[0-9a-f]*:	f8 0c 03 3c 	ld\.w r12,r12\[r12<<0x3\]
+ *[0-9a-f]*:	ea 05 03 25 	ld\.w r5,r5\[r5<<0x2\]
+ *[0-9a-f]*:	e8 04 03 14 	ld\.w r4,r4\[r4<<0x1\]
+ *[0-9a-f]*:	fc 0e 03 1e 	ld\.w lr,lr\[lr<<0x1\]
+ *[0-9a-f]*:	f2 09 03 02 	ld\.w r2,r9\[r9\]
+ *[0-9a-f]*:	e4 06 03 0b 	ld\.w r11,r2\[r6\]
+ *[0-9a-f]*:	e4 0d 03 30 	ld\.w r0,r2\[sp<<0x3\]
+
+[0-9a-f]* <ld_sh5>:
+ *[0-9a-f]*:	fe 0f 04 0f 	ld\.sh pc,pc\[pc\]
+ *[0-9a-f]*:	f8 0c 04 3c 	ld\.sh r12,r12\[r12<<0x3\]
+ *[0-9a-f]*:	ea 05 04 25 	ld\.sh r5,r5\[r5<<0x2\]
+ *[0-9a-f]*:	e8 04 04 14 	ld\.sh r4,r4\[r4<<0x1\]
+ *[0-9a-f]*:	fc 0e 04 1e 	ld\.sh lr,lr\[lr<<0x1\]
+ *[0-9a-f]*:	e0 0f 04 2b 	ld\.sh r11,r0\[pc<<0x2\]
+ *[0-9a-f]*:	fa 06 04 2a 	ld\.sh r10,sp\[r6<<0x2\]
+ *[0-9a-f]*:	e4 02 04 0c 	ld\.sh r12,r2\[r2\]
+
+[0-9a-f]* <ld_uh5>:
+ *[0-9a-f]*:	fe 0f 05 0f 	ld\.uh pc,pc\[pc\]
+ *[0-9a-f]*:	f8 0c 05 3c 	ld\.uh r12,r12\[r12<<0x3\]
+ *[0-9a-f]*:	ea 05 05 25 	ld\.uh r5,r5\[r5<<0x2\]
+ *[0-9a-f]*:	e8 04 05 14 	ld\.uh r4,r4\[r4<<0x1\]
+ *[0-9a-f]*:	fc 0e 05 1e 	ld\.uh lr,lr\[lr<<0x1\]
+ *[0-9a-f]*:	fe 0e 05 38 	ld\.uh r8,pc\[lr<<0x3\]
+ *[0-9a-f]*:	e2 0f 05 16 	ld\.uh r6,r1\[pc<<0x1\]
+ *[0-9a-f]*:	fc 0d 05 16 	ld\.uh r6,lr\[sp<<0x1\]
+
+[0-9a-f]* <ld_sb2>:
+ *[0-9a-f]*:	fe 0f 06 0f 	ld\.sb pc,pc\[pc\]
+ *[0-9a-f]*:	f8 0c 06 3c 	ld\.sb r12,r12\[r12<<0x3\]
+ *[0-9a-f]*:	ea 05 06 25 	ld\.sb r5,r5\[r5<<0x2\]
+ *[0-9a-f]*:	e8 04 06 14 	ld\.sb r4,r4\[r4<<0x1\]
+ *[0-9a-f]*:	fc 0e 06 1e 	ld\.sb lr,lr\[lr<<0x1\]
+ *[0-9a-f]*:	e2 0f 06 39 	ld\.sb r9,r1\[pc<<0x3\]
+ *[0-9a-f]*:	e6 0b 06 10 	ld\.sb r0,r3\[r11<<0x1\]
+ *[0-9a-f]*:	ea 05 06 1a 	ld\.sb r10,r5\[r5<<0x1\]
+
+[0-9a-f]* <ld_ub5>:
+ *[0-9a-f]*:	fe 0f 07 0f 	ld\.ub pc,pc\[pc\]
+ *[0-9a-f]*:	f8 0c 07 3c 	ld\.ub r12,r12\[r12<<0x3\]
+ *[0-9a-f]*:	ea 05 07 25 	ld\.ub r5,r5\[r5<<0x2\]
+ *[0-9a-f]*:	e8 04 07 14 	ld\.ub r4,r4\[r4<<0x1\]
+ *[0-9a-f]*:	fc 0e 07 1e 	ld\.ub lr,lr\[lr<<0x1\]
+ *[0-9a-f]*:	f8 07 07 36 	ld\.ub r6,r12\[r7<<0x3\]
+ *[0-9a-f]*:	ec 0c 07 02 	ld\.ub r2,r6\[r12\]
+ *[0-9a-f]*:	ee 0b 07 10 	ld\.ub r0,r7\[r11<<0x1\]
+
+[0-9a-f]* <st_d5>:
+ *[0-9a-f]*:	fe 0f 08 0e 	st\.d pc\[pc\],lr
+ *[0-9a-f]*:	f8 0c 08 3c 	st\.d r12\[r12<<0x3\],r12
+ *[0-9a-f]*:	ea 05 08 26 	st\.d r5\[r5<<0x2\],r6
+ *[0-9a-f]*:	e8 04 08 14 	st\.d r4\[r4<<0x1\],r4
+ *[0-9a-f]*:	fc 0e 08 1e 	st\.d lr\[lr<<0x1\],lr
+ *[0-9a-f]*:	e2 09 08 14 	st\.d r1\[r9<<0x1\],r4
+ *[0-9a-f]*:	f4 02 08 14 	st\.d r10\[r2<<0x1\],r4
+ *[0-9a-f]*:	f8 06 08 0e 	st\.d r12\[r6\],lr
+
+[0-9a-f]* <st_w5>:
+ *[0-9a-f]*:	fe 0f 09 0f 	st\.w pc\[pc\],pc
+ *[0-9a-f]*:	f8 0c 09 3c 	st\.w r12\[r12<<0x3\],r12
+ *[0-9a-f]*:	ea 05 09 25 	st\.w r5\[r5<<0x2\],r5
+ *[0-9a-f]*:	e8 04 09 14 	st\.w r4\[r4<<0x1\],r4
+ *[0-9a-f]*:	fc 0e 09 1e 	st\.w lr\[lr<<0x1\],lr
+ *[0-9a-f]*:	e2 0a 09 03 	st\.w r1\[r10\],r3
+ *[0-9a-f]*:	e0 0a 09 19 	st\.w r0\[r10<<0x1\],r9
+ *[0-9a-f]*:	e8 05 09 3f 	st\.w r4\[r5<<0x3\],pc
+
+[0-9a-f]* <st_h5>:
+ *[0-9a-f]*:	fe 0f 0a 0f 	st\.h pc\[pc\],pc
+ *[0-9a-f]*:	f8 0c 0a 3c 	st\.h r12\[r12<<0x3\],r12
+ *[0-9a-f]*:	ea 05 0a 25 	st\.h r5\[r5<<0x2\],r5
+ *[0-9a-f]*:	e8 04 0a 14 	st\.h r4\[r4<<0x1\],r4
+ *[0-9a-f]*:	fc 0e 0a 1e 	st\.h lr\[lr<<0x1\],lr
+ *[0-9a-f]*:	e4 09 0a 0b 	st\.h r2\[r9\],r11
+ *[0-9a-f]*:	ea 01 0a 2c 	st\.h r5\[r1<<0x2\],r12
+ *[0-9a-f]*:	fe 08 0a 23 	st\.h pc\[r8<<0x2\],r3
+
+[0-9a-f]* <st_b5>:
+ *[0-9a-f]*:	fe 0f 0b 0f 	st\.b pc\[pc\],pc
+ *[0-9a-f]*:	f8 0c 0b 3c 	st\.b r12\[r12<<0x3\],r12
+ *[0-9a-f]*:	ea 05 0b 25 	st\.b r5\[r5<<0x2\],r5
+ *[0-9a-f]*:	e8 04 0b 14 	st\.b r4\[r4<<0x1\],r4
+ *[0-9a-f]*:	fc 0e 0b 1e 	st\.b lr\[lr<<0x1\],lr
+ *[0-9a-f]*:	e2 08 0b 16 	st\.b r1\[r8<<0x1\],r6
+ *[0-9a-f]*:	fc 0e 0b 31 	st\.b lr\[lr<<0x3\],r1
+ *[0-9a-f]*:	ea 00 0b 2f 	st\.b r5\[r0<<0x2\],pc
+
+[0-9a-f]* <divs>:
+ *[0-9a-f]*:	fe 0f 0c 0f 	divs pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0c 0c 	divs r12,r12,r12
+ *[0-9a-f]*:	ea 05 0c 05 	divs r5,r5,r5
+ *[0-9a-f]*:	e8 04 0c 04 	divs r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0c 0e 	divs lr,lr,lr
+ *[0-9a-f]*:	fe 0f 0c 03 	divs r3,pc,pc
+ *[0-9a-f]*:	f8 02 0c 09 	divs r9,r12,r2
+ *[0-9a-f]*:	e8 01 0c 07 	divs r7,r4,r1
+
+[0-9a-f]* <add1>:
+ *[0-9a-f]*:	1e 0f       	add pc,pc
+ *[0-9a-f]*:	18 0c       	add r12,r12
+ *[0-9a-f]*:	0a 05       	add r5,r5
+ *[0-9a-f]*:	08 04       	add r4,r4
+ *[0-9a-f]*:	1c 0e       	add lr,lr
+ *[0-9a-f]*:	12 0c       	add r12,r9
+ *[0-9a-f]*:	06 06       	add r6,r3
+ *[0-9a-f]*:	18 0a       	add r10,r12
+
+[0-9a-f]* <sub1>:
+ *[0-9a-f]*:	1e 1f       	sub pc,pc
+ *[0-9a-f]*:	18 1c       	sub r12,r12
+ *[0-9a-f]*:	0a 15       	sub r5,r5
+ *[0-9a-f]*:	08 14       	sub r4,r4
+ *[0-9a-f]*:	1c 1e       	sub lr,lr
+ *[0-9a-f]*:	0c 1e       	sub lr,r6
+ *[0-9a-f]*:	1a 10       	sub r0,sp
+ *[0-9a-f]*:	18 16       	sub r6,r12
+
+[0-9a-f]* <rsub1>:
+ *[0-9a-f]*:	1e 2f       	rsub pc,pc
+ *[0-9a-f]*:	18 2c       	rsub r12,r12
+ *[0-9a-f]*:	0a 25       	rsub r5,r5
+ *[0-9a-f]*:	08 24       	rsub r4,r4
+ *[0-9a-f]*:	1c 2e       	rsub lr,lr
+ *[0-9a-f]*:	1a 2b       	rsub r11,sp
+ *[0-9a-f]*:	08 27       	rsub r7,r4
+ *[0-9a-f]*:	02 29       	rsub r9,r1
+
+[0-9a-f]* <cp1>:
+ *[0-9a-f]*:	1e 3f       	cp\.w pc,pc
+ *[0-9a-f]*:	18 3c       	cp\.w r12,r12
+ *[0-9a-f]*:	0a 35       	cp\.w r5,r5
+ *[0-9a-f]*:	08 34       	cp\.w r4,r4
+ *[0-9a-f]*:	1c 3e       	cp\.w lr,lr
+ *[0-9a-f]*:	04 36       	cp\.w r6,r2
+ *[0-9a-f]*:	12 30       	cp\.w r0,r9
+ *[0-9a-f]*:	1a 33       	cp\.w r3,sp
+
+[0-9a-f]* <or1>:
+ *[0-9a-f]*:	1e 4f       	or pc,pc
+ *[0-9a-f]*:	18 4c       	or r12,r12
+ *[0-9a-f]*:	0a 45       	or r5,r5
+ *[0-9a-f]*:	08 44       	or r4,r4
+ *[0-9a-f]*:	1c 4e       	or lr,lr
+ *[0-9a-f]*:	12 44       	or r4,r9
+ *[0-9a-f]*:	08 4b       	or r11,r4
+ *[0-9a-f]*:	00 44       	or r4,r0
+
+[0-9a-f]* <eor1>:
+ *[0-9a-f]*:	1e 5f       	eor pc,pc
+ *[0-9a-f]*:	18 5c       	eor r12,r12
+ *[0-9a-f]*:	0a 55       	eor r5,r5
+ *[0-9a-f]*:	08 54       	eor r4,r4
+ *[0-9a-f]*:	1c 5e       	eor lr,lr
+ *[0-9a-f]*:	16 5c       	eor r12,r11
+ *[0-9a-f]*:	02 50       	eor r0,r1
+ *[0-9a-f]*:	1e 55       	eor r5,pc
+
+[0-9a-f]* <and1>:
+ *[0-9a-f]*:	1e 6f       	and pc,pc
+ *[0-9a-f]*:	18 6c       	and r12,r12
+ *[0-9a-f]*:	0a 65       	and r5,r5
+ *[0-9a-f]*:	08 64       	and r4,r4
+ *[0-9a-f]*:	1c 6e       	and lr,lr
+ *[0-9a-f]*:	02 68       	and r8,r1
+ *[0-9a-f]*:	1a 60       	and r0,sp
+ *[0-9a-f]*:	0a 6a       	and r10,r5
+
+[0-9a-f]* <tst>:
+ *[0-9a-f]*:	1e 7f       	tst pc,pc
+ *[0-9a-f]*:	18 7c       	tst r12,r12
+ *[0-9a-f]*:	0a 75       	tst r5,r5
+ *[0-9a-f]*:	08 74       	tst r4,r4
+ *[0-9a-f]*:	1c 7e       	tst lr,lr
+ *[0-9a-f]*:	18 70       	tst r0,r12
+ *[0-9a-f]*:	0c 7a       	tst r10,r6
+ *[0-9a-f]*:	08 7d       	tst sp,r4
+
+[0-9a-f]* <andn>:
+ *[0-9a-f]*:	1e 8f       	andn pc,pc
+ *[0-9a-f]*:	18 8c       	andn r12,r12
+ *[0-9a-f]*:	0a 85       	andn r5,r5
+ *[0-9a-f]*:	08 84       	andn r4,r4
+ *[0-9a-f]*:	1c 8e       	andn lr,lr
+ *[0-9a-f]*:	18 89       	andn r9,r12
+ *[0-9a-f]*:	1a 8b       	andn r11,sp
+ *[0-9a-f]*:	0a 8c       	andn r12,r5
+
+[0-9a-f]* <mov3>:
+ *[0-9a-f]*:	1e 9f       	mov pc,pc
+ *[0-9a-f]*:	18 9c       	mov r12,r12
+ *[0-9a-f]*:	0a 95       	mov r5,r5
+ *[0-9a-f]*:	08 94       	mov r4,r4
+ *[0-9a-f]*:	1c 9e       	mov lr,lr
+ *[0-9a-f]*:	12 95       	mov r5,r9
+ *[0-9a-f]*:	16 9b       	mov r11,r11
+ *[0-9a-f]*:	1c 92       	mov r2,lr
+
+[0-9a-f]* <st_w1>:
+ *[0-9a-f]*:	1e af       	st\.w pc\+\+,pc
+ *[0-9a-f]*:	18 ac       	st\.w r12\+\+,r12
+ *[0-9a-f]*:	0a a5       	st\.w r5\+\+,r5
+ *[0-9a-f]*:	08 a4       	st\.w r4\+\+,r4
+ *[0-9a-f]*:	1c ae       	st\.w lr\+\+,lr
+ *[0-9a-f]*:	02 ab       	st\.w r1\+\+,r11
+ *[0-9a-f]*:	1a a0       	st\.w sp\+\+,r0
+ *[0-9a-f]*:	1a a1       	st\.w sp\+\+,r1
+
+[0-9a-f]* <st_h1>:
+ *[0-9a-f]*:	1e bf       	st\.h pc\+\+,pc
+ *[0-9a-f]*:	18 bc       	st\.h r12\+\+,r12
+ *[0-9a-f]*:	0a b5       	st\.h r5\+\+,r5
+ *[0-9a-f]*:	08 b4       	st\.h r4\+\+,r4
+ *[0-9a-f]*:	1c be       	st\.h lr\+\+,lr
+ *[0-9a-f]*:	18 bd       	st\.h r12\+\+,sp
+ *[0-9a-f]*:	0e be       	st\.h r7\+\+,lr
+ *[0-9a-f]*:	0e b4       	st\.h r7\+\+,r4
+
+[0-9a-f]* <st_b1>:
+ *[0-9a-f]*:	1e cf       	st\.b pc\+\+,pc
+ *[0-9a-f]*:	18 cc       	st\.b r12\+\+,r12
+ *[0-9a-f]*:	0a c5       	st\.b r5\+\+,r5
+ *[0-9a-f]*:	08 c4       	st\.b r4\+\+,r4
+ *[0-9a-f]*:	1c ce       	st\.b lr\+\+,lr
+ *[0-9a-f]*:	12 cd       	st\.b r9\+\+,sp
+ *[0-9a-f]*:	02 cd       	st\.b r1\+\+,sp
+ *[0-9a-f]*:	00 c4       	st\.b r0\+\+,r4
+
+[0-9a-f]* <st_w2>:
+ *[0-9a-f]*:	1e df       	st\.w --pc,pc
+ *[0-9a-f]*:	18 dc       	st\.w --r12,r12
+ *[0-9a-f]*:	0a d5       	st\.w --r5,r5
+ *[0-9a-f]*:	08 d4       	st\.w --r4,r4
+ *[0-9a-f]*:	1c de       	st\.w --lr,lr
+ *[0-9a-f]*:	02 d7       	st\.w --r1,r7
+ *[0-9a-f]*:	06 d9       	st\.w --r3,r9
+ *[0-9a-f]*:	0a d5       	st\.w --r5,r5
+
+[0-9a-f]* <st_h2>:
+ *[0-9a-f]*:	1e ef       	st\.h --pc,pc
+ *[0-9a-f]*:	18 ec       	st\.h --r12,r12
+ *[0-9a-f]*:	0a e5       	st\.h --r5,r5
+ *[0-9a-f]*:	08 e4       	st\.h --r4,r4
+ *[0-9a-f]*:	1c ee       	st\.h --lr,lr
+ *[0-9a-f]*:	0a e7       	st\.h --r5,r7
+ *[0-9a-f]*:	10 e8       	st\.h --r8,r8
+ *[0-9a-f]*:	0e e2       	st\.h --r7,r2
+
+[0-9a-f]* <st_b2>:
+ *[0-9a-f]*:	1e ff       	st\.b --pc,pc
+ *[0-9a-f]*:	18 fc       	st\.b --r12,r12
+ *[0-9a-f]*:	0a f5       	st\.b --r5,r5
+ *[0-9a-f]*:	08 f4       	st\.b --r4,r4
+ *[0-9a-f]*:	1c fe       	st\.b --lr,lr
+ *[0-9a-f]*:	1a fd       	st\.b --sp,sp
+ *[0-9a-f]*:	1a fb       	st\.b --sp,r11
+ *[0-9a-f]*:	08 f5       	st\.b --r4,r5
+
+[0-9a-f]* <ld_w1>:
+ *[0-9a-f]*:	1f 0f       	ld\.w pc,pc\+\+
+ *[0-9a-f]*:	19 0c       	ld\.w r12,r12\+\+
+ *[0-9a-f]*:	0b 05       	ld\.w r5,r5\+\+
+ *[0-9a-f]*:	09 04       	ld\.w r4,r4\+\+
+ *[0-9a-f]*:	1d 0e       	ld\.w lr,lr\+\+
+ *[0-9a-f]*:	0f 03       	ld\.w r3,r7\+\+
+ *[0-9a-f]*:	1d 03       	ld\.w r3,lr\+\+
+ *[0-9a-f]*:	0b 0c       	ld\.w r12,r5\+\+
+
+[0-9a-f]* <ld_sh1>:
+ *[0-9a-f]*:	1f 1f       	ld\.sh pc,pc\+\+
+ *[0-9a-f]*:	19 1c       	ld\.sh r12,r12\+\+
+ *[0-9a-f]*:	0b 15       	ld\.sh r5,r5\+\+
+ *[0-9a-f]*:	09 14       	ld\.sh r4,r4\+\+
+ *[0-9a-f]*:	1d 1e       	ld\.sh lr,lr\+\+
+ *[0-9a-f]*:	05 1b       	ld\.sh r11,r2\+\+
+ *[0-9a-f]*:	11 12       	ld\.sh r2,r8\+\+
+ *[0-9a-f]*:	0d 17       	ld\.sh r7,r6\+\+
+
+[0-9a-f]* <ld_uh1>:
+ *[0-9a-f]*:	1f 2f       	ld\.uh pc,pc\+\+
+ *[0-9a-f]*:	19 2c       	ld\.uh r12,r12\+\+
+ *[0-9a-f]*:	0b 25       	ld\.uh r5,r5\+\+
+ *[0-9a-f]*:	09 24       	ld\.uh r4,r4\+\+
+ *[0-9a-f]*:	1d 2e       	ld\.uh lr,lr\+\+
+ *[0-9a-f]*:	0f 26       	ld\.uh r6,r7\+\+
+ *[0-9a-f]*:	17 2a       	ld\.uh r10,r11\+\+
+ *[0-9a-f]*:	09 2e       	ld\.uh lr,r4\+\+
+
+[0-9a-f]* <ld_ub1>:
+ *[0-9a-f]*:	1f 3f       	ld\.ub pc,pc\+\+
+ *[0-9a-f]*:	19 3c       	ld\.ub r12,r12\+\+
+ *[0-9a-f]*:	0b 35       	ld\.ub r5,r5\+\+
+ *[0-9a-f]*:	09 34       	ld\.ub r4,r4\+\+
+ *[0-9a-f]*:	1d 3e       	ld\.ub lr,lr\+\+
+ *[0-9a-f]*:	1d 38       	ld\.ub r8,lr\+\+
+ *[0-9a-f]*:	19 3c       	ld\.ub r12,r12\+\+
+ *[0-9a-f]*:	15 3b       	ld\.ub r11,r10\+\+
+
+[0-9a-f]* <ld_w2>:
+ *[0-9a-f]*:	1f 4f       	ld\.w pc,--pc
+ *[0-9a-f]*:	19 4c       	ld\.w r12,--r12
+ *[0-9a-f]*:	0b 45       	ld\.w r5,--r5
+ *[0-9a-f]*:	09 44       	ld\.w r4,--r4
+ *[0-9a-f]*:	1d 4e       	ld\.w lr,--lr
+ *[0-9a-f]*:	1d 4a       	ld\.w r10,--lr
+ *[0-9a-f]*:	13 4c       	ld\.w r12,--r9
+ *[0-9a-f]*:	0b 46       	ld\.w r6,--r5
+
+[0-9a-f]* <ld_sh2>:
+ *[0-9a-f]*:	1f 5f       	ld\.sh pc,--pc
+ *[0-9a-f]*:	19 5c       	ld\.sh r12,--r12
+ *[0-9a-f]*:	0b 55       	ld\.sh r5,--r5
+ *[0-9a-f]*:	09 54       	ld\.sh r4,--r4
+ *[0-9a-f]*:	1d 5e       	ld\.sh lr,--lr
+ *[0-9a-f]*:	15 5f       	ld\.sh pc,--r10
+ *[0-9a-f]*:	07 56       	ld\.sh r6,--r3
+ *[0-9a-f]*:	0d 54       	ld\.sh r4,--r6
+
+[0-9a-f]* <ld_uh2>:
+ *[0-9a-f]*:	1f 6f       	ld\.uh pc,--pc
+ *[0-9a-f]*:	19 6c       	ld\.uh r12,--r12
+ *[0-9a-f]*:	0b 65       	ld\.uh r5,--r5
+ *[0-9a-f]*:	09 64       	ld\.uh r4,--r4
+ *[0-9a-f]*:	1d 6e       	ld\.uh lr,--lr
+ *[0-9a-f]*:	05 63       	ld\.uh r3,--r2
+ *[0-9a-f]*:	01 61       	ld\.uh r1,--r0
+ *[0-9a-f]*:	13 62       	ld\.uh r2,--r9
+
+[0-9a-f]* <ld_ub2>:
+ *[0-9a-f]*:	1f 7f       	ld\.ub pc,--pc
+ *[0-9a-f]*:	19 7c       	ld\.ub r12,--r12
+ *[0-9a-f]*:	0b 75       	ld\.ub r5,--r5
+ *[0-9a-f]*:	09 74       	ld\.ub r4,--r4
+ *[0-9a-f]*:	1d 7e       	ld\.ub lr,--lr
+ *[0-9a-f]*:	03 71       	ld\.ub r1,--r1
+ *[0-9a-f]*:	0d 70       	ld\.ub r0,--r6
+ *[0-9a-f]*:	0f 72       	ld\.ub r2,--r7
+
+[0-9a-f]* <ld_ub3>:
+ *[0-9a-f]*:	1f 8f       	ld\.ub pc,pc\[0x0\]
+ *[0-9a-f]*:	19 fc       	ld\.ub r12,r12\[0x7\]
+ *[0-9a-f]*:	0b c5       	ld\.ub r5,r5\[0x4\]
+ *[0-9a-f]*:	09 b4       	ld\.ub r4,r4\[0x3\]
+ *[0-9a-f]*:	1d 9e       	ld\.ub lr,lr\[0x1\]
+ *[0-9a-f]*:	13 e6       	ld\.ub r6,r9\[0x6\]
+ *[0-9a-f]*:	1d c2       	ld\.ub r2,lr\[0x4\]
+ *[0-9a-f]*:	11 81       	ld\.ub r1,r8\[0x0\]
+
+[0-9a-f]* <sub3_sp>:
+ *[0-9a-f]*:	20 0d       	sub sp,0
+ *[0-9a-f]*:	2f fd       	sub sp,-4
+ *[0-9a-f]*:	28 0d       	sub sp,-512
+ *[0-9a-f]*:	27 fd       	sub sp,508
+ *[0-9a-f]*:	20 1d       	sub sp,4
+ *[0-9a-f]*:	20 bd       	sub sp,44
+ *[0-9a-f]*:	20 2d       	sub sp,8
+ *[0-9a-f]*:	25 7d       	sub sp,348
+
+[0-9a-f]* <sub3>:
+ *[0-9a-f]*:	20 0f       	sub pc,0
+ *[0-9a-f]*:	2f fc       	sub r12,-1
+ *[0-9a-f]*:	28 05       	sub r5,-128
+ *[0-9a-f]*:	27 f4       	sub r4,127
+ *[0-9a-f]*:	20 1e       	sub lr,1
+ *[0-9a-f]*:	2d 76       	sub r6,-41
+ *[0-9a-f]*:	22 54       	sub r4,37
+ *[0-9a-f]*:	23 8c       	sub r12,56
+
+[0-9a-f]* <mov1>:
+ *[0-9a-f]*:	30 0f       	mov pc,0
+ *[0-9a-f]*:	3f fc       	mov r12,-1
+ *[0-9a-f]*:	38 05       	mov r5,-128
+ *[0-9a-f]*:	37 f4       	mov r4,127
+ *[0-9a-f]*:	30 1e       	mov lr,1
+ *[0-9a-f]*:	30 ef       	mov pc,14
+ *[0-9a-f]*:	39 c6       	mov r6,-100
+ *[0-9a-f]*:	38 6e       	mov lr,-122
+
+[0-9a-f]* <lddsp>:
+ *[0-9a-f]*:	40 0f       	lddsp pc,sp\[0x0\]
+ *[0-9a-f]*:	47 fc       	lddsp r12,sp\[0x1fc\]
+ *[0-9a-f]*:	44 05       	lddsp r5,sp\[0x100\]
+ *[0-9a-f]*:	43 f4       	lddsp r4,sp\[0xfc\]
+ *[0-9a-f]*:	40 1e       	lddsp lr,sp\[0x4\]
+ *[0-9a-f]*:	44 0e       	lddsp lr,sp\[0x100\]
+ *[0-9a-f]*:	40 5c       	lddsp r12,sp\[0x14\]
+ *[0-9a-f]*:	47 69       	lddsp r9,sp\[0x1d8\]
+
+[0-9a-f]* <lddpc>:
+ *[0-9a-f]*:	48 0f       	lddpc pc,[0-9a-f]* <.*>
+ *[0-9a-f]*:	4f f0       	lddpc r0,[0-9a-f]* <.*>
+ *[0-9a-f]*:	4c 08       	lddpc r8,[0-9a-f]* <.*>
+ *[0-9a-f]*:	4b f7       	lddpc r7,[0-9a-f]* <.*>
+ *[0-9a-f]*:	48 1e       	lddpc lr,[0-9a-f]* <.*>
+ *[0-9a-f]*:	4f 6d       	lddpc sp,[0-9a-f]* <.*>
+ *[0-9a-f]*:	49 e6       	lddpc r6,[0-9a-f]* <.*>
+ *[0-9a-f]*:	48 7b       	lddpc r11,[0-9a-f]* <.*>
+
+[0-9a-f]* <stdsp>:
+ *[0-9a-f]*:	50 0f       	stdsp sp\[0x0\],pc
+ *[0-9a-f]*:	57 fc       	stdsp sp\[0x1fc\],r12
+ *[0-9a-f]*:	54 05       	stdsp sp\[0x100\],r5
+ *[0-9a-f]*:	53 f4       	stdsp sp\[0xfc\],r4
+ *[0-9a-f]*:	50 1e       	stdsp sp\[0x4\],lr
+ *[0-9a-f]*:	54 cf       	stdsp sp\[0x130\],pc
+ *[0-9a-f]*:	54 00       	stdsp sp\[0x100\],r0
+ *[0-9a-f]*:	55 45       	stdsp sp\[0x150\],r5
+
+[0-9a-f]* <cp2>:
+ *[0-9a-f]*:	58 0f       	cp.w pc,0
+ *[0-9a-f]*:	5b fc       	cp.w r12,-1
+ *[0-9a-f]*:	5a 05       	cp.w r5,-32
+ *[0-9a-f]*:	59 f4       	cp.w r4,31
+ *[0-9a-f]*:	58 1e       	cp.w lr,1
+ *[0-9a-f]*:	58 38       	cp.w r8,3
+ *[0-9a-f]*:	59 0e       	cp.w lr,16
+ *[0-9a-f]*:	5a 67       	cp.w r7,-26
+
+[0-9a-f]* <acr>:
+ *[0-9a-f]*:	5c 0f       	acr pc
+ *[0-9a-f]*:	5c 0c       	acr r12
+ *[0-9a-f]*:	5c 05       	acr r5
+ *[0-9a-f]*:	5c 04       	acr r4
+ *[0-9a-f]*:	5c 0e       	acr lr
+ *[0-9a-f]*:	5c 02       	acr r2
+ *[0-9a-f]*:	5c 0c       	acr r12
+ *[0-9a-f]*:	5c 0f       	acr pc
+
+[0-9a-f]* <scr>:
+ *[0-9a-f]*:	5c 1f       	scr pc
+ *[0-9a-f]*:	5c 1c       	scr r12
+ *[0-9a-f]*:	5c 15       	scr r5
+ *[0-9a-f]*:	5c 14       	scr r4
+ *[0-9a-f]*:	5c 1e       	scr lr
+ *[0-9a-f]*:	5c 1f       	scr pc
+ *[0-9a-f]*:	5c 16       	scr r6
+ *[0-9a-f]*:	5c 11       	scr r1
+
+[0-9a-f]* <cpc0>:
+ *[0-9a-f]*:	5c 2f       	cpc pc
+ *[0-9a-f]*:	5c 2c       	cpc r12
+ *[0-9a-f]*:	5c 25       	cpc r5
+ *[0-9a-f]*:	5c 24       	cpc r4
+ *[0-9a-f]*:	5c 2e       	cpc lr
+ *[0-9a-f]*:	5c 2f       	cpc pc
+ *[0-9a-f]*:	5c 24       	cpc r4
+ *[0-9a-f]*:	5c 29       	cpc r9
+
+[0-9a-f]* <neg>:
+ *[0-9a-f]*:	5c 3f       	neg pc
+ *[0-9a-f]*:	5c 3c       	neg r12
+ *[0-9a-f]*:	5c 35       	neg r5
+ *[0-9a-f]*:	5c 34       	neg r4
+ *[0-9a-f]*:	5c 3e       	neg lr
+ *[0-9a-f]*:	5c 37       	neg r7
+ *[0-9a-f]*:	5c 31       	neg r1
+ *[0-9a-f]*:	5c 39       	neg r9
+
+[0-9a-f]* <abs>:
+ *[0-9a-f]*:	5c 4f       	abs pc
+ *[0-9a-f]*:	5c 4c       	abs r12
+ *[0-9a-f]*:	5c 45       	abs r5
+ *[0-9a-f]*:	5c 44       	abs r4
+ *[0-9a-f]*:	5c 4e       	abs lr
+ *[0-9a-f]*:	5c 46       	abs r6
+ *[0-9a-f]*:	5c 46       	abs r6
+ *[0-9a-f]*:	5c 44       	abs r4
+
+[0-9a-f]* <castu_b>:
+ *[0-9a-f]*:	5c 5f       	castu\.b pc
+ *[0-9a-f]*:	5c 5c       	castu\.b r12
+ *[0-9a-f]*:	5c 55       	castu\.b r5
+ *[0-9a-f]*:	5c 54       	castu\.b r4
+ *[0-9a-f]*:	5c 5e       	castu\.b lr
+ *[0-9a-f]*:	5c 57       	castu\.b r7
+ *[0-9a-f]*:	5c 5d       	castu\.b sp
+ *[0-9a-f]*:	5c 59       	castu\.b r9
+
+[0-9a-f]* <casts_b>:
+ *[0-9a-f]*:	5c 6f       	casts\.b pc
+ *[0-9a-f]*:	5c 6c       	casts\.b r12
+ *[0-9a-f]*:	5c 65       	casts\.b r5
+ *[0-9a-f]*:	5c 64       	casts\.b r4
+ *[0-9a-f]*:	5c 6e       	casts\.b lr
+ *[0-9a-f]*:	5c 6b       	casts\.b r11
+ *[0-9a-f]*:	5c 61       	casts\.b r1
+ *[0-9a-f]*:	5c 6a       	casts\.b r10
+
+[0-9a-f]* <castu_h>:
+ *[0-9a-f]*:	5c 7f       	castu\.h pc
+ *[0-9a-f]*:	5c 7c       	castu\.h r12
+ *[0-9a-f]*:	5c 75       	castu\.h r5
+ *[0-9a-f]*:	5c 74       	castu\.h r4
+ *[0-9a-f]*:	5c 7e       	castu\.h lr
+ *[0-9a-f]*:	5c 7a       	castu\.h r10
+ *[0-9a-f]*:	5c 7b       	castu\.h r11
+ *[0-9a-f]*:	5c 71       	castu\.h r1
+
+[0-9a-f]* <casts_h>:
+ *[0-9a-f]*:	5c 8f       	casts\.h pc
+ *[0-9a-f]*:	5c 8c       	casts\.h r12
+ *[0-9a-f]*:	5c 85       	casts\.h r5
+ *[0-9a-f]*:	5c 84       	casts\.h r4
+ *[0-9a-f]*:	5c 8e       	casts\.h lr
+ *[0-9a-f]*:	5c 80       	casts\.h r0
+ *[0-9a-f]*:	5c 85       	casts\.h r5
+ *[0-9a-f]*:	5c 89       	casts\.h r9
+
+[0-9a-f]* <brev>:
+ *[0-9a-f]*:	5c 9f       	brev pc
+ *[0-9a-f]*:	5c 9c       	brev r12
+ *[0-9a-f]*:	5c 95       	brev r5
+ *[0-9a-f]*:	5c 94       	brev r4
+ *[0-9a-f]*:	5c 9e       	brev lr
+ *[0-9a-f]*:	5c 95       	brev r5
+ *[0-9a-f]*:	5c 9a       	brev r10
+ *[0-9a-f]*:	5c 98       	brev r8
+
+[0-9a-f]* <swap_h>:
+ *[0-9a-f]*:	5c af       	swap\.h pc
+ *[0-9a-f]*:	5c ac       	swap\.h r12
+ *[0-9a-f]*:	5c a5       	swap\.h r5
+ *[0-9a-f]*:	5c a4       	swap\.h r4
+ *[0-9a-f]*:	5c ae       	swap\.h lr
+ *[0-9a-f]*:	5c a7       	swap\.h r7
+ *[0-9a-f]*:	5c a0       	swap\.h r0
+ *[0-9a-f]*:	5c a8       	swap\.h r8
+
+[0-9a-f]* <swap_b>:
+ *[0-9a-f]*:	5c bf       	swap\.b pc
+ *[0-9a-f]*:	5c bc       	swap\.b r12
+ *[0-9a-f]*:	5c b5       	swap\.b r5
+ *[0-9a-f]*:	5c b4       	swap\.b r4
+ *[0-9a-f]*:	5c be       	swap\.b lr
+ *[0-9a-f]*:	5c ba       	swap\.b r10
+ *[0-9a-f]*:	5c bc       	swap\.b r12
+ *[0-9a-f]*:	5c b1       	swap\.b r1
+
+[0-9a-f]* <swap_bh>:
+ *[0-9a-f]*:	5c cf       	swap\.bh pc
+ *[0-9a-f]*:	5c cc       	swap\.bh r12
+ *[0-9a-f]*:	5c c5       	swap\.bh r5
+ *[0-9a-f]*:	5c c4       	swap\.bh r4
+ *[0-9a-f]*:	5c ce       	swap\.bh lr
+ *[0-9a-f]*:	5c c9       	swap\.bh r9
+ *[0-9a-f]*:	5c c4       	swap\.bh r4
+ *[0-9a-f]*:	5c c1       	swap\.bh r1
+
+[0-9a-f]* <One_s_compliment>:
+ *[0-9a-f]*:	5c df       	com pc
+ *[0-9a-f]*:	5c dc       	com r12
+ *[0-9a-f]*:	5c d5       	com r5
+ *[0-9a-f]*:	5c d4       	com r4
+ *[0-9a-f]*:	5c de       	com lr
+ *[0-9a-f]*:	5c d2       	com r2
+ *[0-9a-f]*:	5c d2       	com r2
+ *[0-9a-f]*:	5c d7       	com r7
+
+[0-9a-f]* <tnbz>:
+ *[0-9a-f]*:	5c ef       	tnbz pc
+ *[0-9a-f]*:	5c ec       	tnbz r12
+ *[0-9a-f]*:	5c e5       	tnbz r5
+ *[0-9a-f]*:	5c e4       	tnbz r4
+ *[0-9a-f]*:	5c ee       	tnbz lr
+ *[0-9a-f]*:	5c e8       	tnbz r8
+ *[0-9a-f]*:	5c ec       	tnbz r12
+ *[0-9a-f]*:	5c ef       	tnbz pc
+
+[0-9a-f]* <rol>:
+ *[0-9a-f]*:	5c ff       	rol pc
+ *[0-9a-f]*:	5c fc       	rol r12
+ *[0-9a-f]*:	5c f5       	rol r5
+ *[0-9a-f]*:	5c f4       	rol r4
+ *[0-9a-f]*:	5c fe       	rol lr
+ *[0-9a-f]*:	5c fa       	rol r10
+ *[0-9a-f]*:	5c f9       	rol r9
+ *[0-9a-f]*:	5c f5       	rol r5
+
+[0-9a-f]* <ror>:
+ *[0-9a-f]*:	5d 0f       	ror pc
+ *[0-9a-f]*:	5d 0c       	ror r12
+ *[0-9a-f]*:	5d 05       	ror r5
+ *[0-9a-f]*:	5d 04       	ror r4
+ *[0-9a-f]*:	5d 0e       	ror lr
+ *[0-9a-f]*:	5d 08       	ror r8
+ *[0-9a-f]*:	5d 04       	ror r4
+ *[0-9a-f]*:	5d 07       	ror r7
+
+[0-9a-f]* <icall>:
+ *[0-9a-f]*:	5d 1f       	icall pc
+ *[0-9a-f]*:	5d 1c       	icall r12
+ *[0-9a-f]*:	5d 15       	icall r5
+ *[0-9a-f]*:	5d 14       	icall r4
+ *[0-9a-f]*:	5d 1e       	icall lr
+ *[0-9a-f]*:	5d 13       	icall r3
+ *[0-9a-f]*:	5d 11       	icall r1
+ *[0-9a-f]*:	5d 13       	icall r3
+
+[0-9a-f]* <mustr>:
+ *[0-9a-f]*:	5d 2f       	mustr pc
+ *[0-9a-f]*:	5d 2c       	mustr r12
+ *[0-9a-f]*:	5d 25       	mustr r5
+ *[0-9a-f]*:	5d 24       	mustr r4
+ *[0-9a-f]*:	5d 2e       	mustr lr
+ *[0-9a-f]*:	5d 21       	mustr r1
+ *[0-9a-f]*:	5d 24       	mustr r4
+ *[0-9a-f]*:	5d 2c       	mustr r12
+
+[0-9a-f]* <musfr>:
+ *[0-9a-f]*:	5d 3f       	musfr pc
+ *[0-9a-f]*:	5d 3c       	musfr r12
+ *[0-9a-f]*:	5d 35       	musfr r5
+ *[0-9a-f]*:	5d 34       	musfr r4
+ *[0-9a-f]*:	5d 3e       	musfr lr
+ *[0-9a-f]*:	5d 3b       	musfr r11
+ *[0-9a-f]*:	5d 3c       	musfr r12
+ *[0-9a-f]*:	5d 32       	musfr r2
+
+[0-9a-f]* <ret_cond>:
+ *[0-9a-f]*:	5e 0f       	reteq 1
+ *[0-9a-f]*:	5e fc       	retal r12
+ *[0-9a-f]*:	5e 85       	retls r5
+ *[0-9a-f]*:	5e 74       	retpl r4
+ *[0-9a-f]*:	5e 1e       	retne -1
+ *[0-9a-f]*:	5e 90       	retgt r0
+ *[0-9a-f]*:	5e 9c       	retgt r12
+ *[0-9a-f]*:	5e 4a       	retge r10
+
+[0-9a-f]* <sr_cond>:
+ *[0-9a-f]*:	5f 0f       	sreq pc
+ *[0-9a-f]*:	5f fc       	sral r12
+ *[0-9a-f]*:	5f 85       	srls r5
+ *[0-9a-f]*:	5f 74       	srpl r4
+ *[0-9a-f]*:	5f 1e       	srne lr
+ *[0-9a-f]*:	5f 50       	srlt r0
+ *[0-9a-f]*:	5f fd       	sral sp
+ *[0-9a-f]*:	5f 49       	srge r9
+
+[0-9a-f]* <ld_w3>:
+ *[0-9a-f]*:	7e 0f       	ld\.w pc,pc\[0x0\]
+ *[0-9a-f]*:	79 fc       	ld\.w r12,r12\[0x7c\]
+ *[0-9a-f]*:	6b 05       	ld\.w r5,r5\[0x40\]
+ *[0-9a-f]*:	68 f4       	ld\.w r4,r4\[0x3c\]
+ *[0-9a-f]*:	7c 1e       	ld\.w lr,lr\[0x4\]
+ *[0-9a-f]*:	64 dd       	ld\.w sp,r2\[0x34\]
+ *[0-9a-f]*:	62 29       	ld\.w r9,r1\[0x8\]
+ *[0-9a-f]*:	7a f5       	ld\.w r5,sp\[0x3c\]
+
+[0-9a-f]* <ld_sh3>:
+ *[0-9a-f]*:	9e 0f       	ld\.sh pc,pc\[0x0\]
+ *[0-9a-f]*:	98 7c       	ld\.sh r12,r12\[0xe\]
+ *[0-9a-f]*:	8a 45       	ld\.sh r5,r5\[0x8\]
+ *[0-9a-f]*:	88 34       	ld\.sh r4,r4\[0x6\]
+ *[0-9a-f]*:	9c 1e       	ld\.sh lr,lr\[0x2\]
+ *[0-9a-f]*:	84 44       	ld\.sh r4,r2\[0x8\]
+ *[0-9a-f]*:	9c 5d       	ld\.sh sp,lr\[0xa\]
+ *[0-9a-f]*:	96 12       	ld\.sh r2,r11\[0x2\]
+
+[0-9a-f]* <ld_uh3>:
+ *[0-9a-f]*:	9e 8f       	ld\.uh pc,pc\[0x0\]
+ *[0-9a-f]*:	98 fc       	ld\.uh r12,r12\[0xe\]
+ *[0-9a-f]*:	8a c5       	ld\.uh r5,r5\[0x8\]
+ *[0-9a-f]*:	88 b4       	ld\.uh r4,r4\[0x6\]
+ *[0-9a-f]*:	9c 9e       	ld\.uh lr,lr\[0x2\]
+ *[0-9a-f]*:	80 da       	ld\.uh r10,r0\[0xa\]
+ *[0-9a-f]*:	96 c8       	ld\.uh r8,r11\[0x8\]
+ *[0-9a-f]*:	84 ea       	ld\.uh r10,r2\[0xc\]
+
+[0-9a-f]* <st_w3>:
+ *[0-9a-f]*:	9f 0f       	st\.w pc\[0x0\],pc
+ *[0-9a-f]*:	99 fc       	st\.w r12\[0x3c\],r12
+ *[0-9a-f]*:	8b 85       	st\.w r5\[0x20\],r5
+ *[0-9a-f]*:	89 74       	st\.w r4\[0x1c\],r4
+ *[0-9a-f]*:	9d 1e       	st\.w lr\[0x4\],lr
+ *[0-9a-f]*:	8f bb       	st\.w r7\[0x2c\],r11
+ *[0-9a-f]*:	85 66       	st\.w r2\[0x18\],r6
+ *[0-9a-f]*:	89 39       	st\.w r4\[0xc\],r9
+
+[0-9a-f]* <st_h3>:
+ *[0-9a-f]*:	be 0f       	st\.h pc\[0x0\],pc
+ *[0-9a-f]*:	b8 7c       	st\.h r12\[0xe\],r12
+ *[0-9a-f]*:	aa 45       	st\.h r5\[0x8\],r5
+ *[0-9a-f]*:	a8 34       	st\.h r4\[0x6\],r4
+ *[0-9a-f]*:	bc 1e       	st\.h lr\[0x2\],lr
+ *[0-9a-f]*:	bc 5c       	st\.h lr\[0xa\],r12
+ *[0-9a-f]*:	ac 20       	st\.h r6\[0x4\],r0
+ *[0-9a-f]*:	aa 6d       	st\.h r5\[0xc\],sp
+
+[0-9a-f]* <st_b3>:
+ *[0-9a-f]*:	be 8f       	st\.b pc\[0x0\],pc
+ *[0-9a-f]*:	b8 fc       	st\.b r12\[0x7\],r12
+ *[0-9a-f]*:	aa c5       	st\.b r5\[0x4\],r5
+ *[0-9a-f]*:	a8 b4       	st\.b r4\[0x3\],r4
+ *[0-9a-f]*:	bc 9e       	st\.b lr\[0x1\],lr
+ *[0-9a-f]*:	b8 e9       	st\.b r12\[0x6\],r9
+ *[0-9a-f]*:	a4 be       	st\.b r2\[0x3\],lr
+ *[0-9a-f]*:	a2 bb       	st\.b r1\[0x3\],r11
+
+[0-9a-f]* <ldd>:
+ *[0-9a-f]*:	bf 00       	ld\.d r0,pc
+ *[0-9a-f]*:	b9 0e       	ld\.d lr,r12
+ *[0-9a-f]*:	ab 08       	ld\.d r8,r5
+ *[0-9a-f]*:	a9 06       	ld\.d r6,r4
+ *[0-9a-f]*:	bd 02       	ld\.d r2,lr
+ *[0-9a-f]*:	af 0e       	ld\.d lr,r7
+ *[0-9a-f]*:	a9 04       	ld\.d r4,r4
+ *[0-9a-f]*:	bf 0e       	ld\.d lr,pc
+
+[0-9a-f]* <ldd_postinc>:
+ *[0-9a-f]*:	bf 01       	ld\.d r0,pc\+\+
+ *[0-9a-f]*:	b9 0f       	ld\.d lr,r12\+\+
+ *[0-9a-f]*:	ab 09       	ld\.d r8,r5\+\+
+ *[0-9a-f]*:	a9 07       	ld\.d r6,r4\+\+
+ *[0-9a-f]*:	bd 03       	ld\.d r2,lr\+\+
+ *[0-9a-f]*:	ab 0f       	ld\.d lr,r5\+\+
+ *[0-9a-f]*:	b7 0d       	ld\.d r12,r11\+\+
+ *[0-9a-f]*:	b9 03       	ld\.d r2,r12\+\+
+
+[0-9a-f]* <ldd_predec>:
+ *[0-9a-f]*:	bf 10       	ld\.d r0,--pc
+ *[0-9a-f]*:	b9 1e       	ld\.d lr,--r12
+ *[0-9a-f]*:	ab 18       	ld\.d r8,--r5
+ *[0-9a-f]*:	a9 16       	ld\.d r6,--r4
+ *[0-9a-f]*:	bd 12       	ld\.d r2,--lr
+ *[0-9a-f]*:	a1 18       	ld\.d r8,--r0
+ *[0-9a-f]*:	bf 1a       	ld\.d r10,--pc
+ *[0-9a-f]*:	a9 12       	ld\.d r2,--r4
+
+[0-9a-f]* <std>:
+ *[0-9a-f]*:	bf 11       	st\.d pc,r0
+ *[0-9a-f]*:	b9 1f       	st\.d r12,lr
+ *[0-9a-f]*:	ab 19       	st\.d r5,r8
+ *[0-9a-f]*:	a9 17       	st\.d r4,r6
+ *[0-9a-f]*:	bd 13       	st\.d lr,r2
+ *[0-9a-f]*:	a1 1d       	st\.d r0,r12
+ *[0-9a-f]*:	bb 15       	st\.d sp,r4
+ *[0-9a-f]*:	b9 1d       	st\.d r12,r12
+
+[0-9a-f]* <std_postinc>:
+ *[0-9a-f]*:	bf 20       	st\.d pc\+\+,r0
+ *[0-9a-f]*:	b9 2e       	st\.d r12\+\+,lr
+ *[0-9a-f]*:	ab 28       	st\.d r5\+\+,r8
+ *[0-9a-f]*:	a9 26       	st\.d r4\+\+,r6
+ *[0-9a-f]*:	bd 22       	st\.d lr\+\+,r2
+ *[0-9a-f]*:	bb 26       	st\.d sp\+\+,r6
+ *[0-9a-f]*:	b5 26       	st\.d r10\+\+,r6
+ *[0-9a-f]*:	af 22       	st\.d r7\+\+,r2
+
+[0-9a-f]* <std_predec>:
+ *[0-9a-f]*:	bf 21       	st\.d --pc,r0
+ *[0-9a-f]*:	b9 2f       	st\.d --r12,lr
+ *[0-9a-f]*:	ab 29       	st\.d --r5,r8
+ *[0-9a-f]*:	a9 27       	st\.d --r4,r6
+ *[0-9a-f]*:	bd 23       	st\.d --lr,r2
+ *[0-9a-f]*:	a7 27       	st\.d --r3,r6
+ *[0-9a-f]*:	bd 23       	st\.d --lr,r2
+ *[0-9a-f]*:	a1 25       	st\.d --r0,r4
+
+[0-9a-f]* <mul>:
+ *[0-9a-f]*:	bf 3f       	mul pc,pc
+ *[0-9a-f]*:	b9 3c       	mul r12,r12
+ *[0-9a-f]*:	ab 35       	mul r5,r5
+ *[0-9a-f]*:	a9 34       	mul r4,r4
+ *[0-9a-f]*:	bd 3e       	mul lr,lr
+ *[0-9a-f]*:	bd 3a       	mul r10,lr
+ *[0-9a-f]*:	b1 30       	mul r0,r8
+ *[0-9a-f]*:	ab 38       	mul r8,r5
+
+[0-9a-f]* <asr_imm5>:
+ *[0-9a-f]*:	a1 4f       	asr pc,0x0
+ *[0-9a-f]*:	bf 5c       	asr r12,0x1f
+ *[0-9a-f]*:	b1 45       	asr r5,0x10
+ *[0-9a-f]*:	af 54       	asr r4,0xf
+ *[0-9a-f]*:	a1 5e       	asr lr,0x1
+ *[0-9a-f]*:	b7 56       	asr r6,0x17
+ *[0-9a-f]*:	b3 46       	asr r6,0x12
+ *[0-9a-f]*:	a9 45       	asr r5,0x8
+
+[0-9a-f]* <lsl_imm5>:
+ *[0-9a-f]*:	a1 6f       	lsl pc,0x0
+ *[0-9a-f]*:	bf 7c       	lsl r12,0x1f
+ *[0-9a-f]*:	b1 65       	lsl r5,0x10
+ *[0-9a-f]*:	af 74       	lsl r4,0xf
+ *[0-9a-f]*:	a1 7e       	lsl lr,0x1
+ *[0-9a-f]*:	ad 7c       	lsl r12,0xd
+ *[0-9a-f]*:	b1 66       	lsl r6,0x10
+ *[0-9a-f]*:	b9 71       	lsl r1,0x19
+
+[0-9a-f]* <lsr_imm5>:
+ *[0-9a-f]*:	a1 8f       	lsr pc,0x0
+ *[0-9a-f]*:	bf 9c       	lsr r12,0x1f
+ *[0-9a-f]*:	b1 85       	lsr r5,0x10
+ *[0-9a-f]*:	af 94       	lsr r4,0xf
+ *[0-9a-f]*:	a1 9e       	lsr lr,0x1
+ *[0-9a-f]*:	a1 90       	lsr r0,0x1
+ *[0-9a-f]*:	ab 88       	lsr r8,0xa
+ *[0-9a-f]*:	bb 87       	lsr r7,0x1a
+
+[0-9a-f]* <sbr>:
+ *[0-9a-f]*:	a1 af       	sbr pc,0x0
+ *[0-9a-f]*:	bf bc       	sbr r12,0x1f
+ *[0-9a-f]*:	b1 a5       	sbr r5,0x10
+ *[0-9a-f]*:	af b4       	sbr r4,0xf
+ *[0-9a-f]*:	a1 be       	sbr lr,0x1
+ *[0-9a-f]*:	bf b8       	sbr r8,0x1f
+ *[0-9a-f]*:	b7 a6       	sbr r6,0x16
+ *[0-9a-f]*:	b7 b1       	sbr r1,0x17
+
+[0-9a-f]* <cbr>:
+ *[0-9a-f]*:	a1 cf       	cbr pc,0x0
+ *[0-9a-f]*:	bf dc       	cbr r12,0x1f
+ *[0-9a-f]*:	b1 c5       	cbr r5,0x10
+ *[0-9a-f]*:	af d4       	cbr r4,0xf
+ *[0-9a-f]*:	a1 de       	cbr lr,0x1
+ *[0-9a-f]*:	ab cc       	cbr r12,0xa
+ *[0-9a-f]*:	b7 c7       	cbr r7,0x16
+ *[0-9a-f]*:	a9 d8       	cbr r8,0x9
+
+[0-9a-f]* <brc1>:
+ *[0-9a-f]*:	c0 00       	breq [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf f7       	brpl [0-9a-f]* <.*>
+ *[0-9a-f]*:	c8 04       	brge [0-9a-f]* <.*>
+ *[0-9a-f]*:	c7 f3       	brcs [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 11       	brne [0-9a-f]* <.*>
+ *[0-9a-f]*:	c7 33       	brcs [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf 70       	breq [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 60       	breq [0-9a-f]* <.*>
+
+[0-9a-f]* <rjmp>:
+ *[0-9a-f]*:	c0 08       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf fb       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 0a       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf f9       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 18       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	c1 fa       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 78       	rjmp [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf ea       	rjmp [0-9a-f]* <.*>
+
+[0-9a-f]* <rcall1>:
+ *[0-9a-f]*:	c0 0c       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf ff       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 0e       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf fd       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 1c       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	c6 cc       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf 7e       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	c1 ae       	rcall [0-9a-f]* <.*>
+
+[0-9a-f]* <acall>:
+ *[0-9a-f]*:	d0 00       	acall 0x0
+ *[0-9a-f]*:	df f0       	acall 0x3fc
+ *[0-9a-f]*:	d8 00       	acall 0x200
+ *[0-9a-f]*:	d7 f0       	acall 0x1fc
+ *[0-9a-f]*:	d0 10       	acall 0x4
+ *[0-9a-f]*:	d5 90       	acall 0x164
+ *[0-9a-f]*:	d4 c0       	acall 0x130
+ *[0-9a-f]*:	d2 b0       	acall 0xac
+
+[0-9a-f]* <scall>:
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+ *[0-9a-f]*:	d7 33       	scall
+
+[0-9a-f]* <popm>:
+ *[0-9a-f]*:	d8 02       	popm pc
+ *[0-9a-f]*:	dd fa       	popm r0-r11,pc,r12=-1
+ *[0-9a-f]*:	d4 02       	popm lr
+ *[0-9a-f]*:	db fa       	popm r0-r11,pc,r12=1
+ *[0-9a-f]*:	d0 12       	popm r0-r3
+ *[0-9a-f]*:	d8 e2       	popm r4-r10,pc
+ *[0-9a-f]*:	d9 1a       	popm r0-r3,r11,pc,r12=0
+ *[0-9a-f]*:	d7 b2       	popm r0-r7,r10-r12,lr
+
+[0-9a-f]* <pushm>:
+ *[0-9a-f]*:	d8 01       	pushm pc
+ *[0-9a-f]*:	df f1       	pushm r0-r12,lr-pc
+ *[0-9a-f]*:	d8 01       	pushm pc
+ *[0-9a-f]*:	d7 f1       	pushm r0-r12,lr
+ *[0-9a-f]*:	d0 11       	pushm r0-r3
+ *[0-9a-f]*:	dc c1       	pushm r8-r10,lr-pc
+ *[0-9a-f]*:	d0 91       	pushm r0-r3,r10
+ *[0-9a-f]*:	d2 41       	pushm r8-r9,r12
+
+[0-9a-f]* <popm_n>:
+.*
+.*
+.*
+.*
+.*
+.*
+.*
+.*
+
+[0-9a-f]* <pushm_n>:
+.*
+.*
+.*
+.*
+.*
+.*
+.*
+.*
+
+[0-9a-f]* <csrfcz>:
+ *[0-9a-f]*:	d0 03       	csrfcz 0x0
+ *[0-9a-f]*:	d1 f3       	csrfcz 0x1f
+ *[0-9a-f]*:	d1 03       	csrfcz 0x10
+ *[0-9a-f]*:	d0 f3       	csrfcz 0xf
+ *[0-9a-f]*:	d0 13       	csrfcz 0x1
+ *[0-9a-f]*:	d0 53       	csrfcz 0x5
+ *[0-9a-f]*:	d0 d3       	csrfcz 0xd
+ *[0-9a-f]*:	d1 73       	csrfcz 0x17
+
+[0-9a-f]* <ssrf>:
+ *[0-9a-f]*:	d2 03       	ssrf 0x0
+ *[0-9a-f]*:	d3 f3       	ssrf 0x1f
+ *[0-9a-f]*:	d3 03       	ssrf 0x10
+ *[0-9a-f]*:	d2 f3       	ssrf 0xf
+ *[0-9a-f]*:	d2 13       	ssrf 0x1
+ *[0-9a-f]*:	d3 d3       	ssrf 0x1d
+ *[0-9a-f]*:	d2 d3       	ssrf 0xd
+ *[0-9a-f]*:	d2 d3       	ssrf 0xd
+
+[0-9a-f]* <csrf>:
+ *[0-9a-f]*:	d4 03       	csrf 0x0
+ *[0-9a-f]*:	d5 f3       	csrf 0x1f
+ *[0-9a-f]*:	d5 03       	csrf 0x10
+ *[0-9a-f]*:	d4 f3       	csrf 0xf
+ *[0-9a-f]*:	d4 13       	csrf 0x1
+ *[0-9a-f]*:	d4 a3       	csrf 0xa
+ *[0-9a-f]*:	d4 f3       	csrf 0xf
+ *[0-9a-f]*:	d4 b3       	csrf 0xb
+
+[0-9a-f]* <rete>:
+ *[0-9a-f]*:	d6 03       	rete
+
+[0-9a-f]* <rets>:
+ *[0-9a-f]*:	d6 13       	rets
+
+[0-9a-f]* <retd>:
+ *[0-9a-f]*:	d6 23       	retd
+
+[0-9a-f]* <retj>:
+ *[0-9a-f]*:	d6 33       	retj
+
+[0-9a-f]* <tlbr>:
+ *[0-9a-f]*:	d6 43       	tlbr
+
+[0-9a-f]* <tlbs>:
+ *[0-9a-f]*:	d6 53       	tlbs
+
+[0-9a-f]* <tlbw>:
+ *[0-9a-f]*:	d6 63       	tlbw
+
+[0-9a-f]* <breakpoint>:
+ *[0-9a-f]*:	d6 73       	breakpoint
+
+[0-9a-f]* <incjosp>:
+ *[0-9a-f]*:	d6 83       	incjosp 1
+ *[0-9a-f]*:	d6 93       	incjosp 2
+ *[0-9a-f]*:	d6 a3       	incjosp 3
+ *[0-9a-f]*:	d6 b3       	incjosp 4
+ *[0-9a-f]*:	d6 c3       	incjosp -4
+ *[0-9a-f]*:	d6 d3       	incjosp -3
+ *[0-9a-f]*:	d6 e3       	incjosp -2
+ *[0-9a-f]*:	d6 f3       	incjosp -1
+
+[0-9a-f]* <nop>:
+ *[0-9a-f]*:	d7 03       	nop
+
+[0-9a-f]* <popjc>:
+ *[0-9a-f]*:	d7 13       	popjc
+
+[0-9a-f]* <pushjc>:
+ *[0-9a-f]*:	d7 23       	pushjc
+
+[0-9a-f]* <add2>:
+ *[0-9a-f]*:	fe 0f 00 0f 	add pc,pc,pc
+ *[0-9a-f]*:	f8 0c 00 3c 	add r12,r12,r12<<0x3
+ *[0-9a-f]*:	ea 05 00 25 	add r5,r5,r5<<0x2
+ *[0-9a-f]*:	e8 04 00 14 	add r4,r4,r4<<0x1
+ *[0-9a-f]*:	fc 0e 00 1e 	add lr,lr,lr<<0x1
+ *[0-9a-f]*:	f8 00 00 10 	add r0,r12,r0<<0x1
+ *[0-9a-f]*:	f8 04 00 09 	add r9,r12,r4
+ *[0-9a-f]*:	f8 07 00 2c 	add r12,r12,r7<<0x2
+
+[0-9a-f]* <sub2>:
+ *[0-9a-f]*:	fe 0f 01 0f 	sub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 01 3c 	sub r12,r12,r12<<0x3
+ *[0-9a-f]*:	ea 05 01 25 	sub r5,r5,r5<<0x2
+ *[0-9a-f]*:	e8 04 01 14 	sub r4,r4,r4<<0x1
+ *[0-9a-f]*:	fc 0e 01 1e 	sub lr,lr,lr<<0x1
+ *[0-9a-f]*:	e6 04 01 0d 	sub sp,r3,r4
+ *[0-9a-f]*:	ee 03 01 03 	sub r3,r7,r3
+ *[0-9a-f]*:	f4 0d 01 1d 	sub sp,r10,sp<<0x1
+
+[0-9a-f]* <divu>:
+ *[0-9a-f]*:	fe 0f 0d 0f 	divu pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0d 0c 	divu r12,r12,r12
+ *[0-9a-f]*:	ea 05 0d 05 	divu r5,r5,r5
+ *[0-9a-f]*:	e8 04 0d 04 	divu r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0d 0e 	divu lr,lr,lr
+ *[0-9a-f]*:	e8 0f 0d 0d 	divu sp,r4,pc
+ *[0-9a-f]*:	ea 0d 0d 05 	divu r5,r5,sp
+ *[0-9a-f]*:	fa 00 0d 0a 	divu r10,sp,r0
+
+[0-9a-f]* <addhh_w>:
+ *[0-9a-f]*:	fe 0f 0e 0f 	addhh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 0e 3c 	addhh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 0e 35 	addhh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 0e 04 	addhh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 0e 3e 	addhh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	e0 03 0e 00 	addhh\.w r0,r0:b,r3:b
+ *[0-9a-f]*:	f8 07 0e 2e 	addhh\.w lr,r12:t,r7:b
+ *[0-9a-f]*:	f4 02 0e 23 	addhh\.w r3,r10:t,r2:b
+
+[0-9a-f]* <subhh_w>:
+ *[0-9a-f]*:	fe 0f 0f 0f 	subhh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 0f 3c 	subhh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 0f 35 	subhh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 0f 04 	subhh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 0f 3e 	subhh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	e2 07 0f 2a 	subhh\.w r10,r1:t,r7:b
+ *[0-9a-f]*:	f4 0e 0f 3f 	subhh\.w pc,r10:t,lr:t
+ *[0-9a-f]*:	e0 0c 0f 23 	subhh\.w r3,r0:t,r12:b
+
+[0-9a-f]* <adc>:
+ *[0-9a-f]*:	fe 0f 00 4f 	adc pc,pc,pc
+ *[0-9a-f]*:	f8 0c 00 4c 	adc r12,r12,r12
+ *[0-9a-f]*:	ea 05 00 45 	adc r5,r5,r5
+ *[0-9a-f]*:	e8 04 00 44 	adc r4,r4,r4
+ *[0-9a-f]*:	fc 0e 00 4e 	adc lr,lr,lr
+ *[0-9a-f]*:	e0 07 00 44 	adc r4,r0,r7
+ *[0-9a-f]*:	e8 03 00 4d 	adc sp,r4,r3
+ *[0-9a-f]*:	f8 00 00 42 	adc r2,r12,r0
+
+[0-9a-f]* <sbc>:
+ *[0-9a-f]*:	fe 0f 01 4f 	sbc pc,pc,pc
+ *[0-9a-f]*:	f8 0c 01 4c 	sbc r12,r12,r12
+ *[0-9a-f]*:	ea 05 01 45 	sbc r5,r5,r5
+ *[0-9a-f]*:	e8 04 01 44 	sbc r4,r4,r4
+ *[0-9a-f]*:	fc 0e 01 4e 	sbc lr,lr,lr
+ *[0-9a-f]*:	ee 09 01 46 	sbc r6,r7,r9
+ *[0-9a-f]*:	f0 05 01 40 	sbc r0,r8,r5
+ *[0-9a-f]*:	e0 04 01 41 	sbc r1,r0,r4
+
+[0-9a-f]* <mul_2>:
+ *[0-9a-f]*:	fe 0f 02 4f 	mul pc,pc,pc
+ *[0-9a-f]*:	f8 0c 02 4c 	mul r12,r12,r12
+ *[0-9a-f]*:	ea 05 02 45 	mul r5,r5,r5
+ *[0-9a-f]*:	e8 04 02 44 	mul r4,r4,r4
+ *[0-9a-f]*:	fc 0e 02 4e 	mul lr,lr,lr
+ *[0-9a-f]*:	e0 00 02 4f 	mul pc,r0,r0
+ *[0-9a-f]*:	fe 0e 02 48 	mul r8,pc,lr
+ *[0-9a-f]*:	f8 0f 02 44 	mul r4,r12,pc
+
+[0-9a-f]* <mac>:
+ *[0-9a-f]*:	fe 0f 03 4f 	mac pc,pc,pc
+ *[0-9a-f]*:	f8 0c 03 4c 	mac r12,r12,r12
+ *[0-9a-f]*:	ea 05 03 45 	mac r5,r5,r5
+ *[0-9a-f]*:	e8 04 03 44 	mac r4,r4,r4
+ *[0-9a-f]*:	fc 0e 03 4e 	mac lr,lr,lr
+ *[0-9a-f]*:	e8 00 03 4a 	mac r10,r4,r0
+ *[0-9a-f]*:	fc 00 03 47 	mac r7,lr,r0
+ *[0-9a-f]*:	f2 0c 03 42 	mac r2,r9,r12
+
+[0-9a-f]* <mulsd>:
+ *[0-9a-f]*:	fe 0f 04 4f 	muls\.d pc,pc,pc
+ *[0-9a-f]*:	f8 0c 04 4c 	muls\.d r12,r12,r12
+ *[0-9a-f]*:	ea 05 04 45 	muls\.d r5,r5,r5
+ *[0-9a-f]*:	e8 04 04 44 	muls\.d r4,r4,r4
+ *[0-9a-f]*:	fc 0e 04 4e 	muls\.d lr,lr,lr
+ *[0-9a-f]*:	f0 0e 04 42 	muls\.d r2,r8,lr
+ *[0-9a-f]*:	e0 0b 04 44 	muls\.d r4,r0,r11
+ *[0-9a-f]*:	fc 06 04 45 	muls\.d r5,lr,r6
+
+[0-9a-f]* <macsd>:
+ *[0-9a-f]*:	fe 0f 05 40 	macs\.d r0,pc,pc
+ *[0-9a-f]*:	f8 0c 05 4e 	macs\.d lr,r12,r12
+ *[0-9a-f]*:	ea 05 05 48 	macs\.d r8,r5,r5
+ *[0-9a-f]*:	e8 04 05 46 	macs\.d r6,r4,r4
+ *[0-9a-f]*:	fc 0e 05 42 	macs\.d r2,lr,lr
+ *[0-9a-f]*:	e2 09 05 48 	macs\.d r8,r1,r9
+ *[0-9a-f]*:	f0 08 05 4e 	macs\.d lr,r8,r8
+ *[0-9a-f]*:	e6 0c 05 44 	macs\.d r4,r3,r12
+
+[0-9a-f]* <mulud>:
+ *[0-9a-f]*:	fe 0f 06 40 	mulu\.d r0,pc,pc
+ *[0-9a-f]*:	f8 0c 06 4e 	mulu\.d lr,r12,r12
+ *[0-9a-f]*:	ea 05 06 48 	mulu\.d r8,r5,r5
+ *[0-9a-f]*:	e8 04 06 46 	mulu\.d r6,r4,r4
+ *[0-9a-f]*:	fc 0e 06 42 	mulu\.d r2,lr,lr
+ *[0-9a-f]*:	ea 00 06 46 	mulu\.d r6,r5,r0
+ *[0-9a-f]*:	ec 01 06 44 	mulu\.d r4,r6,r1
+ *[0-9a-f]*:	f0 02 06 48 	mulu\.d r8,r8,r2
+
+[0-9a-f]* <macud>:
+ *[0-9a-f]*:	fe 0f 07 40 	macu\.d r0,pc,pc
+ *[0-9a-f]*:	f8 0c 07 4e 	macu\.d lr,r12,r12
+ *[0-9a-f]*:	ea 05 07 48 	macu\.d r8,r5,r5
+ *[0-9a-f]*:	e8 04 07 46 	macu\.d r6,r4,r4
+ *[0-9a-f]*:	fc 0e 07 42 	macu\.d r2,lr,lr
+ *[0-9a-f]*:	fa 0b 07 46 	macu\.d r6,sp,r11
+ *[0-9a-f]*:	e8 08 07 42 	macu\.d r2,r4,r8
+ *[0-9a-f]*:	f4 09 07 46 	macu\.d r6,r10,r9
+
+[0-9a-f]* <asr_1>:
+ *[0-9a-f]*:	fe 0f 08 4f 	asr pc,pc,pc
+ *[0-9a-f]*:	f8 0c 08 4c 	asr r12,r12,r12
+ *[0-9a-f]*:	ea 05 08 45 	asr r5,r5,r5
+ *[0-9a-f]*:	e8 04 08 44 	asr r4,r4,r4
+ *[0-9a-f]*:	fc 0e 08 4e 	asr lr,lr,lr
+ *[0-9a-f]*:	ec 0f 08 4f 	asr pc,r6,pc
+ *[0-9a-f]*:	ec 0c 08 40 	asr r0,r6,r12
+ *[0-9a-f]*:	fa 00 08 44 	asr r4,sp,r0
+
+[0-9a-f]* <lsl_1>:
+ *[0-9a-f]*:	fe 0f 09 4f 	lsl pc,pc,pc
+ *[0-9a-f]*:	f8 0c 09 4c 	lsl r12,r12,r12
+ *[0-9a-f]*:	ea 05 09 45 	lsl r5,r5,r5
+ *[0-9a-f]*:	e8 04 09 44 	lsl r4,r4,r4
+ *[0-9a-f]*:	fc 0e 09 4e 	lsl lr,lr,lr
+ *[0-9a-f]*:	ea 0e 09 4e 	lsl lr,r5,lr
+ *[0-9a-f]*:	fe 03 09 45 	lsl r5,pc,r3
+ *[0-9a-f]*:	fe 09 09 41 	lsl r1,pc,r9
+
+[0-9a-f]* <lsr_1>:
+ *[0-9a-f]*:	fe 0f 0a 4f 	lsr pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0a 4c 	lsr r12,r12,r12
+ *[0-9a-f]*:	ea 05 0a 45 	lsr r5,r5,r5
+ *[0-9a-f]*:	e8 04 0a 44 	lsr r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0a 4e 	lsr lr,lr,lr
+ *[0-9a-f]*:	e8 01 0a 42 	lsr r2,r4,r1
+ *[0-9a-f]*:	e2 06 0a 45 	lsr r5,r1,r6
+ *[0-9a-f]*:	ec 07 0a 4d 	lsr sp,r6,r7
+
+[0-9a-f]* <xchg>:
+ *[0-9a-f]*:	fe 0f 0b 4f 	xchg pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0b 4c 	xchg r12,r12,r12
+ *[0-9a-f]*:	ea 05 0b 45 	xchg r5,r5,r5
+ *[0-9a-f]*:	e8 04 0b 44 	xchg r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0b 4e 	xchg lr,lr,lr
+ *[0-9a-f]*:	e8 0d 0b 4e 	xchg lr,r4,sp
+ *[0-9a-f]*:	ea 0c 0b 41 	xchg r1,r5,r12
+ *[0-9a-f]*:	f8 00 0b 4e 	xchg lr,r12,r0
+
+[0-9a-f]* <max>:
+ *[0-9a-f]*:	fe 0f 0c 4f 	max pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0c 4c 	max r12,r12,r12
+ *[0-9a-f]*:	ea 05 0c 45 	max r5,r5,r5
+ *[0-9a-f]*:	e8 04 0c 44 	max r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0c 4e 	max lr,lr,lr
+ *[0-9a-f]*:	e4 0d 0c 4e 	max lr,r2,sp
+ *[0-9a-f]*:	f4 09 0c 44 	max r4,r10,r9
+ *[0-9a-f]*:	f2 0e 0c 4e 	max lr,r9,lr
+
+[0-9a-f]* <min>:
+ *[0-9a-f]*:	fe 0f 0d 4f 	min pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0d 4c 	min r12,r12,r12
+ *[0-9a-f]*:	ea 05 0d 45 	min r5,r5,r5
+ *[0-9a-f]*:	e8 04 0d 44 	min r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0d 4e 	min lr,lr,lr
+ *[0-9a-f]*:	ee 08 0d 49 	min r9,r7,r8
+ *[0-9a-f]*:	ea 05 0d 4d 	min sp,r5,r5
+ *[0-9a-f]*:	e2 04 0d 44 	min r4,r1,r4
+
+[0-9a-f]* <addabs>:
+ *[0-9a-f]*:	fe 0f 0e 4f 	addabs pc,pc,pc
+ *[0-9a-f]*:	f8 0c 0e 4c 	addabs r12,r12,r12
+ *[0-9a-f]*:	ea 05 0e 45 	addabs r5,r5,r5
+ *[0-9a-f]*:	e8 04 0e 44 	addabs r4,r4,r4
+ *[0-9a-f]*:	fc 0e 0e 4e 	addabs lr,lr,lr
+ *[0-9a-f]*:	f4 00 0e 47 	addabs r7,r10,r0
+ *[0-9a-f]*:	f2 07 0e 49 	addabs r9,r9,r7
+ *[0-9a-f]*:	f0 0c 0e 42 	addabs r2,r8,r12
+
+[0-9a-f]* <mulnhh_w>:
+ *[0-9a-f]*:	fe 0f 01 8f 	mulnhh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 01 bc 	mulnhh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 01 b5 	mulnhh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 01 84 	mulnhh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 01 be 	mulnhh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	fa 09 01 ab 	mulnhh\.w r11,sp:t,r9:b
+ *[0-9a-f]*:	e8 0e 01 9d 	mulnhh\.w sp,r4:b,lr:t
+ *[0-9a-f]*:	e4 0b 01 ac 	mulnhh\.w r12,r2:t,r11:b
+
+[0-9a-f]* <mulnwh_d>:
+ *[0-9a-f]*:	fe 0f 02 80 	mulnwh\.d r0,pc,pc:b
+ *[0-9a-f]*:	f8 0c 02 9e 	mulnwh\.d lr,r12,r12:t
+ *[0-9a-f]*:	ea 05 02 98 	mulnwh\.d r8,r5,r5:t
+ *[0-9a-f]*:	e8 04 02 86 	mulnwh\.d r6,r4,r4:b
+ *[0-9a-f]*:	fc 0e 02 92 	mulnwh\.d r2,lr,lr:t
+ *[0-9a-f]*:	e6 02 02 9e 	mulnwh\.d lr,r3,r2:t
+ *[0-9a-f]*:	ea 09 02 84 	mulnwh\.d r4,r5,r9:b
+ *[0-9a-f]*:	e8 04 02 9c 	mulnwh\.d r12,r4,r4:t
+
+[0-9a-f]* <machh_w>:
+ *[0-9a-f]*:	fe 0f 04 8f 	machh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 04 bc 	machh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 04 b5 	machh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 04 84 	machh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 04 be 	machh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	ea 01 04 9e 	machh\.w lr,r5:b,r1:t
+ *[0-9a-f]*:	ec 07 04 89 	machh\.w r9,r6:b,r7:b
+ *[0-9a-f]*:	fc 0c 04 a5 	machh\.w r5,lr:t,r12:b
+
+[0-9a-f]* <machh_d>:
+ *[0-9a-f]*:	fe 0f 05 80 	machh\.d r0,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 05 be 	machh\.d lr,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 05 b8 	machh\.d r8,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 05 86 	machh\.d r6,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 05 b2 	machh\.d r2,lr:t,lr:t
+ *[0-9a-f]*:	e0 08 05 8a 	machh\.d r10,r0:b,r8:b
+ *[0-9a-f]*:	e8 05 05 9e 	machh\.d lr,r4:b,r5:t
+ *[0-9a-f]*:	e0 04 05 98 	machh\.d r8,r0:b,r4:t
+
+[0-9a-f]* <macsathh_w>:
+ *[0-9a-f]*:	fe 0f 06 8f 	macsathh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 06 bc 	macsathh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 06 b5 	macsathh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 06 84 	macsathh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 06 be 	macsathh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	ee 0f 06 b7 	macsathh\.w r7,r7:t,pc:t
+ *[0-9a-f]*:	e4 04 06 a4 	macsathh\.w r4,r2:t,r4:b
+ *[0-9a-f]*:	f0 03 06 b4 	macsathh\.w r4,r8:t,r3:t
+
+[0-9a-f]* <mulhh_w>:
+ *[0-9a-f]*:	fe 0f 07 8f 	mulhh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 07 bc 	mulhh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 07 b5 	mulhh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 07 84 	mulhh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 07 be 	mulhh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	e8 09 07 a7 	mulhh\.w r7,r4:t,r9:b
+ *[0-9a-f]*:	e6 07 07 bf 	mulhh\.w pc,r3:t,r7:t
+ *[0-9a-f]*:	e8 09 07 9f 	mulhh\.w pc,r4:b,r9:t
+
+[0-9a-f]* <mulsathh_h>:
+ *[0-9a-f]*:	fe 0f 08 8f 	mulsathh\.h pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 08 bc 	mulsathh\.h r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 08 b5 	mulsathh\.h r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 08 84 	mulsathh\.h r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 08 be 	mulsathh\.h lr,lr:t,lr:t
+ *[0-9a-f]*:	e2 0d 08 83 	mulsathh\.h r3,r1:b,sp:b
+ *[0-9a-f]*:	fc 0b 08 ab 	mulsathh\.h r11,lr:t,r11:b
+ *[0-9a-f]*:	f0 0b 08 98 	mulsathh\.h r8,r8:b,r11:t
+
+[0-9a-f]* <mulsathh_w>:
+ *[0-9a-f]*:	fe 0f 09 8f 	mulsathh\.w pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 09 bc 	mulsathh\.w r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 09 b5 	mulsathh\.w r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 09 84 	mulsathh\.w r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 09 be 	mulsathh\.w lr,lr:t,lr:t
+ *[0-9a-f]*:	f6 06 09 ae 	mulsathh\.w lr,r11:t,r6:b
+ *[0-9a-f]*:	ec 07 09 96 	mulsathh\.w r6,r6:b,r7:t
+ *[0-9a-f]*:	e4 03 09 8a 	mulsathh\.w r10,r2:b,r3:b
+
+[0-9a-f]* <mulsatrndhh_h>:
+ *[0-9a-f]*:	fe 0f 0a 8f 	mulsatrndhh\.h pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 0a bc 	mulsatrndhh\.h r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 0a b5 	mulsatrndhh\.h r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 0a 84 	mulsatrndhh\.h r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 0a be 	mulsatrndhh\.h lr,lr:t,lr:t
+ *[0-9a-f]*:	ec 09 0a 8b 	mulsatrndhh\.h r11,r6:b,r9:b
+ *[0-9a-f]*:	e6 08 0a 9b 	mulsatrndhh\.h r11,r3:b,r8:t
+ *[0-9a-f]*:	fa 07 0a b5 	mulsatrndhh\.h r5,sp:t,r7:t
+
+[0-9a-f]* <mulsatrndwh_w>:
+ *[0-9a-f]*:	fe 0f 0b 8f 	mulsatrndwh\.w pc,pc,pc:b
+ *[0-9a-f]*:	f8 0c 0b 9c 	mulsatrndwh\.w r12,r12,r12:t
+ *[0-9a-f]*:	ea 05 0b 95 	mulsatrndwh\.w r5,r5,r5:t
+ *[0-9a-f]*:	e8 04 0b 84 	mulsatrndwh\.w r4,r4,r4:b
+ *[0-9a-f]*:	fc 0e 0b 9e 	mulsatrndwh\.w lr,lr,lr:t
+ *[0-9a-f]*:	f8 00 0b 85 	mulsatrndwh\.w r5,r12,r0:b
+ *[0-9a-f]*:	f4 0f 0b 87 	mulsatrndwh\.w r7,r10,pc:b
+ *[0-9a-f]*:	f0 05 0b 9a 	mulsatrndwh\.w r10,r8,r5:t
+
+[0-9a-f]* <macwh_d>:
+ *[0-9a-f]*:	fe 0f 0c 80 	macwh\.d r0,pc,pc:b
+ *[0-9a-f]*:	f8 0c 0c 9e 	macwh\.d lr,r12,r12:t
+ *[0-9a-f]*:	ea 05 0c 98 	macwh\.d r8,r5,r5:t
+ *[0-9a-f]*:	e8 04 0c 86 	macwh\.d r6,r4,r4:b
+ *[0-9a-f]*:	fc 0e 0c 92 	macwh\.d r2,lr,lr:t
+ *[0-9a-f]*:	f4 0c 0c 94 	macwh\.d r4,r10,r12:t
+ *[0-9a-f]*:	ee 0d 0c 84 	macwh\.d r4,r7,sp:b
+ *[0-9a-f]*:	f2 0b 0c 8e 	macwh\.d lr,r9,r11:b
+
+[0-9a-f]* <mulwh_d>:
+ *[0-9a-f]*:	fe 0f 0d 80 	mulwh\.d r0,pc,pc:b
+ *[0-9a-f]*:	f8 0c 0d 9e 	mulwh\.d lr,r12,r12:t
+ *[0-9a-f]*:	ea 05 0d 98 	mulwh\.d r8,r5,r5:t
+ *[0-9a-f]*:	e8 04 0d 86 	mulwh\.d r6,r4,r4:b
+ *[0-9a-f]*:	fc 0e 0d 92 	mulwh\.d r2,lr,lr:t
+ *[0-9a-f]*:	ea 01 0d 8c 	mulwh\.d r12,r5,r1:b
+ *[0-9a-f]*:	e2 03 0d 90 	mulwh\.d r0,r1,r3:t
+ *[0-9a-f]*:	f2 02 0d 80 	mulwh\.d r0,r9,r2:b
+
+[0-9a-f]* <mulsatwh_w>:
+ *[0-9a-f]*:	fe 0f 0e 8f 	mulsatwh\.w pc,pc,pc:b
+ *[0-9a-f]*:	f8 0c 0e 9c 	mulsatwh\.w r12,r12,r12:t
+ *[0-9a-f]*:	ea 05 0e 95 	mulsatwh\.w r5,r5,r5:t
+ *[0-9a-f]*:	e8 04 0e 84 	mulsatwh\.w r4,r4,r4:b
+ *[0-9a-f]*:	fc 0e 0e 9e 	mulsatwh\.w lr,lr,lr:t
+ *[0-9a-f]*:	fe 0a 0e 9b 	mulsatwh\.w r11,pc,r10:t
+ *[0-9a-f]*:	f8 09 0e 9d 	mulsatwh\.w sp,r12,r9:t
+ *[0-9a-f]*:	e6 02 0e 90 	mulsatwh\.w r0,r3,r2:t
+
+[0-9a-f]* <ldw7>:
+ *[0-9a-f]*:	fe 0f 0f 8f 	ld\.w pc,pc\[pc:b<<2\]
+ *[0-9a-f]*:	f8 0c 0f bc 	ld\.w r12,r12\[r12:t<<2\]
+ *[0-9a-f]*:	ea 05 0f a5 	ld\.w r5,r5\[r5:u<<2\]
+ *[0-9a-f]*:	e8 04 0f 94 	ld\.w r4,r4\[r4:l<<2\]
+ *[0-9a-f]*:	fc 0e 0f 9e 	ld\.w lr,lr\[lr:l<<2\]
+ *[0-9a-f]*:	f4 06 0f 99 	ld\.w r9,r10\[r6:l<<2\]
+ *[0-9a-f]*:	f4 0a 0f 82 	ld\.w r2,r10\[r10:b<<2\]
+ *[0-9a-f]*:	ea 0f 0f 8b 	ld\.w r11,r5\[pc:b<<2\]
+
+[0-9a-f]* <satadd_w>:
+ *[0-9a-f]*:	fe 0f 00 cf 	satadd\.w pc,pc,pc
+ *[0-9a-f]*:	f8 0c 00 cc 	satadd\.w r12,r12,r12
+ *[0-9a-f]*:	ea 05 00 c5 	satadd\.w r5,r5,r5
+ *[0-9a-f]*:	e8 04 00 c4 	satadd\.w r4,r4,r4
+ *[0-9a-f]*:	fc 0e 00 ce 	satadd\.w lr,lr,lr
+ *[0-9a-f]*:	f0 0b 00 c4 	satadd\.w r4,r8,r11
+ *[0-9a-f]*:	f8 06 00 c3 	satadd\.w r3,r12,r6
+ *[0-9a-f]*:	fc 09 00 c3 	satadd\.w r3,lr,r9
+
+[0-9a-f]* <satsub_w1>:
+ *[0-9a-f]*:	fe 0f 01 cf 	satsub\.w pc,pc,pc
+ *[0-9a-f]*:	f8 0c 01 cc 	satsub\.w r12,r12,r12
+ *[0-9a-f]*:	ea 05 01 c5 	satsub\.w r5,r5,r5
+ *[0-9a-f]*:	e8 04 01 c4 	satsub\.w r4,r4,r4
+ *[0-9a-f]*:	fc 0e 01 ce 	satsub\.w lr,lr,lr
+ *[0-9a-f]*:	fa 00 01 c8 	satsub\.w r8,sp,r0
+ *[0-9a-f]*:	f0 04 01 c9 	satsub\.w r9,r8,r4
+ *[0-9a-f]*:	fc 02 01 cf 	satsub\.w pc,lr,r2
+
+[0-9a-f]* <satadd_h>:
+ *[0-9a-f]*:	fe 0f 02 cf 	satadd\.h pc,pc,pc
+ *[0-9a-f]*:	f8 0c 02 cc 	satadd\.h r12,r12,r12
+ *[0-9a-f]*:	ea 05 02 c5 	satadd\.h r5,r5,r5
+ *[0-9a-f]*:	e8 04 02 c4 	satadd\.h r4,r4,r4
+ *[0-9a-f]*:	fc 0e 02 ce 	satadd\.h lr,lr,lr
+ *[0-9a-f]*:	e6 09 02 c7 	satadd\.h r7,r3,r9
+ *[0-9a-f]*:	e0 02 02 c1 	satadd\.h r1,r0,r2
+ *[0-9a-f]*:	e8 0e 02 c1 	satadd\.h r1,r4,lr
+
+[0-9a-f]* <satsub_h>:
+ *[0-9a-f]*:	fe 0f 03 cf 	satsub\.h pc,pc,pc
+ *[0-9a-f]*:	f8 0c 03 cc 	satsub\.h r12,r12,r12
+ *[0-9a-f]*:	ea 05 03 c5 	satsub\.h r5,r5,r5
+ *[0-9a-f]*:	e8 04 03 c4 	satsub\.h r4,r4,r4
+ *[0-9a-f]*:	fc 0e 03 ce 	satsub\.h lr,lr,lr
+ *[0-9a-f]*:	fc 03 03 ce 	satsub\.h lr,lr,r3
+ *[0-9a-f]*:	ec 05 03 cb 	satsub\.h r11,r6,r5
+ *[0-9a-f]*:	fa 00 03 c3 	satsub\.h r3,sp,r0
+
+[0-9a-f]* <mul3>:
+ *[0-9a-f]*:	fe 0f 10 00 	mul pc,pc,0
+ *[0-9a-f]*:	f8 0c 10 ff 	mul r12,r12,-1
+ *[0-9a-f]*:	ea 05 10 80 	mul r5,r5,-128
+ *[0-9a-f]*:	e8 04 10 7f 	mul r4,r4,127
+ *[0-9a-f]*:	fc 0e 10 01 	mul lr,lr,1
+ *[0-9a-f]*:	e4 0c 10 f9 	mul r12,r2,-7
+ *[0-9a-f]*:	fe 01 10 5f 	mul r1,pc,95
+ *[0-9a-f]*:	ec 04 10 13 	mul r4,r6,19
+
+[0-9a-f]* <rsub2>:
+ *[0-9a-f]*:	fe 0f 11 00 	rsub pc,pc,0
+ *[0-9a-f]*:	f8 0c 11 ff 	rsub r12,r12,-1
+ *[0-9a-f]*:	ea 05 11 80 	rsub r5,r5,-128
+ *[0-9a-f]*:	e8 04 11 7f 	rsub r4,r4,127
+ *[0-9a-f]*:	fc 0e 11 01 	rsub lr,lr,1
+ *[0-9a-f]*:	fc 09 11 60 	rsub r9,lr,96
+ *[0-9a-f]*:	e2 0b 11 38 	rsub r11,r1,56
+ *[0-9a-f]*:	ee 00 11 a9 	rsub r0,r7,-87
+
+[0-9a-f]* <clz>:
+ *[0-9a-f]*:	fe 0f 12 00 	clz pc,pc
+ *[0-9a-f]*:	f8 0c 12 00 	clz r12,r12
+ *[0-9a-f]*:	ea 05 12 00 	clz r5,r5
+ *[0-9a-f]*:	e8 04 12 00 	clz r4,r4
+ *[0-9a-f]*:	fc 0e 12 00 	clz lr,lr
+ *[0-9a-f]*:	e6 02 12 00 	clz r2,r3
+ *[0-9a-f]*:	f6 05 12 00 	clz r5,r11
+ *[0-9a-f]*:	e6 0f 12 00 	clz pc,r3
+
+[0-9a-f]* <cpc1>:
+ *[0-9a-f]*:	fe 0f 13 00 	cpc pc,pc
+ *[0-9a-f]*:	f8 0c 13 00 	cpc r12,r12
+ *[0-9a-f]*:	ea 05 13 00 	cpc r5,r5
+ *[0-9a-f]*:	e8 04 13 00 	cpc r4,r4
+ *[0-9a-f]*:	fc 0e 13 00 	cpc lr,lr
+ *[0-9a-f]*:	e8 0f 13 00 	cpc pc,r4
+ *[0-9a-f]*:	f2 05 13 00 	cpc r5,r9
+ *[0-9a-f]*:	ee 06 13 00 	cpc r6,r7
+
+[0-9a-f]* <asr3>:
+ *[0-9a-f]*:	fe 0f 14 00 	asr pc,pc,0x0
+ *[0-9a-f]*:	f8 0c 14 1f 	asr r12,r12,0x1f
+ *[0-9a-f]*:	ea 05 14 10 	asr r5,r5,0x10
+ *[0-9a-f]*:	e8 04 14 0f 	asr r4,r4,0xf
+ *[0-9a-f]*:	fc 0e 14 01 	asr lr,lr,0x1
+ *[0-9a-f]*:	f6 04 14 13 	asr r4,r11,0x13
+ *[0-9a-f]*:	fe 0d 14 1a 	asr sp,pc,0x1a
+ *[0-9a-f]*:	fa 0b 14 08 	asr r11,sp,0x8
+
+[0-9a-f]* <lsl3>:
+ *[0-9a-f]*:	fe 0f 15 00 	lsl pc,pc,0x0
+ *[0-9a-f]*:	f8 0c 15 1f 	lsl r12,r12,0x1f
+ *[0-9a-f]*:	ea 05 15 10 	lsl r5,r5,0x10
+ *[0-9a-f]*:	e8 04 15 0f 	lsl r4,r4,0xf
+ *[0-9a-f]*:	fc 0e 15 01 	lsl lr,lr,0x1
+ *[0-9a-f]*:	f4 08 15 11 	lsl r8,r10,0x11
+ *[0-9a-f]*:	fc 02 15 03 	lsl r2,lr,0x3
+ *[0-9a-f]*:	f6 0e 15 0e 	lsl lr,r11,0xe
+
+[0-9a-f]* <lsr3>:
+ *[0-9a-f]*:	fe 0f 16 00 	lsr pc,pc,0x0
+ *[0-9a-f]*:	f8 0c 16 1f 	lsr r12,r12,0x1f
+ *[0-9a-f]*:	ea 05 16 10 	lsr r5,r5,0x10
+ *[0-9a-f]*:	e8 04 16 0f 	lsr r4,r4,0xf
+ *[0-9a-f]*:	fc 0e 16 01 	lsr lr,lr,0x1
+ *[0-9a-f]*:	e6 04 16 1f 	lsr r4,r3,0x1f
+ *[0-9a-f]*:	f2 0f 16 0e 	lsr pc,r9,0xe
+ *[0-9a-f]*:	e0 03 16 06 	lsr r3,r0,0x6
+
+[0-9a-f]* <movc1>:
+ *[0-9a-f]*:	fe 0f 17 00 	moveq pc,pc
+ *[0-9a-f]*:	f8 0c 17 f0 	moval r12,r12
+ *[0-9a-f]*:	ea 05 17 80 	movls r5,r5
+ *[0-9a-f]*:	e8 04 17 70 	movpl r4,r4
+ *[0-9a-f]*:	fc 0e 17 10 	movne lr,lr
+ *[0-9a-f]*:	f6 0f 17 10 	movne pc,r11
+ *[0-9a-f]*:	e4 0a 17 60 	movmi r10,r2
+ *[0-9a-f]*:	f8 08 17 80 	movls r8,r12
+
+[0-9a-f]* <padd_h>:
+ *[0-9a-f]*:	fe 0f 20 0f 	padd\.h pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 0c 	padd\.h r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 05 	padd\.h r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 04 	padd\.h r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 0e 	padd\.h lr,lr,lr
+ *[0-9a-f]*:	e4 07 20 08 	padd\.h r8,r2,r7
+ *[0-9a-f]*:	e0 03 20 00 	padd\.h r0,r0,r3
+ *[0-9a-f]*:	f6 06 20 0d 	padd\.h sp,r11,r6
+
+[0-9a-f]* <psub_h>:
+ *[0-9a-f]*:	fe 0f 20 1f 	psub\.h pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 1c 	psub\.h r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 15 	psub\.h r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 14 	psub\.h r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 1e 	psub\.h lr,lr,lr
+ *[0-9a-f]*:	ec 08 20 1e 	psub\.h lr,r6,r8
+ *[0-9a-f]*:	e2 0d 20 10 	psub\.h r0,r1,sp
+ *[0-9a-f]*:	fe 0d 20 1f 	psub\.h pc,pc,sp
+
+[0-9a-f]* <paddx_h>:
+ *[0-9a-f]*:	fe 0f 20 2f 	paddx\.h pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 2c 	paddx\.h r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 25 	paddx\.h r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 24 	paddx\.h r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 2e 	paddx\.h lr,lr,lr
+ *[0-9a-f]*:	fe 01 20 2f 	paddx\.h pc,pc,r1
+ *[0-9a-f]*:	e8 05 20 2a 	paddx\.h r10,r4,r5
+ *[0-9a-f]*:	fe 02 20 25 	paddx\.h r5,pc,r2
+
+[0-9a-f]* <psubx_h>:
+ *[0-9a-f]*:	fe 0f 20 3f 	psubx\.h pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 3c 	psubx\.h r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 35 	psubx\.h r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 34 	psubx\.h r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 3e 	psubx\.h lr,lr,lr
+ *[0-9a-f]*:	f8 05 20 35 	psubx\.h r5,r12,r5
+ *[0-9a-f]*:	f0 03 20 33 	psubx\.h r3,r8,r3
+ *[0-9a-f]*:	e4 03 20 35 	psubx\.h r5,r2,r3
+
+[0-9a-f]* <padds_sh>:
+ *[0-9a-f]*:	fe 0f 20 4f 	padds\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 4c 	padds\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 45 	padds\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 44 	padds\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 4e 	padds\.sh lr,lr,lr
+ *[0-9a-f]*:	fc 02 20 49 	padds\.sh r9,lr,r2
+ *[0-9a-f]*:	f0 01 20 46 	padds\.sh r6,r8,r1
+ *[0-9a-f]*:	e8 0a 20 46 	padds\.sh r6,r4,r10
+
+[0-9a-f]* <psubs_sh>:
+ *[0-9a-f]*:	fe 0f 20 5f 	psubs\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 5c 	psubs\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 55 	psubs\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 54 	psubs\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 5e 	psubs\.sh lr,lr,lr
+ *[0-9a-f]*:	fc 0b 20 56 	psubs\.sh r6,lr,r11
+ *[0-9a-f]*:	f8 04 20 52 	psubs\.sh r2,r12,r4
+ *[0-9a-f]*:	f2 00 20 50 	psubs\.sh r0,r9,r0
+
+[0-9a-f]* <paddxs_sh>:
+ *[0-9a-f]*:	fe 0f 20 6f 	paddxs\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 6c 	paddxs\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 65 	paddxs\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 64 	paddxs\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 6e 	paddxs\.sh lr,lr,lr
+ *[0-9a-f]*:	e6 09 20 60 	paddxs\.sh r0,r3,r9
+ *[0-9a-f]*:	f4 0b 20 6f 	paddxs\.sh pc,r10,r11
+ *[0-9a-f]*:	f4 0f 20 6f 	paddxs\.sh pc,r10,pc
+
+[0-9a-f]* <psubxs_sh>:
+ *[0-9a-f]*:	fe 0f 20 7f 	psubxs\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 7c 	psubxs\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 75 	psubxs\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 74 	psubxs\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 7e 	psubxs\.sh lr,lr,lr
+ *[0-9a-f]*:	e8 04 20 77 	psubxs\.sh r7,r4,r4
+ *[0-9a-f]*:	f0 03 20 77 	psubxs\.sh r7,r8,r3
+ *[0-9a-f]*:	ec 05 20 7f 	psubxs\.sh pc,r6,r5
+
+[0-9a-f]* <padds_uh>:
+ *[0-9a-f]*:	fe 0f 20 8f 	padds\.uh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 8c 	padds\.uh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 85 	padds\.uh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 84 	padds\.uh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 8e 	padds\.uh lr,lr,lr
+ *[0-9a-f]*:	f6 07 20 8c 	padds\.uh r12,r11,r7
+ *[0-9a-f]*:	f0 0e 20 87 	padds\.uh r7,r8,lr
+ *[0-9a-f]*:	f2 07 20 86 	padds\.uh r6,r9,r7
+
+[0-9a-f]* <psubs_uh>:
+ *[0-9a-f]*:	fe 0f 20 9f 	psubs\.uh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 9c 	psubs\.uh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 95 	psubs\.uh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 94 	psubs\.uh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 9e 	psubs\.uh lr,lr,lr
+ *[0-9a-f]*:	f4 06 20 9e 	psubs\.uh lr,r10,r6
+ *[0-9a-f]*:	e4 0f 20 9d 	psubs\.uh sp,r2,pc
+ *[0-9a-f]*:	f2 02 20 92 	psubs\.uh r2,r9,r2
+
+[0-9a-f]* <paddxs_uh>:
+ *[0-9a-f]*:	fe 0f 20 af 	paddxs\.uh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 ac 	paddxs\.uh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 a5 	paddxs\.uh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 a4 	paddxs\.uh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 ae 	paddxs\.uh lr,lr,lr
+ *[0-9a-f]*:	f2 05 20 a7 	paddxs\.uh r7,r9,r5
+ *[0-9a-f]*:	e2 04 20 a9 	paddxs\.uh r9,r1,r4
+ *[0-9a-f]*:	e4 03 20 a5 	paddxs\.uh r5,r2,r3
+
+[0-9a-f]* <psubxs_uh>:
+ *[0-9a-f]*:	fe 0f 20 bf 	psubxs\.uh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 bc 	psubxs\.uh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 b5 	psubxs\.uh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 b4 	psubxs\.uh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 be 	psubxs\.uh lr,lr,lr
+ *[0-9a-f]*:	ea 0d 20 bd 	psubxs\.uh sp,r5,sp
+ *[0-9a-f]*:	ec 06 20 bd 	psubxs\.uh sp,r6,r6
+ *[0-9a-f]*:	f6 08 20 b3 	psubxs\.uh r3,r11,r8
+
+[0-9a-f]* <paddh_sh>:
+ *[0-9a-f]*:	fe 0f 20 cf 	paddh\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 cc 	paddh\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 c5 	paddh\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 c4 	paddh\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 ce 	paddh\.sh lr,lr,lr
+ *[0-9a-f]*:	fa 03 20 cc 	paddh\.sh r12,sp,r3
+ *[0-9a-f]*:	ea 03 20 cf 	paddh\.sh pc,r5,r3
+ *[0-9a-f]*:	f0 0d 20 c8 	paddh\.sh r8,r8,sp
+
+[0-9a-f]* <psubh_sh>:
+ *[0-9a-f]*:	fe 0f 20 df 	psubh\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 dc 	psubh\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 d5 	psubh\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 d4 	psubh\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 de 	psubh\.sh lr,lr,lr
+ *[0-9a-f]*:	ea 08 20 d1 	psubh\.sh r1,r5,r8
+ *[0-9a-f]*:	e6 06 20 d7 	psubh\.sh r7,r3,r6
+ *[0-9a-f]*:	e6 03 20 d4 	psubh\.sh r4,r3,r3
+
+[0-9a-f]* <paddxh_sh>:
+ *[0-9a-f]*:	fe 0f 20 ef 	paddxh\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 ec 	paddxh\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 e5 	paddxh\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 e4 	paddxh\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 ee 	paddxh\.sh lr,lr,lr
+ *[0-9a-f]*:	e0 04 20 e6 	paddxh\.sh r6,r0,r4
+ *[0-9a-f]*:	f0 09 20 e9 	paddxh\.sh r9,r8,r9
+ *[0-9a-f]*:	e0 0d 20 e3 	paddxh\.sh r3,r0,sp
+
+[0-9a-f]* <psubxh_sh>:
+ *[0-9a-f]*:	fe 0f 20 ff 	psubxh\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 20 fc 	psubxh\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 20 f5 	psubxh\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 20 f4 	psubxh\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 20 fe 	psubxh\.sh lr,lr,lr
+ *[0-9a-f]*:	fe 0c 20 f4 	psubxh\.sh r4,pc,r12
+ *[0-9a-f]*:	e8 06 20 f8 	psubxh\.sh r8,r4,r6
+ *[0-9a-f]*:	f2 04 20 fc 	psubxh\.sh r12,r9,r4
+
+[0-9a-f]* <paddsub_h>:
+ *[0-9a-f]*:	fe 0f 21 0f 	paddsub\.h pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 21 3c 	paddsub\.h r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 21 35 	paddsub\.h r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 21 04 	paddsub\.h r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 21 3e 	paddsub\.h lr,lr:t,lr:t
+ *[0-9a-f]*:	e4 0e 21 25 	paddsub\.h r5,r2:t,lr:b
+ *[0-9a-f]*:	e2 08 21 07 	paddsub\.h r7,r1:b,r8:b
+ *[0-9a-f]*:	f4 05 21 36 	paddsub\.h r6,r10:t,r5:t
+
+[0-9a-f]* <psubadd_h>:
+ *[0-9a-f]*:	fe 0f 21 4f 	psubadd\.h pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 21 7c 	psubadd\.h r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 21 75 	psubadd\.h r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 21 44 	psubadd\.h r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 21 7e 	psubadd\.h lr,lr:t,lr:t
+ *[0-9a-f]*:	f6 08 21 79 	psubadd\.h r9,r11:t,r8:t
+ *[0-9a-f]*:	ee 0e 21 7a 	psubadd\.h r10,r7:t,lr:t
+ *[0-9a-f]*:	fe 0f 21 66 	psubadd\.h r6,pc:t,pc:b
+
+[0-9a-f]* <paddsubs_sh>:
+ *[0-9a-f]*:	fe 0f 21 8f 	paddsubs\.sh pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 21 bc 	paddsubs\.sh r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 21 b5 	paddsubs\.sh r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 21 84 	paddsubs\.sh r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 21 be 	paddsubs\.sh lr,lr:t,lr:t
+ *[0-9a-f]*:	fc 00 21 a0 	paddsubs\.sh r0,lr:t,r0:b
+ *[0-9a-f]*:	e4 04 21 b9 	paddsubs\.sh r9,r2:t,r4:t
+ *[0-9a-f]*:	f2 0d 21 bc 	paddsubs\.sh r12,r9:t,sp:t
+
+[0-9a-f]* <psubadds_sh>:
+ *[0-9a-f]*:	fe 0f 21 cf 	psubadds\.sh pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 21 fc 	psubadds\.sh r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 21 f5 	psubadds\.sh r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 21 c4 	psubadds\.sh r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 21 fe 	psubadds\.sh lr,lr:t,lr:t
+ *[0-9a-f]*:	fc 01 21 df 	psubadds\.sh pc,lr:b,r1:t
+ *[0-9a-f]*:	e6 0c 21 cb 	psubadds\.sh r11,r3:b,r12:b
+ *[0-9a-f]*:	e4 08 21 fa 	psubadds\.sh r10,r2:t,r8:t
+
+[0-9a-f]* <paddsubs_uh>:
+ *[0-9a-f]*:	fe 0f 22 0f 	paddsubs\.uh pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 22 3c 	paddsubs\.uh r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 22 35 	paddsubs\.uh r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 22 04 	paddsubs\.uh r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 22 3e 	paddsubs\.uh lr,lr:t,lr:t
+ *[0-9a-f]*:	e4 03 22 09 	paddsubs\.uh r9,r2:b,r3:b
+ *[0-9a-f]*:	fa 07 22 1d 	paddsubs\.uh sp,sp:b,r7:t
+ *[0-9a-f]*:	e0 0a 22 1e 	paddsubs\.uh lr,r0:b,r10:t
+
+[0-9a-f]* <psubadds_uh>:
+ *[0-9a-f]*:	fe 0f 22 4f 	psubadds\.uh pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 22 7c 	psubadds\.uh r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 22 75 	psubadds\.uh r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 22 44 	psubadds\.uh r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 22 7e 	psubadds\.uh lr,lr:t,lr:t
+ *[0-9a-f]*:	f2 0f 22 7c 	psubadds\.uh r12,r9:t,pc:t
+ *[0-9a-f]*:	ec 08 22 48 	psubadds\.uh r8,r6:b,r8:b
+ *[0-9a-f]*:	f0 04 22 48 	psubadds\.uh r8,r8:b,r4:b
+
+[0-9a-f]* <paddsubh_sh>:
+ *[0-9a-f]*:	fe 0f 22 8f 	paddsubh\.sh pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 22 bc 	paddsubh\.sh r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 22 b5 	paddsubh\.sh r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 22 84 	paddsubh\.sh r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 22 be 	paddsubh\.sh lr,lr:t,lr:t
+ *[0-9a-f]*:	f2 09 22 a8 	paddsubh\.sh r8,r9:t,r9:b
+ *[0-9a-f]*:	fa 01 22 b0 	paddsubh\.sh r0,sp:t,r1:t
+ *[0-9a-f]*:	e2 00 22 93 	paddsubh\.sh r3,r1:b,r0:t
+
+[0-9a-f]* <psubaddh_sh>:
+ *[0-9a-f]*:	fe 0f 22 cf 	psubaddh\.sh pc,pc:b,pc:b
+ *[0-9a-f]*:	f8 0c 22 fc 	psubaddh\.sh r12,r12:t,r12:t
+ *[0-9a-f]*:	ea 05 22 f5 	psubaddh\.sh r5,r5:t,r5:t
+ *[0-9a-f]*:	e8 04 22 c4 	psubaddh\.sh r4,r4:b,r4:b
+ *[0-9a-f]*:	fc 0e 22 fe 	psubaddh\.sh lr,lr:t,lr:t
+ *[0-9a-f]*:	e6 0a 22 e7 	psubaddh\.sh r7,r3:t,r10:b
+ *[0-9a-f]*:	e4 01 22 f7 	psubaddh\.sh r7,r2:t,r1:t
+ *[0-9a-f]*:	e6 06 22 cb 	psubaddh\.sh r11,r3:b,r6:b
+
+[0-9a-f]* <padd_b>:
+ *[0-9a-f]*:	fe 0f 23 0f 	padd\.b pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 0c 	padd\.b r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 05 	padd\.b r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 04 	padd\.b r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 0e 	padd\.b lr,lr,lr
+ *[0-9a-f]*:	ec 0f 23 02 	padd\.b r2,r6,pc
+ *[0-9a-f]*:	f2 0c 23 08 	padd\.b r8,r9,r12
+ *[0-9a-f]*:	f8 03 23 05 	padd\.b r5,r12,r3
+
+[0-9a-f]* <psub_b>:
+ *[0-9a-f]*:	fe 0f 23 1f 	psub\.b pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 1c 	psub\.b r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 15 	psub\.b r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 14 	psub\.b r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 1e 	psub\.b lr,lr,lr
+ *[0-9a-f]*:	f8 0f 23 10 	psub\.b r0,r12,pc
+ *[0-9a-f]*:	fa 0a 23 17 	psub\.b r7,sp,r10
+ *[0-9a-f]*:	fa 0c 23 15 	psub\.b r5,sp,r12
+
+[0-9a-f]* <padds_sb>:
+ *[0-9a-f]*:	fe 0f 23 2f 	padds\.sb pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 2c 	padds\.sb r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 25 	padds\.sb r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 24 	padds\.sb r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 2e 	padds\.sb lr,lr,lr
+ *[0-9a-f]*:	f6 04 23 2d 	padds\.sb sp,r11,r4
+ *[0-9a-f]*:	f4 0b 23 2b 	padds\.sb r11,r10,r11
+ *[0-9a-f]*:	f8 06 23 25 	padds\.sb r5,r12,r6
+
+[0-9a-f]* <psubs_sb>:
+ *[0-9a-f]*:	fe 0f 23 3f 	psubs\.sb pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 3c 	psubs\.sb r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 35 	psubs\.sb r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 34 	psubs\.sb r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 3e 	psubs\.sb lr,lr,lr
+ *[0-9a-f]*:	ec 08 23 37 	psubs\.sb r7,r6,r8
+ *[0-9a-f]*:	f4 09 23 3c 	psubs\.sb r12,r10,r9
+ *[0-9a-f]*:	f6 00 23 3f 	psubs\.sb pc,r11,r0
+
+[0-9a-f]* <padds_ub>:
+ *[0-9a-f]*:	fe 0f 23 4f 	padds\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 4c 	padds\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 45 	padds\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 44 	padds\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 4e 	padds\.ub lr,lr,lr
+ *[0-9a-f]*:	e4 0b 23 43 	padds\.ub r3,r2,r11
+ *[0-9a-f]*:	f0 01 23 4a 	padds\.ub r10,r8,r1
+ *[0-9a-f]*:	f0 0a 23 4b 	padds\.ub r11,r8,r10
+
+[0-9a-f]* <psubs_ub>:
+ *[0-9a-f]*:	fe 0f 23 5f 	psubs\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 5c 	psubs\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 55 	psubs\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 54 	psubs\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 5e 	psubs\.ub lr,lr,lr
+ *[0-9a-f]*:	e4 07 23 50 	psubs\.ub r0,r2,r7
+ *[0-9a-f]*:	ea 03 23 5e 	psubs\.ub lr,r5,r3
+ *[0-9a-f]*:	ee 09 23 56 	psubs\.ub r6,r7,r9
+
+[0-9a-f]* <paddh_ub>:
+ *[0-9a-f]*:	fe 0f 23 6f 	paddh\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 6c 	paddh\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 65 	paddh\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 64 	paddh\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 6e 	paddh\.ub lr,lr,lr
+ *[0-9a-f]*:	e2 00 23 6e 	paddh\.ub lr,r1,r0
+ *[0-9a-f]*:	ee 07 23 62 	paddh\.ub r2,r7,r7
+ *[0-9a-f]*:	e2 02 23 62 	paddh\.ub r2,r1,r2
+
+[0-9a-f]* <psubh_ub>:
+ *[0-9a-f]*:	fe 0f 23 7f 	psubh\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 7c 	psubh\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 75 	psubh\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 74 	psubh\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 7e 	psubh\.ub lr,lr,lr
+ *[0-9a-f]*:	e2 06 23 70 	psubh\.ub r0,r1,r6
+ *[0-9a-f]*:	fc 0a 23 74 	psubh\.ub r4,lr,r10
+ *[0-9a-f]*:	f0 01 23 79 	psubh\.ub r9,r8,r1
+
+[0-9a-f]* <pmax_ub>:
+ *[0-9a-f]*:	fe 0f 23 8f 	pmax\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 8c 	pmax\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 85 	pmax\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 84 	pmax\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 8e 	pmax\.ub lr,lr,lr
+ *[0-9a-f]*:	e4 0b 23 8f 	pmax\.ub pc,r2,r11
+ *[0-9a-f]*:	e2 01 23 8c 	pmax\.ub r12,r1,r1
+ *[0-9a-f]*:	e4 00 23 85 	pmax\.ub r5,r2,r0
+
+[0-9a-f]* <pmax_sh>:
+ *[0-9a-f]*:	fe 0f 23 9f 	pmax\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 9c 	pmax\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 95 	pmax\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 94 	pmax\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 9e 	pmax\.sh lr,lr,lr
+ *[0-9a-f]*:	ec 0c 23 9e 	pmax\.sh lr,r6,r12
+ *[0-9a-f]*:	fe 05 23 92 	pmax\.sh r2,pc,r5
+ *[0-9a-f]*:	e4 07 23 9f 	pmax\.sh pc,r2,r7
+
+[0-9a-f]* <pmin_ub>:
+ *[0-9a-f]*:	fe 0f 23 af 	pmin\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 ac 	pmin\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 a5 	pmin\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 a4 	pmin\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 ae 	pmin\.ub lr,lr,lr
+ *[0-9a-f]*:	e2 05 23 a8 	pmin\.ub r8,r1,r5
+ *[0-9a-f]*:	f0 03 23 a1 	pmin\.ub r1,r8,r3
+ *[0-9a-f]*:	e4 07 23 a0 	pmin\.ub r0,r2,r7
+
+[0-9a-f]* <pmin_sh>:
+ *[0-9a-f]*:	fe 0f 23 bf 	pmin\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 bc 	pmin\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 b5 	pmin\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 b4 	pmin\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 be 	pmin\.sh lr,lr,lr
+ *[0-9a-f]*:	e8 0a 23 b8 	pmin\.sh r8,r4,r10
+ *[0-9a-f]*:	f4 0c 23 be 	pmin\.sh lr,r10,r12
+ *[0-9a-f]*:	ec 02 23 b2 	pmin\.sh r2,r6,r2
+
+[0-9a-f]* <pavg_ub>:
+ *[0-9a-f]*:	fe 0f 23 cf 	pavg\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 cc 	pavg\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 c5 	pavg\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 c4 	pavg\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 ce 	pavg\.ub lr,lr,lr
+ *[0-9a-f]*:	e2 06 23 c0 	pavg\.ub r0,r1,r6
+ *[0-9a-f]*:	e6 06 23 c8 	pavg\.ub r8,r3,r6
+ *[0-9a-f]*:	f8 0a 23 cf 	pavg\.ub pc,r12,r10
+
+[0-9a-f]* <pavg_sh>:
+ *[0-9a-f]*:	fe 0f 23 df 	pavg\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 23 dc 	pavg\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 23 d5 	pavg\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 23 d4 	pavg\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 23 de 	pavg\.sh lr,lr,lr
+ *[0-9a-f]*:	fe 0d 23 d9 	pavg\.sh r9,pc,sp
+ *[0-9a-f]*:	fa 03 23 df 	pavg\.sh pc,sp,r3
+ *[0-9a-f]*:	e2 09 23 d6 	pavg\.sh r6,r1,r9
+
+[0-9a-f]* <pabs_sb>:
+ *[0-9a-f]*:	e0 0f 23 ef 	pabs\.sb pc,pc
+ *[0-9a-f]*:	e0 0c 23 ec 	pabs\.sb r12,r12
+ *[0-9a-f]*:	e0 05 23 e5 	pabs\.sb r5,r5
+ *[0-9a-f]*:	e0 04 23 e4 	pabs\.sb r4,r4
+ *[0-9a-f]*:	e0 0e 23 ee 	pabs\.sb lr,lr
+ *[0-9a-f]*:	e0 06 23 eb 	pabs\.sb r11,r6
+ *[0-9a-f]*:	e0 09 23 ee 	pabs\.sb lr,r9
+ *[0-9a-f]*:	e0 07 23 ed 	pabs\.sb sp,r7
+
+[0-9a-f]* <pabs_sh>:
+ *[0-9a-f]*:	e0 0f 23 ff 	pabs\.sh pc,pc
+ *[0-9a-f]*:	e0 0c 23 fc 	pabs\.sh r12,r12
+ *[0-9a-f]*:	e0 05 23 f5 	pabs\.sh r5,r5
+ *[0-9a-f]*:	e0 04 23 f4 	pabs\.sh r4,r4
+ *[0-9a-f]*:	e0 0e 23 fe 	pabs\.sh lr,lr
+ *[0-9a-f]*:	e0 03 23 ff 	pabs\.sh pc,r3
+ *[0-9a-f]*:	e0 07 23 f5 	pabs\.sh r5,r7
+ *[0-9a-f]*:	e0 00 23 f4 	pabs\.sh r4,r0
+
+[0-9a-f]* <psad>:
+ *[0-9a-f]*:	fe 0f 24 0f 	psad pc,pc,pc
+ *[0-9a-f]*:	f8 0c 24 0c 	psad r12,r12,r12
+ *[0-9a-f]*:	ea 05 24 05 	psad r5,r5,r5
+ *[0-9a-f]*:	e8 04 24 04 	psad r4,r4,r4
+ *[0-9a-f]*:	fc 0e 24 0e 	psad lr,lr,lr
+ *[0-9a-f]*:	f6 0b 24 09 	psad r9,r11,r11
+ *[0-9a-f]*:	e8 0d 24 0e 	psad lr,r4,sp
+ *[0-9a-f]*:	e8 05 24 0e 	psad lr,r4,r5
+
+[0-9a-f]* <pasr_b>:
+ *[0-9a-f]*:	fe 00 24 1f 	pasr\.b pc,pc,0x0
+ *[0-9a-f]*:	f8 07 24 1c 	pasr\.b r12,r12,0x7
+ *[0-9a-f]*:	ea 04 24 15 	pasr\.b r5,r5,0x4
+ *[0-9a-f]*:	e8 03 24 14 	pasr\.b r4,r4,0x3
+ *[0-9a-f]*:	fc 01 24 1e 	pasr\.b lr,lr,0x1
+ *[0-9a-f]*:	ee 01 24 1f 	pasr\.b pc,r7,0x1
+ *[0-9a-f]*:	fc 06 24 1d 	pasr\.b sp,lr,0x6
+ *[0-9a-f]*:	e6 02 24 1d 	pasr\.b sp,r3,0x2
+
+[0-9a-f]* <plsl_b>:
+ *[0-9a-f]*:	fe 00 24 2f 	plsl\.b pc,pc,0x0
+ *[0-9a-f]*:	f8 07 24 2c 	plsl\.b r12,r12,0x7
+ *[0-9a-f]*:	ea 04 24 25 	plsl\.b r5,r5,0x4
+ *[0-9a-f]*:	e8 03 24 24 	plsl\.b r4,r4,0x3
+ *[0-9a-f]*:	fc 01 24 2e 	plsl\.b lr,lr,0x1
+ *[0-9a-f]*:	f6 04 24 22 	plsl\.b r2,r11,0x4
+ *[0-9a-f]*:	ea 07 24 28 	plsl\.b r8,r5,0x7
+ *[0-9a-f]*:	e0 02 24 2f 	plsl\.b pc,r0,0x2
+
+[0-9a-f]* <plsr_b>:
+ *[0-9a-f]*:	fe 00 24 3f 	plsr\.b pc,pc,0x0
+ *[0-9a-f]*:	f8 07 24 3c 	plsr\.b r12,r12,0x7
+ *[0-9a-f]*:	ea 04 24 35 	plsr\.b r5,r5,0x4
+ *[0-9a-f]*:	e8 03 24 34 	plsr\.b r4,r4,0x3
+ *[0-9a-f]*:	fc 01 24 3e 	plsr\.b lr,lr,0x1
+ *[0-9a-f]*:	e2 02 24 3c 	plsr\.b r12,r1,0x2
+ *[0-9a-f]*:	fe 07 24 36 	plsr\.b r6,pc,0x7
+ *[0-9a-f]*:	f6 02 24 3c 	plsr\.b r12,r11,0x2
+
+[0-9a-f]* <pasr_h>:
+ *[0-9a-f]*:	fe 00 24 4f 	pasr\.h pc,pc,0x0
+ *[0-9a-f]*:	f8 0f 24 4c 	pasr\.h r12,r12,0xf
+ *[0-9a-f]*:	ea 08 24 45 	pasr\.h r5,r5,0x8
+ *[0-9a-f]*:	e8 07 24 44 	pasr\.h r4,r4,0x7
+ *[0-9a-f]*:	fc 01 24 4e 	pasr\.h lr,lr,0x1
+ *[0-9a-f]*:	f6 0a 24 40 	pasr\.h r0,r11,0xa
+ *[0-9a-f]*:	ec 08 24 44 	pasr\.h r4,r6,0x8
+ *[0-9a-f]*:	e4 04 24 46 	pasr\.h r6,r2,0x4
+
+[0-9a-f]* <plsl_h>:
+ *[0-9a-f]*:	fe 00 24 5f 	plsl\.h pc,pc,0x0
+ *[0-9a-f]*:	f8 0f 24 5c 	plsl\.h r12,r12,0xf
+ *[0-9a-f]*:	ea 08 24 55 	plsl\.h r5,r5,0x8
+ *[0-9a-f]*:	e8 07 24 54 	plsl\.h r4,r4,0x7
+ *[0-9a-f]*:	fc 01 24 5e 	plsl\.h lr,lr,0x1
+ *[0-9a-f]*:	f4 09 24 55 	plsl\.h r5,r10,0x9
+ *[0-9a-f]*:	fc 08 24 5d 	plsl\.h sp,lr,0x8
+ *[0-9a-f]*:	fc 07 24 50 	plsl\.h r0,lr,0x7
+
+[0-9a-f]* <plsr_h>:
+ *[0-9a-f]*:	fe 00 24 6f 	plsr\.h pc,pc,0x0
+ *[0-9a-f]*:	f8 0f 24 6c 	plsr\.h r12,r12,0xf
+ *[0-9a-f]*:	ea 08 24 65 	plsr\.h r5,r5,0x8
+ *[0-9a-f]*:	e8 07 24 64 	plsr\.h r4,r4,0x7
+ *[0-9a-f]*:	fc 01 24 6e 	plsr\.h lr,lr,0x1
+ *[0-9a-f]*:	e0 0f 24 6b 	plsr\.h r11,r0,0xf
+ *[0-9a-f]*:	e6 03 24 6e 	plsr\.h lr,r3,0x3
+ *[0-9a-f]*:	fc 0a 24 68 	plsr\.h r8,lr,0xa
+
+[0-9a-f]* <packw_sh>:
+ *[0-9a-f]*:	fe 0f 24 7f 	packw\.sh pc,pc,pc
+ *[0-9a-f]*:	f8 0c 24 7c 	packw\.sh r12,r12,r12
+ *[0-9a-f]*:	ea 05 24 75 	packw\.sh r5,r5,r5
+ *[0-9a-f]*:	e8 04 24 74 	packw\.sh r4,r4,r4
+ *[0-9a-f]*:	fc 0e 24 7e 	packw\.sh lr,lr,lr
+ *[0-9a-f]*:	f6 0a 24 7d 	packw\.sh sp,r11,r10
+ *[0-9a-f]*:	e4 0c 24 78 	packw\.sh r8,r2,r12
+ *[0-9a-f]*:	e2 05 24 78 	packw\.sh r8,r1,r5
+
+[0-9a-f]* <punpckub_h>:
+ *[0-9a-f]*:	fe 00 24 8f 	punpckub\.h pc,pc:b
+ *[0-9a-f]*:	f8 00 24 9c 	punpckub\.h r12,r12:t
+ *[0-9a-f]*:	ea 00 24 95 	punpckub\.h r5,r5:t
+ *[0-9a-f]*:	e8 00 24 84 	punpckub\.h r4,r4:b
+ *[0-9a-f]*:	fc 00 24 9e 	punpckub\.h lr,lr:t
+ *[0-9a-f]*:	e2 00 24 96 	punpckub\.h r6,r1:t
+ *[0-9a-f]*:	ea 00 24 8e 	punpckub\.h lr,r5:b
+ *[0-9a-f]*:	e4 00 24 9e 	punpckub\.h lr,r2:t
+
+[0-9a-f]* <punpcksb_h>:
+ *[0-9a-f]*:	fe 00 24 af 	punpcksb\.h pc,pc:b
+ *[0-9a-f]*:	f8 00 24 bc 	punpcksb\.h r12,r12:t
+ *[0-9a-f]*:	ea 00 24 b5 	punpcksb\.h r5,r5:t
+ *[0-9a-f]*:	e8 00 24 a4 	punpcksb\.h r4,r4:b
+ *[0-9a-f]*:	fc 00 24 be 	punpcksb\.h lr,lr:t
+ *[0-9a-f]*:	ee 00 24 b4 	punpcksb\.h r4,r7:t
+ *[0-9a-f]*:	fc 00 24 a6 	punpcksb\.h r6,lr:b
+ *[0-9a-f]*:	f8 00 24 bc 	punpcksb\.h r12,r12:t
+
+[0-9a-f]* <packsh_ub>:
+ *[0-9a-f]*:	fe 0f 24 cf 	packsh\.ub pc,pc,pc
+ *[0-9a-f]*:	f8 0c 24 cc 	packsh\.ub r12,r12,r12
+ *[0-9a-f]*:	ea 05 24 c5 	packsh\.ub r5,r5,r5
+ *[0-9a-f]*:	e8 04 24 c4 	packsh\.ub r4,r4,r4
+ *[0-9a-f]*:	fc 0e 24 ce 	packsh\.ub lr,lr,lr
+ *[0-9a-f]*:	ec 03 24 c3 	packsh\.ub r3,r6,r3
+ *[0-9a-f]*:	e0 03 24 c8 	packsh\.ub r8,r0,r3
+ *[0-9a-f]*:	e6 0e 24 c9 	packsh\.ub r9,r3,lr
+
+[0-9a-f]* <packsh_sb>:
+ *[0-9a-f]*:	fe 0f 24 df 	packsh\.sb pc,pc,pc
+ *[0-9a-f]*:	f8 0c 24 dc 	packsh\.sb r12,r12,r12
+ *[0-9a-f]*:	ea 05 24 d5 	packsh\.sb r5,r5,r5
+ *[0-9a-f]*:	e8 04 24 d4 	packsh\.sb r4,r4,r4
+ *[0-9a-f]*:	fc 0e 24 de 	packsh\.sb lr,lr,lr
+ *[0-9a-f]*:	f0 01 24 d6 	packsh\.sb r6,r8,r1
+ *[0-9a-f]*:	f2 08 24 de 	packsh\.sb lr,r9,r8
+ *[0-9a-f]*:	ec 06 24 dd 	packsh\.sb sp,r6,r6
+
+[0-9a-f]* <andl>:
+ *[0-9a-f]*:	e0 1f 00 00 	andl pc,0x0
+ *[0-9a-f]*:	e0 1c ff ff 	andl r12,0xffff
+ *[0-9a-f]*:	e0 15 80 00 	andl r5,0x8000
+ *[0-9a-f]*:	e0 14 7f ff 	andl r4,0x7fff
+ *[0-9a-f]*:	e0 1e 00 01 	andl lr,0x1
+ *[0-9a-f]*:	e0 1f 5a 58 	andl pc,0x5a58
+ *[0-9a-f]*:	e0 18 b8 9e 	andl r8,0xb89e
+ *[0-9a-f]*:	e0 17 35 97 	andl r7,0x3597
+
+[0-9a-f]* <andl_coh>:
+ *[0-9a-f]*:	e2 1f 00 00 	andl pc,0x0,COH
+ *[0-9a-f]*:	e2 1c ff ff 	andl r12,0xffff,COH
+ *[0-9a-f]*:	e2 15 80 00 	andl r5,0x8000,COH
+ *[0-9a-f]*:	e2 14 7f ff 	andl r4,0x7fff,COH
+ *[0-9a-f]*:	e2 1e 00 01 	andl lr,0x1,COH
+ *[0-9a-f]*:	e2 16 58 e1 	andl r6,0x58e1,COH
+ *[0-9a-f]*:	e2 10 9e cd 	andl r0,0x9ecd,COH
+ *[0-9a-f]*:	e2 14 bd c4 	andl r4,0xbdc4,COH
+
+[0-9a-f]* <andh>:
+ *[0-9a-f]*:	e4 1f 00 00 	andh pc,0x0
+ *[0-9a-f]*:	e4 1c ff ff 	andh r12,0xffff
+ *[0-9a-f]*:	e4 15 80 00 	andh r5,0x8000
+ *[0-9a-f]*:	e4 14 7f ff 	andh r4,0x7fff
+ *[0-9a-f]*:	e4 1e 00 01 	andh lr,0x1
+ *[0-9a-f]*:	e4 1c cc 58 	andh r12,0xcc58
+ *[0-9a-f]*:	e4 13 21 e3 	andh r3,0x21e3
+ *[0-9a-f]*:	e4 12 a7 eb 	andh r2,0xa7eb
+
+[0-9a-f]* <andh_coh>:
+ *[0-9a-f]*:	e6 1f 00 00 	andh pc,0x0,COH
+ *[0-9a-f]*:	e6 1c ff ff 	andh r12,0xffff,COH
+ *[0-9a-f]*:	e6 15 80 00 	andh r5,0x8000,COH
+ *[0-9a-f]*:	e6 14 7f ff 	andh r4,0x7fff,COH
+ *[0-9a-f]*:	e6 1e 00 01 	andh lr,0x1,COH
+ *[0-9a-f]*:	e6 1b 86 0d 	andh r11,0x860d,COH
+ *[0-9a-f]*:	e6 18 ce f6 	andh r8,0xcef6,COH
+ *[0-9a-f]*:	e6 1a 5c 83 	andh r10,0x5c83,COH
+
+[0-9a-f]* <orl>:
+ *[0-9a-f]*:	e8 1f 00 00 	orl pc,0x0
+ *[0-9a-f]*:	e8 1c ff ff 	orl r12,0xffff
+ *[0-9a-f]*:	e8 15 80 00 	orl r5,0x8000
+ *[0-9a-f]*:	e8 14 7f ff 	orl r4,0x7fff
+ *[0-9a-f]*:	e8 1e 00 01 	orl lr,0x1
+ *[0-9a-f]*:	e8 1d 41 7e 	orl sp,0x417e
+ *[0-9a-f]*:	e8 10 52 bd 	orl r0,0x52bd
+ *[0-9a-f]*:	e8 1f ac 47 	orl pc,0xac47
+
+[0-9a-f]* <orh>:
+ *[0-9a-f]*:	ea 1f 00 00 	orh pc,0x0
+ *[0-9a-f]*:	ea 1c ff ff 	orh r12,0xffff
+ *[0-9a-f]*:	ea 15 80 00 	orh r5,0x8000
+ *[0-9a-f]*:	ea 14 7f ff 	orh r4,0x7fff
+ *[0-9a-f]*:	ea 1e 00 01 	orh lr,0x1
+ *[0-9a-f]*:	ea 18 6e 7d 	orh r8,0x6e7d
+ *[0-9a-f]*:	ea 1c 77 1c 	orh r12,0x771c
+ *[0-9a-f]*:	ea 11 ea 1a 	orh r1,0xea1a
+
+[0-9a-f]* <eorl>:
+ *[0-9a-f]*:	ec 1f 00 00 	eorl pc,0x0
+ *[0-9a-f]*:	ec 1c ff ff 	eorl r12,0xffff
+ *[0-9a-f]*:	ec 15 80 00 	eorl r5,0x8000
+ *[0-9a-f]*:	ec 14 7f ff 	eorl r4,0x7fff
+ *[0-9a-f]*:	ec 1e 00 01 	eorl lr,0x1
+ *[0-9a-f]*:	ec 14 c7 b9 	eorl r4,0xc7b9
+ *[0-9a-f]*:	ec 16 fb dd 	eorl r6,0xfbdd
+ *[0-9a-f]*:	ec 11 51 b1 	eorl r1,0x51b1
+
+[0-9a-f]* <eorh>:
+ *[0-9a-f]*:	ee 1f 00 00 	eorh pc,0x0
+ *[0-9a-f]*:	ee 1c ff ff 	eorh r12,0xffff
+ *[0-9a-f]*:	ee 15 80 00 	eorh r5,0x8000
+ *[0-9a-f]*:	ee 14 7f ff 	eorh r4,0x7fff
+ *[0-9a-f]*:	ee 1e 00 01 	eorh lr,0x1
+ *[0-9a-f]*:	ee 10 2d d4 	eorh r0,0x2dd4
+ *[0-9a-f]*:	ee 1a 94 b5 	eorh r10,0x94b5
+ *[0-9a-f]*:	ee 19 df 2a 	eorh r9,0xdf2a
+
+[0-9a-f]* <mcall>:
+ *[0-9a-f]*:	f0 1f 00 00 	mcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	f0 1c ff ff 	mcall r12\[-4\]
+ *[0-9a-f]*:	f0 15 80 00 	mcall r5\[-131072\]
+ *[0-9a-f]*:	f0 14 7f ff 	mcall r4\[131068\]
+ *[0-9a-f]*:	f0 1e 00 01 	mcall lr\[4\]
+ *[0-9a-f]*:	f0 1d 3b bf 	mcall sp\[61180\]
+ *[0-9a-f]*:	f0 14 dd d2 	mcall r4\[-35000\]
+ *[0-9a-f]*:	f0 10 09 b1 	mcall r0\[9924\]
+
+[0-9a-f]* <pref>:
+ *[0-9a-f]*:	f2 1f 00 00 	pref pc\[0\]
+ *[0-9a-f]*:	f2 1c ff ff 	pref r12\[-1\]
+ *[0-9a-f]*:	f2 15 80 00 	pref r5\[-32768\]
+ *[0-9a-f]*:	f2 14 7f ff 	pref r4\[32767\]
+ *[0-9a-f]*:	f2 1e 00 01 	pref lr\[1\]
+ *[0-9a-f]*:	f2 17 1e 44 	pref r7\[7748\]
+ *[0-9a-f]*:	f2 17 e1 ed 	pref r7\[-7699\]
+ *[0-9a-f]*:	f2 12 9a dc 	pref r2\[-25892\]
+
+[0-9a-f]* <cache>:
+ *[0-9a-f]*:	f4 1f 00 00 	cache pc\[0\],0x0
+ *[0-9a-f]*:	f4 1c ff ff 	cache r12\[-1\],0x1f
+ *[0-9a-f]*:	f4 15 84 00 	cache r5\[-1024\],0x10
+ *[0-9a-f]*:	f4 14 7b ff 	cache r4\[1023\],0xf
+ *[0-9a-f]*:	f4 1e 08 01 	cache lr\[1\],0x1
+ *[0-9a-f]*:	f4 13 8c 3c 	cache r3\[-964\],0x11
+ *[0-9a-f]*:	f4 14 b6 89 	cache r4\[-375\],0x16
+ *[0-9a-f]*:	f4 13 8c 88 	cache r3\[-888\],0x11
+
+[0-9a-f]* <sub4>:
+ *[0-9a-f]*:	20 0f       	sub pc,0
+ *[0-9a-f]*:	2f fc       	sub r12,-1
+ *[0-9a-f]*:	f0 25 00 00 	sub r5,-1048576
+ *[0-9a-f]*:	ee 34 ff ff 	sub r4,1048575
+ *[0-9a-f]*:	20 1e       	sub lr,1
+ *[0-9a-f]*:	f6 22 8d 6c 	sub r2,-619156
+ *[0-9a-f]*:	e6 3e 0a cd 	sub lr,461517
+ *[0-9a-f]*:	fc 38 2d 25 	sub r8,-185051
+
+[0-9a-f]* <cp3>:
+ *[0-9a-f]*:	58 0f       	cp.w pc,0
+ *[0-9a-f]*:	5b fc       	cp.w r12,-1
+ *[0-9a-f]*:	f0 45 00 00 	cp.w r5,-1048576
+ *[0-9a-f]*:	ee 54 ff ff 	cp.w r4,1048575
+ *[0-9a-f]*:	58 1e       	cp.w lr,1
+ *[0-9a-f]*:	e0 51 e4 ae 	cp.w r1,124078
+ *[0-9a-f]*:	fa 40 37 e3 	cp.w r0,-378909
+ *[0-9a-f]*:	fc 44 4a 14 	cp.w r4,-243180
+
+[0-9a-f]* <mov2>:
+ *[0-9a-f]*:	30 0f       	mov pc,0
+ *[0-9a-f]*:	3f fc       	mov r12,-1
+ *[0-9a-f]*:	f0 65 00 00 	mov r5,-1048576
+ *[0-9a-f]*:	ee 74 ff ff 	mov r4,1048575
+ *[0-9a-f]*:	30 1e       	mov lr,1
+ *[0-9a-f]*:	fa 75 29 a3 	mov r5,-317021
+ *[0-9a-f]*:	f4 6d 91 94 	mov sp,-749164
+ *[0-9a-f]*:	ee 65 58 93 	mov r5,940179
+
+[0-9a-f]* <brc2>:
+ *[0-9a-f]*:	c0 00       	breq [0-9a-f]* <.*>
+ *[0-9a-f]*:	fe 9f ff ff 	bral [0-9a-f]* <.*>
+ *[0-9a-f]*:	f0 88 00 00 	brls [0-9a-f]* <.*>
+ *[0-9a-f]*:	ee 97 ff ff 	brpl [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 11       	brne [0-9a-f]* <.*>
+ *[0-9a-f]*:	f2 8b 4a 4d 	brhi [0-9a-f]* <.*>
+ *[0-9a-f]*:	ea 8e 14 cc 	brqs [0-9a-f]* <.*>
+ *[0-9a-f]*:	fa 98 98 33 	brls [0-9a-f]* <.*>
+
+[0-9a-f]* <rcall2>:
+ *[0-9a-f]*:	c0 0c       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	cf ff       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	f0 a0 00 00 	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	ee b0 ff ff 	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	c0 1c       	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	e2 b0 ca 5a 	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	e8 a0 47 52 	rcall [0-9a-f]* <.*>
+ *[0-9a-f]*:	fe b0 fd ef 	rcall [0-9a-f]* <.*>
+
+[0-9a-f]* <sub5>:
+ *[0-9a-f]*:	fe cf 00 00 	sub pc,pc,0
+ *[0-9a-f]*:	f8 cc ff ff 	sub r12,r12,-1
+ *[0-9a-f]*:	ea c5 80 00 	sub r5,r5,-32768
+ *[0-9a-f]*:	e8 c4 7f ff 	sub r4,r4,32767
+ *[0-9a-f]*:	fc ce 00 01 	sub lr,lr,1
+ *[0-9a-f]*:	fe cf ce 38 	sub pc,pc,-12744
+ *[0-9a-f]*:	ee c7 95 1b 	sub r7,r7,-27365
+ *[0-9a-f]*:	f2 c2 bc 32 	sub r2,r9,-17358
+
+[0-9a-f]* <satsub_w2>:
+ *[0-9a-f]*:	fe df 00 00 	satsub\.w pc,pc,0
+ *[0-9a-f]*:	f8 dc ff ff 	satsub\.w r12,r12,-1
+ *[0-9a-f]*:	ea d5 80 00 	satsub\.w r5,r5,-32768
+ *[0-9a-f]*:	e8 d4 7f ff 	satsub\.w r4,r4,32767
+ *[0-9a-f]*:	fc de 00 01 	satsub\.w lr,lr,1
+ *[0-9a-f]*:	fc d2 f8 29 	satsub\.w r2,lr,-2007
+ *[0-9a-f]*:	f8 d7 fc f0 	satsub\.w r7,r12,-784
+ *[0-9a-f]*:	ee d4 5a 8c 	satsub\.w r4,r7,23180
+
+[0-9a-f]* <ld_d4>:
+ *[0-9a-f]*:	fe e0 00 00 	ld\.d r0,pc\[0\]
+ *[0-9a-f]*:	f8 ee ff ff 	ld\.d lr,r12\[-1\]
+ *[0-9a-f]*:	ea e8 80 00 	ld\.d r8,r5\[-32768\]
+ *[0-9a-f]*:	e8 e6 7f ff 	ld\.d r6,r4\[32767\]
+ *[0-9a-f]*:	fc e2 00 01 	ld\.d r2,lr\[1\]
+ *[0-9a-f]*:	f6 ee 39 c0 	ld\.d lr,r11\[14784\]
+ *[0-9a-f]*:	f2 e6 b6 27 	ld\.d r6,r9\[-18905\]
+ *[0-9a-f]*:	e6 e2 e7 2d 	ld\.d r2,r3\[-6355\]
+
+[0-9a-f]* <ld_w4>:
+ *[0-9a-f]*:	7e 0f       	ld\.w pc,pc\[0x0\]
+ *[0-9a-f]*:	f8 fc ff ff 	ld\.w r12,r12\[-1\]
+ *[0-9a-f]*:	ea f5 80 00 	ld\.w r5,r5\[-32768\]
+ *[0-9a-f]*:	e8 f4 7f ff 	ld\.w r4,r4\[32767\]
+ *[0-9a-f]*:	fc fe 00 01 	ld\.w lr,lr\[1\]
+ *[0-9a-f]*:	f8 f0 a9 8b 	ld\.w r0,r12\[-22133\]
+ *[0-9a-f]*:	fe fd af d7 	ld\.w sp,pc\[-20521\]
+ *[0-9a-f]*:	d7 03       	nop
+
+[0-9a-f]* <ld_sh4>:
+ *[0-9a-f]*:	9e 0f       	ld\.sh pc,pc\[0x0\]
+ *[0-9a-f]*:	f9 0c ff ff 	ld\.sh r12,r12\[-1\]
+ *[0-9a-f]*:	eb 05 80 00 	ld\.sh r5,r5\[-32768\]
+ *[0-9a-f]*:	e9 04 7f ff 	ld\.sh r4,r4\[32767\]
+ *[0-9a-f]*:	fd 0e 00 01 	ld\.sh lr,lr\[1\]
+ *[0-9a-f]*:	f5 06 78 d2 	ld\.sh r6,r10\[30930\]
+ *[0-9a-f]*:	f5 06 55 d5 	ld\.sh r6,r10\[21973\]
+ *[0-9a-f]*:	d7 03       	nop
+
+[0-9a-f]* <ld_uh4>:
+ *[0-9a-f]*:	9e 8f       	ld\.uh pc,pc\[0x0\]
+ *[0-9a-f]*:	f9 1c ff ff 	ld\.uh r12,r12\[-1\]
+ *[0-9a-f]*:	eb 15 80 00 	ld\.uh r5,r5\[-32768\]
+ *[0-9a-f]*:	e9 14 7f ff 	ld\.uh r4,r4\[32767\]
+ *[0-9a-f]*:	fd 1e 00 01 	ld\.uh lr,lr\[1\]
+ *[0-9a-f]*:	f3 11 cb d6 	ld\.uh r1,r9\[-13354\]
+ *[0-9a-f]*:	f7 1e 53 59 	ld\.uh lr,r11\[21337\]
+ *[0-9a-f]*:	d7 03       	nop
+
+[0-9a-f]* <ld_sb1>:
+ *[0-9a-f]*:	ff 2f 00 00 	ld\.sb pc,pc\[0\]
+ *[0-9a-f]*:	f9 2c ff ff 	ld\.sb r12,r12\[-1\]
+ *[0-9a-f]*:	eb 25 80 00 	ld\.sb r5,r5\[-32768\]
+ *[0-9a-f]*:	e9 24 7f ff 	ld\.sb r4,r4\[32767\]
+ *[0-9a-f]*:	fd 2e 00 01 	ld\.sb lr,lr\[1\]
+ *[0-9a-f]*:	fb 27 90 09 	ld\.sb r7,sp\[-28663\]
+ *[0-9a-f]*:	e3 22 e9 09 	ld\.sb r2,r1\[-5879\]
+ *[0-9a-f]*:	e7 2c 49 2e 	ld\.sb r12,r3\[18734\]
+
+[0-9a-f]* <ld_ub4>:
+ *[0-9a-f]*:	1f 8f       	ld\.ub pc,pc\[0x0\]
+ *[0-9a-f]*:	f9 3c ff ff 	ld\.ub r12,r12\[-1\]
+ *[0-9a-f]*:	eb 35 80 00 	ld\.ub r5,r5\[-32768\]
+ *[0-9a-f]*:	e9 34 7f ff 	ld\.ub r4,r4\[32767\]
+ *[0-9a-f]*:	1d 9e       	ld\.ub lr,lr\[0x1\]
+ *[0-9a-f]*:	e9 3f 20 55 	ld\.ub pc,r4\[8277\]
+ *[0-9a-f]*:	f9 35 4a e4 	ld\.ub r5,r12\[19172\]
+ *[0-9a-f]*:	fd 3a 66 eb 	ld\.ub r10,lr\[26347\]
+
+[0-9a-f]* <st_d4>:
+ *[0-9a-f]*:	fe e1 00 00 	st\.d pc\[0\],r0
+ *[0-9a-f]*:	f8 ef ff ff 	st\.d r12\[-1\],lr
+ *[0-9a-f]*:	ea e9 80 00 	st\.d r5\[-32768\],r8
+ *[0-9a-f]*:	e8 e7 7f ff 	st\.d r4\[32767\],r6
+ *[0-9a-f]*:	fc e3 00 01 	st\.d lr\[1\],r2
+ *[0-9a-f]*:	ea eb 33 90 	st\.d r5\[13200\],r10
+ *[0-9a-f]*:	ea eb 24 88 	st\.d r5\[9352\],r10
+ *[0-9a-f]*:	ea e5 7e 75 	st\.d r5\[32373\],r4
+
+[0-9a-f]* <st_w4>:
+ *[0-9a-f]*:	9f 0f       	st\.w pc\[0x0\],pc
+ *[0-9a-f]*:	f9 4c ff ff 	st\.w r12\[-1\],r12
+ *[0-9a-f]*:	eb 45 80 00 	st\.w r5\[-32768\],r5
+ *[0-9a-f]*:	e9 44 7f ff 	st\.w r4\[32767\],r4
+ *[0-9a-f]*:	fd 4e 00 01 	st\.w lr\[1\],lr
+ *[0-9a-f]*:	fb 47 17 f8 	st\.w sp\[6136\],r7
+ *[0-9a-f]*:	ed 4c 69 cf 	st\.w r6\[27087\],r12
+ *[0-9a-f]*:	d7 03       	nop
+
+[0-9a-f]* <st_h4>:
+ *[0-9a-f]*:	be 0f       	st\.h pc\[0x0\],pc
+ *[0-9a-f]*:	f9 5c ff ff 	st\.h r12\[-1\],r12
+ *[0-9a-f]*:	eb 55 80 00 	st\.h r5\[-32768\],r5
+ *[0-9a-f]*:	e9 54 7f ff 	st\.h r4\[32767\],r4
+ *[0-9a-f]*:	fd 5e 00 01 	st\.h lr\[1\],lr
+ *[0-9a-f]*:	e9 57 d9 16 	st\.h r4\[-9962\],r7
+ *[0-9a-f]*:	f3 53 c0 86 	st\.h r9\[-16250\],r3
+ *[0-9a-f]*:	d7 03       	nop
+
+[0-9a-f]* <st_b4>:
+ *[0-9a-f]*:	be 8f       	st\.b pc\[0x0\],pc
+ *[0-9a-f]*:	f9 6c ff ff 	st\.b r12\[-1\],r12
+ *[0-9a-f]*:	eb 65 80 00 	st\.b r5\[-32768\],r5
+ *[0-9a-f]*:	e9 64 7f ff 	st\.b r4\[32767\],r4
+ *[0-9a-f]*:	bc 9e       	st\.b lr\[0x1\],lr
+ *[0-9a-f]*:	f9 66 75 96 	st\.b r12\[30102\],r6
+ *[0-9a-f]*:	eb 61 71 31 	st\.b r5\[28977\],r1
+ *[0-9a-f]*:	e1 61 15 5e 	st\.b r0\[5470\],r1
+
+[0-9a-f]* <mfsr>:
+ *[0-9a-f]*:	e1 bf 00 00 	mfsr pc,0x0
+ *[0-9a-f]*:	e1 bc 00 ff 	mfsr r12,0x3fc
+ *[0-9a-f]*:	e1 b5 00 80 	mfsr r5,0x200
+ *[0-9a-f]*:	e1 b4 00 7f 	mfsr r4,0x1fc
+ *[0-9a-f]*:	e1 be 00 01 	mfsr lr,0x4
+ *[0-9a-f]*:	e1 b2 00 ae 	mfsr r2,0x2b8
+ *[0-9a-f]*:	e1 b4 00 41 	mfsr r4,0x104
+ *[0-9a-f]*:	e1 ba 00 fe 	mfsr r10,0x3f8
+
+[0-9a-f]* <mtsr>:
+ *[0-9a-f]*:	e3 bf 00 00 	mtsr 0x0,pc
+ *[0-9a-f]*:	e3 bc 00 ff 	mtsr 0x3fc,r12
+ *[0-9a-f]*:	e3 b5 00 80 	mtsr 0x200,r5
+ *[0-9a-f]*:	e3 b4 00 7f 	mtsr 0x1fc,r4
+ *[0-9a-f]*:	e3 be 00 01 	mtsr 0x4,lr
+ *[0-9a-f]*:	e3 ba 00 38 	mtsr 0xe0,r10
+ *[0-9a-f]*:	e3 bc 00 d1 	mtsr 0x344,r12
+ *[0-9a-f]*:	e3 b9 00 4c 	mtsr 0x130,r9
+
+[0-9a-f]* <mfdr>:
+ *[0-9a-f]*:	e5 bf 00 00 	mfdr pc,0x0
+ *[0-9a-f]*:	e5 bc 00 ff 	mfdr r12,0x3fc
+ *[0-9a-f]*:	e5 b5 00 80 	mfdr r5,0x200
+ *[0-9a-f]*:	e5 b4 00 7f 	mfdr r4,0x1fc
+ *[0-9a-f]*:	e5 be 00 01 	mfdr lr,0x4
+ *[0-9a-f]*:	e5 b6 00 e9 	mfdr r6,0x3a4
+ *[0-9a-f]*:	e5 b5 00 09 	mfdr r5,0x24
+ *[0-9a-f]*:	e5 b9 00 4b 	mfdr r9,0x12c
+
+[0-9a-f]* <mtdr>:
+ *[0-9a-f]*:	e7 bf 00 00 	mtdr 0x0,pc
+ *[0-9a-f]*:	e7 bc 00 ff 	mtdr 0x3fc,r12
+ *[0-9a-f]*:	e7 b5 00 80 	mtdr 0x200,r5
+ *[0-9a-f]*:	e7 b4 00 7f 	mtdr 0x1fc,r4
+ *[0-9a-f]*:	e7 be 00 01 	mtdr 0x4,lr
+ *[0-9a-f]*:	e7 b8 00 2d 	mtdr 0xb4,r8
+ *[0-9a-f]*:	e7 ba 00 b4 	mtdr 0x2d0,r10
+ *[0-9a-f]*:	e7 be 00 66 	mtdr 0x198,lr
+
+[0-9a-f]* <sleep>:
+ *[0-9a-f]*:	e9 b0 00 00 	sleep 0x0
+ *[0-9a-f]*:	e9 b0 00 ff 	sleep 0xff
+ *[0-9a-f]*:	e9 b0 00 80 	sleep 0x80
+ *[0-9a-f]*:	e9 b0 00 7f 	sleep 0x7f
+ *[0-9a-f]*:	e9 b0 00 01 	sleep 0x1
+ *[0-9a-f]*:	e9 b0 00 fe 	sleep 0xfe
+ *[0-9a-f]*:	e9 b0 00 0f 	sleep 0xf
+ *[0-9a-f]*:	e9 b0 00 2b 	sleep 0x2b
+
+[0-9a-f]* <sync>:
+ *[0-9a-f]*:	eb b0 00 00 	sync 0x0
+ *[0-9a-f]*:	eb b0 00 ff 	sync 0xff
+ *[0-9a-f]*:	eb b0 00 80 	sync 0x80
+ *[0-9a-f]*:	eb b0 00 7f 	sync 0x7f
+ *[0-9a-f]*:	eb b0 00 01 	sync 0x1
+ *[0-9a-f]*:	eb b0 00 a6 	sync 0xa6
+ *[0-9a-f]*:	eb b0 00 e6 	sync 0xe6
+ *[0-9a-f]*:	eb b0 00 b4 	sync 0xb4
+
+[0-9a-f]* <bld>:
+ *[0-9a-f]*:	ed bf 00 00 	bld pc,0x0
+ *[0-9a-f]*:	ed bc 00 1f 	bld r12,0x1f
+ *[0-9a-f]*:	ed b5 00 10 	bld r5,0x10
+ *[0-9a-f]*:	ed b4 00 0f 	bld r4,0xf
+ *[0-9a-f]*:	ed be 00 01 	bld lr,0x1
+ *[0-9a-f]*:	ed b9 00 0f 	bld r9,0xf
+ *[0-9a-f]*:	ed b0 00 04 	bld r0,0x4
+ *[0-9a-f]*:	ed be 00 1a 	bld lr,0x1a
+
+[0-9a-f]* <bst>:
+ *[0-9a-f]*:	ef bf 00 00 	bst pc,0x0
+ *[0-9a-f]*:	ef bc 00 1f 	bst r12,0x1f
+ *[0-9a-f]*:	ef b5 00 10 	bst r5,0x10
+ *[0-9a-f]*:	ef b4 00 0f 	bst r4,0xf
+ *[0-9a-f]*:	ef be 00 01 	bst lr,0x1
+ *[0-9a-f]*:	ef ba 00 1c 	bst r10,0x1c
+ *[0-9a-f]*:	ef b0 00 03 	bst r0,0x3
+ *[0-9a-f]*:	ef bd 00 02 	bst sp,0x2
+
+[0-9a-f]* <sats>:
+ *[0-9a-f]*:	f1 bf 00 00 	sats pc,0x0
+ *[0-9a-f]*:	f1 bc 03 ff 	sats r12>>0x1f,0x1f
+ *[0-9a-f]*:	f1 b5 02 10 	sats r5>>0x10,0x10
+ *[0-9a-f]*:	f1 b4 01 ef 	sats r4>>0xf,0xf
+ *[0-9a-f]*:	f1 be 00 21 	sats lr>>0x1,0x1
+ *[0-9a-f]*:	f1 ba 02 63 	sats r10>>0x3,0x13
+ *[0-9a-f]*:	f1 ba 03 42 	sats r10>>0x2,0x1a
+ *[0-9a-f]*:	f1 b1 00 34 	sats r1>>0x14,0x1
+
+[0-9a-f]* <satu>:
+ *[0-9a-f]*:	f1 bf 04 00 	satu pc,0x0
+ *[0-9a-f]*:	f1 bc 07 ff 	satu r12>>0x1f,0x1f
+ *[0-9a-f]*:	f1 b5 06 10 	satu r5>>0x10,0x10
+ *[0-9a-f]*:	f1 b4 05 ef 	satu r4>>0xf,0xf
+ *[0-9a-f]*:	f1 be 04 21 	satu lr>>0x1,0x1
+ *[0-9a-f]*:	f1 bf 04 e5 	satu pc>>0x5,0x7
+ *[0-9a-f]*:	f1 b7 04 a5 	satu r7>>0x5,0x5
+ *[0-9a-f]*:	f1 b2 06 7a 	satu r2>>0x1a,0x13
+
+[0-9a-f]* <satrnds>:
+ *[0-9a-f]*:	f3 bf 00 00 	satrnds pc,0x0
+ *[0-9a-f]*:	f3 bc 03 ff 	satrnds r12>>0x1f,0x1f
+ *[0-9a-f]*:	f3 b5 02 10 	satrnds r5>>0x10,0x10
+ *[0-9a-f]*:	f3 b4 01 ef 	satrnds r4>>0xf,0xf
+ *[0-9a-f]*:	f3 be 00 21 	satrnds lr>>0x1,0x1
+ *[0-9a-f]*:	f3 b0 02 75 	satrnds r0>>0x15,0x13
+ *[0-9a-f]*:	f3 bd 00 40 	satrnds sp,0x2
+ *[0-9a-f]*:	f3 b7 03 a6 	satrnds r7>>0x6,0x1d
+
+[0-9a-f]* <satrndu>:
+ *[0-9a-f]*:	f3 bf 04 00 	satrndu pc,0x0
+ *[0-9a-f]*:	f3 bc 07 ff 	satrndu r12>>0x1f,0x1f
+ *[0-9a-f]*:	f3 b5 06 10 	satrndu r5>>0x10,0x10
+ *[0-9a-f]*:	f3 b4 05 ef 	satrndu r4>>0xf,0xf
+ *[0-9a-f]*:	f3 be 04 21 	satrndu lr>>0x1,0x1
+ *[0-9a-f]*:	f3 bc 07 40 	satrndu r12,0x1a
+ *[0-9a-f]*:	f3 b4 04 75 	satrndu r4>>0x15,0x3
+ *[0-9a-f]*:	f3 ba 06 03 	satrndu r10>>0x3,0x10
+
+[0-9a-f]* <subfc>:
+ *[0-9a-f]*:	f5 bf 00 00 	subfeq pc,0
+ *[0-9a-f]*:	f5 bc 0f ff 	subfal r12,-1
+ *[0-9a-f]*:	f5 b5 08 80 	subfls r5,-128
+ *[0-9a-f]*:	f5 b4 07 7f 	subfpl r4,127
+ *[0-9a-f]*:	f5 be 01 01 	subfne lr,1
+ *[0-9a-f]*:	f5 ba 08 08 	subfls r10,8
+ *[0-9a-f]*:	f5 bb 0d 63 	subfvc r11,99
+ *[0-9a-f]*:	f5 b2 0c 49 	subfvs r2,73
+
+[0-9a-f]* <subc>:
+ *[0-9a-f]*:	f7 bf 00 00 	subeq pc,0
+ *[0-9a-f]*:	f7 bc 0f ff 	subal r12,-1
+ *[0-9a-f]*:	f7 b5 08 80 	subls r5,-128
+ *[0-9a-f]*:	f7 b4 07 7f 	subpl r4,127
+ *[0-9a-f]*:	f7 be 01 01 	subne lr,1
+ *[0-9a-f]*:	f7 bc 08 76 	subls r12,118
+ *[0-9a-f]*:	f7 be 0d f4 	subvc lr,-12
+ *[0-9a-f]*:	f7 b4 06 f3 	submi r4,-13
+
+[0-9a-f]* <movc2>:
+ *[0-9a-f]*:	f9 bf 00 00 	moveq pc,0
+ *[0-9a-f]*:	f9 bc 0f ff 	moval r12,-1
+ *[0-9a-f]*:	f9 b5 08 80 	movls r5,-128
+ *[0-9a-f]*:	f9 b4 07 7f 	movpl r4,127
+ *[0-9a-f]*:	f9 be 01 01 	movne lr,1
+ *[0-9a-f]*:	f9 b3 05 86 	movlt r3,-122
+ *[0-9a-f]*:	f9 b8 0d 02 	movvc r8,2
+ *[0-9a-f]*:	f9 b7 01 91 	movne r7,-111
+
+[0-9a-f]* <cp_b>:
+ *[0-9a-f]*:	e0 0f 18 00 	cp\.b pc,r0
+ *[0-9a-f]*:	fe 00 18 00 	cp\.b r0,pc
+ *[0-9a-f]*:	f0 07 18 00 	cp\.b r7,r8
+ *[0-9a-f]*:	ee 08 18 00 	cp\.b r8,r7
+
+[0-9a-f]* <cp_h>:
+ *[0-9a-f]*:	e0 0f 19 00 	cp\.h pc,r0
+ *[0-9a-f]*:	fe 00 19 00 	cp\.h r0,pc
+ *[0-9a-f]*:	f0 07 19 00 	cp\.h r7,r8
+ *[0-9a-f]*:	ee 08 19 00 	cp\.h r8,r7
+
+[0-9a-f]* <ldm>:
+ *[0-9a-f]*:	e1 cf 00 7e 	ldm pc,r1-r6
+ *[0-9a-f]*:	e1 cc ff ff 	ldm r12,r0-pc
+ *[0-9a-f]*:	e1 c5 80 00 	ldm r5,pc
+ *[0-9a-f]*:	e1 c4 7f ff 	ldm r4,r0-lr
+ *[0-9a-f]*:	e1 ce 00 01 	ldm lr,r0
+ *[0-9a-f]*:	e1 c9 40 22 	ldm r9,r1,r5,lr
+ *[0-9a-f]*:	e1 cb 81 ec 	ldm r11,r2-r3,r5-r8,pc
+ *[0-9a-f]*:	e1 c6 a2 09 	ldm r6,r0,r3,r9,sp,pc
+
+[0-9a-f]* <ldm_pu>:
+ *[0-9a-f]*:	e3 cf 03 c0 	ldm pc\+\+,r6-r9
+ *[0-9a-f]*:	e3 cc ff ff 	ldm r12\+\+,r0-pc
+ *[0-9a-f]*:	e3 c5 80 00 	ldm r5\+\+,pc
+ *[0-9a-f]*:	e3 c4 7f ff 	ldm r4\+\+,r0-lr
+ *[0-9a-f]*:	e3 ce 00 01 	ldm lr\+\+,r0
+ *[0-9a-f]*:	e3 cc d5 38 	ldm r12\+\+,r3-r5,r8,r10,r12,lr-pc
+ *[0-9a-f]*:	e3 ca c0 74 	ldm r10\+\+,r2,r4-r6,lr-pc
+ *[0-9a-f]*:	e3 c6 7e 1a 	ldm r6\+\+,r1,r3-r4,r9-lr
+
+[0-9a-f]* <ldmts>:
+ *[0-9a-f]*:	e5 cf 01 80 	ldmts pc,r7-r8
+ *[0-9a-f]*:	e5 cc ff ff 	ldmts r12,r0-pc
+ *[0-9a-f]*:	e5 c5 80 00 	ldmts r5,pc
+ *[0-9a-f]*:	e5 c4 7f ff 	ldmts r4,r0-lr
+ *[0-9a-f]*:	e5 ce 00 01 	ldmts lr,r0
+ *[0-9a-f]*:	e5 c0 18 06 	ldmts r0,r1-r2,r11-r12
+ *[0-9a-f]*:	e5 ce 61 97 	ldmts lr,r0-r2,r4,r7-r8,sp-lr
+ *[0-9a-f]*:	e5 cc c2 3b 	ldmts r12,r0-r1,r3-r5,r9,lr-pc
+
+[0-9a-f]* <ldmts_pu>:
+ *[0-9a-f]*:	e7 cf 02 00 	ldmts pc\+\+,r9
+ *[0-9a-f]*:	e7 cc ff ff 	ldmts r12\+\+,r0-pc
+ *[0-9a-f]*:	e7 c5 80 00 	ldmts r5\+\+,pc
+ *[0-9a-f]*:	e7 c4 7f ff 	ldmts r4\+\+,r0-lr
+ *[0-9a-f]*:	e7 ce 00 01 	ldmts lr\+\+,r0
+ *[0-9a-f]*:	e7 cd 0a bd 	ldmts sp\+\+,r0,r2-r5,r7,r9,r11
+ *[0-9a-f]*:	e7 c5 0c 8e 	ldmts r5\+\+,r1-r3,r7,r10-r11
+ *[0-9a-f]*:	e7 c8 a1 9c 	ldmts r8\+\+,r2-r4,r7-r8,sp,pc
+
+[0-9a-f]* <stm>:
+ *[0-9a-f]*:	e9 cf 00 80 	stm pc,r7
+ *[0-9a-f]*:	e9 cc ff ff 	stm r12,r0-pc
+ *[0-9a-f]*:	e9 c5 80 00 	stm r5,pc
+ *[0-9a-f]*:	e9 c4 7f ff 	stm r4,r0-lr
+ *[0-9a-f]*:	e9 ce 00 01 	stm lr,r0
+ *[0-9a-f]*:	e9 cd 49 2c 	stm sp,r2-r3,r5,r8,r11,lr
+ *[0-9a-f]*:	e9 c4 4c 5f 	stm r4,r0-r4,r6,r10-r11,lr
+ *[0-9a-f]*:	e9 c9 f2 22 	stm r9,r1,r5,r9,r12-pc
+
+[0-9a-f]* <stm_pu>:
+ *[0-9a-f]*:	eb cf 00 70 	stm --pc,r4-r6
+ *[0-9a-f]*:	eb cc ff ff 	stm --r12,r0-pc
+ *[0-9a-f]*:	eb c5 80 00 	stm --r5,pc
+ *[0-9a-f]*:	eb c4 7f ff 	stm --r4,r0-lr
+ *[0-9a-f]*:	eb ce 00 01 	stm --lr,r0
+ *[0-9a-f]*:	eb cb fb f1 	stm --r11,r0,r4-r9,r11-pc
+ *[0-9a-f]*:	eb cb 56 09 	stm --r11,r0,r3,r9-r10,r12,lr
+ *[0-9a-f]*:	eb c6 63 04 	stm --r6,r2,r8-r9,sp-lr
+
+[0-9a-f]* <stmts>:
+ *[0-9a-f]*:	ed cf 01 00 	stmts pc,r8
+ *[0-9a-f]*:	ed cc ff ff 	stmts r12,r0-pc
+ *[0-9a-f]*:	ed c5 80 00 	stmts r5,pc
+ *[0-9a-f]*:	ed c4 7f ff 	stmts r4,r0-lr
+ *[0-9a-f]*:	ed ce 00 01 	stmts lr,r0
+ *[0-9a-f]*:	ed c1 c6 5b 	stmts r1,r0-r1,r3-r4,r6,r9-r10,lr-pc
+ *[0-9a-f]*:	ed c3 1d c1 	stmts r3,r0,r6-r8,r10-r12
+ *[0-9a-f]*:	ed cb d6 d1 	stmts r11,r0,r4,r6-r7,r9-r10,r12,lr-pc
+
+[0-9a-f]* <stmts_pu>:
+ *[0-9a-f]*:	ef cf 01 c0 	stmts --pc,r6-r8
+ *[0-9a-f]*:	ef cc ff ff 	stmts --r12,r0-pc
+ *[0-9a-f]*:	ef c5 80 00 	stmts --r5,pc
+ *[0-9a-f]*:	ef c4 7f ff 	stmts --r4,r0-lr
+ *[0-9a-f]*:	ef ce 00 01 	stmts --lr,r0
+ *[0-9a-f]*:	ef c2 36 19 	stmts --r2,r0,r3-r4,r9-r10,r12-sp
+ *[0-9a-f]*:	ef c3 c0 03 	stmts --r3,r0-r1,lr-pc
+ *[0-9a-f]*:	ef c0 44 7d 	stmts --r0,r0,r2-r6,r10,lr
+
+[0-9a-f]* <ldins_h>:
+ *[0-9a-f]*:	ff df 00 00 	ldins\.h pc:b,pc\[0\]
+ *[0-9a-f]*:	f9 dc 1f ff 	ldins\.h r12:t,r12\[-2\]
+ *[0-9a-f]*:	eb d5 18 00 	ldins\.h r5:t,r5\[-4096\]
+ *[0-9a-f]*:	e9 d4 07 ff 	ldins\.h r4:b,r4\[4094\]
+ *[0-9a-f]*:	fd de 10 01 	ldins\.h lr:t,lr\[2\]
+ *[0-9a-f]*:	fd d0 13 c5 	ldins\.h r0:t,lr\[1930\]
+ *[0-9a-f]*:	ef d3 0e f5 	ldins\.h r3:b,r7\[-534\]
+ *[0-9a-f]*:	f9 d2 0b 9a 	ldins\.h r2:b,r12\[-2252\]
+
+[0-9a-f]* <ldins_b>:
+ *[0-9a-f]*:	ff df 40 00 	ldins\.b pc:b,pc\[0\]
+ *[0-9a-f]*:	f9 dc 7f ff 	ldins\.b r12:t,r12\[-1\]
+ *[0-9a-f]*:	eb d5 68 00 	ldins\.b r5:u,r5\[-2048\]
+ *[0-9a-f]*:	e9 d4 57 ff 	ldins\.b r4:l,r4\[2047\]
+ *[0-9a-f]*:	fd de 50 01 	ldins\.b lr:l,lr\[1\]
+ *[0-9a-f]*:	e9 d6 7d 6a 	ldins\.b r6:t,r4\[-662\]
+ *[0-9a-f]*:	e3 d5 4f 69 	ldins\.b r5:b,r1\[-151\]
+ *[0-9a-f]*:	f7 da 78 7d 	ldins\.b r10:t,r11\[-1923\]
+
+[0-9a-f]* <ldswp_sh>:
+ *[0-9a-f]*:	ff df 20 00 	ldswp\.sh pc,pc\[0\]
+ *[0-9a-f]*:	f9 dc 2f ff 	ldswp\.sh r12,r12\[-2\]
+ *[0-9a-f]*:	eb d5 28 00 	ldswp\.sh r5,r5\[-4096\]
+ *[0-9a-f]*:	e9 d4 27 ff 	ldswp\.sh r4,r4\[4094\]
+ *[0-9a-f]*:	fd de 20 01 	ldswp\.sh lr,lr\[2\]
+ *[0-9a-f]*:	f5 d9 27 84 	ldswp\.sh r9,r10\[3848\]
+ *[0-9a-f]*:	f9 d4 2c 04 	ldswp\.sh r4,r12\[-2040\]
+ *[0-9a-f]*:	e5 da 26 08 	ldswp\.sh r10,r2\[3088\]
+
+[0-9a-f]* <ldswp_uh>:
+ *[0-9a-f]*:	ff df 30 00 	ldswp\.uh pc,pc\[0\]
+ *[0-9a-f]*:	f9 dc 3f ff 	ldswp\.uh r12,r12\[-2\]
+ *[0-9a-f]*:	eb d5 38 00 	ldswp\.uh r5,r5\[-4096\]
+ *[0-9a-f]*:	e9 d4 37 ff 	ldswp\.uh r4,r4\[4094\]
+ *[0-9a-f]*:	fd de 30 01 	ldswp\.uh lr,lr\[2\]
+ *[0-9a-f]*:	f3 d4 37 46 	ldswp\.uh r4,r9\[3724\]
+ *[0-9a-f]*:	fb de 3c bc 	ldswp\.uh lr,sp\[-1672\]
+ *[0-9a-f]*:	f9 d8 38 7d 	ldswp\.uh r8,r12\[-3846\]
+
+[0-9a-f]* <ldswp_w>:
+ *[0-9a-f]*:	ff df 80 00 	ldswp\.w pc,pc\[0\]
+ *[0-9a-f]*:	f9 dc 8f ff 	ldswp\.w r12,r12\[-4\]
+ *[0-9a-f]*:	eb d5 88 00 	ldswp\.w r5,r5\[-8192\]
+ *[0-9a-f]*:	e9 d4 87 ff 	ldswp\.w r4,r4\[8188\]
+ *[0-9a-f]*:	fd de 80 01 	ldswp\.w lr,lr\[4\]
+ *[0-9a-f]*:	ef dd 81 d1 	ldswp\.w sp,r7\[1860\]
+ *[0-9a-f]*:	eb df 8c c1 	ldswp\.w pc,r5\[-3324\]
+ *[0-9a-f]*:	f5 dc 8c c8 	ldswp\.w r12,r10\[-3296\]
+
+[0-9a-f]* <stswp_h>:
+ *[0-9a-f]*:	ff df 90 00 	stswp\.h pc\[0\],pc
+ *[0-9a-f]*:	f9 dc 9f ff 	stswp\.h r12\[-2\],r12
+ *[0-9a-f]*:	eb d5 98 00 	stswp\.h r5\[-4096\],r5
+ *[0-9a-f]*:	e9 d4 97 ff 	stswp\.h r4\[4094\],r4
+ *[0-9a-f]*:	fd de 90 01 	stswp\.h lr\[2\],lr
+ *[0-9a-f]*:	ef da 90 20 	stswp\.h r7\[64\],r10
+ *[0-9a-f]*:	f5 d2 95 e8 	stswp\.h r10\[3024\],r2
+ *[0-9a-f]*:	e1 da 9b 74 	stswp\.h r0\[-2328\],r10
+
+[0-9a-f]* <stswp_w>:
+ *[0-9a-f]*:	ff df a0 00 	stswp\.w pc\[0\],pc
+ *[0-9a-f]*:	f9 dc af ff 	stswp\.w r12\[-4\],r12
+ *[0-9a-f]*:	eb d5 a8 00 	stswp\.w r5\[-8192\],r5
+ *[0-9a-f]*:	e9 d4 a7 ff 	stswp\.w r4\[8188\],r4
+ *[0-9a-f]*:	fd de a0 01 	stswp\.w lr\[4\],lr
+ *[0-9a-f]*:	ff d8 a1 21 	stswp\.w pc\[1156\],r8
+ *[0-9a-f]*:	fb da a7 ce 	stswp\.w sp\[7992\],r10
+ *[0-9a-f]*:	f1 d5 ae db 	stswp\.w r8\[-1172\],r5
+
+[0-9a-f]* <and2>:
+ *[0-9a-f]*:	ff ef 00 0f 	and pc,pc,pc
+ *[0-9a-f]*:	f9 ec 01 fc 	and r12,r12,r12<<0x1f
+ *[0-9a-f]*:	eb e5 01 05 	and r5,r5,r5<<0x10
+ *[0-9a-f]*:	e9 e4 00 f4 	and r4,r4,r4<<0xf
+ *[0-9a-f]*:	fd ee 00 1e 	and lr,lr,lr<<0x1
+ *[0-9a-f]*:	e5 e1 00 1a 	and r10,r2,r1<<0x1
+ *[0-9a-f]*:	f1 eb 01 bc 	and r12,r8,r11<<0x1b
+ *[0-9a-f]*:	ef e0 00 3a 	and r10,r7,r0<<0x3
+
+[0-9a-f]* <and3>:
+ *[0-9a-f]*:	ff ef 02 0f 	and pc,pc,pc
+ *[0-9a-f]*:	f9 ec 03 fc 	and r12,r12,r12>>0x1f
+ *[0-9a-f]*:	eb e5 03 05 	and r5,r5,r5>>0x10
+ *[0-9a-f]*:	e9 e4 02 f4 	and r4,r4,r4>>0xf
+ *[0-9a-f]*:	fd ee 02 1e 	and lr,lr,lr>>0x1
+ *[0-9a-f]*:	f1 e7 03 1c 	and r12,r8,r7>>0x11
+ *[0-9a-f]*:	e9 e9 03 4f 	and pc,r4,r9>>0x14
+ *[0-9a-f]*:	f3 ea 02 ca 	and r10,r9,r10>>0xc
+
+[0-9a-f]* <or2>:
+ *[0-9a-f]*:	ff ef 10 0f 	or pc,pc,pc
+ *[0-9a-f]*:	f9 ec 11 fc 	or r12,r12,r12<<0x1f
+ *[0-9a-f]*:	eb e5 11 05 	or r5,r5,r5<<0x10
+ *[0-9a-f]*:	e9 e4 10 f4 	or r4,r4,r4<<0xf
+ *[0-9a-f]*:	fd ee 10 1e 	or lr,lr,lr<<0x1
+ *[0-9a-f]*:	fb eb 11 d8 	or r8,sp,r11<<0x1d
+ *[0-9a-f]*:	f3 e2 11 cf 	or pc,r9,r2<<0x1c
+ *[0-9a-f]*:	e3 e2 10 35 	or r5,r1,r2<<0x3
+
+[0-9a-f]* <or3>:
+ *[0-9a-f]*:	ff ef 12 0f 	or pc,pc,pc
+ *[0-9a-f]*:	f9 ec 13 fc 	or r12,r12,r12>>0x1f
+ *[0-9a-f]*:	eb e5 13 05 	or r5,r5,r5>>0x10
+ *[0-9a-f]*:	e9 e4 12 f4 	or r4,r4,r4>>0xf
+ *[0-9a-f]*:	fd ee 12 1e 	or lr,lr,lr>>0x1
+ *[0-9a-f]*:	fb ed 12 21 	or r1,sp,sp>>0x2
+ *[0-9a-f]*:	e3 e1 13 d0 	or r0,r1,r1>>0x1d
+ *[0-9a-f]*:	f9 e8 12 84 	or r4,r12,r8>>0x8
+
+[0-9a-f]* <eor2>:
+ *[0-9a-f]*:	ff ef 20 0f 	eor pc,pc,pc
+ *[0-9a-f]*:	f9 ec 21 fc 	eor r12,r12,r12<<0x1f
+ *[0-9a-f]*:	eb e5 21 05 	eor r5,r5,r5<<0x10
+ *[0-9a-f]*:	e9 e4 20 f4 	eor r4,r4,r4<<0xf
+ *[0-9a-f]*:	fd ee 20 1e 	eor lr,lr,lr<<0x1
+ *[0-9a-f]*:	f3 e4 20 ba 	eor r10,r9,r4<<0xb
+ *[0-9a-f]*:	e1 e1 21 f4 	eor r4,r0,r1<<0x1f
+ *[0-9a-f]*:	e5 ec 20 d6 	eor r6,r2,r12<<0xd
+
+[0-9a-f]* <eor3>:
+ *[0-9a-f]*:	ff ef 22 0f 	eor pc,pc,pc
+ *[0-9a-f]*:	f9 ec 23 fc 	eor r12,r12,r12>>0x1f
+ *[0-9a-f]*:	eb e5 23 05 	eor r5,r5,r5>>0x10
+ *[0-9a-f]*:	e9 e4 22 f4 	eor r4,r4,r4>>0xf
+ *[0-9a-f]*:	fd ee 22 1e 	eor lr,lr,lr>>0x1
+ *[0-9a-f]*:	eb e5 23 65 	eor r5,r5,r5>>0x16
+ *[0-9a-f]*:	e3 ee 22 3a 	eor r10,r1,lr>>0x3
+ *[0-9a-f]*:	fd ed 23 a7 	eor r7,lr,sp>>0x1a
+
+[0-9a-f]* <sthh_w2>:
+ *[0-9a-f]*:	ff ef 8f 0f 	sthh\.w pc\[pc\],pc:b,pc:b
+ *[0-9a-f]*:	f9 ec bc 3c 	sthh\.w r12\[r12<<0x3\],r12:t,r12:t
+ *[0-9a-f]*:	eb e5 b5 25 	sthh\.w r5\[r5<<0x2\],r5:t,r5:t
+ *[0-9a-f]*:	e9 e4 84 14 	sthh\.w r4\[r4<<0x1\],r4:b,r4:b
+ *[0-9a-f]*:	fd ee be 1e 	sthh\.w lr\[lr<<0x1\],lr:t,lr:t
+ *[0-9a-f]*:	e3 ec b6 3d 	sthh\.w sp\[r6<<0x3\],r1:t,r12:t
+ *[0-9a-f]*:	f3 e9 b6 06 	sthh\.w r6\[r6\],r9:t,r9:t
+ *[0-9a-f]*:	e1 eb 93 0a 	sthh\.w r10\[r3\],r0:b,r11:t
+
+[0-9a-f]* <sthh_w1>:
+ *[0-9a-f]*:	ff ef c0 0f 	sthh\.w pc\[0x0\],pc:b,pc:b
+ *[0-9a-f]*:	f9 ec ff fc 	sthh\.w r12\[0x3fc\],r12:t,r12:t
+ *[0-9a-f]*:	eb e5 f8 05 	sthh\.w r5\[0x200\],r5:t,r5:t
+ *[0-9a-f]*:	e9 e4 c7 f4 	sthh\.w r4\[0x1fc\],r4:b,r4:b
+ *[0-9a-f]*:	fd ee f0 1e 	sthh\.w lr\[0x4\],lr:t,lr:t
+ *[0-9a-f]*:	f3 e0 e6 54 	sthh\.w r4\[0x194\],r9:t,r0:b
+ *[0-9a-f]*:	e5 ea e5 78 	sthh\.w r8\[0x15c\],r2:t,r10:b
+ *[0-9a-f]*:	f3 e2 c2 bd 	sthh\.w sp\[0xac\],r9:b,r2:b
+
+[0-9a-f]* <cop>:
+ *[0-9a-f]*:	e1 a0 00 00 	cop cp0,cr0,cr0,cr0,0x0
+ *[0-9a-f]*:	e7 af ff ff 	cop cp7,cr15,cr15,cr15,0x7f
+ *[0-9a-f]*:	e3 a8 75 55 	cop cp3,cr5,cr5,cr5,0x31
+ *[0-9a-f]*:	e3 a8 44 44 	cop cp2,cr4,cr4,cr4,0x30
+ *[0-9a-f]*:	e5 ad a8 37 	cop cp5,cr8,cr3,cr7,0x5a
+
+[0-9a-f]* <ldc_w1>:
+ *[0-9a-f]*:	e9 a0 00 00 	ldc\.w cp0,cr0,r0\[0x0\]
+ *[0-9a-f]*:	e9 af ef ff 	ldc\.w cp7,cr15,pc\[0x3fc\]
+ *[0-9a-f]*:	e9 a5 65 80 	ldc\.w cp3,cr5,r5\[0x200\]
+ *[0-9a-f]*:	e9 a4 44 7f 	ldc\.w cp2,cr4,r4\[0x1fc\]
+ *[0-9a-f]*:	e9 ad 89 24 	ldc\.w cp4,cr9,sp\[0x90\]
+
+[0-9a-f]* <ldc_w2>:
+ *[0-9a-f]*:	ef a0 00 40 	ldc\.w cp0,cr0,--r0
+ *[0-9a-f]*:	ef af ef 40 	ldc\.w cp7,cr15,--pc
+ *[0-9a-f]*:	ef a5 65 40 	ldc\.w cp3,cr5,--r5
+ *[0-9a-f]*:	ef a4 44 40 	ldc\.w cp2,cr4,--r4
+ *[0-9a-f]*:	ef ad 89 40 	ldc\.w cp4,cr9,--sp
+
+[0-9a-f]* <ldc_w3>:
+ *[0-9a-f]*:	ef a0 10 00 	ldc\.w cp0,cr0,r0\[r0\]
+ *[0-9a-f]*:	ef af ff 3f 	ldc\.w cp7,cr15,pc\[pc<<0x3\]
+ *[0-9a-f]*:	ef a5 75 24 	ldc\.w cp3,cr5,r5\[r4<<0x2\]
+ *[0-9a-f]*:	ef a4 54 13 	ldc\.w cp2,cr4,r4\[r3<<0x1\]
+ *[0-9a-f]*:	ef ad 99 0c 	ldc\.w cp4,cr9,sp\[r12\]
+
+[0-9a-f]* <ldc_d1>:
+ *[0-9a-f]*:	e9 a0 10 00 	ldc\.d cp0,cr0,r0\[0x0\]
+ *[0-9a-f]*:	e9 af fe ff 	ldc\.d cp7,cr14,pc\[0x3fc\]
+ *[0-9a-f]*:	e9 a5 76 80 	ldc\.d cp3,cr6,r5\[0x200\]
+ *[0-9a-f]*:	e9 a4 54 7f 	ldc\.d cp2,cr4,r4\[0x1fc\]
+ *[0-9a-f]*:	e9 ad 98 24 	ldc\.d cp4,cr8,sp\[0x90\]
+
+[0-9a-f]* <ldc_d2>:
+ *[0-9a-f]*:	ef a0 00 50 	ldc\.d cp0,cr0,--r0
+ *[0-9a-f]*:	ef af ee 50 	ldc\.d cp7,cr14,--pc
+ *[0-9a-f]*:	ef a5 66 50 	ldc\.d cp3,cr6,--r5
+ *[0-9a-f]*:	ef a4 44 50 	ldc\.d cp2,cr4,--r4
+ *[0-9a-f]*:	ef ad 88 50 	ldc\.d cp4,cr8,--sp
+
+[0-9a-f]* <ldc_d3>:
+ *[0-9a-f]*:	ef a0 10 40 	ldc\.d cp0,cr0,r0\[r0\]
+ *[0-9a-f]*:	ef af fe 7f 	ldc\.d cp7,cr14,pc\[pc<<0x3\]
+ *[0-9a-f]*:	ef a5 76 64 	ldc\.d cp3,cr6,r5\[r4<<0x2\]
+ *[0-9a-f]*:	ef a4 54 53 	ldc\.d cp2,cr4,r4\[r3<<0x1\]
+ *[0-9a-f]*:	ef ad 98 4c 	ldc\.d cp4,cr8,sp\[r12\]
+
+[0-9a-f]* <stc_w1>:
+ *[0-9a-f]*:	eb a0 00 00 	stc\.w cp0,r0\[0x0\],cr0
+ *[0-9a-f]*:	eb af ef ff 	stc\.w cp7,pc\[0x3fc\],cr15
+ *[0-9a-f]*:	eb a5 65 80 	stc\.w cp3,r5\[0x200\],cr5
+ *[0-9a-f]*:	eb a4 44 7f 	stc\.w cp2,r4\[0x1fc\],cr4
+ *[0-9a-f]*:	eb ad 89 24 	stc\.w cp4,sp\[0x90\],cr9
+
+[0-9a-f]* <stc_w2>:
+ *[0-9a-f]*:	ef a0 00 60 	stc\.w cp0,r0\+\+,cr0
+ *[0-9a-f]*:	ef af ef 60 	stc\.w cp7,pc\+\+,cr15
+ *[0-9a-f]*:	ef a5 65 60 	stc\.w cp3,r5\+\+,cr5
+ *[0-9a-f]*:	ef a4 44 60 	stc\.w cp2,r4\+\+,cr4
+ *[0-9a-f]*:	ef ad 89 60 	stc\.w cp4,sp\+\+,cr9
+
+[0-9a-f]* <stc_w3>:
+ *[0-9a-f]*:	ef a0 10 80 	stc\.w cp0,r0\[r0\],cr0
+ *[0-9a-f]*:	ef af ff bf 	stc\.w cp7,pc\[pc<<0x3\],cr15
+ *[0-9a-f]*:	ef a5 75 a4 	stc\.w cp3,r5\[r4<<0x2\],cr5
+ *[0-9a-f]*:	ef a4 54 93 	stc\.w cp2,r4\[r3<<0x1\],cr4
+ *[0-9a-f]*:	ef ad 99 8c 	stc\.w cp4,sp\[r12\],cr9
+
+[0-9a-f]* <stc_d1>:
+ *[0-9a-f]*:	eb a0 10 00 	stc\.d cp0,r0\[0x0\],cr0
+ *[0-9a-f]*:	eb af fe ff 	stc\.d cp7,pc\[0x3fc\],cr14
+ *[0-9a-f]*:	eb a5 76 80 	stc\.d cp3,r5\[0x200\],cr6
+ *[0-9a-f]*:	eb a4 54 7f 	stc\.d cp2,r4\[0x1fc\],cr4
+ *[0-9a-f]*:	eb ad 98 24 	stc\.d cp4,sp\[0x90\],cr8
+
+[0-9a-f]* <stc_d2>:
+ *[0-9a-f]*:	ef a0 00 70 	stc\.d cp0,r0\+\+,cr0
+ *[0-9a-f]*:	ef af ee 70 	stc\.d cp7,pc\+\+,cr14
+ *[0-9a-f]*:	ef a5 66 70 	stc\.d cp3,r5\+\+,cr6
+ *[0-9a-f]*:	ef a4 44 70 	stc\.d cp2,r4\+\+,cr4
+ *[0-9a-f]*:	ef ad 88 70 	stc\.d cp4,sp\+\+,cr8
+
+[0-9a-f]* <stc_d3>:
+ *[0-9a-f]*:	ef a0 10 c0 	stc\.d cp0,r0\[r0\],cr0
+ *[0-9a-f]*:	ef af fe ff 	stc\.d cp7,pc\[pc<<0x3\],cr14
+ *[0-9a-f]*:	ef a5 76 e4 	stc\.d cp3,r5\[r4<<0x2\],cr6
+ *[0-9a-f]*:	ef a4 54 d3 	stc\.d cp2,r4\[r3<<0x1\],cr4
+ *[0-9a-f]*:	ef ad 98 cc 	stc\.d cp4,sp\[r12\],cr8
+
+[0-9a-f]* <ldc0_w>:
+ *[0-9a-f]*:	f1 a0 00 00 	ldc0\.w cr0,r0\[0x0\]
+ *[0-9a-f]*:	f1 af ff ff 	ldc0\.w cr15,pc\[0x3ffc\]
+ *[0-9a-f]*:	f1 a5 85 00 	ldc0\.w cr5,r5\[0x2000\]
+ *[0-9a-f]*:	f1 a4 74 ff 	ldc0\.w cr4,r4\[0x1ffc\]
+ *[0-9a-f]*:	f1 ad 09 93 	ldc0\.w cr9,sp\[0x24c\]
+
+[0-9a-f]* <ldc0_d>:
+ *[0-9a-f]*:	f3 a0 00 00 	ldc0\.d cr0,r0\[0x0\]
+ *[0-9a-f]*:	f3 af fe ff 	ldc0\.d cr14,pc\[0x3ffc\]
+ *[0-9a-f]*:	f3 a5 86 00 	ldc0\.d cr6,r5\[0x2000\]
+ *[0-9a-f]*:	f3 a4 74 ff 	ldc0\.d cr4,r4\[0x1ffc\]
+ *[0-9a-f]*:	f3 ad 08 93 	ldc0\.d cr8,sp\[0x24c\]
+
+[0-9a-f]* <stc0_w>:
+ *[0-9a-f]*:	f5 a0 00 00 	stc0\.w r0\[0x0\],cr0
+ *[0-9a-f]*:	f5 af ff ff 	stc0\.w pc\[0x3ffc\],cr15
+ *[0-9a-f]*:	f5 a5 85 00 	stc0\.w r5\[0x2000\],cr5
+ *[0-9a-f]*:	f5 a4 74 ff 	stc0\.w r4\[0x1ffc\],cr4
+ *[0-9a-f]*:	f5 ad 09 93 	stc0\.w sp\[0x24c\],cr9
+
+[0-9a-f]* <stc0_d>:
+ *[0-9a-f]*:	f7 a0 00 00 	stc0\.d r0\[0x0\],cr0
+ *[0-9a-f]*:	f7 af fe ff 	stc0\.d pc\[0x3ffc\],cr14
+ *[0-9a-f]*:	f7 a5 86 00 	stc0\.d r5\[0x2000\],cr6
+ *[0-9a-f]*:	f7 a4 74 ff 	stc0\.d r4\[0x1ffc\],cr4
+ *[0-9a-f]*:	f7 ad 08 93 	stc0\.d sp\[0x24c\],cr8
+
+[0-9a-f]* <memc>:
+ *[0-9a-f]*:	f6 10 00 00 	memc 0,0x0
+ *[0-9a-f]*:	f6 1f ff ff 	memc -4,0x1f
+ *[0-9a-f]*:	f6 18 40 00 	memc -65536,0x10
+ *[0-9a-f]*:	f6 17 bf ff 	memc 65532,0xf
+
+[0-9a-f]* <mems>:
+ *[0-9a-f]*:	f8 10 00 00 	mems 0,0x0
+ *[0-9a-f]*:	f8 1f ff ff 	mems -4,0x1f
+ *[0-9a-f]*:	f8 18 40 00 	mems -65536,0x10
+ *[0-9a-f]*:	f8 17 bf ff 	mems 65532,0xf
+
+[0-9a-f]* <memt>:
+ *[0-9a-f]*:	fa 10 00 00 	memt 0,0x0
+ *[0-9a-f]*:	fa 1f ff ff 	memt -4,0x1f
+ *[0-9a-f]*:	fa 18 40 00 	memt -65536,0x10
+ *[0-9a-f]*:	fa 17 bf ff 	memt 65532,0xf
+
+[0-9a-f]* <stcond>:
+ *[0-9a-f]*:	e1 70 00 00 	stcond r0\[0\],r0
+ *[0-9a-f]*:	ff 7f ff ff 	stcond pc\[-1\],pc
+ *[0-9a-f]*:	f1 77 80 00 	stcond r8\[-32768\],r7
+ *[0-9a-f]*:	ef 78 7f ff 	stcond r7\[32767\],r8
+ *[0-9a-f]*:	eb 7a 12 34 	stcond r5\[4660\],r10
+
+[0-9a-f]* <ldcm_w>:
+ *[0-9a-f]*:	ed af 00 ff 	ldcm\.w cp0,pc,cr0-cr7
+ *[0-9a-f]*:	ed a0 e0 01 	ldcm\.w cp7,r0,cr0
+ *[0-9a-f]*:	ed a4 90 7f 	ldcm\.w cp4,r4\+\+,cr0-cr6
+ *[0-9a-f]*:	ed a7 60 80 	ldcm\.w cp3,r7,cr7
+ *[0-9a-f]*:	ed ac 30 72 	ldcm\.w cp1,r12\+\+,cr1,cr4-cr6
+ *[0-9a-f]*:	ed af 01 ff 	ldcm\.w cp0,pc,cr8-cr15
+ *[0-9a-f]*:	ed a0 e1 01 	ldcm\.w cp7,r0,cr8
+ *[0-9a-f]*:	ed a4 91 7f 	ldcm\.w cp4,r4\+\+,cr8-cr14
+ *[0-9a-f]*:	ed a7 61 80 	ldcm\.w cp3,r7,cr15
+ *[0-9a-f]*:	ed ac 31 72 	ldcm\.w cp1,r12\+\+,cr9,cr12-cr14
+
+[0-9a-f]* <ldcm_d>:
+ *[0-9a-f]*:	ed af 04 ff 	ldcm\.d cp0,pc,cr0-cr15
+ *[0-9a-f]*:	ed a0 e4 01 	ldcm\.d cp7,r0,cr0-cr1
+ *[0-9a-f]*:	ed a4 94 7f 	ldcm\.d cp4,r4\+\+,cr0-cr13
+ *[0-9a-f]*:	ed a7 64 80 	ldcm\.d cp3,r7,cr14-cr15
+ *[0-9a-f]*:	ed ac 54 93 	ldcm\.d cp2,r12\+\+,cr0-cr3,cr8-cr9,cr14-cr15
+
+[0-9a-f]* <stcm_w>:
+ *[0-9a-f]*:	ed af 02 ff 	stcm\.w cp0,pc,cr0-cr7
+ *[0-9a-f]*:	ed a0 e2 01 	stcm\.w cp7,r0,cr0
+ *[0-9a-f]*:	ed a4 92 7f 	stcm\.w cp4,--r4,cr0-cr6
+ *[0-9a-f]*:	ed a7 62 80 	stcm\.w cp3,r7,cr7
+ *[0-9a-f]*:	ed ac 32 72 	stcm\.w cp1,--r12,cr1,cr4-cr6
+ *[0-9a-f]*:	ed af 03 ff 	stcm\.w cp0,pc,cr8-cr15
+ *[0-9a-f]*:	ed a0 e3 01 	stcm\.w cp7,r0,cr8
+ *[0-9a-f]*:	ed a4 93 7f 	stcm\.w cp4,--r4,cr8-cr14
+ *[0-9a-f]*:	ed a7 63 80 	stcm\.w cp3,r7,cr15
+ *[0-9a-f]*:	ed ac 33 72 	stcm\.w cp1,--r12,cr9,cr12-cr14
+
+[0-9a-f]* <stcm_d>:
+ *[0-9a-f]*:	ed af 05 ff 	stcm\.d cp0,pc,cr0-cr15
+ *[0-9a-f]*:	ed a0 e5 01 	stcm\.d cp7,r0,cr0-cr1
+ *[0-9a-f]*:	ed a4 95 7f 	stcm\.d cp4,--r4,cr0-cr13
+ *[0-9a-f]*:	ed a7 65 80 	stcm\.d cp3,r7,cr14-cr15
+ *[0-9a-f]*:	ed ac 55 93 	stcm\.d cp2,--r12,cr0-cr3,cr8-cr9,cr14-cr15
+
+[0-9a-f]* <mvcr_w>:
+ *[0-9a-f]*:	ef af ef 00 	mvcr\.w cp7,pc,cr15
+ *[0-9a-f]*:	ef a0 00 00 	mvcr\.w cp0,r0,cr0
+ *[0-9a-f]*:	ef af 0f 00 	mvcr\.w cp0,pc,cr15
+ *[0-9a-f]*:	ef a0 ef 00 	mvcr\.w cp7,r0,cr15
+ *[0-9a-f]*:	ef af e0 00 	mvcr\.w cp7,pc,cr0
+ *[0-9a-f]*:	ef a7 88 00 	mvcr\.w cp4,r7,cr8
+ *[0-9a-f]*:	ef a8 67 00 	mvcr\.w cp3,r8,cr7
+
+[0-9a-f]* <mvcr_d>:
+ *[0-9a-f]*:	ef ae ee 10 	mvcr\.d cp7,lr,cr14
+ *[0-9a-f]*:	ef a0 00 10 	mvcr\.d cp0,r0,cr0
+ *[0-9a-f]*:	ef ae 0e 10 	mvcr\.d cp0,lr,cr14
+ *[0-9a-f]*:	ef a0 ee 10 	mvcr\.d cp7,r0,cr14
+ *[0-9a-f]*:	ef ae e0 10 	mvcr\.d cp7,lr,cr0
+ *[0-9a-f]*:	ef a6 88 10 	mvcr\.d cp4,r6,cr8
+ *[0-9a-f]*:	ef a8 66 10 	mvcr\.d cp3,r8,cr6
+
+[0-9a-f]* <mvrc_w>:
+ *[0-9a-f]*:	ef af ef 20 	mvrc\.w cp7,cr15,pc
+ *[0-9a-f]*:	ef a0 00 20 	mvrc\.w cp0,cr0,r0
+ *[0-9a-f]*:	ef af 0f 20 	mvrc\.w cp0,cr15,pc
+ *[0-9a-f]*:	ef a0 ef 20 	mvrc\.w cp7,cr15,r0
+ *[0-9a-f]*:	ef af e0 20 	mvrc\.w cp7,cr0,pc
+ *[0-9a-f]*:	ef a7 88 20 	mvrc\.w cp4,cr8,r7
+ *[0-9a-f]*:	ef a8 67 20 	mvrc\.w cp3,cr7,r8
+
+[0-9a-f]* <mvrc_d>:
+ *[0-9a-f]*:	ef ae ee 30 	mvrc\.d cp7,cr14,lr
+ *[0-9a-f]*:	ef a0 00 30 	mvrc\.d cp0,cr0,r0
+ *[0-9a-f]*:	ef ae 0e 30 	mvrc\.d cp0,cr14,lr
+ *[0-9a-f]*:	ef a0 ee 30 	mvrc\.d cp7,cr14,r0
+ *[0-9a-f]*:	ef ae e0 30 	mvrc\.d cp7,cr0,lr
+ *[0-9a-f]*:	ef a6 88 30 	mvrc\.d cp4,cr8,r6
+ *[0-9a-f]*:	ef a8 66 30 	mvrc\.d cp3,cr6,r8
+
+[0-9a-f]* <bfexts>:
+ *[0-9a-f]*:	ff df b3 ff 	bfexts pc,pc,0x1f,0x1f
+ *[0-9a-f]*:	e1 d0 b0 00 	bfexts r0,r0,0x0,0x0
+ *[0-9a-f]*:	e1 df b3 ff 	bfexts r0,pc,0x1f,0x1f
+ *[0-9a-f]*:	ff d0 b3 ff 	bfexts pc,r0,0x1f,0x1f
+ *[0-9a-f]*:	ff df b0 1f 	bfexts pc,pc,0x0,0x1f
+ *[0-9a-f]*:	ff df b3 e0 	bfexts pc,pc,0x1f,0x0
+ *[0-9a-f]*:	ef d8 b1 f0 	bfexts r7,r8,0xf,0x10
+ *[0-9a-f]*:	f1 d7 b2 0f 	bfexts r8,r7,0x10,0xf
+
+[0-9a-f]* <bfextu>:
+ *[0-9a-f]*:	ff df c3 ff 	bfextu pc,pc,0x1f,0x1f
+ *[0-9a-f]*:	e1 d0 c0 00 	bfextu r0,r0,0x0,0x0
+ *[0-9a-f]*:	e1 df c3 ff 	bfextu r0,pc,0x1f,0x1f
+ *[0-9a-f]*:	ff d0 c3 ff 	bfextu pc,r0,0x1f,0x1f
+ *[0-9a-f]*:	ff df c0 1f 	bfextu pc,pc,0x0,0x1f
+ *[0-9a-f]*:	ff df c3 e0 	bfextu pc,pc,0x1f,0x0
+ *[0-9a-f]*:	ef d8 c1 f0 	bfextu r7,r8,0xf,0x10
+ *[0-9a-f]*:	f1 d7 c2 0f 	bfextu r8,r7,0x10,0xf
+
+[0-9a-f]* <bfins>:
+ *[0-9a-f]*:	ff df d3 ff 	bfins pc,pc,0x1f,0x1f
+ *[0-9a-f]*:	e1 d0 d0 00 	bfins r0,r0,0x0,0x0
+ *[0-9a-f]*:	e1 df d3 ff 	bfins r0,pc,0x1f,0x1f
+ *[0-9a-f]*:	ff d0 d3 ff 	bfins pc,r0,0x1f,0x1f
+ *[0-9a-f]*:	ff df d0 1f 	bfins pc,pc,0x0,0x1f
+ *[0-9a-f]*:	ff df d3 e0 	bfins pc,pc,0x1f,0x0
+ *[0-9a-f]*:	ef d8 d1 f0 	bfins r7,r8,0xf,0x10
+ *[0-9a-f]*:	f1 d7 d2 0f 	bfins r8,r7,0x10,0xf
+
+[0-9a-f]* <rsubc>:
+ *[0-9a-f]*:	fb bf 00 00 	rsubeq pc,0
+ *[0-9a-f]*:	fb bc 0f ff 	rsubal r12,-1
+ *[0-9a-f]*:	fb b5 08 80 	rsubls r5,-128
+ *[0-9a-f]*:	fb b4 07 7f 	rsubpl r4,127
+ *[0-9a-f]*:	fb be 01 01 	rsubne lr,1
+ *[0-9a-f]*:	fb bc 08 76 	rsubls r12,118
+ *[0-9a-f]*:	fb be 0d f4 	rsubvc lr,-12
+ *[0-9a-f]*:	fb b4 06 f3 	rsubmi r4,-13
+
+[0-9a-f]* <addc>:
+ *[0-9a-f]*:	ff df e0 0f 	addeq pc,pc,pc
+ *[0-9a-f]*:	f9 dc ef 0c 	addal r12,r12,r12
+ *[0-9a-f]*:	eb d5 e8 05 	addls r5,r5,r5
+ *[0-9a-f]*:	e9 d4 e7 04 	addpl r4,r4,r4   
+ *[0-9a-f]*:	fd de e1 0e 	addne lr,lr,lr
+ *[0-9a-f]*:	e5 d1 e8 0a 	addls r10,r2,r1
+ *[0-9a-f]*:	f1 db ed 0c 	addvc r12,r8,r11
+ *[0-9a-f]*:	ef d0 e6 0a 	addmi r10,r7,r0
+
+[0-9a-f]* <subc2>:
+ *[0-9a-f]*:	ff df e0 1f 	subeq pc,pc,pc
+ *[0-9a-f]*:	f9 dc ef 1c 	subal r12,r12,r12
+ *[0-9a-f]*:	eb d5 e8 15 	subls r5,r5,r5
+ *[0-9a-f]*:	e9 d4 e7 14 	subpl r4,r4,r4   
+ *[0-9a-f]*:	fd de e1 1e 	subne lr,lr,lr
+ *[0-9a-f]*:	e5 d1 e8 1a 	subls r10,r2,r1
+ *[0-9a-f]*:	f1 db ed 1c 	subvc r12,r8,r11
+ *[0-9a-f]*:	ef d0 e6 1a 	submi r10,r7,r0
+
+[0-9a-f]* <andc>:
+ *[0-9a-f]*:	ff df e0 2f 	andeq pc,pc,pc
+ *[0-9a-f]*:	f9 dc ef 2c 	andal r12,r12,r12
+ *[0-9a-f]*:	eb d5 e8 25 	andls r5,r5,r5
+ *[0-9a-f]*:	e9 d4 e7 24 	andpl r4,r4,r4   
+ *[0-9a-f]*:	fd de e1 2e 	andne lr,lr,lr
+ *[0-9a-f]*:	e5 d1 e8 2a 	andls r10,r2,r1
+ *[0-9a-f]*:	f1 db ed 2c 	andvc r12,r8,r11
+ *[0-9a-f]*:	ef d0 e6 2a 	andmi r10,r7,r0
+
+[0-9a-f]* <orc>:
+ *[0-9a-f]*:	ff df e0 3f 	oreq pc,pc,pc
+ *[0-9a-f]*:	f9 dc ef 3c 	oral r12,r12,r12
+ *[0-9a-f]*:	eb d5 e8 35 	orls r5,r5,r5
+ *[0-9a-f]*:	e9 d4 e7 34 	orpl r4,r4,r4   
+ *[0-9a-f]*:	fd de e1 3e 	orne lr,lr,lr
+ *[0-9a-f]*:	e5 d1 e8 3a 	orls r10,r2,r1
+ *[0-9a-f]*:	f1 db ed 3c 	orvc r12,r8,r11
+ *[0-9a-f]*:	ef d0 e6 3a 	ormi r10,r7,r0
+
+[0-9a-f]* <eorc>:
+ *[0-9a-f]*:	ff df e0 4f 	eoreq pc,pc,pc
+ *[0-9a-f]*:	f9 dc ef 4c 	eoral r12,r12,r12
+ *[0-9a-f]*:	eb d5 e8 45 	eorls r5,r5,r5
+ *[0-9a-f]*:	e9 d4 e7 44 	eorpl r4,r4,r4   
+ *[0-9a-f]*:	fd de e1 4e 	eorne lr,lr,lr
+ *[0-9a-f]*:	e5 d1 e8 4a 	eorls r10,r2,r1
+ *[0-9a-f]*:	f1 db ed 4c 	eorvc r12,r8,r11
+ *[0-9a-f]*:	ef d0 e6 4a 	eormi r10,r7,r0
+
+[0-9a-f]* <ldcond>:
+ *[0-9a-f]*:	ff ff 01 ff     ld.weq  pc,pc[0x7fc]
+ *[0-9a-f]*:	f9 fc f3 ff     ld.shal r12,r12[0x3fe]
+ *[0-9a-f]*:	eb f5 84 00     ld.shls r5,r5[0x0]
+ *[0-9a-f]*:	e9 f4 79 ff     ld.ubpl r4,r4[0x1ff]
+ *[0-9a-f]*:	fd fe 16 00     ld.sbne lr,lr[0x0]
+ *[0-9a-f]*:	e5 fa 80 00     ld.wls  r10,r2[0x0]
+ *[0-9a-f]*:	f1 fc d3 ff     ld.shvc r12,r8[0x3fe]
+ *[0-9a-f]*:	ef fa 68 01     ld.ubmi r10,r7[0x1]
+
+[0-9a-f]* <stcond2>:
+ *[0-9a-f]*:	ff ff 0b ff     st.weq pc[0x7fc],pc
+ *[0-9a-f]*:	f9 fc fd ff     st.hal r12[0x3fe],r12
+ *[0-9a-f]*:	eb f5 8c 00     st.hls r5[0x0],r5
+ *[0-9a-f]*:	e9 f4 7f ff     st.bpl r4[0x1ff],r4
+ *[0-9a-f]*:	fd fe 1e 00     st.bne lr[0x0],lr
+ *[0-9a-f]*:	e5 fa 8a 00     st.wls r2[0x0],r10
+ *[0-9a-f]*:	f1 fc dd ff     st.hvc r8[0x3fe],r12
+ *[0-9a-f]*:	ef fa 6e 01     st.bmi r7[0x1],r10
+
+[0-9a-f]* <movh>:
+ *[0-9a-f]*:	fc 1f ff ff     movh pc,0xffff
+ *[0-9a-f]*:	fc 10 00 00     movh r0,0x0
+ *[0-9a-f]*:	fc 15 00 01     movh r5,0x1
+ *[0-9a-f]*:	fc 1c 7f ff     movh r12,0x7fff
+
--- /dev/null
+++ b/gas/testsuite/gas/avr32/allinsn.exp
@@ -0,0 +1,5 @@
+# AVR32 assembler testsuite. -*- Tcl -*-
+
+if [istarget avr32-*-*] {
+    run_dump_test "allinsn"
+}
--- /dev/null
+++ b/gas/testsuite/gas/avr32/allinsn.s
@@ -0,0 +1,3330 @@
+ .data
+foodata: .word 42
+ .text
+footext:
+	.text
+	.global ld_d5
+ld_d5:
+	ld.d lr,pc[pc<<3]
+	ld.d r0,r0[r0<<0]
+	ld.d r6,r5[r5<<2]
+	ld.d r4,r4[r4<<1]
+	ld.d lr,lr[lr<<1]
+	ld.d r10,r3[sp<<2]
+	ld.d r8,r10[r6<<2]
+	ld.d r2,r7[r9<<0]
+	.text
+	.global ld_w5
+ld_w5:
+	ld.w pc,pc[pc<<0]
+	ld.w r12,r12[r12<<3]
+	ld.w r5,r5[r5<<2]
+	ld.w r4,r4[r4<<1]
+	ld.w lr,lr[lr<<1]
+	ld.w r2,r9[r9<<0]
+	ld.w r11,r2[r6<<0]
+	ld.w r0,r2[sp<<3]
+	.text
+	.global ld_sh5
+ld_sh5:
+	ld.sh pc,pc[pc<<0]
+	ld.sh r12,r12[r12<<3]
+	ld.sh r5,r5[r5<<2]
+	ld.sh r4,r4[r4<<1]
+	ld.sh lr,lr[lr<<1]
+	ld.sh r11,r0[pc<<2]
+	ld.sh r10,sp[r6<<2]
+	ld.sh r12,r2[r2<<0]
+	.text
+	.global ld_uh5
+ld_uh5:
+	ld.uh pc,pc[pc<<0]
+	ld.uh r12,r12[r12<<3]
+	ld.uh r5,r5[r5<<2]
+	ld.uh r4,r4[r4<<1]
+	ld.uh lr,lr[lr<<1]
+	ld.uh r8,pc[lr<<3]
+	ld.uh r6,r1[pc<<1]
+	ld.uh r6,lr[sp<<1]
+	.text
+	.global ld_sb2
+ld_sb2:
+	ld.sb pc,pc[pc<<0]
+	ld.sb r12,r12[r12<<3]
+	ld.sb r5,r5[r5<<2]
+	ld.sb r4,r4[r4<<1]
+	ld.sb lr,lr[lr<<1]
+	ld.sb r9,r1[pc<<3]
+	ld.sb r0,r3[r11<<1]
+	ld.sb r10,r5[r5<<1]
+	.text
+	.global ld_ub5
+ld_ub5:
+	ld.ub pc,pc[pc<<0]
+	ld.ub r12,r12[r12<<3]
+	ld.ub r5,r5[r5<<2]
+	ld.ub r4,r4[r4<<1]
+	ld.ub lr,lr[lr<<1]
+	ld.ub r6,r12[r7<<3]
+	ld.ub r2,r6[r12<<0]
+	ld.ub r0,r7[r11<<1]
+	.text
+	.global st_d5
+st_d5:
+	st.d pc[pc<<0],r14
+	st.d r12[r12<<3],r12
+	st.d r5[r5<<2],r6
+	st.d r4[r4<<1],r4
+	st.d lr[lr<<1],lr
+	st.d r1[r9<<1],r4
+	st.d r10[r2<<1],r4
+	st.d r12[r6<<0],lr
+	.text
+	.global st_w5
+st_w5:
+	st.w pc[pc<<0],pc
+	st.w r12[r12<<3],r12
+	st.w r5[r5<<2],r5
+	st.w r4[r4<<1],r4
+	st.w lr[lr<<1],lr
+	st.w r1[r10<<0],r3
+	st.w r0[r10<<1],r9
+	st.w r4[r5<<3],pc
+	.text
+	.global st_h5
+st_h5:
+	st.h pc[pc<<0],pc
+	st.h r12[r12<<3],r12
+	st.h r5[r5<<2],r5
+	st.h r4[r4<<1],r4
+	st.h lr[lr<<1],lr
+	st.h r2[r9<<0],r11
+	st.h r5[r1<<2],r12
+	st.h pc[r8<<2],r3
+	.text
+	.global st_b5
+st_b5:
+	st.b pc[pc<<0],pc
+	st.b r12[r12<<3],r12
+	st.b r5[r5<<2],r5
+	st.b r4[r4<<1],r4
+	st.b lr[lr<<1],lr
+	st.b r1[r8<<1],r6
+	st.b lr[lr<<3],r1
+	st.b r5[r0<<2],pc
+	.text
+	.global divs
+divs:
+	divs pc,pc,pc
+	divs r12,r12,r12
+	divs r5,r5,r5
+	divs r4,r4,r4
+	divs lr,lr,lr
+	divs r3,pc,pc
+	divs r9,r12,r2
+	divs r7,r4,r1
+	.text
+	.global add1
+add1:
+	add pc,pc
+	add r12,r12
+	add r5,r5
+	add r4,r4
+	add lr,lr
+	add r12,r9
+	add r6,r3
+	add r10,r12
+	.text
+	.global sub1
+sub1:
+	sub pc,pc
+	sub r12,r12
+	sub r5,r5
+	sub r4,r4
+	sub lr,lr
+	sub lr,r6
+	sub r0,sp
+	sub r6,r12
+	.text
+	.global rsub1
+rsub1:
+	rsub pc,pc
+	rsub r12,r12
+	rsub r5,r5
+	rsub r4,r4
+	rsub lr,lr
+	rsub r11,sp
+	rsub r7,r4
+	rsub r9,r1
+	.text
+	.global cp1
+cp1:
+	cp pc,pc
+	cp r12,r12
+	cp r5,r5
+	cp r4,r4
+	cp lr,lr
+	cp r6,r2
+	cp r0,r9
+	cp r3,sp
+	.text
+	.global or1
+or1:
+	or pc,pc
+	or r12,r12
+	or r5,r5
+	or r4,r4
+	or lr,lr
+	or r4,r9
+	or r11,r4
+	or r4,r0
+	.text
+	.global eor1
+eor1:
+	eor pc,pc
+	eor r12,r12
+	eor r5,r5
+	eor r4,r4
+	eor lr,lr
+	eor r12,r11
+	eor r0,r1
+	eor r5,pc
+	.text
+	.global and1
+and1:
+	and pc,pc
+	and r12,r12
+	and r5,r5
+	and r4,r4
+	and lr,lr
+	and r8,r1
+	and r0,sp
+	and r10,r5
+	.text
+	.global tst
+tst:
+	tst pc,pc
+	tst r12,r12
+	tst r5,r5
+	tst r4,r4
+	tst lr,lr
+	tst r0,r12
+	tst r10,r6
+	tst sp,r4
+	.text
+	.global andn
+andn:
+	andn pc,pc
+	andn r12,r12
+	andn r5,r5
+	andn r4,r4
+	andn lr,lr
+	andn r9,r12
+	andn r11,sp
+	andn r12,r5
+	.text
+	.global mov3
+mov3:
+	mov pc,pc
+	mov r12,r12
+	mov r5,r5
+	mov r4,r4
+	mov lr,lr
+	mov r5,r9
+	mov r11,r11
+	mov r2,lr
+	.text
+	.global st_w1
+st_w1:
+	st.w pc++,pc
+	st.w r12++,r12
+	st.w r5++,r5
+	st.w r4++,r4
+	st.w lr++,lr
+	st.w r1++,r11
+	st.w sp++,r0
+	st.w sp++,r1
+	.text
+	.global st_h1
+st_h1:
+	st.h pc++,pc
+	st.h r12++,r12
+	st.h r5++,r5
+	st.h r4++,r4
+	st.h lr++,lr
+	st.h r12++,sp
+	st.h r7++,lr
+	st.h r7++,r4
+	.text
+	.global st_b1
+st_b1:
+	st.b pc++,pc
+	st.b r12++,r12
+	st.b r5++,r5
+	st.b r4++,r4
+	st.b lr++,lr
+	st.b r9++,sp
+	st.b r1++,sp
+	st.b r0++,r4
+	.text
+	.global st_w2
+st_w2:
+	st.w --pc,pc
+	st.w --r12,r12
+	st.w --r5,r5
+	st.w --r4,r4
+	st.w --lr,lr
+	st.w --r1,r7
+	st.w --r3,r9
+	st.w --r5,r5
+	.text
+	.global st_h2
+st_h2:
+	st.h --pc,pc
+	st.h --r12,r12
+	st.h --r5,r5
+	st.h --r4,r4
+	st.h --lr,lr
+	st.h --r5,r7
+	st.h --r8,r8
+	st.h --r7,r2
+	.text
+	.global st_b2
+st_b2:
+	st.b --pc,pc
+	st.b --r12,r12
+	st.b --r5,r5
+	st.b --r4,r4
+	st.b --lr,lr
+	st.b --sp,sp
+	st.b --sp,r11
+	st.b --r4,r5
+	.text
+	.global ld_w1
+ld_w1:
+	ld.w pc,pc++
+	ld.w r12,r12++
+	ld.w r5,r5++
+	ld.w r4,r4++
+	ld.w lr,lr++
+	ld.w r3,r7++
+	ld.w r3,lr++
+	ld.w r12,r5++
+	.text
+	.global ld_sh1
+ld_sh1:
+	ld.sh pc,pc++
+	ld.sh r12,r12++
+	ld.sh r5,r5++
+	ld.sh r4,r4++
+	ld.sh lr,lr++
+	ld.sh r11,r2++
+	ld.sh r2,r8++
+	ld.sh r7,r6++
+	.text
+	.global ld_uh1
+ld_uh1:
+	ld.uh pc,pc++
+	ld.uh r12,r12++
+	ld.uh r5,r5++
+	ld.uh r4,r4++
+	ld.uh lr,lr++
+	ld.uh r6,r7++
+	ld.uh r10,r11++
+	ld.uh lr,r4++
+	.text
+	.global ld_ub1
+ld_ub1:
+	ld.ub pc,pc++
+	ld.ub r12,r12++
+	ld.ub r5,r5++
+	ld.ub r4,r4++
+	ld.ub lr,lr++
+	ld.ub r8,lr++
+	ld.ub r12,r12++
+	ld.ub r11,r10++
+	.text
+	.global ld_w2
+ld_w2:
+	ld.w pc,--pc
+	ld.w r12,--r12
+	ld.w r5,--r5
+	ld.w r4,--r4
+	ld.w lr,--lr
+	ld.w r10,--lr
+	ld.w r12,--r9
+	ld.w r6,--r5
+	.text
+	.global ld_sh2
+ld_sh2:
+	ld.sh pc,--pc
+	ld.sh r12,--r12
+	ld.sh r5,--r5
+	ld.sh r4,--r4
+	ld.sh lr,--lr
+	ld.sh pc,--r10
+	ld.sh r6,--r3
+	ld.sh r4,--r6
+	.text
+	.global ld_uh2
+ld_uh2:
+	ld.uh pc,--pc
+	ld.uh r12,--r12
+	ld.uh r5,--r5
+	ld.uh r4,--r4
+	ld.uh lr,--lr
+	ld.uh r3,--r2
+	ld.uh r1,--r0
+	ld.uh r2,--r9
+	.text
+	.global ld_ub2
+ld_ub2:
+	ld.ub pc,--pc
+	ld.ub r12,--r12
+	ld.ub r5,--r5
+	ld.ub r4,--r4
+	ld.ub lr,--lr
+	ld.ub r1,--r1
+	ld.ub r0,--r6
+	ld.ub r2,--r7
+	.text
+	.global ld_ub3
+ld_ub3:
+	ld.ub pc,pc[0]
+	ld.ub r12,r12[7]
+	ld.ub r5,r5[4]
+	ld.ub r4,r4[3]
+	ld.ub lr,lr[1]
+	ld.ub r6,r9[6]
+	ld.ub r2,lr[4]
+	ld.ub r1,r8[0]
+	.text
+	.global sub3_sp
+sub3_sp:
+	sub sp,0
+	sub sp,-4
+	sub sp,-512
+	sub sp,508
+	sub sp,4
+	sub sp,44
+	sub sp,8
+	sub sp,348
+	.text
+	.global sub3
+sub3:
+	sub pc,0
+	sub r12,-1
+	sub r5,-128
+	sub r4,127
+	sub lr,1
+	sub r6,-41
+	sub r4,37
+	sub r12,56
+	.text
+	.global mov1
+mov1:
+	mov pc,0
+	mov r12,-1
+	mov r5,-128
+	mov r4,127
+	mov lr,1
+	mov pc,14
+	mov r6,-100
+	mov lr,-122
+	.text
+	.global lddsp
+lddsp:
+	lddsp pc,sp[0]
+	lddsp r12,sp[508]
+	lddsp r5,sp[256]
+	lddsp r4,sp[252]
+	lddsp lr,sp[4]
+	lddsp lr,sp[256]
+	lddsp r12,sp[20]
+	lddsp r9,sp[472]
+	.text
+	.global lddpc
+lddpc:
+	lddpc pc,pc[0]
+	lddpc r0,pc[508]
+	lddpc r8,pc[256]
+	lddpc r7,pc[252]
+	lddpc lr,pc[4]
+	lddpc sp,pc[472]
+	lddpc r6,pc[120]
+	lddpc r11,pc[28]
+	.text
+	.global stdsp
+stdsp:
+	stdsp sp[0],pc
+	stdsp sp[508],r12
+	stdsp sp[256],r5
+	stdsp sp[252],r4
+	stdsp sp[4],lr
+	stdsp sp[304],pc
+	stdsp sp[256],r0
+	stdsp sp[336],r5
+	.text
+	.global cp2
+cp2:
+	cp pc,0
+	cp r12,-1
+	cp r5,-32
+	cp r4,31
+	cp lr,1
+	cp r8,3
+	cp lr,16
+	cp r7,-26
+	.text
+	.global acr
+acr:
+	acr pc
+	acr r12
+	acr r5
+	acr r4
+	acr lr
+	acr r2
+	acr r12
+	acr pc
+	.text
+	.global scr
+scr:
+	scr pc
+	scr r12
+	scr r5
+	scr r4
+	scr lr
+	scr pc
+	scr r6
+	scr r1
+	.text
+	.global cpc0
+cpc0:
+	cpc pc
+	cpc r12
+	cpc r5
+	cpc r4
+	cpc lr
+	cpc pc
+	cpc r4
+	cpc r9
+	.text
+	.global neg
+neg:
+	neg pc
+	neg r12
+	neg r5
+	neg r4
+	neg lr
+	neg r7
+	neg r1
+	neg r9
+	.text
+	.global abs
+abs:
+	abs pc
+	abs r12
+	abs r5
+	abs r4
+	abs lr
+	abs r6
+	abs r6
+	abs r4
+	.text
+	.global castu_b
+castu_b:
+	castu.b pc
+	castu.b r12
+	castu.b r5
+	castu.b r4
+	castu.b lr
+	castu.b r7
+	castu.b sp
+	castu.b r9
+	.text
+	.global casts_b
+casts_b:
+	casts.b pc
+	casts.b r12
+	casts.b r5
+	casts.b r4
+	casts.b lr
+	casts.b r11
+	casts.b r1
+	casts.b r10
+	.text
+	.global castu_h
+castu_h:
+	castu.h pc
+	castu.h r12
+	castu.h r5
+	castu.h r4
+	castu.h lr
+	castu.h r10
+	castu.h r11
+	castu.h r1
+	.text
+	.global casts_h
+casts_h:
+	casts.h pc
+	casts.h r12
+	casts.h r5
+	casts.h r4
+	casts.h lr
+	casts.h r0
+	casts.h r5
+	casts.h r9
+	.text
+	.global brev
+brev:
+	brev pc
+	brev r12
+	brev r5
+	brev r4
+	brev lr
+	brev r5
+	brev r10
+	brev r8
+	.text
+	.global swap_h
+swap_h:
+	swap.h pc
+	swap.h r12
+	swap.h r5
+	swap.h r4
+	swap.h lr
+	swap.h r7
+	swap.h r0
+	swap.h r8
+	.text
+	.global swap_b
+swap_b:
+	swap.b pc
+	swap.b r12
+	swap.b r5
+	swap.b r4
+	swap.b lr
+	swap.b r10
+	swap.b r12
+	swap.b r1
+	.text
+	.global swap_bh
+swap_bh:
+	swap.bh pc
+	swap.bh r12
+	swap.bh r5
+	swap.bh r4
+	swap.bh lr
+	swap.bh r9
+	swap.bh r4
+	swap.bh r1
+	.text
+	.global One_s_compliment
+One_s_compliment:
+	com pc
+	com r12
+	com r5
+	com r4
+	com lr
+	com r2
+	com r2
+	com r7
+	.text
+	.global tnbz
+tnbz:
+	tnbz pc
+	tnbz r12
+	tnbz r5
+	tnbz r4
+	tnbz lr
+	tnbz r8
+	tnbz r12
+	tnbz pc
+	.text
+	.global rol
+rol:
+	rol pc
+	rol r12
+	rol r5
+	rol r4
+	rol lr
+	rol r10
+	rol r9
+	rol r5
+	.text
+	.global ror
+ror:
+	ror pc
+	ror r12
+	ror r5
+	ror r4
+	ror lr
+	ror r8
+	ror r4
+	ror r7
+	.text
+	.global icall
+icall:
+	icall pc
+	icall r12
+	icall r5
+	icall r4
+	icall lr
+	icall r3
+	icall r1
+	icall r3
+	.text
+	.global mustr
+mustr:
+	mustr pc
+	mustr r12
+	mustr r5
+	mustr r4
+	mustr lr
+	mustr r1
+	mustr r4
+	mustr r12
+	.text
+	.global musfr
+musfr:
+	musfr pc
+	musfr r12
+	musfr r5
+	musfr r4
+	musfr lr
+	musfr r11
+	musfr r12
+	musfr r2
+	.text
+	.global ret_cond
+ret_cond:
+	reteq pc
+	retal r12
+	retls r5
+	retpl r4
+	retne lr
+	retgt r0
+	retgt r12
+	retge r10
+	.text
+	.global sr_cond
+sr_cond:
+	sreq pc
+	sral r12
+	srls r5
+	srpl r4
+	srne lr
+	srlt r0
+	sral sp
+	srge r9
+	.text
+	.global ld_w3
+ld_w3:
+	ld.w pc,pc[0]
+	ld.w r12,r12[124]
+	ld.w r5,r5[64]
+	ld.w r4,r4[60]
+	ld.w lr,lr[4]
+	ld.w sp,r2[52]
+	ld.w r9,r1[8]
+	ld.w r5,sp[60]
+	.text
+	.global ld_sh3
+ld_sh3:
+	ld.sh pc,pc[0]
+	ld.sh r12,r12[14]
+	ld.sh r5,r5[8]
+	ld.sh r4,r4[6]
+	ld.sh lr,lr[2]
+	ld.sh r4,r2[8]
+	ld.sh sp,lr[10]
+	ld.sh r2,r11[2]
+	.text
+	.global ld_uh3
+ld_uh3:
+	ld.uh pc,pc[0]
+	ld.uh r12,r12[14]
+	ld.uh r5,r5[8]
+	ld.uh r4,r4[6]
+	ld.uh lr,lr[2]
+	ld.uh r10,r0[10]
+	ld.uh r8,r11[8]
+	ld.uh r10,r2[12]
+	.text
+	.global st_w3
+st_w3:
+	st.w pc[0],pc
+	st.w r12[60],r12
+	st.w r5[32],r5
+	st.w r4[28],r4
+	st.w lr[4],lr
+	st.w r7[44],r11
+	st.w r2[24],r6
+	st.w r4[12],r9
+	.text
+	.global st_h3
+st_h3:
+	st.h pc[0],pc
+	st.h r12[14],r12
+	st.h r5[8],r5
+	st.h r4[6],r4
+	st.h lr[2],lr
+	st.h lr[10],r12
+	st.h r6[4],r0
+	st.h r5[12],sp
+	.text
+	.global st_b3
+st_b3:
+	st.b pc[0],pc
+	st.b r12[7],r12
+	st.b r5[4],r5
+	st.b r4[3],r4
+	st.b lr[1],lr
+	st.b r12[6],r9
+	st.b r2[3],lr
+	st.b r1[3],r11
+	.text
+	.global ldd
+ldd:
+	ld.d r0,pc
+	ld.d r14,r12
+	ld.d r8,r5
+	ld.d r6,r4
+	ld.d r2,lr
+	ld.d r14,r7
+	ld.d r4,r4
+	ld.d r14,pc
+	.text
+	.global ldd_postinc
+ldd_postinc:
+	ld.d r0,pc++
+	ld.d r14,r12++
+	ld.d r8,r5++
+	ld.d r6,r4++
+	ld.d r2,lr++
+	ld.d r14,r5++
+	ld.d r12,r11++
+	ld.d r2,r12++
+	.text
+	.global ldd_predec
+ldd_predec:
+	ld.d r0,--pc
+	ld.d r14,--r12
+	ld.d r8,--r5
+	ld.d r6,--r4
+	ld.d r2,--lr
+	ld.d r8,--r0
+	ld.d r10,--pc
+	ld.d r2,--r4
+	.text
+	.global std
+std:
+	st.d pc,r0
+	st.d r12,r14
+	st.d r5,r8
+	st.d r4,r6
+	st.d lr,r2
+	st.d r0,r12
+	st.d sp,r4
+	st.d r12,r12
+	.text
+	.global std_postinc
+std_postinc:
+	st.d pc++,r0
+	st.d r12++,r14
+	st.d r5++,r8
+	st.d r4++,r6
+	st.d lr++,r2
+	st.d sp++,r6
+	st.d r10++,r6
+	st.d r7++,r2
+	.text
+	.global std_predec
+std_predec:
+	st.d --pc,r0
+	st.d --r12,r14
+	st.d --r5,r8
+	st.d --r4,r6
+	st.d --lr,r2
+	st.d --r3,r6
+	st.d --lr,r2
+	st.d --r0,r4
+	.text
+	.global mul
+mul:
+	mul pc,pc
+	mul r12,r12
+	mul r5,r5
+	mul r4,r4
+	mul lr,lr
+	mul r10,lr
+	mul r0,r8
+	mul r8,r5
+	.text
+	.global asr_imm5
+asr_imm5:
+	asr pc,0
+	asr r12,31
+	asr r5,16
+	asr r4,15
+	asr lr,1
+	asr r6,23
+	asr r6,18
+	asr r5,8
+	.text
+	.global lsl_imm5
+lsl_imm5:
+	lsl pc,0
+	lsl r12,31
+	lsl r5,16
+	lsl r4,15
+	lsl lr,1
+	lsl r12,13
+	lsl r6,16
+	lsl r1,25
+	.text
+	.global lsr_imm5
+lsr_imm5:
+	lsr pc,0
+	lsr r12,31
+	lsr r5,16
+	lsr r4,15
+	lsr lr,1
+	lsr r0,1
+	lsr r8,10
+	lsr r7,26
+	.text
+	.global sbr
+sbr:
+	sbr pc,0
+	sbr r12,31
+	sbr r5,16
+	sbr r4,15
+	sbr lr,1
+	sbr r8,31
+	sbr r6,22
+	sbr r1,23
+	.text
+	.global cbr
+cbr:
+	cbr pc,0
+	cbr r12,31
+	cbr r5,16
+	cbr r4,15
+	cbr lr,1
+	cbr r12,10
+	cbr r7,22
+	cbr r8,9
+	.text
+	.global brc1
+brc1:
+	breq 0
+	brpl -2
+	brge -256
+	brcs 254
+	brne 2
+	brcs 230
+	breq -18
+	breq 12
+	.text
+	.global rjmp
+rjmp:
+	rjmp 0
+	rjmp -2
+	rjmp -1024
+	rjmp 1022
+	rjmp 2
+	rjmp -962
+	rjmp 14
+	rjmp -516
+	.text
+	.global rcall1
+rcall1:
+	rcall 0
+	rcall -2
+	rcall -1024
+	rcall 1022
+	rcall 2
+	rcall 216
+	rcall -530
+	rcall -972
+	.text
+	.global acall
+acall:
+	acall 0
+	acall 1020
+	acall 512
+	acall 508
+	acall 4
+	acall 356
+	acall 304
+	acall 172
+	.text
+	.global scall
+scall:
+	scall
+	scall
+	scall
+	scall
+	scall
+	scall
+	scall
+	scall
+	.text
+	.global popm
+popm:
+	/* popm with no argument fails currently */
+	popm pc
+	popm r0-r11,pc,r12=-1
+	popm lr
+	popm r0-r11,pc,r12=1
+	popm r0-r3
+	popm r4-r10,pc
+	popm r0-r3,r11,pc,r12=0
+	popm r0-r7,r10-r12,lr
+	.text
+	.global pushm
+pushm:
+	pushm pc
+	pushm r0-r12,lr,pc
+	pushm pc
+	pushm r0-r12,lr
+	pushm r0-r3
+	pushm r8-r10,lr,pc
+	pushm r0-r3,r10
+	pushm r8-r9,r12
+	.text
+	.global popm_n
+popm_n:
+	popm pc
+	popm r0-r11,pc,r12=-1
+	popm lr
+	popm r0-r11,pc,r12=1
+	popm r0-r3
+	popm r4-r10,pc
+	popm r0-r3,r11,pc,r12=0
+	popm r0-r7,r10-r12,lr
+	.text
+	.global pushm_n
+pushm_n:
+	pushm pc
+	pushm r0-r12,lr,pc
+	pushm pc
+	pushm r0-r12,lr
+	pushm r0-r3
+	pushm r8-r10,lr,pc
+	pushm r0-r3,r10
+	pushm r8-r9,r12
+	.text
+	.global csrfcz
+csrfcz:
+	csrfcz 0
+	csrfcz 31
+	csrfcz 16
+	csrfcz 15
+	csrfcz 1
+	csrfcz 5
+	csrfcz 13
+	csrfcz 23
+	.text
+	.global ssrf
+ssrf:
+	ssrf 0
+	ssrf 31
+	ssrf 16
+	ssrf 15
+	ssrf 1
+	ssrf 29
+	ssrf 13
+	ssrf 13
+	.text
+	.global csrf
+csrf:
+	csrf 0
+	csrf 31
+	csrf 16
+	csrf 15
+	csrf 1
+	csrf 10
+	csrf 15
+	csrf 11
+	.text
+	.global rete
+rete:
+	rete
+	.text
+	.global rets
+rets:
+	rets
+	.text
+	.global retd
+retd:
+	retd
+	.text
+	.global retj
+retj:
+	retj
+	.text
+	.global tlbr
+tlbr:
+	tlbr
+	.text
+	.global tlbs
+tlbs:
+	tlbs
+	.text
+	.global tlbw
+tlbw:
+	tlbw
+	.text
+	.global breakpoint
+breakpoint:
+	breakpoint
+	.text
+	.global incjosp
+incjosp:
+	incjosp 1
+	incjosp 2
+	incjosp 3
+	incjosp 4
+	incjosp -4
+	incjosp -3
+	incjosp -2
+	incjosp -1
+	.text
+	.global nop
+nop:
+	nop
+	.text
+	.global popjc
+popjc:
+	popjc
+	.text
+	.global pushjc
+pushjc:
+	pushjc
+	.text
+	.global add2
+add2:
+	add pc,pc,pc<<0
+	add r12,r12,r12<<3
+	add r5,r5,r5<<2
+	add r4,r4,r4<<1
+	add lr,lr,lr<<1
+	add r0,r12,r0<<1
+	add r9,r12,r4<<0
+	add r12,r12,r7<<2
+	.text
+	.global sub2
+sub2:
+	sub pc,pc,pc<<0
+	sub r12,r12,r12<<3
+	sub r5,r5,r5<<2
+	sub r4,r4,r4<<1
+	sub lr,lr,lr<<1
+	sub sp,r3,r4<<0
+	sub r3,r7,r3<<0
+	sub sp,r10,sp<<1
+	.text
+	.global divu
+divu:
+	divu pc,pc,pc
+	divu r12,r12,r12
+	divu r5,r5,r5
+	divu r4,r4,r4
+	divu lr,lr,lr
+	divu sp,r4,pc
+	divu r5,r5,sp
+	divu r10,sp,r0
+	.text
+	.global addhh_w
+addhh_w:
+	addhh.w pc,pc:b,pc:b
+	addhh.w r12,r12:t,r12:t
+	addhh.w r5,r5:t,r5:t
+	addhh.w r4,r4:b,r4:b
+	addhh.w lr,lr:t,lr:t
+	addhh.w r0,r0:b,r3:b
+	addhh.w lr,r12:t,r7:b
+	addhh.w r3,r10:t,r2:b
+	.text
+	.global subhh_w
+subhh_w:
+	subhh.w pc,pc:b,pc:b
+	subhh.w r12,r12:t,r12:t
+	subhh.w r5,r5:t,r5:t
+	subhh.w r4,r4:b,r4:b
+	subhh.w lr,lr:t,lr:t
+	subhh.w r10,r1:t,r7:b
+	subhh.w pc,r10:t,lr:t
+	subhh.w r3,r0:t,r12:b
+	.text
+	.global adc
+adc:
+	adc pc,pc,pc
+	adc r12,r12,r12
+	adc r5,r5,r5
+	adc r4,r4,r4
+	adc lr,lr,lr
+	adc r4,r0,r7
+	adc sp,r4,r3
+	adc r2,r12,r0
+	.text
+	.global sbc
+sbc:
+	sbc pc,pc,pc
+	sbc r12,r12,r12
+	sbc r5,r5,r5
+	sbc r4,r4,r4
+	sbc lr,lr,lr
+	sbc r6,r7,r9
+	sbc r0,r8,r5
+	sbc r1,r0,r4
+	.text
+	.global mul_2
+mul_2:
+	mul pc,pc,pc
+	mul r12,r12,r12
+	mul r5,r5,r5
+	mul r4,r4,r4
+	mul lr,lr,lr
+	mul pc,r0,r0
+	mul r8,pc,lr
+	mul r4,r12,pc
+	.text
+	.global mac
+mac:
+	mac pc,pc,pc
+	mac r12,r12,r12
+	mac r5,r5,r5
+	mac r4,r4,r4
+	mac lr,lr,lr
+	mac r10,r4,r0
+	mac r7,lr,r0
+	mac r2,r9,r12
+	.text
+	.global mulsd
+mulsd:
+	muls.d pc,pc,pc
+	muls.d r12,r12,r12
+	muls.d r5,r5,r5
+	muls.d r4,r4,r4
+	muls.d lr,lr,lr
+	muls.d r2,r8,lr
+	muls.d r4,r0,r11
+	muls.d r5,lr,r6
+	.text
+	.global macsd
+macsd:
+	macs.d r0,pc,pc
+	macs.d r14,r12,r12
+	macs.d r8,r5,r5
+	macs.d r6,r4,r4
+	macs.d r2,lr,lr
+	macs.d r8,r1,r9
+	macs.d r14,r8,r8
+	macs.d r4,r3,r12
+	.text
+	.global mulud
+mulud:
+	mulu.d r0,pc,pc
+	mulu.d r14,r12,r12
+	mulu.d r8,r5,r5
+	mulu.d r6,r4,r4
+	mulu.d r2,lr,lr
+	mulu.d r6,r5,r0
+	mulu.d r4,r6,r1
+	mulu.d r8,r8,r2
+	.text
+	.global macud
+macud:
+	macu.d r0,pc,pc
+	macu.d r14,r12,r12
+	macu.d r8,r5,r5
+	macu.d r6,r4,r4
+	macu.d r2,lr,lr
+	macu.d r6,sp,r11
+	macu.d r2,r4,r8
+	macu.d r6,r10,r9
+	.text
+	.global asr_1
+asr_1:
+	asr pc,pc,pc
+	asr r12,r12,r12
+	asr r5,r5,r5
+	asr r4,r4,r4
+	asr lr,lr,lr
+	asr pc,r6,pc
+	asr r0,r6,r12
+	asr r4,sp,r0
+	.text
+	.global lsl_1
+lsl_1:
+	lsl pc,pc,pc
+	lsl r12,r12,r12
+	lsl r5,r5,r5
+	lsl r4,r4,r4
+	lsl lr,lr,lr
+	lsl lr,r5,lr
+	lsl r5,pc,r3
+	lsl r1,pc,r9
+	.text
+	.global lsr_1
+lsr_1:
+	lsr pc,pc,pc
+	lsr r12,r12,r12
+	lsr r5,r5,r5
+	lsr r4,r4,r4
+	lsr lr,lr,lr
+	lsr r2,r4,r1
+	lsr r5,r1,r6
+	lsr sp,r6,r7
+	.text
+	.global xchg
+xchg:
+	xchg pc,pc,pc
+	xchg r12,r12,r12
+	xchg r5,r5,r5
+	xchg r4,r4,r4
+	xchg lr,lr,lr
+	xchg lr,r4,sp
+	xchg r1,r5,r12
+	xchg lr,r12,r0
+	.text
+	.global max
+max:
+	max pc,pc,pc
+	max r12,r12,r12
+	max r5,r5,r5
+	max r4,r4,r4
+	max lr,lr,lr
+	max lr,r2,sp
+	max r4,r10,r9
+	max lr,r9,lr
+	.text
+	.global min
+min:
+	min pc,pc,pc
+	min r12,r12,r12
+	min r5,r5,r5
+	min r4,r4,r4
+	min lr,lr,lr
+	min r9,r7,r8
+	min sp,r5,r5
+	min r4,r1,r4
+	.text
+	.global addabs
+addabs:
+	addabs pc,pc,pc
+	addabs r12,r12,r12
+	addabs r5,r5,r5
+	addabs r4,r4,r4
+	addabs lr,lr,lr
+	addabs r7,r10,r0
+	addabs r9,r9,r7
+	addabs r2,r8,r12
+	.text
+	.global mulnhh_w
+mulnhh_w:
+	mulnhh.w pc,pc:b,pc:b
+	mulnhh.w r12,r12:t,r12:t
+	mulnhh.w r5,r5:t,r5:t
+	mulnhh.w r4,r4:b,r4:b
+	mulnhh.w lr,lr:t,lr:t
+	mulnhh.w r11,sp:t,r9:b
+	mulnhh.w sp,r4:b,lr:t
+	mulnhh.w r12,r2:t,r11:b
+	.text
+	.global mulnwh_d
+mulnwh_d:
+	mulnwh.d r0,pc,pc:b
+	mulnwh.d r14,r12,r12:t
+	mulnwh.d r8,r5,r5:t
+	mulnwh.d r6,r4,r4:b
+	mulnwh.d r2,lr,lr:t
+	mulnwh.d r14,r3,r2:t
+	mulnwh.d r4,r5,r9:b
+	mulnwh.d r12,r4,r4:t
+	.text
+	.global machh_w
+machh_w:
+	machh.w pc,pc:b,pc:b
+	machh.w r12,r12:t,r12:t
+	machh.w r5,r5:t,r5:t
+	machh.w r4,r4:b,r4:b
+	machh.w lr,lr:t,lr:t
+	machh.w lr,r5:b,r1:t
+	machh.w r9,r6:b,r7:b
+	machh.w r5,lr:t,r12:b
+	.text
+	.global machh_d
+machh_d:
+	machh.d r0,pc:b,pc:b
+	machh.d r14,r12:t,r12:t
+	machh.d r8,r5:t,r5:t
+	machh.d r6,r4:b,r4:b
+	machh.d r2,lr:t,lr:t
+	machh.d r10,r0:b,r8:b
+	machh.d r14,r4:b,r5:t
+	machh.d r8,r0:b,r4:t
+	.text
+	.global macsathh_w
+macsathh_w:
+	macsathh.w pc,pc:b,pc:b
+	macsathh.w r12,r12:t,r12:t
+	macsathh.w r5,r5:t,r5:t
+	macsathh.w r4,r4:b,r4:b
+	macsathh.w lr,lr:t,lr:t
+	macsathh.w r7,r7:t,pc:t
+	macsathh.w r4,r2:t,r4:b
+	macsathh.w r4,r8:t,r3:t
+	.text
+	.global mulhh_w
+mulhh_w:
+	mulhh.w pc,pc:b,pc:b
+	mulhh.w r12,r12:t,r12:t
+	mulhh.w r5,r5:t,r5:t
+	mulhh.w r4,r4:b,r4:b
+	mulhh.w lr,lr:t,lr:t
+	mulhh.w r7,r4:t,r9:b
+	mulhh.w pc,r3:t,r7:t
+	mulhh.w pc,r4:b,r9:t
+	.text
+	.global mulsathh_h
+mulsathh_h:
+	mulsathh.h pc,pc:b,pc:b
+	mulsathh.h r12,r12:t,r12:t
+	mulsathh.h r5,r5:t,r5:t
+	mulsathh.h r4,r4:b,r4:b
+	mulsathh.h lr,lr:t,lr:t
+	mulsathh.h r3,r1:b,sp:b
+	mulsathh.h r11,lr:t,r11:b
+	mulsathh.h r8,r8:b,r11:t
+	.text
+	.global mulsathh_w
+mulsathh_w:
+	mulsathh.w pc,pc:b,pc:b
+	mulsathh.w r12,r12:t,r12:t
+	mulsathh.w r5,r5:t,r5:t
+	mulsathh.w r4,r4:b,r4:b
+	mulsathh.w lr,lr:t,lr:t
+	mulsathh.w lr,r11:t,r6:b
+	mulsathh.w r6,r6:b,r7:t
+	mulsathh.w r10,r2:b,r3:b
+	.text
+	.global mulsatrndhh_h
+mulsatrndhh_h:
+	mulsatrndhh.h pc,pc:b,pc:b
+	mulsatrndhh.h r12,r12:t,r12:t
+	mulsatrndhh.h r5,r5:t,r5:t
+	mulsatrndhh.h r4,r4:b,r4:b
+	mulsatrndhh.h lr,lr:t,lr:t
+	mulsatrndhh.h r11,r6:b,r9:b
+	mulsatrndhh.h r11,r3:b,r8:t
+	mulsatrndhh.h r5,sp:t,r7:t
+	.text
+	.global mulsatrndwh_w
+mulsatrndwh_w:
+	mulsatrndwh.w pc,pc,pc:b
+	mulsatrndwh.w r12,r12,r12:t
+	mulsatrndwh.w r5,r5,r5:t
+	mulsatrndwh.w r4,r4,r4:b
+	mulsatrndwh.w lr,lr,lr:t
+	mulsatrndwh.w r5,r12,r0:b
+	mulsatrndwh.w r7,r10,pc:b
+	mulsatrndwh.w r10,r8,r5:t
+	.text
+	.global macwh_d
+macwh_d:
+	macwh.d r0,pc,pc:b
+	macwh.d r14,r12,r12:t
+	macwh.d r8,r5,r5:t
+	macwh.d r6,r4,r4:b
+	macwh.d r2,lr,lr:t
+	macwh.d r4,r10,r12:t
+	macwh.d r4,r7,sp:b
+	macwh.d r14,r9,r11:b
+	.text
+	.global mulwh_d
+mulwh_d:
+	mulwh.d r0,pc,pc:b
+	mulwh.d r14,r12,r12:t
+	mulwh.d r8,r5,r5:t
+	mulwh.d r6,r4,r4:b
+	mulwh.d r2,lr,lr:t
+	mulwh.d r12,r5,r1:b
+	mulwh.d r0,r1,r3:t
+	mulwh.d r0,r9,r2:b
+	.text
+	.global mulsatwh_w
+mulsatwh_w:
+	mulsatwh.w pc,pc,pc:b
+	mulsatwh.w r12,r12,r12:t
+	mulsatwh.w r5,r5,r5:t
+	mulsatwh.w r4,r4,r4:b
+	mulsatwh.w lr,lr,lr:t
+	mulsatwh.w r11,pc,r10:t
+	mulsatwh.w sp,r12,r9:t
+	mulsatwh.w r0,r3,r2:t
+	.text
+	.global ldw7
+ldw7:
+	ld.w pc,pc[pc:b<<2]
+	ld.w r12,r12[r12:t<<2]
+	ld.w r5,r5[r5:u<<2]
+	ld.w r4,r4[r4:l<<2]
+	ld.w lr,lr[lr:l<<2]
+	ld.w r9,r10[r6:l<<2]
+	ld.w r2,r10[r10:b<<2]
+	ld.w r11,r5[pc:b<<2]
+	.text
+	.global satadd_w
+satadd_w:
+	satadd.w pc,pc,pc
+	satadd.w r12,r12,r12
+	satadd.w r5,r5,r5
+	satadd.w r4,r4,r4
+	satadd.w lr,lr,lr
+	satadd.w r4,r8,r11
+	satadd.w r3,r12,r6
+	satadd.w r3,lr,r9
+	.text
+	.global satsub_w1
+satsub_w1:
+	satsub.w pc,pc,pc
+	satsub.w r12,r12,r12
+	satsub.w r5,r5,r5
+	satsub.w r4,r4,r4
+	satsub.w lr,lr,lr
+	satsub.w r8,sp,r0
+	satsub.w r9,r8,r4
+	satsub.w pc,lr,r2
+	.text
+	.global satadd_h
+satadd_h:
+	satadd.h pc,pc,pc
+	satadd.h r12,r12,r12
+	satadd.h r5,r5,r5
+	satadd.h r4,r4,r4
+	satadd.h lr,lr,lr
+	satadd.h r7,r3,r9
+	satadd.h r1,r0,r2
+	satadd.h r1,r4,lr
+	.text
+	.global satsub_h
+satsub_h:
+	satsub.h pc,pc,pc
+	satsub.h r12,r12,r12
+	satsub.h r5,r5,r5
+	satsub.h r4,r4,r4
+	satsub.h lr,lr,lr
+	satsub.h lr,lr,r3
+	satsub.h r11,r6,r5
+	satsub.h r3,sp,r0
+	.text
+	.global mul3
+mul3:
+	mul pc,pc,0
+	mul r12,r12,-1
+	mul r5,r5,-128
+	mul r4,r4,127
+	mul lr,lr,1
+	mul r12,r2,-7
+	mul r1,pc,95
+	mul r4,r6,19
+	.text
+	.global rsub2
+rsub2:
+	rsub pc,pc,0
+	rsub r12,r12,-1
+	rsub r5,r5,-128
+	rsub r4,r4,127
+	rsub lr,lr,1
+	rsub r9,lr,96
+	rsub r11,r1,56
+	rsub r0,r7,-87
+	.text
+	.global clz
+clz:
+	clz pc,pc
+	clz r12,r12
+	clz r5,r5
+	clz r4,r4
+	clz lr,lr
+	clz r2,r3
+	clz r5,r11
+	clz pc,r3
+	.text
+	.global cpc1
+cpc1:
+	cpc pc,pc
+	cpc r12,r12
+	cpc r5,r5
+	cpc r4,r4
+	cpc lr,lr
+	cpc pc,r4
+	cpc r5,r9
+	cpc r6,r7
+	.text
+	.global asr3
+asr3:
+	asr pc,pc,0
+	asr r12,r12,31
+	asr r5,r5,16
+	asr r4,r4,15
+	asr lr,lr,1
+	asr r4,r11,19
+	asr sp,pc,26
+	asr r11,sp,8
+	.text
+	.global lsl3
+lsl3:
+	lsl pc,pc,0
+	lsl r12,r12,31
+	lsl r5,r5,16
+	lsl r4,r4,15
+	lsl lr,lr,1
+	lsl r8,r10,17
+	lsl r2,lr,3
+	lsl lr,r11,14
+	.text
+	.global lsr3
+lsr3:
+	lsr pc,pc,0
+	lsr r12,r12,31
+	lsr r5,r5,16
+	lsr r4,r4,15
+	lsr lr,lr,1
+	lsr r4,r3,31
+	lsr pc,r9,14
+	lsr r3,r0,6
+/*	.text
+	.global extract_b
+extract_b:
+	extract.b pc,pc:b
+	extract.b r12,r12:t
+	extract.b r5,r5:u
+	extract.b r4,r4:l
+	extract.b lr,lr:l
+	extract.b r2,r5:l
+	extract.b r12,r3:l
+	extract.b sp,r3:l
+	.text
+	.global insert_b
+insert_b:
+	insert.b pc:b,pc
+	insert.b r12:t,r12
+	insert.b r5:u,r5
+	insert.b r4:l,r4
+	insert.b lr:l,lr
+	insert.b r12:u,r3
+	insert.b r10:l,lr
+	insert.b r11:l,r12
+	.text
+	.global extract_h
+extract_h:
+	extract.h pc,pc:b
+	extract.h r12,r12:t
+	extract.h r5,r5:t
+	extract.h r4,r4:b
+	extract.h lr,lr:t
+	extract.h r11,lr:b
+	extract.h r10,r0:b
+	extract.h r11,r12:b
+	.text
+	.global insert_h
+insert_h:
+	insert.h pc:b,pc
+	insert.h r12:t,r12
+	insert.h r5:t,r5
+	insert.h r4:b,r4
+	insert.h lr:t,lr
+	insert.h r12:t,r11
+	insert.h r7:b,r6
+	insert.h r1:t,r11 */
+	.text
+	.global movc1
+movc1:
+	moveq pc,pc
+	moval r12,r12
+	movls r5,r5
+	movpl r4,r4
+	movne lr,lr
+	movne pc,r11
+	movmi r10,r2
+	movls r8,r12
+	.text
+	.global padd_h
+padd_h:
+	padd.h pc,pc,pc
+	padd.h r12,r12,r12
+	padd.h r5,r5,r5
+	padd.h r4,r4,r4
+	padd.h lr,lr,lr
+	padd.h r8,r2,r7
+	padd.h r0,r0,r3
+	padd.h sp,r11,r6
+	.text
+	.global psub_h
+psub_h:
+	psub.h pc,pc,pc
+	psub.h r12,r12,r12
+	psub.h r5,r5,r5
+	psub.h r4,r4,r4
+	psub.h lr,lr,lr
+	psub.h lr,r6,r8
+	psub.h r0,r1,sp
+	psub.h pc,pc,sp
+	.text
+	.global paddx_h
+paddx_h:
+	paddx.h pc,pc,pc
+	paddx.h r12,r12,r12
+	paddx.h r5,r5,r5
+	paddx.h r4,r4,r4
+	paddx.h lr,lr,lr
+	paddx.h pc,pc,r1
+	paddx.h r10,r4,r5
+	paddx.h r5,pc,r2
+	.text
+	.global psubx_h
+psubx_h:
+	psubx.h pc,pc,pc
+	psubx.h r12,r12,r12
+	psubx.h r5,r5,r5
+	psubx.h r4,r4,r4
+	psubx.h lr,lr,lr
+	psubx.h r5,r12,r5
+	psubx.h r3,r8,r3
+	psubx.h r5,r2,r3
+	.text
+	.global padds_sh
+padds_sh:
+	padds.sh pc,pc,pc
+	padds.sh r12,r12,r12
+	padds.sh r5,r5,r5
+	padds.sh r4,r4,r4
+	padds.sh lr,lr,lr
+	padds.sh r9,lr,r2
+	padds.sh r6,r8,r1
+	padds.sh r6,r4,r10
+	.text
+	.global psubs_sh
+psubs_sh:
+	psubs.sh pc,pc,pc
+	psubs.sh r12,r12,r12
+	psubs.sh r5,r5,r5
+	psubs.sh r4,r4,r4
+	psubs.sh lr,lr,lr
+	psubs.sh r6,lr,r11
+	psubs.sh r2,r12,r4
+	psubs.sh r0,r9,r0
+	.text
+	.global paddxs_sh
+paddxs_sh:
+	paddxs.sh pc,pc,pc
+	paddxs.sh r12,r12,r12
+	paddxs.sh r5,r5,r5
+	paddxs.sh r4,r4,r4
+	paddxs.sh lr,lr,lr
+	paddxs.sh r0,r3,r9
+	paddxs.sh pc,r10,r11
+	paddxs.sh pc,r10,pc
+	.text
+	.global psubxs_sh
+psubxs_sh:
+	psubxs.sh pc,pc,pc
+	psubxs.sh r12,r12,r12
+	psubxs.sh r5,r5,r5
+	psubxs.sh r4,r4,r4
+	psubxs.sh lr,lr,lr
+	psubxs.sh r7,r4,r4
+	psubxs.sh r7,r8,r3
+	psubxs.sh pc,r6,r5
+	.text
+	.global padds_uh
+padds_uh:
+	padds.uh pc,pc,pc
+	padds.uh r12,r12,r12
+	padds.uh r5,r5,r5
+	padds.uh r4,r4,r4
+	padds.uh lr,lr,lr
+	padds.uh r12,r11,r7
+	padds.uh r7,r8,lr
+	padds.uh r6,r9,r7
+	.text
+	.global psubs_uh
+psubs_uh:
+	psubs.uh pc,pc,pc
+	psubs.uh r12,r12,r12
+	psubs.uh r5,r5,r5
+	psubs.uh r4,r4,r4
+	psubs.uh lr,lr,lr
+	psubs.uh lr,r10,r6
+	psubs.uh sp,r2,pc
+	psubs.uh r2,r9,r2
+	.text
+	.global paddxs_uh
+paddxs_uh:
+	paddxs.uh pc,pc,pc
+	paddxs.uh r12,r12,r12
+	paddxs.uh r5,r5,r5
+	paddxs.uh r4,r4,r4
+	paddxs.uh lr,lr,lr
+	paddxs.uh r7,r9,r5
+	paddxs.uh r9,r1,r4
+	paddxs.uh r5,r2,r3
+	.text
+	.global psubxs_uh
+psubxs_uh:
+	psubxs.uh pc,pc,pc
+	psubxs.uh r12,r12,r12
+	psubxs.uh r5,r5,r5
+	psubxs.uh r4,r4,r4
+	psubxs.uh lr,lr,lr
+	psubxs.uh sp,r5,sp
+	psubxs.uh sp,r6,r6
+	psubxs.uh r3,r11,r8
+	.text
+	.global paddh_sh
+paddh_sh:
+	paddh.sh pc,pc,pc
+	paddh.sh r12,r12,r12
+	paddh.sh r5,r5,r5
+	paddh.sh r4,r4,r4
+	paddh.sh lr,lr,lr
+	paddh.sh r12,sp,r3
+	paddh.sh pc,r5,r3
+	paddh.sh r8,r8,sp
+	.text
+	.global psubh_sh
+psubh_sh:
+	psubh.sh pc,pc,pc
+	psubh.sh r12,r12,r12
+	psubh.sh r5,r5,r5
+	psubh.sh r4,r4,r4
+	psubh.sh lr,lr,lr
+	psubh.sh r1,r5,r8
+	psubh.sh r7,r3,r6
+	psubh.sh r4,r3,r3
+	.text
+	.global paddxh_sh
+paddxh_sh:
+	paddxh.sh pc,pc,pc
+	paddxh.sh r12,r12,r12
+	paddxh.sh r5,r5,r5
+	paddxh.sh r4,r4,r4
+	paddxh.sh lr,lr,lr
+	paddxh.sh r6,r0,r4
+	paddxh.sh r9,r8,r9
+	paddxh.sh r3,r0,sp
+	.text
+	.global psubxh_sh
+psubxh_sh:
+	psubxh.sh pc,pc,pc
+	psubxh.sh r12,r12,r12
+	psubxh.sh r5,r5,r5
+	psubxh.sh r4,r4,r4
+	psubxh.sh lr,lr,lr
+	psubxh.sh r4,pc,r12
+	psubxh.sh r8,r4,r6
+	psubxh.sh r12,r9,r4
+	.text
+	.global paddsub_h
+paddsub_h:
+	paddsub.h pc,pc:b,pc:b
+	paddsub.h r12,r12:t,r12:t
+	paddsub.h r5,r5:t,r5:t
+	paddsub.h r4,r4:b,r4:b
+	paddsub.h lr,lr:t,lr:t
+	paddsub.h r5,r2:t,lr:b
+	paddsub.h r7,r1:b,r8:b
+	paddsub.h r6,r10:t,r5:t
+	.text
+	.global psubadd_h
+psubadd_h:
+	psubadd.h pc,pc:b,pc:b
+	psubadd.h r12,r12:t,r12:t
+	psubadd.h r5,r5:t,r5:t
+	psubadd.h r4,r4:b,r4:b
+	psubadd.h lr,lr:t,lr:t
+	psubadd.h r9,r11:t,r8:t
+	psubadd.h r10,r7:t,lr:t
+	psubadd.h r6,pc:t,pc:b
+	.text
+	.global paddsubs_sh
+paddsubs_sh:
+	paddsubs.sh pc,pc:b,pc:b
+	paddsubs.sh r12,r12:t,r12:t
+	paddsubs.sh r5,r5:t,r5:t
+	paddsubs.sh r4,r4:b,r4:b
+	paddsubs.sh lr,lr:t,lr:t
+	paddsubs.sh r0,lr:t,r0:b
+	paddsubs.sh r9,r2:t,r4:t
+	paddsubs.sh r12,r9:t,sp:t
+	.text
+	.global psubadds_sh
+psubadds_sh:
+	psubadds.sh pc,pc:b,pc:b
+	psubadds.sh r12,r12:t,r12:t
+	psubadds.sh r5,r5:t,r5:t
+	psubadds.sh r4,r4:b,r4:b
+	psubadds.sh lr,lr:t,lr:t
+	psubadds.sh pc,lr:b,r1:t
+	psubadds.sh r11,r3:b,r12:b
+	psubadds.sh r10,r2:t,r8:t
+	.text
+	.global paddsubs_uh
+paddsubs_uh:
+	paddsubs.uh pc,pc:b,pc:b
+	paddsubs.uh r12,r12:t,r12:t
+	paddsubs.uh r5,r5:t,r5:t
+	paddsubs.uh r4,r4:b,r4:b
+	paddsubs.uh lr,lr:t,lr:t
+	paddsubs.uh r9,r2:b,r3:b
+	paddsubs.uh sp,sp:b,r7:t
+	paddsubs.uh lr,r0:b,r10:t
+	.text
+	.global psubadds_uh
+psubadds_uh:
+	psubadds.uh pc,pc:b,pc:b
+	psubadds.uh r12,r12:t,r12:t
+	psubadds.uh r5,r5:t,r5:t
+	psubadds.uh r4,r4:b,r4:b
+	psubadds.uh lr,lr:t,lr:t
+	psubadds.uh r12,r9:t,pc:t
+	psubadds.uh r8,r6:b,r8:b
+	psubadds.uh r8,r8:b,r4:b
+	.text
+	.global paddsubh_sh
+paddsubh_sh:
+	paddsubh.sh pc,pc:b,pc:b
+	paddsubh.sh r12,r12:t,r12:t
+	paddsubh.sh r5,r5:t,r5:t
+	paddsubh.sh r4,r4:b,r4:b
+	paddsubh.sh lr,lr:t,lr:t
+	paddsubh.sh r8,r9:t,r9:b
+	paddsubh.sh r0,sp:t,r1:t
+	paddsubh.sh r3,r1:b,r0:t
+	.text
+	.global psubaddh_sh
+psubaddh_sh:
+	psubaddh.sh pc,pc:b,pc:b
+	psubaddh.sh r12,r12:t,r12:t
+	psubaddh.sh r5,r5:t,r5:t
+	psubaddh.sh r4,r4:b,r4:b
+	psubaddh.sh lr,lr:t,lr:t
+	psubaddh.sh r7,r3:t,r10:b
+	psubaddh.sh r7,r2:t,r1:t
+	psubaddh.sh r11,r3:b,r6:b
+	.text
+	.global padd_b
+padd_b:
+	padd.b pc,pc,pc
+	padd.b r12,r12,r12
+	padd.b r5,r5,r5
+	padd.b r4,r4,r4
+	padd.b lr,lr,lr
+	padd.b r2,r6,pc
+	padd.b r8,r9,r12
+	padd.b r5,r12,r3
+	.text
+	.global psub_b
+psub_b:
+	psub.b pc,pc,pc
+	psub.b r12,r12,r12
+	psub.b r5,r5,r5
+	psub.b r4,r4,r4
+	psub.b lr,lr,lr
+	psub.b r0,r12,pc
+	psub.b r7,sp,r10
+	psub.b r5,sp,r12
+	.text
+	.global padds_sb
+padds_sb:
+	padds.sb pc,pc,pc
+	padds.sb r12,r12,r12
+	padds.sb r5,r5,r5
+	padds.sb r4,r4,r4
+	padds.sb lr,lr,lr
+	padds.sb sp,r11,r4
+	padds.sb r11,r10,r11
+	padds.sb r5,r12,r6
+	.text
+	.global psubs_sb
+psubs_sb:
+	psubs.sb pc,pc,pc
+	psubs.sb r12,r12,r12
+	psubs.sb r5,r5,r5
+	psubs.sb r4,r4,r4
+	psubs.sb lr,lr,lr
+	psubs.sb r7,r6,r8
+	psubs.sb r12,r10,r9
+	psubs.sb pc,r11,r0
+	.text
+	.global padds_ub
+padds_ub:
+	padds.ub pc,pc,pc
+	padds.ub r12,r12,r12
+	padds.ub r5,r5,r5
+	padds.ub r4,r4,r4
+	padds.ub lr,lr,lr
+	padds.ub r3,r2,r11
+	padds.ub r10,r8,r1
+	padds.ub r11,r8,r10
+	.text
+	.global psubs_ub
+psubs_ub:
+	psubs.ub pc,pc,pc
+	psubs.ub r12,r12,r12
+	psubs.ub r5,r5,r5
+	psubs.ub r4,r4,r4
+	psubs.ub lr,lr,lr
+	psubs.ub r0,r2,r7
+	psubs.ub lr,r5,r3
+	psubs.ub r6,r7,r9
+	.text
+	.global paddh_ub
+paddh_ub:
+	paddh.ub pc,pc,pc
+	paddh.ub r12,r12,r12
+	paddh.ub r5,r5,r5
+	paddh.ub r4,r4,r4
+	paddh.ub lr,lr,lr
+	paddh.ub lr,r1,r0
+	paddh.ub r2,r7,r7
+	paddh.ub r2,r1,r2
+	.text
+	.global psubh_ub
+psubh_ub:
+	psubh.ub pc,pc,pc
+	psubh.ub r12,r12,r12
+	psubh.ub r5,r5,r5
+	psubh.ub r4,r4,r4
+	psubh.ub lr,lr,lr
+	psubh.ub r0,r1,r6
+	psubh.ub r4,lr,r10
+	psubh.ub r9,r8,r1
+	.text
+	.global pmax_ub
+pmax_ub:
+	pmax.ub pc,pc,pc
+	pmax.ub r12,r12,r12
+	pmax.ub r5,r5,r5
+	pmax.ub r4,r4,r4
+	pmax.ub lr,lr,lr
+	pmax.ub pc,r2,r11
+	pmax.ub r12,r1,r1
+	pmax.ub r5,r2,r0
+	.text
+	.global pmax_sh
+pmax_sh:
+	pmax.sh pc,pc,pc
+	pmax.sh r12,r12,r12
+	pmax.sh r5,r5,r5
+	pmax.sh r4,r4,r4
+	pmax.sh lr,lr,lr
+	pmax.sh lr,r6,r12
+	pmax.sh r2,pc,r5
+	pmax.sh pc,r2,r7
+	.text
+	.global pmin_ub
+pmin_ub:
+	pmin.ub pc,pc,pc
+	pmin.ub r12,r12,r12
+	pmin.ub r5,r5,r5
+	pmin.ub r4,r4,r4
+	pmin.ub lr,lr,lr
+	pmin.ub r8,r1,r5
+	pmin.ub r1,r8,r3
+	pmin.ub r0,r2,r7
+	.text
+	.global pmin_sh
+pmin_sh:
+	pmin.sh pc,pc,pc
+	pmin.sh r12,r12,r12
+	pmin.sh r5,r5,r5
+	pmin.sh r4,r4,r4
+	pmin.sh lr,lr,lr
+	pmin.sh r8,r4,r10
+	pmin.sh lr,r10,r12
+	pmin.sh r2,r6,r2
+	.text
+	.global pavg_ub
+pavg_ub:
+	pavg.ub pc,pc,pc
+	pavg.ub r12,r12,r12
+	pavg.ub r5,r5,r5
+	pavg.ub r4,r4,r4
+	pavg.ub lr,lr,lr
+	pavg.ub r0,r1,r6
+	pavg.ub r8,r3,r6
+	pavg.ub pc,r12,r10
+	.text
+	.global pavg_sh
+pavg_sh:
+	pavg.sh pc,pc,pc
+	pavg.sh r12,r12,r12
+	pavg.sh r5,r5,r5
+	pavg.sh r4,r4,r4
+	pavg.sh lr,lr,lr
+	pavg.sh r9,pc,sp
+	pavg.sh pc,sp,r3
+	pavg.sh r6,r1,r9
+	.text
+	.global pabs_sb
+pabs_sb:
+	pabs.sb pc,pc
+	pabs.sb r12,r12
+	pabs.sb r5,r5
+	pabs.sb r4,r4
+	pabs.sb lr,lr
+	pabs.sb r11,r6
+	pabs.sb lr,r9
+	pabs.sb sp,r7
+	.text
+	.global pabs_sh
+pabs_sh:
+	pabs.sh pc,pc
+	pabs.sh r12,r12
+	pabs.sh r5,r5
+	pabs.sh r4,r4
+	pabs.sh lr,lr
+	pabs.sh pc,r3
+	pabs.sh r5,r7
+	pabs.sh r4,r0
+	.text
+	.global psad
+psad:
+	psad pc,pc,pc
+	psad r12,r12,r12
+	psad r5,r5,r5
+	psad r4,r4,r4
+	psad lr,lr,lr
+	psad r9,r11,r11
+	psad lr,r4,sp
+	psad lr,r4,r5
+	.text
+	.global pasr_b
+pasr_b:
+	pasr.b pc,pc,0
+	pasr.b r12,r12,7
+	pasr.b r5,r5,4
+	pasr.b r4,r4,3
+	pasr.b lr,lr,1
+	pasr.b pc,r7,1
+	pasr.b sp,lr,6
+	pasr.b sp,r3,2
+	.text
+	.global plsl_b
+plsl_b:
+	plsl.b pc,pc,0
+	plsl.b r12,r12,7
+	plsl.b r5,r5,4
+	plsl.b r4,r4,3
+	plsl.b lr,lr,1
+	plsl.b r2,r11,4
+	plsl.b r8,r5,7
+	plsl.b pc,r0,2
+	.text
+	.global plsr_b
+plsr_b:
+	plsr.b pc,pc,0
+	plsr.b r12,r12,7
+	plsr.b r5,r5,4
+	plsr.b r4,r4,3
+	plsr.b lr,lr,1
+	plsr.b r12,r1,2
+	plsr.b r6,pc,7
+	plsr.b r12,r11,2
+	.text
+	.global pasr_h
+pasr_h:
+	pasr.h pc,pc,0
+	pasr.h r12,r12,15
+	pasr.h r5,r5,8
+	pasr.h r4,r4,7
+	pasr.h lr,lr,1
+	pasr.h r0,r11,10
+	pasr.h r4,r6,8
+	pasr.h r6,r2,4
+	.text
+	.global plsl_h
+plsl_h:
+	plsl.h pc,pc,0
+	plsl.h r12,r12,15
+	plsl.h r5,r5,8
+	plsl.h r4,r4,7
+	plsl.h lr,lr,1
+	plsl.h r5,r10,9
+	plsl.h sp,lr,8
+	plsl.h r0,lr,7
+	.text
+	.global plsr_h
+plsr_h:
+	plsr.h pc,pc,0
+	plsr.h r12,r12,15
+	plsr.h r5,r5,8
+	plsr.h r4,r4,7
+	plsr.h lr,lr,1
+	plsr.h r11,r0,15
+	plsr.h lr,r3,3
+	plsr.h r8,lr,10
+	.text
+	.global packw_sh
+packw_sh:
+	packw.sh pc,pc,pc
+	packw.sh r12,r12,r12
+	packw.sh r5,r5,r5
+	packw.sh r4,r4,r4
+	packw.sh lr,lr,lr
+	packw.sh sp,r11,r10
+	packw.sh r8,r2,r12
+	packw.sh r8,r1,r5
+	.text
+	.global punpckub_h
+punpckub_h:
+	punpckub.h pc,pc:b
+	punpckub.h r12,r12:t
+	punpckub.h r5,r5:t
+	punpckub.h r4,r4:b
+	punpckub.h lr,lr:t
+	punpckub.h r6,r1:t
+	punpckub.h lr,r5:b
+	punpckub.h lr,r2:t
+	.text
+	.global punpcksb_h
+punpcksb_h:
+	punpcksb.h pc,pc:b
+	punpcksb.h r12,r12:t
+	punpcksb.h r5,r5:t
+	punpcksb.h r4,r4:b
+	punpcksb.h lr,lr:t
+	punpcksb.h r4,r7:t
+	punpcksb.h r6,lr:b
+	punpcksb.h r12,r12:t
+	.text
+	.global packsh_ub
+packsh_ub:
+	packsh.ub pc,pc,pc
+	packsh.ub r12,r12,r12
+	packsh.ub r5,r5,r5
+	packsh.ub r4,r4,r4
+	packsh.ub lr,lr,lr
+	packsh.ub r3,r6,r3
+	packsh.ub r8,r0,r3
+	packsh.ub r9,r3,lr
+	.text
+	.global packsh_sb
+packsh_sb:
+	packsh.sb pc,pc,pc
+	packsh.sb r12,r12,r12
+	packsh.sb r5,r5,r5
+	packsh.sb r4,r4,r4
+	packsh.sb lr,lr,lr
+	packsh.sb r6,r8,r1
+	packsh.sb lr,r9,r8
+	packsh.sb sp,r6,r6
+	.text
+	.global andl
+andl:
+	andl pc,0
+	andl r12,65535
+	andl r5,32768
+	andl r4,32767
+	andl lr,1
+	andl pc,23128
+	andl r8,47262
+	andl r7,13719
+	.text
+	.global andl_coh
+andl_coh:
+	andl pc,0,COH
+	andl r12,65535,COH
+	andl r5,32768,COH
+	andl r4,32767,COH
+	andl lr,1,COH
+	andl r6,22753,COH
+	andl r0,40653,COH
+	andl r4,48580,COH
+	.text
+	.global andh
+andh:
+	andh pc,0
+	andh r12,65535
+	andh r5,32768
+	andh r4,32767
+	andh lr,1
+	andh r12,52312
+	andh r3,8675
+	andh r2,42987
+	.text
+	.global andh_coh
+andh_coh:
+	andh pc,0,COH
+	andh r12,65535,COH
+	andh r5,32768,COH
+	andh r4,32767,COH
+	andh lr,1,COH
+	andh r11,34317,COH
+	andh r8,52982,COH
+	andh r10,23683,COH
+	.text
+	.global orl
+orl:
+	orl pc,0
+	orl r12,65535
+	orl r5,32768
+	orl r4,32767
+	orl lr,1
+	orl sp,16766
+	orl r0,21181
+	orl pc,44103
+	.text
+	.global orh
+orh:
+	orh pc,0
+	orh r12,65535
+	orh r5,32768
+	orh r4,32767
+	orh lr,1
+	orh r8,28285
+	orh r12,30492
+	orh r1,59930
+	.text
+	.global eorl
+eorl:
+	eorl pc,0
+	eorl r12,65535
+	eorl r5,32768
+	eorl r4,32767
+	eorl lr,1
+	eorl r4,51129
+	eorl r6,64477
+	eorl r1,20913
+	.text
+	.global eorh
+eorh:
+	eorh pc,0
+	eorh r12,65535
+	eorh r5,32768
+	eorh r4,32767
+	eorh lr,1
+	eorh r0,11732
+	eorh r10,38069
+	eorh r9,57130
+	.text
+	.global mcall
+mcall:
+	mcall pc[0]
+	mcall r12[-4]
+	mcall r5[-131072]
+	mcall r4[131068]
+	mcall lr[4]
+	mcall sp[61180]
+	mcall r4[-35000]
+	mcall r0[9924]
+	.text
+	.global pref
+pref:
+	pref pc[0]
+	pref r12[-1]
+	pref r5[-32768]
+	pref r4[32767]
+	pref lr[1]
+	pref r7[7748]
+	pref r7[-7699]
+	pref r2[-25892]
+	.text
+	.global cache
+cache:
+	cache pc[0],0
+	cache r12[-1],31
+	cache r5[-1024],16
+	cache r4[1023],15
+	cache lr[1],1
+	cache r3[-964],17
+	cache r4[-375],22
+	cache r3[-888],17
+	.text
+	.global sub4
+sub4:
+	sub pc,0
+	sub r12,-1
+	sub r5,-1048576
+	sub r4,1048575
+	sub lr,1
+	sub r2,-619156
+	sub lr,461517
+	sub r8,-185051
+	.text
+	.global cp3
+cp3:
+	cp pc,0
+	cp r12,-1
+	cp r5,-1048576
+	cp r4,1048575
+	cp lr,1
+	cp r1,124078
+	cp r0,-378909
+	cp r4,-243180
+	.text
+	.global mov2
+mov2:
+	mov pc,0
+	mov r12,-1
+	mov r5,-1048576
+	mov r4,1048575
+	mov lr,1
+	mov r5,-317021
+	mov sp,-749164
+	mov r5,940179
+	.text
+	.global brc2
+brc2:
+	breq 0
+	bral -2
+	brls -2097152
+	brpl 2097150
+	brne 2
+	brhi -1796966
+	brqs 1321368
+	brls -577434
+	.text
+	.global rcall2
+rcall2:
+	rcall 0
+	rcall -2
+	rcall -2097152
+	rcall 2097150
+	rcall 2
+	rcall 496820
+	rcall 1085092
+	rcall -1058
+	.text
+	.global sub5
+sub5:
+	sub pc,pc,0
+	sub r12,r12,-1
+	sub r5,r5,-32768
+	sub r4,r4,32767
+	sub lr,lr,1
+	sub pc,pc,-12744
+	sub r7,r7,-27365
+	sub r2,r9,-17358
+	.text
+	.global satsub_w2
+satsub_w2:
+	satsub.w pc,pc,0
+	satsub.w r12,r12,-1
+	satsub.w r5,r5,-32768
+	satsub.w r4,r4,32767
+	satsub.w lr,lr,1
+	satsub.w r2,lr,-2007
+	satsub.w r7,r12,-784
+	satsub.w r4,r7,23180
+	.text
+	.global ld_d4
+ld_d4:
+	ld.d r0,pc[0]
+	ld.d r14,r12[-1]
+	ld.d r8,r5[-32768]
+	ld.d r6,r4[32767]
+	ld.d r2,lr[1]
+	ld.d r14,r11[14784]
+	ld.d r6,r9[-18905]
+	ld.d r2,r3[-6355]
+	.text
+	.global ld_w4
+ld_w4:
+	ld.w pc,pc[0]
+	ld.w r12,r12[-1]
+	ld.w r5,r5[-32768]
+	ld.w r4,r4[32767]
+	ld.w lr,lr[1]
+	ld.w r0,r12[-22133]
+	ld.w sp,pc[-20521]
+	/* ld.w r3,r5[29035] */
+	nop
+	.text
+	.global ld_sh4
+ld_sh4:
+	ld.sh pc,pc[0]
+	ld.sh r12,r12[-1]
+	ld.sh r5,r5[-32768]
+	ld.sh r4,r4[32767]
+	ld.sh lr,lr[1]
+	ld.sh r6,r10[30930]
+	ld.sh r6,r10[21973]
+	/* ld.sh r11,r10[-2058] */
+	nop
+	.text
+	.global ld_uh4
+ld_uh4:
+	ld.uh pc,pc[0]
+	ld.uh r12,r12[-1]
+	ld.uh r5,r5[-32768]
+	ld.uh r4,r4[32767]
+	ld.uh lr,lr[1]
+	ld.uh r1,r9[-13354]
+	ld.uh lr,r11[21337]
+	/* ld.uh r2,lr[-25370] */
+	nop
+	.text
+	.global ld_sb1
+ld_sb1:
+	ld.sb pc,pc[0]
+	ld.sb r12,r12[-1]
+	ld.sb r5,r5[-32768]
+	ld.sb r4,r4[32767]
+	ld.sb lr,lr[1]
+	ld.sb r7,sp[-28663]
+	ld.sb r2,r1[-5879]
+	ld.sb r12,r3[18734]
+	.text
+	.global ld_ub4
+ld_ub4:
+	ld.ub pc,pc[0]
+	ld.ub r12,r12[-1]
+	ld.ub r5,r5[-32768]
+	ld.ub r4,r4[32767]
+	ld.ub lr,lr[1]
+	ld.ub pc,r4[8277]
+	ld.ub r5,r12[19172]
+	ld.ub r10,lr[26347]
+	.text
+	.global st_d4
+st_d4:
+	st.d pc[0],r0
+	st.d r12[-1],r14
+	st.d r5[-32768],r8
+	st.d r4[32767],r6
+	st.d lr[1],r2
+	st.d r5[13200],r10
+	st.d r5[9352],r10
+	st.d r5[32373],r4
+	.text
+	.global st_w4
+st_w4:
+	st.w pc[0],pc
+	st.w r12[-1],r12
+	st.w r5[-32768],r5
+	st.w r4[32767],r4
+	st.w lr[1],lr
+	st.w sp[6136],r7
+	st.w r6[27087],r12
+	/* st.w r3[20143],r7 */
+	nop
+	.text
+	.global st_h4
+st_h4:
+	st.h pc[0],pc
+	st.h r12[-1],r12
+	st.h r5[-32768],r5
+	st.h r4[32767],r4
+	st.h lr[1],lr
+	st.h r4[-9962],r7
+	st.h r9[-16250],r3
+	/* st.h r8[-28810],r7 */
+	nop
+	.text
+	.global st_b4
+st_b4:
+	st.b pc[0],pc
+	st.b r12[-1],r12
+	st.b r5[-32768],r5
+	st.b r4[32767],r4
+	st.b lr[1],lr
+	st.b r12[30102],r6
+	st.b r5[28977],r1
+	st.b r0[5470],r1
+	.text
+	.global mfsr
+mfsr:
+	mfsr pc,0
+	mfsr r12,1020
+	mfsr r5,512
+	mfsr r4,508
+	mfsr lr,4
+	mfsr r2,696
+	mfsr r4,260
+	mfsr r10,1016
+	.text
+	.global mtsr
+mtsr:
+	mtsr 0,pc
+	mtsr 1020,r12
+	mtsr 512,r5
+	mtsr 508,r4
+	mtsr 4,lr
+	mtsr 224,r10
+	mtsr 836,r12
+	mtsr 304,r9
+	.text
+	.global mfdr
+mfdr:
+	mfdr pc,0
+	mfdr r12,1020
+	mfdr r5,512
+	mfdr r4,508
+	mfdr lr,4
+	mfdr r6,932
+	mfdr r5,36
+	mfdr r9,300
+	.text
+	.global mtdr
+mtdr:
+	mtdr 0,pc
+	mtdr 1020,r12
+	mtdr 512,r5
+	mtdr 508,r4
+	mtdr 4,lr
+	mtdr 180,r8
+	mtdr 720,r10
+	mtdr 408,lr
+	.text
+	.global sleep
+sleep:
+	sleep 0
+	sleep 255
+	sleep 128
+	sleep 127
+	sleep 1
+	sleep 254
+	sleep 15
+	sleep 43
+	.text
+	.global sync
+sync:
+	sync 0
+	sync 255
+	sync 128
+	sync 127
+	sync 1
+	sync 166
+	sync 230
+	sync 180
+	.text
+	.global bld
+bld:
+	bld pc,0
+	bld r12,31
+	bld r5,16
+	bld r4,15
+	bld lr,1
+	bld r9,15
+	bld r0,4
+	bld lr,26
+	.text
+	.global bst
+bst:
+	bst pc,0
+	bst r12,31
+	bst r5,16
+	bst r4,15
+	bst lr,1
+	bst r10,28
+	bst r0,3
+	bst sp,2
+	.text
+	.global sats
+sats:
+	sats pc>>0,0
+	sats r12>>31,31
+	sats r5>>16,16
+	sats r4>>15,15
+	sats lr>>1,1
+	sats r10>>3,19
+	sats r10>>2,26
+	sats r1>>20,1
+	.text
+	.global satu
+satu:
+	satu pc>>0,0
+	satu r12>>31,31
+	satu r5>>16,16
+	satu r4>>15,15
+	satu lr>>1,1
+	satu pc>>5,7
+	satu r7>>5,5
+	satu r2>>26,19
+	.text
+	.global satrnds
+satrnds:
+	satrnds pc>>0,0
+	satrnds r12>>31,31
+	satrnds r5>>16,16
+	satrnds r4>>15,15
+	satrnds lr>>1,1
+	satrnds r0>>21,19
+	satrnds sp>>0,2
+	satrnds r7>>6,29
+	.text
+	.global satrndu
+satrndu:
+	satrndu pc>>0,0
+	satrndu r12>>31,31
+	satrndu r5>>16,16
+	satrndu r4>>15,15
+	satrndu lr>>1,1
+	satrndu r12>>0,26
+	satrndu r4>>21,3
+	satrndu r10>>3,16
+	.text
+	.global subfc
+subfc:
+	subfeq pc,0
+	subfal r12,-1
+	subfls r5,-128
+	subfpl r4,127
+	subfne lr,1
+	subfls r10,8
+	subfvc r11,99
+	subfvs r2,73
+	.text
+	.global subc
+subc:
+	subeq pc,0
+	subal r12,-1
+	subls r5,-128
+	subpl r4,127
+	subne lr,1
+	subls r12,118
+	subvc lr,-12
+	submi r4,-13
+	.text
+	.global movc2
+movc2:
+	moveq pc,0
+	moval r12,-1
+	movls r5,-128
+	movpl r4,127
+	movne lr,1
+	movlt r3,-122
+	movvc r8,2
+	movne r7,-111
+	.text
+	.global cp_b
+cp_b:
+	cp.b pc,r0
+	cp.b r0,pc
+	cp.b r7,r8
+	cp.b r8,r7
+	.text
+	.global cp_h
+cp_h:
+	cp.h pc,r0
+	cp.h r0,pc
+	cp.h r7,r8
+	cp.h r8,r7
+	.text
+	.global ldm
+ldm:
+	ldm pc,r1-r6
+	ldm r12,r0-r15
+	ldm r5,r15
+	ldm r4,r0-r14
+	ldm lr,r0
+	ldm r9,r1,r5,r14
+	ldm r11,r2-r3,r5-r8,r15
+	ldm r6,r0,r3,r9,r13,r15
+	.text
+	.global ldm_pu
+ldm_pu:
+	ldm pc++,r6-r9
+	ldm r12++,r0-r15
+	ldm r5++,r15
+	ldm r4++,r0-r14
+	ldm lr++,r0
+	ldm r12++,r3-r5,r8,r10,r12,r14-r15
+	ldm r10++,r2,r4-r6,r14-r15
+	ldm r6++,r1,r3-r4,r9-r14
+	.text
+	.global ldmts
+ldmts:
+	ldmts pc,r7-r8
+	ldmts r12,r0-r15
+	ldmts r5,r15
+	ldmts r4,r0-r14
+	ldmts lr,r0
+	ldmts r0,r1-r2,r11-r12
+	ldmts lr,r0-r2,r4,r7-r8,r13-r14
+	ldmts r12,r0-r1,r3-r5,r9,r14-r15
+	.text
+	.global ldmts_pu
+ldmts_pu:
+	ldmts pc++,r9
+	ldmts r12++,r0-r15
+	ldmts r5++,r15
+	ldmts r4++,r0-r14
+	ldmts lr++,r0
+	ldmts sp++,r0,r2-r5,r7,r9,r11
+	ldmts r5++,r1-r3,r7,r10-r11
+	ldmts r8++,r2-r4,r7-r8,r13,r15
+	.text
+	.global stm
+stm:
+	stm pc,r7
+	stm r12,r0-r15
+	stm r5,r15
+	stm r4,r0-r14
+	stm lr,r0
+	stm sp,r2-r3,r5,r8,r11,r14
+	stm r4,r0-r4,r6,r10-r11,r14
+	stm r9,r1,r5,r9,r12-r15
+	.text
+	.global stm_pu
+stm_pu:
+	stm --pc,r4-r6
+	stm --r12,r0-r15
+	stm --r5,r15
+	stm --r4,r0-r14
+	stm --lr,r0
+	stm --r11,r0,r4-r9,r11-r15
+	stm --r11,r0,r3,r9-r10,r12,r14
+	stm --r6,r2,r8-r9,r13-r14
+	.text
+	.global stmts
+stmts:
+	stmts pc,r8
+	stmts r12,r0-r15
+	stmts r5,r15
+	stmts r4,r0-r14
+	stmts lr,r0
+	stmts r1,r0-r1,r3-r4,r6,r9-r10,r14-r15
+	stmts r3,r0,r6-r8,r10-r12
+	stmts r11,r0,r4,r6-r7,r9-r10,r12,r14-r15
+	.text
+	.global stmts_pu
+stmts_pu:
+	stmts --pc,r6-r8
+	stmts --r12,r0-r15
+	stmts --r5,r15
+	stmts --r4,r0-r14
+	stmts --lr,r0
+	stmts --r2,r0,r3-r4,r9-r10,r12-r13
+	stmts --r3,r0-r1,r14-r15
+	stmts --r0,r0,r2-r6,r10,r14
+	.text
+	.global ldins_h
+ldins_h:
+	ldins.h pc:b,pc[0]
+	ldins.h r12:t,r12[-2]
+	ldins.h r5:t,r5[-4096]
+	ldins.h r4:b,r4[4094]
+	ldins.h lr:t,lr[2]
+	ldins.h r0:t,lr[1930]
+	ldins.h r3:b,r7[-534]
+	ldins.h r2:b,r12[-2252]
+	.text
+	.global ldins_b
+ldins_b:
+	ldins.b pc:b,pc[0]
+	ldins.b r12:t,r12[-1]
+	ldins.b r5:u,r5[-2048]
+	ldins.b r4:l,r4[2047]
+	ldins.b lr:l,lr[1]
+	ldins.b r6:t,r4[-662]
+	ldins.b r5:b,r1[-151]
+	ldins.b r10:t,r11[-1923]
+	.text
+	.global ldswp_sh
+ldswp_sh:
+	ldswp.sh pc,pc[0]
+	ldswp.sh r12,r12[-2]
+	ldswp.sh r5,r5[-4096]
+	ldswp.sh r4,r4[4094]
+	ldswp.sh lr,lr[2]
+	ldswp.sh r9,r10[3848]
+	ldswp.sh r4,r12[-2040]
+	ldswp.sh r10,r2[3088]
+	.text
+	.global ldswp_uh
+ldswp_uh:
+	ldswp.uh pc,pc[0]
+	ldswp.uh r12,r12[-2]
+	ldswp.uh r5,r5[-4096]
+	ldswp.uh r4,r4[4094]
+	ldswp.uh lr,lr[2]
+	ldswp.uh r4,r9[3724]
+	ldswp.uh lr,sp[-1672]
+	ldswp.uh r8,r12[-3846]
+	.text
+	.global ldswp_w
+ldswp_w:
+	ldswp.w pc,pc[0]
+	ldswp.w r12,r12[-4]
+	ldswp.w r5,r5[-8192]
+	ldswp.w r4,r4[8188]
+	ldswp.w lr,lr[4]
+	ldswp.w sp,r7[1860]
+	ldswp.w pc,r5[-3324]
+	ldswp.w r12,r10[-3296]
+	.text
+	.global stswp_h
+stswp_h:
+	stswp.h pc[0],pc
+	stswp.h r12[-2],r12
+	stswp.h r5[-4096],r5
+	stswp.h r4[4094],r4
+	stswp.h lr[2],lr
+	stswp.h r7[64],r10
+	stswp.h r10[3024],r2
+	stswp.h r0[-2328],r10
+	.text
+	.global stswp_w
+stswp_w:
+	stswp.w pc[0],pc
+	stswp.w r12[-4],r12
+	stswp.w r5[-8192],r5
+	stswp.w r4[8188],r4
+	stswp.w lr[4],lr
+	stswp.w pc[1156],r8
+	stswp.w sp[7992],r10
+	stswp.w r8[-1172],r5
+	.text
+	.global and2
+and2:
+	and pc,pc,pc<<0
+	and r12,r12,r12<<31
+	and r5,r5,r5<<16
+	and r4,r4,r4<<15
+	and lr,lr,lr<<1
+	and r10,r2,r1<<1
+	and r12,r8,r11<<27
+	and r10,r7,r0<<3
+	.text
+	.global and3
+and3:
+	and pc,pc,pc>>0
+	and r12,r12,r12>>31
+	and r5,r5,r5>>16
+	and r4,r4,r4>>15
+	and lr,lr,lr>>1
+	and r12,r8,r7>>17
+	and pc,r4,r9>>20
+	and r10,r9,r10>>12
+	.text
+	.global or2
+or2:
+	or pc,pc,pc<<0
+	or r12,r12,r12<<31
+	or r5,r5,r5<<16
+	or r4,r4,r4<<15
+	or lr,lr,lr<<1
+	or r8,sp,r11<<29
+	or pc,r9,r2<<28
+	or r5,r1,r2<<3
+	.text
+	.global or3
+or3:
+	or pc,pc,pc>>0
+	or r12,r12,r12>>31
+	or r5,r5,r5>>16
+	or r4,r4,r4>>15
+	or lr,lr,lr>>1
+	or r1,sp,sp>>2
+	or r0,r1,r1>>29
+	or r4,r12,r8>>8
+	.text
+	.global eor2
+eor2:
+	eor pc,pc,pc<<0
+	eor r12,r12,r12<<31
+	eor r5,r5,r5<<16
+	eor r4,r4,r4<<15
+	eor lr,lr,lr<<1
+	eor r10,r9,r4<<11
+	eor r4,r0,r1<<31
+	eor r6,r2,r12<<13
+	.text
+	.global eor3
+eor3:
+	eor pc,pc,pc>>0
+	eor r12,r12,r12>>31
+	eor r5,r5,r5>>16
+	eor r4,r4,r4>>15
+	eor lr,lr,lr>>1
+	eor r5,r5,r5>>22
+	eor r10,r1,lr>>3
+	eor r7,lr,sp>>26
+	.text
+	.global sthh_w2
+sthh_w2:
+	sthh.w pc[pc<<0],pc:b,pc:b
+	sthh.w r12[r12<<3],r12:t,r12:t
+	sthh.w r5[r5<<2],r5:t,r5:t
+	sthh.w r4[r4<<1],r4:b,r4:b
+	sthh.w lr[lr<<1],lr:t,lr:t
+	sthh.w sp[r6<<3],r1:t,r12:t
+	sthh.w r6[r6<<0],r9:t,r9:t
+	sthh.w r10[r3<<0],r0:b,r11:t
+	.text
+	.global sthh_w1
+sthh_w1:
+	sthh.w pc[0],pc:b,pc:b
+	sthh.w r12[1020],r12:t,r12:t
+	sthh.w r5[512],r5:t,r5:t
+	sthh.w r4[508],r4:b,r4:b
+	sthh.w lr[4],lr:t,lr:t
+	sthh.w r4[404],r9:t,r0:b
+	sthh.w r8[348],r2:t,r10:b
+	sthh.w sp[172],r9:b,r2:b
+	.text
+	.global cop
+cop:
+	cop cp0,cr0,cr0,cr0,0
+	cop cp7,cr15,cr15,cr15,0x7f
+	cop cp3,cr5,cr5,cr5,0x31
+	cop cp2,cr4,cr4,cr4,0x30
+	cop cp5,cr8,cr3,cr7,0x5a
+	.text
+	.global ldc_w1
+ldc_w1:
+	ldc.w cp0,cr0,r0[0]
+	ldc.w cp7,cr15,pc[255<<2]
+	ldc.w cp3,cr5,r5[128<<2]
+	ldc.w cp2,cr4,r4[127<<2]
+	ldc.w cp4,cr9,r13[36<<2]
+	.text
+	.global ldc_w2
+ldc_w2:
+	ldc.w cp0,cr0,--r0
+	ldc.w cp7,cr15,--pc
+	ldc.w cp3,cr5,--r5
+	ldc.w cp2,cr4,--r4
+	ldc.w cp4,cr9,--r13
+	.text
+	.global ldc_w3
+ldc_w3:
+	ldc.w cp0,cr0,r0[r0]
+	ldc.w cp7,cr15,pc[pc<<3]
+	ldc.w cp3,cr5,r5[r4<<2]
+	ldc.w cp2,cr4,r4[r3<<1]
+	ldc.w cp4,cr9,r13[r12<<0]
+	.text
+	.global ldc_d1
+ldc_d1:
+	ldc.d cp0,cr0,r0[0]
+	ldc.d cp7,cr14,pc[255<<2]
+	ldc.d cp3,cr6,r5[128<<2]
+	ldc.d cp2,cr4,r4[127<<2]
+	ldc.d cp4,cr8,r13[36<<2]
+	.text
+	.global ldc_d2
+ldc_d2:
+	ldc.d cp0,cr0,--r0
+	ldc.d cp7,cr14,--pc
+	ldc.d cp3,cr6,--r5
+	ldc.d cp2,cr4,--r4
+	ldc.d cp4,cr8,--r13
+	.text
+	.global ldc_d3
+ldc_d3:
+	ldc.d cp0,cr0,r0[r0]
+	ldc.d cp7,cr14,pc[pc<<3]
+	ldc.d cp3,cr6,r5[r4<<2]
+	ldc.d cp2,cr4,r4[r3<<1]
+	ldc.d cp4,cr8,r13[r12<<0]
+	.text
+	.global stc_w1
+stc_w1:
+	stc.w cp0,r0[0],cr0
+	stc.w cp7,pc[255<<2],cr15
+	stc.w cp3,r5[128<<2],cr5
+	stc.w cp2,r4[127<<2],cr4
+	stc.w cp4,r13[36<<2],cr9
+	.text
+	.global stc_w2
+stc_w2:
+	stc.w cp0,r0++,cr0
+	stc.w cp7,pc++,cr15
+	stc.w cp3,r5++,cr5
+	stc.w cp2,r4++,cr4
+	stc.w cp4,r13++,cr9
+	.text
+	.global stc_w3
+stc_w3:
+	stc.w cp0,r0[r0],cr0
+	stc.w cp7,pc[pc<<3],cr15
+	stc.w cp3,r5[r4<<2],cr5
+	stc.w cp2,r4[r3<<1],cr4
+	stc.w cp4,r13[r12<<0],cr9
+	.text
+	.global stc_d1
+stc_d1:
+	stc.d cp0,r0[0],cr0
+	stc.d cp7,pc[255<<2],cr14
+	stc.d cp3,r5[128<<2],cr6
+	stc.d cp2,r4[127<<2],cr4
+	stc.d cp4,r13[36<<2],cr8
+	.text
+	.global stc_d2
+stc_d2:
+	stc.d cp0,r0++,cr0
+	stc.d cp7,pc++,cr14
+	stc.d cp3,r5++,cr6
+	stc.d cp2,r4++,cr4
+	stc.d cp4,r13++,cr8
+	.text
+	.global stc_d3
+stc_d3:
+	stc.d cp0,r0[r0],cr0
+	stc.d cp7,pc[pc<<3],cr14
+	stc.d cp3,r5[r4<<2],cr6
+	stc.d cp2,r4[r3<<1],cr4
+	stc.d cp4,r13[r12<<0],cr8
+	.text
+	.global ldc0_w
+ldc0_w:
+	ldc0.w cr0,r0[0]
+	ldc0.w cr15,pc[4095<<2]
+	ldc0.w cr5,r5[2048<<2]
+	ldc0.w cr4,r4[2047<<2]
+	ldc0.w cr9,r13[147<<2]
+	.text
+	.global ldc0_d
+ldc0_d:
+	ldc0.d cr0,r0[0]
+	ldc0.d cr14,pc[4095<<2]
+	ldc0.d cr6,r5[2048<<2]
+	ldc0.d cr4,r4[2047<<2]
+	ldc0.d cr8,r13[147<<2]
+	.text
+	.global stc0_w
+stc0_w:
+	stc0.w r0[0],cr0
+	stc0.w pc[4095<<2],cr15
+	stc0.w r5[2048<<2],cr5
+	stc0.w r4[2047<<2],cr4
+	stc0.w r13[147<<2],cr9
+	.text
+	.global stc0_d
+stc0_d:
+	stc0.d r0[0],cr0
+	stc0.d pc[4095<<2],cr14
+	stc0.d r5[2048<<2],cr6
+	stc0.d r4[2047<<2],cr4
+	stc0.d r13[147<<2],cr8
+	.text
+	.global memc
+memc:
+	memc 0, 0
+	memc -4, 31
+	memc -65536, 16
+	memc 65532, 15
+	.text
+	.global mems
+mems:
+	mems 0, 0
+	mems -4, 31
+	mems -65536, 16
+	mems 65532, 15
+	.text
+	.global memt
+memt:
+	memt 0, 0
+	memt -4, 31
+	memt -65536, 16
+	memt 65532, 15
+
+	.text
+	.global stcond
+stcond:
+	stcond r0[0], r0
+	stcond pc[-1], pc
+	stcond r8[-32768], r7
+	stcond r7[32767], r8
+	stcond r5[0x1234], r10
+
+ldcm_w:
+	ldcm.w cp0,pc,cr0-cr7
+	ldcm.w cp7,r0,cr0
+	ldcm.w cp4,r4++,cr0-cr6
+	ldcm.w cp3,r7,cr7
+	ldcm.w cp1,r12++,cr1,cr4-cr6
+	ldcm.w cp0,pc,cr8-cr15
+	ldcm.w cp7,r0,cr8
+	ldcm.w cp4,r4++,cr8-cr14
+	ldcm.w cp3,r7,cr15
+	ldcm.w cp1,r12++,cr9,cr12-cr14
+
+ldcm_d:
+	ldcm.d cp0,pc,cr0-cr15
+	ldcm.d cp7,r0,cr0,cr1
+	ldcm.d cp4,r4++,cr0-cr13
+	ldcm.d cp3,r7,cr14-cr15
+	ldcm.d cp2,r12++,cr0-cr3,cr8-cr9,cr14-cr15
+
+stcm_w:
+	stcm.w cp0,pc,cr0-cr7
+	stcm.w cp7,r0,cr0
+	stcm.w cp4,--r4,cr0-cr6
+	stcm.w cp3,r7,cr7
+	stcm.w cp1,--r12,cr1,cr4-cr6
+	stcm.w cp0,pc,cr8-cr15
+	stcm.w cp7,r0,cr8
+	stcm.w cp4,--r4,cr8-cr14
+	stcm.w cp3,r7,cr15
+	stcm.w cp1,--r12,cr9,cr12-cr14
+
+stcm_d:
+	stcm.d cp0,pc,cr0-cr15
+	stcm.d cp7,r0,cr0,cr1
+	stcm.d cp4,--r4,cr0-cr13
+	stcm.d cp3,r7,cr14-cr15
+	stcm.d cp2,--r12,cr0-cr3,cr8-cr9,cr14-cr15
+
+mvcr_w:
+	mvcr.w cp7,pc,cr15
+	mvcr.w cp0,r0,cr0
+	mvcr.w cp0,pc,cr15
+	mvcr.w cp7,r0,cr15
+	mvcr.w cp7,pc,cr0
+	mvcr.w cp4,r7,cr8
+	mvcr.w cp3,r8,cr7
+
+mvcr_d:
+	mvcr.d cp7,lr,cr14
+	mvcr.d cp0,r0,cr0
+	mvcr.d cp0,lr,cr14
+	mvcr.d cp7,r0,cr14
+	mvcr.d cp7,lr,cr0
+	mvcr.d cp4,r6,cr8
+	mvcr.d cp3,r8,cr6
+
+mvrc_w:
+	mvrc.w cp7,cr15,pc
+	mvrc.w cp0,cr0,r0
+	mvrc.w cp0,cr15,pc
+	mvrc.w cp7,cr15,r0
+	mvrc.w cp7,cr0,pc
+	mvrc.w cp4,cr8,r7
+	mvrc.w cp3,cr7,r8
+
+mvrc_d:
+	mvrc.d cp7,cr14,lr
+	mvrc.d cp0,cr0,r0
+	mvrc.d cp0,cr14,lr
+	mvrc.d cp7,cr14,r0
+	mvrc.d cp7,cr0,lr
+	mvrc.d cp4,cr8,r6
+	mvrc.d cp3,cr6,r8
+
+bfexts:
+	bfexts pc,pc,31,31
+	bfexts r0,r0,0,0
+	bfexts r0,pc,31,31
+	bfexts pc,r0,31,31
+	bfexts pc,pc,0,31
+	bfexts pc,pc,31,0
+	bfexts r7,r8,15,16
+	bfexts r8,r7,16,15
+
+bfextu:
+	bfextu pc,pc,31,31
+	bfextu r0,r0,0,0
+	bfextu r0,pc,31,31
+	bfextu pc,r0,31,31
+	bfextu pc,pc,0,31
+	bfextu pc,pc,31,0
+	bfextu r7,r8,15,16
+	bfextu r8,r7,16,15
+
+bfins:
+	bfins pc,pc,31,31
+	bfins r0,r0,0,0
+	bfins r0,pc,31,31
+	bfins pc,r0,31,31
+	bfins pc,pc,0,31
+	bfins pc,pc,31,0
+	bfins r7,r8,15,16
+	bfins r8,r7,16,15
+
+rsubc:
+	rsubeq pc,0
+	rsubal r12,-1
+	rsubls r5,-128
+	rsubpl r4,127
+	rsubne lr,1
+	rsubls r12,118
+	rsubvc lr,-12
+	rsubmi r4,-13
+
+addc:
+	addeq pc,pc,pc
+	addal r12,r12,r12
+	addls r5,r5,r5
+	addpl r4,r4,r4
+	addne lr,lr,lr
+	addls r10,r2,r1
+	addvc r12,r8,r11
+	addmi r10,r7,r0   
+
+subc2:
+	subeq pc,pc,pc
+	subal r12,r12,r12
+	subls r5,r5,r5
+	subpl r4,r4,r4
+	subne lr,lr,lr
+	subls r10,r2,r1
+	subvc r12,r8,r11
+	submi r10,r7,r0   
+
+andc:
+	andeq pc,pc,pc
+	andal r12,r12,r12
+	andls r5,r5,r5
+	andpl r4,r4,r4
+	andne lr,lr,lr
+	andls r10,r2,r1
+	andvc r12,r8,r11
+	andmi r10,r7,r0   
+
+orc:
+	oreq pc,pc,pc
+	oral r12,r12,r12
+	orls r5,r5,r5
+	orpl r4,r4,r4
+	orne lr,lr,lr
+	orls r10,r2,r1
+	orvc r12,r8,r11
+	ormi r10,r7,r0   
+
+eorc:
+	eoreq pc,pc,pc
+	eoral r12,r12,r12
+	eorls r5,r5,r5
+	eorpl r4,r4,r4
+	eorne lr,lr,lr
+	eorls r10,r2,r1
+	eorvc r12,r8,r11
+	eormi r10,r7,r0   
+
+ldcond:
+	ld.weq  pc,pc[2044]
+	ld.shal r12,r12[1022]
+	ld.uhls r5,r5[0]
+	ld.ubpl r4,r4[511]
+	ld.sbne lr,lr[0]
+	ld.wls  r10,r2[0]
+	ld.shvc r12,r8[0x3fe]
+	ld.ubmi r10,r7[1]
+  
+stcond2:
+	st.weq pc[2044],pc
+	st.hal r12[1022],r12
+	st.hls r5[0],r5
+	st.bpl r4[511],r4
+	st.bne lr[0],lr
+	st.wls r2[0],r10
+	st.hvc r8[0x3fe],r12
+	st.bmi r7[1],r10
+	
+movh:	
+	movh	pc, 65535
+	movh	r0, 0
+	movh	r5, 1
+	movh	r12, 32767
+	
+		
--- /dev/null
+++ b/gas/testsuite/gas/avr32/avr32.exp
@@ -0,0 +1,23 @@
+# AVR32 assembler testsuite. -*- Tcl -*-
+
+if [istarget avr32-*-*] {
+    run_dump_test "hwrd-lwrd"
+    run_dump_test "pcrel"
+    run_dump_test "aliases"
+    run_dump_test "dwarf2"
+    run_dump_test "pic_reloc"
+    run_dump_test "fpinsn"
+    run_dump_test "pico"
+    run_dump_test "lda_pic"
+    run_dump_test "lda_pic_linkrelax"
+    run_dump_test "lda_nopic"
+    run_dump_test "lda_nopic_linkrelax"
+    run_dump_test "call_pic"
+    run_dump_test "call_pic_linkrelax"
+    run_dump_test "call_nopic"
+    run_dump_test "call_nopic_linkrelax"
+    run_dump_test "jmptable"
+    run_dump_test "jmptable_linkrelax"
+    run_dump_test "symdiff"
+    run_dump_test "symdiff_linkrelax"
+}
--- /dev/null
+++ b/gas/testsuite/gas/avr32/call_nopic.d
@@ -0,0 +1,36 @@
+#source: call.s
+#as:
+#objdump: -dr
+#name: call_nopic
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <call_test>:
+       0:	d7 03       	nop
+
+00000002 <toofar_negative>:
+	\.\.\.
+  1ffffe:	00 00       	add r0,r0
+  200000:	f0 a0 00 00 	rcall 0 <call_test>
+  200004:	f0 1f 00 0c 	mcall 200034 <toofar_negative\+0x200032>
+  200008:	f0 1f 00 0c 	mcall 200038 <toofar_negative\+0x200036>
+  20000c:	f0 1f 00 0c 	mcall 20003c <toofar_negative\+0x20003a>
+  200010:	f0 1f 00 0c 	mcall 200040 <toofar_negative\+0x20003e>
+	\.\.\.
+  200030:	ee b0 ff ff 	rcall 40002e <far_positive>
+	\.\.\.
+			200034: R_AVR32_32_CPENT	\.text\+0x2
+			200038: R_AVR32_32_CPENT	\.text\.init
+			20003c: R_AVR32_32_CPENT	undefined
+			200040: R_AVR32_32_CPENT	\.text\+0x40002c
+
+0040002c <toofar_positive>:
+  40002c:	d7 03       	nop
+0040002e <far_positive>:
+  40002e:	d7 03       	nop
+Disassembly of section \.text\.init:
+
+00000000 <different_section>:
+   0:	e2 c0 00 00 	sub r0,r1,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/call_nopic_linkrelax.d
@@ -0,0 +1,43 @@
+#source: call.s
+#as: --linkrelax
+#objdump: -dr
+#name: call_nopic_linkrelax
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <call_test>:
+       0:	d7 03       	nop
+
+00000002 <toofar_negative>:
+	\.\.\.
+  1ffffe:	00 00       	add r0,r0
+  200000:	e0 a0 00 00 	rcall 200000 <toofar_negative\+0x1ffffe>
+			200000: R_AVR32_22H_PCREL	\.text
+  200004:	f0 1f 00 00 	mcall 200004 <toofar_negative\+0x200002>
+			200004: R_AVR32_CPCALL	\.text\+0x200034
+  200008:	f0 1f 00 00 	mcall 200008 <toofar_negative\+0x200006>
+			200008: R_AVR32_CPCALL	\.text\+0x200038
+  20000c:	f0 1f 00 00 	mcall 20000c <toofar_negative\+0x20000a>
+			20000c: R_AVR32_CPCALL	\.text\+0x20003c
+  200010:	f0 1f 00 00 	mcall 200010 <toofar_negative\+0x20000e>
+			200010: R_AVR32_CPCALL	\.text\+0x200040
+	\.\.\.
+  200030:	e0 a0 00 00 	rcall 200030 <toofar_negative\+0x20002e>
+			200030: R_AVR32_22H_PCREL	\.text\+0x40002e
+	\.\.\.
+			200034: R_AVR32_ALIGN	\*ABS\*\+0x2
+			200034: R_AVR32_32_CPENT	\.text\+0x2
+			200038: R_AVR32_32_CPENT	\.text\.init
+			20003c: R_AVR32_32_CPENT	undefined
+			200040: R_AVR32_32_CPENT	\.text\+0x40002c
+
+0040002c <toofar_positive>:
+  40002c:	d7 03       	nop
+0040002e <far_positive>:
+  40002e:	d7 03       	nop
+Disassembly of section \.text\.init:
+
+00000000 <different_section>:
+   0:	e2 c0 00 00 	sub r0,r1,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/call_pic.d
@@ -0,0 +1,36 @@
+#source: call.s
+#as: --pic
+#objdump: -dr
+#name: call_pic
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <call_test>:
+       0:	d7 03       	nop
+
+00000002 <toofar_negative>:
+	\.\.\.
+  1ffffe:	00 00       	add r0,r0
+  200000:	f0 a0 00 00 	rcall 0 <call_test>
+  200004:	f0 16 00 00 	mcall r6\[0\]
+			200004: R_AVR32_GOT18SW	toofar_negative
+  200008:	f0 16 00 00 	mcall r6\[0\]
+			200008: R_AVR32_GOT18SW	different_section
+  20000c:	f0 16 00 00 	mcall r6\[0\]
+			20000c: R_AVR32_GOT18SW	undefined
+  200010:	f0 16 00 00 	mcall r6\[0\]
+			200010: R_AVR32_GOT18SW	toofar_positive
+	\.\.\.
+  200030:	ee b0 ff ff 	rcall 40002e <far_positive>
+	\.\.\.
+
+0040002c <toofar_positive>:
+  40002c:	d7 03       	nop
+0040002e <far_positive>:
+  40002e:	d7 03       	nop
+Disassembly of section \.text\.init:
+
+00000000 <different_section>:
+   0:	e2 c0 00 00 	sub r0,r1,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/call_pic_linkrelax.d
@@ -0,0 +1,47 @@
+#source: call.s
+#as: --pic --linkrelax
+#objdump: -dr
+#name: call_pic_linkrelax
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <call_test>:
+       0:	d7 03       	nop
+
+00000002 <toofar_negative>:
+	\.\.\.
+  1ffffe:	00 00       	add r0,r0
+  200000:	e0 a0 00 00 	rcall 200000 <toofar_negative\+0x1ffffe>
+			200000: R_AVR32_22H_PCREL	\.text
+  200004:	e0 6e 00 00 	mov lr,0
+			200004: R_AVR32_GOTCALL	toofar_negative
+  200008:	ec 0e 03 2e 	ld\.w lr,r6\[lr<<0x2\]
+  20000c:	5d 1e       	icall lr
+  20000e:	e0 6e 00 00 	mov lr,0
+			20000e: R_AVR32_GOTCALL	different_section
+  200012:	ec 0e 03 2e 	ld\.w lr,r6\[lr<<0x2\]
+  200016:	5d 1e       	icall lr
+  200018:	e0 6e 00 00 	mov lr,0
+			200018: R_AVR32_GOTCALL	undefined
+  20001c:	ec 0e 03 2e 	ld\.w lr,r6\[lr<<0x2\]
+  200020:	5d 1e       	icall lr
+  200022:	e0 6e 00 00 	mov lr,0
+			200022: R_AVR32_GOTCALL	toofar_positive
+  200026:	ec 0e 03 2e 	ld\.w lr,r6\[lr<<0x2\]
+  20002a:	5d 1e       	icall lr
+  20002c:	00 00       	add r0,r0
+  20002e:	00 00       	add r0,r0
+  200030:	e0 a0 00 00 	rcall 200030 <toofar_negative\+0x20002e>
+			200030: R_AVR32_22H_PCREL	\.text\+0x40002e
+	\.\.\.
+
+0040002c <toofar_positive>:
+  40002c:	d7 03       	nop
+0040002e <far_positive>:
+  40002e:	d7 03       	nop
+Disassembly of section \.text\.init:
+
+00000000 <different_section>:
+   0:	e2 c0 00 00 	sub r0,r1,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/call.s
@@ -0,0 +1,30 @@
+
+	.text
+	.global call_test
+call_test:
+far_negative:
+	nop
+toofar_negative:
+
+	.org	0x200000
+
+	call	far_negative
+	call	toofar_negative
+	call	different_section
+	call	undefined
+	call	toofar_positive
+	.org	0x200030
+	call	far_positive
+
+	.cpool
+
+	.org	0x40002c
+
+toofar_positive:
+	nop
+far_positive:
+	nop
+
+	.section .text.init,"ax",@progbits
+different_section:
+	sub	r0, r1, 0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/dwarf2.d
@@ -0,0 +1,42 @@
+#readelf: -wl
+#name: dwarf2
+#source: dwarf2.s
+
+Dump of debug contents of section \.debug_line:
+
+  Length:                      53
+  DWARF Version:               2
+  Prologue Length:             26
+  Minimum Instruction Length:  1
+  Initial value of 'is_stmt':  1
+  Line Base:                   -5
+  Line Range:                  14
+  Opcode Base:                 10
+  \(Pointer size:               4\)
+
+ Opcodes:
+  Opcode 1 has 0 args
+  Opcode 2 has 1 args
+  Opcode 3 has 1 args
+  Opcode 4 has 1 args
+  Opcode 5 has 1 args
+  Opcode 6 has 0 args
+  Opcode 7 has 0 args
+  Opcode 8 has 0 args
+  Opcode 9 has 1 args
+
+ The Directory Table is empty\.
+
+ The File Name Table:
+  Entry	Dir	Time	Size	Name
+  1	0	0	0	main\.c
+
+ Line Number Statements:
+  Extended opcode 2: set Address to 0x0
+  Advance Line by 87 to 88
+  Copy
+  Advance Line by 23 to 111
+  Special opcode .*: advance Address by 4 to 0x4 and Line by 0 to 111
+  Special opcode .*: advance Address by 10 to 0xe and Line by 1 to 112
+  Advance PC by 530 to 220
+  Extended opcode 1: End of Sequence
--- /dev/null
+++ b/gas/testsuite/gas/avr32/dwarf2.s
@@ -0,0 +1,67 @@
+# Source file used to test DWARF2 information for AVR32.
+
+	.file	"main.c"
+
+	.section .debug_abbrev,"",@progbits
+.Ldebug_abbrev0:
+	.section .debug_info,"",@progbits
+.Ldebug_info0:
+	.section .debug_line,"",@progbits
+.Ldebug_line0:
+
+	.text
+	.align	1
+	.globl	main
+	.type	main, @function
+.Ltext0:
+main:
+	.file 1 "main.c"
+	.loc 1 88 0
+	pushm	r0-r7,lr
+	sub	sp, 4
+	.loc 1 111 0
+	lddpc	r12, .LC1
+	lddpc	r7, .LC1
+	icall	r7
+	.loc 1 112 0
+	lddpc	r6, .LC4
+
+	.align	2
+.LC4:	.int	0
+
+	.fill	256, 2, 0
+
+	.align	2
+.LC1:
+	.int	0
+.LC2:
+	.int	0
+.LC3:
+	.int	0
+	.size	main, . - main
+
+.Letext0:
+
+	.section .debug_info
+	.int	.Ledebug_info0 - .Ldebug_info0	// size
+	.short	2				// version
+	.int	.Ldebug_abbrev0			// abbrev offset
+	.byte	4				// bytes per addr
+
+	.uleb128 1				// abbrev 1
+	.int	.Ldebug_line0			// DW_AT_stmt_list
+	.int	.Letext0			// DW_AT_high_pc
+	.int	.Ltext0				// DW_AT_low_pc
+
+.Ledebug_info0:
+
+	.section .debug_abbrev
+	.uleb128 0x01
+	.uleb128 0x11		// DW_TAG_compile_unit
+	.byte	0		// DW_CHILDREN_no
+	.uleb128 0x10, 0x6	// DW_AT_stmt_list
+	.uleb128 0x12, 0x1	// DW_AT_high_pc
+	.uleb128 0x11, 0x1	// DW_AT_low_pc
+	.uleb128 0, 0
+
+	.byte	0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/fpinsn.d
@@ -0,0 +1,271 @@
+#as:
+#objdump: -dr
+#name: fpinsn
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+[0-9a-f]* <fadd_s>:
+ *[0-9a-f]*:	e1 a2 0f ff 	cop cp0,cr15,cr15,cr15,0x4
+ *[0-9a-f]*:	e1 a2 00 00 	cop cp0,cr0,cr0,cr0,0x4
+ *[0-9a-f]*:	e1 a2 00 ff 	cop cp0,cr0,cr15,cr15,0x4
+ *[0-9a-f]*:	e1 a2 0f 0f 	cop cp0,cr15,cr0,cr15,0x4
+ *[0-9a-f]*:	e1 a2 0f f0 	cop cp0,cr15,cr15,cr0,0x4
+ *[0-9a-f]*:	e1 a2 07 88 	cop cp0,cr7,cr8,cr8,0x4
+ *[0-9a-f]*:	e1 a2 08 78 	cop cp0,cr8,cr7,cr8,0x4
+ *[0-9a-f]*:	e1 a2 08 87 	cop cp0,cr8,cr8,cr7,0x4
+
+[0-9a-f]* <fsub_s>:
+ *[0-9a-f]*:	e1 a2 1f ff 	cop cp0,cr15,cr15,cr15,0x5
+ *[0-9a-f]*:	e1 a2 10 00 	cop cp0,cr0,cr0,cr0,0x5
+ *[0-9a-f]*:	e1 a2 10 ff 	cop cp0,cr0,cr15,cr15,0x5
+ *[0-9a-f]*:	e1 a2 1f 0f 	cop cp0,cr15,cr0,cr15,0x5
+ *[0-9a-f]*:	e1 a2 1f f0 	cop cp0,cr15,cr15,cr0,0x5
+ *[0-9a-f]*:	e1 a2 17 88 	cop cp0,cr7,cr8,cr8,0x5
+ *[0-9a-f]*:	e1 a2 18 78 	cop cp0,cr8,cr7,cr8,0x5
+ *[0-9a-f]*:	e1 a2 18 87 	cop cp0,cr8,cr8,cr7,0x5
+
+[0-9a-f]* <fmac_s>:
+ *[0-9a-f]*:	e1 a0 0f ff 	cop cp0,cr15,cr15,cr15,0x0
+ *[0-9a-f]*:	e1 a0 00 00 	cop cp0,cr0,cr0,cr0,0x0
+ *[0-9a-f]*:	e1 a0 00 ff 	cop cp0,cr0,cr15,cr15,0x0
+ *[0-9a-f]*:	e1 a0 0f 0f 	cop cp0,cr15,cr0,cr15,0x0
+ *[0-9a-f]*:	e1 a0 0f f0 	cop cp0,cr15,cr15,cr0,0x0
+ *[0-9a-f]*:	e1 a0 07 88 	cop cp0,cr7,cr8,cr8,0x0
+ *[0-9a-f]*:	e1 a0 08 78 	cop cp0,cr8,cr7,cr8,0x0
+ *[0-9a-f]*:	e1 a0 08 87 	cop cp0,cr8,cr8,cr7,0x0
+
+[0-9a-f]* <fnmac_s>:
+ *[0-9a-f]*:	e1 a0 1f ff 	cop cp0,cr15,cr15,cr15,0x1
+ *[0-9a-f]*:	e1 a0 10 00 	cop cp0,cr0,cr0,cr0,0x1
+ *[0-9a-f]*:	e1 a0 10 ff 	cop cp0,cr0,cr15,cr15,0x1
+ *[0-9a-f]*:	e1 a0 1f 0f 	cop cp0,cr15,cr0,cr15,0x1
+ *[0-9a-f]*:	e1 a0 1f f0 	cop cp0,cr15,cr15,cr0,0x1
+ *[0-9a-f]*:	e1 a0 17 88 	cop cp0,cr7,cr8,cr8,0x1
+ *[0-9a-f]*:	e1 a0 18 78 	cop cp0,cr8,cr7,cr8,0x1
+ *[0-9a-f]*:	e1 a0 18 87 	cop cp0,cr8,cr8,cr7,0x1
+
+[0-9a-f]* <fmsc_s>:
+ *[0-9a-f]*:	e1 a1 0f ff 	cop cp0,cr15,cr15,cr15,0x2
+ *[0-9a-f]*:	e1 a1 00 00 	cop cp0,cr0,cr0,cr0,0x2
+ *[0-9a-f]*:	e1 a1 00 ff 	cop cp0,cr0,cr15,cr15,0x2
+ *[0-9a-f]*:	e1 a1 0f 0f 	cop cp0,cr15,cr0,cr15,0x2
+ *[0-9a-f]*:	e1 a1 0f f0 	cop cp0,cr15,cr15,cr0,0x2
+ *[0-9a-f]*:	e1 a1 07 88 	cop cp0,cr7,cr8,cr8,0x2
+ *[0-9a-f]*:	e1 a1 08 78 	cop cp0,cr8,cr7,cr8,0x2
+ *[0-9a-f]*:	e1 a1 08 87 	cop cp0,cr8,cr8,cr7,0x2
+
+[0-9a-f]* <fnmsc_s>:
+ *[0-9a-f]*:	e1 a1 1f ff 	cop cp0,cr15,cr15,cr15,0x3
+ *[0-9a-f]*:	e1 a1 10 00 	cop cp0,cr0,cr0,cr0,0x3
+ *[0-9a-f]*:	e1 a1 10 ff 	cop cp0,cr0,cr15,cr15,0x3
+ *[0-9a-f]*:	e1 a1 1f 0f 	cop cp0,cr15,cr0,cr15,0x3
+ *[0-9a-f]*:	e1 a1 1f f0 	cop cp0,cr15,cr15,cr0,0x3
+ *[0-9a-f]*:	e1 a1 17 88 	cop cp0,cr7,cr8,cr8,0x3
+ *[0-9a-f]*:	e1 a1 18 78 	cop cp0,cr8,cr7,cr8,0x3
+ *[0-9a-f]*:	e1 a1 18 87 	cop cp0,cr8,cr8,cr7,0x3
+
+[0-9a-f]* <fmul_s>:
+ *[0-9a-f]*:	e1 a3 0f ff 	cop cp0,cr15,cr15,cr15,0x6
+ *[0-9a-f]*:	e1 a3 00 00 	cop cp0,cr0,cr0,cr0,0x6
+ *[0-9a-f]*:	e1 a3 00 ff 	cop cp0,cr0,cr15,cr15,0x6
+ *[0-9a-f]*:	e1 a3 0f 0f 	cop cp0,cr15,cr0,cr15,0x6
+ *[0-9a-f]*:	e1 a3 0f f0 	cop cp0,cr15,cr15,cr0,0x6
+ *[0-9a-f]*:	e1 a3 07 88 	cop cp0,cr7,cr8,cr8,0x6
+ *[0-9a-f]*:	e1 a3 08 78 	cop cp0,cr8,cr7,cr8,0x6
+ *[0-9a-f]*:	e1 a3 08 87 	cop cp0,cr8,cr8,cr7,0x6
+
+[0-9a-f]* <fnmul_s>:
+ *[0-9a-f]*:	e1 a3 1f ff 	cop cp0,cr15,cr15,cr15,0x7
+ *[0-9a-f]*:	e1 a3 10 00 	cop cp0,cr0,cr0,cr0,0x7
+ *[0-9a-f]*:	e1 a3 10 ff 	cop cp0,cr0,cr15,cr15,0x7
+ *[0-9a-f]*:	e1 a3 1f 0f 	cop cp0,cr15,cr0,cr15,0x7
+ *[0-9a-f]*:	e1 a3 1f f0 	cop cp0,cr15,cr15,cr0,0x7
+ *[0-9a-f]*:	e1 a3 17 88 	cop cp0,cr7,cr8,cr8,0x7
+ *[0-9a-f]*:	e1 a3 18 78 	cop cp0,cr8,cr7,cr8,0x7
+ *[0-9a-f]*:	e1 a3 18 87 	cop cp0,cr8,cr8,cr7,0x7
+
+[0-9a-f]* <fneg_s>:
+ *[0-9a-f]*:	e1 a4 0f f0 	cop cp0,cr15,cr15,cr0,0x8
+ *[0-9a-f]*:	e1 a4 00 00 	cop cp0,cr0,cr0,cr0,0x8
+ *[0-9a-f]*:	e1 a4 00 f0 	cop cp0,cr0,cr15,cr0,0x8
+ *[0-9a-f]*:	e1 a4 0f 00 	cop cp0,cr15,cr0,cr0,0x8
+ *[0-9a-f]*:	e1 a4 07 80 	cop cp0,cr7,cr8,cr0,0x8
+ *[0-9a-f]*:	e1 a4 08 70 	cop cp0,cr8,cr7,cr0,0x8
+
+[0-9a-f]* <fabs_s>:
+ *[0-9a-f]*:	e1 a4 1f f0 	cop cp0,cr15,cr15,cr0,0x9
+ *[0-9a-f]*:	e1 a4 10 00 	cop cp0,cr0,cr0,cr0,0x9
+ *[0-9a-f]*:	e1 a4 10 f0 	cop cp0,cr0,cr15,cr0,0x9
+ *[0-9a-f]*:	e1 a4 1f 00 	cop cp0,cr15,cr0,cr0,0x9
+ *[0-9a-f]*:	e1 a4 17 80 	cop cp0,cr7,cr8,cr0,0x9
+ *[0-9a-f]*:	e1 a4 18 70 	cop cp0,cr8,cr7,cr0,0x9
+
+[0-9a-f]* <fcmp_s>:
+ *[0-9a-f]*:	e1 a6 10 ff 	cop cp0,cr0,cr15,cr15,0xd
+ *[0-9a-f]*:	e1 a6 10 00 	cop cp0,cr0,cr0,cr0,0xd
+ *[0-9a-f]*:	e1 a6 10 0f 	cop cp0,cr0,cr0,cr15,0xd
+ *[0-9a-f]*:	e1 a6 10 f0 	cop cp0,cr0,cr15,cr0,0xd
+ *[0-9a-f]*:	e1 a6 10 78 	cop cp0,cr0,cr7,cr8,0xd
+ *[0-9a-f]*:	e1 a6 10 87 	cop cp0,cr0,cr8,cr7,0xd
+
+[0-9a-f]* <fadd_d>:
+ *[0-9a-f]*:	e5 a2 0e ee 	cop cp0,cr14,cr14,cr14,0x44
+ *[0-9a-f]*:	e5 a2 00 00 	cop cp0,cr0,cr0,cr0,0x44
+ *[0-9a-f]*:	e5 a2 00 ee 	cop cp0,cr0,cr14,cr14,0x44
+ *[0-9a-f]*:	e5 a2 0e 0e 	cop cp0,cr14,cr0,cr14,0x44
+ *[0-9a-f]*:	e5 a2 0e e0 	cop cp0,cr14,cr14,cr0,0x44
+ *[0-9a-f]*:	e5 a2 06 88 	cop cp0,cr6,cr8,cr8,0x44
+ *[0-9a-f]*:	e5 a2 08 68 	cop cp0,cr8,cr6,cr8,0x44
+ *[0-9a-f]*:	e5 a2 08 86 	cop cp0,cr8,cr8,cr6,0x44
+
+[0-9a-f]* <fsub_d>:
+ *[0-9a-f]*:	e5 a2 1e ee 	cop cp0,cr14,cr14,cr14,0x45
+ *[0-9a-f]*:	e5 a2 10 00 	cop cp0,cr0,cr0,cr0,0x45
+ *[0-9a-f]*:	e5 a2 10 ee 	cop cp0,cr0,cr14,cr14,0x45
+ *[0-9a-f]*:	e5 a2 1e 0e 	cop cp0,cr14,cr0,cr14,0x45
+ *[0-9a-f]*:	e5 a2 1e e0 	cop cp0,cr14,cr14,cr0,0x45
+ *[0-9a-f]*:	e5 a2 16 88 	cop cp0,cr6,cr8,cr8,0x45
+ *[0-9a-f]*:	e5 a2 18 68 	cop cp0,cr8,cr6,cr8,0x45
+ *[0-9a-f]*:	e5 a2 18 86 	cop cp0,cr8,cr8,cr6,0x45
+
+[0-9a-f]* <fmac_d>:
+ *[0-9a-f]*:	e5 a0 0e ee 	cop cp0,cr14,cr14,cr14,0x40
+ *[0-9a-f]*:	e5 a0 00 00 	cop cp0,cr0,cr0,cr0,0x40
+ *[0-9a-f]*:	e5 a0 00 ee 	cop cp0,cr0,cr14,cr14,0x40
+ *[0-9a-f]*:	e5 a0 0e 0e 	cop cp0,cr14,cr0,cr14,0x40
+ *[0-9a-f]*:	e5 a0 0e e0 	cop cp0,cr14,cr14,cr0,0x40
+ *[0-9a-f]*:	e5 a0 06 88 	cop cp0,cr6,cr8,cr8,0x40
+ *[0-9a-f]*:	e5 a0 08 68 	cop cp0,cr8,cr6,cr8,0x40
+ *[0-9a-f]*:	e5 a0 08 86 	cop cp0,cr8,cr8,cr6,0x40
+
+[0-9a-f]* <fnmac_d>:
+ *[0-9a-f]*:	e5 a0 1e ee 	cop cp0,cr14,cr14,cr14,0x41
+ *[0-9a-f]*:	e5 a0 10 00 	cop cp0,cr0,cr0,cr0,0x41
+ *[0-9a-f]*:	e5 a0 10 ee 	cop cp0,cr0,cr14,cr14,0x41
+ *[0-9a-f]*:	e5 a0 1e 0e 	cop cp0,cr14,cr0,cr14,0x41
+ *[0-9a-f]*:	e5 a0 1e e0 	cop cp0,cr14,cr14,cr0,0x41
+ *[0-9a-f]*:	e5 a0 16 88 	cop cp0,cr6,cr8,cr8,0x41
+ *[0-9a-f]*:	e5 a0 18 68 	cop cp0,cr8,cr6,cr8,0x41
+ *[0-9a-f]*:	e5 a0 18 86 	cop cp0,cr8,cr8,cr6,0x41
+
+[0-9a-f]* <fmsc_d>:
+ *[0-9a-f]*:	e5 a1 0e ee 	cop cp0,cr14,cr14,cr14,0x42
+ *[0-9a-f]*:	e5 a1 00 00 	cop cp0,cr0,cr0,cr0,0x42
+ *[0-9a-f]*:	e5 a1 00 ee 	cop cp0,cr0,cr14,cr14,0x42
+ *[0-9a-f]*:	e5 a1 0e 0e 	cop cp0,cr14,cr0,cr14,0x42
+ *[0-9a-f]*:	e5 a1 0e e0 	cop cp0,cr14,cr14,cr0,0x42
+ *[0-9a-f]*:	e5 a1 06 88 	cop cp0,cr6,cr8,cr8,0x42
+ *[0-9a-f]*:	e5 a1 08 68 	cop cp0,cr8,cr6,cr8,0x42
+ *[0-9a-f]*:	e5 a1 08 86 	cop cp0,cr8,cr8,cr6,0x42
+
+[0-9a-f]* <fnmsc_d>:
+ *[0-9a-f]*:	e5 a1 1e ee 	cop cp0,cr14,cr14,cr14,0x43
+ *[0-9a-f]*:	e5 a1 10 00 	cop cp0,cr0,cr0,cr0,0x43
+ *[0-9a-f]*:	e5 a1 10 ee 	cop cp0,cr0,cr14,cr14,0x43
+ *[0-9a-f]*:	e5 a1 1e 0e 	cop cp0,cr14,cr0,cr14,0x43
+ *[0-9a-f]*:	e5 a1 1e e0 	cop cp0,cr14,cr14,cr0,0x43
+ *[0-9a-f]*:	e5 a1 16 88 	cop cp0,cr6,cr8,cr8,0x43
+ *[0-9a-f]*:	e5 a1 18 68 	cop cp0,cr8,cr6,cr8,0x43
+ *[0-9a-f]*:	e5 a1 18 86 	cop cp0,cr8,cr8,cr6,0x43
+
+[0-9a-f]* <fmul_d>:
+ *[0-9a-f]*:	e5 a3 0e ee 	cop cp0,cr14,cr14,cr14,0x46
+ *[0-9a-f]*:	e5 a3 00 00 	cop cp0,cr0,cr0,cr0,0x46
+ *[0-9a-f]*:	e5 a3 00 ee 	cop cp0,cr0,cr14,cr14,0x46
+ *[0-9a-f]*:	e5 a3 0e 0e 	cop cp0,cr14,cr0,cr14,0x46
+ *[0-9a-f]*:	e5 a3 0e e0 	cop cp0,cr14,cr14,cr0,0x46
+ *[0-9a-f]*:	e5 a3 06 88 	cop cp0,cr6,cr8,cr8,0x46
+ *[0-9a-f]*:	e5 a3 08 68 	cop cp0,cr8,cr6,cr8,0x46
+ *[0-9a-f]*:	e5 a3 08 86 	cop cp0,cr8,cr8,cr6,0x46
+
+[0-9a-f]* <fnmul_d>:
+ *[0-9a-f]*:	e5 a3 1e ee 	cop cp0,cr14,cr14,cr14,0x47
+ *[0-9a-f]*:	e5 a3 10 00 	cop cp0,cr0,cr0,cr0,0x47
+ *[0-9a-f]*:	e5 a3 10 ee 	cop cp0,cr0,cr14,cr14,0x47
+ *[0-9a-f]*:	e5 a3 1e 0e 	cop cp0,cr14,cr0,cr14,0x47
+ *[0-9a-f]*:	e5 a3 1e e0 	cop cp0,cr14,cr14,cr0,0x47
+ *[0-9a-f]*:	e5 a3 16 88 	cop cp0,cr6,cr8,cr8,0x47
+ *[0-9a-f]*:	e5 a3 18 68 	cop cp0,cr8,cr6,cr8,0x47
+ *[0-9a-f]*:	e5 a3 18 86 	cop cp0,cr8,cr8,cr6,0x47
+
+[0-9a-f]* <fneg_d>:
+ *[0-9a-f]*:	e5 a4 0e e0 	cop cp0,cr14,cr14,cr0,0x48
+ *[0-9a-f]*:	e5 a4 00 00 	cop cp0,cr0,cr0,cr0,0x48
+ *[0-9a-f]*:	e5 a4 00 e0 	cop cp0,cr0,cr14,cr0,0x48
+ *[0-9a-f]*:	e5 a4 0e 00 	cop cp0,cr14,cr0,cr0,0x48
+ *[0-9a-f]*:	e5 a4 06 80 	cop cp0,cr6,cr8,cr0,0x48
+ *[0-9a-f]*:	e5 a4 08 60 	cop cp0,cr8,cr6,cr0,0x48
+
+[0-9a-f]* <fabs_d>:
+ *[0-9a-f]*:	e5 a4 1e e0 	cop cp0,cr14,cr14,cr0,0x49
+ *[0-9a-f]*:	e5 a4 10 00 	cop cp0,cr0,cr0,cr0,0x49
+ *[0-9a-f]*:	e5 a4 10 e0 	cop cp0,cr0,cr14,cr0,0x49
+ *[0-9a-f]*:	e5 a4 1e 00 	cop cp0,cr14,cr0,cr0,0x49
+ *[0-9a-f]*:	e5 a4 16 80 	cop cp0,cr6,cr8,cr0,0x49
+ *[0-9a-f]*:	e5 a4 18 60 	cop cp0,cr8,cr6,cr0,0x49
+
+[0-9a-f]* <fcmp_d>:
+ *[0-9a-f]*:	e5 a6 10 ee 	cop cp0,cr0,cr14,cr14,0x4d
+ *[0-9a-f]*:	e5 a6 10 00 	cop cp0,cr0,cr0,cr0,0x4d
+ *[0-9a-f]*:	e5 a6 10 0e 	cop cp0,cr0,cr0,cr14,0x4d
+ *[0-9a-f]*:	e5 a6 10 e0 	cop cp0,cr0,cr14,cr0,0x4d
+ *[0-9a-f]*:	e5 a6 10 68 	cop cp0,cr0,cr6,cr8,0x4d
+ *[0-9a-f]*:	e5 a6 10 86 	cop cp0,cr0,cr8,cr6,0x4d
+
+[0-9a-f]* <fmov_s>:
+ *[0-9a-f]*:	e1 a5 0f f0 	cop cp0,cr15,cr15,cr0,0xa
+ *[0-9a-f]*:	e1 a5 00 00 	cop cp0,cr0,cr0,cr0,0xa
+ *[0-9a-f]*:	e1 a5 0f 00 	cop cp0,cr15,cr0,cr0,0xa
+ *[0-9a-f]*:	e1 a5 00 f0 	cop cp0,cr0,cr15,cr0,0xa
+ *[0-9a-f]*:	e1 a5 08 70 	cop cp0,cr8,cr7,cr0,0xa
+ *[0-9a-f]*:	e1 a5 07 80 	cop cp0,cr7,cr8,cr0,0xa
+ *[0-9a-f]*:	ef af 0f 00 	mvcr.w cp0,pc,cr15
+ *[0-9a-f]*:	ef a0 00 00 	mvcr.w cp0,r0,cr0
+ *[0-9a-f]*:	ef af 00 00 	mvcr.w cp0,pc,cr0
+ *[0-9a-f]*:	ef a0 0f 00 	mvcr.w cp0,r0,cr15
+ *[0-9a-f]*:	ef a8 07 00 	mvcr.w cp0,r8,cr7
+ *[0-9a-f]*:	ef a7 08 00 	mvcr.w cp0,r7,cr8
+ *[0-9a-f]*:	ef af 0f 20 	mvrc.w cp0,cr15,pc
+ *[0-9a-f]*:	ef a0 00 20 	mvrc.w cp0,cr0,r0
+ *[0-9a-f]*:	ef a0 0f 20 	mvrc.w cp0,cr15,r0
+ *[0-9a-f]*:	ef af 00 20 	mvrc.w cp0,cr0,pc
+ *[0-9a-f]*:	ef a7 08 20 	mvrc.w cp0,cr8,r7
+ *[0-9a-f]*:	ef a8 07 20 	mvrc.w cp0,cr7,r8
+
+[0-9a-f]* <fmov_d>:
+ *[0-9a-f]*:	e5 a5 0e e0 	cop cp0,cr14,cr14,cr0,0x4a
+ *[0-9a-f]*:	e5 a5 00 00 	cop cp0,cr0,cr0,cr0,0x4a
+ *[0-9a-f]*:	e5 a5 0e 00 	cop cp0,cr14,cr0,cr0,0x4a
+ *[0-9a-f]*:	e5 a5 00 e0 	cop cp0,cr0,cr14,cr0,0x4a
+ *[0-9a-f]*:	e5 a5 08 60 	cop cp0,cr8,cr6,cr0,0x4a
+ *[0-9a-f]*:	e5 a5 06 80 	cop cp0,cr6,cr8,cr0,0x4a
+ *[0-9a-f]*:	ef ae 0e 10 	mvcr.d cp0,lr,cr14
+ *[0-9a-f]*:	ef a0 00 10 	mvcr.d cp0,r0,cr0
+ *[0-9a-f]*:	ef ae 00 10 	mvcr.d cp0,lr,cr0
+ *[0-9a-f]*:	ef a0 0e 10 	mvcr.d cp0,r0,cr14
+ *[0-9a-f]*:	ef a8 06 10 	mvcr.d cp0,r8,cr6
+ *[0-9a-f]*:	ef a6 08 10 	mvcr.d cp0,r6,cr8
+ *[0-9a-f]*:	ef ae 0e 30 	mvrc.d cp0,cr14,lr
+ *[0-9a-f]*:	ef a0 00 30 	mvrc.d cp0,cr0,r0
+ *[0-9a-f]*:	ef a0 0e 30 	mvrc.d cp0,cr14,r0
+ *[0-9a-f]*:	ef ae 00 30 	mvrc.d cp0,cr0,lr
+ *[0-9a-f]*:	ef a6 08 30 	mvrc.d cp0,cr8,r6
+ *[0-9a-f]*:	ef a8 06 30 	mvrc.d cp0,cr6,r8
+
+[0-9a-f]* <fcasts_d>:
+ *[0-9a-f]*:	e1 a7 1f e0 	cop cp0,cr15,cr14,cr0,0xf
+ *[0-9a-f]*:	e1 a7 10 00 	cop cp0,cr0,cr0,cr0,0xf
+ *[0-9a-f]*:	e1 a7 1f 00 	cop cp0,cr15,cr0,cr0,0xf
+ *[0-9a-f]*:	e1 a7 10 e0 	cop cp0,cr0,cr14,cr0,0xf
+ *[0-9a-f]*:	e1 a7 18 60 	cop cp0,cr8,cr6,cr0,0xf
+ *[0-9a-f]*:	e1 a7 17 80 	cop cp0,cr7,cr8,cr0,0xf
+
+[0-9a-f]* <fcastd_s>:
+ *[0-9a-f]*:	e1 a8 0e f0 	cop cp0,cr14,cr15,cr0,0x10
+ *[0-9a-f]*:	e1 a8 00 00 	cop cp0,cr0,cr0,cr0,0x10
+ *[0-9a-f]*:	e1 a8 0e 00 	cop cp0,cr14,cr0,cr0,0x10
+ *[0-9a-f]*:	e1 a8 00 f0 	cop cp0,cr0,cr15,cr0,0x10
+ *[0-9a-f]*:	e1 a8 08 70 	cop cp0,cr8,cr7,cr0,0x10
+ *[0-9a-f]*:	e1 a8 06 80 	cop cp0,cr6,cr8,cr0,0x10
--- /dev/null
+++ b/gas/testsuite/gas/avr32/fpinsn.s
@@ -0,0 +1,266 @@
+
+	.text
+	.global	fadd_s
+fadd_s:
+	fadd.s fr15, fr15, fr15
+	fadd.s fr0, fr0, fr0
+	fadd.s fr0, fr15, fr15
+	fadd.s fr15, fr0, fr15
+	fadd.s fr15, fr15, fr0
+	fadd.s fr7, fr8, fr8
+	fadd.s fr8, fr7, fr8
+	fadd.s fr8, fr8, fr7
+	.global	fsub_s
+fsub_s:
+	fsub.s fr15, fr15, fr15
+	fsub.s fr0, fr0, fr0
+	fsub.s fr0, fr15, fr15
+	fsub.s fr15, fr0, fr15
+	fsub.s fr15, fr15, fr0
+	fsub.s fr7, fr8, fr8
+	fsub.s fr8, fr7, fr8
+	fsub.s fr8, fr8, fr7
+	.global	fmac_s
+fmac_s:
+	fmac.s fr15, fr15, fr15
+	fmac.s fr0, fr0, fr0
+	fmac.s fr0, fr15, fr15
+	fmac.s fr15, fr0, fr15
+	fmac.s fr15, fr15, fr0
+	fmac.s fr7, fr8, fr8
+	fmac.s fr8, fr7, fr8
+	fmac.s fr8, fr8, fr7
+	.global	fnmac_s
+fnmac_s:
+	fnmac.s fr15, fr15, fr15
+	fnmac.s fr0, fr0, fr0
+	fnmac.s fr0, fr15, fr15
+	fnmac.s fr15, fr0, fr15
+	fnmac.s fr15, fr15, fr0
+	fnmac.s fr7, fr8, fr8
+	fnmac.s fr8, fr7, fr8
+	fnmac.s fr8, fr8, fr7
+	.global	fmsc_s
+fmsc_s:
+	fmsc.s fr15, fr15, fr15
+	fmsc.s fr0, fr0, fr0
+	fmsc.s fr0, fr15, fr15
+	fmsc.s fr15, fr0, fr15
+	fmsc.s fr15, fr15, fr0
+	fmsc.s fr7, fr8, fr8
+	fmsc.s fr8, fr7, fr8
+	fmsc.s fr8, fr8, fr7
+	.global	fnmsc_s
+fnmsc_s:
+	fnmsc.s fr15, fr15, fr15
+	fnmsc.s fr0, fr0, fr0
+	fnmsc.s fr0, fr15, fr15
+	fnmsc.s fr15, fr0, fr15
+	fnmsc.s fr15, fr15, fr0
+	fnmsc.s fr7, fr8, fr8
+	fnmsc.s fr8, fr7, fr8
+	fnmsc.s fr8, fr8, fr7
+	.global	fmul_s
+fmul_s:
+	fmul.s fr15, fr15, fr15
+	fmul.s fr0, fr0, fr0
+	fmul.s fr0, fr15, fr15
+	fmul.s fr15, fr0, fr15
+	fmul.s fr15, fr15, fr0
+	fmul.s fr7, fr8, fr8
+	fmul.s fr8, fr7, fr8
+	fmul.s fr8, fr8, fr7
+	.global	fnmul_s
+fnmul_s:
+	fnmul.s fr15, fr15, fr15
+	fnmul.s fr0, fr0, fr0
+	fnmul.s fr0, fr15, fr15
+	fnmul.s fr15, fr0, fr15
+	fnmul.s fr15, fr15, fr0
+	fnmul.s fr7, fr8, fr8
+	fnmul.s fr8, fr7, fr8
+	fnmul.s fr8, fr8, fr7
+	.global	fneg_s
+fneg_s:
+	fneg.s fr15, fr15
+	fneg.s fr0, fr0
+	fneg.s fr0, fr15
+	fneg.s fr15, fr0
+	fneg.s fr7, fr8
+	fneg.s fr8, fr7
+	.global	fabs_s
+fabs_s:
+	fabs.s fr15, fr15
+	fabs.s fr0, fr0
+	fabs.s fr0, fr15
+	fabs.s fr15, fr0
+	fabs.s fr7, fr8
+	fabs.s fr8, fr7
+	.global	fcmp_s
+fcmp_s:
+	fcmp.s fr15, fr15
+	fcmp.s fr0, fr0
+	fcmp.s fr0, fr15
+	fcmp.s fr15, fr0
+	fcmp.s fr7, fr8
+	fcmp.s fr8, fr7
+	.global	fadd_d
+fadd_d:
+	fadd.d fr14, fr14, fr14
+	fadd.d fr0, fr0, fr0
+	fadd.d fr0, fr14, fr14
+	fadd.d fr14, fr0, fr14
+	fadd.d fr14, fr14, fr0
+	fadd.d fr6, fr8, fr8
+	fadd.d fr8, fr6, fr8
+	fadd.d fr8, fr8, fr6
+	.global	fsub_d
+fsub_d:
+	fsub.d fr14, fr14, fr14
+	fsub.d fr0, fr0, fr0
+	fsub.d fr0, fr14, fr14
+	fsub.d fr14, fr0, fr14
+	fsub.d fr14, fr14, fr0
+	fsub.d fr6, fr8, fr8
+	fsub.d fr8, fr6, fr8
+	fsub.d fr8, fr8, fr6
+	.global	fmac_d
+fmac_d:
+	fmac.d fr14, fr14, fr14
+	fmac.d fr0, fr0, fr0
+	fmac.d fr0, fr14, fr14
+	fmac.d fr14, fr0, fr14
+	fmac.d fr14, fr14, fr0
+	fmac.d fr6, fr8, fr8
+	fmac.d fr8, fr6, fr8
+	fmac.d fr8, fr8, fr6
+	.global	fnmac_d
+fnmac_d:
+	fnmac.d fr14, fr14, fr14
+	fnmac.d fr0, fr0, fr0
+	fnmac.d fr0, fr14, fr14
+	fnmac.d fr14, fr0, fr14
+	fnmac.d fr14, fr14, fr0
+	fnmac.d fr6, fr8, fr8
+	fnmac.d fr8, fr6, fr8
+	fnmac.d fr8, fr8, fr6
+	.global	fmsc_d
+fmsc_d:
+	fmsc.d fr14, fr14, fr14
+	fmsc.d fr0, fr0, fr0
+	fmsc.d fr0, fr14, fr14
+	fmsc.d fr14, fr0, fr14
+	fmsc.d fr14, fr14, fr0
+	fmsc.d fr6, fr8, fr8
+	fmsc.d fr8, fr6, fr8
+	fmsc.d fr8, fr8, fr6
+	.global	fnmsc_d
+fnmsc_d:
+	fnmsc.d fr14, fr14, fr14
+	fnmsc.d fr0, fr0, fr0
+	fnmsc.d fr0, fr14, fr14
+	fnmsc.d fr14, fr0, fr14
+	fnmsc.d fr14, fr14, fr0
+	fnmsc.d fr6, fr8, fr8
+	fnmsc.d fr8, fr6, fr8
+	fnmsc.d fr8, fr8, fr6
+	.global	fmul_d
+fmul_d:
+	fmul.d fr14, fr14, fr14
+	fmul.d fr0, fr0, fr0
+	fmul.d fr0, fr14, fr14
+	fmul.d fr14, fr0, fr14
+	fmul.d fr14, fr14, fr0
+	fmul.d fr6, fr8, fr8
+	fmul.d fr8, fr6, fr8
+	fmul.d fr8, fr8, fr6
+	.global	fnmul_d
+fnmul_d:
+	fnmul.d fr14, fr14, fr14
+	fnmul.d fr0, fr0, fr0
+	fnmul.d fr0, fr14, fr14
+	fnmul.d fr14, fr0, fr14
+	fnmul.d fr14, fr14, fr0
+	fnmul.d fr6, fr8, fr8
+	fnmul.d fr8, fr6, fr8
+	fnmul.d fr8, fr8, fr6
+	.global	fneg_d
+fneg_d:
+	fneg.d fr14, fr14
+	fneg.d fr0, fr0
+	fneg.d fr0, fr14
+	fneg.d fr14, fr0
+	fneg.d fr6, fr8
+	fneg.d fr8, fr6
+	.global	fabs_d
+fabs_d:
+	fabs.d fr14, fr14
+	fabs.d fr0, fr0
+	fabs.d fr0, fr14
+	fabs.d fr14, fr0
+	fabs.d fr6, fr8
+	fabs.d fr8, fr6
+	.global	fcmp_d
+fcmp_d:
+	fcmp.d fr14, fr14
+	fcmp.d fr0, fr0
+	fcmp.d fr0, fr14
+	fcmp.d fr14, fr0
+	fcmp.d fr6, fr8
+	fcmp.d fr8, fr6
+	.global fmov_s
+fmov_s:
+	fmov.s fr15, fr15
+	fmov.s fr0, fr0
+	fmov.s fr15, fr0
+	fmov.s fr0, fr15
+	fmov.s fr8, fr7
+	fmov.s fr7, fr8
+	fmov.s pc, fr15
+	fmov.s r0, fr0
+	fmov.s pc, fr0
+	fmov.s r0, fr15
+	fmov.s r8, fr7
+	fmov.s r7, fr8
+	fmov.s fr15, pc
+	fmov.s fr0, r0
+	fmov.s fr15, r0
+	fmov.s fr0, pc
+	fmov.s fr8, r7
+	fmov.s fr7, r8
+	.global fmov_d
+fmov_d:
+	fmov.d fr14, fr14
+	fmov.d fr0, fr0
+	fmov.d fr14, fr0
+	fmov.d fr0, fr14
+	fmov.d fr8, fr6
+	fmov.d fr6, fr8
+	fmov.d lr, fr14
+	fmov.d r0, fr0
+	fmov.d lr, fr0
+	fmov.d r0, fr14
+	fmov.d r8, fr6
+	fmov.d r6, fr8
+	fmov.d fr14, lr
+	fmov.d fr0, r0
+	fmov.d fr14, r0
+	fmov.d fr0, lr
+	fmov.d fr8, r6
+	fmov.d fr6, r8
+	.global fcasts_d
+fcasts_d:
+	fcasts.d fr15, fr14
+	fcasts.d fr0, fr0
+	fcasts.d fr15, fr0
+	fcasts.d fr0, fr14
+	fcasts.d fr8, fr6
+	fcasts.d fr7, fr8
+	.global fcastd_s
+fcastd_s:
+	fcastd.s fr14, fr15
+	fcastd.s fr0, fr0
+	fcastd.s fr14, fr0
+	fcastd.s fr0, fr15
+	fcastd.s fr8, fr7
+	fcastd.s fr6, fr8
--- /dev/null
+++ b/gas/testsuite/gas/avr32/hwrd-lwrd.d
@@ -0,0 +1,47 @@
+#as:
+#objdump: -dr
+#name: hwrd-lwrd
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <test_hwrd>:
+   0:	e0 60 87 65 	mov r0,34661
+   4:	e0 60 12 34 	mov r0,4660
+   8:	e0 60 00 00 	mov r0,0
+			8: R_AVR32_HI16	\.text\+0x60
+   c:	e0 60 00 00 	mov r0,0
+			c: R_AVR32_HI16	extsym1
+  10:	ea 10 87 65 	orh r0,0x8765
+  14:	ea 10 12 34 	orh r0,0x1234
+  18:	ea 10 00 00 	orh r0,0x0
+			18: R_AVR32_HI16	\.text\+0x60
+  1c:	ea 10 00 00 	orh r0,0x0
+			1c: R_AVR32_HI16	extsym1
+  20:	e4 10 87 65 	andh r0,0x8765
+  24:	e4 10 12 34 	andh r0,0x1234
+  28:	e4 10 00 00 	andh r0,0x0
+			28: R_AVR32_HI16	\.text\+0x60
+  2c:	e4 10 00 00 	andh r0,0x0
+			2c: R_AVR32_HI16	extsym1
+
+00000030 <test_lwrd>:
+  30:	e0 60 43 21 	mov r0,17185
+  34:	e0 60 56 78 	mov r0,22136
+  38:	e0 60 00 00 	mov r0,0
+			38: R_AVR32_LO16	\.text\+0x60
+  3c:	e0 60 00 00 	mov r0,0
+			3c: R_AVR32_LO16	extsym1
+  40:	e8 10 43 21 	orl r0,0x4321
+  44:	e8 10 56 78 	orl r0,0x5678
+  48:	e8 10 00 00 	orl r0,0x0
+			48: R_AVR32_LO16	\.text\+0x60
+  4c:	e8 10 00 00 	orl r0,0x0
+			4c: R_AVR32_LO16	extsym1
+  50:	e0 10 43 21 	andl r0,0x4321
+  54:	e0 10 56 78 	andl r0,0x5678
+  58:	e0 10 00 00 	andl r0,0x0
+			58: R_AVR32_LO16	\.text\+0x60
+  5c:	e0 10 00 00 	andl r0,0x0
+			5c: R_AVR32_LO16	extsym1
--- /dev/null
+++ b/gas/testsuite/gas/avr32/hwrd-lwrd.s
@@ -0,0 +1,39 @@
+
+        .equ    sym1, 0x12345678
+
+        .text
+        .global test_hwrd
+test_hwrd:
+        mov     r0, hi(0x87654321)
+        mov     r0, hi(sym1)
+        mov     r0, hi(sym2)
+        mov     r0, hi(extsym1)
+
+        orh	r0, hi(0x87654321)
+        orh	r0, hi(sym1)
+        orh	r0, hi(sym2)
+        orh	r0, hi(extsym1)
+
+        andh	r0, hi(0x87654321)
+        andh	r0, hi(sym1)
+        andh	r0, hi(sym2)
+        andh	r0, hi(extsym1)
+
+        .global test_lwrd
+test_lwrd:
+        mov     r0, lo(0x87654321)
+        mov     r0, lo(sym1)
+        mov     r0, lo(sym2)
+        mov     r0, lo(extsym1)
+
+        orl	r0, lo(0x87654321)
+        orl	r0, lo(sym1)
+        orl	r0, lo(sym2)
+        orl	r0, lo(extsym1)
+
+        andl	r0, lo(0x87654321)
+        andl	r0, lo(sym1)
+        andl	r0, lo(sym2)
+        andl	r0, lo(extsym1)
+
+sym2:
--- /dev/null
+++ b/gas/testsuite/gas/avr32/jmptable.d
@@ -0,0 +1,20 @@
+#source: jmptable.s
+#as:
+#objdump: -dr
+#name: jmptable
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <jmptable_test>:
+   0:	fe c8 ff f4 	sub r8,pc,-12
+   4:	f0 00 00 2f 	add pc,r8,r0<<0x2
+   8:	d7 03       	nop
+   a:	00 00       	add r0,r0
+   c:	c0 38       	rjmp 12 <jmptable_test\+0x12>
+   e:	c0 38       	rjmp 14 <jmptable_test\+0x14>
+  10:	c0 38       	rjmp 16 <jmptable_test\+0x16>
+  12:	d7 03       	nop
+  14:	d7 03       	nop
+  16:	d7 03       	nop
--- /dev/null
+++ b/gas/testsuite/gas/avr32/jmptable_linkrelax.d
@@ -0,0 +1,25 @@
+#source: jmptable.s
+#as: --linkrelax
+#objdump: -dr
+#name: jmptable_linkrelax
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <jmptable_test>:
+   0:	fe c8 00 00 	sub r8,pc,0
+			0: R_AVR32_16N_PCREL	\.text\+0xc
+   4:	f0 00 00 2f 	add pc,r8,r0<<0x2
+   8:	d7 03       	nop
+   a:	00 00       	add r0,r0
+			a: R_AVR32_ALIGN	\*ABS\*\+0x2
+   c:	c0 08       	rjmp c <jmptable_test\+0xc>
+			c: R_AVR32_11H_PCREL	\.text\+0x12
+   e:	c0 08       	rjmp e <jmptable_test\+0xe>
+			e: R_AVR32_11H_PCREL	\.text\+0x14
+  10:	c0 08       	rjmp 10 <jmptable_test\+0x10>
+			10: R_AVR32_11H_PCREL	\.text\+0x16
+  12:	d7 03       	nop
+  14:	d7 03       	nop
+  16:	d7 03       	nop
--- /dev/null
+++ b/gas/testsuite/gas/avr32/jmptable.s
@@ -0,0 +1,14 @@
+
+	.text
+	.global	jmptable_test
+jmptable_test:
+	sub	r8, pc, -(.L1 - .)
+	add	pc, r8, r0 << 2
+	nop
+	.align	2
+.L1:	rjmp	1f
+	rjmp	2f
+	rjmp	3f
+1:	nop
+2:	nop
+3:	nop
--- /dev/null
+++ b/gas/testsuite/gas/avr32/lda_nopic.d
@@ -0,0 +1,32 @@
+#source: lda.s
+#as:
+#objdump: -dr
+#name: lda_nopic
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <lda_test>:
+       0:	f2 c8 00 00 	sub r8,r9,0
+
+00000004 <far_negative>:
+       4:	f6 ca 00 00 	sub r10,r11,0
+	...
+    8000:	fe c0 7f fc 	sub r0,pc,32764
+    8004:	48 31       	lddpc r1,8010 <far_negative\+0x800c>
+    8006:	48 42       	lddpc r2,8014 <far_negative\+0x8010>
+    8008:	48 43       	lddpc r3,8018 <far_negative\+0x8014>
+    800a:	48 54       	lddpc r4,801c <far_negative\+0x8018>
+    800c:	fe c5 80 04 	sub r5,pc,-32764
+	...
+			8010: R_AVR32_32_CPENT	\.text
+			8014: R_AVR32_32_CPENT	\.data
+			8018: R_AVR32_32_CPENT	undefined
+			801c: R_AVR32_32_CPENT	\.text\+0x1001c
+
+00010008 <far_positive>:
+   10008:	fa cc 00 00 	sub r12,sp,0
+	...
+0001001c <toofar_positive>:
+   1001c:	fe ce 00 00 	sub lr,pc,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/lda_nopic_linkrelax.d
@@ -0,0 +1,41 @@
+#source: lda.s
+#as: --linkrelax
+#objdump: -dr
+#name: lda_nopic_linkrelax
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <lda_test>:
+       0:	f2 c8 00 00 	sub r8,r9,0
+
+00000004 <far_negative>:
+       4:	f6 ca 00 00 	sub r10,r11,0
+	\.\.\.
+    8000:	48 00       	lddpc r0,8000 <far_negative\+0x7ffc>
+			8000: R_AVR32_9W_CP	\.text\+0x800c
+    8002:	48 01       	lddpc r1,8000 <far_negative\+0x7ffc>
+			8002: R_AVR32_9W_CP	\.text\+0x8010
+    8004:	48 02       	lddpc r2,8004 <far_negative\+0x8000>
+			8004: R_AVR32_9W_CP	\.text\+0x8014
+    8006:	48 03       	lddpc r3,8004 <far_negative\+0x8000>
+			8006: R_AVR32_9W_CP	\.text\+0x8018
+    8008:	48 04       	lddpc r4,8008 <far_negative\+0x8004>
+			8008: R_AVR32_9W_CP	\.text\+0x801c
+    800a:	48 05       	lddpc r5,8008 <far_negative\+0x8004>
+			800a: R_AVR32_9W_CP	\.text\+0x8020
+	\.\.\.
+			800c: R_AVR32_ALIGN	\*ABS\*\+0x2
+			800c: R_AVR32_32_CPENT	\.text\+0x4
+			8010: R_AVR32_32_CPENT	\.text
+			8014: R_AVR32_32_CPENT	\.data
+			8018: R_AVR32_32_CPENT	undefined
+			801c: R_AVR32_32_CPENT	\.text\+0x10020
+			8020: R_AVR32_32_CPENT	\.text\+0x1000c
+
+0001000c <far_positive>:
+   1000c:	fa cc 00 00 	sub r12,sp,0
+	\.\.\.
+00010020 <toofar_positive>:
+   10020:	fe ce 00 00 	sub lr,pc,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/lda_pic.d
@@ -0,0 +1,32 @@
+#source: lda.s
+#as: --pic
+#objdump: -dr
+#name: lda_pic
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <lda_test>:
+       0:	f2 c8 00 00 	sub r8,r9,0
+
+00000004 <far_negative>:
+       4:	f6 ca 00 00 	sub r10,r11,0
+	...
+    8000:	fe c0 7f fc 	sub r0,pc,32764
+    8004:	ec f1 00 00 	ld.w r1,r6\[0\]
+			8004: R_AVR32_GOT16S	toofar_negative
+    8008:	ec f2 00 00 	ld.w r2,r6\[0\]
+			8008: R_AVR32_GOT16S	different_section
+    800c:	ec f3 00 00 	ld.w r3,r6\[0\]
+			800c: R_AVR32_GOT16S	undefined
+    8010:	ec f4 00 00 	ld.w r4,r6\[0\]
+			8010: R_AVR32_GOT16S	toofar_positive
+    8014:	fe c5 80 14 	sub r5,pc,-32748
+	...
+
+00010000 <far_positive>:
+   10000:	fa cc 00 00 	sub r12,sp,0
+	...
+00010014 <toofar_positive>:
+   10014:	fe ce 00 00 	sub lr,pc,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/lda_pic_linkrelax.d
@@ -0,0 +1,40 @@
+#source: lda.s
+#as: --pic --linkrelax
+#objdump: -dr
+#name: lda_pic_linkrelax
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <lda_test>:
+       0:	f2 c8 00 00 	sub r8,r9,0
+
+00000004 <far_negative>:
+       4:	f6 ca 00 00 	sub r10,r11,0
+	...
+    8000:	e0 60 00 00 	mov r0,0
+			8000: R_AVR32_LDA_GOT	far_negative
+    8004:	ec 00 03 20 	ld\.w r0,r6\[r0<<0x2\]
+    8008:	e0 61 00 00 	mov r1,0
+			8008: R_AVR32_LDA_GOT	toofar_negative
+    800c:	ec 01 03 21 	ld\.w r1,r6\[r1<<0x2\]
+    8010:	e0 62 00 00 	mov r2,0
+			8010: R_AVR32_LDA_GOT	different_section
+    8014:	ec 02 03 22 	ld\.w r2,r6\[r2<<0x2\]
+    8018:	e0 63 00 00 	mov r3,0
+			8018: R_AVR32_LDA_GOT	undefined
+    801c:	ec 03 03 23 	ld\.w r3,r6\[r3<<0x2\]
+    8020:	e0 64 00 00 	mov r4,0
+			8020: R_AVR32_LDA_GOT	toofar_positive
+    8024:	ec 04 03 24 	ld\.w r4,r6\[r4<<0x2\]
+    8028:	e0 65 00 00 	mov r5,0
+			8028: R_AVR32_LDA_GOT	far_positive
+    802c:	ec 05 03 25 	ld\.w r5,r6\[r5<<0x2\]
+	...
+
+00010018 <far_positive>:
+   10018:	fa cc 00 00 	sub r12,sp,0
+	...
+0001002c <toofar_positive>:
+   1002c:	fe ce 00 00 	sub lr,pc,0
--- /dev/null
+++ b/gas/testsuite/gas/avr32/lda.s
@@ -0,0 +1,30 @@
+
+	.text
+	.global lda_test
+lda_test:
+toofar_negative:
+	sub	r8, r9, 0
+far_negative:
+	sub	r10, r11, 0
+
+	.fill	32760, 1, 0x00
+
+	lda.w	r0, far_negative
+	lda.w	r1, toofar_negative
+	lda.w	r2, different_section
+	lda.w	r3, undefined
+	lda.w	r4, toofar_positive
+	lda.w	r5, far_positive
+
+	.cpool
+
+	.fill	32744, 1, 0x00
+far_positive:
+	sub	r12, sp, 0
+	.fill	16, 1, 0x00
+toofar_positive:
+	sub	lr, pc, 0
+
+	.data
+different_section:
+	.long	0x12345678
--- /dev/null
+++ b/gas/testsuite/gas/avr32/pcrel.d
@@ -0,0 +1,64 @@
+#as:
+#objdump: -dr
+#name: pcrel
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <test_rjmp>:
+   0:	d7 03       	nop
+   2:	c0 28       	rjmp 6 <test_rjmp\+0x6>
+   4:	d7 03       	nop
+   6:	e0 8f 00 00 	bral 6 <test_rjmp\+0x6>
+			6: R_AVR32_22H_PCREL	extsym10
+
+0000000a <test_rcall>:
+   a:	d7 03       	nop
+0000000c <test_rcall2>:
+   c:	c0 2c       	rcall 10 <test_rcall2\+0x4>
+   e:	d7 03       	nop
+  10:	e0 a0 00 00 	rcall 10 <test_rcall2\+0x4>
+			10: R_AVR32_22H_PCREL	extsym21
+
+00000014 <test_branch>:
+  14:	c0 31       	brne 1a <test_branch\+0x6>
+  16:	e0 8f 00 00 	bral 16 <test_branch\+0x2>
+			16: R_AVR32_22H_PCREL	test_branch
+  1a:	e0 80 00 00 	breq 1a <test_branch\+0x6>
+			1a: R_AVR32_22H_PCREL	extsym21
+
+0000001e <test_lddpc>:
+  1e:	48 30       	lddpc r0,28 <sym1>
+  20:	48 20       	lddpc r0,28 <sym1>
+  22:	fe f0 00 00 	ld.w r0,pc\[0\]
+			22: R_AVR32_16B_PCREL	extsym16
+	\.\.\.
+
+00000028 <sym1>:
+  28:	d7 03       	nop
+  2a:	d7 03       	nop
+
+0000002c <test_local>:
+  2c:	48 20       	lddpc r0,34 <test_local\+0x8>
+  2e:	48 30       	lddpc r0,38 <test_local\+0xc>
+  30:	48 20       	lddpc r0,38 <test_local\+0xc>
+  32:	00 00       	add r0,r0
+  34:	d7 03       	nop
+  36:	d7 03       	nop
+  38:	d7 03       	nop
+  3a:	d7 03       	nop
+
+Disassembly of section \.text\.init:
+
+00000000 <test_inter_section>:
+   0:	e0 a0 .. .. 	rcall [0-9a-f]+ <.*>
+			0: R_AVR32_22H_PCREL	test_rcall
+   4:	d7 03       	nop
+   6:	e0 a0 .. .. 	rcall [0-9a-f]+ <.*>
+			6: R_AVR32_22H_PCREL	test_rcall
+   a:	e0 a0 .. .. 	rcall [0-9a-z]+ <.*>
+			a: R_AVR32_22H_PCREL	\.text\+0xc
+   e:	d7 03       	nop
+  10:	e0 a0 .. .. 	rcall [0-9a-f]+ <.*>
+			10: R_AVR32_22H_PCREL	\.text\+0xc
--- /dev/null
+++ b/gas/testsuite/gas/avr32/pcrel.s
@@ -0,0 +1,57 @@
+
+        .text
+        .global test_rjmp
+test_rjmp:
+        nop
+        rjmp    0f
+        nop
+0:      rjmp    extsym10
+
+        .global test_rcall
+test_rcall:
+        nop
+test_rcall2:
+        rcall   0f
+        nop
+0:      rcall   extsym21
+
+        .global test_branch
+test_branch:
+        brne    0f
+	/* This will generate a reloc since test_branch is global */
+        bral    test_branch
+0:	breq    extsym21
+
+        .global test_lddpc
+test_lddpc:
+        lddpc   r0,sym1
+        lddpc   r0,sym1
+        lddpc   r0,extsym16
+
+        .align	2
+sym1:   nop
+        nop
+
+	.global	test_local
+test_local:
+	lddpc	r0, .LC1
+	lddpc	r0, .LC2
+	lddpc	r0, .LC1 + 0x4
+
+	.align	2
+.LC1:
+	nop
+	nop
+.LC2:
+	nop
+	nop
+
+	.section .text.init,"ax"
+	.global test_inter_section
+test_inter_section:
+	rcall	test_rcall
+	nop
+	rcall	test_rcall
+	rcall	test_rcall2
+	nop
+	rcall	test_rcall2
--- /dev/null
+++ b/gas/testsuite/gas/avr32/pico.d
@@ -0,0 +1,149 @@
+#as:
+#objdump: -dr
+#name: pico
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+[0-9a-f]* <picosvmac>:
+ *[0-9a-f]*:	e1 a6 20 00 	cop cp1,cr0,cr0,cr0,0xc
+ *[0-9a-f]*:	e1 a7 2b bb 	cop cp1,cr11,cr11,cr11,0xe
+ *[0-9a-f]*:	e1 a6 3a 05 	cop cp1,cr10,cr0,cr5,0xd
+ *[0-9a-f]*:	e1 a7 36 90 	cop cp1,cr6,cr9,cr0,0xf
+
+[0-9a-f]* <picosvmul>:
+ *[0-9a-f]*:	e1 a4 20 00 	cop cp1,cr0,cr0,cr0,0x8
+ *[0-9a-f]*:	e1 a5 2b bb 	cop cp1,cr11,cr11,cr11,0xa
+ *[0-9a-f]*:	e1 a4 3a 05 	cop cp1,cr10,cr0,cr5,0x9
+ *[0-9a-f]*:	e1 a5 36 90 	cop cp1,cr6,cr9,cr0,0xb
+
+[0-9a-f]* <picovmac>:
+ *[0-9a-f]*:	e1 a2 20 00 	cop cp1,cr0,cr0,cr0,0x4
+ *[0-9a-f]*:	e1 a3 2b bb 	cop cp1,cr11,cr11,cr11,0x6
+ *[0-9a-f]*:	e1 a2 3a 05 	cop cp1,cr10,cr0,cr5,0x5
+ *[0-9a-f]*:	e1 a3 36 90 	cop cp1,cr6,cr9,cr0,0x7
+
+[0-9a-f]* <picovmul>:
+ *[0-9a-f]*:	e1 a0 20 00 	cop cp1,cr0,cr0,cr0,0x0
+ *[0-9a-f]*:	e1 a1 2b bb 	cop cp1,cr11,cr11,cr11,0x2
+ *[0-9a-f]*:	e1 a0 3a 05 	cop cp1,cr10,cr0,cr5,0x1
+ *[0-9a-f]*:	e1 a1 36 90 	cop cp1,cr6,cr9,cr0,0x3
+
+[0-9a-f]* <picold_d>:
+ *[0-9a-f]*:	e9 af 3e ff 	ldc\.d cp1,cr14,pc\[0x3fc\]
+ *[0-9a-f]*:	e9 a0 30 ff 	ldc\.d cp1,cr0,r0\[0x3fc\]
+ *[0-9a-f]*:	e9 a0 30 00 	ldc\.d cp1,cr0,r0\[0x0\]
+ *[0-9a-f]*:	ef a8 26 50 	ldc\.d cp1,cr6,--r8
+ *[0-9a-f]*:	ef a7 28 50 	ldc\.d cp1,cr8,--r7
+ *[0-9a-f]*:	ef aa 32 65 	ldc\.d cp1,cr2,r10\[r5<<0x2\]
+ *[0-9a-f]*:	ef a3 3c 46 	ldc\.d cp1,cr12,r3\[r6\]
+
+[0-9a-f]* <picold_w>:
+ *[0-9a-f]*:	e9 af 2f ff 	ldc\.w cp1,cr15,pc\[0x3fc\]
+ *[0-9a-f]*:	e9 a0 20 ff 	ldc\.w cp1,cr0,r0\[0x3fc\]
+ *[0-9a-f]*:	e9 a0 20 00 	ldc\.w cp1,cr0,r0\[0x0\]
+ *[0-9a-f]*:	ef a8 27 40 	ldc\.w cp1,cr7,--r8
+ *[0-9a-f]*:	ef a7 28 40 	ldc\.w cp1,cr8,--r7
+ *[0-9a-f]*:	ef aa 31 25 	ldc\.w cp1,cr1,r10\[r5<<0x2\]
+ *[0-9a-f]*:	ef a3 3d 06 	ldc\.w cp1,cr13,r3\[r6\]
+
+[0-9a-f]* <picoldm_d>:
+ *[0-9a-f]*:	ed af 24 ff 	ldcm\.d cp1,pc,cr0-cr15
+ *[0-9a-f]*:	ed a0 24 01 	ldcm\.d cp1,r0,cr0-cr1
+ *[0-9a-f]*:	ed a7 24 80 	ldcm\.d cp1,r7,cr14-cr15
+ *[0-9a-f]*:	ed a8 24 7f 	ldcm\.d cp1,r8,cr0-cr13
+
+[0-9a-f]* <picoldm_d_pu>:
+ *[0-9a-f]*:	ed af 34 ff 	ldcm\.d cp1,pc\+\+,cr0-cr15
+ *[0-9a-f]*:	ed a0 34 01 	ldcm\.d cp1,r0\+\+,cr0-cr1
+ *[0-9a-f]*:	ed a7 34 80 	ldcm\.d cp1,r7\+\+,cr14-cr15
+ *[0-9a-f]*:	ed a8 34 7f 	ldcm\.d cp1,r8\+\+,cr0-cr13
+
+[0-9a-f]* <picoldm_w>:
+ *[0-9a-f]*:	ed af 20 ff 	ldcm\.w cp1,pc,cr0-cr7
+ *[0-9a-f]*:	ed a0 20 01 	ldcm\.w cp1,r0,cr0
+ *[0-9a-f]*:	ed a7 20 80 	ldcm\.w cp1,r7,cr7
+ *[0-9a-f]*:	ed a8 20 7f 	ldcm\.w cp1,r8,cr0-cr6
+ *[0-9a-f]*:	ed af 21 ff 	ldcm\.w cp1,pc,cr8-cr15
+ *[0-9a-f]*:	ed a0 21 01 	ldcm\.w cp1,r0,cr8
+ *[0-9a-f]*:	ed a7 21 80 	ldcm\.w cp1,r7,cr15
+ *[0-9a-f]*:	ed a8 21 7f 	ldcm\.w cp1,r8,cr8-cr14
+
+[0-9a-f]* <picoldm_w_pu>:
+ *[0-9a-f]*:	ed af 30 ff 	ldcm\.w cp1,pc\+\+,cr0-cr7
+ *[0-9a-f]*:	ed a0 30 01 	ldcm\.w cp1,r0\+\+,cr0
+ *[0-9a-f]*:	ed a7 30 80 	ldcm\.w cp1,r7\+\+,cr7
+ *[0-9a-f]*:	ed a8 30 7f 	ldcm\.w cp1,r8\+\+,cr0-cr6
+ *[0-9a-f]*:	ed af 31 ff 	ldcm\.w cp1,pc\+\+,cr8-cr15
+ *[0-9a-f]*:	ed a0 31 01 	ldcm\.w cp1,r0\+\+,cr8
+ *[0-9a-f]*:	ed a7 31 80 	ldcm\.w cp1,r7\+\+,cr15
+ *[0-9a-f]*:	ed a8 31 7f 	ldcm\.w cp1,r8\+\+,cr8-cr14
+
+[0-9a-f]* <picomv_d>:
+ *[0-9a-f]*:	ef ae 2e 30 	mvrc\.d cp1,cr14,lr
+ *[0-9a-f]*:	ef a0 20 30 	mvrc\.d cp1,cr0,r0
+ *[0-9a-f]*:	ef a8 26 30 	mvrc\.d cp1,cr6,r8
+ *[0-9a-f]*:	ef a6 28 30 	mvrc\.d cp1,cr8,r6
+ *[0-9a-f]*:	ef ae 2e 10 	mvcr\.d cp1,lr,cr14
+ *[0-9a-f]*:	ef a0 20 10 	mvcr\.d cp1,r0,cr0
+ *[0-9a-f]*:	ef a8 26 10 	mvcr\.d cp1,r8,cr6
+ *[0-9a-f]*:	ef a6 28 10 	mvcr\.d cp1,r6,cr8
+
+[0-9a-f]* <picomv_w>:
+ *[0-9a-f]*:	ef af 2f 20 	mvrc\.w cp1,cr15,pc
+ *[0-9a-f]*:	ef a0 20 20 	mvrc\.w cp1,cr0,r0
+ *[0-9a-f]*:	ef a8 27 20 	mvrc\.w cp1,cr7,r8
+ *[0-9a-f]*:	ef a7 28 20 	mvrc\.w cp1,cr8,r7
+ *[0-9a-f]*:	ef af 2f 00 	mvcr\.w cp1,pc,cr15
+ *[0-9a-f]*:	ef a0 20 00 	mvcr\.w cp1,r0,cr0
+ *[0-9a-f]*:	ef a8 27 00 	mvcr\.w cp1,r8,cr7
+ *[0-9a-f]*:	ef a7 28 00 	mvcr\.w cp1,r7,cr8
+
+[0-9a-f]* <picost_d>:
+ *[0-9a-f]*:	eb af 3e ff 	stc\.d cp1,pc\[0x3fc\],cr14
+ *[0-9a-f]*:	eb a0 30 00 	stc\.d cp1,r0\[0x0\],cr0
+ *[0-9a-f]*:	ef a8 26 70 	stc\.d cp1,r8\+\+,cr6
+ *[0-9a-f]*:	ef a7 28 70 	stc\.d cp1,r7\+\+,cr8
+ *[0-9a-f]*:	ef aa 32 e5 	stc\.d cp1,r10\[r5<<0x2\],cr2
+ *[0-9a-f]*:	ef a3 3c c6 	stc\.d cp1,r3\[r6\],cr12
+
+[0-9a-f]* <picost_w>:
+ *[0-9a-f]*:	eb af 2f ff 	stc\.w cp1,pc\[0x3fc\],cr15
+ *[0-9a-f]*:	eb a0 20 00 	stc\.w cp1,r0\[0x0\],cr0
+ *[0-9a-f]*:	ef a8 27 60 	stc\.w cp1,r8\+\+,cr7
+ *[0-9a-f]*:	ef a7 28 60 	stc\.w cp1,r7\+\+,cr8
+ *[0-9a-f]*:	ef aa 31 a5 	stc\.w cp1,r10\[r5<<0x2\],cr1
+ *[0-9a-f]*:	ef a3 3d 86 	stc\.w cp1,r3\[r6\],cr13
+
+[0-9a-f]* <picostm_d>:
+ *[0-9a-f]*:	ed af 25 ff 	stcm\.d cp1,pc,cr0-cr15
+ *[0-9a-f]*:	ed a0 25 01 	stcm\.d cp1,r0,cr0-cr1
+ *[0-9a-f]*:	ed a7 25 80 	stcm\.d cp1,r7,cr14-cr15
+ *[0-9a-f]*:	ed a8 25 7f 	stcm\.d cp1,r8,cr0-cr13
+
+[0-9a-f]* <picostm_d_pu>:
+ *[0-9a-f]*:	ed af 35 ff 	stcm\.d cp1,--pc,cr0-cr15
+ *[0-9a-f]*:	ed a0 35 01 	stcm\.d cp1,--r0,cr0-cr1
+ *[0-9a-f]*:	ed a7 35 80 	stcm\.d cp1,--r7,cr14-cr15
+ *[0-9a-f]*:	ed a8 35 7f 	stcm\.d cp1,--r8,cr0-cr13
+
+[0-9a-f]* <picostm_w>:
+ *[0-9a-f]*:	ed af 22 ff 	stcm\.w cp1,pc,cr0-cr7
+ *[0-9a-f]*:	ed a0 22 01 	stcm\.w cp1,r0,cr0
+ *[0-9a-f]*:	ed a7 22 80 	stcm\.w cp1,r7,cr7
+ *[0-9a-f]*:	ed a8 22 7f 	stcm\.w cp1,r8,cr0-cr6
+ *[0-9a-f]*:	ed af 23 ff 	stcm\.w cp1,pc,cr8-cr15
+ *[0-9a-f]*:	ed a0 23 01 	stcm\.w cp1,r0,cr8
+ *[0-9a-f]*:	ed a7 23 80 	stcm\.w cp1,r7,cr15
+ *[0-9a-f]*:	ed a8 23 7f 	stcm\.w cp1,r8,cr8-cr14
+
+[0-9a-f]* <picostm_w_pu>:
+ *[0-9a-f]*:	ed af 32 ff 	stcm\.w cp1,--pc,cr0-cr7
+ *[0-9a-f]*:	ed a0 32 01 	stcm\.w cp1,--r0,cr0
+ *[0-9a-f]*:	ed a7 32 80 	stcm\.w cp1,--r7,cr7
+ *[0-9a-f]*:	ed a8 32 7f 	stcm\.w cp1,--r8,cr0-cr6
+ *[0-9a-f]*:	ed af 33 ff 	stcm\.w cp1,--pc,cr8-cr15
+ *[0-9a-f]*:	ed a0 33 01 	stcm\.w cp1,--r0,cr8
+ *[0-9a-f]*:	ed a7 33 80 	stcm\.w cp1,--r7,cr15
+ *[0-9a-f]*:	ed a8 33 7f 	stcm\.w cp1,--r8,cr8-cr14
--- /dev/null
+++ b/gas/testsuite/gas/avr32/pico.s
@@ -0,0 +1,144 @@
+
+	.text
+	.global	picosvmac
+picosvmac:
+	picosvmac	out0, in0, in0, in0
+	picosvmac	out2, in11, in11, in11
+	picosvmac	out1, in10, in0, in5
+	picosvmac	out3, in6, in9, in0
+	.global picosvmul
+picosvmul:
+	picosvmul	out0, in0, in0, in0
+	picosvmul	out2, in11, in11, in11
+	picosvmul	out1, in10, in0, in5
+	picosvmul	out3, in6, in9, in0
+	.global picovmac
+picovmac:
+	picovmac	out0, in0, in0, in0
+	picovmac	out2, in11, in11, in11
+	picovmac	out1, in10, in0, in5
+	picovmac	out3, in6, in9, in0
+	.global picovmul
+picovmul:
+	picovmul	out0, in0, in0, in0
+	picovmul	out2, in11, in11, in11
+	picovmul	out1, in10, in0, in5
+	picovmul	out3, in6, in9, in0
+	.global	picold_d
+picold_d:
+	picold.d	vmu2_out, pc[1020]
+	picold.d	inpix2, r0[1020]
+	picold.d	inpix2, r0[0]
+	picold.d	coeff0_a, --r8
+	picold.d	coeff1_a, --r7
+	picold.d	inpix0, r10[r5 << 2]
+	picold.d	vmu0_out, r3[r6 << 0]
+	.global	picold_w
+picold_w:	
+	picold.w	config, pc[1020]
+	picold.w	inpix2, r0[1020]
+	picold.w	inpix2, r0[0]
+	picold.w	coeff0_b, --r8
+	picold.w	coeff1_a, --r7
+	picold.w	inpix1, r10[r5 << 2]
+	picold.w	vmu1_out, r3[r6 << 0]
+	.global	picoldm_d
+picoldm_d:
+	picoldm.d	pc, inpix2-config
+	picoldm.d	r0, inpix2, inpix1
+	picoldm.d	r7, vmu2_out, config
+	picoldm.d	r8, inpix2-vmu1_out
+	.global	picoldm_d_pu
+picoldm_d_pu:
+	picoldm.d	pc++, inpix2, inpix1, inpix0, outpix2, outpix1, outpix0, coeff0_a, coeff0_b, coeff1_a, coeff1_b, coeff2_a, coeff2_b, vmu0_out, vmu1_out, vmu2_out, config
+	picoldm.d	r0++, inpix2, inpix1
+	picoldm.d	r7++, vmu2_out, config
+	picoldm.d	r8++, inpix2, inpix1, inpix0, outpix2, outpix1, outpix0, coeff0_a, coeff0_b, coeff1_a, coeff1_b, coeff2_a, coeff2_b, vmu0_out, vmu1_out
+	.global	picoldm_w
+picoldm_w:
+	picoldm.w	pc, inpix2-coeff0_b
+	picoldm.w	r0, inpix2
+	picoldm.w	r7, coeff0_b
+	picoldm.w	r8, inpix2-coeff0_a
+	picoldm.w	pc, coeff1_a-config
+	picoldm.w	r0, coeff1_a
+	picoldm.w	r7, config
+	picoldm.w	r8, coeff1_a-vmu2_out
+	.global	picoldm_w_pu
+picoldm_w_pu:
+	picoldm.w	pc++, inpix2-coeff0_b
+	picoldm.w	r0++, inpix2
+	picoldm.w	r7++, coeff0_b
+	picoldm.w	r8++, inpix2-coeff0_a
+	picoldm.w	pc++, coeff1_a-config
+	picoldm.w	r0++, coeff1_a
+	picoldm.w	r7++, config
+	picoldm.w	r8++, coeff1_a-vmu2_out
+	.global	picomv_d
+picomv_d:
+	picomv.d	vmu2_out, lr
+	picomv.d	inpix2, r0
+	picomv.d	coeff0_a, r8
+	picomv.d	coeff1_a, r6
+	picomv.d	pc, vmu2_out
+	picomv.d	r0, inpix2
+	picomv.d	r8, coeff0_a
+	picomv.d	r6, coeff1_a
+	.global	picomv_w
+picomv_w:
+	picomv.w	config, pc
+	picomv.w	inpix2, r0
+	picomv.w	coeff0_b, r8
+	picomv.w	coeff1_a, r7
+	picomv.w	pc, config
+	picomv.w	r0, inpix2
+	picomv.w	r8, coeff0_b
+	picomv.w	r7, coeff1_a
+	.global	picost_d
+picost_d:
+	picost.d	pc[1020], vmu2_out
+	picost.d	r0[0], inpix2
+	picost.d	r8++, coeff0_a
+	picost.d	r7++, coeff1_a
+	picost.d	r10[r5 << 2], inpix0
+	picost.d	r3[r6 << 0], vmu0_out
+	.global	picost_w
+picost_w:	
+	picost.w	pc[1020], config
+	picost.w	r0[0], inpix2
+	picost.w	r8++, coeff0_b
+	picost.w	r7++, coeff1_a
+	picost.w	r10[r5 << 2], inpix1
+	picost.w	r3[r6 << 0], vmu1_out
+	.global	picostm_d
+picostm_d:
+	picostm.d	pc, inpix2-config
+	picostm.d	r0, inpix2, inpix1
+	picostm.d	r7, vmu2_out, config
+	picostm.d	r8, inpix2-vmu1_out
+	.global	picostm_d_pu
+picostm_d_pu:
+	picostm.d	--pc, inpix2, inpix1, inpix0, outpix2, outpix1, outpix0, coeff0_a, coeff0_b, coeff1_a, coeff1_b, coeff2_a, coeff2_b, vmu0_out, vmu1_out, vmu2_out, config
+	picostm.d	--r0, inpix2, inpix1
+	picostm.d	--r7, vmu2_out, config
+	picostm.d	--r8, inpix2, inpix1, inpix0, outpix2, outpix1, outpix0, coeff0_a, coeff0_b, coeff1_a, coeff1_b, coeff2_a, coeff2_b, vmu0_out, vmu1_out
+	.global	picostm_w
+picostm_w:
+	picostm.w	pc, inpix2-coeff0_b
+	picostm.w	r0, inpix2
+	picostm.w	r7, coeff0_b
+	picostm.w	r8, inpix2-coeff0_a
+	picostm.w	pc, coeff1_a-config
+	picostm.w	r0, coeff1_a
+	picostm.w	r7, config
+	picostm.w	r8, coeff1_a-vmu2_out
+	.global	picostm_w_pu
+picostm_w_pu:
+	picostm.w	--pc, inpix2-coeff0_b
+	picostm.w	--r0, inpix2
+	picostm.w	--r7, coeff0_b
+	picostm.w	--r8, inpix2-coeff0_a
+	picostm.w	--pc, coeff1_a-config
+	picostm.w	--r0, coeff1_a
+	picostm.w	--r7, config
+	picostm.w	--r8, coeff1_a-vmu2_out
--- /dev/null
+++ b/gas/testsuite/gas/avr32/pic_reloc.d
@@ -0,0 +1,27 @@
+#as:
+#objdump: -dr
+#name: pic_reloc
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <mcall_got>:
+   0:	f0 16 00 00 	mcall r6\[0\]
+			0: R_AVR32_GOT18SW	extfunc
+   4:	f0 16 00 00 	mcall r6\[0\]
+			4: R_AVR32_GOT18SW	\.L1
+   8:	f0 16 00 00 	mcall r6\[0\]
+			8: R_AVR32_GOT18SW	\.L2
+   c:	f0 16 00 00 	mcall r6\[0\]
+			c: R_AVR32_GOT18SW	mcall_got
+
+00000010 <ldw_got>:
+  10:	ec f0 00 00 	ld.w r0,r6\[0\]
+			10: R_AVR32_GOT16S	extvar
+  14:	ec f0 00 00 	ld.w r0,r6\[0\]
+			14: R_AVR32_GOT16S	\.L3
+  18:	ec f0 00 00 	ld.w r0,r6\[0\]
+			18: R_AVR32_GOT16S	\.L4
+  1c:	ec f0 00 00 	ld.w r0,r6\[0\]
+			1c: R_AVR32_GOT16S	ldw_got
--- /dev/null
+++ b/gas/testsuite/gas/avr32/pic_reloc.s
@@ -0,0 +1,18 @@
+
+	.text
+	.global	mcall_got
+mcall_got:
+.L1:
+	mcall	r6[extfunc@got]
+	mcall	r6[.L1@got]
+	mcall	r6[.L2@got]
+	mcall	r6[mcall_got@got]
+.L2:
+
+	.global	ldw_got
+ldw_got:
+.L3:	ld.w	r0,r6[extvar@got]
+	ld.w	r0,r6[.L3@got]
+	ld.w	r0,r6[.L4@got]
+	ld.w	r0,r6[ldw_got@got]
+.L4:
--- /dev/null
+++ b/gas/testsuite/gas/avr32/symdiff.d
@@ -0,0 +1,24 @@
+#source: symdiff.s
+#as:
+#objdump: -dr
+#name: symdiff
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <diff32>:
+   0:	00 00       	add r0,r0
+   2:	00 04       	add r4,r0
+
+00000004 <diff16>:
+   4:	00 04       	add r4,r0
+
+00000006 <diff8>:
+   6:	04 00       	add r0,r2
+
+00000008 <symdiff_test>:
+   8:	d7 03       	nop
+   a:	d7 03       	nop
+   c:	d7 03       	nop
+   e:	d7 03       	nop
--- /dev/null
+++ b/gas/testsuite/gas/avr32/symdiff_linkrelax.d
@@ -0,0 +1,28 @@
+#source: symdiff.s
+#as: --linkrelax
+#objdump: -dr
+#name: symdiff_linkrelax
+
+.*: +file format .*
+
+Disassembly of section \.text:
+
+00000000 <diff32>:
+   0:	00 00       	add r0,r0
+			0: R_AVR32_DIFF32	\.text\+0xa
+   2:	00 04       	add r4,r0
+
+00000004 <diff16>:
+   4:	00 04       	add r4,r0
+			4: R_AVR32_DIFF16	\.text\+0xa
+
+00000006 <diff8>:
+   6:	04 00       	add r0,r2
+			6: R_AVR32_DIFF8	\.text\+0xa
+			7: R_AVR32_ALIGN	\*ABS\*\+0x1
+
+00000008 <symdiff_test>:
+   8:	d7 03       	nop
+   a:	d7 03       	nop
+   c:	d7 03       	nop
+   e:	d7 03       	nop
--- /dev/null
+++ b/gas/testsuite/gas/avr32/symdiff.s
@@ -0,0 +1,19 @@
+
+	.text
+	.global	diff32
+diff32:
+	.long	.L2 - .L1
+	.global	diff16
+diff16:
+	.short	.L2 - .L1
+	.global	diff8
+diff8:
+	.byte	.L2 - .L1
+
+	.global	symdiff_test
+	.align	1
+symdiff_test:
+	nop
+.L1:	nop
+	nop
+.L2:	nop
--- a/gas/write.c
+++ b/gas/write.c
@@ -1955,6 +1955,10 @@ relax_frag (segT segment, fragS *fragP, 
 
 #endif /* defined (TC_GENERIC_RELAX_TABLE)  */
 
+#ifdef TC_RELAX_ALIGN
+#define RELAX_ALIGN(SEG, FRAG, ADDR) TC_RELAX_ALIGN(SEG, FRAG, ADDR)
+#else
+#define RELAX_ALIGN(SEG, FRAG, ADDR) relax_align(ADDR, (FRAG)->fr_offset)
 /* Relax_align. Advance location counter to next address that has 'alignment'
    lowest order bits all 0s, return size of adjustment made.  */
 static relax_addressT
@@ -1974,6 +1978,7 @@ relax_align (register relax_addressT add
 #endif
   return (new_address - address);
 }
+#endif
 
 /* Now we have a segment, not a crowd of sub-segments, we can make
    fr_address values.
@@ -2017,7 +2022,7 @@ relax_segment (struct frag *segment_frag
 	case rs_align_code:
 	case rs_align_test:
 	  {
-	    addressT offset = relax_align (address, (int) fragP->fr_offset);
+	    addressT offset = RELAX_ALIGN(segment, fragP, address);
 
 	    if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
 	      offset = 0;
@@ -2218,10 +2223,10 @@ relax_segment (struct frag *segment_frag
 		{
 		  addressT oldoff, newoff;
 
-		  oldoff = relax_align (was_address + fragP->fr_fix,
-					(int) offset);
-		  newoff = relax_align (address + fragP->fr_fix,
-					(int) offset);
+		  oldoff = RELAX_ALIGN (segment, fragP,
+					was_address + fragP->fr_fix);
+		  newoff = RELAX_ALIGN (segment, fragP,
+					address + fragP->fr_fix);
 
 		  if (fragP->fr_subtype != 0)
 		    {
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -204,13 +204,14 @@ typedef struct disassemble_info
 
 } disassemble_info;
 
-
+
 /* Standard disassemblers.  Disassemble one instruction at the given
    target address.  Return number of octets processed.  */
 typedef int (*disassembler_ftype) (bfd_vma, disassemble_info *);
 
 extern int print_insn_alpha		(bfd_vma, disassemble_info *);
 extern int print_insn_avr		(bfd_vma, disassemble_info *);
+extern int print_insn_avr32		(bfd_vma, disassemble_info *);
 extern int print_insn_bfin		(bfd_vma, disassemble_info *);
 extern int print_insn_big_arm		(bfd_vma, disassemble_info *);
 extern int print_insn_big_mips		(bfd_vma, disassemble_info *);
@@ -290,7 +291,9 @@ extern void print_i386_disassembler_opti
 extern void print_mips_disassembler_options (FILE *);
 extern void print_ppc_disassembler_options (FILE *);
 extern void print_arm_disassembler_options (FILE *);
+extern void print_avr32_disassembler_options (FILE *);
 extern void parse_arm_disassembler_option (char *);
+extern void parse_avr32_disassembler_option (char *);
 extern int  get_arm_regname_num_options (void);
 extern int  set_arm_regname_option (int);
 extern int  get_arm_regnames (int, const char **, const char **, const char *const **);
@@ -306,7 +309,7 @@ extern void disassemble_init_for_target 
 /* Document any target specific options available from the disassembler.  */
 extern void disassembler_usage (FILE *);
 
-
+
 /* This block of definitions is for particular callers who read instructions
    into a buffer before calling the instruction decoder.  */
 
--- /dev/null
+++ b/include/elf/avr32.h
@@ -0,0 +1,98 @@
+/* AVR32 ELF support for BFD.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "elf/reloc-macros.h"
+
+/* CPU-specific flags for the ELF header e_flags field */
+#define EF_AVR32_LINKRELAX		0x01
+#define EF_AVR32_PIC			0x02
+
+START_RELOC_NUMBERS (elf_avr32_reloc_type)
+    RELOC_NUMBER (R_AVR32_NONE,			0)
+
+    /* Data Relocations */
+    RELOC_NUMBER (R_AVR32_32,			1)
+    RELOC_NUMBER (R_AVR32_16,			2)
+    RELOC_NUMBER (R_AVR32_8,			3)
+    RELOC_NUMBER (R_AVR32_32_PCREL,		4)
+    RELOC_NUMBER (R_AVR32_16_PCREL,		5)
+    RELOC_NUMBER (R_AVR32_8_PCREL,		6)
+    RELOC_NUMBER (R_AVR32_DIFF32,		7)
+    RELOC_NUMBER (R_AVR32_DIFF16,		8)
+    RELOC_NUMBER (R_AVR32_DIFF8,		9)
+    RELOC_NUMBER (R_AVR32_GOT32,		10)
+    RELOC_NUMBER (R_AVR32_GOT16,		11)
+    RELOC_NUMBER (R_AVR32_GOT8,			12)
+
+    /* Normal Code Relocations */
+    RELOC_NUMBER (R_AVR32_21S,			13)
+    RELOC_NUMBER (R_AVR32_16U,			14)
+    RELOC_NUMBER (R_AVR32_16S,			15)
+    RELOC_NUMBER (R_AVR32_8S,			16)
+    RELOC_NUMBER (R_AVR32_8S_EXT,		17)
+
+    /* PC-Relative Code Relocations */
+    RELOC_NUMBER (R_AVR32_22H_PCREL,		18)
+    RELOC_NUMBER (R_AVR32_18W_PCREL,		19)
+    RELOC_NUMBER (R_AVR32_16B_PCREL,		20)
+    RELOC_NUMBER (R_AVR32_16N_PCREL,		21)
+    RELOC_NUMBER (R_AVR32_14UW_PCREL,		22)
+    RELOC_NUMBER (R_AVR32_11H_PCREL,		23)
+    RELOC_NUMBER (R_AVR32_10UW_PCREL,		24)
+    RELOC_NUMBER (R_AVR32_9H_PCREL,		25)
+    RELOC_NUMBER (R_AVR32_9UW_PCREL,		26)
+
+    /* Special Code Relocations */
+    RELOC_NUMBER (R_AVR32_HI16,			27)
+    RELOC_NUMBER (R_AVR32_LO16,			28)
+
+    /* PIC Relocations */
+    RELOC_NUMBER (R_AVR32_GOTPC,		29)
+    RELOC_NUMBER (R_AVR32_GOTCALL,		30)
+    RELOC_NUMBER (R_AVR32_LDA_GOT,		31)
+    RELOC_NUMBER (R_AVR32_GOT21S,		32)
+    RELOC_NUMBER (R_AVR32_GOT18SW,		33)
+    RELOC_NUMBER (R_AVR32_GOT16S,		34)
+    RELOC_NUMBER (R_AVR32_GOT7UW,		35)
+
+    /* Constant Pool Relocations */
+    RELOC_NUMBER (R_AVR32_32_CPENT,		36)
+    RELOC_NUMBER (R_AVR32_CPCALL,		37)
+    RELOC_NUMBER (R_AVR32_16_CP,		38)
+    RELOC_NUMBER (R_AVR32_9W_CP,		39)
+
+    /* Dynamic Relocations */
+    RELOC_NUMBER (R_AVR32_RELATIVE,		40)
+    RELOC_NUMBER (R_AVR32_GLOB_DAT,		41)
+    RELOC_NUMBER (R_AVR32_JMP_SLOT,		42)
+
+    /* Linkrelax Information */
+    RELOC_NUMBER (R_AVR32_ALIGN,		43)
+
+    RELOC_NUMBER (R_AVR32_15S,		        44)
+
+END_RELOC_NUMBERS (R_AVR32_max)
+
+/* Processor specific dynamic array tags.  */
+
+/* The total size in bytes of the Global Offset Table */
+#define DT_AVR32_GOTSZ			0x70000001
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -259,6 +259,9 @@
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850		0x9080
 
+/* AVR32 magic number, picked by IAR Systems. */
+#define EM_AVR32		0x18ad
+
 /* old S/390 backend magic number. Written in the absence of an ABI.  */
 #define EM_S390_OLD		0xa390
 
--- a/ld/configdoc.texi
+++ b/ld/configdoc.texi
@@ -7,6 +7,7 @@
 @set H8300
 @set HPPA
 @set I960
+@set AVR32
 @set M68HC11
 @set MMIX
 @set MSP430
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -109,6 +109,9 @@ xscale-*-elf)		targ_emul=armelf
 avr-*-*)		targ_emul=avr2
 			targ_extra_emuls="avr1 avr3 avr4 avr5 avr6"
 			;;
+avr32-*-none)       targ_emul=avr32elf_ap7000
+            targ_extra_emuls="avr32elf_ap7001 avr32elf_ap7002 avr32elf_ap7200 avr32elf_uc3a0128 avr32elf_uc3a0256 avr32elf_uc3a0512 avr32elf_uc3a0512es avr32elf_uc3a1128 avr32elf_uc3a1256 avr32elf_uc3a1512es avr32elf_uc3a1512 avr32elf_uc3a364 avr32elf_uc3a364s avr32elf_uc3a3128 avr32elf_uc3a3128s avr32elf_uc3a3256 avr32elf_uc3a3256s avr32elf_uc3b064 avr32elf_uc3b0128 avr32elf_uc3b0256es avr32elf_uc3b0256 avr32elf_uc3b164 avr32elf_uc3b1128 avr32elf_uc3b1256es avr32elf_uc3b1256" ;;
+avr32-*-linux*)     targ_emul=avr32linux ;;
 bfin-*-elf)		targ_emul=elf32bfin;
 			targ_extra_emuls="elf32bfinfd"
 			targ_extra_libpath=$targ_extra_emuls
--- /dev/null
+++ b/ld/emulparams/avr32elf.sh
@@ -0,0 +1,163 @@
+# This script is called from ld/genscript.sh 
+# There is a difference on how 'bash' and POSIX handles 
+# the  '.' (source) command in a script.
+# genscript.sh calls this script with argument ${EMULATION_NAME}
+# but that will fail on POSIX compilant shells like 'sh' or 'dash'
+# therefor I use the variable directly instead of $1 
+EMULATION=${EMULATION_NAME}
+SCRIPT_NAME=elf_xip
+TEMPLATE_NAME=elf32
+EXTRA_EM_FILE=avr32elf
+OUTPUT_FORMAT="elf32-avr32"
+ARCH=avr32
+MAXPAGESIZE=4096
+ENTRY=_start
+EMBEDDED=yes
+NO_SMALL_DATA=yes
+NOP=0xd703d703
+
+DATA_SEGMENT_ALIGN=8
+BSS_ALIGNMENT=8
+
+RO_LMA_REGION="FLASH"
+RO_VMA_REGION="FLASH"
+RW_LMA_REGION="FLASH"
+RW_VMA_REGION="CPUSRAM"
+
+STACK_SIZE=0x1000
+STACK_ADDR="ORIGIN(CPUSRAM) + LENGTH(CPUSRAM) - ${STACK_SIZE}"
+
+DATA_SEGMENT_END="__heap_start__ = ALIGN(8);
+  . = ${STACK_ADDR};
+  __heap_end__ = .;"
+
+case "$EMULATION" in
+avr32elf_ap*)
+    MACHINE=ap
+    INITIAL_READONLY_SECTIONS=".reset : {  *(.reset) } >FLASH AT>FLASH
+    . = . & 0x9fffffff;"
+    TEXT_START_ADDR=0xa0000000
+    case "$EMULATION" in
+	    avr32elf_ap700[0-2])
+	       MEMORY="MEMORY
+  {
+	FLASH (rxai) : ORIGIN = 0x00000000, LENGTH = 64M
+	CPUSRAM (rwxa) : ORIGIN = 0x24000000, LENGTH = 32K
+  }"
+        ;;
+    avr32elf_ap7200)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai) : ORIGIN = 0x00000000, LENGTH = 64M
+    CPUSRAM (rwxa) : ORIGIN = 0x08000000, LENGTH = 64K
+  }"
+        ;;
+    esac
+    ;;
+
+avr32elf_uc3*)
+    MACHINE=uc
+    INITIAL_READONLY_SECTIONS=".reset : {  *(.reset) } >FLASH AT>FLASH"
+    TEXT_START_ADDR=0x80000000
+    OTHER_SECTIONS=".userpage :  {	*(.userpage .userpage.*)  } >USERPAGE AT>USERPAGE
+  	.factorypage :  {	*(.factorypage .factorypage.*)  } >FACTORYPAGE AT>FACTORYPAGE"
+
+    case "$EMULATION" in
+    avr32elf_uc3a[01]512*)
+       MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 512K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 64K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+        ;;
+
+    avr32elf_uc3a[01]256)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 256K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 64K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+        ;;
+
+    avr32elf_uc3b[01]256*)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 256K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 32K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+        ;;
+
+    avr32elf_uc3[ab][01]128)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 128K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 32K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+        ;;
+
+    avr32elf_uc3b[01]64)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 64K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 16K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+        ;;
+
+    avr32elf_uc3a3256*)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 256K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 64K
+    HSBSRAM (wxa!ri) : ORIGIN = 0xFF000000, LENGTH = 64K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+  		OTHER_SECTIONS ="${OTHER_SECTIONS}
+  	.hsbsram       : { *(.hsbsram .hsbsram.*) } >HSBSRAM AT>FLASH :FLASH
+"
+  		
+        ;;
+
+    avr32elf_uc3a3128*)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 128K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 64K
+    HSBSRAM (wxa!ri) : ORIGIN = 0xFF000000, LENGTH = 64K
+    USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+    FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+  		OTHER_SECTIONS ="${OTHER_SECTIONS}
+  	.hsbsram       : { *(.hsbsram .hsbsram.*) } >HSBSRAM AT>FLASH :FLASH
+"
+        ;;
+
+    avr32elf_uc3a364*)
+        MEMORY="MEMORY
+  {
+    FLASH (rxai!w) : ORIGIN = 0x80000000, LENGTH = 64K
+    CPUSRAM (wxa!ri) : ORIGIN = 0x00000000, LENGTH = 64K
+    HSBSRAM (wxa!ri) : ORIGIN = 0xFF000000, LENGTH = 64K
+	USERPAGE : ORIGIN = 0x80800000, LENGTH = 512
+	FACTORYPAGE : ORIGIN = 0x80800200, LENGTH = 512
+  }"
+  		OTHER_SECTIONS ="${OTHER_SECTIONS}
+  	.hsbsram       : { *(.hsbsram .hsbsram.*) } >HSBSRAM AT>FLASH :FLASH
+"
+        ;;
+
+
+    esac
+    ;;
+
+esac
--- /dev/null
+++ b/ld/emulparams/avr32linux.sh
@@ -0,0 +1,14 @@
+ARCH=avr32
+SCRIPT_NAME=elf
+TEMPLATE_NAME=elf32
+EXTRA_EM_FILE=avr32elf
+OUTPUT_FORMAT="elf32-avr32"
+GENERATE_SHLIB_SCRIPT=yes
+MAXPAGESIZE=0x1000
+TEXT_START_ADDR=0x00001000
+NOP=0xd703d703
+
+# This appears to place the GOT before the data section, which is
+# essential for uClinux.  We don't use those .s* sections on AVR32
+# anyway, so it shouldn't hurt for regular Linux either...
+NO_SMALL_DATA=yes
--- /dev/null
+++ b/ld/emultempl/avr32elf.em
@@ -0,0 +1,133 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2007 Atmel Corporation
+#
+# This file is part of GLD, the Gnu Linker.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+#
+
+# This file is sourced from elf32.em, and defines extra avr32-elf
+# specific routines.
+#
+
+# Generate linker script for writable rodata
+LD_FLAG=rodata-writable
+DATA_ALIGNMENT=${DATA_ALIGNMENT_}
+RELOCATING=" "
+WRITABLE_RODATA=" "
+( echo "/* Linker script for writable rodata */"
+  . ${CUSTOMIZER_SCRIPT} ${EMULATION_NAME}
+  . ${srcdir}/scripttempl/${SCRIPT_NAME}.sc
+) | sed -e '/^ *$/d;s/[ 	]*$//' > ldscripts/${EMULATION_NAME}.xwr
+
+
+cat >> e${EMULATION_NAME}.c <<EOF
+
+#include "libbfd.h"
+#include "elf32-avr32.h"
+
+/* Whether to allow direct references (sub or mov) to SEC_DATA and
+   !SEC_CONTENTS sections when optimizing.  Not enabled by default
+   since it might cause link errors.  */
+static int direct_data_refs = 0;
+
+static void avr32_elf_after_open (void)
+{
+  bfd_elf32_avr32_set_options (&link_info, direct_data_refs);
+  gld${EMULATION_NAME}_after_open ();
+}
+
+static int rodata_writable = 0;
+
+static char * gld${EMULATION_NAME}_get_script (int *isfile);
+
+static char * avr32_elf_get_script (int *isfile)
+{
+  if ( rodata_writable )
+    {
+EOF
+if test -n "$COMPILE_IN"
+then
+# Scripts compiled in.
+
+# sed commands to quote an ld script as a C string.
+sc="-f stringify.sed"
+
+cat >>e${EMULATION_NAME}.c <<EOF
+      *isfile = 0;
+      return
+EOF
+sed $sc ldscripts/${EMULATION_NAME}.xwr			>> e${EMULATION_NAME}.c
+echo  ';'	                                        >> e${EMULATION_NAME}.c
+else
+# Scripts read from the filesystem.
+
+cat >>e${EMULATION_NAME}.c <<EOF
+      *isfile = 1;
+      return "ldscripts/${EMULATION_NAME}.xwr";
+EOF
+fi
+
+cat >>e${EMULATION_NAME}.c <<EOF
+    }
+  return gld${EMULATION_NAME}_get_script (isfile);
+}
+
+
+EOF
+
+# Define some shell vars to insert bits of code into the standard elf
+# parse_args and list_options functions.
+#
+PARSE_AND_LIST_PROLOGUE='
+#define OPTION_DIRECT_DATA		300
+#define OPTION_NO_DIRECT_DATA		301
+#define OPTION_RODATA_WRITABLE		302
+#define OPTION_NO_RODATA_WRITABLE	303
+'
+
+PARSE_AND_LIST_LONGOPTS='
+  { "direct-data", no_argument, NULL, OPTION_DIRECT_DATA },
+  { "no-direct-data", no_argument, NULL, OPTION_NO_DIRECT_DATA },
+  { "rodata-writable", no_argument, NULL, OPTION_RODATA_WRITABLE },
+  { "no-rodata-writable", no_argument, NULL, OPTION_NO_RODATA_WRITABLE },
+'
+
+PARSE_AND_LIST_OPTIONS='
+  fprintf (file, _("  --direct-data\t\tAllow direct data references when optimizing\n"));
+  fprintf (file, _("  --no-direct-data\tDo not allow direct data references when optimizing\n"));
+  fprintf (file, _("  --rodata-writable\tPut read-only data in writable data section\n"));
+  fprintf (file, _("  --no-rodata-writable\tDo not put read-only data in writable data section\n"));
+'
+
+PARSE_AND_LIST_ARGS_CASES='
+    case OPTION_DIRECT_DATA:
+      direct_data_refs = 1;
+      break;
+    case OPTION_NO_DIRECT_DATA:
+      direct_data_refs = 0;
+      break;
+    case OPTION_RODATA_WRITABLE:
+      rodata_writable = 1;
+      break;
+    case OPTION_NO_RODATA_WRITABLE:
+      rodata_writable = 0;
+      break;
+'
+
+# Replace some of the standard ELF functions with our own versions.
+#
+LDEMUL_AFTER_OPEN=avr32_elf_after_open
+LDEMUL_GET_SCRIPT=avr32_elf_get_script
--- a/ld/ld.info
+++ b/ld/ld.info
@@ -4347,6 +4347,8 @@ not listed.
 
 * ARM::				`ld' and the ARM family
 
+* AVR32::                       `ld' and AVR32 processors
+
 * HPPA ELF32::                  `ld' and HPPA 32-bit ELF
 
 * MMIX::			`ld' and MMIX
@@ -4487,7 +4489,7 @@ PIC.  This avoids problems on uClinux ta
 used to generate relocatable binaries.
 
 
-File: ld.info,  Node: ARM,  Next: HPPA ELF32,  Prev: i960,  Up: Machine Dependent
+File: ld.info,  Node: ARM,  Next: AV32,  Prev: i960,  Up: Machine Dependent
 
 4.4 `ld' and the ARM family
 ===========================
@@ -4588,7 +4590,31 @@ enumeration values fitted into the small
 diagnosed.
 
 
-File: ld.info,  Node: HPPA ELF32,  Next: MMIX,  Prev: ARM,  Up: Machine Dependent
+File: ld.info,  Node: AVR32,  Next: HPPA ELF32,  Prev: ARM,  Up: Machine Dependent
+
+4.4 `ld' and AVR32 processors
+=============================
+
+`--direct-data'
+
+`--no-direct-data'
+     Taking the address of a symbol can often be done by using a direct
+     `mov' or pc-relative `sub' instruction, which is faster than using
+     a PC- or GOT-relative load, especially on the uC3 processors.
+     However, this does not always work when dealing with symbols in
+     the `.data' section so this optimization is disabled by default.
+
+     Specifying `--direct-data' will enable this optimization. Note
+     that this may cause `relocation truncated to fit' errors for
+     certain large programs. If this happens, the optimization can be
+     turned off by specifying `--no-direct-data'.
+
+     All known issues with direct data optimizations are detected at
+     link time, so if the linker doesn't complain, the result should
+     run just fine.
+
+
+File: ld.info,  Node: HPPA ELF32,  Next: MMIX,  Prev: AVR32,  Up: Machine Dependent
 
 4.5 `ld' and HPPA 32-bit ELF Support
 ====================================
@@ -6336,6 +6362,7 @@ LD Index
 * --no-check-sections:                   Options.            (line  765)
 * --no-define-common:                    Options.            (line  787)
 * --no-demangle:                         Options.            (line  816)
+* --no-direct-data:                      AVR32.              (line    6)
 * --no-dotsyms:                          PowerPC64 ELF64.    (line   33)
 * --no-enum-size-warning:                ARM.                (line   94)
 * --no-gc-sections:                      Options.            (line  848)
@@ -6534,6 +6561,7 @@ LD Index
 * AT(LMA):                               Output Section LMA. (line    6)
 * AT>LMA_REGION:                         Output Section LMA. (line    6)
 * automatic data imports:                WIN32.              (line  170)
+* AVR32 options:                         AVR32.              (line    6)
 * back end:                              BFD.                (line    6)
 * BASE (MRI):                            MRI.                (line   54)
 * BE8:                                   ARM.                (line   23)
@@ -7018,6 +7046,7 @@ Node: H8/300183897
 Node: i960185522
 Node: M68HC11/68HC12187207
 Node: ARM188910
+Node: AVR32182578
 Node: HPPA ELF32193760
 Node: MMIX195383
 Node: MSP430196600
--- a/ld/ld.texinfo
+++ b/ld/ld.texinfo
@@ -21,6 +21,7 @@
 @set UsesEnvVars
 @set GENERIC
 @set ARM
+@set AVR32
 @set H8300
 @set HPPA
 @set I960
@@ -139,6 +140,9 @@ section entitled ``GNU Free Documentatio
 @ifset ARM
 * ARM::				ld and the ARM family
 @end ifset
+@ifset AVR32
+* AVR32::                       ld and AVR32 processors
+@end ifset
 @ifset HPPA
 * HPPA ELF32::                  ld and HPPA 32-bit ELF
 @end ifset
@@ -5248,6 +5252,9 @@ functionality are not listed.
 @ifset ARM
 * ARM::				@command{ld} and the ARM family
 @end ifset
+@ifset AVR32
+* AVR32::                       @command{ld} and AVR32 processors
+@end ifset
 @ifset HPPA
 * HPPA ELF32::                  @command{ld} and HPPA 32-bit ELF
 @end ifset
@@ -5589,6 +5596,52 @@ not be diagnosed.
 @end ifclear
 @end ifset
 
+@ifset AVR32
+@ifclear GENERIC
+@raisesections
+@end ifclear
+
+@node AVR32
+@section @command{ld} and AVR32 processors
+@cindex AVR32 options
+@table @option
+@kindex --direct-data
+@kindex --no-direct-data
+@item --direct-data
+@item --no-direct-data
+Taking the address of a symbol can often be done by using a direct
+@code{mov} or pc-relative @code{sub} instruction, which is faster than
+using a PC- or GOT-relative load, especially on the uC3
+processors. However, this does not always work when dealing with
+symbols in the @code{.data} section so this optimization is disabled
+by default.
+
+Specifying @option{--direct-data} will enable this optimization. Note
+that this may cause @samp{relocation truncated to fit} errors for
+certain large programs. If this happens, the optimization can be
+turned off by specifying @option{--no-direct-data}.
+
+All known issues with direct data optimizations are detected at link
+time, so if the linker doesn't complain, the result should run just
+fine.
+
+@kindex --rodata-writable
+@kindex --no-rodata-writable
+@item --rodata-writable
+@item --no-rodata-writable
+Using the @option{--rodata-writable} options will cause the linker
+to try and use a linker script where read-only data will be placed
+in the same section as writable data. This can give great performance 
+gain on cacheless processors where read-only data normally is placed in
+flash, and writable data is placed in internal sram. This will however 
+come at the expence of a larger memory footprint.
+@end table
+
+@ifclear GENERIC
+@lowersections
+@end ifclear
+@end ifset
+
 @ifset HPPA
 @ifclear GENERIC
 @raisesections
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -137,7 +137,34 @@ ALL_EMULATIONS = \
 	eavr3.o \
 	eavr4.o \
 	eavr5.o \
-	eavr6.o \
+    eavr6.o \
+	eavr32elf_ap7000.o \
+	eavr32elf_ap7001.o \
+	eavr32elf_ap7002.o \
+	eavr32elf_ap7200.o \
+	eavr32elf_uc3a0128.o \
+	eavr32elf_uc3a0256.o \
+	eavr32elf_uc3a0512.o \
+	eavr32elf_uc3a0512es.o \
+	eavr32elf_uc3a1128.o \
+	eavr32elf_uc3a1256.o \
+	eavr32elf_uc3a1512es.o \
+	eavr32elf_uc3a1512.o \
+	eavr32elf_uc3a364.o \
+	eavr32elf_uc3a364s.o \
+	eavr32elf_uc3a3128.o \
+	eavr32elf_uc3a3128s.o \
+	eavr32elf_uc3a3256.o \
+	eavr32elf_uc3a3256s.o \
+	eavr32elf_uc3b064.o \
+	eavr32elf_uc3b0128.o \
+	eavr32elf_uc3b0256es.o \
+	eavr32elf_uc3b0256.o \
+	eavr32elf_uc3b164.o \
+	eavr32elf_uc3b1128.o \
+	eavr32elf_uc3b1256es.o \
+	eavr32elf_uc3b1256.o \
+	eavr32linux.o \
 	ecoff_i860.o \
 	ecoff_sparc.o \
 	eelf32_spu.o \
@@ -622,6 +649,114 @@ eavr6.c: $(srcdir)/emulparams/avr6.sh $(
   $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avr6 "$(tdir_avr2)"
+eavr32elf_ap7000.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7000 "$(tdir_avr32)" avr32elf
+eavr32elf_ap7001.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7001 "$(tdir_avr32)" avr32elf
+eavr32elf_ap7002.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7002 "$(tdir_avr32)" avr32elf
+eavr32elf_ap7200.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7200 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0512.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0512 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0512es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0512es "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1512.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1512 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1512es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1512es "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a364.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a364 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a364s.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a364s "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3128s.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3128s "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3256s.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3256s "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b064.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b064 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b0128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b0128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b0256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b0256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b0256es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b0256es "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b164.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b164 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b1128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b1128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b1256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b1256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b1256es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b1256es "$(tdir_avr32)" avr32elf
+eavr32linux.c: $(srcdir)/emulparams/avr32linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32linux "$(tdir_avr32)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
@@ -1877,7 +2012,9 @@ install-exec-local: ld-new$(EXEEXT)
 	  || $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
 	fi
 
-install-data-local:
+# We want install to imply install-info as per GNU standards, despite the
+# cygnus option.
+install-data-local: install-info
 	$(mkinstalldirs) $(DESTDIR)$(scriptdir)/ldscripts
 	for f in ldscripts/*; do \
 	  $(INSTALL_DATA) $$f $(DESTDIR)$(scriptdir)/$$f ; \
--- /dev/null
+++ b/ld/scripttempl/elf_xip.sc
@@ -0,0 +1,456 @@
+#
+# Unusual variables checked by this code:
+#	NOP - four byte opcode for no-op (defaults to 0)
+#	NO_SMALL_DATA - no .sbss/.sbss2/.sdata/.sdata2 sections if not
+#		empty.
+#	SMALL_DATA_CTOR - .ctors contains small data.
+#	SMALL_DATA_DTOR - .dtors contains small data.
+#	DATA_ADDR - if end-of-text-plus-one-page isn't right for data start
+#	INITIAL_READONLY_SECTIONS - at start of text segment
+#	OTHER_READONLY_SECTIONS - other than .text .init .rodata ...
+#		(e.g., .PARISC.milli)
+#	OTHER_TEXT_SECTIONS - these get put in .text when relocating
+#	OTHER_READWRITE_SECTIONS - other than .data .bss .ctors .sdata ...
+#		(e.g., .PARISC.global)
+#	OTHER_RELRO_SECTIONS - other than .data.rel.ro ...
+#		(e.g. PPC32 .fixup, .got[12])
+#	OTHER_BSS_SECTIONS - other than .bss .sbss ...
+#	OTHER_SECTIONS - at the end
+#	EXECUTABLE_SYMBOLS - symbols that must be defined for an
+#		executable (e.g., _DYNAMIC_LINK)
+#       TEXT_START_ADDR - the first byte of the text segment, after any
+#               headers.
+#       TEXT_BASE_ADDRESS - the first byte of the text segment.
+#	TEXT_START_SYMBOLS - symbols that appear at the start of the
+#		.text section.
+#	DATA_START_SYMBOLS - symbols that appear at the start of the
+#		.data section.
+#	OTHER_GOT_SYMBOLS - symbols defined just before .got.
+#	OTHER_GOT_SECTIONS - sections just after .got.
+#	OTHER_SDATA_SECTIONS - sections just after .sdata.
+#	OTHER_BSS_SYMBOLS - symbols that appear at the start of the
+#		.bss section besides __bss_start.
+#	DATA_PLT - .plt should be in data segment, not text segment.
+#	PLT_BEFORE_GOT - .plt just before .got when .plt is in data segement.
+#	BSS_PLT - .plt should be in bss segment
+#	TEXT_DYNAMIC - .dynamic in text segment, not data segment.
+#	EMBEDDED - whether this is for an embedded system.
+#	SHLIB_TEXT_START_ADDR - if set, add to SIZEOF_HEADERS to set
+#		start address of shared library.
+#	INPUT_FILES - INPUT command of files to always include
+#	WRITABLE_RODATA - if set, the .rodata section should be writable
+#	INIT_START, INIT_END -  statements just before and just after
+# 	combination of .init sections.
+#	FINI_START, FINI_END - statements just before and just after
+# 	combination of .fini sections.
+#	STACK_ADDR - start of a .stack section.
+#	OTHER_END_SYMBOLS - symbols to place right at the end of the script.
+#	SEPARATE_GOTPLT - if set, .got.plt should be separate output section,
+#		so that .got can be in the RELRO area.  It should be set to
+#		the number of bytes in the beginning of .got.plt which can be
+#		in the RELRO area as well.
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+
+#  Many sections come in three flavours.  There is the 'real' section,
+#  like ".data".  Then there are the per-procedure or per-variable
+#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
+#  and useful for --gc-sections, which for a variable "foo" might be
+#  ".data.foo".  Then there are the linkonce sections, for which the linker
+#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
+#  The exact correspondences are:
+#
+#  Section	Linkonce section
+#  .text	.gnu.linkonce.t.foo
+#  .rodata	.gnu.linkonce.r.foo
+#  .data	.gnu.linkonce.d.foo
+#  .bss		.gnu.linkonce.b.foo
+#  .sdata	.gnu.linkonce.s.foo
+#  .sbss	.gnu.linkonce.sb.foo
+#  .sdata2	.gnu.linkonce.s2.foo
+#  .sbss2	.gnu.linkonce.sb2.foo
+#  .debug_info	.gnu.linkonce.wi.foo
+#  .tdata	.gnu.linkonce.td.foo
+#  .tbss	.gnu.linkonce.tb.foo
+#
+#  Each of these can also have corresponding .rel.* and .rela.* sections.
+
+test -z "$ENTRY" && ENTRY=_start
+test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test -z "${ELFSIZE}" && ELFSIZE=32
+test -z "${ALIGNMENT}" && ALIGNMENT="${ELFSIZE} / 8"
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+test -n "$CREATE_SHLIB$CREATE_PIE" && test -n "$SHLIB_DATA_ADDR" && COMMONPAGESIZE=""
+test -z "$CREATE_SHLIB$CREATE_PIE" && test -n "$DATA_ADDR" && COMMONPAGESIZE=""
+test -n "$RELRO_NOW" && unset SEPARATE_GOTPLT
+if test -n "$RELOCATING"; then
+  RO_REGION="${RO_VMA_REGION+ >}${RO_VMA_REGION}${RO_LMA_REGION+ AT>}${RO_LMA_REGION}"
+  RW_REGION="${RW_VMA_REGION+ >}${RW_VMA_REGION}${RW_LMA_REGION+ AT>}${RW_LMA_REGION}"
+else
+  RO_REGION=""
+  RW_REGION=""
+fi
+INTERP=".interp       ${RELOCATING-0} : { *(.interp) }${RO_REGION}"
+PLT=".plt          ${RELOCATING-0} : { *(.plt) }"
+if test -z "$GOT"; then
+  if test -z "$SEPARATE_GOTPLT"; then
+    GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) }"
+  else
+    GOT=".got          ${RELOCATING-0} : { *(.got) }"
+    GOTPLT="${RELOCATING+${DATA_SEGMENT_RELRO_GOTPLT_END}}
+  .got.plt      ${RELOCATING-0} : { *(.got.plt) }"
+  fi
+fi
+DALIGN=".dalign	: { . = ALIGN(${DATA_SEGMENT_ALIGN}); PROVIDE(_data_lma = .); }${RO_REGION}"
+BALIGN=".balign	: { . = ALIGN(${BSS_ALIGNMENT}); _edata = .; }${RW_REGION}"
+DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
+RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
+DATARELRO=".data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro*) }${RW_REGION}"
+STACKNOTE="/DISCARD/ : { *(.note.GNU-stack) }"
+if test -z "${NO_SMALL_DATA}"; then
+  SBSS=".sbss         ${RELOCATING-0} :
+  {
+    ${RELOCATING+PROVIDE (__sbss_start = .);}
+    ${RELOCATING+PROVIDE (___sbss_start = .);}
+    ${CREATE_SHLIB+*(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)}
+    *(.dynsbss)
+    *(.sbss${RELOCATING+ .sbss.* .gnu.linkonce.sb.*})
+    *(.scommon)
+    ${RELOCATING+PROVIDE (__sbss_end = .);}
+    ${RELOCATING+PROVIDE (___sbss_end = .);}
+  }${RW_REGION}"
+  SBSS2=".sbss2        ${RELOCATING-0} : { *(.sbss2${RELOCATING+ .sbss2.* .gnu.linkonce.sb2.*}) }${RW_REGION}"
+  SDATA="/* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata        ${RELOCATING-0} :
+  {
+    ${RELOCATING+${SDATA_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sdata2 .sdata2.* .gnu.linkonce.s2.*)}
+    *(.sdata${RELOCATING+ .sdata.* .gnu.linkonce.s.*})
+  }${RW_REGION}"
+  SDATA2=".sdata2       ${RELOCATING-0} : { *(.sdata2${RELOCATING+ .sdata2.* .gnu.linkonce.s2.*}) }${RW_REGION}"
+  REL_SDATA=".rel.sdata    ${RELOCATING-0} : { *(.rel.sdata${RELOCATING+ .rel.sdata.* .rel.gnu.linkonce.s.*}) }${RO_REGION}
+  .rela.sdata   ${RELOCATING-0} : { *(.rela.sdata${RELOCATING+ .rela.sdata.* .rela.gnu.linkonce.s.*}) }"
+  REL_SBSS=".rel.sbss     ${RELOCATING-0} : { *(.rel.sbss${RELOCATING+ .rel.sbss.* .rel.gnu.linkonce.sb.*}) }${RO_REGION}
+  .rela.sbss    ${RELOCATING-0} : { *(.rela.sbss${RELOCATING+ .rela.sbss.* .rela.gnu.linkonce.sb.*}) }${RO_REGION}"
+  REL_SDATA2=".rel.sdata2   ${RELOCATING-0} : { *(.rel.sdata2${RELOCATING+ .rel.sdata2.* .rel.gnu.linkonce.s2.*}) }${RO_REGION}
+  .rela.sdata2  ${RELOCATING-0} : { *(.rela.sdata2${RELOCATING+ .rela.sdata2.* .rela.gnu.linkonce.s2.*}) }${RO_REGION}"
+  REL_SBSS2=".rel.sbss2    ${RELOCATING-0} : { *(.rel.sbss2${RELOCATING+ .rel.sbss2.* .rel.gnu.linkonce.sb2.*}) }${RO_REGION}
+  .rela.sbss2   ${RELOCATING-0} : { *(.rela.sbss2${RELOCATING+ .rela.sbss2.* .rela.gnu.linkonce.sb2.*}) }${RO_REGION}"
+else
+  NO_SMALL_DATA=" "
+fi
+test -n "$SEPARATE_GOTPLT" && SEPARATE_GOTPLT=" "
+CTOR=".ctors        ${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+${CTOR_START}}
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+
+    KEEP (*crtbegin*.o(.ctors))
+
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+
+    KEEP (*(EXCLUDE_FILE (*crtend*.o $OTHER_EXCLUDE_FILES) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    ${CONSTRUCTING+${CTOR_END}}
+  }"
+DTOR=".dtors        ${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+${DTOR_START}}
+    KEEP (*crtbegin*.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend*.o $OTHER_EXCLUDE_FILES) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    ${CONSTRUCTING+${DTOR_END}}
+  }"
+STACK=".stack        ${RELOCATING-0}${RELOCATING+${STACK_ADDR}} :
+  {
+    ${RELOCATING+_stack = .;}
+    *(.stack)
+    ${RELOCATING+${STACK_SIZE+. = ${STACK_SIZE};}}
+    ${RELOCATING+_estack = .;}
+  }${RW_REGION}"
+
+# if this is for an embedded system, don't add SIZEOF_HEADERS.
+if [ -z "$EMBEDDED" ]; then
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR} + SIZEOF_HEADERS"
+else
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+fi
+
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
+	      "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+ENTRY(${ENTRY})
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+${RELOCATING+/* Do we need any of these for elf?
+   __DYNAMIC = 0; ${STACKZERO+${STACKZERO}} ${SHLIB_PATH+${SHLIB_PATH}}  */}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+${INPUT_FILES}}
+${RELOCATING- /* For some reason, the Solaris linker makes bad executables
+  if gld -r is used and the intermediate file has sections starting
+  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld
+  bug.  But for now assigning the zero vmas works.  */}
+
+${RELOCATING+${MEMORY}}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+PROVIDE (__executable_start = ${TEXT_START_ADDR}); . = ${TEXT_BASE_ADDRESS};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_SHLIB-${INTERP}}
+  ${INITIAL_READONLY_SECTIONS}
+  ${TEXT_DYNAMIC+${DYNAMIC}${RO_REGION}}
+  .hash         ${RELOCATING-0} : { *(.hash) }${RO_REGION}
+  .dynsym       ${RELOCATING-0} : { *(.dynsym) }${RO_REGION}
+  .dynstr       ${RELOCATING-0} : { *(.dynstr) }${RO_REGION}
+  .gnu.version  ${RELOCATING-0} : { *(.gnu.version) }${RO_REGION}
+  .gnu.version_d ${RELOCATING-0}: { *(.gnu.version_d) }${RO_REGION}
+  .gnu.version_r ${RELOCATING-0}: { *(.gnu.version_r) }${RO_REGION}
+
+EOF
+if [ "x$COMBRELOC" = x ]; then
+  COMBRELOCCAT=cat
+else
+  COMBRELOCCAT="cat > $COMBRELOC"
+fi
+eval $COMBRELOCCAT <<EOF
+  .rel.init     ${RELOCATING-0} : { *(.rel.init) }${RO_REGION}
+  .rela.init    ${RELOCATING-0} : { *(.rela.init) }${RO_REGION}
+  .rel.text     ${RELOCATING-0} : { *(.rel.text${RELOCATING+ .rel.text.* .rel.gnu.linkonce.t.*}) }${RO_REGION}
+  .rela.text    ${RELOCATING-0} : { *(.rela.text${RELOCATING+ .rela.text.* .rela.gnu.linkonce.t.*}) }${RO_REGION}
+  .rel.fini     ${RELOCATING-0} : { *(.rel.fini) }${RO_REGION}
+  .rela.fini    ${RELOCATING-0} : { *(.rela.fini) }${RO_REGION}
+  .rel.rodata   ${RELOCATING-0} : { *(.rel.rodata${RELOCATING+ .rel.rodata.* .rel.gnu.linkonce.r.*}) }${RO_REGION}
+  .rela.rodata  ${RELOCATING-0} : { *(.rela.rodata${RELOCATING+ .rela.rodata.* .rela.gnu.linkonce.r.*}) }${RO_REGION}
+  ${OTHER_READONLY_RELOC_SECTIONS}
+  .rel.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+*}) }${RO_REGION}
+  .rela.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+*}) }${RO_REGION}
+  .rel.data     ${RELOCATING-0} : { *(.rel.data${RELOCATING+ .rel.data.* .rel.gnu.linkonce.d.*}) }${RO_REGION}
+  .rela.data    ${RELOCATING-0} : { *(.rela.data${RELOCATING+ .rela.data.* .rela.gnu.linkonce.d.*}) }${RO_REGION}
+  .rel.tdata	${RELOCATING-0} : { *(.rel.tdata${RELOCATING+ .rel.tdata.* .rel.gnu.linkonce.td.*}) }${RO_REGION}
+  .rela.tdata	${RELOCATING-0} : { *(.rela.tdata${RELOCATING+ .rela.tdata.* .rela.gnu.linkonce.td.*}) }${RO_REGION}
+  .rel.tbss	${RELOCATING-0} : { *(.rel.tbss${RELOCATING+ .rel.tbss.* .rel.gnu.linkonce.tb.*}) }${RO_REGION}
+  .rela.tbss	${RELOCATING-0} : { *(.rela.tbss${RELOCATING+ .rela.tbss.* .rela.gnu.linkonce.tb.*}) }${RO_REGION}
+  .rel.ctors    ${RELOCATING-0} : { *(.rel.ctors) }${RO_REGION}
+  .rela.ctors   ${RELOCATING-0} : { *(.rela.ctors) }${RO_REGION}
+  .rel.dtors    ${RELOCATING-0} : { *(.rel.dtors) }${RO_REGION}
+  .rela.dtors   ${RELOCATING-0} : { *(.rela.dtors) }${RO_REGION}
+  .rel.got      ${RELOCATING-0} : { *(.rel.got) }${RO_REGION}
+  .rela.got     ${RELOCATING-0} : { *(.rela.got) }${RO_REGION}
+  ${OTHER_GOT_RELOC_SECTIONS}
+  ${REL_SDATA}
+  ${REL_SBSS}
+  ${REL_SDATA2}
+  ${REL_SBSS2}
+  .rel.bss      ${RELOCATING-0} : { *(.rel.bss${RELOCATING+ .rel.bss.* .rel.gnu.linkonce.b.*}) }${RO_REGION}
+  .rela.bss     ${RELOCATING-0} : { *(.rela.bss${RELOCATING+ .rela.bss.* .rela.gnu.linkonce.b.*}) }${RO_REGION}
+EOF
+if [ -n "$COMBRELOC" ]; then
+cat <<EOF
+  .rel.dyn      ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rela\./d;s/^.*: { *\(.*\)}$/      \1/' $COMBRELOC
+cat <<EOF
+    }${RO_REGION}
+  .rela.dyn     ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rel\./d;s/^.*: { *\(.*\)}/      \1/' $COMBRELOC
+cat <<EOF
+    }${RO_REGION}
+EOF
+fi
+cat <<EOF
+  .rel.plt      ${RELOCATING-0} : { *(.rel.plt) }${RO_REGION}
+  .rela.plt     ${RELOCATING-0} : { *(.rela.plt) }${RO_REGION}
+  ${OTHER_PLT_RELOC_SECTIONS}
+
+  .init         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${INIT_START}}
+    KEEP (*(.init))
+    ${RELOCATING+${INIT_END}}
+  }${RO_REGION} =${NOP-0}
+
+  ${DATA_PLT-${BSS_PLT-${PLT}${RO_REGION}}}
+  .text         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${TEXT_START_SYMBOLS}}
+    *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
+    KEEP (*(.text.*personality*))
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    ${RELOCATING+${OTHER_TEXT_SECTIONS}}
+  }${RO_REGION} =${NOP-0}
+  .fini         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${FINI_START}}
+    KEEP (*(.fini))
+    ${RELOCATING+${FINI_END}}
+  }${RO_REGION} =${NOP-0}
+  ${RELOCATING+PROVIDE (__etext = .);}
+  ${RELOCATING+PROVIDE (_etext = .);}
+  ${RELOCATING+PROVIDE (etext = .);}
+  ${WRITABLE_RODATA-${RODATA}${RO_REGION}}
+  .rodata1      ${RELOCATING-0} : { *(.rodata1) }${RO_REGION}
+  ${CREATE_SHLIB-${SDATA2}}
+  ${CREATE_SHLIB-${SBSS2}}
+  ${OTHER_READONLY_SECTIONS}
+  .eh_frame_hdr : { *(.eh_frame_hdr) }${RO_REGION}
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }${RO_REGION}
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }${RO_REGION}
+
+  ${RELOCATING+${DALIGN}}
+  ${RELOCATING+PROVIDE (_data = ORIGIN(${RW_VMA_REGION}));}
+  . = ORIGIN(${RW_VMA_REGION});
+  /* Exception handling  */
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.eh_frame)) }${RW_REGION}
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }${RW_REGION}
+
+  /* Thread Local Storage sections  */
+  .tdata	${RELOCATING-0} : { *(.tdata${RELOCATING+ .tdata.* .gnu.linkonce.td.*}) }${RW_REGION}
+  .tbss		${RELOCATING-0} : { *(.tbss${RELOCATING+ .tbss.* .gnu.linkonce.tb.*})${RELOCATING+ *(.tcommon)} }${RW_REGION}
+
+  /* Ensure the __preinit_array_start label is properly aligned.  We
+     could instead move the label definition inside the section, but
+     the linker would then create the section even if it turns out to
+     be empty, which isn't pretty.  */
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__preinit_array_start = ALIGN(${ALIGNMENT}));}}
+  .preinit_array   ${RELOCATING-0} : { KEEP (*(.preinit_array)) }${RW_REGION}
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__preinit_array_end = .);}}
+
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__init_array_start = .);}}
+  .init_array   ${RELOCATING-0} : { KEEP (*(.init_array)) }${RW_REGION}
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__init_array_end = .);}}
+
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__fini_array_start = .);}}
+  .fini_array   ${RELOCATING-0} : { KEEP (*(.fini_array)) }${RW_REGION}
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__fini_array_end = .);}}
+
+  ${SMALL_DATA_CTOR-${RELOCATING+${CTOR}${RW_REGION}}}
+  ${SMALL_DATA_DTOR-${RELOCATING+${DTOR}${RW_REGION}}}
+  .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }${RW_REGION}
+
+  ${RELOCATING+${DATARELRO}}
+  ${OTHER_RELRO_SECTIONS}
+  ${TEXT_DYNAMIC-${DYNAMIC}${RW_REGION}}
+  ${NO_SMALL_DATA+${RELRO_NOW+${GOT}${RW_REGION}}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT+${GOT}${RW_REGION}}}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT+${GOTPLT}${RW_REGION}}}}
+  ${RELOCATING+${DATA_SEGMENT_RELRO_END}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT-${GOT}${RW_REGION}}}}
+
+  ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}${RW_REGION}}}
+
+  .data         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${DATA_START_SYMBOLS}}
+    *(.data${RELOCATING+ .data.* .gnu.linkonce.d.*})
+    KEEP (*(.gnu.linkonce.d.*personality*))
+    ${CONSTRUCTING+SORT(CONSTRUCTORS)}
+  }${RW_REGION}
+  .data1        ${RELOCATING-0} : { *(.data1) }${RW_REGION}
+  ${WRITABLE_RODATA+${RODATA}${RW_REGION}}
+  ${OTHER_READWRITE_SECTIONS}
+  ${SMALL_DATA_CTOR+${RELOCATING+${CTOR}${RW_REGION}}}
+  ${SMALL_DATA_DTOR+${RELOCATING+${DTOR}${RW_REGION}}}
+  ${DATA_PLT+${PLT_BEFORE_GOT+${PLT}${RW_REGION}}}
+  ${RELOCATING+${OTHER_GOT_SYMBOLS}}
+  ${NO_SMALL_DATA-${GOT}${RW_REGION}}
+  ${OTHER_GOT_SECTIONS}
+  ${SDATA}
+  ${OTHER_SDATA_SECTIONS}
+  ${RELOCATING+${BALIGN}}
+  ${RELOCATING+_edata = .;}
+  ${RELOCATING+PROVIDE (edata = .);}
+  ${RELOCATING+__bss_start = .;}
+  ${RELOCATING+${OTHER_BSS_SYMBOLS}}
+  ${SBSS}
+  ${BSS_PLT+${PLT}${RW_REGION}}
+  .bss          ${RELOCATING-0} :
+  {
+   *(.dynbss)
+   *(.bss${RELOCATING+ .bss.* .gnu.linkonce.b.*})
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.  */
+   ${RELOCATING+. = ALIGN(${BSS_ALIGNMENT});}
+  }${RW_REGION}
+  ${OTHER_BSS_SECTIONS}
+  ${RELOCATING+. = ALIGN(${BSS_ALIGNMENT});}
+  ${RELOCATING+_end = .;}
+  ${RELOCATING+${OTHER_BSS_END_SYMBOLS}}
+  ${RELOCATING+PROVIDE (end = .);}
+  ${RELOCATING+${DATA_SEGMENT_END}}
+
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+
+  .comment       0 : { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+
+  ${STACK_ADDR+${STACK}}
+  ${OTHER_SECTIONS}
+  ${RELOCATING+${OTHER_END_SYMBOLS}}
+  ${RELOCATING+${STACKNOTE}}
+}
+EOF
--- /dev/null
+++ b/ld/testsuite/ld-avr32/avr32.exp
@@ -0,0 +1,25 @@
+# Expect script for AVR32 ELF linker tests.
+#   Copyright 2004-2006 Atmel Corporation.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# Written by Haavard Skinnemoen (hskinnemoen@atmel.com)
+#
+
+if ![istarget avr32-*-*] {
+    return
+}
+
+run_dump_test "pcrel"
--- /dev/null
+++ b/ld/testsuite/ld-avr32/pcrel.d
@@ -0,0 +1,74 @@
+#name: AVR32 ELF PC-relative external relocs
+#source: symbols.s
+#source: ../../../gas/testsuite/gas/avr32/pcrel.s
+#ld: -T $srcdir/$subdir/pcrel.ld
+#objdump: -d
+
+.*:     file format elf.*avr32.*
+
+Disassembly of section .text:
+
+a0000000 <_start>:
+a0000000:	d7 03       	nop
+a0000002:	d7 03       	nop
+
+a0000004 <test_rjmp>:
+a0000004:	d7 03       	nop
+a0000006:	c0 28       	rjmp a000000a <test_rjmp\+0x6>
+a0000008:	d7 03       	nop
+a000000a:	e0 8f 01 fb 	bral a0000400 <extsym10>
+
+a000000e <test_rcall>:
+a000000e:	d7 03       	nop
+a0000010 <test_rcall2>:
+a0000010:	c0 2c       	rcall a0000014 <test_rcall2\+0x4>
+a0000012:	d7 03       	nop
+a0000014:	ee b0 ff f6 	rcall a0200000 <extsym21>
+
+a0000018 <test_branch>:
+a0000018:	c0 31       	brne a000001e <test_branch\+0x6>
+a000001a:	fe 9f ff ff 	bral a0000018 <test_branch>
+a000001e:	ee 90 ff f1 	breq a0200000 <extsym21>
+
+a0000022 <test_lddpc>:
+a0000022:	48 30       	lddpc r0,a000002c <sym1>
+a0000024:	48 20       	lddpc r0,a000002c <sym1>
+a0000026:	fe f0 7f da 	ld.w r0,pc\[32730\]
+	...
+
+a000002c <sym1>:
+a000002c:	d7 03       	nop
+a000002e:	d7 03       	nop
+
+a0000030 <test_local>:
+a0000030:	48 20       	lddpc r0,a0000038 <test_local\+0x8>
+a0000032:	48 30       	lddpc r0,a000003c <test_local\+0xc>
+a0000034:	48 20       	lddpc r0,a000003c <test_local\+0xc>
+a0000036:	00 00       	add r0,r0
+a0000038:	d7 03       	nop
+a000003a:	d7 03       	nop
+a000003c:	d7 03       	nop
+a000003e:	d7 03       	nop
+
+Disassembly of section \.text\.init:
+a0000040 <test_inter_section>:
+a0000040:	fe b0 ff e7 	rcall a000000e <test_rcall>
+a0000044:	d7 03       	nop
+a0000046:	fe b0 ff e4 	rcall a000000e <test_rcall>
+a000004a:	fe b0 ff e3 	rcall a0000010 <test_rcall2>
+a000004e:	d7 03       	nop
+a0000050:	fe b0 ff e0 	rcall a0000010 <test_rcall2>
+
+Disassembly of section \.text\.pcrel10:
+
+a0000400 <extsym10>:
+a0000400:	d7 03       	nop
+
+Disassembly of section \.text\.pcrel16:
+
+a0008000 <extsym16>:
+a0008000:	d7 03       	nop
+
+Disassembly of section \.text\.pcrel21:
+a0200000 <extsym21>:
+a0200000:	d7 03       	nop
--- /dev/null
+++ b/ld/testsuite/ld-avr32/pcrel.ld
@@ -0,0 +1,23 @@
+ENTRY(_start)
+SECTIONS
+{
+	.text 0xa0000000:
+	{
+		*(.text)
+	}
+
+	.text.pcrel10 0xa0000400:
+	{
+		*(.text.pcrel10)
+	}
+
+	.text.pcrel16 0xa0008000:
+	{
+		*(.text.pcrel16)
+	}
+
+	.text.pcrel21 0xa0200000:
+	{
+		*(.text.pcrel21)
+	}
+}
--- /dev/null
+++ b/ld/testsuite/ld-avr32/symbols.s
@@ -0,0 +1,20 @@
+	.text
+	.global _start
+_start:
+	nop
+	nop
+
+	.section .text.pcrel10,"ax"
+	.global extsym10
+extsym10:
+	nop
+
+	.section .text.pcrel16,"ax"
+	.global extsym16
+extsym16:
+	nop
+
+	.section .text.pcrel21,"ax"
+	.global extsym21
+extsym21:
+	nop
--- /dev/null
+++ b/opcodes/avr32-asm.c
@@ -0,0 +1,264 @@
+/* Assembler interface for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include <string.h>
+
+#include "avr32-opc.h"
+#include "avr32-asm.h"
+
+/* Structure for a register hash table entry.  */
+struct reg_entry
+{
+  const char	*name;
+  int		number;
+};
+
+/* Integer Registers.  */
+static const struct reg_entry reg_table[] =
+  {
+    /* Primary names (used by the disassembler) */
+    { "r0",   0 }, { "r1",   1 }, { "r2",   2 }, { "r3",   3 },
+    { "r4",   4 }, { "r5",   5 }, { "r6",   6 }, { "r7",   7 },
+    { "r8",   8 }, { "r9",   9 }, { "r10", 10 }, { "r11", 11 },
+    { "r12", 12 }, { "sp",  13 }, { "lr",  14 }, { "pc",  15 },
+    /* Alternatives to sp, lr and pc.  */
+    { "r13", 13 }, { "r14", 14 }, { "r15", 15 },
+  };
+#define AVR32_NR_INTREGS (sizeof(reg_table)/sizeof(reg_table[0]))
+
+/* Coprocessor Registers.  */
+static const struct reg_entry cr_table[] =
+  {
+    { "cr0",   0 }, { "cr1",   1 }, { "cr2",   2 }, { "cr3",   3 },
+    { "cr4",   4 }, { "cr5",   5 }, { "cr6",   6 }, { "cr7",   7 },
+    { "cr8",   8 }, { "cr9",   9 }, { "cr10", 10 }, { "cr11", 11 },
+    { "cr12", 12 }, { "cr13", 13 }, { "cr14", 14 }, { "cr15", 15 },
+  };
+#define AVR32_NR_CPREGS (sizeof(cr_table)/sizeof(cr_table[0]))
+
+/* Floating-point Registers.  */
+static const struct reg_entry fr_table[] =
+  {
+    { "fr0",   0 }, { "fr1",   1 }, { "fr2",   2 }, { "fr3",   3 },
+    { "fr4",   4 }, { "fr5",   5 }, { "fr6",   6 }, { "fr7",   7 },
+    { "fr8",   8 }, { "fr9",   9 }, { "fr10", 10 }, { "fr11", 11 },
+    { "fr12", 12 }, { "fr13", 13 }, { "fr14", 14 }, { "fr15", 15 },
+  };
+#define AVR32_NR_FPREGS (sizeof(fr_table)/sizeof(fr_table[0]))
+
+/* PiCo Registers.  */
+static const struct reg_entry pico_table[] =
+  {
+    { "inpix2",    0 }, { "inpix1",    1 }, { "inpix0",    2 },
+    { "outpix2",   3 }, { "outpix1",   4 }, { "outpix0",   5 },
+    { "coeff0_a",  6 }, { "coeff0_b",  7 }, { "coeff1_a",  8 },
+    { "coeff1_b",  9 }, { "coeff2_a", 10 }, { "coeff2_b", 11 },
+    { "vmu0_out", 12 }, { "vmu1_out", 13 }, { "vmu2_out", 14 },
+    { "config",   15 },
+  };
+#define AVR32_NR_PICOREGS (sizeof(pico_table)/sizeof(pico_table[0]))
+
+int
+avr32_parse_intreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_INTREGS; i++)
+    {
+      if (strcasecmp(reg_table[i].name, str) == 0)
+	return reg_table[i].number;
+    }
+
+  return -1;
+}
+
+int
+avr32_parse_cpreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_CPREGS; i++)
+    {
+      if (strcasecmp(cr_table[i].name, str) == 0)
+	return cr_table[i].number;
+    }
+
+  return -1;
+}
+
+int avr32_parse_fpreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_FPREGS; i++)
+    {
+      if (strcasecmp(fr_table[i].name, str) == 0)
+	return fr_table[i].number;
+    }
+
+  return -1;
+}
+
+int avr32_parse_picoreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_PICOREGS; i++)
+    {
+      if (strcasecmp(pico_table[i].name, str) == 0)
+	return pico_table[i].number;
+    }
+
+  return -1;
+}
+
+static unsigned long
+parse_reglist(char *str, char **endptr, int (*parse_reg)(const char *))
+{
+  int reg_from, reg_to;
+  unsigned long result = 0;
+  char *p1, *p2, c;
+
+  while (*str)
+    {
+      for (p1 = str; *p1; p1++)
+	if (*p1 == ',' || *p1 == '-')
+	  break;
+
+      c = *p1, *p1 = 0;
+      reg_from = parse_reg(str);
+      *p1 = c;
+
+      if (reg_from < 0)
+	break;
+
+      if (*p1 == '-')
+	{
+	  for (p2 = ++p1; *p2; p2++)
+	    if (*p2 == ',')
+	      break;
+
+	  c = *p2, *p2 = 0;
+	  /* printf("going to parse reg_to from `%s'\n", p1); */
+	  reg_to = parse_reg(p1);
+	  *p2 = c;
+
+	  if (reg_to < 0)
+	    break;
+
+	  while (reg_from <= reg_to)
+	    result |= (1 << reg_from++);
+	  p1 = p2;
+	}
+      else
+	result |= (1 << reg_from);
+
+      str = p1;
+      if (*str) ++str;
+    }
+
+  if (endptr)
+    *endptr = str;
+
+  return result;
+}
+
+unsigned long
+avr32_parse_reglist(char *str, char **endptr)
+{
+  return parse_reglist(str, endptr, avr32_parse_intreg);
+}
+
+unsigned long
+avr32_parse_cpreglist(char *str, char **endptr)
+{
+  return parse_reglist(str, endptr, avr32_parse_cpreg);
+}
+
+unsigned long
+avr32_parse_pico_reglist(char *str, char **endptr)
+{
+  return parse_reglist(str, endptr, avr32_parse_picoreg);
+}
+
+int
+avr32_make_regmask8(unsigned long regmask16, unsigned long *regmask8)
+{
+  unsigned long result = 0;
+
+  /* printf("convert regmask16 0x%04lx\n", regmask16); */
+
+  if (regmask16 & 0xf)
+    {
+      if ((regmask16 & 0xf) == 0xf)
+	result |= 1 << 0;
+      else
+	return -1;
+    }
+  if (regmask16 & 0xf0)
+    {
+      if ((regmask16 & 0xf0) == 0xf0)
+	result |= 1 << 1;
+      else
+	return -1;
+    }
+  if (regmask16 & 0x300)
+    {
+      if ((regmask16 & 0x300) == 0x300)
+	result |= 1 << 2;
+      else
+	return -1;
+    }
+  if (regmask16 & (1 << 13))
+    return -1;
+
+  if (regmask16 & (1 << 10))
+    result |= 1 << 3;
+  if (regmask16 & (1 << 11))
+    result |= 1 << 4;
+  if (regmask16 & (1 << 12))
+    result |= 1 << 5;
+  if (regmask16 & (1 << 14))
+    result |= 1 << 6;
+  if (regmask16 & (1 << 15))
+    result |= 1 << 7;
+
+  *regmask8 = result;
+
+  return 0;
+}
+
+#if 0
+struct reg_map
+{
+  const struct reg_entry	*names;
+  int				nr_regs;
+  struct hash_control		*htab;
+  const char			*errmsg;
+};
+
+struct reg_map all_reg_maps[] =
+  {
+    { reg_table, AVR32_NR_INTREGS, NULL, N_("integral register expected") },
+    { cr_table,  AVR32_NR_CPREGS,  NULL, N_("coprocessor register expected") },
+  };
+#endif
--- /dev/null
+++ b/opcodes/avr32-asm.h
@@ -0,0 +1,42 @@
+/* Assembler interface for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+#ifndef __OPCODES_AVR32_ASM_H
+#define __OPCODES_AVR32_ASM_H
+
+extern int
+avr32_parse_intreg(const char *str);
+extern int
+avr32_parse_cpreg(const char *str);
+extern int
+avr32_parse_fpreg(const char *str);
+extern int
+avr32_parse_picoreg(const char *str);
+extern unsigned long
+avr32_parse_reglist(char *str, char **endptr);
+extern unsigned long
+avr32_parse_cpreglist(char *str, char **endptr);
+extern unsigned long
+avr32_parse_pico_reglist(char *str, char **endptr);
+extern int
+avr32_make_regmask8(unsigned long regmask16, unsigned long *regmask8);
+
+#endif /* __OPCODES_AVR32_ASM_H */
--- /dev/null
+++ b/opcodes/avr32-dis.c
@@ -0,0 +1,891 @@
+/* Print AVR32 instructions for GDB and objdump.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include "avr32-opc.h"
+#include "opintl.h"
+#include "safe-ctype.h"
+
+/* TODO: Share this with -asm */
+
+/* Structure for a register hash table entry.  */
+struct reg_entry
+{
+  const char	*name;
+  int		number;
+};
+
+#ifndef strneq
+#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
+#endif
+
+
+static const struct reg_entry reg_table[] =
+  {
+    /* Primary names (used by the disassembler) */
+    { "r0",   0 }, { "r1",   1 }, { "r2",   2 }, { "r3",   3 },
+    { "r4",   4 }, { "r5",   5 }, { "r6",   6 }, { "r7",   7 },
+    { "r8",   8 }, { "r9",   9 }, { "r10", 10 }, { "r11", 11 },
+    { "r12", 12 }, { "sp",  13 }, { "lr",  14 }, { "pc",  15 },
+    /* Alternatives to sp, lr and pc.  */
+    { "r13", 13 }, { "r14", 14 }, { "r15", 15 },
+  };
+#define AVR32_NR_INTREGS (sizeof(reg_table)/sizeof(reg_table[0]))
+
+/* Coprocessor Registers.  */
+static const struct reg_entry cr_table[] =
+  {
+    { "cr0",   0 }, { "cr1",   1 }, { "cr2",   2 }, { "cr3",   3 },
+    { "cr4",   4 }, { "cr5",   5 }, { "cr6",   6 }, { "cr7",   7 },
+    { "cr8",   8 }, { "cr9",   9 }, { "cr10", 10 }, { "cr11", 11 },
+    { "cr12", 12 }, { "cr13", 13 }, { "cr14", 14 }, { "cr15", 15 },
+  };
+#define AVR32_NR_CPREGS (sizeof(cr_table)/sizeof(cr_table[0]))
+
+static const char bparts[4] = { 'b', 'l', 'u', 't' };
+static bfd_vma current_pc;
+
+struct avr32_field_value
+{
+  const struct avr32_ifield *ifield;
+  unsigned long value;
+};
+
+struct avr32_operand
+{
+  int id;
+  int is_pcrel;
+  int align_order;
+  int (*print)(struct avr32_operand *op, struct disassemble_info *info,
+	       struct avr32_field_value *ifields);
+};
+
+static signed long
+get_signed_value(const struct avr32_field_value *fv)
+{
+  signed long value = fv->value;
+
+  if (fv->value & (1 << (fv->ifield->bitsize - 1)))
+    value |= (~0UL << fv->ifield->bitsize);
+
+  return value;
+}
+
+static void
+print_reglist_range(unsigned int first, unsigned int last,
+		    const struct reg_entry *reg_names,
+		    int need_comma,
+		    struct disassemble_info *info)
+{
+  if (need_comma)
+    info->fprintf_func(info->stream, ",");
+
+  if (first == last)
+    info->fprintf_func(info->stream, "%s",
+		       reg_names[first].name);
+  else
+    info->fprintf_func(info->stream, "%s-%s",
+		       reg_names[first].name, reg_names[last].name);
+}
+
+static int
+print_intreg(struct avr32_operand *op,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  unsigned long regid = ifields[0].value << op->align_order;
+
+  info->fprintf_func(info->stream, "%s",
+		     reg_table[regid].name);
+  return 1;
+}
+
+static int
+print_intreg_predec(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		    struct disassemble_info *info,
+		    struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "--%s",
+		     reg_table[ifields[0].value].name);
+  return 1;
+}
+
+static int
+print_intreg_postinc(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		     struct disassemble_info *info,
+		     struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s++",
+		     reg_table[ifields[0].value].name);
+  return 1;
+}
+
+static int
+print_intreg_lsl(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		 struct disassemble_info *info,
+		 struct avr32_field_value *ifields)
+{
+  const char *rp = reg_table[ifields[0].value].name;
+  unsigned long sa = ifields[1].value;
+
+  if (sa)
+    info->fprintf_func(info->stream, "%s<<0x%lx", rp, sa);
+  else
+    info->fprintf_func(info->stream, "%s", rp);
+
+  return 2;
+}
+
+static int
+print_intreg_lsr(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		 struct disassemble_info *info,
+		 struct avr32_field_value *ifields)
+{
+  const char *rp = reg_table[ifields[0].value].name;
+  unsigned long sa = ifields[1].value;
+
+  if (sa)
+    info->fprintf_func(info->stream, "%s>>0x%lx", rp, sa);
+  else
+    info->fprintf_func(info->stream, "%s", rp);
+
+  return 2;
+}
+
+static int
+print_intreg_bpart(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s:%c",
+		     reg_table[ifields[0].value].name,
+		     bparts[ifields[1].value]);
+  return 2;
+}
+
+static int
+print_intreg_hpart(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s:%c",
+		     reg_table[ifields[0].value].name,
+		     ifields[1].value ? 't' : 'b');
+  return 2;
+}
+
+static int
+print_intreg_sdisp(struct avr32_operand *op,
+		  struct disassemble_info *info,
+		  struct avr32_field_value *ifields)
+{
+  signed long disp;
+
+  disp = get_signed_value(&ifields[1]) << op->align_order;
+
+  info->fprintf_func(info->stream, "%s[%ld]",
+		     reg_table[ifields[0].value].name, disp);
+  return 2;
+}
+
+static int
+print_intreg_udisp(struct avr32_operand *op,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s[0x%lx]",
+		     reg_table[ifields[0].value].name,
+		     ifields[1].value << op->align_order);
+  return 2;
+}
+
+static int
+print_intreg_index(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  const char *rb, *ri;
+  unsigned long sa = ifields[2].value;
+
+  rb = reg_table[ifields[0].value].name;
+  ri = reg_table[ifields[1].value].name;
+
+  if (sa)
+    info->fprintf_func(info->stream, "%s[%s<<0x%lx]", rb, ri, sa);
+  else
+    info->fprintf_func(info->stream, "%s[%s]", rb, ri);
+
+  return 3;
+}
+
+static int
+print_intreg_xindex(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		    struct disassemble_info *info,
+		    struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s[%s:%c<<2]",
+		     reg_table[ifields[0].value].name,
+		     reg_table[ifields[1].value].name,
+		     bparts[ifields[2].value]);
+  return 3;
+}
+
+static int
+print_jmplabel(struct avr32_operand *op,
+	       struct disassemble_info *info,
+	       struct avr32_field_value *ifields)
+{
+  bfd_vma address, offset;
+
+  offset = get_signed_value(ifields) << op->align_order;
+  address = (current_pc & (~0UL << op->align_order)) + offset;
+
+  info->print_address_func(address, info);
+
+  return 1;
+}
+
+static int
+print_pc_disp(struct avr32_operand *op,
+	      struct disassemble_info *info,
+	      struct avr32_field_value *ifields)
+{
+  bfd_vma address, offset;
+
+  offset = ifields[0].value << op->align_order;
+  address = (current_pc & (~0UL << op->align_order)) + offset;
+
+  info->print_address_func(address, info);
+
+  return 1;
+}
+
+static int
+print_sp(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	 struct disassemble_info *info,
+	 struct avr32_field_value *ifields ATTRIBUTE_UNUSED)
+{
+  info->fprintf_func(info->stream, "sp");
+  return 1;
+}
+
+static int
+print_sp_disp(struct avr32_operand *op,
+	      struct disassemble_info *info,
+	      struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "sp[0x%lx]",
+		     ifields[0].value << op->align_order);
+  return 1;
+}
+
+static int
+print_cpno(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	   struct disassemble_info *info,
+	   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "cp%lu", ifields[0].value);
+  return 1;
+}
+
+static int
+print_cpreg(struct avr32_operand *op,
+	    struct disassemble_info *info,
+	    struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "cr%lu",
+		     ifields[0].value << op->align_order);
+  return 1;
+}
+
+static int
+print_uconst(struct avr32_operand *op,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "0x%lx",
+		     ifields[0].value << op->align_order);
+  return 1;
+}
+
+static int
+print_sconst(struct avr32_operand *op,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%ld",
+		     get_signed_value(ifields) << op->align_order);
+  return 1;
+}
+
+static int
+print_reglist8_head(unsigned long regmask, int *commap,
+		    struct disassemble_info *info)
+{
+  int first = -1, last, i = 0;
+  int need_comma = 0;
+
+  while (i < 12)
+    {
+      if (first == -1 && (regmask & 1))
+	{
+	  first = i;
+	}
+      else if (first != -1 && !(regmask & 1))
+	{
+	  last = i - 1;
+
+	  print_reglist_range(first, last, reg_table, need_comma, info);
+	  need_comma = 1;
+	  first = -1;
+	}
+
+      if (i < 8)
+	i += 4;
+      else if (i < 10)
+	i += 2;
+      else
+	i++;
+      regmask >>= 1;
+    }
+
+  *commap = need_comma;
+  return first;
+}
+
+static void
+print_reglist8_tail(unsigned long regmask, int first, int need_comma,
+		    struct disassemble_info *info)
+{
+  int last = 11;
+
+  if (regmask & 0x20)
+    {
+      if (first == -1)
+	first = 12;
+      last = 12;
+    }
+
+  if (first != -1)
+    {
+      print_reglist_range(first, last, reg_table, need_comma, info);
+      need_comma = 1;
+      first = -1;
+    }
+
+  if (regmask & 0x40)
+    {
+      if (first == -1)
+	first = 14;
+      last = 14;
+    }
+
+  if (regmask & 0x80)
+    {
+      if (first == -1)
+	first = 15;
+      last = 15;
+    }
+
+  if (first != -1)
+    print_reglist_range(first, last, reg_table, need_comma, info);
+}
+
+static int
+print_reglist8(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	       struct disassemble_info *info,
+	       struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  int first, need_comma;
+
+  first = print_reglist8_head(regmask, &need_comma, info);
+  print_reglist8_tail(regmask, first, need_comma, info);
+
+  return 1;
+}
+
+static int
+print_reglist9(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	       struct disassemble_info *info,
+	       struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value >> 1;
+  int first, last, need_comma;
+
+  first = print_reglist8_head(regmask, &need_comma, info);
+
+  if ((ifields[0].value & 0x101) == 0x101)
+    {
+      if (first != -1)
+	{
+	  last = 11;
+
+	  print_reglist_range(first, last, reg_table, need_comma, info);
+	  need_comma = 1;
+	  first = -1;
+	}
+
+      print_reglist_range(15, 15, reg_table, need_comma, info);
+
+      regmask >>= 5;
+
+      if ((regmask & 3) == 0)
+	info->fprintf_func(info->stream, ",r12=0");
+      else if ((regmask & 3) == 1)
+	info->fprintf_func(info->stream, ",r12=1");
+      else
+	info->fprintf_func(info->stream, ",r12=-1");
+    }
+  else
+      print_reglist8_tail(regmask, first, need_comma, info);
+
+  return 1;
+}
+
+static int
+print_reglist16(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		struct disassemble_info *info,
+		struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  unsigned int i = 0, first, last;
+  int need_comma = 0;
+
+  while (i < 16)
+    {
+      if (regmask & 1)
+	{
+	  first = i;
+	  while (i < 16)
+	    {
+	      i++;
+	      regmask >>= 1;
+	      if (!(regmask & 1))
+		break;
+	    }
+	  last = i - 1;
+	  print_reglist_range(first, last, reg_table, need_comma, info);
+	  need_comma = 1;
+	}
+      else
+	{
+	  i++;
+	  regmask >>= 1;
+	}
+    }
+
+  return 1;
+}
+
+static int
+print_reglist_ldm(struct avr32_operand *op,
+		  struct disassemble_info *info,
+		  struct avr32_field_value *ifields)
+{
+  int rp, w_bit;
+  int i, first, last;
+  unsigned long regmask;
+
+  rp = ifields[0].value;
+  w_bit = ifields[1].value;
+  regmask = ifields[2].value;
+
+  if (regmask & (1 << AVR32_REG_PC) && rp == AVR32_REG_PC)
+    {
+      if (w_bit)
+	info->fprintf_func(info->stream, "sp++");
+      else
+	info->fprintf_func(info->stream, "sp");
+
+      for (i = 0; i < 12; )
+	{
+	  if (regmask & (1 << i))
+	    {
+	      first = i;
+	      while (i < 12)
+		{
+		  i++;
+		  if (!(regmask & (1 << i)))
+		    break;
+		}
+	      last = i - 1;
+	      print_reglist_range(first, last, reg_table, 1, info);
+	    }
+	  else
+	    i++;
+	}
+
+      info->fprintf_func(info->stream, ",pc");
+      if (regmask & (1 << AVR32_REG_LR))
+	info->fprintf_func(info->stream, ",r12=-1");
+      else if (regmask & (1 << AVR32_REG_R12))
+	info->fprintf_func(info->stream, ",r12=1");
+      else
+	info->fprintf_func(info->stream, ",r12=0");
+    }
+  else
+    {
+      if (w_bit)
+	info->fprintf_func(info->stream, "%s++,", reg_table[rp].name);
+      else
+	info->fprintf_func(info->stream, "%s,", reg_table[rp].name);
+
+      print_reglist16(op, info, ifields + 2);
+    }
+
+  return 3;
+}
+
+static int
+print_reglist_cp8(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		  struct disassemble_info *info,
+		  struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  unsigned int i = 0, first, last, offset = 0;
+  int need_comma = 0;
+
+  if (ifields[1].value)
+    offset = 8;
+
+  while (i < 8)
+    {
+      if (regmask & 1)
+	{
+	  first = i;
+	  while (i < 8)
+	    {
+	      i++;
+	      regmask >>= 1;
+	      if (!(regmask & 1))
+		break;
+	    }
+	  last = i - 1;
+	  print_reglist_range(offset + first, offset + last,
+			      cr_table, need_comma, info);
+	  need_comma = 1;
+	}
+      else
+	{
+	  i++;
+	  regmask >>= 1;
+	}
+    }
+
+  return 2;
+}
+
+static int
+print_reglist_cpd8(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  unsigned int i = 0, first, last;
+  int need_comma = 0;
+
+  while (i < 8)
+    {
+      if (regmask & 1)
+	{
+	  first = 2 * i;
+	  while (i < 8)
+	    {
+	      i++;
+	      regmask >>= 1;
+	      if (!(regmask & 1))
+		break;
+	    }
+	  last = 2 * (i - 1) + 1;
+	  print_reglist_range(first, last, cr_table, need_comma, info);
+	  need_comma = 1;
+	}
+      else
+	{
+	  i++;
+	  regmask >>= 1;
+	}
+    }
+
+  return 1;
+}
+
+static int
+print_retval(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  unsigned long regid = ifields[0].value;
+  const char *retval;
+
+  if (regid < AVR32_REG_SP)
+    retval = reg_table[regid].name;
+  else if (regid == AVR32_REG_SP)
+    retval = "0";
+  else if (regid == AVR32_REG_LR)
+    retval = "-1";
+  else
+    retval = "1";
+
+  info->fprintf_func(info->stream, "%s", retval);
+
+  return 1;
+}
+
+static int
+print_mcall(struct avr32_operand *op,
+	    struct disassemble_info *info,
+	    struct avr32_field_value *ifields)
+{
+  unsigned long regid = ifields[0].value;
+
+  if (regid == AVR32_REG_PC)
+    print_jmplabel(op, info, ifields + 1);
+  else
+    print_intreg_sdisp(op, info, ifields);
+
+  return 2;
+}
+
+static int
+print_jospinc(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	      struct disassemble_info *info,
+	      struct avr32_field_value *ifields)
+{
+  signed long value = ifields[0].value;
+
+  if (value >= 4)
+    value -= 8;
+  else
+    value += 1;
+
+  info->fprintf_func(info->stream, "%ld", value);
+
+  return 1;
+}
+
+static int
+print_coh(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	  struct disassemble_info *info,
+	  struct avr32_field_value *ifields ATTRIBUTE_UNUSED)
+{
+  info->fprintf_func(info->stream, "COH");
+  return 0;
+}
+
+#define OP(name, sgn, pcrel, align, func) \
+  { AVR32_OPERAND_##name, pcrel, align, print_##func }
+
+struct avr32_operand operand[AVR32_NR_OPERANDS] =
+  {
+    OP(INTREG, 0, 0, 0, intreg),
+    OP(INTREG_PREDEC, 0, 0, 0, intreg_predec),
+    OP(INTREG_POSTINC, 0, 0, 0, intreg_postinc),
+    OP(INTREG_LSL, 0, 0, 0, intreg_lsl),
+    OP(INTREG_LSR, 0, 0, 0, intreg_lsr),
+    OP(INTREG_BSEL, 0, 0, 0, intreg_bpart),
+    OP(INTREG_HSEL, 0, 0, 1, intreg_hpart),
+    OP(INTREG_SDISP, 1, 0, 0, intreg_sdisp),
+    OP(INTREG_SDISP_H, 1, 0, 1, intreg_sdisp),
+    OP(INTREG_SDISP_W, 1, 0, 2, intreg_sdisp),
+    OP(INTREG_UDISP, 0, 0, 0, intreg_udisp),
+    OP(INTREG_UDISP_H, 0, 0, 1, intreg_udisp),
+    OP(INTREG_UDISP_W, 0, 0, 2, intreg_udisp),
+    OP(INTREG_INDEX, 0, 0, 0, intreg_index),
+    OP(INTREG_XINDEX, 0, 0, 0, intreg_xindex),
+    OP(DWREG, 0, 0, 1, intreg),
+    OP(PC_UDISP_W, 0, 1, 2, pc_disp),
+    OP(SP, 0, 0, 0, sp),
+    OP(SP_UDISP_W, 0, 0, 2, sp_disp),
+    OP(CPNO, 0, 0, 0, cpno),
+    OP(CPREG, 0, 0, 0, cpreg),
+    OP(CPREG_D, 0, 0, 1, cpreg),
+    OP(UNSIGNED_CONST, 0, 0, 0, uconst),
+    OP(UNSIGNED_CONST_W, 0, 0, 2, uconst),
+    OP(SIGNED_CONST, 1, 0, 0, sconst),
+    OP(SIGNED_CONST_W, 1, 0, 2, sconst),
+    OP(JMPLABEL, 1, 1, 1, jmplabel),
+    OP(UNSIGNED_NUMBER, 0, 0, 0, uconst),
+    OP(UNSIGNED_NUMBER_W, 0, 0, 2, uconst),
+    OP(REGLIST8, 0, 0, 0, reglist8),
+    OP(REGLIST9, 0, 0, 0, reglist9),
+    OP(REGLIST16, 0, 0, 0, reglist16),
+    OP(REGLIST_LDM, 0, 0, 0, reglist_ldm),
+    OP(REGLIST_CP8, 0, 0, 0, reglist_cp8),
+    OP(REGLIST_CPD8, 0, 0, 0, reglist_cpd8),
+    OP(RETVAL, 0, 0, 0, retval),
+    OP(MCALL, 1, 0, 2, mcall),
+    OP(JOSPINC, 0, 0, 0, jospinc),
+    OP(COH, 0, 0, 0, coh),
+  };
+
+static void
+print_opcode(bfd_vma insn_word, const struct avr32_opcode *opc,
+	     bfd_vma pc, struct disassemble_info *info)
+{
+  const struct avr32_syntax *syntax = opc->syntax;
+  struct avr32_field_value fields[AVR32_MAX_FIELDS];
+  unsigned int i, next_field = 0, nr_operands;
+
+  for (i = 0; i < opc->nr_fields; i++)
+    {
+      opc->fields[i]->extract(opc->fields[i], &insn_word, &fields[i].value);
+      fields[i].ifield = opc->fields[i];
+    }
+
+  current_pc = pc;
+  info->fprintf_func(info->stream, "%s", syntax->mnemonic->name);
+
+  if (syntax->nr_operands < 0)
+    nr_operands = (unsigned int) -syntax->nr_operands;
+  else
+    nr_operands = (unsigned int) syntax->nr_operands;
+
+  for (i = 0; i < nr_operands; i++)
+    {
+      struct avr32_operand *op = &operand[syntax->operand[i]];
+
+      if (i)
+	info->fprintf_func(info->stream, ",");
+      else
+	info->fprintf_func(info->stream, "\t");
+      next_field += op->print(op, info, &fields[next_field]);
+    }
+}
+
+static const struct avr32_opcode *
+find_opcode(bfd_vma insn_word)
+{
+  int i;
+
+  for (i = 0; i < AVR32_NR_OPCODES; i++)
+    {
+      const struct avr32_opcode *opc = &avr32_opc_table[i];
+
+      if ((insn_word & opc->mask) == opc->value)
+	return opc;
+    }
+
+  return NULL;
+}
+
+static int
+read_insn_word(bfd_vma pc, bfd_vma *valuep,
+	       struct disassemble_info *info)
+{
+  bfd_byte b[4];
+  int status;
+
+  status = info->read_memory_func(pc, b, 4, info);
+  if (status)
+    {
+      status = info->read_memory_func(pc, b, 2, info);
+      if (status)
+	{
+	  info->memory_error_func(status, pc, info);
+	  return -1;
+	}
+      b[3] = b[2] = 0;
+    }
+
+  *valuep =  (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];
+  return 0;
+}
+
+/* Parse an individual disassembler option.  */
+
+void
+parse_avr32_disassembler_option (option)
+     char * option;
+{
+  if (option == NULL)
+    return;
+
+  /* XXX - should break 'option' at following delimiter.  */
+  fprintf (stderr, _("Unrecognised disassembler option: %s\n"), option);
+
+  return;
+}
+
+/* Parse the string of disassembler options, spliting it at whitespaces
+   or commas.  (Whitespace separators supported for backwards compatibility).  */
+
+static void
+parse_disassembler_options (char *options)
+{
+  if (options == NULL)
+    return;
+
+  while (*options)
+    {
+      parse_avr32_disassembler_option (options);
+
+      /* Skip forward to next seperator.  */
+      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
+	++ options;
+      /* Skip forward past seperators.  */
+      while (ISSPACE (*options) || (*options == ','))
+	++ options;
+    }
+}
+
+int
+print_insn_avr32(bfd_vma pc, struct disassemble_info *info)
+{
+  bfd_vma insn_word;
+  const struct avr32_opcode *opc;
+
+  if (info->disassembler_options)
+    {
+      parse_disassembler_options (info->disassembler_options);
+
+      /* To avoid repeated parsing of these options, we remove them here.  */
+      info->disassembler_options = NULL;
+    }
+
+  info->bytes_per_chunk = 1;
+  info->display_endian = BFD_ENDIAN_BIG;
+
+  if (read_insn_word(pc, &insn_word, info))
+    return -1;
+
+  opc = find_opcode(insn_word);
+  if (opc)
+    {
+      print_opcode(insn_word, opc, pc, info);
+      return opc->size;
+    }
+  else
+    {
+      info->fprintf_func(info->stream, _("*unknown*"));
+      return 2;
+    }
+
+}
+
+void
+print_avr32_disassembler_options (FILE *stream ATTRIBUTE_UNUSED)
+{
+
+}
--- /dev/null
+++ b/opcodes/avr32-opc.c
@@ -0,0 +1,6932 @@
+/* Opcode tables for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include <stdlib.h>
+#include <assert.h>
+
+#include "avr32-opc.h"
+
+#define PICO_CPNO	1
+
+void
+avr32_insert_simple(const struct avr32_ifield *field,
+		    void *buf, unsigned long value)
+{
+  bfd_vma word;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  word |= (value << field->shift) & field->mask;
+  bfd_putb32(word, buf);
+}
+
+void
+avr32_insert_bit5c(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+		   void *buf, unsigned long value)
+{
+  char *opcode = buf;
+
+  opcode[0] = (opcode[0] & 0xe1) | (value & 0x1e);
+  opcode[1] = (opcode[1] & 0xef) | ((value & 1) << 4);
+}
+
+void
+avr32_insert_k10(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+		 void *buf, unsigned long value)
+{
+  char *opcode = buf;
+
+  opcode[0] = (opcode[0] & 0xf0) | ((value & 0xf0) >> 4);
+  opcode[1] = ((opcode[1] & 0x0c) | ((value & 0x0f) << 4)
+	       | ((value & 0x300) >> 8));
+}
+
+
+void
+avr32_insert_k21(const struct avr32_ifield *field,
+		 void *buf, unsigned long value)
+{
+  bfd_vma word;
+  bfd_vma k21;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  k21 = ((value & 0xffff) | ((value & 0x10000) << 4)
+	 | ((value & 0x1e0000) << 8));
+  assert(!(k21 & ~field->mask));
+  word |= k21;
+  bfd_putb32(word, buf);
+}
+
+void
+avr32_insert_cpop(const struct avr32_ifield *field,
+		  void *buf, unsigned long value)
+{
+  bfd_vma word;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  word |= (((value & 0x1e) << 15) | ((value & 0x60) << 20)
+	   | ((value & 0x01) << 12));
+  bfd_putb32(word, buf);
+}
+
+void
+avr32_insert_k12cp(const struct avr32_ifield *field,
+		   void *buf, unsigned long value)
+{
+  bfd_vma word;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  word |= ((value & 0xf00) << 4) | (value & 0xff);
+  bfd_putb32(word, buf);
+}
+
+void avr32_extract_simple(const struct avr32_ifield *field,
+			  void *buf, unsigned long *value)
+{
+  /* XXX: The disassembler has done any necessary byteswapping already */
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = (word & field->mask) >> field->shift;
+}
+
+void avr32_extract_bit5c(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+			 void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word >> 20) & 1) | ((word >> 24) & 0x1e);
+}
+
+void avr32_extract_k10(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+		       void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word >> 8) & 0x300) | ((word >> 20) & 0xff);
+}
+
+void avr32_extract_k21(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+		       void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word & 0xffff) | ((word >> 4) & 0x10000)
+	    | ((word >> 8) & 0x1e0000));
+}
+
+void avr32_extract_cpop(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+			void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = (((word >> 12) & 1) | ((word >> 15) & 0x1e)
+	    | ((word >> 20) & 0x60));
+}
+
+void avr32_extract_k12cp(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+			 void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word >> 4) & 0xf00) | (word & 0xff);
+}
+
+
+#define IFLD(id, bitsz, shift, mask, func) \
+  { AVR32_IFIELD_##id, bitsz, shift, mask, \
+    avr32_insert_##func, avr32_extract_##func }
+
+const struct avr32_ifield avr32_ifield_table[] =
+  {
+    IFLD(RX, 4, 25, 0x1e000000, simple),
+    IFLD(RY, 4, 16, 0x000f0000, simple),
+    IFLD(COND4C, 4, 20, 0x00f00000, simple),
+    IFLD(K8C, 8, 20, 0x0ff00000, simple),
+    IFLD(K7C, 7, 20, 0x07f00000, simple),
+    IFLD(K5C, 5, 20, 0x01f00000, simple),
+    IFLD(K3, 3, 20, 0x00700000, simple),
+    IFLD(RY_DW, 3, 17, 0x000e0000, simple),
+    IFLD(COND4E, 4, 8, 0x00000f00, simple),
+    IFLD(K8E, 8, 0, 0x000000ff, simple),
+    IFLD(BIT5C, 5, 20, 0x1e100000, bit5c),
+    IFLD(COND3, 3, 16, 0x00070000, simple),
+    IFLD(K10, 10, 16, 0x0ff30000, k10),
+    IFLD(POPM, 9, 19, 0x0ff80000, simple),
+    IFLD(K2, 2, 4, 0x00000030, simple),
+    IFLD(RD_E, 4, 0, 0x0000000f, simple),
+    IFLD(RD_DW, 3, 1, 0x0000000e, simple),
+    IFLD(X, 1, 5, 0x00000020, simple),
+    IFLD(Y, 1, 4, 0x00000010, simple),
+    IFLD(X2, 1, 13, 0x00002000, simple),
+    IFLD(Y2, 1, 12, 0x00001000, simple),
+    IFLD(K5E, 5, 0, 0x0000001f, simple),
+    IFLD(PART2, 2, 0, 0x00000003, simple),
+    IFLD(PART1, 1, 0, 0x00000001, simple),
+    IFLD(K16, 16, 0, 0x0000ffff, simple),
+    IFLD(CACHEOP, 5, 11, 0x0000f800, simple),
+    IFLD(K11, 11, 0, 0x000007ff, simple),
+    IFLD(K21, 21, 0, 0x1e10ffff, k21),
+    IFLD(CPOP, 7, 12, 0x060f1000, cpop),
+    IFLD(CPNO, 3, 13, 0x0000e000, simple),
+    IFLD(CRD_RI, 4, 8, 0x00000f00, simple),
+    IFLD(CRX, 4, 4, 0x000000f0, simple),
+    IFLD(CRY, 4, 0, 0x0000000f, simple),
+    IFLD(K7E, 7, 0, 0x0000007f, simple),
+    IFLD(CRD_DW, 3, 9, 0x00000e00, simple),
+    IFLD(PART1_K12, 1, 12, 0x00001000, simple),
+    IFLD(PART2_K12, 2, 12, 0x00003000, simple),
+    IFLD(K12, 12, 0, 0x00000fff, simple),
+    IFLD(S5, 5, 5, 0x000003e0, simple),
+    IFLD(K5E2, 5, 4, 0x000001f0, simple),
+    IFLD(K4, 4, 20, 0x00f00000, simple),
+    IFLD(COND4E2, 4, 4, 0x000000f0, simple),
+    IFLD(K8E2, 8, 4, 0x00000ff0, simple),
+    IFLD(K6, 6, 20, 0x03f00000, simple),
+    IFLD(MEM15, 15, 0, 0x00007fff, simple),
+    IFLD(MEMB5, 5, 15, 0x000f8000, simple),
+    IFLD(W, 1, 25, 0x02000000, simple),
+    /* Coprocessor Multiple High/Low */
+    IFLD(CM_HL, 1, 8, 0x00000100, simple),
+    IFLD(K12CP, 12 ,0, 0x0000f0ff, k12cp),
+    IFLD(K9E, 9 ,0, 0x000001ff, simple),
+  };
+#undef IFLD
+
+
+struct avr32_opcode avr32_opc_table[] =
+  {
+    {
+      AVR32_OPC_ABS, 2, 0x5c400000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ABS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_ACALL, 2, 0xd0000000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_ACALL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_ACR, 2, 0x5c000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ACR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ADC, 4, 0xe0000040, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADC],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ADD1, 2, 0x00000000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ADD1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_ADD2, 4, 0xe0000000, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADD2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_ADDABS, 4, 0xe0000e40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADDABS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ADDHH_W, 4, 0xe0000e00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADDHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_AND1, 2, 0x00600000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_AND1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_AND2, 4, 0xe1e00000, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_AND2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_AND3, 4, 0xe1e00200, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_AND3],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_ANDH, 4, 0xe4100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDH_COH, 4, 0xe6100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDH_COH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDL, 4, 0xe0100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDL],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDL_COH, 4, 0xe2100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDL_COH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDN, 2, 0x00800000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDN],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_ASR1, 4, 0xe0000840, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_ASR1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ASR3, 4, 0xe0001400, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_ASR3],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_ASR2, 2, 0xa1400000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ASR2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_BLD, 4, 0xedb00000, 0xfff0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_BLD],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_BREQ1, 2, 0xc0000000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREQ1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRNE1, 2, 0xc0010000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRNE1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRCC1, 2, 0xc0020000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRCC1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRCS1, 2, 0xc0030000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRCS1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRGE1, 2, 0xc0040000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRGE1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRLT1, 2, 0xc0050000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLT1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRMI1, 2, 0xc0060000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRMI1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRPL1, 2, 0xc0070000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRPL1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BREQ2, 4, 0xe0800000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREQ2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRNE2, 4, 0xe0810000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRNE2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRCC2, 4, 0xe0820000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRHS2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRCS2, 4, 0xe0830000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLO2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRGE2, 4, 0xe0840000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRGE2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRLT2, 4, 0xe0850000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLT2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRMI2, 4, 0xe0860000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRMI2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRPL2, 4, 0xe0870000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRPL2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRLS, 4, 0xe0880000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLS],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRGT, 4, 0xe0890000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRGT],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRLE, 4, 0xe08a0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLE],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRHI, 4, 0xe08b0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRHI],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRVS, 4, 0xe08c0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRVS],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRVC, 4, 0xe08d0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRVC],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRQS, 4, 0xe08e0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRQS],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRAL, 4, 0xe08f0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRAL],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BREAKPOINT, 2, 0xd6730000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREAKPOINT],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_BREV, 2, 0x5c900000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREV],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_BST, 4, 0xefb00000, 0xfff0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_BST],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_CACHE, 4, 0xf4100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CACHE],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K11],
+	&avr32_ifield_table[AVR32_IFIELD_CACHEOP],
+      },
+    },
+    {
+      AVR32_OPC_CASTS_B, 2, 0x5c600000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTS_B],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CASTS_H, 2, 0x5c800000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTS_H],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CASTU_B, 2, 0x5c500000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTU_B],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CASTU_H, 2, 0x5c700000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTU_H],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CBR, 2, 0xa1c00000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CBR],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_CLZ, 4, 0xe0001200, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CLZ],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_COM, 2, 0x5cd00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_COM],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_COP, 4, 0xe1a00000, 0xf9f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_COP],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_CRX],
+	&avr32_ifield_table[AVR32_IFIELD_CRY],
+	&avr32_ifield_table[AVR32_IFIELD_CPOP],
+      },
+    },
+    {
+      AVR32_OPC_CP_B, 4, 0xe0001800, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_B],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CP_H, 4, 0xe0001900, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_H],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CP_W1, 2, 0x00300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_W1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CP_W2, 2, 0x58000000, 0xfc000000,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_W2],
+      BFD_RELOC_AVR32_6S, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K6],
+      },
+    },
+    {
+      AVR32_OPC_CP_W3, 4, 0xe0400000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_W3],
+      BFD_RELOC_AVR32_21S, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_CPC1, 4, 0xe0001300, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CPC1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CPC2, 2, 0x5c200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CPC2],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CSRF, 2, 0xd4030000, 0xfe0f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_CSRF],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_CSRFCZ, 2, 0xd0030000, 0xfe0f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_CSRFCZ],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_DIVS, 4, 0xe0000c00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_DIVS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_DIVU, 4, 0xe0000d00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_DIVU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_EOR1, 2, 0x00500000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_EOR1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_EOR2, 4, 0xe1e02000, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_EOR2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E2],
+      }
+    },
+    {
+      AVR32_OPC_EOR3, 4, 0xe1e02200, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_EOR3],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E2],
+      }
+    },
+    {
+      AVR32_OPC_EORL, 4, 0xec100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_EORL],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_EORH, 4, 0xee100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_EORH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_FRS, 2, 0xd7430000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_FRS],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_ICALL, 2, 0x5d100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ICALL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_INCJOSP, 2, 0xd6830000, 0xff8f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_INCJOSP],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_D1, 2, 0xa1010000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_D2, 2, 0xa1100000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_D3, 2, 0xa1000000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D3],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_D5, 4, 0xe0000200, 0xe1f0ffc1,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_D4, 4, 0xe0e00000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_SB2, 4, 0xe0000600, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SB2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_SB1, 4, 0xe1200000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SB1],
+      BFD_RELOC_AVR32_16S, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB1, 2, 0x01300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB2, 2, 0x01700000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB5, 4, 0xe0000700, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB3, 2, 0x01800000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB3],
+      BFD_RELOC_AVR32_3U, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB4, 4, 0xe1300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH1, 2, 0x01100000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH2, 2, 0x01500000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH5, 4, 0xe0000400, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH3, 2, 0x80000000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH3],
+      BFD_RELOC_AVR32_4UH, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH4, 4, 0xe1000000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH1, 2, 0x01200000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH2, 2, 0x01600000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH5, 4, 0xe0000500, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH3, 2, 0x80800000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH3],
+      BFD_RELOC_AVR32_4UH, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH4, 4, 0xe1100000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_W1, 2, 0x01000000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_W2, 2, 0x01400000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_W5, 4, 0xe0000300, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_W6, 4, 0xe0000f80, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W6],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_W3, 2, 0x60000000, 0xe0000000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W3],
+      BFD_RELOC_AVR32_7UW, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_LD_W4, 4, 0xe0f00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDC_D1, 4, 0xe9a01000, 0xfff01100,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_D1],
+      BFD_RELOC_AVR32_10UW, 4, 3,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDC_D2, 4, 0xefa00050, 0xfff011ff,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_D2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LDC_D3, 4, 0xefa01040, 0xfff011c0,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_D3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LDC_W1, 4, 0xe9a00000, 0xfff01000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_W1],
+      BFD_RELOC_AVR32_10UW, 4, 3,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDC_W2, 4, 0xefa00040, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_W2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LDC_W3, 4, 0xefa01000, 0xfff010c0,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_W3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LDC0_D, 4, 0xf3a00000, 0xfff00100,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC0_D],
+      BFD_RELOC_AVR32_14UW, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K12CP],
+      },
+    },
+    {
+      AVR32_OPC_LDC0_W, 4, 0xf1a00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC0_W],
+      BFD_RELOC_AVR32_14UW, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K12CP],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_D, 4, 0xeda00400, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_D_PU, 4, 0xeda01400, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_D_PU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_W, 4, 0xeda00000, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_W_PU, 4, 0xeda01000, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_W_PU],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_LDDPC, 2, 0x48000000, 0xf8000000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDDPC],
+      BFD_RELOC_AVR32_9UW_PCREL, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K7C],
+      },
+    },
+    {
+      AVR32_OPC_LDDPC_EXT, 4, 0xfef00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDDPC_EXT],
+      BFD_RELOC_AVR32_16B_PCREL, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDDSP, 2, 0x40000000, 0xf8000000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDDSP],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K7C],
+      },
+    },
+    {
+      AVR32_OPC_LDINS_B, 4, 0xe1d04000, 0xe1f0c000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDINS_B],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_PART2_K12],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDINS_H, 4, 0xe1d00000, 0xe1f0e000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDINS_H],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_PART1_K12],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDM, 4, 0xe1c00000, 0xfdf00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDM],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_W],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDMTS, 4, 0xe5c00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDMTS],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDMTS_PU, 4, 0xe7c00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDMTS_PU],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDSWP_SH, 4, 0xe1d02000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDSWP_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDSWP_UH, 4, 0xe1d03000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDSWP_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDSWP_W, 4, 0xe1d08000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDSWP_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LSL1, 4, 0xe0000940, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSL1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LSL3, 4, 0xe0001500, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSL3],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_LSL2, 2, 0xa1600000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LSL2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_LSR1, 4, 0xe0000a40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSR1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LSR3, 4, 0xe0001600, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSR3],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_LSR2, 2, 0xa1800000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LSR2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_MAC, 4, 0xe0000340, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MAC],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MACHH_D, 4, 0xe0000580, 0xe1f0ffc1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACHH_D],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MACHH_W, 4, 0xe0000480, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MACHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MACS_D, 4, 0xe0000540, 0xe1f0fff1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACS_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MACSATHH_W, 4, 0xe0000680, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MACSATHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MACUD, 4, 0xe0000740, 0xe1f0fff1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACUD],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MACWH_D, 4, 0xe0000c80, 0xe1f0ffe1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACWH_D],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MAX, 4, 0xe0000c40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MAX],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MCALL, 4, 0xf0100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MCALL],
+      BFD_RELOC_AVR32_18W_PCREL, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_MFDR, 4, 0xe5b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MFDR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MFSR, 4, 0xe1b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MFSR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MIN, 4, 0xe0000d40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MIN],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MOV3, 2, 0x00900000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOV3],
+      BFD_RELOC_NONE, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOV1, 2, 0x30000000, 0xf0000000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOV1],
+      BFD_RELOC_AVR32_8S, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_MOV2, 4, 0xe0600000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOV2],
+      BFD_RELOC_AVR32_21S, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_MOVEQ1, 4, 0xe0001700, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVEQ1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVNE1, 4, 0xe0001710, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVNE1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVCC1, 4, 0xe0001720, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVCS1, 4, 0xe0001730, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLO1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVGE1, 4, 0xe0001740, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGE1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVLT1, 4, 0xe0001750, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLT1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVMI1, 4, 0xe0001760, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVMI1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVPL1, 4, 0xe0001770, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVPL1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVLS1, 4, 0xe0001780, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVGT1, 4, 0xe0001790, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGT1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVLE1, 4, 0xe00017a0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLE1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVHI1, 4, 0xe00017b0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHI1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVVS1, 4, 0xe00017c0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVVC1, 4, 0xe00017d0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVC1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVQS1, 4, 0xe00017e0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVQS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVAL1, 4, 0xe00017f0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVAL1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVEQ2, 4, 0xf9b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVEQ2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVNE2, 4, 0xf9b00100, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVNE2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVCC2, 4, 0xf9b00200, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVCS2, 4, 0xf9b00300, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLO2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVGE2, 4, 0xf9b00400, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGE2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVLT2, 4, 0xf9b00500, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLT2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVMI2, 4, 0xf9b00600, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVMI2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVPL2, 4, 0xf9b00700, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVPL2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVLS2, 4, 0xf9b00800, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVGT2, 4, 0xf9b00900, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGT2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVLE2, 4, 0xf9b00a00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLE2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVHI2, 4, 0xf9b00b00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHI2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVVS2, 4, 0xf9b00c00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVVC2, 4, 0xf9b00d00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVC2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVQS2, 4, 0xf9b00e00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVQS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVAL2, 4, 0xf9b00f00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVAL2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MTDR, 4, 0xe7b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MTDR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MTSR, 4, 0xe3b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MTSR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MUL1, 2, 0xa1300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MUL1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MUL2, 4, 0xe0000240, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MUL2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MUL3, 4, 0xe0001000, 0xe1f0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MUL3],
+      BFD_RELOC_AVR32_8S_EXT, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MULHH_W, 4, 0xe0000780, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULNHH_W, 4, 0xe0000180, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULNHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULNWH_D, 4, 0xe0000280, 0xe1f0ffe1,
+      &avr32_syntax_table[AVR32_SYNTAX_MULNWH_D],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSD, 4, 0xe0000440, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSD],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MULSATHH_H, 4, 0xe0000880, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATHH_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATHH_W, 4, 0xe0000980, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATRNDHH_H, 4, 0xe0000a80, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATRNDHH_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATRNDWH_W, 4, 0xe0000b80, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATRNDWH_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATWH_W, 4, 0xe0000e80, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATWH_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULU_D, 4, 0xe0000640, 0xe1f0fff1,
+      &avr32_syntax_table[AVR32_SYNTAX_MULU_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MULWH_D, 4, 0xe0000d80, 0xe1f0ffe1,
+      &avr32_syntax_table[AVR32_SYNTAX_MULWH_D],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MUSFR, 2, 0x5d300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MUSFR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_MUSTR, 2, 0x5d200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MUSTR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_MVCR_D, 4, 0xefa00010, 0xfff111ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVCR_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_MVCR_W, 4, 0xefa00000, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVCR_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_MVRC_D, 4, 0xefa00030, 0xfff111ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVRC_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_MVRC_W, 4, 0xefa00020, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVRC_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_NEG, 2, 0x5c300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_NEG],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_NOP, 2, 0xd7030000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_NOP],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_OR1, 2, 0x00400000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_OR1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_OR2, 4, 0xe1e01000, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_OR2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_OR3, 4, 0xe1e01200, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_OR3],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_ORH, 4, 0xea100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ORH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ORL, 4, 0xe8100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ORL],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_PABS_SB, 4, 0xe00023e0, 0xfff0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PABS_SB],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PABS_SH, 4, 0xe00023f0, 0xfff0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PABS_SH],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PACKSH_SB, 4, 0xe00024d0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PACKSH_SB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PACKSH_UB, 4, 0xe00024c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PACKSH_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PACKW_SH, 4, 0xe0002470, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PACKW_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADD_B, 4, 0xe0002300, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADD_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADD_H, 4, 0xe0002000, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADD_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDH_SH, 4, 0xe00020c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDH_UB, 4, 0xe0002360, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDH_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_SB, 4, 0xe0002320, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_SB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_SH, 4, 0xe0002040, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_UB, 4, 0xe0002340, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_UH, 4, 0xe0002080, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUB_H, 4, 0xe0002100, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUB_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUBH_SH, 4, 0xe0002280, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUBH_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUBS_SH, 4, 0xe0002180, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUBS_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUBS_UH, 4, 0xe0002200, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUBS_UH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDX_H, 4, 0xe0002020, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDX_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDXH_SH, 4, 0xe00020e0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDXH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDXS_SH, 4, 0xe0002060, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDXS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDXS_UH, 4, 0xe00020a0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDXS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PASR_B, 4, 0xe0002410, 0xe1f8fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PASR_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_COND3],
+      },
+    },
+    {
+      AVR32_OPC_PASR_H, 4, 0xe0002440, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PASR_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PAVG_SH, 4, 0xe00023d0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PAVG_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PAVG_UB, 4, 0xe00023c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PAVG_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PLSL_B, 4, 0xe0002420, 0xe1f8fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSL_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_COND3],
+      },
+    },
+    {
+      AVR32_OPC_PLSL_H, 4, 0xe0002450, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSL_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PLSR_B, 4, 0xe0002430, 0xe1f8fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSR_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_COND3],
+      },
+    },
+    {
+      AVR32_OPC_PLSR_H, 4, 0xe0002460, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSR_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMAX_SH, 4, 0xe0002390, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMAX_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMAX_UB, 4, 0xe0002380, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMAX_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMIN_SH, 4, 0xe00023b0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMIN_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMIN_UB, 4, 0xe00023a0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMIN_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_POPJC, 2, 0xd7130000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_POPJC],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_POPM, 2, 0xd0020000, 0xf0070000,
+      &avr32_syntax_table[AVR32_SYNTAX_POPM],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_POPM],
+      },
+    },
+    {
+      AVR32_OPC_POPM_E, 4, 0xe3cd0000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_POPM_E],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_PREF, 4, 0xf2100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_PREF],
+      BFD_RELOC_AVR32_16S, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_PSAD, 4, 0xe0002400, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSAD],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUB_B, 4, 0xe0002310, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUB_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUB_H, 4, 0xe0002010, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADD_H, 4, 0xe0002140, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADD_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADDH_SH, 4, 0xe00022c0, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADDH_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADDS_SH, 4, 0xe00021c0, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADDS_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADDS_UH, 4, 0xe0002240, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADDS_UH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBH_SH, 4, 0xe00020d0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBH_UB, 4, 0xe0002370, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBH_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_SB, 4, 0xe0002330, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_SB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_SH, 4, 0xe0002050, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_UB, 4, 0xe0002350, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_UH, 4, 0xe0002090, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBX_H, 4, 0xe0002030, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBX_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBXH_SH, 4, 0xe00020f0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBXH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBXS_SH, 4, 0xe0002070, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBXS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBXS_UH, 4, 0xe00020b0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBXS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PUNPCKSB_H, 4, 0xe00024a0, 0xe1ffffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_PUNPCKSB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PUNPCKUB_H, 4, 0xe0002480, 0xe1ffffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_PUNPCKUB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PUSHJC, 2, 0xd7230000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_PUSHJC],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_PUSHM, 2, 0xd0010000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_PUSHM],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_PUSHM_E, 4, 0xebcd0000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_PUSHM_E],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_RCALL1, 2, 0xc00c0000, 0xf00c0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RCALL1],
+      BFD_RELOC_AVR32_11H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K10],
+      },
+    },
+    {
+      AVR32_OPC_RCALL2, 4, 0xe0a00000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RCALL2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_RETEQ, 2, 0x5e000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETEQ],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETNE, 2, 0x5e100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETNE],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETCC, 2, 0x5e200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETHS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETCS, 2, 0x5e300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLO],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETGE, 2, 0x5e400000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETGE],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETLT, 2, 0x5e500000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLT],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETMI, 2, 0x5e600000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETMI],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETPL, 2, 0x5e700000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETPL],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETLS, 2, 0x5e800000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETGT, 2, 0x5e900000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETGT],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETLE, 2, 0x5ea00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLE],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETHI, 2, 0x5eb00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETHI],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETVS, 2, 0x5ec00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETVS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETVC, 2, 0x5ed00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETVC],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETQS, 2, 0x5ee00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETQS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETAL, 2, 0x5ef00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETAL],
+      BFD_RELOC_NONE, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETD, 2, 0xd6230000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETD],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RETE, 2, 0xd6030000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETE],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RETJ, 2, 0xd6330000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETJ],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RETS, 2, 0xd6130000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETS],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RJMP, 2, 0xc0080000, 0xf00c0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RJMP],
+      BFD_RELOC_AVR32_11H_PCREL, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K10],
+      },
+    },
+    {
+      AVR32_OPC_ROL, 2, 0x5cf00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ROL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_ROR, 2, 0x5d000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ROR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_RSUB1, 2, 0x00200000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RSUB1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_RSUB2, 4, 0xe0001100, 0xe1f0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_RSUB2],
+      BFD_RELOC_AVR32_8S_EXT, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SATADD_H, 4, 0xe00002c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATADD_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATADD_W, 4, 0xe00000c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATADD_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATRNDS, 4, 0xf3b00000, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATRNDS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SATRNDU, 4, 0xf3b00400, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATRNDU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SATS, 4, 0xf1b00000, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SATSUB_H, 4, 0xe00003c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATSUB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATSUB_W1, 4, 0xe00001c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATSUB_W1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATSUB_W2, 4, 0xe0d00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SATSUB_W2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_SATU, 4, 0xf1b00400, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SBC, 4, 0xe0000140, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SBC],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SBR, 2, 0xa1a00000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SBR],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_SCALL, 2, 0xd7330000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_SCALL],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_SCR, 2, 0x5c100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SCR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SLEEP, 4, 0xe9b00000, 0xffffff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SLEEP],
+      BFD_RELOC_AVR32_8S_EXT, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SREQ, 2, 0x5f000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SREQ],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRNE, 2, 0x5f100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRNE],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRCC, 2, 0x5f200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRHS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRCS, 2, 0x5f300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLO],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRGE, 2, 0x5f400000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRGE],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRLT, 2, 0x5f500000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLT],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRMI, 2, 0x5f600000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRMI],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRPL, 2, 0x5f700000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRPL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRLS, 2, 0x5f800000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRGT, 2, 0x5f900000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRGT],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRLE, 2, 0x5fa00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLE],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRHI, 2, 0x5fb00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRHI],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRVS, 2, 0x5fc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRVS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRVC, 2, 0x5fd00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRVC],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRQS, 2, 0x5fe00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRQS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRAL, 2, 0x5ff00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRAL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SSRF, 2, 0xd2030000, 0xfe0f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_SSRF],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_ST_B1, 2, 0x00c00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_B2, 2, 0x00f00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_B5, 4, 0xe0000b00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+      },
+    },
+    {
+      AVR32_OPC_ST_B3, 2, 0xa0800000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B3],
+      BFD_RELOC_AVR32_3U, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K3],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_B4, 4, 0xe1600000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_D1, 2, 0xa1200000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D2, 2, 0xa1210000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D3, 2, 0xa1110000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D3],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D5, 4, 0xe0000800, 0xe1f0ffc1,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_RD_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D4, 4, 0xe0e10000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+	&avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_H1, 2, 0x00b00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_H2, 2, 0x00e00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_H5, 4, 0xe0000a00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+      },
+    },
+    {
+      AVR32_OPC_ST_H3, 2, 0xa0000000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H3],
+      BFD_RELOC_AVR32_4UH, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K3],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_H4, 4, 0xe1500000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W1, 2, 0x00a00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W2, 2, 0x00d00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W5, 4, 0xe0000900, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+      },
+    },
+    {
+      AVR32_OPC_ST_W3, 2, 0x81000000, 0xe1000000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W3],
+      BFD_RELOC_AVR32_6UW, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K4],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W4, 4, 0xe1400000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STC_D1, 4, 0xeba01000, 0xfff01100,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_D1],
+      BFD_RELOC_AVR32_10UW, 4, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC_D2, 4, 0xefa00070, 0xfff011f0,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_D2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC_D3, 4, 0xefa010c0, 0xfff011c0,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_D3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC_W1, 4, 0xeba00000, 0xfff01000,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_W1],
+      BFD_RELOC_AVR32_10UW, 4, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STC_W2, 4, 0xefa00060, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_W2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STC_W3, 4, 0xefa01080, 0xfff010c0,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_W3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STC0_D, 4, 0xf7a00000, 0xfff00100,
+      &avr32_syntax_table[AVR32_SYNTAX_STC0_D],
+      BFD_RELOC_AVR32_14UW, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K12CP],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC0_W, 4, 0xf5a00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STC0_W],
+      BFD_RELOC_AVR32_14UW, 3, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K12CP],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STCM_D, 4, 0xeda00500, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_STCM_D_PU, 4, 0xeda01500, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_D_PU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_STCM_W, 4, 0xeda00200, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_STCM_W_PU, 4, 0xeda01200, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_W_PU],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_CPNO],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+	&avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_STCOND, 4, 0xe1700000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STCOND],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STDSP, 2, 0x50000000, 0xf8000000,
+      &avr32_syntax_table[AVR32_SYNTAX_STDSP],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K7C],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STHH_W2, 4, 0xe1e08000, 0xe1f0c0c0,
+      &avr32_syntax_table[AVR32_SYNTAX_STHH_W2],
+      BFD_RELOC_UNUSED, 7, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X2],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y2],
+      },
+    },
+    {
+      AVR32_OPC_STHH_W1, 4, 0xe1e0c000, 0xe1f0c000,
+      &avr32_syntax_table[AVR32_SYNTAX_STHH_W1],
+      BFD_RELOC_AVR32_STHH_W, 6, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_K8E2],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X2],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y2],
+      },
+    },
+    {
+      AVR32_OPC_STM, 4, 0xe9c00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STM],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STM_PU, 4, 0xebc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STM_PU],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STMTS, 4, 0xedc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STMTS],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STMTS_PU, 4, 0xefc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STMTS_PU],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STSWP_H, 4, 0xe1d09000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_STSWP_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STSWP_W, 4, 0xe1d0a000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_STSWP_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K12],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SUB1, 2, 0x00100000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_SUB2, 4, 0xe0000100, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_SUB5, 4, 0xe0c00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB5],
+      BFD_RELOC_AVR32_SUB5, 3, 2,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_SUB3_SP, 2, 0x200d0000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB3_SP],
+      BFD_RELOC_AVR32_10SW, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_SUB3, 2, 0x20000000, 0xf0000000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB3],
+      BFD_RELOC_AVR32_8S, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_SUB4, 4, 0xe0200000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB4],
+      BFD_RELOC_AVR32_21S, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_SUBEQ, 4, 0xf7b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBEQ],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBNE, 4, 0xf7b00100, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBNE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBCC, 4, 0xf7b00200, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBHS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBCS, 4, 0xf7b00300, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLO],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBGE, 4, 0xf7b00400, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBGE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBLT, 4, 0xf7b00500, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBMI, 4, 0xf7b00600, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBMI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBPL, 4, 0xf7b00700, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBPL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBLS, 4, 0xf7b00800, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBGT, 4, 0xf7b00900, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBGT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBLE, 4, 0xf7b00a00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBHI, 4, 0xf7b00b00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBHI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBVS, 4, 0xf7b00c00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBVS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBVC, 4, 0xf7b00d00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBVC],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBQS, 4, 0xf7b00e00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBQS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBAL, 4, 0xf7b00f00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBAL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFEQ, 4, 0xf5b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFEQ],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFNE, 4, 0xf5b00100, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFNE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFCC, 4, 0xf5b00200, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFHS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFCS, 4, 0xf5b00300, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLO],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFGE, 4, 0xf5b00400, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFGE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFLT, 4, 0xf5b00500, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFMI, 4, 0xf5b00600, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFMI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFPL, 4, 0xf5b00700, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFPL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFLS, 4, 0xf5b00800, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFGT, 4, 0xf5b00900, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFGT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFLE, 4, 0xf5b00a00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFHI, 4, 0xf5b00b00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFHI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFVS, 4, 0xf5b00c00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFVS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFVC, 4, 0xf5b00d00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFVC],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFQS, 4, 0xf5b00e00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFQS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFAL, 4, 0xf5b00f00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFAL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBHH_W, 4, 0xe0000f00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_X],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_SWAP_B, 2, 0x5cb00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SWAP_B],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_SWAP_BH, 2, 0x5cc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SWAP_BH],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_SWAP_H, 2, 0x5ca00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SWAP_H],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_SYNC, 4, 0xebb00000, 0xffffff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SYNC],
+      BFD_RELOC_AVR32_8S_EXT, 1, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_K8E],
+      }
+    },
+    {
+      AVR32_OPC_TLBR, 2, 0xd6430000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_TLBR],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_TLBS, 2, 0xd6530000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_TLBS],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_TLBW, 2, 0xd6630000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_TLBW],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_TNBZ, 2, 0x5ce00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_TNBZ],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_TST, 2, 0x00700000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_TST],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_XCHG, 4, 0xe0000b40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_XCHG],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MEMC, 4, 0xf6100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MEMC],
+      BFD_RELOC_AVR32_15S, 2, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_MEM15],
+	&avr32_ifield_table[AVR32_IFIELD_MEMB5],
+      },
+    },
+    {
+      AVR32_OPC_MEMS, 4, 0xf8100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MEMS],
+      BFD_RELOC_AVR32_15S, 2, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_MEM15],
+	&avr32_ifield_table[AVR32_IFIELD_MEMB5],
+      },
+    },
+    {
+      AVR32_OPC_MEMT, 4, 0xfa100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MEMT],
+      BFD_RELOC_AVR32_15S, 2, 0,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_MEM15],
+	&avr32_ifield_table[AVR32_IFIELD_MEMB5],
+      },
+    },
+    {
+      AVR32_OPC_BFEXTS, 4, 0xe1d0b000, 0xe1f0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_BFEXTS],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_BFEXTU, 4, 0xe1d0c000, 0xe1f0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_BFEXTU],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_BFINS, 4, 0xe1d0d000, 0xe1f0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_BFINS],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RX],
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_S5],
+	&avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+#define AVR32_OPCODE_RSUBCOND(cond_name, cond_field)                    \
+    {                                                                   \
+      AVR32_OPC_RSUB ## cond_name , 4,                                  \
+      0xfbb00000 | (cond_field << 8), 0xfff0ff00,                       \
+      &avr32_syntax_table[AVR32_SYNTAX_RSUB ## cond_name ],             \
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,                                     \
+      {                                                                 \
+	&avr32_ifield_table[AVR32_IFIELD_RY],                           \
+	&avr32_ifield_table[AVR32_IFIELD_K8E],                          \
+      },                                                                \
+    },
+
+    AVR32_OPCODE_RSUBCOND (EQ, 0) 
+    AVR32_OPCODE_RSUBCOND (NE, 1) 
+    AVR32_OPCODE_RSUBCOND (CC, 2) 
+    AVR32_OPCODE_RSUBCOND (CS, 3) 
+    AVR32_OPCODE_RSUBCOND (GE, 4) 
+    AVR32_OPCODE_RSUBCOND (LT, 5) 
+    AVR32_OPCODE_RSUBCOND (MI, 6) 
+    AVR32_OPCODE_RSUBCOND (PL, 7) 
+    AVR32_OPCODE_RSUBCOND (LS, 8) 
+    AVR32_OPCODE_RSUBCOND (GT, 9) 
+    AVR32_OPCODE_RSUBCOND (LE, 10) 
+    AVR32_OPCODE_RSUBCOND (HI, 11) 
+    AVR32_OPCODE_RSUBCOND (VS, 12) 
+    AVR32_OPCODE_RSUBCOND (VC, 13) 
+    AVR32_OPCODE_RSUBCOND (QS, 14) 
+    AVR32_OPCODE_RSUBCOND (AL, 15) 
+
+#define AVR32_OPCODE_OP3_COND(op_name, op_field, cond_name, cond_field) \
+    {                                                                   \
+      AVR32_OPC_ ## op_name ## cond_name , 4,                           \
+      0xe1d0e000 | (cond_field << 8) | (op_field << 4), 0xe1f0fff0,     \
+      &avr32_syntax_table[AVR32_SYNTAX_ ## op_name ## cond_name ],      \
+      BFD_RELOC_UNUSED, 3, -1,                                          \
+      {                                                                 \
+	&avr32_ifield_table[AVR32_IFIELD_RD_E],                         \
+	&avr32_ifield_table[AVR32_IFIELD_RX],                           \
+	&avr32_ifield_table[AVR32_IFIELD_RY],                           \
+      },                                                                \
+    },
+
+    AVR32_OPCODE_OP3_COND (ADD, 0, EQ, 0)
+    AVR32_OPCODE_OP3_COND (ADD, 0, NE, 1)
+    AVR32_OPCODE_OP3_COND (ADD, 0, CC, 2)
+    AVR32_OPCODE_OP3_COND (ADD, 0, CS, 3)
+    AVR32_OPCODE_OP3_COND (ADD, 0, GE, 4)
+    AVR32_OPCODE_OP3_COND (ADD, 0, LT, 5)
+    AVR32_OPCODE_OP3_COND (ADD, 0, MI, 6)
+    AVR32_OPCODE_OP3_COND (ADD, 0, PL, 7)
+    AVR32_OPCODE_OP3_COND (ADD, 0, LS, 8)
+    AVR32_OPCODE_OP3_COND (ADD, 0, GT, 9)
+    AVR32_OPCODE_OP3_COND (ADD, 0, LE, 10)
+    AVR32_OPCODE_OP3_COND (ADD, 0, HI, 11)
+    AVR32_OPCODE_OP3_COND (ADD, 0, VS, 12)
+    AVR32_OPCODE_OP3_COND (ADD, 0, VC, 13)
+    AVR32_OPCODE_OP3_COND (ADD, 0, QS, 14)
+    AVR32_OPCODE_OP3_COND (ADD, 0, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (SUB2, 1, EQ, 0)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, NE, 1)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, CC, 2)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, CS, 3)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, GE, 4)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, LT, 5)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, MI, 6)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, PL, 7)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, LS, 8)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, GT, 9)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, LE, 10)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, HI, 11)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, VS, 12)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, VC, 13)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, QS, 14)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (AND, 2, EQ, 0)
+    AVR32_OPCODE_OP3_COND (AND, 2, NE, 1)
+    AVR32_OPCODE_OP3_COND (AND, 2, CC, 2)
+    AVR32_OPCODE_OP3_COND (AND, 2, CS, 3)
+    AVR32_OPCODE_OP3_COND (AND, 2, GE, 4)
+    AVR32_OPCODE_OP3_COND (AND, 2, LT, 5)
+    AVR32_OPCODE_OP3_COND (AND, 2, MI, 6)
+    AVR32_OPCODE_OP3_COND (AND, 2, PL, 7)
+    AVR32_OPCODE_OP3_COND (AND, 2, LS, 8)
+    AVR32_OPCODE_OP3_COND (AND, 2, GT, 9)
+    AVR32_OPCODE_OP3_COND (AND, 2, LE, 10)
+    AVR32_OPCODE_OP3_COND (AND, 2, HI, 11)
+    AVR32_OPCODE_OP3_COND (AND, 2, VS, 12)
+    AVR32_OPCODE_OP3_COND (AND, 2, VC, 13)
+    AVR32_OPCODE_OP3_COND (AND, 2, QS, 14)
+    AVR32_OPCODE_OP3_COND (AND, 2, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (OR, 3, EQ, 0)
+    AVR32_OPCODE_OP3_COND (OR, 3, NE, 1)
+    AVR32_OPCODE_OP3_COND (OR, 3, CC, 2)
+    AVR32_OPCODE_OP3_COND (OR, 3, CS, 3)
+    AVR32_OPCODE_OP3_COND (OR, 3, GE, 4)
+    AVR32_OPCODE_OP3_COND (OR, 3, LT, 5)
+    AVR32_OPCODE_OP3_COND (OR, 3, MI, 6)
+    AVR32_OPCODE_OP3_COND (OR, 3, PL, 7)
+    AVR32_OPCODE_OP3_COND (OR, 3, LS, 8)
+    AVR32_OPCODE_OP3_COND (OR, 3, GT, 9)
+    AVR32_OPCODE_OP3_COND (OR, 3, LE, 10)
+    AVR32_OPCODE_OP3_COND (OR, 3, HI, 11)
+    AVR32_OPCODE_OP3_COND (OR, 3, VS, 12)
+    AVR32_OPCODE_OP3_COND (OR, 3, VC, 13)
+    AVR32_OPCODE_OP3_COND (OR, 3, QS, 14)
+    AVR32_OPCODE_OP3_COND (OR, 3, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (EOR, 4, EQ, 0)
+    AVR32_OPCODE_OP3_COND (EOR, 4, NE, 1)
+    AVR32_OPCODE_OP3_COND (EOR, 4, CC, 2)
+    AVR32_OPCODE_OP3_COND (EOR, 4, CS, 3)
+    AVR32_OPCODE_OP3_COND (EOR, 4, GE, 4)
+    AVR32_OPCODE_OP3_COND (EOR, 4, LT, 5)
+    AVR32_OPCODE_OP3_COND (EOR, 4, MI, 6)
+    AVR32_OPCODE_OP3_COND (EOR, 4, PL, 7)
+    AVR32_OPCODE_OP3_COND (EOR, 4, LS, 8)
+    AVR32_OPCODE_OP3_COND (EOR, 4, GT, 9)
+    AVR32_OPCODE_OP3_COND (EOR, 4, LE, 10)
+    AVR32_OPCODE_OP3_COND (EOR, 4, HI, 11)
+    AVR32_OPCODE_OP3_COND (EOR, 4, VS, 12)
+    AVR32_OPCODE_OP3_COND (EOR, 4, VC, 13)
+    AVR32_OPCODE_OP3_COND (EOR, 4, QS, 14)
+    AVR32_OPCODE_OP3_COND (EOR, 4, AL, 15) 
+
+#define AVR32_OPCODE_LD_COND(op_name, op_field, cond_name, cond_field)  \
+    {                                                                   \
+      AVR32_OPC_ ## op_name ## cond_name , 4,                           \
+      0xe1f00000 | (cond_field << 12) | (op_field  << 9), 0xe1f0fe00,   \
+      &avr32_syntax_table[AVR32_SYNTAX_ ## op_name ## cond_name ],      \
+      BFD_RELOC_UNUSED, 3, -1,                                          \
+      {                                                                 \
+	&avr32_ifield_table[AVR32_IFIELD_RY],                           \
+	&avr32_ifield_table[AVR32_IFIELD_RX],                           \
+	&avr32_ifield_table[AVR32_IFIELD_K9E],                          \
+      },                                                                \
+    },
+    
+#define AVR32_OPCODE_ST_COND(op_name, op_field, cond_name, cond_field)  \
+    {                                                                   \
+      AVR32_OPC_ ## op_name ## cond_name , 4,                           \
+      0xe1f00000 | (cond_field << 12) | (op_field  << 9), 0xe1f0fe00,   \
+      &avr32_syntax_table[AVR32_SYNTAX_ ## op_name ## cond_name ],      \
+      BFD_RELOC_UNUSED, 3, -1,                                          \
+      {                                                                 \
+	&avr32_ifield_table[AVR32_IFIELD_RX],                           \
+	&avr32_ifield_table[AVR32_IFIELD_K9E],                          \
+	&avr32_ifield_table[AVR32_IFIELD_RY],                           \
+      },                                                                \
+    },
+
+    AVR32_OPCODE_LD_COND (LD_W, 0, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_SH, 1, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_UH, 2, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_SB, 3, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_UB, 4, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, AL, 15) 
+
+    AVR32_OPCODE_ST_COND (ST_W, 5, EQ, 0) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, NE, 1) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, CC, 2) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, CS, 3) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, GE, 4) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, LT, 5) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, MI, 6) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, PL, 7) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, LS, 8) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, GT, 9) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, LE, 10) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, HI, 11) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, VS, 12) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, VC, 13) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, QS, 14) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, AL, 15) 
+
+    AVR32_OPCODE_ST_COND (ST_H, 6, EQ, 0) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, NE, 1) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, CC, 2) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, CS, 3) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, GE, 4) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, LT, 5) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, MI, 6) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, PL, 7) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, LS, 8) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, GT, 9) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, LE, 10) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, HI, 11) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, VS, 12) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, VC, 13) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, QS, 14) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, AL, 15) 
+
+    AVR32_OPCODE_ST_COND (ST_B, 7, EQ, 0) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, NE, 1) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, CC, 2) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, CS, 3) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, GE, 4) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, LT, 5) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, MI, 6) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, PL, 7) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, LS, 8) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, GT, 9) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, LE, 10) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, HI, 11) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, VS, 12) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, VC, 13) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, QS, 14) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, AL, 15) 
+
+    {
+      AVR32_OPC_MOVH, 4, 0xfc100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVH],
+      BFD_RELOC_AVR32_16U,  2, 1,
+      {
+	&avr32_ifield_table[AVR32_IFIELD_RY],
+	&avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+
+ };
+
+#define FPALIAS_DXY(name, opcode)			\
+  {							\
+    AVR32_ALIAS_##name##_S,				\
+    &avr32_opc_table[AVR32_OPC_COP],			\
+    {							\
+      { 0, 0 },						\
+      { 1, 0 }, { 1, 1 }, { 1, 2 },			\
+      { 0, opcode },					\
+    },							\
+  }, {							\
+    AVR32_ALIAS_##name##_D,				\
+    &avr32_opc_table[AVR32_OPC_COP],			\
+    {							\
+      { 0, 0 },						\
+      { 1, 0 }, { 1, 1 }, { 1, 2 },			\
+      { 0, (opcode) | 0x40 },				\
+    },							\
+  }
+#define FPALIAS_DX(name, opcode)			\
+  {							\
+    AVR32_ALIAS_##name##_S,				\
+    &avr32_opc_table[AVR32_OPC_COP],			\
+    {							\
+      { 0, 0 },						\
+      { 1, 0 }, { 1, 1 }, { 0, 0 },			\
+      { 0, opcode },					\
+    },							\
+  }, {							\
+    AVR32_ALIAS_##name##_D,				\
+    &avr32_opc_table[AVR32_OPC_COP],			\
+    {							\
+      { 0, 0 },						\
+      { 1, 0 }, { 1, 1 }, { 0, 0 },			\
+      { 0, (opcode) | 0x40 },				\
+    },							\
+  }
+#define FPALIAS_XY(name, opcode)			\
+  {							\
+    AVR32_ALIAS_##name##_S,				\
+    &avr32_opc_table[AVR32_OPC_COP],			\
+    {							\
+      { 0, 0 },						\
+      { 0, 0 }, { 1, 0 }, { 1, 1 },			\
+      { 0, opcode },					\
+    },							\
+  }, {							\
+    AVR32_ALIAS_##name##_D,				\
+    &avr32_opc_table[AVR32_OPC_COP],			\
+    {							\
+      { 0, 0 },						\
+      { 0, 0 }, { 1, 0 }, { 1, 1 },			\
+      { 0, (opcode) | 0x40 },				\
+    },							\
+  }
+
+const struct avr32_alias avr32_alias_table[] =
+  {
+    FPALIAS_DXY(FMAC, 0x00),
+    FPALIAS_DXY(FNMAC, 0x01),
+    FPALIAS_DXY(FMSC, 0x02),
+    FPALIAS_DXY(FNMSC, 0x03),
+    FPALIAS_DXY(FADD, 0x04),
+    FPALIAS_DXY(FSUB, 0x05),
+    FPALIAS_DXY(FMUL, 0x06),
+    FPALIAS_DXY(FNMUL, 0x07),
+    FPALIAS_DX(FNEG, 0x08),
+    FPALIAS_DX(FABS, 0x09),
+    FPALIAS_XY(FCMP, 0x0d),
+    FPALIAS_DX(FMOV1, 0x0a),
+    {
+      AVR32_ALIAS_FMOV2_S,
+      &avr32_opc_table[AVR32_OPC_MVCR_W],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FMOV2_D,
+      &avr32_opc_table[AVR32_OPC_MVCR_D],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FMOV3_S,
+      &avr32_opc_table[AVR32_OPC_MVRC_W],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FMOV3_D,
+      &avr32_opc_table[AVR32_OPC_MVRC_D],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FCASTS_D,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, 0 },
+	{ 1, 0 }, { 1, 1 }, { 0, 0 },
+	{ 0, 0x0f },
+      },
+    },
+    {
+      AVR32_ALIAS_FCASTD_S,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, 0 },
+	{ 1, 0 }, { 1, 1 }, { 0, 0 },
+	{ 0, 0x10 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x0c },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x0d },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x0e },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x0f },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x08 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x09 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x0a },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x0b },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x04 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x05 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x06 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x07 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x00 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x01 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x02 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+	{ 0, 0x03 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_D1,
+      &avr32_opc_table[AVR32_OPC_LDC_D1],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_D2,
+      &avr32_opc_table[AVR32_OPC_LDC_D2],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_D3,
+      &avr32_opc_table[AVR32_OPC_LDC_D3],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_W1,
+      &avr32_opc_table[AVR32_OPC_LDC_W1],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_W2,
+      &avr32_opc_table[AVR32_OPC_LDC_W2],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_W3,
+      &avr32_opc_table[AVR32_OPC_LDC_W3],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_D,
+      &avr32_opc_table[AVR32_OPC_LDCM_D],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_D_PU,
+      &avr32_opc_table[AVR32_OPC_LDCM_D_PU],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_W,
+      &avr32_opc_table[AVR32_OPC_LDCM_W],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_W_PU,
+      &avr32_opc_table[AVR32_OPC_LDCM_W_PU],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_D1,
+      &avr32_opc_table[AVR32_OPC_MVCR_D],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_D2,
+      &avr32_opc_table[AVR32_OPC_MVRC_D],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_W1,
+      &avr32_opc_table[AVR32_OPC_MVCR_W],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_W2,
+      &avr32_opc_table[AVR32_OPC_MVRC_W],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_D1,
+      &avr32_opc_table[AVR32_OPC_STC_D1],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_D2,
+      &avr32_opc_table[AVR32_OPC_STC_D2],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_D3,
+      &avr32_opc_table[AVR32_OPC_STC_D3],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_W1,
+      &avr32_opc_table[AVR32_OPC_STC_W1],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_W2,
+      &avr32_opc_table[AVR32_OPC_STC_W2],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_W3,
+      &avr32_opc_table[AVR32_OPC_STC_W3],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_D,
+      &avr32_opc_table[AVR32_OPC_STCM_D],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_D_PU,
+      &avr32_opc_table[AVR32_OPC_STCM_D_PU],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_W,
+      &avr32_opc_table[AVR32_OPC_STCM_W],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_W_PU,
+      &avr32_opc_table[AVR32_OPC_STCM_W_PU],
+      {
+	{ 0, PICO_CPNO },
+	{ 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+  };
+
+
+#define SYNTAX_NORMAL0(id, mne, opc, arch)			\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },		\
+    NULL, 0, { }					\
+  }
+#define SYNTAX_NORMAL1(id, mne, opc, op0, arch)		\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },		\
+    NULL, 1,						\
+    {							\
+      AVR32_OPERAND_##op0,				\
+    }							\
+  }
+#define SYNTAX_NORMALM1(id, mne, opc, op0, arch)		\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    NULL, -1,						\
+    {							\
+      AVR32_OPERAND_##op0,				\
+    }							\
+  }
+#define SYNTAX_NORMAL2(id, mne, opc, op0, op1, arch)		\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    NULL, 2,						\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+    }							\
+  }
+#define SYNTAX_NORMALM2(id, mne, opc, op0, op1, arch)		\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    NULL, -2,						\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+    }							\
+  }
+#define SYNTAX_NORMAL3(id, mne, opc, op0, op1, op2, arch)	\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    NULL, 3,						\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+      AVR32_OPERAND_##op2,				\
+    }							\
+  }
+#define SYNTAX_NORMALM3(id, mne, opc, op0, op1, op2, arch)	\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    NULL, -3,						\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+      AVR32_OPERAND_##op2,				\
+    }							\
+  }
+#define SYNTAX_NORMAL4(id, mne, opc, op0, op1, op2, op3, arch)\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    NULL, 4,						\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+      AVR32_OPERAND_##op2, AVR32_OPERAND_##op3,		\
+    }							\
+  }
+#define SYNTAX_NORMAL5(id, mne, opc, op0, op1, op2, op3, op4, arch)	\
+  {								\
+    AVR32_SYNTAX_##id, arch,				\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],		\
+    AVR32_PARSER_NORMAL,						\
+    { &avr32_opc_table[AVR32_OPC_##opc], },				\
+    NULL, 5,							\
+    {								\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,			\
+      AVR32_OPERAND_##op2, AVR32_OPERAND_##op3,			\
+      AVR32_OPERAND_##op4,					\
+    }								\
+  }
+
+#define SYNTAX_NORMAL_C1(id, mne, opc, nxt, op0, arch)	\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], 1,		\
+    {							\
+      AVR32_OPERAND_##op0,				\
+    }							\
+  }
+#define SYNTAX_NORMAL_CM1(id, mne, opc, nxt, op0, arch)	\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], -1,	\
+    {							\
+      AVR32_OPERAND_##op0,				\
+    }							\
+  }
+#define SYNTAX_NORMAL_C2(id, mne, opc, nxt, op0, op1, arch)	\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], 2,		\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+    }							\
+  }
+#define SYNTAX_NORMAL_CM2(id, mne, opc, nxt, op0, op1, arch)	\
+  {							\
+    AVR32_SYNTAX_##id, arch,			\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],	\
+    AVR32_PARSER_NORMAL,					\
+    { &avr32_opc_table[AVR32_OPC_##opc], },			\
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], -2,	\
+    {							\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,		\
+    }							\
+  }
+#define SYNTAX_NORMAL_C3(id, mne, opc, nxt, op0, op1, op2, arch)	\
+  {								\
+    AVR32_SYNTAX_##id, arch,				\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],		\
+    AVR32_PARSER_NORMAL,						\
+    { &avr32_opc_table[AVR32_OPC_##opc], },				\
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], 3,			\
+    {								\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,			\
+      AVR32_OPERAND_##op2,					\
+    }								\
+  }
+#define SYNTAX_NORMAL_CM3(id, mne, opc, nxt, op0, op1, op2, arch)	\
+  {								\
+    AVR32_SYNTAX_##id, arch,				\
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],		\
+    AVR32_PARSER_NORMAL,						\
+    { &avr32_opc_table[AVR32_OPC_##opc], },				\
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], -3,		\
+    {								\
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,			\
+      AVR32_OPERAND_##op2,					\
+    }								\
+  }
+
+#define SYNTAX_FP(name, nr_ops)					\
+    {								\
+      AVR32_SYNTAX_##name##_S,					\
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,			\
+      { .alias = &avr32_alias_table[AVR32_ALIAS_##name##_S] },	\
+      NULL, nr_ops,						\
+      {								\
+	AVR32_OPERAND_FPREG_S,					\
+	AVR32_OPERAND_FPREG_S,					\
+	AVR32_OPERAND_FPREG_S,					\
+      },							\
+    },								\
+    {								\
+      AVR32_SYNTAX_##name##_D,					\
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,			\
+      { .alias = &avr32_alias_table[AVR32_ALIAS_##name##_D] },	\
+      NULL, nr_ops,						\
+      {								\
+	AVR32_OPERAND_FPREG_D,					\
+	AVR32_OPERAND_FPREG_D,					\
+	AVR32_OPERAND_FPREG_D,					\
+      },							\
+    }
+
+const struct avr32_syntax avr32_syntax_table[] =
+  {
+    SYNTAX_NORMAL1(ABS, ABS, ABS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(ACALL, ACALL, ACALL, UNSIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL1(ACR, ACR, ACR, INTREG,AVR32_V1),
+    SYNTAX_NORMAL3(ADC, ADC, ADC, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ADD1, ADD, ADD1, ADD2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(ADD2, ADD, ADD2, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(ADDABS, ADDABS, ADDABS, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(ADDHH_W, ADDHH_W, ADDHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL_C2(AND1, AND, AND1, AND2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(AND2, AND, AND2, AND3, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(AND3, AND, AND3, INTREG, INTREG, INTREG_LSR, AVR32_V1),
+    SYNTAX_NORMAL_C2(ANDH, ANDH, ANDH, ANDH_COH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(ANDH_COH, ANDH, ANDH_COH, INTREG, UNSIGNED_CONST, COH, AVR32_V1),
+    SYNTAX_NORMAL_C2(ANDL, ANDL, ANDL, ANDL_COH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(ANDL_COH, ANDL, ANDL_COH, INTREG, UNSIGNED_CONST, COH, AVR32_V1),
+    SYNTAX_NORMAL2(ANDN, ANDN, ANDN, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(ASR1, ASR, ASR1, ASR3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(ASR3, ASR, ASR3, ASR2, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(ASR2, ASR, ASR2, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL4(BFEXTS, BFEXTS, BFEXTS, INTREG, INTREG, UNSIGNED_NUMBER, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL4(BFEXTU, BFEXTU, BFEXTU, INTREG, INTREG, UNSIGNED_NUMBER, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL4(BFINS, BFINS, BFINS, INTREG, INTREG, UNSIGNED_NUMBER, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(BLD, BLD, BLD, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL_C1(BREQ1, BREQ, BREQ1, BREQ2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRNE1, BRNE, BRNE1, BRNE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRCC1, BRCC, BRCC1, BRCC2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRCS1, BRCS, BRCS1, BRCS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRGE1, BRGE, BRGE1, BRGE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRLT1, BRLT, BRLT1, BRLT2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRMI1, BRMI, BRMI1, BRMI2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRPL1, BRPL, BRPL1, BRPL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRHS1, BRHS, BRCC1, BRHS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRLO1, BRLO, BRCS1, BRLO2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BREQ2, BREQ, BREQ2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRNE2, BRNE, BRNE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRCC2, BRCC, BRCC2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRCS2, BRCS, BRCS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRGE2, BRGE, BRGE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLT2, BRLT, BRLT2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRMI2, BRMI, BRMI2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRPL2, BRPL, BRPL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLS, BRLS, BRLS, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRGT, BRGT, BRGT, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLE, BRLE, BRLE, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRHI, BRHI, BRHI, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRVS, BRVS, BRVS, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRVC, BRVC, BRVC, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRQS, BRQS, BRQS, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRAL, BRAL, BRAL, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRHS2, BRHS, BRCC2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLO2, BRLO, BRCS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL0(BREAKPOINT, BREAKPOINT, BREAKPOINT, AVR32_V1),
+    SYNTAX_NORMAL1(BREV, BREV, BREV, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(BST, BST, BST, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(CACHE, CACHE, CACHE, INTREG_SDISP, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL1(CASTS_B, CASTS_B, CASTS_B, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CASTS_H, CASTS_H, CASTS_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CASTU_B, CASTU_B, CASTU_B, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CASTU_H, CASTU_H, CASTU_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(CBR, CBR, CBR, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(CLZ, CLZ, CLZ, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(COM, COM, COM, INTREG, AVR32_V1),
+    SYNTAX_NORMAL5(COP, COP, COP, CPNO, CPREG, CPREG, CPREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(CP_B, CP_B, CP_B, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(CP_H, CP_H, CP_H, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(CP_W1, CP_W, CP_W1, CP_W2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(CP_W2, CP_W, CP_W2, CP_W3, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(CP_W3, CP_W, CP_W3, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(CPC1, CPC, CPC1, CPC2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CPC2, CPC, CPC2, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CSRF, CSRF, CSRF, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL1(CSRFCZ, CSRFCZ, CSRFCZ, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL3(DIVS, DIVS, DIVS, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(DIVU, DIVU, DIVU, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(EOR1, EOR, EOR1, EOR2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(EOR2, EOR, EOR2, EOR3, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(EOR3, EOR, EOR3, INTREG, INTREG, INTREG_LSR, AVR32_V1),
+    SYNTAX_NORMAL2(EORL, EORL, EORL, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(EORH, EORH, EORH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL0(FRS, FRS, FRS, AVR32_V1),
+    SYNTAX_NORMAL1(ICALL, ICALL, ICALL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(INCJOSP, INCJOSP, INCJOSP, JOSPINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D1, LD_D, LD_D1, LD_D2, DWREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D2, LD_D, LD_D2, LD_D3, DWREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D3, LD_D, LD_D3, LD_D5, DWREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D5, LD_D, LD_D5, LD_D4, DWREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL2(LD_D4, LD_D, LD_D4, DWREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SB2, LD_SB, LD_SB2, LD_SB1, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL2(LD_SB1, LD_SB, LD_SB1, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB1, LD_UB, LD_UB1, LD_UB2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB2, LD_UB, LD_UB2, LD_UB5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB5, LD_UB, LD_UB5, LD_UB3, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB3, LD_UB, LD_UB3, LD_UB4, INTREG, INTREG_UDISP, AVR32_V1),
+    SYNTAX_NORMAL2(LD_UB4, LD_UB, LD_UB4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH1, LD_SH, LD_SH1, LD_SH2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH2, LD_SH, LD_SH2, LD_SH5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH5, LD_SH, LD_SH5, LD_SH3, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH3, LD_SH, LD_SH3, LD_SH4, INTREG, INTREG_UDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LD_SH4, LD_SH, LD_SH4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH1, LD_UH, LD_UH1, LD_UH2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH2, LD_UH, LD_UH2, LD_UH5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH5, LD_UH, LD_UH5, LD_UH3, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH3, LD_UH, LD_UH3, LD_UH4, INTREG, INTREG_UDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LD_UH4, LD_UH, LD_UH4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W1, LD_W, LD_W1, LD_W2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W2, LD_W, LD_W2, LD_W5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W5, LD_W, LD_W5, LD_W6, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W6, LD_W, LD_W6, LD_W3, INTREG, INTREG_XINDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W3, LD_W, LD_W3, LD_W4, INTREG, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LD_W4, LD_W, LD_W4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL3(LDC_D1, LDC_D, LDC_D1, CPNO, CPREG_D, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_D2, LDC_D, LDC_D2, LDC_D1, CPNO, CPREG_D, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_D3, LDC_D, LDC_D3, LDC_D2, CPNO, CPREG_D, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL3(LDC_W1, LDC_W, LDC_W1, CPNO, CPREG, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_W2, LDC_W, LDC_W2, LDC_W1, CPNO, CPREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_W3, LDC_W, LDC_W3, LDC_W2, CPNO, CPREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL2(LDC0_D, LDC0_D, LDC0_D, CPREG_D, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LDC0_W, LDC0_W, LDC0_W, CPREG, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_CM3(LDCM_D, LDCM_D, LDCM_D, LDCM_D_PU, CPNO, INTREG, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMALM3(LDCM_D_PU, LDCM_D, LDCM_D_PU, CPNO, INTREG_POSTINC, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMAL_CM3(LDCM_W, LDCM_W, LDCM_W, LDCM_W_PU, CPNO, INTREG, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMALM3(LDCM_W_PU, LDCM_W, LDCM_W_PU, CPNO, INTREG_POSTINC, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMAL2(LDDPC, LDDPC, LDDPC, INTREG, PC_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LDDPC_EXT, LDDPC, LDDPC_EXT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(LDDSP, LDDSP, LDDSP, INTREG, SP_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LDINS_B, LDINS_B, LDINS_B, INTREG_BSEL, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL2(LDINS_H, LDINS_H, LDINS_H, INTREG_HSEL, INTREG_SDISP_H, AVR32_V1),
+    SYNTAX_NORMALM1(LDM, LDM, LDM, REGLIST_LDM, AVR32_V1),
+    SYNTAX_NORMAL_CM2(LDMTS, LDMTS, LDMTS, LDMTS_PU, INTREG, REGLIST16, AVR32_V1),
+    SYNTAX_NORMALM2(LDMTS_PU, LDMTS, LDMTS_PU, INTREG_POSTINC, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL2(LDSWP_SH, LDSWP_SH, LDSWP_SH, INTREG, INTREG_SDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LDSWP_UH, LDSWP_UH, LDSWP_UH, INTREG, INTREG_SDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LDSWP_W, LDSWP_W, LDSWP_W, INTREG, INTREG_SDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSL1, LSL, LSL1, LSL3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSL3, LSL, LSL3, LSL2, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(LSL2, LSL, LSL2, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSR1, LSR, LSR1, LSR3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSR3, LSR, LSR3, LSR2, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(LSR2, LSR, LSR2, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL3(MAC, MAC, MAC, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MACHH_D, MACHH_D, MACHH_D, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MACHH_W, MACHH_W, MACHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MACS_D, MACS_D, MACS_D, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MACSATHH_W, MACSATHH_W, MACSATHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MACUD, MACU_D, MACUD, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MACWH_D, MACWH_D, MACWH_D, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MAX, MAX, MAX, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(MCALL, MCALL, MCALL, MCALL, AVR32_V1),
+    SYNTAX_NORMAL2(MFDR, MFDR, MFDR, INTREG, UNSIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL2(MFSR, MFSR, MFSR, INTREG, UNSIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL3(MIN, MIN, MIN, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOV3, MOV, MOV3, MOV1, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOV1, MOV, MOV1, MOV2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOV2, MOV, MOV2,INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVEQ1, MOVEQ, MOVEQ1, MOVEQ2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVNE1, MOVNE, MOVNE1, MOVNE2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVCC1, MOVCC, MOVCC1, MOVCC2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVCS1, MOVCS, MOVCS1, MOVCS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVGE1, MOVGE, MOVGE1, MOVGE2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLT1, MOVLT, MOVLT1, MOVLT2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVMI1, MOVMI, MOVMI1, MOVMI2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVPL1, MOVPL, MOVPL1, MOVPL2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLS1, MOVLS, MOVLS1, MOVLS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVGT1, MOVGT, MOVGT1, MOVGT2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLE1, MOVLE, MOVLE1, MOVLE2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVHI1, MOVHI, MOVHI1, MOVHI2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVVS1, MOVVS, MOVVS1, MOVVS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVVC1, MOVVC, MOVVC1, MOVVC2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVQS1, MOVQS, MOVQS1, MOVQS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVAL1, MOVAL, MOVAL1, MOVAL2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVHS1, MOVHS, MOVCC1, MOVHS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLO1, MOVLO, MOVCS1, MOVLO2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(MOVEQ2, MOVEQ, MOVEQ2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVNE2, MOVNE, MOVNE2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVCC2, MOVCC, MOVCC2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVCS2, MOVCS, MOVCS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVGE2, MOVGE, MOVGE2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLT2, MOVLT, MOVLT2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVMI2, MOVMI, MOVMI2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVPL2, MOVPL, MOVPL2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLS2, MOVLS, MOVLS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVGT2, MOVGT, MOVGT2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLE2, MOVLE, MOVLE2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVHI2, MOVHI, MOVHI2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVVS2, MOVVS, MOVVS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVVC2, MOVVC, MOVVC2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVQS2, MOVQS, MOVQS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVAL2, MOVAL, MOVAL2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVHS2, MOVHS, MOVCC2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLO2, MOVLO, MOVCS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MTDR, MTDR, MTDR, UNSIGNED_CONST_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(MTSR, MTSR, MTSR, UNSIGNED_CONST_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MUL1, MUL, MUL1, MUL2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(MUL2, MUL, MUL2, MUL3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MUL3, MUL, MUL3, INTREG, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(MULHH_W, MULHH_W, MULHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULNHH_W, MULNHH_W, MULNHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULNWH_D, MULNWH_D, MULNWH_D, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSD, MULS_D, MULSD, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MULSATHH_H, MULSATHH_H, MULSATHH_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATHH_W, MULSATHH_W, MULSATHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATRNDHH_H, MULSATRNDHH_H, MULSATRNDHH_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATRNDWH_W, MULSATRNDWH_W, MULSATRNDWH_W, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATWH_W, MULSATWH_W, MULSATWH_W, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULU_D, MULU_D, MULU_D, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MULWH_D, MULWH_D, MULWH_D, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL1(MUSFR, MUSFR, MUSFR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(MUSTR, MUSTR, MUSTR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MVCR_D, MVCR_D, MVCR_D, CPNO, DWREG, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL3(MVCR_W, MVCR_W, MVCR_W, CPNO, INTREG, CPREG, AVR32_V1),
+    SYNTAX_NORMAL3(MVRC_D, MVRC_D, MVRC_D, CPNO, CPREG_D, DWREG, AVR32_V1),
+    SYNTAX_NORMAL3(MVRC_W, MVRC_W, MVRC_W, CPNO, CPREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(NEG, NEG, NEG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL0(NOP, NOP, NOP, AVR32_V1),
+    SYNTAX_NORMAL_C2(OR1, OR, OR1, OR2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(OR2, OR, OR2, OR3, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(OR3, OR, OR3, INTREG, INTREG, INTREG_LSR, AVR32_V1),
+    SYNTAX_NORMAL2(ORH, ORH, ORH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(ORL, ORL, ORL, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(PABS_SB, PABS_SB, PABS_SB, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL2(PABS_SH, PABS_SH, PABS_SH, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PACKSH_SB, PACKSH_SB, PACKSH_SB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PACKSH_UB, PACKSH_UB, PACKSH_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PACKW_SH, PACKW_SH, PACKW_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADD_B, PADD_B, PADD_B, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADD_H, PADD_H, PADD_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDH_SH, PADDH_SH, PADDH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDH_UB, PADDH_UB, PADDH_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_SB, PADDS_SB, PADDS_SB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_SH, PADDS_SH, PADDS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_UB, PADDS_UB, PADDS_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_UH, PADDS_UH, PADDS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUB_H, PADDSUB_H, PADDSUB_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUBH_SH, PADDSUBH_SH, PADDSUBH_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUBS_SH, PADDSUBS_SH, PADDSUBS_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUBS_UH, PADDSUBS_UH, PADDSUBS_UH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDX_H, PADDX_H, PADDX_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDXH_SH, PADDXH_SH, PADDXH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDXS_SH, PADDXS_SH, PADDXS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDXS_UH, PADDXS_UH, PADDXS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PASR_B, PASR_B, PASR_B, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PASR_H, PASR_H, PASR_H, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PAVG_SH, PAVG_SH, PAVG_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PAVG_UB, PAVG_UB, PAVG_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSL_B, PLSL_B, PLSL_B, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSL_H, PLSL_H, PLSL_H, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSR_B, PLSR_B, PLSR_B, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSR_H, PLSR_H, PLSR_H, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMAX_SH, PMAX_SH, PMAX_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMAX_UB, PMAX_UB, PMAX_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMIN_SH, PMIN_SH, PMIN_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMIN_UB, PMIN_UB, PMIN_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL0(POPJC, POPJC, POPJC, AVR32_V1),
+    SYNTAX_NORMAL_CM1(POPM, POPM, POPM, POPM_E, REGLIST9, AVR32_V1),
+    SYNTAX_NORMALM1(POPM_E, POPM, POPM_E, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL1(PREF, PREF, PREF, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL3(PSAD, PSAD, PSAD, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUB_B, PSUB_B, PSUB_B, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUB_H, PSUB_H, PSUB_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADD_H, PSUBADD_H, PSUBADD_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADDH_SH, PSUBADDH_SH, PSUBADDH_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADDS_SH, PSUBADDS_SH, PSUBADDS_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADDS_UH, PSUBADDS_UH, PSUBADDS_UH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBH_SH, PSUBH_SH, PSUBH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBH_UB, PSUBH_UB, PSUBH_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_SB, PSUBS_SB, PSUBS_SB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_SH, PSUBS_SH, PSUBS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_UB, PSUBS_UB, PSUBS_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_UH, PSUBS_UH, PSUBS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBX_H, PSUBX_H, PSUBX_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBXH_SH, PSUBXH_SH, PSUBXH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBXS_SH, PSUBXS_SH, PSUBXS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBXS_UH, PSUBXS_UH, PSUBXS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL2(PUNPCKSB_H, PUNPCKSB_H, PUNPCKSB_H, INTREG, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL2(PUNPCKUB_H, PUNPCKUB_H, PUNPCKUB_H, INTREG, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL0(PUSHJC, PUSHJC, PUSHJC, AVR32_V1),
+    SYNTAX_NORMAL_CM1(PUSHM, PUSHM, PUSHM, PUSHM_E, REGLIST8, AVR32_V1),
+    SYNTAX_NORMALM1(PUSHM_E, PUSHM, PUSHM_E, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL_C1(RCALL1, RCALL, RCALL1, RCALL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(RCALL2, RCALL, RCALL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(RETEQ, RETEQ, RETEQ, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETNE, RETNE, RETNE, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETCC, RETCC, RETCC, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETCS, RETCS, RETCS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETGE, RETGE, RETGE, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLT, RETLT, RETLT, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETMI, RETMI, RETMI, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETPL, RETPL, RETPL, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLS, RETLS, RETLS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETGT, RETGT, RETGT, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLE, RETLE, RETLE, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETHI, RETHI, RETHI, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETVS, RETVS, RETVS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETVC, RETVC, RETVC, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETQS, RETQS, RETQS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETAL, RETAL, RETAL, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETHS, RETHS, RETCC, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLO, RETLO, RETCS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL0(RETD, RETD, RETD, AVR32_V1),
+    SYNTAX_NORMAL0(RETE, RETE, RETE, AVR32_V1),
+    SYNTAX_NORMAL0(RETJ, RETJ, RETJ, AVR32_V1),
+    SYNTAX_NORMAL0(RETS, RETS, RETS, AVR32_V1),
+    SYNTAX_NORMAL1(RJMP, RJMP, RJMP, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(ROL, ROL, ROL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(ROR, ROR, ROR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(RSUB1, RSUB, RSUB1, RSUB2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(RSUB2, RSUB, RSUB2, INTREG, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(SATADD_H, SATADD_H, SATADD_H, INTREG, INTREG, INTREG,  AVR32_DSP),
+    SYNTAX_NORMAL3(SATADD_W, SATADD_W, SATADD_W, INTREG, INTREG, INTREG, AVR32_DSP),
+    SYNTAX_NORMAL2(SATRNDS, SATRNDS, SATRNDS, INTREG_LSR, UNSIGNED_NUMBER, AVR32_DSP),
+    SYNTAX_NORMAL2(SATRNDU, SATRNDU, SATRNDU, INTREG_LSR, UNSIGNED_NUMBER, AVR32_DSP),
+    SYNTAX_NORMAL2(SATS, SATS, SATS, INTREG_LSR, UNSIGNED_NUMBER, AVR32_DSP),
+    SYNTAX_NORMAL3(SATSUB_H, SATSUB_H, SATSUB_H, INTREG, INTREG, INTREG, AVR32_DSP),
+    SYNTAX_NORMAL_C3(SATSUB_W1, SATSUB_W, SATSUB_W1, SATSUB_W2, INTREG, INTREG, INTREG, AVR32_DSP),
+    SYNTAX_NORMAL3(SATSUB_W2, SATSUB_W, SATSUB_W2, INTREG, INTREG, SIGNED_CONST, AVR32_DSP),
+    SYNTAX_NORMAL2(SATU, SATU, SATU, INTREG_LSR, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL3(SBC, SBC, SBC, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(SBR, SBR, SBR, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL0(SCALL, SCALL, SCALL, AVR32_V1),
+    SYNTAX_NORMAL1(SCR, SCR, SCR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SLEEP, SLEEP, SLEEP, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL1(SREQ, SREQ, SREQ, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRNE, SRNE, SRNE, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRCC, SRCC, SRCC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRCS, SRCS, SRCS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRGE, SRGE, SRGE, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLT, SRLT, SRLT, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRMI, SRMI, SRMI, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRPL, SRPL, SRPL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLS, SRLS, SRLS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRGT, SRGT, SRGT, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLE, SRLE, SRLE, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRHI, SRHI, SRHI, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRVS, SRVS, SRVS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRVC, SRVC, SRVC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRQS, SRQS, SRQS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRAL, SRAL, SRAL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRHS, SRHS, SRCC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLO, SRLO, SRCS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SSRF, SSRF, SSRF, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B1, ST_B, ST_B1, ST_B2, INTREG_POSTINC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B2, ST_B, ST_B2, ST_B5, INTREG_PREDEC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B5, ST_B, ST_B5, ST_B3, INTREG_INDEX, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B3, ST_B, ST_B3, ST_B4, INTREG_UDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_B4, ST_B, ST_B4, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D1, ST_D, ST_D1, ST_D2, INTREG_POSTINC, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D2, ST_D, ST_D2, ST_D3, INTREG_PREDEC, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D3, ST_D, ST_D3, ST_D5, INTREG, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D5, ST_D, ST_D5, ST_D4, INTREG_INDEX, DWREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_D4, ST_D, ST_D4, INTREG_SDISP, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H1, ST_H, ST_H1, ST_H2, INTREG_POSTINC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H2, ST_H, ST_H2, ST_H5, INTREG_PREDEC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H5, ST_H, ST_H5, ST_H3, INTREG_INDEX, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H3, ST_H, ST_H3, ST_H4, INTREG_UDISP_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_H4, ST_H, ST_H4, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W1, ST_W, ST_W1, ST_W2, INTREG_POSTINC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W2, ST_W, ST_W2, ST_W5, INTREG_PREDEC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W5, ST_W, ST_W5, ST_W3, INTREG_INDEX, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W3, ST_W, ST_W3, ST_W4, INTREG_UDISP_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_W4, ST_W, ST_W4, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(STC_D1, STC_D, STC_D1, CPNO, INTREG_UDISP_W, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_D2, STC_D, STC_D2, STC_D1, CPNO, INTREG_POSTINC, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_D3, STC_D, STC_D3, STC_D2, CPNO, INTREG_INDEX, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL3(STC_W1, STC_W, STC_W1, CPNO, INTREG_UDISP_W, CPREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_W2, STC_W, STC_W2, STC_W1, CPNO, INTREG_POSTINC, CPREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_W3, STC_W, STC_W3, STC_W2, CPNO, INTREG_INDEX, CPREG, AVR32_V1),
+    SYNTAX_NORMAL2(STC0_D, STC0_D, STC0_D, INTREG_UDISP_W, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL2(STC0_W, STC0_W, STC0_W, INTREG_UDISP_W, CPREG, AVR32_V1),
+    SYNTAX_NORMAL_CM3(STCM_D, STCM_D, STCM_D, STCM_D_PU, CPNO, INTREG, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMALM3(STCM_D_PU, STCM_D, STCM_D_PU, CPNO, INTREG_PREDEC, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMAL_CM3(STCM_W, STCM_W, STCM_W, STCM_W_PU, CPNO, INTREG, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMALM3(STCM_W_PU, STCM_W, STCM_W_PU, CPNO, INTREG_PREDEC, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMAL2(STCOND, STCOND, STCOND, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(STDSP, STDSP, STDSP, SP_UDISP_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(STHH_W2, STHH_W, STHH_W2, STHH_W1, INTREG_INDEX, INTREG_HSEL, INTREG_HSEL, AVR32_V1),
+    SYNTAX_NORMAL3(STHH_W1, STHH_W, STHH_W1, INTREG_UDISP_W, INTREG_HSEL, INTREG_HSEL, AVR32_V1),
+    SYNTAX_NORMAL_CM2(STM, STM, STM, STM_PU, INTREG, REGLIST16, AVR32_V1),
+    SYNTAX_NORMALM2(STM_PU, STM, STM_PU, INTREG_PREDEC, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL_CM2(STMTS, STMTS, STMTS, STMTS_PU, INTREG, REGLIST16, AVR32_V1),
+    SYNTAX_NORMALM2(STMTS_PU, STMTS, STMTS_PU, INTREG_PREDEC, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL2(STSWP_H, STSWP_H, STSWP_H, INTREG_SDISP_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(STSWP_W, STSWP_W, STSWP_W, INTREG_SDISP_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUB1, SUB, SUB1, SUB2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(SUB2, SUB, SUB2, SUB5, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL_C3(SUB5, SUB, SUB5, SUB3_SP, INTREG, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUB3_SP, SUB, SUB3_SP, SUB3, SP, SIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUB3, SUB, SUB3, SUB4, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUB4, SUB, SUB4, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBEQ, SUBEQ, SUBEQ, SUB2EQ, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBNE, SUBNE, SUBNE, SUB2NE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBCC, SUBCC, SUBCC, SUB2CC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBCS, SUBCS, SUBCS, SUB2CS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBGE, SUBGE, SUBGE, SUB2GE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLT, SUBLT, SUBLT, SUB2LT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBMI, SUBMI, SUBMI, SUB2MI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBPL, SUBPL, SUBPL, SUB2PL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLS, SUBLS, SUBLS, SUB2LS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBGT, SUBGT, SUBGT, SUB2GT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLE, SUBLE, SUBLE, SUB2LE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBHI, SUBHI, SUBHI, SUB2HI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBVS, SUBVS, SUBVS, SUB2VS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBVC, SUBVC, SUBVC, SUB2VC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBQS, SUBQS, SUBQS, SUB2QS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBAL, SUBAL, SUBAL, SUB2AL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBHS, SUBHS, SUBCC, SUB2CC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLO, SUBLO, SUBCS, SUB2CS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFEQ, SUBFEQ, SUBFEQ, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFNE, SUBFNE, SUBFNE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFCC, SUBFCC, SUBFCC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFCS, SUBFCS, SUBFCS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFGE, SUBFGE, SUBFGE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLT, SUBFLT, SUBFLT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFMI, SUBFMI, SUBFMI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFPL, SUBFPL, SUBFPL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLS, SUBFLS, SUBFLS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFGT, SUBFGT, SUBFGT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLE, SUBFLE, SUBFLE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFHI, SUBFHI, SUBFHI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFVS, SUBFVS, SUBFVS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFVC, SUBFVC, SUBFVC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFQS, SUBFQS, SUBFQS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFAL, SUBFAL, SUBFAL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFHS, SUBFHS, SUBFCC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLO, SUBFLO, SUBFCS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(SUBHH_W, SUBHH_W, SUBHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL1(SWAP_B, SWAP_B, SWAP_B, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SWAP_BH, SWAP_BH, SWAP_BH, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SWAP_H, SWAP_H, SWAP_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SYNC, SYNC, SYNC, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL0(TLBR, TLBR, TLBR, AVR32_V1),
+    SYNTAX_NORMAL0(TLBS, TLBS, TLBS, AVR32_V1),
+    SYNTAX_NORMAL0(TLBW, TLBW, TLBW, AVR32_V1),
+    SYNTAX_NORMAL1(TNBZ, TNBZ, TNBZ, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(TST, TST, TST, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(XCHG, XCHG, XCHG, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(MEMC, MEMC, MEMC, SIGNED_CONST_W, UNSIGNED_NUMBER, AVR32_RMW),
+    SYNTAX_NORMAL2(MEMS, MEMS, MEMS, SIGNED_CONST_W, UNSIGNED_NUMBER, AVR32_RMW),
+    SYNTAX_NORMAL2(MEMT, MEMT, MEMT, SIGNED_CONST_W, UNSIGNED_NUMBER, AVR32_RMW),
+    SYNTAX_FP(FADD, 3),
+    SYNTAX_FP(FSUB, 3),
+    SYNTAX_FP(FMAC, 3),
+    SYNTAX_FP(FNMAC, 3),
+    SYNTAX_FP(FMSC, 3),
+    SYNTAX_FP(FNMSC, 3),
+    SYNTAX_FP(FMUL, 3),
+    SYNTAX_FP(FNMUL, 3),
+    SYNTAX_FP(FNEG, 2),
+    SYNTAX_FP(FABS, 2),
+    SYNTAX_FP(FCMP, 2),
+    {
+      AVR32_SYNTAX_FMOV1_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV1_S] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV2_S],
+      2,
+      {
+	AVR32_OPERAND_FPREG_S,
+	AVR32_OPERAND_FPREG_S,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV1_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV1_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV2_D],
+      2,
+      {
+	AVR32_OPERAND_FPREG_D,
+	AVR32_OPERAND_FPREG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV2_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV2_S] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV3_S],
+      2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_FPREG_S,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV2_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV2_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV3_D],
+      2,
+      {
+	AVR32_OPERAND_DWREG,
+	AVR32_OPERAND_FPREG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV3_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV3_S] }, NULL,
+      2,
+      {
+	AVR32_OPERAND_FPREG_S,
+	AVR32_OPERAND_INTREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV3_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV3_D] }, NULL,
+      2,
+      {
+	AVR32_OPERAND_FPREG_D,
+	AVR32_OPERAND_DWREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_FCASTS_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FCASTS_D] }, NULL,
+      2,
+      {
+	AVR32_OPERAND_FPREG_S,
+	AVR32_OPERAND_FPREG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_FCASTD_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FCASTD_S] }, NULL,
+      2,
+      {
+	AVR32_OPERAND_FPREG_D,
+	AVR32_OPERAND_FPREG_S,
+      },
+    },
+    {
+      AVR32_SYNTAX_LDA_W,
+      AVR32_V1, NULL, AVR32_PARSER_LDA,
+      { NULL }, NULL,
+      2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_SIGNED_CONST,
+      },
+    },
+    {
+      AVR32_SYNTAX_CALL,
+      AVR32_V1, NULL, AVR32_PARSER_CALL,
+      { NULL }, NULL,
+      1,
+      {
+	AVR32_OPERAND_JMPLABEL,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMAC1], 4,
+      {
+	AVR32_OPERAND_PICO_OUT0,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMAC2], 4,
+      {
+	AVR32_OPERAND_PICO_OUT1,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMAC3], 4,
+      {
+	AVR32_OPERAND_PICO_OUT2,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC3] },
+      NULL, 4,
+      {
+	AVR32_OPERAND_PICO_OUT3,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMUL1], 4,
+      {
+	AVR32_OPERAND_PICO_OUT0,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMUL2], 4,
+      {
+	AVR32_OPERAND_PICO_OUT1,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMUL3], 4,
+      {
+	AVR32_OPERAND_PICO_OUT2,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL3] },
+      NULL, 4,
+      {
+	AVR32_OPERAND_PICO_OUT3,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMAC1], 4,
+      {
+	AVR32_OPERAND_PICO_OUT0,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMAC2], 4,
+      {
+	AVR32_OPERAND_PICO_OUT1,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMAC3], 4,
+      {
+	AVR32_OPERAND_PICO_OUT2,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC3] },
+      NULL, 4,
+      {
+	AVR32_OPERAND_PICO_OUT3,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMUL1], 4,
+      {
+	AVR32_OPERAND_PICO_OUT0,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMUL2], 4,
+      {
+	AVR32_OPERAND_PICO_OUT1,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMUL3], 4,
+      {
+	AVR32_OPERAND_PICO_OUT2,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL3] },
+      NULL, 4,
+      {
+	AVR32_OPERAND_PICO_OUT3,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+	AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_D2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_D2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_D3], 2,
+      {
+	AVR32_OPERAND_PICO_REG_D,
+	AVR32_OPERAND_INTREG_PREDEC,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_D3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_D3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_D1], 2,
+      {
+	AVR32_OPERAND_PICO_REG_D,
+	AVR32_OPERAND_INTREG_INDEX,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_D1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_D1] },
+      NULL, 2,
+      {
+	AVR32_OPERAND_PICO_REG_D,
+	AVR32_OPERAND_INTREG_UDISP_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_W2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_W2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_W3], 2,
+      {
+	AVR32_OPERAND_PICO_REG_W,
+	AVR32_OPERAND_INTREG_PREDEC,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_W3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_W3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_W1], 2,
+      {
+	AVR32_OPERAND_PICO_REG_W,
+	AVR32_OPERAND_INTREG_INDEX,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_W1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_W1] },
+      NULL, 2,
+      {
+	AVR32_OPERAND_PICO_REG_W,
+	AVR32_OPERAND_INTREG_UDISP_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_D,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLDM_D_PU], -2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_D_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_D_PU] },
+      NULL, -2,
+      {
+	AVR32_OPERAND_INTREG_POSTINC,
+	AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_W,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_W] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLDM_W_PU], -2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_W_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_W_PU] },
+      NULL, -2,
+      {
+	AVR32_OPERAND_INTREG_POSTINC,
+	AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_D1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_D1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOMV_D2], 2,
+      {
+	AVR32_OPERAND_DWREG,
+	AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_D2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_D2] },
+      NULL, 2,
+      {
+	AVR32_OPERAND_PICO_REG_D,
+	AVR32_OPERAND_DWREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_W1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_W1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOMV_W2], 2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_W2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_W2] },
+      NULL, 2,
+      {
+	AVR32_OPERAND_PICO_REG_W,
+	AVR32_OPERAND_INTREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_D2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_D2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_D3], 2,
+      {
+	AVR32_OPERAND_INTREG_POSTINC,
+	AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_D3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_D3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_D1], 2,
+      {
+	AVR32_OPERAND_INTREG_INDEX,
+	AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_D1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_D1] },
+      NULL, 2,
+      {
+	AVR32_OPERAND_INTREG_UDISP_W,
+	AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_W2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_W2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_W3], 2,
+      {
+	AVR32_OPERAND_INTREG_POSTINC,
+	AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_W3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_W3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_W1], 2,
+      {
+	AVR32_OPERAND_INTREG_INDEX,
+	AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_W1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_W1] },
+      NULL, 2,
+      {
+	AVR32_OPERAND_INTREG_UDISP_W,
+	AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_D,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSTM_D_PU], -2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_D_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_D_PU] },
+      NULL, -2,
+      {
+	AVR32_OPERAND_INTREG_PREDEC,
+	AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_W,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_W] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSTM_W_PU], -2,
+      {
+	AVR32_OPERAND_INTREG,
+	AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_W_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_W_PU] },
+      NULL, -2,
+      {
+	AVR32_OPERAND_INTREG_PREDEC,
+	AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    SYNTAX_NORMAL2(RSUBEQ, RSUBEQ, RSUBEQ, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(RSUBNE, RSUBNE, RSUBNE, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBCC, RSUBCC, RSUBCC, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBCS, RSUBCS, RSUBCS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBGE, RSUBGE, RSUBGE, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLT, RSUBLT, RSUBLT, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBMI, RSUBMI, RSUBMI, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBPL, RSUBPL, RSUBPL, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLS, RSUBLS, RSUBLS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBGT, RSUBGT, RSUBGT, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLE, RSUBLE, RSUBLE, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBHI, RSUBHI, RSUBHI, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBVS, RSUBVS, RSUBVS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBVC, RSUBVC, RSUBVC, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBQS, RSUBQS, RSUBQS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBAL, RSUBAL, RSUBAL, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBHS, RSUBHS, RSUBCC, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLO, RSUBLO, RSUBCS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL3(ADDEQ, ADDEQ, ADDEQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDNE, ADDNE, ADDNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDCC, ADDCC, ADDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDCS, ADDCS, ADDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDGE, ADDGE, ADDGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLT, ADDLT, ADDLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDMI, ADDMI, ADDMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDPL, ADDPL, ADDPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLS, ADDLS, ADDLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDGT, ADDGT, ADDGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLE, ADDLE, ADDLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDHI, ADDHI, ADDHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDVS, ADDVS, ADDVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDVC, ADDVC, ADDVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDQS, ADDQS, ADDQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDAL, ADDAL, ADDAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDHS, ADDHS, ADDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLO, ADDLO, ADDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2EQ, SUBEQ, SUB2EQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2NE, SUBNE, SUB2NE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2CC, SUBCC, SUB2CC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2CS, SUBCS, SUB2CS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2GE, SUBGE, SUB2GE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LT, SUBLT, SUB2LT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2MI, SUBMI, SUB2MI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2PL, SUBPL, SUB2PL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LS, SUBLS, SUB2LS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2GT, SUBGT, SUB2GT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LE, SUBLE, SUB2LE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2HI, SUBHI, SUB2HI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2VS, SUBVS, SUB2VS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2VC, SUBVC, SUB2VC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2QS, SUBQS, SUB2QS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2AL, SUBAL, SUB2AL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2HS, SUBHS, SUB2CC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LO, SUBLO, SUB2CS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDEQ, ANDEQ, ANDEQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDNE, ANDNE, ANDNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDCC, ANDCC, ANDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDCS, ANDCS, ANDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDGE, ANDGE, ANDGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLT, ANDLT, ANDLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDMI, ANDMI, ANDMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDPL, ANDPL, ANDPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLS, ANDLS, ANDLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDGT, ANDGT, ANDGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLE, ANDLE, ANDLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDHI, ANDHI, ANDHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDVS, ANDVS, ANDVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDVC, ANDVC, ANDVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDQS, ANDQS, ANDQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDAL, ANDAL, ANDAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDHS, ANDHS, ANDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLO, ANDLO, ANDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(OREQ, OREQ, OREQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORNE, ORNE, ORNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORCC, ORCC, ORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORCS, ORCS, ORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORGE, ORGE, ORGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLT, ORLT, ORLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORMI, ORMI, ORMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORPL, ORPL, ORPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLS, ORLS, ORLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORGT, ORGT, ORGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLE, ORLE, ORLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORHI, ORHI, ORHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORVS, ORVS, ORVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORVC, ORVC, ORVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORQS, ORQS, ORQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORAL, ORAL, ORAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORHS, ORHS, ORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLO, ORLO, ORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EOREQ, EOREQ, EOREQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORNE, EORNE, EORNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORCC, EORCC, EORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORCS, EORCS, EORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORGE, EORGE, EORGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLT, EORLT, EORLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORMI, EORMI, EORMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORPL, EORPL, EORPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLS, EORLS, EORLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORGT, EORGT, EORGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLE, EORLE, EORLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORHI, EORHI, EORHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORVS, EORVS, EORVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORVC, EORVC, EORVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORQS, EORQS, EORQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORAL, EORAL, EORAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORHS, EORHS, EORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLO, EORLO, EORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WEQ, LD_WEQ, LD_WEQ, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WNE, LD_WNE, LD_WNE, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WCC, LD_WCC, LD_WCC, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WCS, LD_WCS, LD_WCS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WGE, LD_WGE, LD_WGE, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLT, LD_WLT, LD_WLT, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WMI, LD_WMI, LD_WMI, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WPL, LD_WPL, LD_WPL, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLS, LD_WLS, LD_WLS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WGT, LD_WGT, LD_WGT, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLE, LD_WLE, LD_WLE, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WHI, LD_WHI, LD_WHI, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WVS, LD_WVS, LD_WVS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WVC, LD_WVC, LD_WVC, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WQS, LD_WQS, LD_WQS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WAL, LD_WAL, LD_WAL, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WHS, LD_WHS, LD_WCC, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLO, LD_WLO, LD_WCS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHEQ, LD_SHEQ, LD_SHEQ, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHNE, LD_SHNE, LD_SHNE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHCC, LD_SHCC, LD_SHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHCS, LD_SHCS, LD_SHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHGE, LD_SHGE, LD_SHGE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLT, LD_SHLT, LD_SHLT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHMI, LD_SHMI, LD_SHMI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHPL, LD_SHPL, LD_SHPL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLS, LD_SHLS, LD_SHLS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHGT, LD_SHGT, LD_SHGT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLE, LD_SHLE, LD_SHLE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHHI, LD_SHHI, LD_SHHI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHVS, LD_SHVS, LD_SHVS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHVC, LD_SHVC, LD_SHVC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHQS, LD_SHQS, LD_SHQS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHAL, LD_SHAL, LD_SHAL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHHS, LD_SHHS, LD_SHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLO, LD_SHLO, LD_SHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHEQ, LD_UHEQ, LD_UHEQ, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHNE, LD_UHNE, LD_UHNE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHCC, LD_UHCC, LD_UHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHCS, LD_UHCS, LD_UHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHGE, LD_UHGE, LD_UHGE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLT, LD_UHLT, LD_UHLT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHMI, LD_UHMI, LD_UHMI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHPL, LD_UHPL, LD_UHPL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLS, LD_UHLS, LD_UHLS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHGT, LD_UHGT, LD_UHGT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLE, LD_UHLE, LD_UHLE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHHI, LD_UHHI, LD_UHHI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHVS, LD_UHVS, LD_UHVS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHVC, LD_UHVC, LD_UHVC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHQS, LD_UHQS, LD_UHQS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHAL, LD_UHAL, LD_UHAL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHHS, LD_UHHS, LD_UHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLO, LD_UHLO, LD_UHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBEQ, LD_SBEQ, LD_SBEQ, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBNE, LD_SBNE, LD_SBNE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBCC, LD_SBCC, LD_SBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBCS, LD_SBCS, LD_SBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBGE, LD_SBGE, LD_SBGE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLT, LD_SBLT, LD_SBLT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBMI, LD_SBMI, LD_SBMI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBPL, LD_SBPL, LD_SBPL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLS, LD_SBLS, LD_SBLS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBGT, LD_SBGT, LD_SBGT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLE, LD_SBLE, LD_SBLE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBHI, LD_SBHI, LD_SBHI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBVS, LD_SBVS, LD_SBVS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBVC, LD_SBVC, LD_SBVC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBQS, LD_SBQS, LD_SBQS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBAL, LD_SBAL, LD_SBAL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBHS, LD_SBHS, LD_SBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLO, LD_SBLO, LD_SBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBEQ, LD_UBEQ, LD_UBEQ, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBNE, LD_UBNE, LD_UBNE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBCC, LD_UBCC, LD_UBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBCS, LD_UBCS, LD_UBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBGE, LD_UBGE, LD_UBGE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLT, LD_UBLT, LD_UBLT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBMI, LD_UBMI, LD_UBMI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBPL, LD_UBPL, LD_UBPL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLS, LD_UBLS, LD_UBLS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBGT, LD_UBGT, LD_UBGT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLE, LD_UBLE, LD_UBLE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBHI, LD_UBHI, LD_UBHI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBVS, LD_UBVS, LD_UBVS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBVC, LD_UBVC, LD_UBVC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBQS, LD_UBQS, LD_UBQS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBAL, LD_UBAL, LD_UBAL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBHS, LD_UBHS, LD_UBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLO, LD_UBLO, LD_UBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WEQ, ST_WEQ, ST_WEQ, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WNE, ST_WNE, ST_WNE, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WCC, ST_WCC, ST_WCC, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WCS, ST_WCS, ST_WCS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WGE, ST_WGE, ST_WGE, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLT, ST_WLT, ST_WLT, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WMI, ST_WMI, ST_WMI, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WPL, ST_WPL, ST_WPL, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLS, ST_WLS, ST_WLS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WGT, ST_WGT, ST_WGT, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLE, ST_WLE, ST_WLE, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WHI, ST_WHI, ST_WHI, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WVS, ST_WVS, ST_WVS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WVC, ST_WVC, ST_WVC, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WQS, ST_WQS, ST_WQS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WAL, ST_WAL, ST_WAL, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WHS, ST_WHS, ST_WCC, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLO, ST_WLO, ST_WCS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HEQ, ST_HEQ, ST_HEQ, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HNE, ST_HNE, ST_HNE, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HCC, ST_HCC, ST_HCC, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HCS, ST_HCS, ST_HCS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HGE, ST_HGE, ST_HGE, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLT, ST_HLT, ST_HLT, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HMI, ST_HMI, ST_HMI, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HPL, ST_HPL, ST_HPL, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLS, ST_HLS, ST_HLS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HGT, ST_HGT, ST_HGT, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLE, ST_HLE, ST_HLE, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HHI, ST_HHI, ST_HHI, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HVS, ST_HVS, ST_HVS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HVC, ST_HVC, ST_HVC, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HQS, ST_HQS, ST_HQS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HAL, ST_HAL, ST_HAL, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HHS, ST_HHS, ST_HCC, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLO, ST_HLO, ST_HCS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BEQ, ST_BEQ, ST_BEQ, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BNE, ST_BNE, ST_BNE, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BCC, ST_BCC, ST_BCC, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BCS, ST_BCS, ST_BCS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BGE, ST_BGE, ST_BGE, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLT, ST_BLT, ST_BLT, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BMI, ST_BMI, ST_BMI, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BPL, ST_BPL, ST_BPL, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLS, ST_BLS, ST_BLS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BGT, ST_BGT, ST_BGT, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLE, ST_BLE, ST_BLE, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BHI, ST_BHI, ST_BHI, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BVS, ST_BVS, ST_BVS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BVC, ST_BVC, ST_BVC, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BQS, ST_BQS, ST_BQS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BAL, ST_BAL, ST_BAL, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BHS, ST_BHS, ST_BCC, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLO, ST_BLO, ST_BCS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(MOVH, MOVH, MOVH, INTREG, UNSIGNED_CONST, AVR32_V2),
+
+  };
+
+#define NORMAL_MNEMONIC(name, syntax, str)		\
+  {							\
+    AVR32_MNEMONIC_##name, str,				\
+    &avr32_syntax_table[AVR32_SYNTAX_##syntax],		\
+  }
+#define FP_MNEMONIC(name, syntax, str)			\
+  NORMAL_MNEMONIC(name##_S, syntax##_S, str ".s"),	\
+  NORMAL_MNEMONIC(name##_D, syntax##_D, str ".d")
+
+const struct avr32_mnemonic avr32_mnemonic_table[] =
+  {
+    NORMAL_MNEMONIC(ABS, ABS, "abs"),
+    NORMAL_MNEMONIC(ACALL, ACALL, "acall"),
+    NORMAL_MNEMONIC(ACR, ACR, "acr"),
+    NORMAL_MNEMONIC(ADC, ADC, "adc"),
+    NORMAL_MNEMONIC(ADD, ADD1, "add"),
+    NORMAL_MNEMONIC(ADDABS, ADDABS, "addabs"),
+    NORMAL_MNEMONIC(ADDHH_W, ADDHH_W, "addhh.w"),
+    NORMAL_MNEMONIC(AND, AND1, "and"),
+    NORMAL_MNEMONIC(ANDH, ANDH, "andh"),
+    NORMAL_MNEMONIC(ANDL, ANDL, "andl"),
+    NORMAL_MNEMONIC(ANDN, ANDN, "andn"),
+    NORMAL_MNEMONIC(ASR, ASR1, "asr"),
+    NORMAL_MNEMONIC(BFEXTS, BFEXTS, "bfexts"),
+    NORMAL_MNEMONIC(BFEXTU, BFEXTU, "bfextu"),
+    NORMAL_MNEMONIC(BFINS, BFINS, "bfins"),
+    NORMAL_MNEMONIC(BLD, BLD, "bld"),
+    NORMAL_MNEMONIC(BREQ, BREQ1, "breq"),
+    NORMAL_MNEMONIC(BRNE, BRNE1, "brne"),
+    NORMAL_MNEMONIC(BRCC, BRCC1, "brcc"),
+    NORMAL_MNEMONIC(BRCS, BRCS1, "brcs"),
+    NORMAL_MNEMONIC(BRGE, BRGE1, "brge"),
+    NORMAL_MNEMONIC(BRLT, BRLT1, "brlt"),
+    NORMAL_MNEMONIC(BRMI, BRMI1, "brmi"),
+    NORMAL_MNEMONIC(BRPL, BRPL1, "brpl"),
+    NORMAL_MNEMONIC(BRHS, BRHS1, "brhs"),
+    NORMAL_MNEMONIC(BRLO, BRLO1, "brlo"),
+    NORMAL_MNEMONIC(BRLS, BRLS, "brls"),
+    NORMAL_MNEMONIC(BRGT, BRGT, "brgt"),
+    NORMAL_MNEMONIC(BRLE, BRLE, "brle"),
+    NORMAL_MNEMONIC(BRHI, BRHI, "brhi"),
+    NORMAL_MNEMONIC(BRVS, BRVS, "brvs"),
+    NORMAL_MNEMONIC(BRVC, BRVC, "brvc"),
+    NORMAL_MNEMONIC(BRQS, BRQS, "brqs"),
+    NORMAL_MNEMONIC(BRAL, BRAL, "bral"),
+    NORMAL_MNEMONIC(BREAKPOINT, BREAKPOINT, "breakpoint"),
+    NORMAL_MNEMONIC(BREV, BREV, "brev"),
+    NORMAL_MNEMONIC(BST, BST, "bst"),
+    NORMAL_MNEMONIC(CACHE, CACHE, "cache"),
+    NORMAL_MNEMONIC(CASTS_B, CASTS_B, "casts.b"),
+    NORMAL_MNEMONIC(CASTS_H, CASTS_H, "casts.h"),
+    NORMAL_MNEMONIC(CASTU_B, CASTU_B, "castu.b"),
+    NORMAL_MNEMONIC(CASTU_H, CASTU_H, "castu.h"),
+    NORMAL_MNEMONIC(CBR, CBR, "cbr"),
+    NORMAL_MNEMONIC(CLZ, CLZ, "clz"),
+    NORMAL_MNEMONIC(COM, COM, "com"),
+    NORMAL_MNEMONIC(COP, COP, "cop"),
+    NORMAL_MNEMONIC(CP_B, CP_B, "cp.b"),
+    NORMAL_MNEMONIC(CP_H, CP_H, "cp.h"),
+    NORMAL_MNEMONIC(CP_W, CP_W1, "cp.w"),
+    NORMAL_MNEMONIC(CP, CP_W1, "cp"),
+    NORMAL_MNEMONIC(CPC, CPC1, "cpc"),
+    NORMAL_MNEMONIC(CSRF, CSRF, "csrf"),
+    NORMAL_MNEMONIC(CSRFCZ, CSRFCZ, "csrfcz"),
+    NORMAL_MNEMONIC(DIVS, DIVS, "divs"),
+    NORMAL_MNEMONIC(DIVU, DIVU, "divu"),
+    NORMAL_MNEMONIC(EOR, EOR1, "eor"),
+    NORMAL_MNEMONIC(EORL, EORL, "eorl"),
+    NORMAL_MNEMONIC(EORH, EORH, "eorh"),
+    NORMAL_MNEMONIC(FRS, FRS, "frs"),
+    NORMAL_MNEMONIC(ICALL, ICALL, "icall"),
+    NORMAL_MNEMONIC(INCJOSP, INCJOSP, "incjosp"),
+    NORMAL_MNEMONIC(LD_D, LD_D1, "ld.d"),
+    NORMAL_MNEMONIC(LD_SB, LD_SB2, "ld.sb"),
+    NORMAL_MNEMONIC(LD_UB, LD_UB1, "ld.ub"),
+    NORMAL_MNEMONIC(LD_SH, LD_SH1, "ld.sh"),
+    NORMAL_MNEMONIC(LD_UH, LD_UH1, "ld.uh"),
+    NORMAL_MNEMONIC(LD_W, LD_W1, "ld.w"),
+    NORMAL_MNEMONIC(LDC_D, LDC_D3, "ldc.d"),
+    NORMAL_MNEMONIC(LDC_W, LDC_W3, "ldc.w"),
+    NORMAL_MNEMONIC(LDC0_D, LDC0_D, "ldc0.d"),
+    NORMAL_MNEMONIC(LDC0_W, LDC0_W, "ldc0.w"),
+    NORMAL_MNEMONIC(LDCM_D, LDCM_D, "ldcm.d"),
+    NORMAL_MNEMONIC(LDCM_W, LDCM_W, "ldcm.w"),
+    NORMAL_MNEMONIC(LDDPC, LDDPC, "lddpc"),
+    NORMAL_MNEMONIC(LDDSP, LDDSP, "lddsp"),
+    NORMAL_MNEMONIC(LDINS_B, LDINS_B, "ldins.b"),
+    NORMAL_MNEMONIC(LDINS_H, LDINS_H, "ldins.h"),
+    NORMAL_MNEMONIC(LDM, LDM, "ldm"),
+    NORMAL_MNEMONIC(LDMTS, LDMTS, "ldmts"),
+    NORMAL_MNEMONIC(LDSWP_SH, LDSWP_SH, "ldswp.sh"),
+    NORMAL_MNEMONIC(LDSWP_UH, LDSWP_UH, "ldswp.uh"),
+    NORMAL_MNEMONIC(LDSWP_W, LDSWP_W, "ldswp.w"),
+    NORMAL_MNEMONIC(LSL, LSL1, "lsl"),
+    NORMAL_MNEMONIC(LSR, LSR1, "lsr"),
+    NORMAL_MNEMONIC(MAC, MAC, "mac"),
+    NORMAL_MNEMONIC(MACHH_D, MACHH_D, "machh.d"),
+    NORMAL_MNEMONIC(MACHH_W, MACHH_W, "machh.w"),
+    NORMAL_MNEMONIC(MACS_D, MACS_D, "macs.d"),
+    NORMAL_MNEMONIC(MACSATHH_W, MACSATHH_W, "macsathh.w"),
+    NORMAL_MNEMONIC(MACU_D, MACUD, "macu.d"),
+    NORMAL_MNEMONIC(MACWH_D, MACWH_D, "macwh.d"),
+    NORMAL_MNEMONIC(MAX, MAX, "max"),
+    NORMAL_MNEMONIC(MCALL, MCALL, "mcall"),
+    NORMAL_MNEMONIC(MFDR, MFDR, "mfdr"),
+    NORMAL_MNEMONIC(MFSR, MFSR, "mfsr"),
+    NORMAL_MNEMONIC(MIN, MIN, "min"),
+    NORMAL_MNEMONIC(MOV, MOV3, "mov"),
+    NORMAL_MNEMONIC(MOVEQ, MOVEQ1, "moveq"),
+    NORMAL_MNEMONIC(MOVNE, MOVNE1, "movne"),
+    NORMAL_MNEMONIC(MOVCC, MOVCC1, "movcc"),
+    NORMAL_MNEMONIC(MOVCS, MOVCS1, "movcs"),
+    NORMAL_MNEMONIC(MOVGE, MOVGE1, "movge"),
+    NORMAL_MNEMONIC(MOVLT, MOVLT1, "movlt"),
+    NORMAL_MNEMONIC(MOVMI, MOVMI1, "movmi"),
+    NORMAL_MNEMONIC(MOVPL, MOVPL1, "movpl"),
+    NORMAL_MNEMONIC(MOVLS, MOVLS1, "movls"),
+    NORMAL_MNEMONIC(MOVGT, MOVGT1, "movgt"),
+    NORMAL_MNEMONIC(MOVLE, MOVLE1, "movle"),
+    NORMAL_MNEMONIC(MOVHI, MOVHI1, "movhi"),
+    NORMAL_MNEMONIC(MOVVS, MOVVS1, "movvs"),
+    NORMAL_MNEMONIC(MOVVC, MOVVC1, "movvc"),
+    NORMAL_MNEMONIC(MOVQS, MOVQS1, "movqs"),
+    NORMAL_MNEMONIC(MOVAL, MOVAL1, "moval"),
+    NORMAL_MNEMONIC(MOVHS, MOVHS1, "movhs"),
+    NORMAL_MNEMONIC(MOVLO, MOVLO1, "movlo"),
+    NORMAL_MNEMONIC(MTDR, MTDR, "mtdr"),
+    NORMAL_MNEMONIC(MTSR, MTSR, "mtsr"),
+    NORMAL_MNEMONIC(MUL, MUL1, "mul"),
+    NORMAL_MNEMONIC(MULHH_W, MULHH_W, "mulhh.w"),
+    NORMAL_MNEMONIC(MULNHH_W, MULNHH_W, "mulnhh.w"),
+    NORMAL_MNEMONIC(MULNWH_D, MULNWH_D, "mulnwh.d"),
+    NORMAL_MNEMONIC(MULS_D, MULSD, "muls.d"),
+    NORMAL_MNEMONIC(MULSATHH_H, MULSATHH_H, "mulsathh.h"),
+    NORMAL_MNEMONIC(MULSATHH_W, MULSATHH_W, "mulsathh.w"),
+    NORMAL_MNEMONIC(MULSATRNDHH_H, MULSATRNDHH_H, "mulsatrndhh.h"),
+    NORMAL_MNEMONIC(MULSATRNDWH_W, MULSATRNDWH_W, "mulsatrndwh.w"),
+    NORMAL_MNEMONIC(MULSATWH_W, MULSATWH_W, "mulsatwh.w"),
+    NORMAL_MNEMONIC(MULU_D, MULU_D, "mulu.d"),
+    NORMAL_MNEMONIC(MULWH_D, MULWH_D, "mulwh.d"),
+    NORMAL_MNEMONIC(MUSFR, MUSFR, "musfr"),
+    NORMAL_MNEMONIC(MUSTR, MUSTR, "mustr"),
+    NORMAL_MNEMONIC(MVCR_D, MVCR_D, "mvcr.d"),
+    NORMAL_MNEMONIC(MVCR_W, MVCR_W, "mvcr.w"),
+    NORMAL_MNEMONIC(MVRC_D, MVRC_D, "mvrc.d"),
+    NORMAL_MNEMONIC(MVRC_W, MVRC_W, "mvrc.w"),
+    NORMAL_MNEMONIC(NEG, NEG, "neg"),
+    NORMAL_MNEMONIC(NOP, NOP, "nop"),
+    NORMAL_MNEMONIC(OR, OR1, "or"),
+    NORMAL_MNEMONIC(ORH, ORH, "orh"),
+    NORMAL_MNEMONIC(ORL, ORL, "orl"),
+    NORMAL_MNEMONIC(PABS_SB, PABS_SB, "pabs.sb"),
+    NORMAL_MNEMONIC(PABS_SH, PABS_SH, "pabs.sh"),
+    NORMAL_MNEMONIC(PACKSH_SB, PACKSH_SB, "packsh.sb"),
+    NORMAL_MNEMONIC(PACKSH_UB, PACKSH_UB, "packsh.ub"),
+    NORMAL_MNEMONIC(PACKW_SH, PACKW_SH, "packw.sh"),
+    NORMAL_MNEMONIC(PADD_B, PADD_B, "padd.b"),
+    NORMAL_MNEMONIC(PADD_H, PADD_H, "padd.h"),
+    NORMAL_MNEMONIC(PADDH_SH, PADDH_SH, "paddh.sh"),
+    NORMAL_MNEMONIC(PADDH_UB, PADDH_UB, "paddh.ub"),
+    NORMAL_MNEMONIC(PADDS_SB, PADDS_SB, "padds.sb"),
+    NORMAL_MNEMONIC(PADDS_SH, PADDS_SH, "padds.sh"),
+    NORMAL_MNEMONIC(PADDS_UB, PADDS_UB, "padds.ub"),
+    NORMAL_MNEMONIC(PADDS_UH, PADDS_UH, "padds.uh"),
+    NORMAL_MNEMONIC(PADDSUB_H, PADDSUB_H, "paddsub.h"),
+    NORMAL_MNEMONIC(PADDSUBH_SH, PADDSUBH_SH, "paddsubh.sh"),
+    NORMAL_MNEMONIC(PADDSUBS_SH, PADDSUBS_SH, "paddsubs.sh"),
+    NORMAL_MNEMONIC(PADDSUBS_UH, PADDSUBS_UH, "paddsubs.uh"),
+    NORMAL_MNEMONIC(PADDX_H, PADDX_H, "paddx.h"),
+    NORMAL_MNEMONIC(PADDXH_SH, PADDXH_SH, "paddxh.sh"),
+    NORMAL_MNEMONIC(PADDXS_SH, PADDXS_SH, "paddxs.sh"),
+    NORMAL_MNEMONIC(PADDXS_UH, PADDXS_UH, "paddxs.uh"),
+    NORMAL_MNEMONIC(PASR_B, PASR_B, "pasr.b"),
+    NORMAL_MNEMONIC(PASR_H, PASR_H, "pasr.h"),
+    NORMAL_MNEMONIC(PAVG_SH, PAVG_SH, "pavg.sh"),
+    NORMAL_MNEMONIC(PAVG_UB, PAVG_UB, "pavg.ub"),
+    NORMAL_MNEMONIC(PLSL_B, PLSL_B, "plsl.b"),
+    NORMAL_MNEMONIC(PLSL_H, PLSL_H, "plsl.h"),
+    NORMAL_MNEMONIC(PLSR_B, PLSR_B, "plsr.b"),
+    NORMAL_MNEMONIC(PLSR_H, PLSR_H, "plsr.h"),
+    NORMAL_MNEMONIC(PMAX_SH, PMAX_SH, "pmax.sh"),
+    NORMAL_MNEMONIC(PMAX_UB, PMAX_UB, "pmax.ub"),
+    NORMAL_MNEMONIC(PMIN_SH, PMIN_SH, "pmin.sh"),
+    NORMAL_MNEMONIC(PMIN_UB, PMIN_UB, "pmin.ub"),
+    NORMAL_MNEMONIC(POPJC, POPJC, "popjc"),
+    NORMAL_MNEMONIC(POPM, POPM, "popm"),
+    NORMAL_MNEMONIC(PREF, PREF, "pref"),
+    NORMAL_MNEMONIC(PSAD, PSAD, "psad"),
+    NORMAL_MNEMONIC(PSUB_B, PSUB_B, "psub.b"),
+    NORMAL_MNEMONIC(PSUB_H, PSUB_H, "psub.h"),
+    NORMAL_MNEMONIC(PSUBADD_H, PSUBADD_H, "psubadd.h"),
+    NORMAL_MNEMONIC(PSUBADDH_SH, PSUBADDH_SH, "psubaddh.sh"),
+    NORMAL_MNEMONIC(PSUBADDS_SH, PSUBADDS_SH, "psubadds.sh"),
+    NORMAL_MNEMONIC(PSUBADDS_UH, PSUBADDS_UH, "psubadds.uh"),
+    NORMAL_MNEMONIC(PSUBH_SH, PSUBH_SH, "psubh.sh"),
+    NORMAL_MNEMONIC(PSUBH_UB, PSUBH_UB, "psubh.ub"),
+    NORMAL_MNEMONIC(PSUBS_SB, PSUBS_SB, "psubs.sb"),
+    NORMAL_MNEMONIC(PSUBS_SH, PSUBS_SH, "psubs.sh"),
+    NORMAL_MNEMONIC(PSUBS_UB, PSUBS_UB, "psubs.ub"),
+    NORMAL_MNEMONIC(PSUBS_UH, PSUBS_UH, "psubs.uh"),
+    NORMAL_MNEMONIC(PSUBX_H, PSUBX_H, "psubx.h"),
+    NORMAL_MNEMONIC(PSUBXH_SH, PSUBXH_SH, "psubxh.sh"),
+    NORMAL_MNEMONIC(PSUBXS_SH, PSUBXS_SH, "psubxs.sh"),
+    NORMAL_MNEMONIC(PSUBXS_UH, PSUBXS_UH, "psubxs.uh"),
+    NORMAL_MNEMONIC(PUNPCKSB_H, PUNPCKSB_H, "punpcksb.h"),
+    NORMAL_MNEMONIC(PUNPCKUB_H, PUNPCKUB_H, "punpckub.h"),
+    NORMAL_MNEMONIC(PUSHJC, PUSHJC, "pushjc"),
+    NORMAL_MNEMONIC(PUSHM, PUSHM, "pushm"),
+    NORMAL_MNEMONIC(RCALL, RCALL1, "rcall"),
+    NORMAL_MNEMONIC(RETEQ, RETEQ, "reteq"),
+    NORMAL_MNEMONIC(RETNE, RETNE, "retne"),
+    NORMAL_MNEMONIC(RETCC, RETCC, "retcc"),
+    NORMAL_MNEMONIC(RETCS, RETCS, "retcs"),
+    NORMAL_MNEMONIC(RETGE, RETGE, "retge"),
+    NORMAL_MNEMONIC(RETLT, RETLT, "retlt"),
+    NORMAL_MNEMONIC(RETMI, RETMI, "retmi"),
+    NORMAL_MNEMONIC(RETPL, RETPL, "retpl"),
+    NORMAL_MNEMONIC(RETLS, RETLS, "retls"),
+    NORMAL_MNEMONIC(RETGT, RETGT, "retgt"),
+    NORMAL_MNEMONIC(RETLE, RETLE, "retle"),
+    NORMAL_MNEMONIC(RETHI, RETHI, "rethi"),
+    NORMAL_MNEMONIC(RETVS, RETVS, "retvs"),
+    NORMAL_MNEMONIC(RETVC, RETVC, "retvc"),
+    NORMAL_MNEMONIC(RETQS, RETQS, "retqs"),
+    NORMAL_MNEMONIC(RETAL, RETAL, "retal"),
+    NORMAL_MNEMONIC(RETHS, RETHS, "reths"),
+    NORMAL_MNEMONIC(RETLO, RETLO, "retlo"),
+    NORMAL_MNEMONIC(RET, RETAL, "ret"),
+    NORMAL_MNEMONIC(RETD, RETD, "retd"),
+    NORMAL_MNEMONIC(RETE, RETE, "rete"),
+    NORMAL_MNEMONIC(RETJ, RETJ, "retj"),
+    NORMAL_MNEMONIC(RETS, RETS, "rets"),
+    NORMAL_MNEMONIC(RJMP, RJMP, "rjmp"),
+    NORMAL_MNEMONIC(ROL, ROL, "rol"),
+    NORMAL_MNEMONIC(ROR, ROR, "ror"),
+    NORMAL_MNEMONIC(RSUB, RSUB1, "rsub"),
+    NORMAL_MNEMONIC(SATADD_H, SATADD_H, "satadd.h"),
+    NORMAL_MNEMONIC(SATADD_W, SATADD_W, "satadd.w"),
+    NORMAL_MNEMONIC(SATRNDS, SATRNDS, "satrnds"),
+    NORMAL_MNEMONIC(SATRNDU, SATRNDU, "satrndu"),
+    NORMAL_MNEMONIC(SATS, SATS, "sats"),
+    NORMAL_MNEMONIC(SATSUB_H, SATSUB_H, "satsub.h"),
+    NORMAL_MNEMONIC(SATSUB_W, SATSUB_W1, "satsub.w"),
+    NORMAL_MNEMONIC(SATU, SATU, "satu"),
+    NORMAL_MNEMONIC(SBC, SBC, "sbc"),
+    NORMAL_MNEMONIC(SBR, SBR, "sbr"),
+    NORMAL_MNEMONIC(SCALL, SCALL, "scall"),
+    NORMAL_MNEMONIC(SCR, SCR, "scr"),
+    NORMAL_MNEMONIC(SLEEP, SLEEP, "sleep"),
+    NORMAL_MNEMONIC(SREQ, SREQ, "sreq"),
+    NORMAL_MNEMONIC(SRNE, SRNE, "srne"),
+    NORMAL_MNEMONIC(SRCC, SRCC, "srcc"),
+    NORMAL_MNEMONIC(SRCS, SRCS, "srcs"),
+    NORMAL_MNEMONIC(SRGE, SRGE, "srge"),
+    NORMAL_MNEMONIC(SRLT, SRLT, "srlt"),
+    NORMAL_MNEMONIC(SRMI, SRMI, "srmi"),
+    NORMAL_MNEMONIC(SRPL, SRPL, "srpl"),
+    NORMAL_MNEMONIC(SRLS, SRLS, "srls"),
+    NORMAL_MNEMONIC(SRGT, SRGT, "srgt"),
+    NORMAL_MNEMONIC(SRLE, SRLE, "srle"),
+    NORMAL_MNEMONIC(SRHI, SRHI, "srhi"),
+    NORMAL_MNEMONIC(SRVS, SRVS, "srvs"),
+    NORMAL_MNEMONIC(SRVC, SRVC, "srvc"),
+    NORMAL_MNEMONIC(SRQS, SRQS, "srqs"),
+    NORMAL_MNEMONIC(SRAL, SRAL, "sral"),
+    NORMAL_MNEMONIC(SRHS, SRHS, "srhs"),
+    NORMAL_MNEMONIC(SRLO, SRLO, "srlo"),
+    NORMAL_MNEMONIC(SSRF, SSRF, "ssrf"),
+    NORMAL_MNEMONIC(ST_B, ST_B1, "st.b"),
+    NORMAL_MNEMONIC(ST_D, ST_D1, "st.d"),
+    NORMAL_MNEMONIC(ST_H, ST_H1, "st.h"),
+    NORMAL_MNEMONIC(ST_W, ST_W1, "st.w"),
+    NORMAL_MNEMONIC(STC_D, STC_D3, "stc.d"),
+    NORMAL_MNEMONIC(STC_W, STC_W3, "stc.w"),
+    NORMAL_MNEMONIC(STC0_D, STC0_D, "stc0.d"),
+    NORMAL_MNEMONIC(STC0_W, STC0_W, "stc0.w"),
+    NORMAL_MNEMONIC(STCM_D, STCM_D, "stcm.d"),
+    NORMAL_MNEMONIC(STCM_W, STCM_W, "stcm.w"),
+    NORMAL_MNEMONIC(STCOND, STCOND, "stcond"),
+    NORMAL_MNEMONIC(STDSP, STDSP, "stdsp"),
+    NORMAL_MNEMONIC(STHH_W, STHH_W2, "sthh.w"),
+    NORMAL_MNEMONIC(STM, STM, "stm"),
+    NORMAL_MNEMONIC(STMTS, STMTS, "stmts"),
+    NORMAL_MNEMONIC(STSWP_H, STSWP_H, "stswp.h"),
+    NORMAL_MNEMONIC(STSWP_W, STSWP_W, "stswp.w"),
+    NORMAL_MNEMONIC(SUB, SUB1, "sub"),
+    NORMAL_MNEMONIC(SUBEQ, SUBEQ, "subeq"),
+    NORMAL_MNEMONIC(SUBNE, SUBNE, "subne"),
+    NORMAL_MNEMONIC(SUBCC, SUBCC, "subcc"),
+    NORMAL_MNEMONIC(SUBCS, SUBCS, "subcs"),
+    NORMAL_MNEMONIC(SUBGE, SUBGE, "subge"),
+    NORMAL_MNEMONIC(SUBLT, SUBLT, "sublt"),
+    NORMAL_MNEMONIC(SUBMI, SUBMI, "submi"),
+    NORMAL_MNEMONIC(SUBPL, SUBPL, "subpl"),
+    NORMAL_MNEMONIC(SUBLS, SUBLS, "subls"),
+    NORMAL_MNEMONIC(SUBGT, SUBGT, "subgt"),
+    NORMAL_MNEMONIC(SUBLE, SUBLE, "suble"),
+    NORMAL_MNEMONIC(SUBHI, SUBHI, "subhi"),
+    NORMAL_MNEMONIC(SUBVS, SUBVS, "subvs"),
+    NORMAL_MNEMONIC(SUBVC, SUBVC, "subvc"),
+    NORMAL_MNEMONIC(SUBQS, SUBQS, "subqs"),
+    NORMAL_MNEMONIC(SUBAL, SUBAL, "subal"),
+    NORMAL_MNEMONIC(SUBHS, SUBHS, "subhs"),
+    NORMAL_MNEMONIC(SUBLO, SUBLO, "sublo"),
+    NORMAL_MNEMONIC(SUBFEQ, SUBFEQ, "subfeq"),
+    NORMAL_MNEMONIC(SUBFNE, SUBFNE, "subfne"),
+    NORMAL_MNEMONIC(SUBFCC, SUBFCC, "subfcc"),
+    NORMAL_MNEMONIC(SUBFCS, SUBFCS, "subfcs"),
+    NORMAL_MNEMONIC(SUBFGE, SUBFGE, "subfge"),
+    NORMAL_MNEMONIC(SUBFLT, SUBFLT, "subflt"),
+    NORMAL_MNEMONIC(SUBFMI, SUBFMI, "subfmi"),
+    NORMAL_MNEMONIC(SUBFPL, SUBFPL, "subfpl"),
+    NORMAL_MNEMONIC(SUBFLS, SUBFLS, "subfls"),
+    NORMAL_MNEMONIC(SUBFGT, SUBFGT, "subfgt"),
+    NORMAL_MNEMONIC(SUBFLE, SUBFLE, "subfle"),
+    NORMAL_MNEMONIC(SUBFHI, SUBFHI, "subfhi"),
+    NORMAL_MNEMONIC(SUBFVS, SUBFVS, "subfvs"),
+    NORMAL_MNEMONIC(SUBFVC, SUBFVC, "subfvc"),
+    NORMAL_MNEMONIC(SUBFQS, SUBFQS, "subfqs"),
+    NORMAL_MNEMONIC(SUBFAL, SUBFAL, "subfal"),
+    NORMAL_MNEMONIC(SUBFHS, SUBFHS, "subfhs"),
+    NORMAL_MNEMONIC(SUBFLO, SUBFLO, "subflo"),
+    NORMAL_MNEMONIC(SUBHH_W, SUBHH_W, "subhh.w"),
+    NORMAL_MNEMONIC(SWAP_B, SWAP_B, "swap.b"),
+    NORMAL_MNEMONIC(SWAP_BH, SWAP_BH, "swap.bh"),
+    NORMAL_MNEMONIC(SWAP_H, SWAP_H, "swap.h"),
+    NORMAL_MNEMONIC(SYNC, SYNC, "sync"),
+    NORMAL_MNEMONIC(TLBR, TLBR, "tlbr"),
+    NORMAL_MNEMONIC(TLBS, TLBS, "tlbs"),
+    NORMAL_MNEMONIC(TLBW, TLBW, "tlbw"),
+    NORMAL_MNEMONIC(TNBZ, TNBZ, "tnbz"),
+    NORMAL_MNEMONIC(TST, TST, "tst"),
+    NORMAL_MNEMONIC(XCHG, XCHG, "xchg"),
+    NORMAL_MNEMONIC(MEMC, MEMC, "memc"),
+    NORMAL_MNEMONIC(MEMS, MEMS, "mems"),
+    NORMAL_MNEMONIC(MEMT, MEMT, "memt"),
+    FP_MNEMONIC(FADD, FADD, "fadd"),
+    FP_MNEMONIC(FSUB, FSUB, "fsub"),
+    FP_MNEMONIC(FMAC, FMAC, "fmac"),
+    FP_MNEMONIC(FNMAC, FNMAC, "fnmac"),
+    FP_MNEMONIC(FMSC, FMSC, "fmsc"),
+    FP_MNEMONIC(FNMSC, FNMSC, "fnmsc"),
+    FP_MNEMONIC(FMUL, FMUL, "fmul"),
+    FP_MNEMONIC(FNMUL, FNMUL, "fnmul"),
+    FP_MNEMONIC(FNEG, FNEG, "fneg"),
+    FP_MNEMONIC(FABS, FABS, "fabs"),
+    FP_MNEMONIC(FCMP, FCMP, "fcmp"),
+    FP_MNEMONIC(FMOV, FMOV1, "fmov"),
+    NORMAL_MNEMONIC(FCASTS_D, FCASTS_D, "fcasts.d"),
+    NORMAL_MNEMONIC(FCASTD_S, FCASTD_S, "fcastd.s"),
+    NORMAL_MNEMONIC(LDA_W, LDA_W, "lda.w"),
+    NORMAL_MNEMONIC(CALL, CALL, "call"),
+    NORMAL_MNEMONIC(PICOSVMAC, PICOSVMAC0, "picosvmac"),
+    NORMAL_MNEMONIC(PICOSVMUL, PICOSVMUL0, "picosvmul"),
+    NORMAL_MNEMONIC(PICOVMAC, PICOVMAC0, "picovmac"),
+    NORMAL_MNEMONIC(PICOVMUL, PICOVMUL0, "picovmul"),
+    NORMAL_MNEMONIC(PICOLD_D, PICOLD_D2, "picold.d"),
+    NORMAL_MNEMONIC(PICOLD_W, PICOLD_W2, "picold.w"),
+    NORMAL_MNEMONIC(PICOLDM_D, PICOLDM_D, "picoldm.d"),
+    NORMAL_MNEMONIC(PICOLDM_W, PICOLDM_W, "picoldm.w"),
+    NORMAL_MNEMONIC(PICOMV_D, PICOMV_D1, "picomv.d"),
+    NORMAL_MNEMONIC(PICOMV_W, PICOMV_W1, "picomv.w"),
+    NORMAL_MNEMONIC(PICOST_D, PICOST_D2, "picost.d"),
+    NORMAL_MNEMONIC(PICOST_W, PICOST_W2, "picost.w"),
+    NORMAL_MNEMONIC(PICOSTM_D, PICOSTM_D, "picostm.d"),
+    NORMAL_MNEMONIC(PICOSTM_W, PICOSTM_W, "picostm.w"),
+    NORMAL_MNEMONIC(RSUBEQ, RSUBEQ, "rsubeq"),
+    NORMAL_MNEMONIC(RSUBNE, RSUBNE, "rsubne"),
+    NORMAL_MNEMONIC(RSUBCC, RSUBCC, "rsubcc"),
+    NORMAL_MNEMONIC(RSUBCS, RSUBCS, "rsubcs"),
+    NORMAL_MNEMONIC(RSUBGE, RSUBGE, "rsubge"),
+    NORMAL_MNEMONIC(RSUBLT, RSUBLT, "rsublt"),
+    NORMAL_MNEMONIC(RSUBMI, RSUBMI, "rsubmi"),
+    NORMAL_MNEMONIC(RSUBPL, RSUBPL, "rsubpl"),
+    NORMAL_MNEMONIC(RSUBLS, RSUBLS, "rsubls"),
+    NORMAL_MNEMONIC(RSUBGT, RSUBGT, "rsubgt"),
+    NORMAL_MNEMONIC(RSUBLE, RSUBLE, "rsuble"),
+    NORMAL_MNEMONIC(RSUBHI, RSUBHI, "rsubhi"),
+    NORMAL_MNEMONIC(RSUBVS, RSUBVS, "rsubvs"),
+    NORMAL_MNEMONIC(RSUBVC, RSUBVC, "rsubvc"),
+    NORMAL_MNEMONIC(RSUBQS, RSUBQS, "rsubqs"),
+    NORMAL_MNEMONIC(RSUBAL, RSUBAL, "rsubal"),
+    NORMAL_MNEMONIC(RSUBHS, RSUBHS, "rsubhs"),
+    NORMAL_MNEMONIC(RSUBLO, RSUBLO, "rsublo"),
+    NORMAL_MNEMONIC(ADDEQ, ADDEQ, "addeq"),
+    NORMAL_MNEMONIC(ADDNE, ADDNE, "addne"),
+    NORMAL_MNEMONIC(ADDCC, ADDCC, "addcc"),
+    NORMAL_MNEMONIC(ADDCS, ADDCS, "addcs"),
+    NORMAL_MNEMONIC(ADDGE, ADDGE, "addge"),
+    NORMAL_MNEMONIC(ADDLT, ADDLT, "addlt"),
+    NORMAL_MNEMONIC(ADDMI, ADDMI, "addmi"),
+    NORMAL_MNEMONIC(ADDPL, ADDPL, "addpl"),
+    NORMAL_MNEMONIC(ADDLS, ADDLS, "addls"),
+    NORMAL_MNEMONIC(ADDGT, ADDGT, "addgt"),
+    NORMAL_MNEMONIC(ADDLE, ADDLE, "addle"),
+    NORMAL_MNEMONIC(ADDHI, ADDHI, "addhi"),
+    NORMAL_MNEMONIC(ADDVS, ADDVS, "addvs"),
+    NORMAL_MNEMONIC(ADDVC, ADDVC, "addvc"),
+    NORMAL_MNEMONIC(ADDQS, ADDQS, "addqs"),
+    NORMAL_MNEMONIC(ADDAL, ADDAL, "addal"),
+    NORMAL_MNEMONIC(ADDHS, ADDHS, "addhs"),
+    NORMAL_MNEMONIC(ADDLO, ADDLO, "addlo"),
+    NORMAL_MNEMONIC(ANDEQ, ANDEQ, "andeq"),
+    NORMAL_MNEMONIC(ANDNE, ANDNE, "andne"),
+    NORMAL_MNEMONIC(ANDCC, ANDCC, "andcc"),
+    NORMAL_MNEMONIC(ANDCS, ANDCS, "andcs"),
+    NORMAL_MNEMONIC(ANDGE, ANDGE, "andge"),
+    NORMAL_MNEMONIC(ANDLT, ANDLT, "andlt"),
+    NORMAL_MNEMONIC(ANDMI, ANDMI, "andmi"),
+    NORMAL_MNEMONIC(ANDPL, ANDPL, "andpl"),
+    NORMAL_MNEMONIC(ANDLS, ANDLS, "andls"),
+    NORMAL_MNEMONIC(ANDGT, ANDGT, "andgt"),
+    NORMAL_MNEMONIC(ANDLE, ANDLE, "andle"),
+    NORMAL_MNEMONIC(ANDHI, ANDHI, "andhi"),
+    NORMAL_MNEMONIC(ANDVS, ANDVS, "andvs"),
+    NORMAL_MNEMONIC(ANDVC, ANDVC, "andvc"),
+    NORMAL_MNEMONIC(ANDQS, ANDQS, "andqs"),
+    NORMAL_MNEMONIC(ANDAL, ANDAL, "andal"),
+    NORMAL_MNEMONIC(ANDHS, ANDHS, "andhs"),
+    NORMAL_MNEMONIC(ANDLO, ANDLO, "andlo"),
+    NORMAL_MNEMONIC(OREQ, OREQ, "oreq"),
+    NORMAL_MNEMONIC(ORNE, ORNE, "orne"),
+    NORMAL_MNEMONIC(ORCC, ORCC, "orcc"),
+    NORMAL_MNEMONIC(ORCS, ORCS, "orcs"),
+    NORMAL_MNEMONIC(ORGE, ORGE, "orge"),
+    NORMAL_MNEMONIC(ORLT, ORLT, "orlt"),
+    NORMAL_MNEMONIC(ORMI, ORMI, "ormi"),
+    NORMAL_MNEMONIC(ORPL, ORPL, "orpl"),
+    NORMAL_MNEMONIC(ORLS, ORLS, "orls"),
+    NORMAL_MNEMONIC(ORGT, ORGT, "orgt"),
+    NORMAL_MNEMONIC(ORLE, ORLE, "orle"),
+    NORMAL_MNEMONIC(ORHI, ORHI, "orhi"),
+    NORMAL_MNEMONIC(ORVS, ORVS, "orvs"),
+    NORMAL_MNEMONIC(ORVC, ORVC, "orvc"),
+    NORMAL_MNEMONIC(ORQS, ORQS, "orqs"),
+    NORMAL_MNEMONIC(ORAL, ORAL, "oral"),
+    NORMAL_MNEMONIC(ORHS, ORHS, "orhs"),
+    NORMAL_MNEMONIC(ORLO, ORLO, "orlo"),
+    NORMAL_MNEMONIC(EOREQ, EOREQ, "eoreq"),
+    NORMAL_MNEMONIC(EORNE, EORNE, "eorne"),
+    NORMAL_MNEMONIC(EORCC, EORCC, "eorcc"),
+    NORMAL_MNEMONIC(EORCS, EORCS, "eorcs"),
+    NORMAL_MNEMONIC(EORGE, EORGE, "eorge"),
+    NORMAL_MNEMONIC(EORLT, EORLT, "eorlt"),
+    NORMAL_MNEMONIC(EORMI, EORMI, "eormi"),
+    NORMAL_MNEMONIC(EORPL, EORPL, "eorpl"),
+    NORMAL_MNEMONIC(EORLS, EORLS, "eorls"),
+    NORMAL_MNEMONIC(EORGT, EORGT, "eorgt"),
+    NORMAL_MNEMONIC(EORLE, EORLE, "eorle"),
+    NORMAL_MNEMONIC(EORHI, EORHI, "eorhi"),
+    NORMAL_MNEMONIC(EORVS, EORVS, "eorvs"),
+    NORMAL_MNEMONIC(EORVC, EORVC, "eorvc"),
+    NORMAL_MNEMONIC(EORQS, EORQS, "eorqs"),
+    NORMAL_MNEMONIC(EORAL, EORAL, "eoral"),
+    NORMAL_MNEMONIC(EORHS, EORHS, "eorhs"),
+    NORMAL_MNEMONIC(EORLO, EORLO, "eorlo"),
+    NORMAL_MNEMONIC(LD_WEQ, LD_WEQ, "ld.weq"),
+    NORMAL_MNEMONIC(LD_WNE, LD_WNE, "ld.wne"),
+    NORMAL_MNEMONIC(LD_WCC, LD_WCC, "ld.wcc"),
+    NORMAL_MNEMONIC(LD_WCS, LD_WCS, "ld.wcs"),
+    NORMAL_MNEMONIC(LD_WGE, LD_WGE, "ld.wge"),
+    NORMAL_MNEMONIC(LD_WLT, LD_WLT, "ld.wlt"),
+    NORMAL_MNEMONIC(LD_WMI, LD_WMI, "ld.wmi"),
+    NORMAL_MNEMONIC(LD_WPL, LD_WPL, "ld.wpl"),
+    NORMAL_MNEMONIC(LD_WLS, LD_WLS, "ld.wls"),
+    NORMAL_MNEMONIC(LD_WGT, LD_WGT, "ld.wgt"),
+    NORMAL_MNEMONIC(LD_WLE, LD_WLE, "ld.wle"),
+    NORMAL_MNEMONIC(LD_WHI, LD_WHI, "ld.whi"),
+    NORMAL_MNEMONIC(LD_WVS, LD_WVS, "ld.wvs"),
+    NORMAL_MNEMONIC(LD_WVC, LD_WVC, "ld.wvc"),
+    NORMAL_MNEMONIC(LD_WQS, LD_WQS, "ld.wqs"),
+    NORMAL_MNEMONIC(LD_WAL, LD_WAL, "ld.wal"),
+    NORMAL_MNEMONIC(LD_WHS, LD_WHS, "ld.whs"),
+    NORMAL_MNEMONIC(LD_WLO, LD_WLO, "ld.wlo"),
+    NORMAL_MNEMONIC(LD_SHEQ, LD_SHEQ, "ld.sheq"),
+    NORMAL_MNEMONIC(LD_SHNE, LD_SHNE, "ld.shne"),
+    NORMAL_MNEMONIC(LD_SHCC, LD_SHCC, "ld.shcc"),
+    NORMAL_MNEMONIC(LD_SHCS, LD_SHCS, "ld.shcs"),
+    NORMAL_MNEMONIC(LD_SHGE, LD_SHGE, "ld.shge"),
+    NORMAL_MNEMONIC(LD_SHLT, LD_SHLT, "ld.shlt"),
+    NORMAL_MNEMONIC(LD_SHMI, LD_SHMI, "ld.shmi"),
+    NORMAL_MNEMONIC(LD_SHPL, LD_SHPL, "ld.shpl"),
+    NORMAL_MNEMONIC(LD_SHLS, LD_SHLS, "ld.shls"),
+    NORMAL_MNEMONIC(LD_SHGT, LD_SHGT, "ld.shgt"),
+    NORMAL_MNEMONIC(LD_SHLE, LD_SHLE, "ld.shle"),
+    NORMAL_MNEMONIC(LD_SHHI, LD_SHHI, "ld.shhi"),
+    NORMAL_MNEMONIC(LD_SHVS, LD_SHVS, "ld.shvs"),
+    NORMAL_MNEMONIC(LD_SHVC, LD_SHVC, "ld.shvc"),
+    NORMAL_MNEMONIC(LD_SHQS, LD_SHQS, "ld.shqs"),
+    NORMAL_MNEMONIC(LD_SHAL, LD_SHAL, "ld.shal"),
+    NORMAL_MNEMONIC(LD_SHHS, LD_SHHS, "ld.shhs"),
+    NORMAL_MNEMONIC(LD_SHLO, LD_SHLO, "ld.shlo"),
+    NORMAL_MNEMONIC(LD_UHEQ, LD_UHEQ, "ld.uheq"),
+    NORMAL_MNEMONIC(LD_UHNE, LD_UHNE, "ld.uhne"),
+    NORMAL_MNEMONIC(LD_UHCC, LD_UHCC, "ld.uhcc"),
+    NORMAL_MNEMONIC(LD_UHCS, LD_UHCS, "ld.uhcs"),
+    NORMAL_MNEMONIC(LD_UHGE, LD_UHGE, "ld.uhge"),
+    NORMAL_MNEMONIC(LD_UHLT, LD_UHLT, "ld.uhlt"),
+    NORMAL_MNEMONIC(LD_UHMI, LD_UHMI, "ld.uhmi"),
+    NORMAL_MNEMONIC(LD_UHPL, LD_UHPL, "ld.uhpl"),
+    NORMAL_MNEMONIC(LD_UHLS, LD_UHLS, "ld.uhls"),
+    NORMAL_MNEMONIC(LD_UHGT, LD_UHGT, "ld.uhgt"),
+    NORMAL_MNEMONIC(LD_UHLE, LD_UHLE, "ld.uhle"),
+    NORMAL_MNEMONIC(LD_UHHI, LD_UHHI, "ld.uhhi"),
+    NORMAL_MNEMONIC(LD_UHVS, LD_UHVS, "ld.uhvs"),
+    NORMAL_MNEMONIC(LD_UHVC, LD_UHVC, "ld.uhvc"),
+    NORMAL_MNEMONIC(LD_UHQS, LD_UHQS, "ld.uhqs"),
+    NORMAL_MNEMONIC(LD_UHAL, LD_UHAL, "ld.uhal"),
+    NORMAL_MNEMONIC(LD_UHHS, LD_UHHS, "ld.uhhs"),
+    NORMAL_MNEMONIC(LD_UHLO, LD_UHLO, "ld.uhlo"),
+    NORMAL_MNEMONIC(LD_SBEQ, LD_SBEQ, "ld.sbeq"),
+    NORMAL_MNEMONIC(LD_SBNE, LD_SBNE, "ld.sbne"),
+    NORMAL_MNEMONIC(LD_SBCC, LD_SBCC, "ld.sbcc"),
+    NORMAL_MNEMONIC(LD_SBCS, LD_SBCS, "ld.sbcs"),
+    NORMAL_MNEMONIC(LD_SBGE, LD_SBGE, "ld.sbge"),
+    NORMAL_MNEMONIC(LD_SBLT, LD_SBLT, "ld.sblt"),
+    NORMAL_MNEMONIC(LD_SBMI, LD_SBMI, "ld.sbmi"),
+    NORMAL_MNEMONIC(LD_SBPL, LD_SBPL, "ld.sbpl"),
+    NORMAL_MNEMONIC(LD_SBLS, LD_SBLS, "ld.sbls"),
+    NORMAL_MNEMONIC(LD_SBGT, LD_SBGT, "ld.sbgt"),
+    NORMAL_MNEMONIC(LD_SBLE, LD_SBLE, "ld.sble"),
+    NORMAL_MNEMONIC(LD_SBHI, LD_SBHI, "ld.sbhi"),
+    NORMAL_MNEMONIC(LD_SBVS, LD_SBVS, "ld.sbvs"),
+    NORMAL_MNEMONIC(LD_SBVC, LD_SBVC, "ld.sbvc"),
+    NORMAL_MNEMONIC(LD_SBQS, LD_SBQS, "ld.sbqs"),
+    NORMAL_MNEMONIC(LD_SBAL, LD_SBAL, "ld.sbal"),
+    NORMAL_MNEMONIC(LD_SBHS, LD_SBHS, "ld.sbhs"),
+    NORMAL_MNEMONIC(LD_SBLO, LD_SBLO, "ld.sblo"),
+    NORMAL_MNEMONIC(LD_UBEQ, LD_UBEQ, "ld.ubeq"),
+    NORMAL_MNEMONIC(LD_UBNE, LD_UBNE, "ld.ubne"),
+    NORMAL_MNEMONIC(LD_UBCC, LD_UBCC, "ld.ubcc"),
+    NORMAL_MNEMONIC(LD_UBCS, LD_UBCS, "ld.ubcs"),
+    NORMAL_MNEMONIC(LD_UBGE, LD_UBGE, "ld.ubge"),
+    NORMAL_MNEMONIC(LD_UBLT, LD_UBLT, "ld.ublt"),
+    NORMAL_MNEMONIC(LD_UBMI, LD_UBMI, "ld.ubmi"),
+    NORMAL_MNEMONIC(LD_UBPL, LD_UBPL, "ld.ubpl"),
+    NORMAL_MNEMONIC(LD_UBLS, LD_UBLS, "ld.ubls"),
+    NORMAL_MNEMONIC(LD_UBGT, LD_UBGT, "ld.ubgt"),
+    NORMAL_MNEMONIC(LD_UBLE, LD_UBLE, "ld.uble"),
+    NORMAL_MNEMONIC(LD_UBHI, LD_UBHI, "ld.ubhi"),
+    NORMAL_MNEMONIC(LD_UBVS, LD_UBVS, "ld.ubvs"),
+    NORMAL_MNEMONIC(LD_UBVC, LD_UBVC, "ld.ubvc"),
+    NORMAL_MNEMONIC(LD_UBQS, LD_UBQS, "ld.ubqs"),
+    NORMAL_MNEMONIC(LD_UBAL, LD_UBAL, "ld.ubal"),
+    NORMAL_MNEMONIC(LD_UBHS, LD_UBHS, "ld.ubhs"),
+    NORMAL_MNEMONIC(LD_UBLO, LD_UBLO, "ld.ublo"),
+    NORMAL_MNEMONIC(ST_WEQ, ST_WEQ, "st.weq"),
+    NORMAL_MNEMONIC(ST_WNE, ST_WNE, "st.wne"),
+    NORMAL_MNEMONIC(ST_WCC, ST_WCC, "st.wcc"),
+    NORMAL_MNEMONIC(ST_WCS, ST_WCS, "st.wcs"),
+    NORMAL_MNEMONIC(ST_WGE, ST_WGE, "st.wge"),
+    NORMAL_MNEMONIC(ST_WLT, ST_WLT, "st.wlt"),
+    NORMAL_MNEMONIC(ST_WMI, ST_WMI, "st.wmi"),
+    NORMAL_MNEMONIC(ST_WPL, ST_WPL, "st.wpl"),
+    NORMAL_MNEMONIC(ST_WLS, ST_WLS, "st.wls"),
+    NORMAL_MNEMONIC(ST_WGT, ST_WGT, "st.wgt"),
+    NORMAL_MNEMONIC(ST_WLE, ST_WLE, "st.wle"),
+    NORMAL_MNEMONIC(ST_WHI, ST_WHI, "st.whi"),
+    NORMAL_MNEMONIC(ST_WVS, ST_WVS, "st.wvs"),
+    NORMAL_MNEMONIC(ST_WVC, ST_WVC, "st.wvc"),
+    NORMAL_MNEMONIC(ST_WQS, ST_WQS, "st.wqs"),
+    NORMAL_MNEMONIC(ST_WAL, ST_WAL, "st.wal"),
+    NORMAL_MNEMONIC(ST_WHS, ST_WHS, "st.whs"),
+    NORMAL_MNEMONIC(ST_WLO, ST_WLO, "st.wlo"),
+    NORMAL_MNEMONIC(ST_HEQ, ST_HEQ, "st.heq"),
+    NORMAL_MNEMONIC(ST_HNE, ST_HNE, "st.hne"),
+    NORMAL_MNEMONIC(ST_HCC, ST_HCC, "st.hcc"),
+    NORMAL_MNEMONIC(ST_HCS, ST_HCS, "st.hcs"),
+    NORMAL_MNEMONIC(ST_HGE, ST_HGE, "st.hge"),
+    NORMAL_MNEMONIC(ST_HLT, ST_HLT, "st.hlt"),
+    NORMAL_MNEMONIC(ST_HMI, ST_HMI, "st.hmi"),
+    NORMAL_MNEMONIC(ST_HPL, ST_HPL, "st.hpl"),
+    NORMAL_MNEMONIC(ST_HLS, ST_HLS, "st.hls"),
+    NORMAL_MNEMONIC(ST_HGT, ST_HGT, "st.hgt"),
+    NORMAL_MNEMONIC(ST_HLE, ST_HLE, "st.hle"),
+    NORMAL_MNEMONIC(ST_HHI, ST_HHI, "st.hhi"),
+    NORMAL_MNEMONIC(ST_HVS, ST_HVS, "st.hvs"),
+    NORMAL_MNEMONIC(ST_HVC, ST_HVC, "st.hvc"),
+    NORMAL_MNEMONIC(ST_HQS, ST_HQS, "st.hqs"),
+    NORMAL_MNEMONIC(ST_HAL, ST_HAL, "st.hal"),
+    NORMAL_MNEMONIC(ST_HHS, ST_HHS, "st.hhs"),
+    NORMAL_MNEMONIC(ST_HLO, ST_HLO, "st.hlo"),
+    NORMAL_MNEMONIC(ST_BEQ, ST_BEQ, "st.beq"),
+    NORMAL_MNEMONIC(ST_BNE, ST_BNE, "st.bne"),
+    NORMAL_MNEMONIC(ST_BCC, ST_BCC, "st.bcc"),
+    NORMAL_MNEMONIC(ST_BCS, ST_BCS, "st.bcs"),
+    NORMAL_MNEMONIC(ST_BGE, ST_BGE, "st.bge"),
+    NORMAL_MNEMONIC(ST_BLT, ST_BLT, "st.blt"),
+    NORMAL_MNEMONIC(ST_BMI, ST_BMI, "st.bmi"),
+    NORMAL_MNEMONIC(ST_BPL, ST_BPL, "st.bpl"),
+    NORMAL_MNEMONIC(ST_BLS, ST_BLS, "st.bls"),
+    NORMAL_MNEMONIC(ST_BGT, ST_BGT, "st.bgt"),
+    NORMAL_MNEMONIC(ST_BLE, ST_BLE, "st.ble"),
+    NORMAL_MNEMONIC(ST_BHI, ST_BHI, "st.bhi"),
+    NORMAL_MNEMONIC(ST_BVS, ST_BVS, "st.bvs"),
+    NORMAL_MNEMONIC(ST_BVC, ST_BVC, "st.bvc"),
+    NORMAL_MNEMONIC(ST_BQS, ST_BQS, "st.bqs"),
+    NORMAL_MNEMONIC(ST_BAL, ST_BAL, "st.bal"),
+    NORMAL_MNEMONIC(ST_BHS, ST_BHS, "st.bhs"),
+    NORMAL_MNEMONIC(ST_BLO, ST_BLO, "st.blo"),
+    NORMAL_MNEMONIC(MOVH, MOVH, "movh"),
+
+  };
+#undef NORMAL_MNEMONIC
+#undef ALIAS_MNEMONIC
+#undef FP_MNEMONIC
--- /dev/null
+++ b/opcodes/avr32-opc.h
@@ -0,0 +1,2370 @@
+/* Opcode tables for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "bfd.h"
+
+#define AVR32_MAX_OPERANDS	8
+#define AVR32_MAX_FIELDS	8
+
+#define AVR32_V1	        (1 << 1)
+#define AVR32_SIMD		(1 << 2)
+#define AVR32_DSP		(1 << 3)
+#define AVR32_RMW		(1 << 4)
+#define AVR32_V2	        (1 << 5)
+#define AVR32_FP		(1 << 16)
+#define AVR32_PICO		(1 << 17)
+
+/* Registers we commonly refer to */
+#define AVR32_REG_R12		12
+#define AVR32_REG_SP		13
+#define AVR32_REG_LR		14
+#define AVR32_REG_PC		15
+
+struct avr32_ifield
+{
+  int id;
+  unsigned short bitsize;
+  unsigned short shift;
+  unsigned long mask;
+
+  /* If the value doesn't fit, it will be truncated with no warning */
+  void (*insert)(const struct avr32_ifield *, void *, unsigned long);
+  void (*extract)(const struct avr32_ifield *, void *, unsigned long *);
+};
+
+struct avr32_opcode
+{
+  int id;
+  int size;
+  unsigned long value;
+  unsigned long mask;
+  const struct avr32_syntax *syntax;
+  bfd_reloc_code_real_type reloc_type;
+  unsigned int nr_fields;
+  /* if relaxable, which field is variable, otherwise -1 */
+  int var_field;
+  const struct avr32_ifield *fields[AVR32_MAX_FIELDS];
+};
+
+struct avr32_alias
+{
+  int id;
+  const struct avr32_opcode *opc;
+  struct {
+    int is_opindex;
+    unsigned long value;
+  } operand_map[AVR32_MAX_OPERANDS];
+};
+
+struct avr32_syntax
+{
+  int id;
+  unsigned long isa_flags;
+  const struct avr32_mnemonic *mnemonic;
+  int type;
+  union {
+    const struct avr32_opcode *opc;
+    const struct avr32_alias *alias;
+  } u;
+  const struct avr32_syntax *next;
+  /* negative means "vararg" */
+  int nr_operands;
+  int operand[AVR32_MAX_OPERANDS];
+};
+
+#if 0
+#define AVR32_ALIAS_MAKE_CONST(val) ((val) | 0x80000000UL)
+#define AVR32_ALIAS_IS_CONST(mapval) (((mapval) & 0x80000000UL) != 0)
+#define AVR32_ALIAS_GET_CONST(mapval) ((mapval) & ~0x80000000UL)
+#endif
+
+struct avr32_mnemonic
+{
+  int id;
+  const char *name;
+  const struct avr32_syntax *syntax;
+};
+
+extern const struct avr32_ifield avr32_ifield_table[];
+extern struct avr32_opcode avr32_opc_table[];
+extern const struct avr32_syntax avr32_syntax_table[];
+extern const struct avr32_alias avr32_alias_table[];
+extern const struct avr32_mnemonic avr32_mnemonic_table[];
+
+extern void avr32_insert_simple(const struct avr32_ifield *field,
+				void *buf, unsigned long value);
+extern void avr32_insert_bit5c(const struct avr32_ifield *field,
+			       void *buf, unsigned long value);
+extern void avr32_insert_k10(const struct avr32_ifield *field,
+			     void *buf, unsigned long value);
+extern void avr32_insert_k21(const struct avr32_ifield *field,
+			     void *buf, unsigned long value);
+extern void avr32_insert_cpop(const struct avr32_ifield *field,
+			      void *buf, unsigned long value);
+extern void avr32_insert_k12cp(const struct avr32_ifield *field,
+			       void *buf, unsigned long value);
+
+extern void avr32_extract_simple(const struct avr32_ifield *field,
+				 void *buf, unsigned long *value);
+extern void avr32_extract_bit5c(const struct avr32_ifield *field,
+				void *buf, unsigned long *value);
+extern void avr32_extract_k10(const struct avr32_ifield *field,
+			      void *buf, unsigned long *value);
+extern void avr32_extract_k21(const struct avr32_ifield *field,
+			      void *buf, unsigned long *value);
+extern void avr32_extract_cpop(const struct avr32_ifield *field,
+			       void *buf, unsigned long *value);
+extern void avr32_extract_k12cp(const struct avr32_ifield *field,
+				void *buf, unsigned long *value);
+
+enum avr32_operand_type
+{
+  AVR32_OPERAND_INTREG,		/* just a register */
+  AVR32_OPERAND_INTREG_PREDEC,	/* register with pre-decrement */
+  AVR32_OPERAND_INTREG_POSTINC,	/* register with post-increment */
+  AVR32_OPERAND_INTREG_LSL,	/* register with left shift */
+  AVR32_OPERAND_INTREG_LSR,	/* register with right shift */
+  AVR32_OPERAND_INTREG_BSEL,	/* register with byte selector */
+  AVR32_OPERAND_INTREG_HSEL,	/* register with halfword selector */
+  AVR32_OPERAND_INTREG_SDISP,	/* Rp[signed disp] */
+  AVR32_OPERAND_INTREG_SDISP_H,	/* Rp[signed hword-aligned disp] */
+  AVR32_OPERAND_INTREG_SDISP_W,	/* Rp[signed word-aligned disp] */
+  AVR32_OPERAND_INTREG_UDISP,	/* Rp[unsigned disp] */
+  AVR32_OPERAND_INTREG_UDISP_H,	/* Rp[unsigned hword-aligned disp] */
+  AVR32_OPERAND_INTREG_UDISP_W, /* Rp[unsigned word-aligned disp] */
+  AVR32_OPERAND_INTREG_INDEX,	/* Rp[Ri << sa] */
+  AVR32_OPERAND_INTREG_XINDEX,	/* Rp[Ri:bytesel << 2] */
+  AVR32_OPERAND_DWREG,		/* Even-numbered register */
+  AVR32_OPERAND_PC_UDISP_W,	/* PC[unsigned word-aligned disp] or label */
+  AVR32_OPERAND_SP,		/* Just SP */
+  AVR32_OPERAND_SP_UDISP_W,	/* SP[unsigned word-aligned disp] */
+  AVR32_OPERAND_CPNO,
+  AVR32_OPERAND_CPREG,
+  AVR32_OPERAND_CPREG_D,
+  AVR32_OPERAND_UNSIGNED_CONST,
+  AVR32_OPERAND_UNSIGNED_CONST_W,
+  AVR32_OPERAND_SIGNED_CONST,
+  AVR32_OPERAND_SIGNED_CONST_W,
+  AVR32_OPERAND_JMPLABEL,
+  AVR32_OPERAND_UNSIGNED_NUMBER,
+  AVR32_OPERAND_UNSIGNED_NUMBER_W,
+  AVR32_OPERAND_REGLIST8,
+  AVR32_OPERAND_REGLIST9,
+  AVR32_OPERAND_REGLIST16,
+  AVR32_OPERAND_REGLIST_LDM,
+  AVR32_OPERAND_REGLIST_CP8,
+  AVR32_OPERAND_REGLIST_CPD8,
+  AVR32_OPERAND_RETVAL,
+  AVR32_OPERAND_MCALL,
+  AVR32_OPERAND_JOSPINC,
+  AVR32_OPERAND_COH,
+  AVR32_OPERAND_FPREG_S,
+  AVR32_OPERAND_FPREG_D,
+  AVR32_OPERAND_PICO_REG_W,
+  AVR32_OPERAND_PICO_REG_D,
+  AVR32_OPERAND_PICO_REGLIST_W,
+  AVR32_OPERAND_PICO_REGLIST_D,
+  AVR32_OPERAND_PICO_IN,
+  AVR32_OPERAND_PICO_OUT0,
+  AVR32_OPERAND_PICO_OUT1,
+  AVR32_OPERAND_PICO_OUT2,
+  AVR32_OPERAND_PICO_OUT3,
+  AVR32_OPERAND__END_
+};
+#define AVR32_OPERAND_UNKNOWN AVR32_OPERAND__END_
+#define AVR32_NR_OPERANDS AVR32_OPERAND__END_
+
+enum avr32_ifield_type
+{
+  AVR32_IFIELD_RX,
+  AVR32_IFIELD_RY,
+  AVR32_IFIELD_COND4C,
+  AVR32_IFIELD_K8C,
+  AVR32_IFIELD_K7C,
+  AVR32_IFIELD_K5C,
+  AVR32_IFIELD_K3,
+  AVR32_IFIELD_RY_DW,
+  AVR32_IFIELD_COND4E,
+  AVR32_IFIELD_K8E,
+  AVR32_IFIELD_BIT5C,
+  AVR32_IFIELD_COND3,
+  AVR32_IFIELD_K10,
+  AVR32_IFIELD_POPM,
+  AVR32_IFIELD_K2,
+  AVR32_IFIELD_RD_E,
+  AVR32_IFIELD_RD_DW,
+  AVR32_IFIELD_X,
+  AVR32_IFIELD_Y,
+  AVR32_IFIELD_X2,
+  AVR32_IFIELD_Y2,
+  AVR32_IFIELD_K5E,
+  AVR32_IFIELD_PART2,
+  AVR32_IFIELD_PART1,
+  AVR32_IFIELD_K16,
+  AVR32_IFIELD_CACHEOP,
+  AVR32_IFIELD_K11,
+  AVR32_IFIELD_K21,
+  AVR32_IFIELD_CPOP,
+  AVR32_IFIELD_CPNO,
+  AVR32_IFIELD_CRD_RI,
+  AVR32_IFIELD_CRX,
+  AVR32_IFIELD_CRY,
+  AVR32_IFIELD_K7E,
+  AVR32_IFIELD_CRD_DW,
+  AVR32_IFIELD_PART1_K12,
+  AVR32_IFIELD_PART2_K12,
+  AVR32_IFIELD_K12,
+  AVR32_IFIELD_S5,
+  AVR32_IFIELD_K5E2,
+  AVR32_IFIELD_K4,
+  AVR32_IFIELD_COND4E2,
+  AVR32_IFIELD_K8E2,
+  AVR32_IFIELD_K6,
+  AVR32_IFIELD_MEM15,
+  AVR32_IFIELD_MEMB5,
+  AVR32_IFIELD_W,
+  AVR32_IFIELD_CM_HL,
+  AVR32_IFIELD_K12CP,
+  AVR32_IFIELD_K9E,
+  AVR32_IFIELD__END_,
+};
+#define AVR32_NR_IFIELDS AVR32_IFIELD__END_
+
+enum avr32_opc_type
+{
+  AVR32_OPC_ABS,
+  AVR32_OPC_ACALL,
+  AVR32_OPC_ACR,
+  AVR32_OPC_ADC,
+  AVR32_OPC_ADD1,
+  AVR32_OPC_ADD2,
+  AVR32_OPC_ADDABS,
+  AVR32_OPC_ADDHH_W,
+  AVR32_OPC_AND1,
+  AVR32_OPC_AND2,
+  AVR32_OPC_AND3,
+  AVR32_OPC_ANDH,
+  AVR32_OPC_ANDH_COH,
+  AVR32_OPC_ANDL,
+  AVR32_OPC_ANDL_COH,
+  AVR32_OPC_ANDN,
+  AVR32_OPC_ASR1,
+  AVR32_OPC_ASR3,
+  AVR32_OPC_ASR2,
+  AVR32_OPC_BLD,
+  AVR32_OPC_BREQ1,
+  AVR32_OPC_BRNE1,
+  AVR32_OPC_BRCC1,
+  AVR32_OPC_BRCS1,
+  AVR32_OPC_BRGE1,
+  AVR32_OPC_BRLT1,
+  AVR32_OPC_BRMI1,
+  AVR32_OPC_BRPL1,
+  AVR32_OPC_BREQ2,
+  AVR32_OPC_BRNE2,
+  AVR32_OPC_BRCC2,
+  AVR32_OPC_BRCS2,
+  AVR32_OPC_BRGE2,
+  AVR32_OPC_BRLT2,
+  AVR32_OPC_BRMI2,
+  AVR32_OPC_BRPL2,
+  AVR32_OPC_BRLS,
+  AVR32_OPC_BRGT,
+  AVR32_OPC_BRLE,
+  AVR32_OPC_BRHI,
+  AVR32_OPC_BRVS,
+  AVR32_OPC_BRVC,
+  AVR32_OPC_BRQS,
+  AVR32_OPC_BRAL,
+  AVR32_OPC_BREAKPOINT,
+  AVR32_OPC_BREV,
+  AVR32_OPC_BST,
+  AVR32_OPC_CACHE,
+  AVR32_OPC_CASTS_B,
+  AVR32_OPC_CASTS_H,
+  AVR32_OPC_CASTU_B,
+  AVR32_OPC_CASTU_H,
+  AVR32_OPC_CBR,
+  AVR32_OPC_CLZ,
+  AVR32_OPC_COM,
+  AVR32_OPC_COP,
+  AVR32_OPC_CP_B,
+  AVR32_OPC_CP_H,
+  AVR32_OPC_CP_W1,
+  AVR32_OPC_CP_W2,
+  AVR32_OPC_CP_W3,
+  AVR32_OPC_CPC1,
+  AVR32_OPC_CPC2,
+  AVR32_OPC_CSRF,
+  AVR32_OPC_CSRFCZ,
+  AVR32_OPC_DIVS,
+  AVR32_OPC_DIVU,
+  AVR32_OPC_EOR1,
+  AVR32_OPC_EOR2,
+  AVR32_OPC_EOR3,
+  AVR32_OPC_EORL,
+  AVR32_OPC_EORH,
+  AVR32_OPC_FRS,
+  AVR32_OPC_ICALL,
+  AVR32_OPC_INCJOSP,
+  AVR32_OPC_LD_D1,
+  AVR32_OPC_LD_D2,
+  AVR32_OPC_LD_D3,
+  AVR32_OPC_LD_D5,
+  AVR32_OPC_LD_D4,
+  AVR32_OPC_LD_SB2,
+  AVR32_OPC_LD_SB1,
+  AVR32_OPC_LD_UB1,
+  AVR32_OPC_LD_UB2,
+  AVR32_OPC_LD_UB5,
+  AVR32_OPC_LD_UB3,
+  AVR32_OPC_LD_UB4,
+  AVR32_OPC_LD_SH1,
+  AVR32_OPC_LD_SH2,
+  AVR32_OPC_LD_SH5,
+  AVR32_OPC_LD_SH3,
+  AVR32_OPC_LD_SH4,
+  AVR32_OPC_LD_UH1,
+  AVR32_OPC_LD_UH2,
+  AVR32_OPC_LD_UH5,
+  AVR32_OPC_LD_UH3,
+  AVR32_OPC_LD_UH4,
+  AVR32_OPC_LD_W1,
+  AVR32_OPC_LD_W2,
+  AVR32_OPC_LD_W5,
+  AVR32_OPC_LD_W6,
+  AVR32_OPC_LD_W3,
+  AVR32_OPC_LD_W4,
+  AVR32_OPC_LDC_D1,
+  AVR32_OPC_LDC_D2,
+  AVR32_OPC_LDC_D3,
+  AVR32_OPC_LDC_W1,
+  AVR32_OPC_LDC_W2,
+  AVR32_OPC_LDC_W3,
+  AVR32_OPC_LDC0_D,
+  AVR32_OPC_LDC0_W,
+  AVR32_OPC_LDCM_D,
+  AVR32_OPC_LDCM_D_PU,
+  AVR32_OPC_LDCM_W,
+  AVR32_OPC_LDCM_W_PU,
+  AVR32_OPC_LDDPC,
+  AVR32_OPC_LDDPC_EXT,
+  AVR32_OPC_LDDSP,
+  AVR32_OPC_LDINS_B,
+  AVR32_OPC_LDINS_H,
+  AVR32_OPC_LDM,
+  AVR32_OPC_LDMTS,
+  AVR32_OPC_LDMTS_PU,
+  AVR32_OPC_LDSWP_SH,
+  AVR32_OPC_LDSWP_UH,
+  AVR32_OPC_LDSWP_W,
+  AVR32_OPC_LSL1,
+  AVR32_OPC_LSL3,
+  AVR32_OPC_LSL2,
+  AVR32_OPC_LSR1,
+  AVR32_OPC_LSR3,
+  AVR32_OPC_LSR2,
+  AVR32_OPC_MAC,
+  AVR32_OPC_MACHH_D,
+  AVR32_OPC_MACHH_W,
+  AVR32_OPC_MACS_D,
+  AVR32_OPC_MACSATHH_W,
+  AVR32_OPC_MACUD,
+  AVR32_OPC_MACWH_D,
+  AVR32_OPC_MAX,
+  AVR32_OPC_MCALL,
+  AVR32_OPC_MFDR,
+  AVR32_OPC_MFSR,
+  AVR32_OPC_MIN,
+  AVR32_OPC_MOV3,
+  AVR32_OPC_MOV1,
+  AVR32_OPC_MOV2,
+  AVR32_OPC_MOVEQ1,
+  AVR32_OPC_MOVNE1,
+  AVR32_OPC_MOVCC1,
+  AVR32_OPC_MOVCS1,
+  AVR32_OPC_MOVGE1,
+  AVR32_OPC_MOVLT1,
+  AVR32_OPC_MOVMI1,
+  AVR32_OPC_MOVPL1,
+  AVR32_OPC_MOVLS1,
+  AVR32_OPC_MOVGT1,
+  AVR32_OPC_MOVLE1,
+  AVR32_OPC_MOVHI1,
+  AVR32_OPC_MOVVS1,
+  AVR32_OPC_MOVVC1,
+  AVR32_OPC_MOVQS1,
+  AVR32_OPC_MOVAL1,
+  AVR32_OPC_MOVEQ2,
+  AVR32_OPC_MOVNE2,
+  AVR32_OPC_MOVCC2,
+  AVR32_OPC_MOVCS2,
+  AVR32_OPC_MOVGE2,
+  AVR32_OPC_MOVLT2,
+  AVR32_OPC_MOVMI2,
+  AVR32_OPC_MOVPL2,
+  AVR32_OPC_MOVLS2,
+  AVR32_OPC_MOVGT2,
+  AVR32_OPC_MOVLE2,
+  AVR32_OPC_MOVHI2,
+  AVR32_OPC_MOVVS2,
+  AVR32_OPC_MOVVC2,
+  AVR32_OPC_MOVQS2,
+  AVR32_OPC_MOVAL2,
+  AVR32_OPC_MTDR,
+  AVR32_OPC_MTSR,
+  AVR32_OPC_MUL1,
+  AVR32_OPC_MUL2,
+  AVR32_OPC_MUL3,
+  AVR32_OPC_MULHH_W,
+  AVR32_OPC_MULNHH_W,
+  AVR32_OPC_MULNWH_D,
+  AVR32_OPC_MULSD,
+  AVR32_OPC_MULSATHH_H,
+  AVR32_OPC_MULSATHH_W,
+  AVR32_OPC_MULSATRNDHH_H,
+  AVR32_OPC_MULSATRNDWH_W,
+  AVR32_OPC_MULSATWH_W,
+  AVR32_OPC_MULU_D,
+  AVR32_OPC_MULWH_D,
+  AVR32_OPC_MUSFR,
+  AVR32_OPC_MUSTR,
+  AVR32_OPC_MVCR_D,
+  AVR32_OPC_MVCR_W,
+  AVR32_OPC_MVRC_D,
+  AVR32_OPC_MVRC_W,
+  AVR32_OPC_NEG,
+  AVR32_OPC_NOP,
+  AVR32_OPC_OR1,
+  AVR32_OPC_OR2,
+  AVR32_OPC_OR3,
+  AVR32_OPC_ORH,
+  AVR32_OPC_ORL,
+  AVR32_OPC_PABS_SB,
+  AVR32_OPC_PABS_SH,
+  AVR32_OPC_PACKSH_SB,
+  AVR32_OPC_PACKSH_UB,
+  AVR32_OPC_PACKW_SH,
+  AVR32_OPC_PADD_B,
+  AVR32_OPC_PADD_H,
+  AVR32_OPC_PADDH_SH,
+  AVR32_OPC_PADDH_UB,
+  AVR32_OPC_PADDS_SB,
+  AVR32_OPC_PADDS_SH,
+  AVR32_OPC_PADDS_UB,
+  AVR32_OPC_PADDS_UH,
+  AVR32_OPC_PADDSUB_H,
+  AVR32_OPC_PADDSUBH_SH,
+  AVR32_OPC_PADDSUBS_SH,
+  AVR32_OPC_PADDSUBS_UH,
+  AVR32_OPC_PADDX_H,
+  AVR32_OPC_PADDXH_SH,
+  AVR32_OPC_PADDXS_SH,
+  AVR32_OPC_PADDXS_UH,
+  AVR32_OPC_PASR_B,
+  AVR32_OPC_PASR_H,
+  AVR32_OPC_PAVG_SH,
+  AVR32_OPC_PAVG_UB,
+  AVR32_OPC_PLSL_B,
+  AVR32_OPC_PLSL_H,
+  AVR32_OPC_PLSR_B,
+  AVR32_OPC_PLSR_H,
+  AVR32_OPC_PMAX_SH,
+  AVR32_OPC_PMAX_UB,
+  AVR32_OPC_PMIN_SH,
+  AVR32_OPC_PMIN_UB,
+  AVR32_OPC_POPJC,
+  AVR32_OPC_POPM,
+  AVR32_OPC_POPM_E,
+  AVR32_OPC_PREF,
+  AVR32_OPC_PSAD,
+  AVR32_OPC_PSUB_B,
+  AVR32_OPC_PSUB_H,
+  AVR32_OPC_PSUBADD_H,
+  AVR32_OPC_PSUBADDH_SH,
+  AVR32_OPC_PSUBADDS_SH,
+  AVR32_OPC_PSUBADDS_UH,
+  AVR32_OPC_PSUBH_SH,
+  AVR32_OPC_PSUBH_UB,
+  AVR32_OPC_PSUBS_SB,
+  AVR32_OPC_PSUBS_SH,
+  AVR32_OPC_PSUBS_UB,
+  AVR32_OPC_PSUBS_UH,
+  AVR32_OPC_PSUBX_H,
+  AVR32_OPC_PSUBXH_SH,
+  AVR32_OPC_PSUBXS_SH,
+  AVR32_OPC_PSUBXS_UH,
+  AVR32_OPC_PUNPCKSB_H,
+  AVR32_OPC_PUNPCKUB_H,
+  AVR32_OPC_PUSHJC,
+  AVR32_OPC_PUSHM,
+  AVR32_OPC_PUSHM_E,
+  AVR32_OPC_RCALL1,
+  AVR32_OPC_RCALL2,
+  AVR32_OPC_RETEQ,
+  AVR32_OPC_RETNE,
+  AVR32_OPC_RETCC,
+  AVR32_OPC_RETCS,
+  AVR32_OPC_RETGE,
+  AVR32_OPC_RETLT,
+  AVR32_OPC_RETMI,
+  AVR32_OPC_RETPL,
+  AVR32_OPC_RETLS,
+  AVR32_OPC_RETGT,
+  AVR32_OPC_RETLE,
+  AVR32_OPC_RETHI,
+  AVR32_OPC_RETVS,
+  AVR32_OPC_RETVC,
+  AVR32_OPC_RETQS,
+  AVR32_OPC_RETAL,
+  AVR32_OPC_RETD,
+  AVR32_OPC_RETE,
+  AVR32_OPC_RETJ,
+  AVR32_OPC_RETS,
+  AVR32_OPC_RJMP,
+  AVR32_OPC_ROL,
+  AVR32_OPC_ROR,
+  AVR32_OPC_RSUB1,
+  AVR32_OPC_RSUB2,
+  AVR32_OPC_SATADD_H,
+  AVR32_OPC_SATADD_W,
+  AVR32_OPC_SATRNDS,
+  AVR32_OPC_SATRNDU,
+  AVR32_OPC_SATS,
+  AVR32_OPC_SATSUB_H,
+  AVR32_OPC_SATSUB_W1,
+  AVR32_OPC_SATSUB_W2,
+  AVR32_OPC_SATU,
+  AVR32_OPC_SBC,
+  AVR32_OPC_SBR,
+  AVR32_OPC_SCALL,
+  AVR32_OPC_SCR,
+  AVR32_OPC_SLEEP,
+  AVR32_OPC_SREQ,
+  AVR32_OPC_SRNE,
+  AVR32_OPC_SRCC,
+  AVR32_OPC_SRCS,
+  AVR32_OPC_SRGE,
+  AVR32_OPC_SRLT,
+  AVR32_OPC_SRMI,
+  AVR32_OPC_SRPL,
+  AVR32_OPC_SRLS,
+  AVR32_OPC_SRGT,
+  AVR32_OPC_SRLE,
+  AVR32_OPC_SRHI,
+  AVR32_OPC_SRVS,
+  AVR32_OPC_SRVC,
+  AVR32_OPC_SRQS,
+  AVR32_OPC_SRAL,
+  AVR32_OPC_SSRF,
+  AVR32_OPC_ST_B1,
+  AVR32_OPC_ST_B2,
+  AVR32_OPC_ST_B5,
+  AVR32_OPC_ST_B3,
+  AVR32_OPC_ST_B4,
+  AVR32_OPC_ST_D1,
+  AVR32_OPC_ST_D2,
+  AVR32_OPC_ST_D3,
+  AVR32_OPC_ST_D5,
+  AVR32_OPC_ST_D4,
+  AVR32_OPC_ST_H1,
+  AVR32_OPC_ST_H2,
+  AVR32_OPC_ST_H5,
+  AVR32_OPC_ST_H3,
+  AVR32_OPC_ST_H4,
+  AVR32_OPC_ST_W1,
+  AVR32_OPC_ST_W2,
+  AVR32_OPC_ST_W5,
+  AVR32_OPC_ST_W3,
+  AVR32_OPC_ST_W4,
+  AVR32_OPC_STC_D1,
+  AVR32_OPC_STC_D2,
+  AVR32_OPC_STC_D3,
+  AVR32_OPC_STC_W1,
+  AVR32_OPC_STC_W2,
+  AVR32_OPC_STC_W3,
+  AVR32_OPC_STC0_D,
+  AVR32_OPC_STC0_W,
+  AVR32_OPC_STCM_D,
+  AVR32_OPC_STCM_D_PU,
+  AVR32_OPC_STCM_W,
+  AVR32_OPC_STCM_W_PU,
+  AVR32_OPC_STCOND,
+  AVR32_OPC_STDSP,
+  AVR32_OPC_STHH_W2,
+  AVR32_OPC_STHH_W1,
+  AVR32_OPC_STM,
+  AVR32_OPC_STM_PU,
+  AVR32_OPC_STMTS,
+  AVR32_OPC_STMTS_PU,
+  AVR32_OPC_STSWP_H,
+  AVR32_OPC_STSWP_W,
+  AVR32_OPC_SUB1,
+  AVR32_OPC_SUB2,
+  AVR32_OPC_SUB5,
+  AVR32_OPC_SUB3_SP,
+  AVR32_OPC_SUB3,
+  AVR32_OPC_SUB4,
+  AVR32_OPC_SUBEQ,
+  AVR32_OPC_SUBNE,
+  AVR32_OPC_SUBCC,
+  AVR32_OPC_SUBCS,
+  AVR32_OPC_SUBGE,
+  AVR32_OPC_SUBLT,
+  AVR32_OPC_SUBMI,
+  AVR32_OPC_SUBPL,
+  AVR32_OPC_SUBLS,
+  AVR32_OPC_SUBGT,
+  AVR32_OPC_SUBLE,
+  AVR32_OPC_SUBHI,
+  AVR32_OPC_SUBVS,
+  AVR32_OPC_SUBVC,
+  AVR32_OPC_SUBQS,
+  AVR32_OPC_SUBAL,
+  AVR32_OPC_SUBFEQ,
+  AVR32_OPC_SUBFNE,
+  AVR32_OPC_SUBFCC,
+  AVR32_OPC_SUBFCS,
+  AVR32_OPC_SUBFGE,
+  AVR32_OPC_SUBFLT,
+  AVR32_OPC_SUBFMI,
+  AVR32_OPC_SUBFPL,
+  AVR32_OPC_SUBFLS,
+  AVR32_OPC_SUBFGT,
+  AVR32_OPC_SUBFLE,
+  AVR32_OPC_SUBFHI,
+  AVR32_OPC_SUBFVS,
+  AVR32_OPC_SUBFVC,
+  AVR32_OPC_SUBFQS,
+  AVR32_OPC_SUBFAL,
+  AVR32_OPC_SUBHH_W,
+  AVR32_OPC_SWAP_B,
+  AVR32_OPC_SWAP_BH,
+  AVR32_OPC_SWAP_H,
+  AVR32_OPC_SYNC,
+  AVR32_OPC_TLBR,
+  AVR32_OPC_TLBS,
+  AVR32_OPC_TLBW,
+  AVR32_OPC_TNBZ,
+  AVR32_OPC_TST,
+  AVR32_OPC_XCHG,
+  AVR32_OPC_MEMC,
+  AVR32_OPC_MEMS,
+  AVR32_OPC_MEMT,
+  AVR32_OPC_BFEXTS,
+  AVR32_OPC_BFEXTU,
+  AVR32_OPC_BFINS,
+  AVR32_OPC_RSUBEQ,
+  AVR32_OPC_RSUBNE,
+  AVR32_OPC_RSUBCC,
+  AVR32_OPC_RSUBCS,
+  AVR32_OPC_RSUBGE,
+  AVR32_OPC_RSUBLT,
+  AVR32_OPC_RSUBMI,
+  AVR32_OPC_RSUBPL,
+  AVR32_OPC_RSUBLS,
+  AVR32_OPC_RSUBGT,
+  AVR32_OPC_RSUBLE,
+  AVR32_OPC_RSUBHI,
+  AVR32_OPC_RSUBVS,
+  AVR32_OPC_RSUBVC,
+  AVR32_OPC_RSUBQS,
+  AVR32_OPC_RSUBAL,
+  AVR32_OPC_ADDEQ,
+  AVR32_OPC_ADDNE,
+  AVR32_OPC_ADDCC,
+  AVR32_OPC_ADDCS,
+  AVR32_OPC_ADDGE,
+  AVR32_OPC_ADDLT,
+  AVR32_OPC_ADDMI,
+  AVR32_OPC_ADDPL,
+  AVR32_OPC_ADDLS,
+  AVR32_OPC_ADDGT,
+  AVR32_OPC_ADDLE,
+  AVR32_OPC_ADDHI,
+  AVR32_OPC_ADDVS,
+  AVR32_OPC_ADDVC,
+  AVR32_OPC_ADDQS,
+  AVR32_OPC_ADDAL,
+  AVR32_OPC_SUB2EQ,
+  AVR32_OPC_SUB2NE,
+  AVR32_OPC_SUB2CC,
+  AVR32_OPC_SUB2CS,
+  AVR32_OPC_SUB2GE,
+  AVR32_OPC_SUB2LT,
+  AVR32_OPC_SUB2MI,
+  AVR32_OPC_SUB2PL,
+  AVR32_OPC_SUB2LS,
+  AVR32_OPC_SUB2GT,
+  AVR32_OPC_SUB2LE,
+  AVR32_OPC_SUB2HI,
+  AVR32_OPC_SUB2VS,
+  AVR32_OPC_SUB2VC,
+  AVR32_OPC_SUB2QS,
+  AVR32_OPC_SUB2AL,
+  AVR32_OPC_ANDEQ,
+  AVR32_OPC_ANDNE,
+  AVR32_OPC_ANDCC,
+  AVR32_OPC_ANDCS,
+  AVR32_OPC_ANDGE,
+  AVR32_OPC_ANDLT,
+  AVR32_OPC_ANDMI,
+  AVR32_OPC_ANDPL,
+  AVR32_OPC_ANDLS,
+  AVR32_OPC_ANDGT,
+  AVR32_OPC_ANDLE,
+  AVR32_OPC_ANDHI,
+  AVR32_OPC_ANDVS,
+  AVR32_OPC_ANDVC,
+  AVR32_OPC_ANDQS,
+  AVR32_OPC_ANDAL,
+  AVR32_OPC_OREQ,
+  AVR32_OPC_ORNE,
+  AVR32_OPC_ORCC,
+  AVR32_OPC_ORCS,
+  AVR32_OPC_ORGE,
+  AVR32_OPC_ORLT,
+  AVR32_OPC_ORMI,
+  AVR32_OPC_ORPL,
+  AVR32_OPC_ORLS,
+  AVR32_OPC_ORGT,
+  AVR32_OPC_ORLE,
+  AVR32_OPC_ORHI,
+  AVR32_OPC_ORVS,
+  AVR32_OPC_ORVC,
+  AVR32_OPC_ORQS,
+  AVR32_OPC_ORAL,
+  AVR32_OPC_EOREQ,
+  AVR32_OPC_EORNE,
+  AVR32_OPC_EORCC,
+  AVR32_OPC_EORCS,
+  AVR32_OPC_EORGE,
+  AVR32_OPC_EORLT,
+  AVR32_OPC_EORMI,
+  AVR32_OPC_EORPL,
+  AVR32_OPC_EORLS,
+  AVR32_OPC_EORGT,
+  AVR32_OPC_EORLE,
+  AVR32_OPC_EORHI,
+  AVR32_OPC_EORVS,
+  AVR32_OPC_EORVC,
+  AVR32_OPC_EORQS,
+  AVR32_OPC_EORAL,
+  AVR32_OPC_LD_WEQ,
+  AVR32_OPC_LD_WNE,
+  AVR32_OPC_LD_WCC,
+  AVR32_OPC_LD_WCS,
+  AVR32_OPC_LD_WGE,
+  AVR32_OPC_LD_WLT,
+  AVR32_OPC_LD_WMI,
+  AVR32_OPC_LD_WPL,
+  AVR32_OPC_LD_WLS,
+  AVR32_OPC_LD_WGT,
+  AVR32_OPC_LD_WLE,
+  AVR32_OPC_LD_WHI,
+  AVR32_OPC_LD_WVS,
+  AVR32_OPC_LD_WVC,
+  AVR32_OPC_LD_WQS,
+  AVR32_OPC_LD_WAL,
+  AVR32_OPC_LD_SHEQ,
+  AVR32_OPC_LD_SHNE,
+  AVR32_OPC_LD_SHCC,
+  AVR32_OPC_LD_SHCS,
+  AVR32_OPC_LD_SHGE,
+  AVR32_OPC_LD_SHLT,
+  AVR32_OPC_LD_SHMI,
+  AVR32_OPC_LD_SHPL,
+  AVR32_OPC_LD_SHLS,
+  AVR32_OPC_LD_SHGT,
+  AVR32_OPC_LD_SHLE,
+  AVR32_OPC_LD_SHHI,
+  AVR32_OPC_LD_SHVS,
+  AVR32_OPC_LD_SHVC,
+  AVR32_OPC_LD_SHQS,
+  AVR32_OPC_LD_SHAL,
+  AVR32_OPC_LD_UHEQ,
+  AVR32_OPC_LD_UHNE,
+  AVR32_OPC_LD_UHCC,
+  AVR32_OPC_LD_UHCS,
+  AVR32_OPC_LD_UHGE,
+  AVR32_OPC_LD_UHLT,
+  AVR32_OPC_LD_UHMI,
+  AVR32_OPC_LD_UHPL,
+  AVR32_OPC_LD_UHLS,
+  AVR32_OPC_LD_UHGT,
+  AVR32_OPC_LD_UHLE,
+  AVR32_OPC_LD_UHHI,
+  AVR32_OPC_LD_UHVS,
+  AVR32_OPC_LD_UHVC,
+  AVR32_OPC_LD_UHQS,
+  AVR32_OPC_LD_UHAL,
+  AVR32_OPC_LD_SBEQ,
+  AVR32_OPC_LD_SBNE,
+  AVR32_OPC_LD_SBCC,
+  AVR32_OPC_LD_SBCS,
+  AVR32_OPC_LD_SBGE,
+  AVR32_OPC_LD_SBLT,
+  AVR32_OPC_LD_SBMI,
+  AVR32_OPC_LD_SBPL,
+  AVR32_OPC_LD_SBLS,
+  AVR32_OPC_LD_SBGT,
+  AVR32_OPC_LD_SBLE,
+  AVR32_OPC_LD_SBHI,
+  AVR32_OPC_LD_SBVS,
+  AVR32_OPC_LD_SBVC,
+  AVR32_OPC_LD_SBQS,
+  AVR32_OPC_LD_SBAL,
+  AVR32_OPC_LD_UBEQ,
+  AVR32_OPC_LD_UBNE,
+  AVR32_OPC_LD_UBCC,
+  AVR32_OPC_LD_UBCS,
+  AVR32_OPC_LD_UBGE,
+  AVR32_OPC_LD_UBLT,
+  AVR32_OPC_LD_UBMI,
+  AVR32_OPC_LD_UBPL,
+  AVR32_OPC_LD_UBLS,
+  AVR32_OPC_LD_UBGT,
+  AVR32_OPC_LD_UBLE,
+  AVR32_OPC_LD_UBHI,
+  AVR32_OPC_LD_UBVS,
+  AVR32_OPC_LD_UBVC,
+  AVR32_OPC_LD_UBQS,
+  AVR32_OPC_LD_UBAL,
+  AVR32_OPC_ST_WEQ,
+  AVR32_OPC_ST_WNE,
+  AVR32_OPC_ST_WCC,
+  AVR32_OPC_ST_WCS,
+  AVR32_OPC_ST_WGE,
+  AVR32_OPC_ST_WLT,
+  AVR32_OPC_ST_WMI,
+  AVR32_OPC_ST_WPL,
+  AVR32_OPC_ST_WLS,
+  AVR32_OPC_ST_WGT,
+  AVR32_OPC_ST_WLE,
+  AVR32_OPC_ST_WHI,
+  AVR32_OPC_ST_WVS,
+  AVR32_OPC_ST_WVC,
+  AVR32_OPC_ST_WQS,
+  AVR32_OPC_ST_WAL,
+  AVR32_OPC_ST_HEQ,
+  AVR32_OPC_ST_HNE,
+  AVR32_OPC_ST_HCC,
+  AVR32_OPC_ST_HCS,
+  AVR32_OPC_ST_HGE,
+  AVR32_OPC_ST_HLT,
+  AVR32_OPC_ST_HMI,
+  AVR32_OPC_ST_HPL,
+  AVR32_OPC_ST_HLS,
+  AVR32_OPC_ST_HGT,
+  AVR32_OPC_ST_HLE,
+  AVR32_OPC_ST_HHI,
+  AVR32_OPC_ST_HVS,
+  AVR32_OPC_ST_HVC,
+  AVR32_OPC_ST_HQS,
+  AVR32_OPC_ST_HAL,
+  AVR32_OPC_ST_BEQ,
+  AVR32_OPC_ST_BNE,
+  AVR32_OPC_ST_BCC,
+  AVR32_OPC_ST_BCS,
+  AVR32_OPC_ST_BGE,
+  AVR32_OPC_ST_BLT,
+  AVR32_OPC_ST_BMI,
+  AVR32_OPC_ST_BPL,
+  AVR32_OPC_ST_BLS,
+  AVR32_OPC_ST_BGT,
+  AVR32_OPC_ST_BLE,
+  AVR32_OPC_ST_BHI,
+  AVR32_OPC_ST_BVS,
+  AVR32_OPC_ST_BVC,
+  AVR32_OPC_ST_BQS,
+  AVR32_OPC_ST_BAL,
+  AVR32_OPC_MOVH,
+  AVR32_OPC__END_
+};
+#define AVR32_NR_OPCODES AVR32_OPC__END_
+
+enum avr32_syntax_type
+{
+  AVR32_SYNTAX_ABS,
+  AVR32_SYNTAX_ACALL,
+  AVR32_SYNTAX_ACR,
+  AVR32_SYNTAX_ADC,
+  AVR32_SYNTAX_ADD1,
+  AVR32_SYNTAX_ADD2,
+  AVR32_SYNTAX_ADDABS,
+  AVR32_SYNTAX_ADDHH_W,
+  AVR32_SYNTAX_AND1,
+  AVR32_SYNTAX_AND2,
+  AVR32_SYNTAX_AND3,
+  AVR32_SYNTAX_ANDH,
+  AVR32_SYNTAX_ANDH_COH,
+  AVR32_SYNTAX_ANDL,
+  AVR32_SYNTAX_ANDL_COH,
+  AVR32_SYNTAX_ANDN,
+  AVR32_SYNTAX_ASR1,
+  AVR32_SYNTAX_ASR3,
+  AVR32_SYNTAX_ASR2,
+  AVR32_SYNTAX_BFEXTS,
+  AVR32_SYNTAX_BFEXTU,
+  AVR32_SYNTAX_BFINS,
+  AVR32_SYNTAX_BLD,
+  AVR32_SYNTAX_BREQ1,
+  AVR32_SYNTAX_BRNE1,
+  AVR32_SYNTAX_BRCC1,
+  AVR32_SYNTAX_BRCS1,
+  AVR32_SYNTAX_BRGE1,
+  AVR32_SYNTAX_BRLT1,
+  AVR32_SYNTAX_BRMI1,
+  AVR32_SYNTAX_BRPL1,
+  AVR32_SYNTAX_BRHS1,
+  AVR32_SYNTAX_BRLO1,
+  AVR32_SYNTAX_BREQ2,
+  AVR32_SYNTAX_BRNE2,
+  AVR32_SYNTAX_BRCC2,
+  AVR32_SYNTAX_BRCS2,
+  AVR32_SYNTAX_BRGE2,
+  AVR32_SYNTAX_BRLT2,
+  AVR32_SYNTAX_BRMI2,
+  AVR32_SYNTAX_BRPL2,
+  AVR32_SYNTAX_BRLS,
+  AVR32_SYNTAX_BRGT,
+  AVR32_SYNTAX_BRLE,
+  AVR32_SYNTAX_BRHI,
+  AVR32_SYNTAX_BRVS,
+  AVR32_SYNTAX_BRVC,
+  AVR32_SYNTAX_BRQS,
+  AVR32_SYNTAX_BRAL,
+  AVR32_SYNTAX_BRHS2,
+  AVR32_SYNTAX_BRLO2,
+  AVR32_SYNTAX_BREAKPOINT,
+  AVR32_SYNTAX_BREV,
+  AVR32_SYNTAX_BST,
+  AVR32_SYNTAX_CACHE,
+  AVR32_SYNTAX_CASTS_B,
+  AVR32_SYNTAX_CASTS_H,
+  AVR32_SYNTAX_CASTU_B,
+  AVR32_SYNTAX_CASTU_H,
+  AVR32_SYNTAX_CBR,
+  AVR32_SYNTAX_CLZ,
+  AVR32_SYNTAX_COM,
+  AVR32_SYNTAX_COP,
+  AVR32_SYNTAX_CP_B,
+  AVR32_SYNTAX_CP_H,
+  AVR32_SYNTAX_CP_W1,
+  AVR32_SYNTAX_CP_W2,
+  AVR32_SYNTAX_CP_W3,
+  AVR32_SYNTAX_CPC1,
+  AVR32_SYNTAX_CPC2,
+  AVR32_SYNTAX_CSRF,
+  AVR32_SYNTAX_CSRFCZ,
+  AVR32_SYNTAX_DIVS,
+  AVR32_SYNTAX_DIVU,
+  AVR32_SYNTAX_EOR1,
+  AVR32_SYNTAX_EOR2,
+  AVR32_SYNTAX_EOR3,
+  AVR32_SYNTAX_EORL,
+  AVR32_SYNTAX_EORH,
+  AVR32_SYNTAX_FRS,
+  AVR32_SYNTAX_ICALL,
+  AVR32_SYNTAX_INCJOSP,
+  AVR32_SYNTAX_LD_D1,
+  AVR32_SYNTAX_LD_D2,
+  AVR32_SYNTAX_LD_D3,
+  AVR32_SYNTAX_LD_D5,
+  AVR32_SYNTAX_LD_D4,
+  AVR32_SYNTAX_LD_SB2,
+  AVR32_SYNTAX_LD_SB1,
+  AVR32_SYNTAX_LD_UB1,
+  AVR32_SYNTAX_LD_UB2,
+  AVR32_SYNTAX_LD_UB5,
+  AVR32_SYNTAX_LD_UB3,
+  AVR32_SYNTAX_LD_UB4,
+  AVR32_SYNTAX_LD_SH1,
+  AVR32_SYNTAX_LD_SH2,
+  AVR32_SYNTAX_LD_SH5,
+  AVR32_SYNTAX_LD_SH3,
+  AVR32_SYNTAX_LD_SH4,
+  AVR32_SYNTAX_LD_UH1,
+  AVR32_SYNTAX_LD_UH2,
+  AVR32_SYNTAX_LD_UH5,
+  AVR32_SYNTAX_LD_UH3,
+  AVR32_SYNTAX_LD_UH4,
+  AVR32_SYNTAX_LD_W1,
+  AVR32_SYNTAX_LD_W2,
+  AVR32_SYNTAX_LD_W5,
+  AVR32_SYNTAX_LD_W6,
+  AVR32_SYNTAX_LD_W3,
+  AVR32_SYNTAX_LD_W4,
+  AVR32_SYNTAX_LDC_D1,
+  AVR32_SYNTAX_LDC_D2,
+  AVR32_SYNTAX_LDC_D3,
+  AVR32_SYNTAX_LDC_W1,
+  AVR32_SYNTAX_LDC_W2,
+  AVR32_SYNTAX_LDC_W3,
+  AVR32_SYNTAX_LDC0_D,
+  AVR32_SYNTAX_LDC0_W,
+  AVR32_SYNTAX_LDCM_D,
+  AVR32_SYNTAX_LDCM_D_PU,
+  AVR32_SYNTAX_LDCM_W,
+  AVR32_SYNTAX_LDCM_W_PU,
+  AVR32_SYNTAX_LDDPC,
+  AVR32_SYNTAX_LDDPC_EXT,
+  AVR32_SYNTAX_LDDSP,
+  AVR32_SYNTAX_LDINS_B,
+  AVR32_SYNTAX_LDINS_H,
+  AVR32_SYNTAX_LDM,
+  AVR32_SYNTAX_LDMTS,
+  AVR32_SYNTAX_LDMTS_PU,
+  AVR32_SYNTAX_LDSWP_SH,
+  AVR32_SYNTAX_LDSWP_UH,
+  AVR32_SYNTAX_LDSWP_W,
+  AVR32_SYNTAX_LSL1,
+  AVR32_SYNTAX_LSL3,
+  AVR32_SYNTAX_LSL2,
+  AVR32_SYNTAX_LSR1,
+  AVR32_SYNTAX_LSR3,
+  AVR32_SYNTAX_LSR2,
+  AVR32_SYNTAX_MAC,
+  AVR32_SYNTAX_MACHH_D,
+  AVR32_SYNTAX_MACHH_W,
+  AVR32_SYNTAX_MACS_D,
+  AVR32_SYNTAX_MACSATHH_W,
+  AVR32_SYNTAX_MACUD,
+  AVR32_SYNTAX_MACWH_D,
+  AVR32_SYNTAX_MAX,
+  AVR32_SYNTAX_MCALL,
+  AVR32_SYNTAX_MFDR,
+  AVR32_SYNTAX_MFSR,
+  AVR32_SYNTAX_MIN,
+  AVR32_SYNTAX_MOV3,
+  AVR32_SYNTAX_MOV1,
+  AVR32_SYNTAX_MOV2,
+  AVR32_SYNTAX_MOVEQ1,
+  AVR32_SYNTAX_MOVNE1,
+  AVR32_SYNTAX_MOVCC1,
+  AVR32_SYNTAX_MOVCS1,
+  AVR32_SYNTAX_MOVGE1,
+  AVR32_SYNTAX_MOVLT1,
+  AVR32_SYNTAX_MOVMI1,
+  AVR32_SYNTAX_MOVPL1,
+  AVR32_SYNTAX_MOVLS1,
+  AVR32_SYNTAX_MOVGT1,
+  AVR32_SYNTAX_MOVLE1,
+  AVR32_SYNTAX_MOVHI1,
+  AVR32_SYNTAX_MOVVS1,
+  AVR32_SYNTAX_MOVVC1,
+  AVR32_SYNTAX_MOVQS1,
+  AVR32_SYNTAX_MOVAL1,
+  AVR32_SYNTAX_MOVHS1,
+  AVR32_SYNTAX_MOVLO1,
+  AVR32_SYNTAX_MOVEQ2,
+  AVR32_SYNTAX_MOVNE2,
+  AVR32_SYNTAX_MOVCC2,
+  AVR32_SYNTAX_MOVCS2,
+  AVR32_SYNTAX_MOVGE2,
+  AVR32_SYNTAX_MOVLT2,
+  AVR32_SYNTAX_MOVMI2,
+  AVR32_SYNTAX_MOVPL2,
+  AVR32_SYNTAX_MOVLS2,
+  AVR32_SYNTAX_MOVGT2,
+  AVR32_SYNTAX_MOVLE2,
+  AVR32_SYNTAX_MOVHI2,
+  AVR32_SYNTAX_MOVVS2,
+  AVR32_SYNTAX_MOVVC2,
+  AVR32_SYNTAX_MOVQS2,
+  AVR32_SYNTAX_MOVAL2,
+  AVR32_SYNTAX_MOVHS2,
+  AVR32_SYNTAX_MOVLO2,
+  AVR32_SYNTAX_MTDR,
+  AVR32_SYNTAX_MTSR,
+  AVR32_SYNTAX_MUL1,
+  AVR32_SYNTAX_MUL2,
+  AVR32_SYNTAX_MUL3,
+  AVR32_SYNTAX_MULHH_W,
+  AVR32_SYNTAX_MULNHH_W,
+  AVR32_SYNTAX_MULNWH_D,
+  AVR32_SYNTAX_MULSD,
+  AVR32_SYNTAX_MULSATHH_H,
+  AVR32_SYNTAX_MULSATHH_W,
+  AVR32_SYNTAX_MULSATRNDHH_H,
+  AVR32_SYNTAX_MULSATRNDWH_W,
+  AVR32_SYNTAX_MULSATWH_W,
+  AVR32_SYNTAX_MULU_D,
+  AVR32_SYNTAX_MULWH_D,
+  AVR32_SYNTAX_MUSFR,
+  AVR32_SYNTAX_MUSTR,
+  AVR32_SYNTAX_MVCR_D,
+  AVR32_SYNTAX_MVCR_W,
+  AVR32_SYNTAX_MVRC_D,
+  AVR32_SYNTAX_MVRC_W,
+  AVR32_SYNTAX_NEG,
+  AVR32_SYNTAX_NOP,
+  AVR32_SYNTAX_OR1,
+  AVR32_SYNTAX_OR2,
+  AVR32_SYNTAX_OR3,
+  AVR32_SYNTAX_ORH,
+  AVR32_SYNTAX_ORL,
+  AVR32_SYNTAX_PABS_SB,
+  AVR32_SYNTAX_PABS_SH,
+  AVR32_SYNTAX_PACKSH_SB,
+  AVR32_SYNTAX_PACKSH_UB,
+  AVR32_SYNTAX_PACKW_SH,
+  AVR32_SYNTAX_PADD_B,
+  AVR32_SYNTAX_PADD_H,
+  AVR32_SYNTAX_PADDH_SH,
+  AVR32_SYNTAX_PADDH_UB,
+  AVR32_SYNTAX_PADDS_SB,
+  AVR32_SYNTAX_PADDS_SH,
+  AVR32_SYNTAX_PADDS_UB,
+  AVR32_SYNTAX_PADDS_UH,
+  AVR32_SYNTAX_PADDSUB_H,
+  AVR32_SYNTAX_PADDSUBH_SH,
+  AVR32_SYNTAX_PADDSUBS_SH,
+  AVR32_SYNTAX_PADDSUBS_UH,
+  AVR32_SYNTAX_PADDX_H,
+  AVR32_SYNTAX_PADDXH_SH,
+  AVR32_SYNTAX_PADDXS_SH,
+  AVR32_SYNTAX_PADDXS_UH,
+  AVR32_SYNTAX_PASR_B,
+  AVR32_SYNTAX_PASR_H,
+  AVR32_SYNTAX_PAVG_SH,
+  AVR32_SYNTAX_PAVG_UB,
+  AVR32_SYNTAX_PLSL_B,
+  AVR32_SYNTAX_PLSL_H,
+  AVR32_SYNTAX_PLSR_B,
+  AVR32_SYNTAX_PLSR_H,
+  AVR32_SYNTAX_PMAX_SH,
+  AVR32_SYNTAX_PMAX_UB,
+  AVR32_SYNTAX_PMIN_SH,
+  AVR32_SYNTAX_PMIN_UB,
+  AVR32_SYNTAX_POPJC,
+  AVR32_SYNTAX_POPM,
+  AVR32_SYNTAX_POPM_E,
+  AVR32_SYNTAX_PREF,
+  AVR32_SYNTAX_PSAD,
+  AVR32_SYNTAX_PSUB_B,
+  AVR32_SYNTAX_PSUB_H,
+  AVR32_SYNTAX_PSUBADD_H,
+  AVR32_SYNTAX_PSUBADDH_SH,
+  AVR32_SYNTAX_PSUBADDS_SH,
+  AVR32_SYNTAX_PSUBADDS_UH,
+  AVR32_SYNTAX_PSUBH_SH,
+  AVR32_SYNTAX_PSUBH_UB,
+  AVR32_SYNTAX_PSUBS_SB,
+  AVR32_SYNTAX_PSUBS_SH,
+  AVR32_SYNTAX_PSUBS_UB,
+  AVR32_SYNTAX_PSUBS_UH,
+  AVR32_SYNTAX_PSUBX_H,
+  AVR32_SYNTAX_PSUBXH_SH,
+  AVR32_SYNTAX_PSUBXS_SH,
+  AVR32_SYNTAX_PSUBXS_UH,
+  AVR32_SYNTAX_PUNPCKSB_H,
+  AVR32_SYNTAX_PUNPCKUB_H,
+  AVR32_SYNTAX_PUSHJC,
+  AVR32_SYNTAX_PUSHM,
+  AVR32_SYNTAX_PUSHM_E,
+  AVR32_SYNTAX_RCALL1,
+  AVR32_SYNTAX_RCALL2,
+  AVR32_SYNTAX_RETEQ,
+  AVR32_SYNTAX_RETNE,
+  AVR32_SYNTAX_RETCC,
+  AVR32_SYNTAX_RETCS,
+  AVR32_SYNTAX_RETGE,
+  AVR32_SYNTAX_RETLT,
+  AVR32_SYNTAX_RETMI,
+  AVR32_SYNTAX_RETPL,
+  AVR32_SYNTAX_RETLS,
+  AVR32_SYNTAX_RETGT,
+  AVR32_SYNTAX_RETLE,
+  AVR32_SYNTAX_RETHI,
+  AVR32_SYNTAX_RETVS,
+  AVR32_SYNTAX_RETVC,
+  AVR32_SYNTAX_RETQS,
+  AVR32_SYNTAX_RETAL,
+  AVR32_SYNTAX_RETHS,
+  AVR32_SYNTAX_RETLO,
+  AVR32_SYNTAX_RETD,
+  AVR32_SYNTAX_RETE,
+  AVR32_SYNTAX_RETJ,
+  AVR32_SYNTAX_RETS,
+  AVR32_SYNTAX_RJMP,
+  AVR32_SYNTAX_ROL,
+  AVR32_SYNTAX_ROR,
+  AVR32_SYNTAX_RSUB1,
+  AVR32_SYNTAX_RSUB2,
+  AVR32_SYNTAX_SATADD_H,
+  AVR32_SYNTAX_SATADD_W,
+  AVR32_SYNTAX_SATRNDS,
+  AVR32_SYNTAX_SATRNDU,
+  AVR32_SYNTAX_SATS,
+  AVR32_SYNTAX_SATSUB_H,
+  AVR32_SYNTAX_SATSUB_W1,
+  AVR32_SYNTAX_SATSUB_W2,
+  AVR32_SYNTAX_SATU,
+  AVR32_SYNTAX_SBC,
+  AVR32_SYNTAX_SBR,
+  AVR32_SYNTAX_SCALL,
+  AVR32_SYNTAX_SCR,
+  AVR32_SYNTAX_SLEEP,
+  AVR32_SYNTAX_SREQ,
+  AVR32_SYNTAX_SRNE,
+  AVR32_SYNTAX_SRCC,
+  AVR32_SYNTAX_SRCS,
+  AVR32_SYNTAX_SRGE,
+  AVR32_SYNTAX_SRLT,
+  AVR32_SYNTAX_SRMI,
+  AVR32_SYNTAX_SRPL,
+  AVR32_SYNTAX_SRLS,
+  AVR32_SYNTAX_SRGT,
+  AVR32_SYNTAX_SRLE,
+  AVR32_SYNTAX_SRHI,
+  AVR32_SYNTAX_SRVS,
+  AVR32_SYNTAX_SRVC,
+  AVR32_SYNTAX_SRQS,
+  AVR32_SYNTAX_SRAL,
+  AVR32_SYNTAX_SRHS,
+  AVR32_SYNTAX_SRLO,
+  AVR32_SYNTAX_SSRF,
+  AVR32_SYNTAX_ST_B1,
+  AVR32_SYNTAX_ST_B2,
+  AVR32_SYNTAX_ST_B5,
+  AVR32_SYNTAX_ST_B3,
+  AVR32_SYNTAX_ST_B4,
+  AVR32_SYNTAX_ST_D1,
+  AVR32_SYNTAX_ST_D2,
+  AVR32_SYNTAX_ST_D3,
+  AVR32_SYNTAX_ST_D5,
+  AVR32_SYNTAX_ST_D4,
+  AVR32_SYNTAX_ST_H1,
+  AVR32_SYNTAX_ST_H2,
+  AVR32_SYNTAX_ST_H5,
+  AVR32_SYNTAX_ST_H3,
+  AVR32_SYNTAX_ST_H4,
+  AVR32_SYNTAX_ST_W1,
+  AVR32_SYNTAX_ST_W2,
+  AVR32_SYNTAX_ST_W5,
+  AVR32_SYNTAX_ST_W3,
+  AVR32_SYNTAX_ST_W4,
+  AVR32_SYNTAX_STC_D1,
+  AVR32_SYNTAX_STC_D2,
+  AVR32_SYNTAX_STC_D3,
+  AVR32_SYNTAX_STC_W1,
+  AVR32_SYNTAX_STC_W2,
+  AVR32_SYNTAX_STC_W3,
+  AVR32_SYNTAX_STC0_D,
+  AVR32_SYNTAX_STC0_W,
+  AVR32_SYNTAX_STCM_D,
+  AVR32_SYNTAX_STCM_D_PU,
+  AVR32_SYNTAX_STCM_W,
+  AVR32_SYNTAX_STCM_W_PU,
+  AVR32_SYNTAX_STCOND,
+  AVR32_SYNTAX_STDSP,
+  AVR32_SYNTAX_STHH_W2,
+  AVR32_SYNTAX_STHH_W1,
+  AVR32_SYNTAX_STM,
+  AVR32_SYNTAX_STM_PU,
+  AVR32_SYNTAX_STMTS,
+  AVR32_SYNTAX_STMTS_PU,
+  AVR32_SYNTAX_STSWP_H,
+  AVR32_SYNTAX_STSWP_W,
+  AVR32_SYNTAX_SUB1,
+  AVR32_SYNTAX_SUB2,
+  AVR32_SYNTAX_SUB5,
+  AVR32_SYNTAX_SUB3_SP,
+  AVR32_SYNTAX_SUB3,
+  AVR32_SYNTAX_SUB4,
+  AVR32_SYNTAX_SUBEQ,
+  AVR32_SYNTAX_SUBNE,
+  AVR32_SYNTAX_SUBCC,
+  AVR32_SYNTAX_SUBCS,
+  AVR32_SYNTAX_SUBGE,
+  AVR32_SYNTAX_SUBLT,
+  AVR32_SYNTAX_SUBMI,
+  AVR32_SYNTAX_SUBPL,
+  AVR32_SYNTAX_SUBLS,
+  AVR32_SYNTAX_SUBGT,
+  AVR32_SYNTAX_SUBLE,
+  AVR32_SYNTAX_SUBHI,
+  AVR32_SYNTAX_SUBVS,
+  AVR32_SYNTAX_SUBVC,
+  AVR32_SYNTAX_SUBQS,
+  AVR32_SYNTAX_SUBAL,
+  AVR32_SYNTAX_SUBHS,
+  AVR32_SYNTAX_SUBLO,
+  AVR32_SYNTAX_SUBFEQ,
+  AVR32_SYNTAX_SUBFNE,
+  AVR32_SYNTAX_SUBFCC,
+  AVR32_SYNTAX_SUBFCS,
+  AVR32_SYNTAX_SUBFGE,
+  AVR32_SYNTAX_SUBFLT,
+  AVR32_SYNTAX_SUBFMI,
+  AVR32_SYNTAX_SUBFPL,
+  AVR32_SYNTAX_SUBFLS,
+  AVR32_SYNTAX_SUBFGT,
+  AVR32_SYNTAX_SUBFLE,
+  AVR32_SYNTAX_SUBFHI,
+  AVR32_SYNTAX_SUBFVS,
+  AVR32_SYNTAX_SUBFVC,
+  AVR32_SYNTAX_SUBFQS,
+  AVR32_SYNTAX_SUBFAL,
+  AVR32_SYNTAX_SUBFHS,
+  AVR32_SYNTAX_SUBFLO,
+  AVR32_SYNTAX_SUBHH_W,
+  AVR32_SYNTAX_SWAP_B,
+  AVR32_SYNTAX_SWAP_BH,
+  AVR32_SYNTAX_SWAP_H,
+  AVR32_SYNTAX_SYNC,
+  AVR32_SYNTAX_TLBR,
+  AVR32_SYNTAX_TLBS,
+  AVR32_SYNTAX_TLBW,
+  AVR32_SYNTAX_TNBZ,
+  AVR32_SYNTAX_TST,
+  AVR32_SYNTAX_XCHG,
+  AVR32_SYNTAX_MEMC,
+  AVR32_SYNTAX_MEMS,
+  AVR32_SYNTAX_MEMT,
+  AVR32_SYNTAX_FADD_S,
+  AVR32_SYNTAX_FADD_D,
+  AVR32_SYNTAX_FSUB_S,
+  AVR32_SYNTAX_FSUB_D,
+  AVR32_SYNTAX_FMAC_S,
+  AVR32_SYNTAX_FMAC_D,
+  AVR32_SYNTAX_FNMAC_S,
+  AVR32_SYNTAX_FNMAC_D,
+  AVR32_SYNTAX_FMSC_S,
+  AVR32_SYNTAX_FMSC_D,
+  AVR32_SYNTAX_FNMSC_S,
+  AVR32_SYNTAX_FNMSC_D,
+  AVR32_SYNTAX_FMUL_S,
+  AVR32_SYNTAX_FMUL_D,
+  AVR32_SYNTAX_FNMUL_S,
+  AVR32_SYNTAX_FNMUL_D,
+  AVR32_SYNTAX_FNEG_S,
+  AVR32_SYNTAX_FNEG_D,
+  AVR32_SYNTAX_FABS_S,
+  AVR32_SYNTAX_FABS_D,
+  AVR32_SYNTAX_FCMP_S,
+  AVR32_SYNTAX_FCMP_D,
+  AVR32_SYNTAX_FMOV1_S,
+  AVR32_SYNTAX_FMOV1_D,
+  AVR32_SYNTAX_FMOV2_S,
+  AVR32_SYNTAX_FMOV2_D,
+  AVR32_SYNTAX_FMOV3_S,
+  AVR32_SYNTAX_FMOV3_D,
+  AVR32_SYNTAX_FCASTS_D,
+  AVR32_SYNTAX_FCASTD_S,
+  AVR32_SYNTAX_LDA_W,
+  AVR32_SYNTAX_CALL,
+  AVR32_SYNTAX_PICOSVMAC0,
+  AVR32_SYNTAX_PICOSVMAC1,
+  AVR32_SYNTAX_PICOSVMAC2,
+  AVR32_SYNTAX_PICOSVMAC3,
+  AVR32_SYNTAX_PICOSVMUL0,
+  AVR32_SYNTAX_PICOSVMUL1,
+  AVR32_SYNTAX_PICOSVMUL2,
+  AVR32_SYNTAX_PICOSVMUL3,
+  AVR32_SYNTAX_PICOVMAC0,
+  AVR32_SYNTAX_PICOVMAC1,
+  AVR32_SYNTAX_PICOVMAC2,
+  AVR32_SYNTAX_PICOVMAC3,
+  AVR32_SYNTAX_PICOVMUL0,
+  AVR32_SYNTAX_PICOVMUL1,
+  AVR32_SYNTAX_PICOVMUL2,
+  AVR32_SYNTAX_PICOVMUL3,
+  AVR32_SYNTAX_PICOLD_D2,
+  AVR32_SYNTAX_PICOLD_D3,
+  AVR32_SYNTAX_PICOLD_D1,
+  AVR32_SYNTAX_PICOLD_W2,
+  AVR32_SYNTAX_PICOLD_W3,
+  AVR32_SYNTAX_PICOLD_W1,
+  AVR32_SYNTAX_PICOLDM_D,
+  AVR32_SYNTAX_PICOLDM_D_PU,
+  AVR32_SYNTAX_PICOLDM_W,
+  AVR32_SYNTAX_PICOLDM_W_PU,
+  AVR32_SYNTAX_PICOMV_D1,
+  AVR32_SYNTAX_PICOMV_D2,
+  AVR32_SYNTAX_PICOMV_W1,
+  AVR32_SYNTAX_PICOMV_W2,
+  AVR32_SYNTAX_PICOST_D2,
+  AVR32_SYNTAX_PICOST_D3,
+  AVR32_SYNTAX_PICOST_D1,
+  AVR32_SYNTAX_PICOST_W2,
+  AVR32_SYNTAX_PICOST_W3,
+  AVR32_SYNTAX_PICOST_W1,
+  AVR32_SYNTAX_PICOSTM_D,
+  AVR32_SYNTAX_PICOSTM_D_PU,
+  AVR32_SYNTAX_PICOSTM_W,
+  AVR32_SYNTAX_PICOSTM_W_PU,
+  AVR32_SYNTAX_RSUBEQ,
+  AVR32_SYNTAX_RSUBNE,
+  AVR32_SYNTAX_RSUBCC,
+  AVR32_SYNTAX_RSUBCS,
+  AVR32_SYNTAX_RSUBGE,
+  AVR32_SYNTAX_RSUBLT,
+  AVR32_SYNTAX_RSUBMI,
+  AVR32_SYNTAX_RSUBPL,
+  AVR32_SYNTAX_RSUBLS,
+  AVR32_SYNTAX_RSUBGT,
+  AVR32_SYNTAX_RSUBLE,
+  AVR32_SYNTAX_RSUBHI,
+  AVR32_SYNTAX_RSUBVS,
+  AVR32_SYNTAX_RSUBVC,
+  AVR32_SYNTAX_RSUBQS,
+  AVR32_SYNTAX_RSUBAL,
+  AVR32_SYNTAX_RSUBHS,
+  AVR32_SYNTAX_RSUBLO,
+  AVR32_SYNTAX_ADDEQ,
+  AVR32_SYNTAX_ADDNE,
+  AVR32_SYNTAX_ADDCC,
+  AVR32_SYNTAX_ADDCS,
+  AVR32_SYNTAX_ADDGE,
+  AVR32_SYNTAX_ADDLT,
+  AVR32_SYNTAX_ADDMI,
+  AVR32_SYNTAX_ADDPL,
+  AVR32_SYNTAX_ADDLS,
+  AVR32_SYNTAX_ADDGT,
+  AVR32_SYNTAX_ADDLE,
+  AVR32_SYNTAX_ADDHI,
+  AVR32_SYNTAX_ADDVS,
+  AVR32_SYNTAX_ADDVC,
+  AVR32_SYNTAX_ADDQS,
+  AVR32_SYNTAX_ADDAL,
+  AVR32_SYNTAX_ADDHS,
+  AVR32_SYNTAX_ADDLO,
+  AVR32_SYNTAX_SUB2EQ,
+  AVR32_SYNTAX_SUB2NE,
+  AVR32_SYNTAX_SUB2CC,
+  AVR32_SYNTAX_SUB2CS,
+  AVR32_SYNTAX_SUB2GE,
+  AVR32_SYNTAX_SUB2LT,
+  AVR32_SYNTAX_SUB2MI,
+  AVR32_SYNTAX_SUB2PL,
+  AVR32_SYNTAX_SUB2LS,
+  AVR32_SYNTAX_SUB2GT,
+  AVR32_SYNTAX_SUB2LE,
+  AVR32_SYNTAX_SUB2HI,
+  AVR32_SYNTAX_SUB2VS,
+  AVR32_SYNTAX_SUB2VC,
+  AVR32_SYNTAX_SUB2QS,
+  AVR32_SYNTAX_SUB2AL,
+  AVR32_SYNTAX_SUB2HS,
+  AVR32_SYNTAX_SUB2LO,
+  AVR32_SYNTAX_ANDEQ,
+  AVR32_SYNTAX_ANDNE,
+  AVR32_SYNTAX_ANDCC,
+  AVR32_SYNTAX_ANDCS,
+  AVR32_SYNTAX_ANDGE,
+  AVR32_SYNTAX_ANDLT,
+  AVR32_SYNTAX_ANDMI,
+  AVR32_SYNTAX_ANDPL,
+  AVR32_SYNTAX_ANDLS,
+  AVR32_SYNTAX_ANDGT,
+  AVR32_SYNTAX_ANDLE,
+  AVR32_SYNTAX_ANDHI,
+  AVR32_SYNTAX_ANDVS,
+  AVR32_SYNTAX_ANDVC,
+  AVR32_SYNTAX_ANDQS,
+  AVR32_SYNTAX_ANDAL,
+  AVR32_SYNTAX_ANDHS,
+  AVR32_SYNTAX_ANDLO,
+  AVR32_SYNTAX_OREQ,
+  AVR32_SYNTAX_ORNE,
+  AVR32_SYNTAX_ORCC,
+  AVR32_SYNTAX_ORCS,
+  AVR32_SYNTAX_ORGE,
+  AVR32_SYNTAX_ORLT,
+  AVR32_SYNTAX_ORMI,
+  AVR32_SYNTAX_ORPL,
+  AVR32_SYNTAX_ORLS,
+  AVR32_SYNTAX_ORGT,
+  AVR32_SYNTAX_ORLE,
+  AVR32_SYNTAX_ORHI,
+  AVR32_SYNTAX_ORVS,
+  AVR32_SYNTAX_ORVC,
+  AVR32_SYNTAX_ORQS,
+  AVR32_SYNTAX_ORAL,
+  AVR32_SYNTAX_ORHS,
+  AVR32_SYNTAX_ORLO,
+  AVR32_SYNTAX_EOREQ,
+  AVR32_SYNTAX_EORNE,
+  AVR32_SYNTAX_EORCC,
+  AVR32_SYNTAX_EORCS,
+  AVR32_SYNTAX_EORGE,
+  AVR32_SYNTAX_EORLT,
+  AVR32_SYNTAX_EORMI,
+  AVR32_SYNTAX_EORPL,
+  AVR32_SYNTAX_EORLS,
+  AVR32_SYNTAX_EORGT,
+  AVR32_SYNTAX_EORLE,
+  AVR32_SYNTAX_EORHI,
+  AVR32_SYNTAX_EORVS,
+  AVR32_SYNTAX_EORVC,
+  AVR32_SYNTAX_EORQS,
+  AVR32_SYNTAX_EORAL,
+  AVR32_SYNTAX_EORHS,
+  AVR32_SYNTAX_EORLO,
+  AVR32_SYNTAX_LD_WEQ,
+  AVR32_SYNTAX_LD_WNE,
+  AVR32_SYNTAX_LD_WCC,
+  AVR32_SYNTAX_LD_WCS,
+  AVR32_SYNTAX_LD_WGE,
+  AVR32_SYNTAX_LD_WLT,
+  AVR32_SYNTAX_LD_WMI,
+  AVR32_SYNTAX_LD_WPL,
+  AVR32_SYNTAX_LD_WLS,
+  AVR32_SYNTAX_LD_WGT,
+  AVR32_SYNTAX_LD_WLE,
+  AVR32_SYNTAX_LD_WHI,
+  AVR32_SYNTAX_LD_WVS,
+  AVR32_SYNTAX_LD_WVC,
+  AVR32_SYNTAX_LD_WQS,
+  AVR32_SYNTAX_LD_WAL,
+  AVR32_SYNTAX_LD_WHS,
+  AVR32_SYNTAX_LD_WLO,
+  AVR32_SYNTAX_LD_SHEQ,
+  AVR32_SYNTAX_LD_SHNE,
+  AVR32_SYNTAX_LD_SHCC,
+  AVR32_SYNTAX_LD_SHCS,
+  AVR32_SYNTAX_LD_SHGE,
+  AVR32_SYNTAX_LD_SHLT,
+  AVR32_SYNTAX_LD_SHMI,
+  AVR32_SYNTAX_LD_SHPL,
+  AVR32_SYNTAX_LD_SHLS,
+  AVR32_SYNTAX_LD_SHGT,
+  AVR32_SYNTAX_LD_SHLE,
+  AVR32_SYNTAX_LD_SHHI,
+  AVR32_SYNTAX_LD_SHVS,
+  AVR32_SYNTAX_LD_SHVC,
+  AVR32_SYNTAX_LD_SHQS,
+  AVR32_SYNTAX_LD_SHAL,
+  AVR32_SYNTAX_LD_SHHS,
+  AVR32_SYNTAX_LD_SHLO,
+  AVR32_SYNTAX_LD_UHEQ,
+  AVR32_SYNTAX_LD_UHNE,
+  AVR32_SYNTAX_LD_UHCC,
+  AVR32_SYNTAX_LD_UHCS,
+  AVR32_SYNTAX_LD_UHGE,
+  AVR32_SYNTAX_LD_UHLT,
+  AVR32_SYNTAX_LD_UHMI,
+  AVR32_SYNTAX_LD_UHPL,
+  AVR32_SYNTAX_LD_UHLS,
+  AVR32_SYNTAX_LD_UHGT,
+  AVR32_SYNTAX_LD_UHLE,
+  AVR32_SYNTAX_LD_UHHI,
+  AVR32_SYNTAX_LD_UHVS,
+  AVR32_SYNTAX_LD_UHVC,
+  AVR32_SYNTAX_LD_UHQS,
+  AVR32_SYNTAX_LD_UHAL,
+  AVR32_SYNTAX_LD_UHHS,
+  AVR32_SYNTAX_LD_UHLO,
+  AVR32_SYNTAX_LD_SBEQ,
+  AVR32_SYNTAX_LD_SBNE,
+  AVR32_SYNTAX_LD_SBCC,
+  AVR32_SYNTAX_LD_SBCS,
+  AVR32_SYNTAX_LD_SBGE,
+  AVR32_SYNTAX_LD_SBLT,
+  AVR32_SYNTAX_LD_SBMI,
+  AVR32_SYNTAX_LD_SBPL,
+  AVR32_SYNTAX_LD_SBLS,
+  AVR32_SYNTAX_LD_SBGT,
+  AVR32_SYNTAX_LD_SBLE,
+  AVR32_SYNTAX_LD_SBHI,
+  AVR32_SYNTAX_LD_SBVS,
+  AVR32_SYNTAX_LD_SBVC,
+  AVR32_SYNTAX_LD_SBQS,
+  AVR32_SYNTAX_LD_SBAL,
+  AVR32_SYNTAX_LD_SBHS,
+  AVR32_SYNTAX_LD_SBLO,
+  AVR32_SYNTAX_LD_UBEQ,
+  AVR32_SYNTAX_LD_UBNE,
+  AVR32_SYNTAX_LD_UBCC,
+  AVR32_SYNTAX_LD_UBCS,
+  AVR32_SYNTAX_LD_UBGE,
+  AVR32_SYNTAX_LD_UBLT,
+  AVR32_SYNTAX_LD_UBMI,
+  AVR32_SYNTAX_LD_UBPL,
+  AVR32_SYNTAX_LD_UBLS,
+  AVR32_SYNTAX_LD_UBGT,
+  AVR32_SYNTAX_LD_UBLE,
+  AVR32_SYNTAX_LD_UBHI,
+  AVR32_SYNTAX_LD_UBVS,
+  AVR32_SYNTAX_LD_UBVC,
+  AVR32_SYNTAX_LD_UBQS,
+  AVR32_SYNTAX_LD_UBAL,
+  AVR32_SYNTAX_LD_UBHS,
+  AVR32_SYNTAX_LD_UBLO,
+  AVR32_SYNTAX_ST_WEQ,
+  AVR32_SYNTAX_ST_WNE,
+  AVR32_SYNTAX_ST_WCC,
+  AVR32_SYNTAX_ST_WCS,
+  AVR32_SYNTAX_ST_WGE,
+  AVR32_SYNTAX_ST_WLT,
+  AVR32_SYNTAX_ST_WMI,
+  AVR32_SYNTAX_ST_WPL,
+  AVR32_SYNTAX_ST_WLS,
+  AVR32_SYNTAX_ST_WGT,
+  AVR32_SYNTAX_ST_WLE,
+  AVR32_SYNTAX_ST_WHI,
+  AVR32_SYNTAX_ST_WVS,
+  AVR32_SYNTAX_ST_WVC,
+  AVR32_SYNTAX_ST_WQS,
+  AVR32_SYNTAX_ST_WAL,
+  AVR32_SYNTAX_ST_WHS,
+  AVR32_SYNTAX_ST_WLO,
+  AVR32_SYNTAX_ST_HEQ,
+  AVR32_SYNTAX_ST_HNE,
+  AVR32_SYNTAX_ST_HCC,
+  AVR32_SYNTAX_ST_HCS,
+  AVR32_SYNTAX_ST_HGE,
+  AVR32_SYNTAX_ST_HLT,
+  AVR32_SYNTAX_ST_HMI,
+  AVR32_SYNTAX_ST_HPL,
+  AVR32_SYNTAX_ST_HLS,
+  AVR32_SYNTAX_ST_HGT,
+  AVR32_SYNTAX_ST_HLE,
+  AVR32_SYNTAX_ST_HHI,
+  AVR32_SYNTAX_ST_HVS,
+  AVR32_SYNTAX_ST_HVC,
+  AVR32_SYNTAX_ST_HQS,
+  AVR32_SYNTAX_ST_HAL,
+  AVR32_SYNTAX_ST_HHS,
+  AVR32_SYNTAX_ST_HLO,
+  AVR32_SYNTAX_ST_BEQ,
+  AVR32_SYNTAX_ST_BNE,
+  AVR32_SYNTAX_ST_BCC,
+  AVR32_SYNTAX_ST_BCS,
+  AVR32_SYNTAX_ST_BGE,
+  AVR32_SYNTAX_ST_BLT,
+  AVR32_SYNTAX_ST_BMI,
+  AVR32_SYNTAX_ST_BPL,
+  AVR32_SYNTAX_ST_BLS,
+  AVR32_SYNTAX_ST_BGT,
+  AVR32_SYNTAX_ST_BLE,
+  AVR32_SYNTAX_ST_BHI,
+  AVR32_SYNTAX_ST_BVS,
+  AVR32_SYNTAX_ST_BVC,
+  AVR32_SYNTAX_ST_BQS,
+  AVR32_SYNTAX_ST_BAL,
+  AVR32_SYNTAX_ST_BHS,
+  AVR32_SYNTAX_ST_BLO,
+  AVR32_SYNTAX_MOVH,
+  AVR32_SYNTAX__END_
+};
+#define AVR32_NR_SYNTAX AVR32_SYNTAX__END_
+
+enum avr32_alias_type
+  {
+    AVR32_ALIAS_FMAC_S,
+    AVR32_ALIAS_FMAC_D,
+    AVR32_ALIAS_FNMAC_S,
+    AVR32_ALIAS_FNMAC_D,
+    AVR32_ALIAS_FMSC_S,
+    AVR32_ALIAS_FMSC_D,
+    AVR32_ALIAS_FNMSC_S,
+    AVR32_ALIAS_FNMSC_D,
+    AVR32_ALIAS_FADD_S,
+    AVR32_ALIAS_FADD_D,
+    AVR32_ALIAS_FSUB_S,
+    AVR32_ALIAS_FSUB_D,
+    AVR32_ALIAS_FMUL_S,
+    AVR32_ALIAS_FMUL_D,
+    AVR32_ALIAS_FNMUL_S,
+    AVR32_ALIAS_FNMUL_D,
+    AVR32_ALIAS_FNEG_S,
+    AVR32_ALIAS_FNEG_D,
+    AVR32_ALIAS_FABS_S,
+    AVR32_ALIAS_FABS_D,
+    AVR32_ALIAS_FCMP_S,
+    AVR32_ALIAS_FCMP_D,
+    AVR32_ALIAS_FMOV1_S,
+    AVR32_ALIAS_FMOV1_D,
+    AVR32_ALIAS_FMOV2_S,
+    AVR32_ALIAS_FMOV2_D,
+    AVR32_ALIAS_FMOV3_S,
+    AVR32_ALIAS_FMOV3_D,
+    AVR32_ALIAS_FCASTS_D,
+    AVR32_ALIAS_FCASTD_S,
+    AVR32_ALIAS_PICOSVMAC0,
+    AVR32_ALIAS_PICOSVMAC1,
+    AVR32_ALIAS_PICOSVMAC2,
+    AVR32_ALIAS_PICOSVMAC3,
+    AVR32_ALIAS_PICOSVMUL0,
+    AVR32_ALIAS_PICOSVMUL1,
+    AVR32_ALIAS_PICOSVMUL2,
+    AVR32_ALIAS_PICOSVMUL3,
+    AVR32_ALIAS_PICOVMAC0,
+    AVR32_ALIAS_PICOVMAC1,
+    AVR32_ALIAS_PICOVMAC2,
+    AVR32_ALIAS_PICOVMAC3,
+    AVR32_ALIAS_PICOVMUL0,
+    AVR32_ALIAS_PICOVMUL1,
+    AVR32_ALIAS_PICOVMUL2,
+    AVR32_ALIAS_PICOVMUL3,
+    AVR32_ALIAS_PICOLD_D1,
+    AVR32_ALIAS_PICOLD_D2,
+    AVR32_ALIAS_PICOLD_D3,
+    AVR32_ALIAS_PICOLD_W1,
+    AVR32_ALIAS_PICOLD_W2,
+    AVR32_ALIAS_PICOLD_W3,
+    AVR32_ALIAS_PICOLDM_D,
+    AVR32_ALIAS_PICOLDM_D_PU,
+    AVR32_ALIAS_PICOLDM_W,
+    AVR32_ALIAS_PICOLDM_W_PU,
+    AVR32_ALIAS_PICOMV_D1,
+    AVR32_ALIAS_PICOMV_D2,
+    AVR32_ALIAS_PICOMV_W1,
+    AVR32_ALIAS_PICOMV_W2,
+    AVR32_ALIAS_PICOST_D1,
+    AVR32_ALIAS_PICOST_D2,
+    AVR32_ALIAS_PICOST_D3,
+    AVR32_ALIAS_PICOST_W1,
+    AVR32_ALIAS_PICOST_W2,
+    AVR32_ALIAS_PICOST_W3,
+    AVR32_ALIAS_PICOSTM_D,
+    AVR32_ALIAS_PICOSTM_D_PU,
+    AVR32_ALIAS_PICOSTM_W,
+    AVR32_ALIAS_PICOSTM_W_PU,
+    AVR32_ALIAS__END_
+  };
+#define AVR32_NR_ALIAS AVR32_ALIAS__END_
+
+enum avr32_mnemonic_type
+{
+  AVR32_MNEMONIC_ABS,
+  AVR32_MNEMONIC_ACALL,
+  AVR32_MNEMONIC_ACR,
+  AVR32_MNEMONIC_ADC,
+  AVR32_MNEMONIC_ADD,
+  AVR32_MNEMONIC_ADDABS,
+  AVR32_MNEMONIC_ADDHH_W,
+  AVR32_MNEMONIC_AND,
+  AVR32_MNEMONIC_ANDH,
+  AVR32_MNEMONIC_ANDL,
+  AVR32_MNEMONIC_ANDN,
+  AVR32_MNEMONIC_ASR,
+  AVR32_MNEMONIC_BFEXTS,
+  AVR32_MNEMONIC_BFEXTU,
+  AVR32_MNEMONIC_BFINS,
+  AVR32_MNEMONIC_BLD,
+  AVR32_MNEMONIC_BREQ,
+  AVR32_MNEMONIC_BRNE,
+  AVR32_MNEMONIC_BRCC,
+  AVR32_MNEMONIC_BRCS,
+  AVR32_MNEMONIC_BRGE,
+  AVR32_MNEMONIC_BRLT,
+  AVR32_MNEMONIC_BRMI,
+  AVR32_MNEMONIC_BRPL,
+  AVR32_MNEMONIC_BRHS,
+  AVR32_MNEMONIC_BRLO,
+  AVR32_MNEMONIC_BRLS,
+  AVR32_MNEMONIC_BRGT,
+  AVR32_MNEMONIC_BRLE,
+  AVR32_MNEMONIC_BRHI,
+  AVR32_MNEMONIC_BRVS,
+  AVR32_MNEMONIC_BRVC,
+  AVR32_MNEMONIC_BRQS,
+  AVR32_MNEMONIC_BRAL,
+  AVR32_MNEMONIC_BREAKPOINT,
+  AVR32_MNEMONIC_BREV,
+  AVR32_MNEMONIC_BST,
+  AVR32_MNEMONIC_CACHE,
+  AVR32_MNEMONIC_CASTS_B,
+  AVR32_MNEMONIC_CASTS_H,
+  AVR32_MNEMONIC_CASTU_B,
+  AVR32_MNEMONIC_CASTU_H,
+  AVR32_MNEMONIC_CBR,
+  AVR32_MNEMONIC_CLZ,
+  AVR32_MNEMONIC_COM,
+  AVR32_MNEMONIC_COP,
+  AVR32_MNEMONIC_CP_B,
+  AVR32_MNEMONIC_CP_H,
+  AVR32_MNEMONIC_CP_W,
+  AVR32_MNEMONIC_CP,
+  AVR32_MNEMONIC_CPC,
+  AVR32_MNEMONIC_CSRF,
+  AVR32_MNEMONIC_CSRFCZ,
+  AVR32_MNEMONIC_DIVS,
+  AVR32_MNEMONIC_DIVU,
+  AVR32_MNEMONIC_EOR,
+  AVR32_MNEMONIC_EORL,
+  AVR32_MNEMONIC_EORH,
+  AVR32_MNEMONIC_FRS,
+  AVR32_MNEMONIC_ICALL,
+  AVR32_MNEMONIC_INCJOSP,
+  AVR32_MNEMONIC_LD_D,
+  AVR32_MNEMONIC_LD_SB,
+  AVR32_MNEMONIC_LD_UB,
+  AVR32_MNEMONIC_LD_SH,
+  AVR32_MNEMONIC_LD_UH,
+  AVR32_MNEMONIC_LD_W,
+  AVR32_MNEMONIC_LDC_D,
+  AVR32_MNEMONIC_LDC_W,
+  AVR32_MNEMONIC_LDC0_D,
+  AVR32_MNEMONIC_LDC0_W,
+  AVR32_MNEMONIC_LDCM_D,
+  AVR32_MNEMONIC_LDCM_W,
+  AVR32_MNEMONIC_LDDPC,
+  AVR32_MNEMONIC_LDDSP,
+  AVR32_MNEMONIC_LDINS_B,
+  AVR32_MNEMONIC_LDINS_H,
+  AVR32_MNEMONIC_LDM,
+  AVR32_MNEMONIC_LDMTS,
+  AVR32_MNEMONIC_LDSWP_SH,
+  AVR32_MNEMONIC_LDSWP_UH,
+  AVR32_MNEMONIC_LDSWP_W,
+  AVR32_MNEMONIC_LSL,
+  AVR32_MNEMONIC_LSR,
+  AVR32_MNEMONIC_MAC,
+  AVR32_MNEMONIC_MACHH_D,
+  AVR32_MNEMONIC_MACHH_W,
+  AVR32_MNEMONIC_MACS_D,
+  AVR32_MNEMONIC_MACSATHH_W,
+  AVR32_MNEMONIC_MACU_D,
+  AVR32_MNEMONIC_MACWH_D,
+  AVR32_MNEMONIC_MAX,
+  AVR32_MNEMONIC_MCALL,
+  AVR32_MNEMONIC_MFDR,
+  AVR32_MNEMONIC_MFSR,
+  AVR32_MNEMONIC_MIN,
+  AVR32_MNEMONIC_MOV,
+  AVR32_MNEMONIC_MOVEQ,
+  AVR32_MNEMONIC_MOVNE,
+  AVR32_MNEMONIC_MOVCC,
+  AVR32_MNEMONIC_MOVCS,
+  AVR32_MNEMONIC_MOVGE,
+  AVR32_MNEMONIC_MOVLT,
+  AVR32_MNEMONIC_MOVMI,
+  AVR32_MNEMONIC_MOVPL,
+  AVR32_MNEMONIC_MOVLS,
+  AVR32_MNEMONIC_MOVGT,
+  AVR32_MNEMONIC_MOVLE,
+  AVR32_MNEMONIC_MOVHI,
+  AVR32_MNEMONIC_MOVVS,
+  AVR32_MNEMONIC_MOVVC,
+  AVR32_MNEMONIC_MOVQS,
+  AVR32_MNEMONIC_MOVAL,
+  AVR32_MNEMONIC_MOVHS,
+  AVR32_MNEMONIC_MOVLO,
+  AVR32_MNEMONIC_MTDR,
+  AVR32_MNEMONIC_MTSR,
+  AVR32_MNEMONIC_MUL,
+  AVR32_MNEMONIC_MULHH_W,
+  AVR32_MNEMONIC_MULNHH_W,
+  AVR32_MNEMONIC_MULNWH_D,
+  AVR32_MNEMONIC_MULS_D,
+  AVR32_MNEMONIC_MULSATHH_H,
+  AVR32_MNEMONIC_MULSATHH_W,
+  AVR32_MNEMONIC_MULSATRNDHH_H,
+  AVR32_MNEMONIC_MULSATRNDWH_W,
+  AVR32_MNEMONIC_MULSATWH_W,
+  AVR32_MNEMONIC_MULU_D,
+  AVR32_MNEMONIC_MULWH_D,
+  AVR32_MNEMONIC_MUSFR,
+  AVR32_MNEMONIC_MUSTR,
+  AVR32_MNEMONIC_MVCR_D,
+  AVR32_MNEMONIC_MVCR_W,
+  AVR32_MNEMONIC_MVRC_D,
+  AVR32_MNEMONIC_MVRC_W,
+  AVR32_MNEMONIC_NEG,
+  AVR32_MNEMONIC_NOP,
+  AVR32_MNEMONIC_OR,
+  AVR32_MNEMONIC_ORH,
+  AVR32_MNEMONIC_ORL,
+  AVR32_MNEMONIC_PABS_SB,
+  AVR32_MNEMONIC_PABS_SH,
+  AVR32_MNEMONIC_PACKSH_SB,
+  AVR32_MNEMONIC_PACKSH_UB,
+  AVR32_MNEMONIC_PACKW_SH,
+  AVR32_MNEMONIC_PADD_B,
+  AVR32_MNEMONIC_PADD_H,
+  AVR32_MNEMONIC_PADDH_SH,
+  AVR32_MNEMONIC_PADDH_UB,
+  AVR32_MNEMONIC_PADDS_SB,
+  AVR32_MNEMONIC_PADDS_SH,
+  AVR32_MNEMONIC_PADDS_UB,
+  AVR32_MNEMONIC_PADDS_UH,
+  AVR32_MNEMONIC_PADDSUB_H,
+  AVR32_MNEMONIC_PADDSUBH_SH,
+  AVR32_MNEMONIC_PADDSUBS_SH,
+  AVR32_MNEMONIC_PADDSUBS_UH,
+  AVR32_MNEMONIC_PADDX_H,
+  AVR32_MNEMONIC_PADDXH_SH,
+  AVR32_MNEMONIC_PADDXS_SH,
+  AVR32_MNEMONIC_PADDXS_UH,
+  AVR32_MNEMONIC_PASR_B,
+  AVR32_MNEMONIC_PASR_H,
+  AVR32_MNEMONIC_PAVG_SH,
+  AVR32_MNEMONIC_PAVG_UB,
+  AVR32_MNEMONIC_PLSL_B,
+  AVR32_MNEMONIC_PLSL_H,
+  AVR32_MNEMONIC_PLSR_B,
+  AVR32_MNEMONIC_PLSR_H,
+  AVR32_MNEMONIC_PMAX_SH,
+  AVR32_MNEMONIC_PMAX_UB,
+  AVR32_MNEMONIC_PMIN_SH,
+  AVR32_MNEMONIC_PMIN_UB,
+  AVR32_MNEMONIC_POPJC,
+  AVR32_MNEMONIC_POPM,
+  AVR32_MNEMONIC_PREF,
+  AVR32_MNEMONIC_PSAD,
+  AVR32_MNEMONIC_PSUB_B,
+  AVR32_MNEMONIC_PSUB_H,
+  AVR32_MNEMONIC_PSUBADD_H,
+  AVR32_MNEMONIC_PSUBADDH_SH,
+  AVR32_MNEMONIC_PSUBADDS_SH,
+  AVR32_MNEMONIC_PSUBADDS_UH,
+  AVR32_MNEMONIC_PSUBH_SH,
+  AVR32_MNEMONIC_PSUBH_UB,
+  AVR32_MNEMONIC_PSUBS_SB,
+  AVR32_MNEMONIC_PSUBS_SH,
+  AVR32_MNEMONIC_PSUBS_UB,
+  AVR32_MNEMONIC_PSUBS_UH,
+  AVR32_MNEMONIC_PSUBX_H,
+  AVR32_MNEMONIC_PSUBXH_SH,
+  AVR32_MNEMONIC_PSUBXS_SH,
+  AVR32_MNEMONIC_PSUBXS_UH,
+  AVR32_MNEMONIC_PUNPCKSB_H,
+  AVR32_MNEMONIC_PUNPCKUB_H,
+  AVR32_MNEMONIC_PUSHJC,
+  AVR32_MNEMONIC_PUSHM,
+  AVR32_MNEMONIC_RCALL,
+  AVR32_MNEMONIC_RETEQ,
+  AVR32_MNEMONIC_RETNE,
+  AVR32_MNEMONIC_RETCC,
+  AVR32_MNEMONIC_RETCS,
+  AVR32_MNEMONIC_RETGE,
+  AVR32_MNEMONIC_RETLT,
+  AVR32_MNEMONIC_RETMI,
+  AVR32_MNEMONIC_RETPL,
+  AVR32_MNEMONIC_RETLS,
+  AVR32_MNEMONIC_RETGT,
+  AVR32_MNEMONIC_RETLE,
+  AVR32_MNEMONIC_RETHI,
+  AVR32_MNEMONIC_RETVS,
+  AVR32_MNEMONIC_RETVC,
+  AVR32_MNEMONIC_RETQS,
+  AVR32_MNEMONIC_RETAL,
+  AVR32_MNEMONIC_RETHS,
+  AVR32_MNEMONIC_RETLO,
+  AVR32_MNEMONIC_RET,
+  AVR32_MNEMONIC_RETD,
+  AVR32_MNEMONIC_RETE,
+  AVR32_MNEMONIC_RETJ,
+  AVR32_MNEMONIC_RETS,
+  AVR32_MNEMONIC_RJMP,
+  AVR32_MNEMONIC_ROL,
+  AVR32_MNEMONIC_ROR,
+  AVR32_MNEMONIC_RSUB,
+  AVR32_MNEMONIC_SATADD_H,
+  AVR32_MNEMONIC_SATADD_W,
+  AVR32_MNEMONIC_SATRNDS,
+  AVR32_MNEMONIC_SATRNDU,
+  AVR32_MNEMONIC_SATS,
+  AVR32_MNEMONIC_SATSUB_H,
+  AVR32_MNEMONIC_SATSUB_W,
+  AVR32_MNEMONIC_SATU,
+  AVR32_MNEMONIC_SBC,
+  AVR32_MNEMONIC_SBR,
+  AVR32_MNEMONIC_SCALL,
+  AVR32_MNEMONIC_SCR,
+  AVR32_MNEMONIC_SLEEP,
+  AVR32_MNEMONIC_SREQ,
+  AVR32_MNEMONIC_SRNE,
+  AVR32_MNEMONIC_SRCC,
+  AVR32_MNEMONIC_SRCS,
+  AVR32_MNEMONIC_SRGE,
+  AVR32_MNEMONIC_SRLT,
+  AVR32_MNEMONIC_SRMI,
+  AVR32_MNEMONIC_SRPL,
+  AVR32_MNEMONIC_SRLS,
+  AVR32_MNEMONIC_SRGT,
+  AVR32_MNEMONIC_SRLE,
+  AVR32_MNEMONIC_SRHI,
+  AVR32_MNEMONIC_SRVS,
+  AVR32_MNEMONIC_SRVC,
+  AVR32_MNEMONIC_SRQS,
+  AVR32_MNEMONIC_SRAL,
+  AVR32_MNEMONIC_SRHS,
+  AVR32_MNEMONIC_SRLO,
+  AVR32_MNEMONIC_SSRF,
+  AVR32_MNEMONIC_ST_B,
+  AVR32_MNEMONIC_ST_D,
+  AVR32_MNEMONIC_ST_H,
+  AVR32_MNEMONIC_ST_W,
+  AVR32_MNEMONIC_STC_D,
+  AVR32_MNEMONIC_STC_W,
+  AVR32_MNEMONIC_STC0_D,
+  AVR32_MNEMONIC_STC0_W,
+  AVR32_MNEMONIC_STCM_D,
+  AVR32_MNEMONIC_STCM_W,
+  AVR32_MNEMONIC_STCOND,
+  AVR32_MNEMONIC_STDSP,
+  AVR32_MNEMONIC_STHH_W,
+  AVR32_MNEMONIC_STM,
+  AVR32_MNEMONIC_STMTS,
+  AVR32_MNEMONIC_STSWP_H,
+  AVR32_MNEMONIC_STSWP_W,
+  AVR32_MNEMONIC_SUB,
+  AVR32_MNEMONIC_SUBEQ,
+  AVR32_MNEMONIC_SUBNE,
+  AVR32_MNEMONIC_SUBCC,
+  AVR32_MNEMONIC_SUBCS,
+  AVR32_MNEMONIC_SUBGE,
+  AVR32_MNEMONIC_SUBLT,
+  AVR32_MNEMONIC_SUBMI,
+  AVR32_MNEMONIC_SUBPL,
+  AVR32_MNEMONIC_SUBLS,
+  AVR32_MNEMONIC_SUBGT,
+  AVR32_MNEMONIC_SUBLE,
+  AVR32_MNEMONIC_SUBHI,
+  AVR32_MNEMONIC_SUBVS,
+  AVR32_MNEMONIC_SUBVC,
+  AVR32_MNEMONIC_SUBQS,
+  AVR32_MNEMONIC_SUBAL,
+  AVR32_MNEMONIC_SUBHS,
+  AVR32_MNEMONIC_SUBLO,
+  AVR32_MNEMONIC_SUBFEQ,
+  AVR32_MNEMONIC_SUBFNE,
+  AVR32_MNEMONIC_SUBFCC,
+  AVR32_MNEMONIC_SUBFCS,
+  AVR32_MNEMONIC_SUBFGE,
+  AVR32_MNEMONIC_SUBFLT,
+  AVR32_MNEMONIC_SUBFMI,
+  AVR32_MNEMONIC_SUBFPL,
+  AVR32_MNEMONIC_SUBFLS,
+  AVR32_MNEMONIC_SUBFGT,
+  AVR32_MNEMONIC_SUBFLE,
+  AVR32_MNEMONIC_SUBFHI,
+  AVR32_MNEMONIC_SUBFVS,
+  AVR32_MNEMONIC_SUBFVC,
+  AVR32_MNEMONIC_SUBFQS,
+  AVR32_MNEMONIC_SUBFAL,
+  AVR32_MNEMONIC_SUBFHS,
+  AVR32_MNEMONIC_SUBFLO,
+  AVR32_MNEMONIC_SUBHH_W,
+  AVR32_MNEMONIC_SWAP_B,
+  AVR32_MNEMONIC_SWAP_BH,
+  AVR32_MNEMONIC_SWAP_H,
+  AVR32_MNEMONIC_SYNC,
+  AVR32_MNEMONIC_TLBR,
+  AVR32_MNEMONIC_TLBS,
+  AVR32_MNEMONIC_TLBW,
+  AVR32_MNEMONIC_TNBZ,
+  AVR32_MNEMONIC_TST,
+  AVR32_MNEMONIC_XCHG,
+  AVR32_MNEMONIC_MEMC,
+  AVR32_MNEMONIC_MEMS,
+  AVR32_MNEMONIC_MEMT,
+  AVR32_MNEMONIC_FADD_S,
+  AVR32_MNEMONIC_FADD_D,
+  AVR32_MNEMONIC_FSUB_S,
+  AVR32_MNEMONIC_FSUB_D,
+  AVR32_MNEMONIC_FMAC_S,
+  AVR32_MNEMONIC_FMAC_D,
+  AVR32_MNEMONIC_FNMAC_S,
+  AVR32_MNEMONIC_FNMAC_D,
+  AVR32_MNEMONIC_FMSC_S,
+  AVR32_MNEMONIC_FMSC_D,
+  AVR32_MNEMONIC_FNMSC_S,
+  AVR32_MNEMONIC_FNMSC_D,
+  AVR32_MNEMONIC_FMUL_S,
+  AVR32_MNEMONIC_FMUL_D,
+  AVR32_MNEMONIC_FNMUL_S,
+  AVR32_MNEMONIC_FNMUL_D,
+  AVR32_MNEMONIC_FNEG_S,
+  AVR32_MNEMONIC_FNEG_D,
+  AVR32_MNEMONIC_FABS_S,
+  AVR32_MNEMONIC_FABS_D,
+  AVR32_MNEMONIC_FCMP_S,
+  AVR32_MNEMONIC_FCMP_D,
+  AVR32_MNEMONIC_FMOV_S,
+  AVR32_MNEMONIC_FMOV_D,
+  AVR32_MNEMONIC_FCASTS_D,
+  AVR32_MNEMONIC_FCASTD_S,
+  /* AVR32_MNEMONIC_FLD_S,
+     AVR32_MNEMONIC_FLD_D,
+     AVR32_MNEMONIC_FST_S,
+     AVR32_MNEMONIC_FST_D, */
+  AVR32_MNEMONIC_LDA_W,
+  AVR32_MNEMONIC_CALL,
+  AVR32_MNEMONIC_PICOSVMAC,
+  AVR32_MNEMONIC_PICOSVMUL,
+  AVR32_MNEMONIC_PICOVMAC,
+  AVR32_MNEMONIC_PICOVMUL,
+  AVR32_MNEMONIC_PICOLD_D,
+  AVR32_MNEMONIC_PICOLD_W,
+  AVR32_MNEMONIC_PICOLDM_D,
+  AVR32_MNEMONIC_PICOLDM_W,
+  AVR32_MNEMONIC_PICOMV_D,
+  AVR32_MNEMONIC_PICOMV_W,
+  AVR32_MNEMONIC_PICOST_D,
+  AVR32_MNEMONIC_PICOST_W,
+  AVR32_MNEMONIC_PICOSTM_D,
+  AVR32_MNEMONIC_PICOSTM_W,
+  AVR32_MNEMONIC_RSUBEQ,
+  AVR32_MNEMONIC_RSUBNE,
+  AVR32_MNEMONIC_RSUBCC,
+  AVR32_MNEMONIC_RSUBCS,
+  AVR32_MNEMONIC_RSUBGE,
+  AVR32_MNEMONIC_RSUBLT,
+  AVR32_MNEMONIC_RSUBMI,
+  AVR32_MNEMONIC_RSUBPL,
+  AVR32_MNEMONIC_RSUBLS,
+  AVR32_MNEMONIC_RSUBGT,
+  AVR32_MNEMONIC_RSUBLE,
+  AVR32_MNEMONIC_RSUBHI,
+  AVR32_MNEMONIC_RSUBVS,
+  AVR32_MNEMONIC_RSUBVC,
+  AVR32_MNEMONIC_RSUBQS,
+  AVR32_MNEMONIC_RSUBAL,
+  AVR32_MNEMONIC_RSUBHS,
+  AVR32_MNEMONIC_RSUBLO,
+  AVR32_MNEMONIC_ADDEQ,
+  AVR32_MNEMONIC_ADDNE,
+  AVR32_MNEMONIC_ADDCC,
+  AVR32_MNEMONIC_ADDCS,
+  AVR32_MNEMONIC_ADDGE,
+  AVR32_MNEMONIC_ADDLT,
+  AVR32_MNEMONIC_ADDMI,
+  AVR32_MNEMONIC_ADDPL,
+  AVR32_MNEMONIC_ADDLS,
+  AVR32_MNEMONIC_ADDGT,
+  AVR32_MNEMONIC_ADDLE,
+  AVR32_MNEMONIC_ADDHI,
+  AVR32_MNEMONIC_ADDVS,
+  AVR32_MNEMONIC_ADDVC,
+  AVR32_MNEMONIC_ADDQS,
+  AVR32_MNEMONIC_ADDAL,
+  AVR32_MNEMONIC_ADDHS,
+  AVR32_MNEMONIC_ADDLO,
+  AVR32_MNEMONIC_ANDEQ,
+  AVR32_MNEMONIC_ANDNE,
+  AVR32_MNEMONIC_ANDCC,
+  AVR32_MNEMONIC_ANDCS,
+  AVR32_MNEMONIC_ANDGE,
+  AVR32_MNEMONIC_ANDLT,
+  AVR32_MNEMONIC_ANDMI,
+  AVR32_MNEMONIC_ANDPL,
+  AVR32_MNEMONIC_ANDLS,
+  AVR32_MNEMONIC_ANDGT,
+  AVR32_MNEMONIC_ANDLE,
+  AVR32_MNEMONIC_ANDHI,
+  AVR32_MNEMONIC_ANDVS,
+  AVR32_MNEMONIC_ANDVC,
+  AVR32_MNEMONIC_ANDQS,
+  AVR32_MNEMONIC_ANDAL,
+  AVR32_MNEMONIC_ANDHS,
+  AVR32_MNEMONIC_ANDLO,
+  AVR32_MNEMONIC_OREQ,
+  AVR32_MNEMONIC_ORNE,
+  AVR32_MNEMONIC_ORCC,
+  AVR32_MNEMONIC_ORCS,
+  AVR32_MNEMONIC_ORGE,
+  AVR32_MNEMONIC_ORLT,
+  AVR32_MNEMONIC_ORMI,
+  AVR32_MNEMONIC_ORPL,
+  AVR32_MNEMONIC_ORLS,
+  AVR32_MNEMONIC_ORGT,
+  AVR32_MNEMONIC_ORLE,
+  AVR32_MNEMONIC_ORHI,
+  AVR32_MNEMONIC_ORVS,
+  AVR32_MNEMONIC_ORVC,
+  AVR32_MNEMONIC_ORQS,
+  AVR32_MNEMONIC_ORAL,
+  AVR32_MNEMONIC_ORHS,
+  AVR32_MNEMONIC_ORLO,
+  AVR32_MNEMONIC_EOREQ,
+  AVR32_MNEMONIC_EORNE,
+  AVR32_MNEMONIC_EORCC,
+  AVR32_MNEMONIC_EORCS,
+  AVR32_MNEMONIC_EORGE,
+  AVR32_MNEMONIC_EORLT,
+  AVR32_MNEMONIC_EORMI,
+  AVR32_MNEMONIC_EORPL,
+  AVR32_MNEMONIC_EORLS,
+  AVR32_MNEMONIC_EORGT,
+  AVR32_MNEMONIC_EORLE,
+  AVR32_MNEMONIC_EORHI,
+  AVR32_MNEMONIC_EORVS,
+  AVR32_MNEMONIC_EORVC,
+  AVR32_MNEMONIC_EORQS,
+  AVR32_MNEMONIC_EORAL,
+  AVR32_MNEMONIC_EORHS,
+  AVR32_MNEMONIC_EORLO,
+  AVR32_MNEMONIC_LD_WEQ,
+  AVR32_MNEMONIC_LD_WNE,
+  AVR32_MNEMONIC_LD_WCC,
+  AVR32_MNEMONIC_LD_WCS,
+  AVR32_MNEMONIC_LD_WGE,
+  AVR32_MNEMONIC_LD_WLT,
+  AVR32_MNEMONIC_LD_WMI,
+  AVR32_MNEMONIC_LD_WPL,
+  AVR32_MNEMONIC_LD_WLS,
+  AVR32_MNEMONIC_LD_WGT,
+  AVR32_MNEMONIC_LD_WLE,
+  AVR32_MNEMONIC_LD_WHI,
+  AVR32_MNEMONIC_LD_WVS,
+  AVR32_MNEMONIC_LD_WVC,
+  AVR32_MNEMONIC_LD_WQS,
+  AVR32_MNEMONIC_LD_WAL,
+  AVR32_MNEMONIC_LD_WHS,
+  AVR32_MNEMONIC_LD_WLO,
+  AVR32_MNEMONIC_LD_SHEQ,
+  AVR32_MNEMONIC_LD_SHNE,
+  AVR32_MNEMONIC_LD_SHCC,
+  AVR32_MNEMONIC_LD_SHCS,
+  AVR32_MNEMONIC_LD_SHGE,
+  AVR32_MNEMONIC_LD_SHLT,
+  AVR32_MNEMONIC_LD_SHMI,
+  AVR32_MNEMONIC_LD_SHPL,
+  AVR32_MNEMONIC_LD_SHLS,
+  AVR32_MNEMONIC_LD_SHGT,
+  AVR32_MNEMONIC_LD_SHLE,
+  AVR32_MNEMONIC_LD_SHHI,
+  AVR32_MNEMONIC_LD_SHVS,
+  AVR32_MNEMONIC_LD_SHVC,
+  AVR32_MNEMONIC_LD_SHQS,
+  AVR32_MNEMONIC_LD_SHAL,
+  AVR32_MNEMONIC_LD_SHHS,
+  AVR32_MNEMONIC_LD_SHLO,
+  AVR32_MNEMONIC_LD_UHEQ,
+  AVR32_MNEMONIC_LD_UHNE,
+  AVR32_MNEMONIC_LD_UHCC,
+  AVR32_MNEMONIC_LD_UHCS,
+  AVR32_MNEMONIC_LD_UHGE,
+  AVR32_MNEMONIC_LD_UHLT,
+  AVR32_MNEMONIC_LD_UHMI,
+  AVR32_MNEMONIC_LD_UHPL,
+  AVR32_MNEMONIC_LD_UHLS,
+  AVR32_MNEMONIC_LD_UHGT,
+  AVR32_MNEMONIC_LD_UHLE,
+  AVR32_MNEMONIC_LD_UHHI,
+  AVR32_MNEMONIC_LD_UHVS,
+  AVR32_MNEMONIC_LD_UHVC,
+  AVR32_MNEMONIC_LD_UHQS,
+  AVR32_MNEMONIC_LD_UHAL,
+  AVR32_MNEMONIC_LD_UHHS,
+  AVR32_MNEMONIC_LD_UHLO,
+  AVR32_MNEMONIC_LD_SBEQ,
+  AVR32_MNEMONIC_LD_SBNE,
+  AVR32_MNEMONIC_LD_SBCC,
+  AVR32_MNEMONIC_LD_SBCS,
+  AVR32_MNEMONIC_LD_SBGE,
+  AVR32_MNEMONIC_LD_SBLT,
+  AVR32_MNEMONIC_LD_SBMI,
+  AVR32_MNEMONIC_LD_SBPL,
+  AVR32_MNEMONIC_LD_SBLS,
+  AVR32_MNEMONIC_LD_SBGT,
+  AVR32_MNEMONIC_LD_SBLE,
+  AVR32_MNEMONIC_LD_SBHI,
+  AVR32_MNEMONIC_LD_SBVS,
+  AVR32_MNEMONIC_LD_SBVC,
+  AVR32_MNEMONIC_LD_SBQS,
+  AVR32_MNEMONIC_LD_SBAL,
+  AVR32_MNEMONIC_LD_SBHS,
+  AVR32_MNEMONIC_LD_SBLO,
+  AVR32_MNEMONIC_LD_UBEQ,
+  AVR32_MNEMONIC_LD_UBNE,
+  AVR32_MNEMONIC_LD_UBCC,
+  AVR32_MNEMONIC_LD_UBCS,
+  AVR32_MNEMONIC_LD_UBGE,
+  AVR32_MNEMONIC_LD_UBLT,
+  AVR32_MNEMONIC_LD_UBMI,
+  AVR32_MNEMONIC_LD_UBPL,
+  AVR32_MNEMONIC_LD_UBLS,
+  AVR32_MNEMONIC_LD_UBGT,
+  AVR32_MNEMONIC_LD_UBLE,
+  AVR32_MNEMONIC_LD_UBHI,
+  AVR32_MNEMONIC_LD_UBVS,
+  AVR32_MNEMONIC_LD_UBVC,
+  AVR32_MNEMONIC_LD_UBQS,
+  AVR32_MNEMONIC_LD_UBAL,
+  AVR32_MNEMONIC_LD_UBHS,
+  AVR32_MNEMONIC_LD_UBLO,
+  AVR32_MNEMONIC_ST_WEQ,
+  AVR32_MNEMONIC_ST_WNE,
+  AVR32_MNEMONIC_ST_WCC,
+  AVR32_MNEMONIC_ST_WCS,
+  AVR32_MNEMONIC_ST_WGE,
+  AVR32_MNEMONIC_ST_WLT,
+  AVR32_MNEMONIC_ST_WMI,
+  AVR32_MNEMONIC_ST_WPL,
+  AVR32_MNEMONIC_ST_WLS,
+  AVR32_MNEMONIC_ST_WGT,
+  AVR32_MNEMONIC_ST_WLE,
+  AVR32_MNEMONIC_ST_WHI,
+  AVR32_MNEMONIC_ST_WVS,
+  AVR32_MNEMONIC_ST_WVC,
+  AVR32_MNEMONIC_ST_WQS,
+  AVR32_MNEMONIC_ST_WAL,
+  AVR32_MNEMONIC_ST_WHS,
+  AVR32_MNEMONIC_ST_WLO,
+  AVR32_MNEMONIC_ST_HEQ,
+  AVR32_MNEMONIC_ST_HNE,
+  AVR32_MNEMONIC_ST_HCC,
+  AVR32_MNEMONIC_ST_HCS,
+  AVR32_MNEMONIC_ST_HGE,
+  AVR32_MNEMONIC_ST_HLT,
+  AVR32_MNEMONIC_ST_HMI,
+  AVR32_MNEMONIC_ST_HPL,
+  AVR32_MNEMONIC_ST_HLS,
+  AVR32_MNEMONIC_ST_HGT,
+  AVR32_MNEMONIC_ST_HLE,
+  AVR32_MNEMONIC_ST_HHI,
+  AVR32_MNEMONIC_ST_HVS,
+  AVR32_MNEMONIC_ST_HVC,
+  AVR32_MNEMONIC_ST_HQS,
+  AVR32_MNEMONIC_ST_HAL,
+  AVR32_MNEMONIC_ST_HHS,
+  AVR32_MNEMONIC_ST_HLO,
+  AVR32_MNEMONIC_ST_BEQ,
+  AVR32_MNEMONIC_ST_BNE,
+  AVR32_MNEMONIC_ST_BCC,
+  AVR32_MNEMONIC_ST_BCS,
+  AVR32_MNEMONIC_ST_BGE,
+  AVR32_MNEMONIC_ST_BLT,
+  AVR32_MNEMONIC_ST_BMI,
+  AVR32_MNEMONIC_ST_BPL,
+  AVR32_MNEMONIC_ST_BLS,
+  AVR32_MNEMONIC_ST_BGT,
+  AVR32_MNEMONIC_ST_BLE,
+  AVR32_MNEMONIC_ST_BHI,
+  AVR32_MNEMONIC_ST_BVS,
+  AVR32_MNEMONIC_ST_BVC,
+  AVR32_MNEMONIC_ST_BQS,
+  AVR32_MNEMONIC_ST_BAL,
+  AVR32_MNEMONIC_ST_BHS,
+  AVR32_MNEMONIC_ST_BLO,
+  AVR32_MNEMONIC_MOVH,
+  AVR32_MNEMONIC__END_
+};
+#define AVR32_NR_MNEMONICS AVR32_MNEMONIC__END_
+
+enum avr32_syntax_parser
+  {
+    AVR32_PARSER_NORMAL,
+    AVR32_PARSER_ALIAS,
+    AVR32_PARSER_LDA,
+    AVR32_PARSER_CALL,
+    AVR32_PARSER__END_
+  };
+#define AVR32_NR_PARSERS AVR32_PARSER__END_
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -158,6 +158,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_arc_arch)		ta="$ta arc-dis.lo arc-opc.lo arc-ext.lo" ;;
 	bfd_arm_arch)		ta="$ta arm-dis.lo" ;;
 	bfd_avr_arch)		ta="$ta avr-dis.lo" ;;
+	bfd_avr32_arch)		ta="$ta avr32-asm.lo avr32-dis.lo avr32-opc.lo" ;;
 	bfd_bfin_arch)		ta="$ta bfin-dis.lo" ;;
 	bfd_cr16_arch)    	ta="$ta cr16-dis.lo cr16-opc.lo" ;;
 	bfd_cris_arch)		ta="$ta cris-dis.lo cris-opc.lo cgen-bitset.lo" ;;
@@ -216,7 +217,7 @@ if test x${all_targets} = xfalse ; then
 				ta="$ta sh64-dis.lo sh64-opc.lo"
 				archdefs="$archdefs -DINCLUDE_SHMEDIA"
 				break;;
-	    esac;
+	    esac
 	  done
 				ta="$ta sh-dis.lo cgen-bitset.lo" ;;
 	bfd_sparc_arch)		ta="$ta sparc-dis.lo sparc-opc.lo" ;;
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -27,6 +27,7 @@
 #define ARCH_arc
 #define ARCH_arm
 #define ARCH_avr
+#define ARCH_avr32
 #define ARCH_bfin
 #define ARCH_cr16
 #define ARCH_cris
@@ -128,6 +129,11 @@ disassembler (abfd)
       disassemble = print_insn_avr;
       break;
 #endif
+#ifdef ARCH_avr32
+    case bfd_arch_avr32:
+      disassemble = print_insn_avr32;
+      break;
+#endif
 #ifdef ARCH_bfin
     case bfd_arch_bfin:
       disassemble = print_insn_bfin;
@@ -346,9 +352,9 @@ disassembler (abfd)
 #ifdef ARCH_score
     case bfd_arch_score:
       if (bfd_big_endian (abfd))
-        disassemble = print_insn_big_score;      
+        disassemble = print_insn_big_score;
       else
-        disassemble = print_insn_little_score; 
+        disassemble = print_insn_little_score;
      break;
 #endif
 #ifdef ARCH_sh
@@ -466,6 +472,9 @@ disassembler_usage (stream)
 #ifdef ARCH_i386
   print_i386_disassembler_options (stream);
 #endif
+#ifdef ARCH_avr32
+  print_avr32_disassembler_options (stream);
+#endif
 
   return;
 }
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -30,6 +30,7 @@ LIBIBERTY = ../libiberty/libiberty.a
 # Header files.
 HFILES = \
 	cgen-ops.h cgen-types.h \
+	avr32-asm.h avr32-opc.h \
 	fr30-desc.h fr30-opc.h \
 	frv-desc.h frv-opc.h \
 	h8500-opc.h \
@@ -63,6 +64,9 @@ CFILES = \
 	arc-ext.c \
 	arm-dis.c \
 	avr-dis.c \
+	avr32-asm.c \
+	avr32-dis.c \
+	avr32-opc.c \
 	bfin-dis.c \
 	cgen-asm.c \
 	cgen-bitset.c \
@@ -217,6 +221,9 @@ ALL_MACHINES = \
 	arc-ext.lo \
 	arm-dis.lo \
 	avr-dis.lo \
+	avr32-asm.lo \
+	avr32-dis.lo \
+	avr32-opc.lo \
 	bfin-dis.lo \
 	cgen-asm.lo \
 	cgen-bitset.lo \
@@ -674,6 +681,15 @@ avr-dis.lo: avr-dis.c sysdep.h config.h 
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h \
   opintl.h $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/avr.h
+avr32-asm.lo: avr32-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h opintl.h \
+  $(INCDIR)/xregex.h $(INCDIR)/xregex2.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
+avr32-dis.lo: avr32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
+  avr32-opc.h opintl.h
+avr32-opc.lo: avr32-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h $(INCDIR)/libiberty.h
 bfin-dis.lo: bfin-dis.c $(INCDIR)/opcode/bfin.h $(INCDIR)/dis-asm.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h
 cgen-asm.lo: cgen-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -2017,6 +2017,11 @@ enum bfd_architecture
 #define bfd_mach_avr4          4
 #define bfd_mach_avr5          5
 #define bfd_mach_avr6          6
+  bfd_arch_avr32,     /* Atmel AVR32 */
+#define bfd_mach_avr32_ap      7000
+#define bfd_mach_avr32_uc      3000
+#define bfd_mach_avr32_ucr1    3001
+#define bfd_mach_avr32_ucr2    3002
   bfd_arch_bfin,        /* ADI Blackfin */
 #define bfd_mach_bfin          1
   bfd_arch_cr16,       /* National Semiconductor CompactRISC (ie CR16). */
@@ -3758,6 +3763,88 @@ instructions  */
 instructions  */
   BFD_RELOC_AVR_6_ADIW,
 
+/* Difference between two labels: L2 - L1. The value of L1 is encoded
+as sym + addend, while the initial difference after assembly is
+inserted into the object file by the assembler.  */
+  BFD_RELOC_AVR32_DIFF32,
+  BFD_RELOC_AVR32_DIFF16,
+  BFD_RELOC_AVR32_DIFF8,
+
+/* Reference to a symbol through the Global Offset Table. The linker
+will allocate an entry for symbol in the GOT and insert the offset
+of this entry as the relocation value.  */
+  BFD_RELOC_AVR32_GOT32,
+  BFD_RELOC_AVR32_GOT16,
+  BFD_RELOC_AVR32_GOT8,
+
+/* Normal (non-pc-relative) code relocations. Alignment and signedness
+is indicated by the suffixes. S means signed, U means unsigned. W
+means word-aligned, H means halfword-aligned, neither means
+byte-aligned (no alignment.) SUB5 is the same relocation as 16S.  */
+  BFD_RELOC_AVR32_21S,
+  BFD_RELOC_AVR32_16U,
+  BFD_RELOC_AVR32_16S,
+  BFD_RELOC_AVR32_SUB5,
+  BFD_RELOC_AVR32_8S_EXT,
+  BFD_RELOC_AVR32_8S,
+  BFD_RELOC_AVR32_15S,
+
+/* PC-relative relocations are signed if neither 'U' nor 'S' is
+specified. However, we explicitly tack on a 'B' to indicate no
+alignment, to avoid confusion with data relocs. All of these resolve
+to sym + addend - offset, except the one with 'N' (negated) suffix.
+This particular one resolves to offset - sym - addend.  */
+  BFD_RELOC_AVR32_22H_PCREL,
+  BFD_RELOC_AVR32_18W_PCREL,
+  BFD_RELOC_AVR32_16B_PCREL,
+  BFD_RELOC_AVR32_16N_PCREL,
+  BFD_RELOC_AVR32_14UW_PCREL,
+  BFD_RELOC_AVR32_11H_PCREL,
+  BFD_RELOC_AVR32_10UW_PCREL,
+  BFD_RELOC_AVR32_9H_PCREL,
+  BFD_RELOC_AVR32_9UW_PCREL,
+
+/* Subtract the link-time address of the GOT from (symbol + addend)
+and insert the result.  */
+  BFD_RELOC_AVR32_GOTPC,
+
+/* Reference to a symbol through the GOT. The linker will allocate an
+entry for symbol in the GOT and insert the offset of this entry as
+the relocation value. addend must be zero. As usual, 'S' means
+signed, 'W' means word-aligned, etc.  */
+  BFD_RELOC_AVR32_GOTCALL,
+  BFD_RELOC_AVR32_LDA_GOT,
+  BFD_RELOC_AVR32_GOT21S,
+  BFD_RELOC_AVR32_GOT18SW,
+  BFD_RELOC_AVR32_GOT16S,
+
+/* 32-bit constant pool entry. I don't think 8- and 16-bit entries make
+a whole lot of sense.  */
+  BFD_RELOC_AVR32_32_CPENT,
+
+/* Constant pool references. Some of these relocations are signed,
+others are unsigned. It doesn't really matter, since the constant
+pool always comes after the code that references it.  */
+  BFD_RELOC_AVR32_CPCALL,
+  BFD_RELOC_AVR32_16_CP,
+  BFD_RELOC_AVR32_9W_CP,
+
+/* sym must be the absolute symbol. The addend specifies the alignment
+order, e.g. if addend is 2, the linker must add padding so that the
+next address is aligned to a 4-byte boundary.  */
+  BFD_RELOC_AVR32_ALIGN,
+
+/* Code relocations that will never make it to the output file.  */
+  BFD_RELOC_AVR32_14UW,
+  BFD_RELOC_AVR32_10UW,
+  BFD_RELOC_AVR32_10SW,
+  BFD_RELOC_AVR32_STHH_W,
+  BFD_RELOC_AVR32_7UW,
+  BFD_RELOC_AVR32_6S,
+  BFD_RELOC_AVR32_6UW,
+  BFD_RELOC_AVR32_4UH,
+  BFD_RELOC_AVR32_3U,
+
 /* Direct 12 bit.  */
   BFD_RELOC_390_12,
 
--- /dev/null
+++ b/bfd/bfd-in3.h
@@ -0,0 +1,5406 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
+   generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c", 
+   "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c", 
+   "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c", 
+   "linker.c" and "simple.c".
+   Run "make headers" in your build bfd/ to regenerate.  */
+
+/* Main header file for the bfd library -- portable access to object files.
+
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   Contributed by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef __BFD_H_SEEN__
+#define __BFD_H_SEEN__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ansidecl.h"
+#include "symcat.h"
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#ifndef SABER
+/* This hack is to avoid a problem with some strict ANSI C preprocessors.
+   The problem is, "32_" is not a valid preprocessing token, and we don't
+   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
+   cause the inner CONCAT2 macros to be evaluated first, producing
+   still-valid pp-tokens.  Then the final concatenation can be done.  */
+#undef CONCAT4
+#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
+#endif
+#endif
+
+/* This is a utility macro to handle the situation where the code
+   wants to place a constant string into the code, followed by a
+   comma and then the length of the string.  Doing this by hand
+   is error prone, so using this macro is safer.  The macro will
+   also safely handle the case where a NULL is passed as the arg.  */
+#define STRING_COMMA_LEN(STR) (STR), ((STR) ? sizeof (STR) - 1 : 0)
+/* Unfortunately it is not possible to use the STRING_COMMA_LEN macro
+   to create the arguments to another macro, since the preprocessor
+   will mis-count the number of arguments to the outer macro (by not
+   evaluating STRING_COMMA_LEN and so missing the comma).  This is a
+   problem for example when trying to use STRING_COMMA_LEN to build
+   the arguments to the strncmp() macro.  Hence this alternative
+   definition of strncmp is provided here.
+   
+   Note - these macros do NOT work if STR2 is not a constant string.  */
+#define CONST_STRNEQ(STR1,STR2) (strncmp ((STR1), (STR2), sizeof (STR2) - 1) == 0)
+  /* strcpy() can have a similar problem, but since we know we are
+     copying a constant string, we can use memcpy which will be faster
+     since there is no need to check for a NUL byte inside STR.  We
+     can also save time if we do not need to copy the terminating NUL.  */
+#define LITMEMCPY(DEST,STR2) memcpy ((DEST), (STR2), sizeof (STR2) - 1)
+#define LITSTRCPY(DEST,STR2) memcpy ((DEST), (STR2), sizeof (STR2))
+
+
+/* The word size used by BFD on the host.  This may be 64 with a 32
+   bit target if the host is 64 bit, or if other 64 bit targets have
+   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
+#define BFD_ARCH_SIZE 32
+
+/* The word size of the default bfd target.  */
+#define BFD_DEFAULT_TARGET_SIZE 32
+
+#define BFD_HOST_64BIT_LONG 0
+#define BFD_HOST_64BIT_LONG_LONG 0
+#define BFD_HOST_LONG_LONG 1
+#if 1
+#define BFD_HOST_64_BIT long long
+#define BFD_HOST_U_64_BIT unsigned long long
+typedef BFD_HOST_64_BIT bfd_int64_t;
+typedef BFD_HOST_U_64_BIT bfd_uint64_t;
+#endif
+
+#if BFD_ARCH_SIZE >= 64
+#define BFD64
+#endif
+
+#ifndef INLINE
+#if __GNUC__ >= 2
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+/* Declaring a type wide enough to hold a host long and a host pointer.  */
+#define BFD_HOSTPTR_T	unsigned long
+typedef BFD_HOSTPTR_T bfd_hostptr_t;
+
+/* Forward declaration.  */
+typedef struct bfd bfd;
+
+/* Boolean type used in bfd.  Too many systems define their own
+   versions of "boolean" for us to safely typedef a "boolean" of
+   our own.  Using an enum for "bfd_boolean" has its own set of
+   problems, with strange looking casts required to avoid warnings
+   on some older compilers.  Thus we just use an int.
+
+   General rule: Functions which are bfd_boolean return TRUE on
+   success and FALSE on failure (unless they're a predicate).  */
+
+typedef int bfd_boolean;
+#undef FALSE
+#undef TRUE
+#define FALSE 0
+#define TRUE 1
+
+#ifdef BFD64
+
+#ifndef BFD_HOST_64_BIT
+ #error No 64 bit integer type available
+#endif /* ! defined (BFD_HOST_64_BIT) */
+
+typedef BFD_HOST_U_64_BIT bfd_vma;
+typedef BFD_HOST_64_BIT bfd_signed_vma;
+typedef BFD_HOST_U_64_BIT bfd_size_type;
+typedef BFD_HOST_U_64_BIT symvalue;
+
+#ifndef fprintf_vma
+#if BFD_HOST_64BIT_LONG
+#define sprintf_vma(s,x) sprintf (s, "%016lx", x)
+#define fprintf_vma(f,x) fprintf (f, "%016lx", x)
+#elif BFD_HOST_64BIT_LONG_LONG
+#define sprintf_vma(s,x) sprintf (s, "%016llx", x)
+#define fprintf_vma(f,x) fprintf (f, "%016llx", x)
+#else
+#define _bfd_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
+#define _bfd_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
+#define fprintf_vma(s,x) \
+  fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#define sprintf_vma(s,x) \
+  sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#endif
+#endif
+
+#else /* not BFD64  */
+
+/* Represent a target address.  Also used as a generic unsigned type
+   which is guaranteed to be big enough to hold any arithmetic types
+   we need to deal with.  */
+typedef unsigned long bfd_vma;
+
+/* A generic signed type which is guaranteed to be big enough to hold any
+   arithmetic types we need to deal with.  Can be assumed to be compatible
+   with bfd_vma in the same way that signed and unsigned ints are compatible
+   (as parameters, in assignment, etc).  */
+typedef long bfd_signed_vma;
+
+typedef unsigned long symvalue;
+typedef unsigned long bfd_size_type;
+
+/* Print a bfd_vma x on stream s.  */
+#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
+#define sprintf_vma(s,x) sprintf (s, "%08lx", x)
+
+#endif /* not BFD64  */
+
+#define HALF_BFD_SIZE_TYPE \
+  (((bfd_size_type) 1) << (8 * sizeof (bfd_size_type) / 2))
+
+#ifndef BFD_HOST_64_BIT
+/* Fall back on a 32 bit type.  The idea is to make these types always
+   available for function return types, but in the case that
+   BFD_HOST_64_BIT is undefined such a function should abort or
+   otherwise signal an error.  */
+typedef bfd_signed_vma bfd_int64_t;
+typedef bfd_vma bfd_uint64_t;
+#endif
+
+/* An offset into a file.  BFD always uses the largest possible offset
+   based on the build time availability of fseek, fseeko, or fseeko64.  */
+typedef BFD_HOST_64_BIT file_ptr;
+typedef unsigned BFD_HOST_64_BIT ufile_ptr;
+
+extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
+extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);
+
+#define printf_vma(x) fprintf_vma(stdout,x)
+#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)
+
+typedef unsigned int flagword;	/* 32 bits of flags */
+typedef unsigned char bfd_byte;
+
+/* File formats.  */
+
+typedef enum bfd_format
+{
+  bfd_unknown = 0,	/* File format is unknown.  */
+  bfd_object,		/* Linker/assembler/compiler output.  */
+  bfd_archive,		/* Object archive file.  */
+  bfd_core,		/* Core dump.  */
+  bfd_type_end		/* Marks the end; don't use it!  */
+}
+bfd_format;
+
+/* Values that may appear in the flags field of a BFD.  These also
+   appear in the object_flags field of the bfd_target structure, where
+   they indicate the set of flags used by that backend (not all flags
+   are meaningful for all object file formats) (FIXME: at the moment,
+   the object_flags values have mostly just been copied from backend
+   to another, and are not necessarily correct).  */
+
+/* No flags.  */
+#define BFD_NO_FLAGS   	0x00
+
+/* BFD contains relocation entries.  */
+#define HAS_RELOC   	0x01
+
+/* BFD is directly executable.  */
+#define EXEC_P      	0x02
+
+/* BFD has line number information (basically used for F_LNNO in a
+   COFF header).  */
+#define HAS_LINENO  	0x04
+
+/* BFD has debugging information.  */
+#define HAS_DEBUG   	0x08
+
+/* BFD has symbols.  */
+#define HAS_SYMS    	0x10
+
+/* BFD has local symbols (basically used for F_LSYMS in a COFF
+   header).  */
+#define HAS_LOCALS  	0x20
+
+/* BFD is a dynamic object.  */
+#define DYNAMIC     	0x40
+
+/* Text section is write protected (if D_PAGED is not set, this is
+   like an a.out NMAGIC file) (the linker sets this by default, but
+   clears it for -r or -N).  */
+#define WP_TEXT     	0x80
+
+/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
+   linker sets this by default, but clears it for -r or -n or -N).  */
+#define D_PAGED     	0x100
+
+/* BFD is relaxable (this means that bfd_relax_section may be able to
+   do something) (sometimes bfd_relax_section can do something even if
+   this is not set).  */
+#define BFD_IS_RELAXABLE 0x200
+
+/* This may be set before writing out a BFD to request using a
+   traditional format.  For example, this is used to request that when
+   writing out an a.out object the symbols not be hashed to eliminate
+   duplicates.  */
+#define BFD_TRADITIONAL_FORMAT 0x400
+
+/* This flag indicates that the BFD contents are actually cached in
+   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
+#define BFD_IN_MEMORY 0x800
+
+/* The sections in this BFD specify a memory page.  */
+#define HAS_LOAD_PAGE 0x1000
+
+/* This BFD has been created by the linker and doesn't correspond
+   to any input file.  */
+#define BFD_LINKER_CREATED 0x2000
+
+/* Symbols and relocation.  */
+
+/* A count of carsyms (canonical archive symbols).  */
+typedef unsigned long symindex;
+
+/* How to perform a relocation.  */
+typedef const struct reloc_howto_struct reloc_howto_type;
+
+#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)
+
+/* General purpose part of a symbol X;
+   target specific parts are in libcoff.h, libaout.h, etc.  */
+
+#define bfd_get_section(x) ((x)->section)
+#define bfd_get_output_section(x) ((x)->section->output_section)
+#define bfd_set_section(x,y) ((x)->section) = (y)
+#define bfd_asymbol_base(x) ((x)->section->vma)
+#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
+#define bfd_asymbol_name(x) ((x)->name)
+/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
+#define bfd_asymbol_bfd(x) ((x)->the_bfd)
+#define bfd_asymbol_flavour(x) (bfd_asymbol_bfd(x)->xvec->flavour)
+
+/* A canonical archive symbol.  */
+/* This is a type pun with struct ranlib on purpose!  */
+typedef struct carsym
+{
+  char *name;
+  file_ptr file_offset;	/* Look here to find the file.  */
+}
+carsym;			/* To make these you call a carsymogen.  */
+
+/* Used in generating armaps (archive tables of contents).
+   Perhaps just a forward definition would do?  */
+struct orl 			/* Output ranlib.  */
+{
+  char **name;		/* Symbol name.  */
+  union
+  {
+    file_ptr pos;
+    bfd *abfd;
+  } u;			/* bfd* or file position.  */
+  int namidx;		/* Index into string table.  */
+};
+
+/* Linenumber stuff.  */
+typedef struct lineno_cache_entry
+{
+  unsigned int line_number;	/* Linenumber from start of function.  */
+  union
+  {
+    struct bfd_symbol *sym;	/* Function name.  */
+    bfd_vma offset;	    		/* Offset into section.  */
+  } u;
+}
+alent;
+
+/* Object and core file sections.  */
+
+#define	align_power(addr, align)	\
+  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
+
+typedef struct bfd_section *sec_ptr;
+
+#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
+#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
+#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
+#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
+#define bfd_section_name(bfd, ptr) ((ptr)->name)
+#define bfd_section_size(bfd, ptr) ((ptr)->size)
+#define bfd_get_section_size(ptr) ((ptr)->size)
+#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
+#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
+#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
+#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
+#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)
+
+#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)
+
+#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
+#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
+#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)
+/* Find the address one past the end of SEC.  */
+#define bfd_get_section_limit(bfd, sec) \
+  (((sec)->rawsize ? (sec)->rawsize : (sec)->size) \
+   / bfd_octets_per_byte (bfd))
+
+/* Return TRUE if section has been discarded.  */
+#define elf_discarded_section(sec)				\
+  (!bfd_is_abs_section (sec)					\
+   && bfd_is_abs_section ((sec)->output_section)		\
+   && (sec)->sec_info_type != ELF_INFO_TYPE_MERGE		\
+   && (sec)->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
+
+/* Forward define.  */
+struct stat;
+
+typedef enum bfd_print_symbol
+{
+  bfd_print_symbol_name,
+  bfd_print_symbol_more,
+  bfd_print_symbol_all
+} bfd_print_symbol_type;
+
+/* Information about a symbol that nm needs.  */
+
+typedef struct _symbol_info
+{
+  symvalue value;
+  char type;
+  const char *name;            /* Symbol name.  */
+  unsigned char stab_type;     /* Stab type.  */
+  char stab_other;             /* Stab other.  */
+  short stab_desc;             /* Stab desc.  */
+  const char *stab_name;       /* String for stab type.  */
+} symbol_info;
+
+/* Get the name of a stabs type code.  */
+
+extern const char *bfd_get_stab_name (int);
+
+/* Hash table routines.  There is no way to free up a hash table.  */
+
+/* An element in the hash table.  Most uses will actually use a larger
+   structure, and an instance of this will be the first field.  */
+
+struct bfd_hash_entry
+{
+  /* Next entry for this hash code.  */
+  struct bfd_hash_entry *next;
+  /* String being hashed.  */
+  const char *string;
+  /* Hash code.  This is the full hash code, not the index into the
+     table.  */
+  unsigned long hash;
+};
+
+/* A hash table.  */
+
+struct bfd_hash_table
+{
+  /* The hash array.  */
+  struct bfd_hash_entry **table;
+  /* A function used to create new elements in the hash table.  The
+     first entry is itself a pointer to an element.  When this
+     function is first invoked, this pointer will be NULL.  However,
+     having the pointer permits a hierarchy of method functions to be
+     built each of which calls the function in the superclass.  Thus
+     each function should be written to allocate a new block of memory
+     only if the argument is NULL.  */
+  struct bfd_hash_entry *(*newfunc)
+    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+   /* An objalloc for this hash table.  This is a struct objalloc *,
+     but we use void * to avoid requiring the inclusion of objalloc.h.  */
+  void *memory;
+  /* The number of slots in the hash table.  */
+  unsigned int size;
+  /* The number of entries in the hash table.  */
+  unsigned int count;
+  /* The size of elements.  */
+  unsigned int entsize;
+  /* If non-zero, don't grow the hash table.  */
+  unsigned int frozen:1;
+};
+
+/* Initialize a hash table.  */
+extern bfd_boolean bfd_hash_table_init
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int);
+
+/* Initialize a hash table specifying a size.  */
+extern bfd_boolean bfd_hash_table_init_n
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int, unsigned int);
+
+/* Free up a hash table.  */
+extern void bfd_hash_table_free
+  (struct bfd_hash_table *);
+
+/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
+   will be created for this string if one does not already exist.  The
+   COPY argument must be TRUE if this routine should copy the string
+   into newly allocated memory when adding an entry.  */
+extern struct bfd_hash_entry *bfd_hash_lookup
+  (struct bfd_hash_table *, const char *, bfd_boolean create,
+   bfd_boolean copy);
+
+/* Replace an entry in a hash table.  */
+extern void bfd_hash_replace
+  (struct bfd_hash_table *, struct bfd_hash_entry *old,
+   struct bfd_hash_entry *nw);
+
+/* Base method for creating a hash table entry.  */
+extern struct bfd_hash_entry *bfd_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+
+/* Grab some space for a hash table entry.  */
+extern void *bfd_hash_allocate
+  (struct bfd_hash_table *, unsigned int);
+
+/* Traverse a hash table in a random order, calling a function on each
+   element.  If the function returns FALSE, the traversal stops.  The
+   INFO argument is passed to the function.  */
+extern void bfd_hash_traverse
+  (struct bfd_hash_table *,
+   bfd_boolean (*) (struct bfd_hash_entry *, void *),
+   void *info);
+
+/* Allows the default size of a hash table to be configured. New hash
+   tables allocated using bfd_hash_table_init will be created with
+   this size.  */
+extern void bfd_hash_set_default_size (bfd_size_type);
+
+/* This structure is used to keep track of stabs in sections
+   information while linking.  */
+
+struct stab_info
+{
+  /* A hash table used to hold stabs strings.  */
+  struct bfd_strtab_hash *strings;
+  /* The header file hash table.  */
+  struct bfd_hash_table includes;
+  /* The first .stabstr section.  */
+  struct bfd_section *stabstr;
+};
+
+#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table
+
+/* User program access to BFD facilities.  */
+
+/* Direct I/O routines, for programs which know more about the object
+   file than BFD does.  Use higher level routines if possible.  */
+
+extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
+extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
+extern int bfd_seek (bfd *, file_ptr, int);
+extern file_ptr bfd_tell (bfd *);
+extern int bfd_flush (bfd *);
+extern int bfd_stat (bfd *, struct stat *);
+
+/* Deprecated old routines.  */
+#if __GNUC__
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#else
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#endif
+extern void warn_deprecated (const char *, const char *, int, const char *);
+
+/* Cast from const char * to char * so that caller can assign to
+   a char * without a warning.  */
+#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
+#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
+#define bfd_get_format(abfd) ((abfd)->format)
+#define bfd_get_target(abfd) ((abfd)->xvec->name)
+#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
+#define bfd_family_coff(abfd) \
+  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
+   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
+#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
+#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_header_big_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
+#define bfd_header_little_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_get_file_flags(abfd) ((abfd)->flags)
+#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
+#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
+#define bfd_my_archive(abfd) ((abfd)->my_archive)
+#define bfd_has_map(abfd) ((abfd)->has_armap)
+
+#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
+#define bfd_usrdata(abfd) ((abfd)->usrdata)
+
+#define bfd_get_start_address(abfd) ((abfd)->start_address)
+#define bfd_get_symcount(abfd) ((abfd)->symcount)
+#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
+#define bfd_count_sections(abfd) ((abfd)->section_count)
+
+#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)
+
+#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)
+
+#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)
+
+extern bfd_boolean bfd_cache_close
+  (bfd *abfd);
+/* NB: This declaration should match the autogenerated one in libbfd.h.  */
+
+extern bfd_boolean bfd_cache_close_all (void);
+
+extern bfd_boolean bfd_record_phdr
+  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
+   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
+
+/* Byte swapping routines.  */
+
+bfd_uint64_t bfd_getb64 (const void *);
+bfd_uint64_t bfd_getl64 (const void *);
+bfd_int64_t bfd_getb_signed_64 (const void *);
+bfd_int64_t bfd_getl_signed_64 (const void *);
+bfd_vma bfd_getb32 (const void *);
+bfd_vma bfd_getl32 (const void *);
+bfd_signed_vma bfd_getb_signed_32 (const void *);
+bfd_signed_vma bfd_getl_signed_32 (const void *);
+bfd_vma bfd_getb16 (const void *);
+bfd_vma bfd_getl16 (const void *);
+bfd_signed_vma bfd_getb_signed_16 (const void *);
+bfd_signed_vma bfd_getl_signed_16 (const void *);
+void bfd_putb64 (bfd_uint64_t, void *);
+void bfd_putl64 (bfd_uint64_t, void *);
+void bfd_putb32 (bfd_vma, void *);
+void bfd_putl32 (bfd_vma, void *);
+void bfd_putb16 (bfd_vma, void *);
+void bfd_putl16 (bfd_vma, void *);
+
+/* Byte swapping routines which take size and endiannes as arguments.  */
+
+bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
+void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
+
+extern bfd_boolean bfd_section_already_linked_table_init (void);
+extern void bfd_section_already_linked_table_free (void);
+
+/* Externally visible ECOFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct ecoff_debug_info;
+struct ecoff_debug_swap;
+struct ecoff_extr;
+struct bfd_symbol;
+struct bfd_link_info;
+struct bfd_link_hash_entry;
+struct bfd_elf_version_tree;
+#endif
+extern bfd_vma bfd_ecoff_get_gp_value
+  (bfd * abfd);
+extern bfd_boolean bfd_ecoff_set_gp_value
+  (bfd *abfd, bfd_vma gp_value);
+extern bfd_boolean bfd_ecoff_set_regmasks
+  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
+   unsigned long *cprmask);
+extern void *bfd_ecoff_debug_init
+  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern void bfd_ecoff_debug_free
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct ecoff_debug_info *input_debug,
+   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate_other
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_externals
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
+   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
+   void (*set_index) (struct bfd_symbol *, bfd_size_type));
+extern bfd_boolean bfd_ecoff_debug_one_external
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, const char *name,
+   struct ecoff_extr *esym);
+extern bfd_size_type bfd_ecoff_debug_size
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap);
+extern bfd_boolean bfd_ecoff_write_debug
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, file_ptr where);
+extern bfd_boolean bfd_ecoff_write_accumulated_debug
+  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap,
+   struct bfd_link_info *info, file_ptr where);
+
+/* Externally visible ELF routines.  */
+
+struct bfd_link_needed_list
+{
+  struct bfd_link_needed_list *next;
+  bfd *by;
+  const char *name;
+};
+
+enum dynamic_lib_link_class {
+  DYN_NORMAL = 0,
+  DYN_AS_NEEDED = 1,
+  DYN_DT_NEEDED = 2,
+  DYN_NO_ADD_NEEDED = 4,
+  DYN_NO_NEEDED = 8
+};
+
+enum notice_asneeded_action {
+  notice_as_needed,
+  notice_not_needed,
+  notice_needed
+};
+
+extern bfd_boolean bfd_elf_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
+   bfd_boolean);
+extern struct bfd_link_needed_list *bfd_elf_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_get_bfd_needed_list
+  (bfd *, struct bfd_link_needed_list **);
+extern bfd_boolean bfd_elf_size_dynamic_sections
+  (bfd *, const char *, const char *, const char *, const char * const *,
+   struct bfd_link_info *, struct bfd_section **,
+   struct bfd_elf_version_tree *);
+extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
+  (bfd *, struct bfd_link_info *);
+extern void bfd_elf_set_dt_needed_name
+  (bfd *, const char *);
+extern const char *bfd_elf_get_dt_soname
+  (bfd *);
+extern void bfd_elf_set_dyn_lib_class
+  (bfd *, enum dynamic_lib_link_class);
+extern int bfd_elf_get_dyn_lib_class
+  (bfd *);
+extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_discard_info
+  (bfd *, struct bfd_link_info *);
+extern unsigned int _bfd_elf_default_action_discarded
+  (struct bfd_section *);
+
+/* Return an upper bound on the number of bytes required to store a
+   copy of ABFD's program header table entries.  Return -1 if an error
+   occurs; bfd_get_error will return an appropriate code.  */
+extern long bfd_get_elf_phdr_upper_bound
+  (bfd *abfd);
+
+/* Copy ABFD's program header table entries to *PHDRS.  The entries
+   will be stored as an array of Elf_Internal_Phdr structures, as
+   defined in include/elf/internal.h.  To find out how large the
+   buffer needs to be, call bfd_get_elf_phdr_upper_bound.
+
+   Return the number of program header table entries read, or -1 if an
+   error occurs; bfd_get_error will return an appropriate code.  */
+extern int bfd_get_elf_phdrs
+  (bfd *abfd, void *phdrs);
+
+/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
+   reconstruct an ELF file by reading the segments out of remote memory
+   based on the ELF file header at EHDR_VMA and the ELF program headers it
+   points to.  If not null, *LOADBASEP is filled in with the difference
+   between the VMAs from which the segments were read, and the VMAs the
+   file headers (and hence BFD's idea of each section's VMA) put them at.
+
+   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
+   remote memory at target address VMA into the local buffer at MYADDR; it
+   should return zero on success or an `errno' code on failure.  TEMPL must
+   be a BFD for an ELF target with the word size and byte order found in
+   the remote memory.  */
+extern bfd *bfd_elf_bfd_from_remote_memory
+  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
+   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr, int len));
+
+/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
+extern int bfd_get_arch_size
+  (bfd *);
+
+/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
+extern int bfd_get_sign_extend_vma
+  (bfd *);
+
+extern struct bfd_section *_bfd_elf_tls_setup
+  (bfd *, struct bfd_link_info *);
+
+extern void _bfd_fix_excluded_sec_syms
+  (bfd *, struct bfd_link_info *);
+
+extern unsigned bfd_m68k_mach_to_features (int);
+
+extern int bfd_m68k_features_to_mach (unsigned);
+
+extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+/* SunOS shared library support routines for the linker.  */
+
+extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sunos_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_sunos_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, struct bfd_section **,
+   struct bfd_section **, struct bfd_section **);
+
+/* Linux shared library support routines for the linker.  */
+
+extern bfd_boolean bfd_i386linux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_m68klinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sparclinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+
+/* mmap hacks */
+
+struct _bfd_window_internal;
+typedef struct _bfd_window_internal bfd_window_internal;
+
+typedef struct _bfd_window
+{
+  /* What the user asked for.  */
+  void *data;
+  bfd_size_type size;
+  /* The actual window used by BFD.  Small user-requested read-only
+     regions sharing a page may share a single window into the object
+     file.  Read-write versions shouldn't until I've fixed things to
+     keep track of which portions have been claimed by the
+     application; don't want to give the same region back when the
+     application wants two writable copies!  */
+  struct _bfd_window_internal *i;
+}
+bfd_window;
+
+extern void bfd_init_window
+  (bfd_window *);
+extern void bfd_free_window
+  (bfd_window *);
+extern bfd_boolean bfd_get_file_window
+  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);
+
+/* XCOFF support routines for the linker.  */
+
+extern bfd_boolean bfd_xcoff_link_record_set
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
+extern bfd_boolean bfd_xcoff_import_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
+   const char *, const char *, const char *, unsigned int);
+extern bfd_boolean bfd_xcoff_export_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
+extern bfd_boolean bfd_xcoff_link_count_reloc
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, const char *, const char *,
+   unsigned long, unsigned long, unsigned long, bfd_boolean,
+   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
+extern bfd_boolean bfd_xcoff_link_generate_rtinit
+  (bfd *, const char *, const char *, bfd_boolean);
+
+/* XCOFF support routines for ar.  */
+extern bfd_boolean bfd_xcoff_ar_archive_set_magic
+  (bfd *, char *);
+
+/* Externally visible COFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct internal_syment;
+union internal_auxent;
+#endif
+
+extern bfd_boolean bfd_coff_get_syment
+  (bfd *, struct bfd_symbol *, struct internal_syment *);
+
+extern bfd_boolean bfd_coff_get_auxent
+  (bfd *, struct bfd_symbol *, int, union internal_auxent *);
+
+extern bfd_boolean bfd_coff_set_symbol_class
+  (bfd *, struct bfd_symbol *, unsigned int);
+
+extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
+
+/* ARM VFP11 erratum workaround support.  */
+typedef enum
+{
+  BFD_ARM_VFP11_FIX_DEFAULT,
+  BFD_ARM_VFP11_FIX_NONE,
+  BFD_ARM_VFP11_FIX_SCALAR,
+  BFD_ARM_VFP11_FIX_VECTOR
+} bfd_arm_vfp11_fix;
+
+extern void bfd_elf32_arm_init_maps
+  (bfd *);
+
+extern void bfd_elf32_arm_set_vfp11_fix
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_vfp11_fix_veneer_locations
+  (bfd *, struct bfd_link_info *);
+
+/* ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* PE ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_pe_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *);
+
+void bfd_elf32_arm_set_target_relocs
+  (bfd *, struct bfd_link_info *, int, char *, int, int, bfd_arm_vfp11_fix,
+   int, int);
+
+extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM mapping symbol support */
+#define BFD_ARM_SPECIAL_SYM_TYPE_MAP	(1 << 0)
+#define BFD_ARM_SPECIAL_SYM_TYPE_TAG	(1 << 1)
+#define BFD_ARM_SPECIAL_SYM_TYPE_OTHER  (1 << 2)
+#define BFD_ARM_SPECIAL_SYM_TYPE_ANY	(~0)
+extern bfd_boolean bfd_is_arm_special_symbol_name
+  (const char * name, int type);
+
+extern void bfd_elf32_arm_set_byteswap_code (struct bfd_link_info *, int);
+
+/* ARM Note section processing.  */
+extern bfd_boolean bfd_arm_merge_machines
+  (bfd *, bfd *);
+
+extern bfd_boolean bfd_arm_update_notes
+  (bfd *, const char *);
+
+extern unsigned int bfd_arm_get_mach_from_notes
+  (bfd *, const char *);
+
+/* TI COFF load page support.  */
+extern void bfd_ticoff_set_section_load_page
+  (struct bfd_section *, int);
+
+extern int bfd_ticoff_get_section_load_page
+  (struct bfd_section *);
+
+/* H8/300 functions.  */
+extern bfd_vma bfd_h8300_pad_address
+  (bfd *, bfd_vma);
+
+/* IA64 Itanium code generation.  Called from linker.  */
+extern void bfd_elf32_ia64_after_parse
+  (int);
+
+extern void bfd_elf64_ia64_after_parse
+  (int);
+
+/* This structure is used for a comdat section, as in PE.  A comdat
+   section is associated with a particular symbol.  When the linker
+   sees a comdat section, it keeps only one of the sections with a
+   given name and associated with a given symbol.  */
+
+struct coff_comdat_info
+{
+  /* The name of the symbol associated with a comdat section.  */
+  const char *name;
+
+  /* The local symbol table index of the symbol associated with a
+     comdat section.  This is only meaningful to the object file format
+     specific code; it is not an index into the list returned by
+     bfd_canonicalize_symtab.  */
+  long symbol;
+};
+
+extern struct coff_comdat_info *bfd_coff_get_comdat_section
+  (bfd *, struct bfd_section *);
+
+/* Extracted from init.c.  */
+void bfd_init (void);
+
+/* Extracted from opncls.c.  */
+bfd *bfd_fopen (const char *filename, const char *target,
+    const char *mode, int fd);
+
+bfd *bfd_openr (const char *filename, const char *target);
+
+bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
+
+bfd *bfd_openstreamr (const char *, const char *, void *);
+
+bfd *bfd_openr_iovec (const char *filename, const char *target,
+    void *(*open) (struct bfd *nbfd,
+    void *open_closure),
+    void *open_closure,
+    file_ptr (*pread) (struct bfd *nbfd,
+    void *stream,
+    void *buf,
+    file_ptr nbytes,
+    file_ptr offset),
+    int (*close) (struct bfd *nbfd,
+    void *stream),
+    int (*stat) (struct bfd *abfd,
+    void *stream,
+    struct stat *sb));
+
+bfd *bfd_openw (const char *filename, const char *target);
+
+bfd_boolean bfd_close (bfd *abfd);
+
+bfd_boolean bfd_close_all_done (bfd *);
+
+bfd *bfd_create (const char *filename, bfd *templ);
+
+bfd_boolean bfd_make_writable (bfd *abfd);
+
+bfd_boolean bfd_make_readable (bfd *abfd);
+
+unsigned long bfd_calc_gnu_debuglink_crc32
+   (unsigned long crc, const unsigned char *buf, bfd_size_type len);
+
+char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
+
+struct bfd_section *bfd_create_gnu_debuglink_section
+   (bfd *abfd, const char *filename);
+
+bfd_boolean bfd_fill_in_gnu_debuglink_section
+   (bfd *abfd, struct bfd_section *sect, const char *filename);
+
+/* Extracted from libbfd.c.  */
+
+/* Byte swapping macros for user section data.  */
+
+#define bfd_put_8(abfd, val, ptr) \
+  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
+#define bfd_put_signed_8 \
+  bfd_put_8
+#define bfd_get_8(abfd, ptr) \
+  (*(unsigned char *) (ptr) & 0xff)
+#define bfd_get_signed_8(abfd, ptr) \
+  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
+
+#define bfd_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
+#define bfd_put_signed_16 \
+  bfd_put_16
+#define bfd_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx16, (ptr))
+#define bfd_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
+
+#define bfd_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
+#define bfd_put_signed_32 \
+  bfd_put_32
+#define bfd_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx32, (ptr))
+#define bfd_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
+
+#define bfd_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
+#define bfd_put_signed_64 \
+  bfd_put_64
+#define bfd_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx64, (ptr))
+#define bfd_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
+
+#define bfd_get(bits, abfd, ptr)                       \
+  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
+   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
+   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
+   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
+   : (abort (), (bfd_vma) - 1))
+
+#define bfd_put(bits, abfd, val, ptr)                  \
+  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
+   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
+   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
+   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
+   : (abort (), (void) 0))
+
+
+/* Byte swapping macros for file header data.  */
+
+#define bfd_h_put_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_put_signed_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_get_8(abfd, ptr) \
+  bfd_get_8 (abfd, ptr)
+#define bfd_h_get_signed_8(abfd, ptr) \
+  bfd_get_signed_8 (abfd, ptr)
+
+#define bfd_h_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
+#define bfd_h_put_signed_16 \
+  bfd_h_put_16
+#define bfd_h_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx16, (ptr))
+#define bfd_h_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
+
+#define bfd_h_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
+#define bfd_h_put_signed_32 \
+  bfd_h_put_32
+#define bfd_h_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx32, (ptr))
+#define bfd_h_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
+
+#define bfd_h_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
+#define bfd_h_put_signed_64 \
+  bfd_h_put_64
+#define bfd_h_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx64, (ptr))
+#define bfd_h_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
+
+/* Aliases for the above, which should eventually go away.  */
+
+#define H_PUT_64  bfd_h_put_64
+#define H_PUT_32  bfd_h_put_32
+#define H_PUT_16  bfd_h_put_16
+#define H_PUT_8   bfd_h_put_8
+#define H_PUT_S64 bfd_h_put_signed_64
+#define H_PUT_S32 bfd_h_put_signed_32
+#define H_PUT_S16 bfd_h_put_signed_16
+#define H_PUT_S8  bfd_h_put_signed_8
+#define H_GET_64  bfd_h_get_64
+#define H_GET_32  bfd_h_get_32
+#define H_GET_16  bfd_h_get_16
+#define H_GET_8   bfd_h_get_8
+#define H_GET_S64 bfd_h_get_signed_64
+#define H_GET_S32 bfd_h_get_signed_32
+#define H_GET_S16 bfd_h_get_signed_16
+#define H_GET_S8  bfd_h_get_signed_8
+
+
+/* Extracted from bfdio.c.  */
+long bfd_get_mtime (bfd *abfd);
+
+file_ptr bfd_get_size (bfd *abfd);
+
+/* Extracted from bfdwin.c.  */
+/* Extracted from section.c.  */
+typedef struct bfd_section
+{
+  /* The name of the section; the name isn't a copy, the pointer is
+     the same as that passed to bfd_make_section.  */
+  const char *name;
+
+  /* A unique sequence number.  */
+  int id;
+
+  /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
+  int index;
+
+  /* The next section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *next;
+
+  /* The previous section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *prev;
+
+  /* The field flags contains attributes of the section. Some
+     flags are read in from the object file, and some are
+     synthesized from other information.  */
+  flagword flags;
+
+#define SEC_NO_FLAGS   0x000
+
+  /* Tells the OS to allocate space for this section when loading.
+     This is clear for a section containing debug information only.  */
+#define SEC_ALLOC      0x001
+
+  /* Tells the OS to load the section from the file when loading.
+     This is clear for a .bss section.  */
+#define SEC_LOAD       0x002
+
+  /* The section contains data still to be relocated, so there is
+     some relocation information too.  */
+#define SEC_RELOC      0x004
+
+  /* A signal to the OS that the section contains read only data.  */
+#define SEC_READONLY   0x008
+
+  /* The section contains code only.  */
+#define SEC_CODE       0x010
+
+  /* The section contains data only.  */
+#define SEC_DATA       0x020
+
+  /* The section will reside in ROM.  */
+#define SEC_ROM        0x040
+
+  /* The section contains constructor information. This section
+     type is used by the linker to create lists of constructors and
+     destructors used by <<g++>>. When a back end sees a symbol
+     which should be used in a constructor list, it creates a new
+     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
+     the symbol to it, and builds a relocation. To build the lists
+     of constructors, all the linker has to do is catenate all the
+     sections called <<__CTOR_LIST__>> and relocate the data
+     contained within - exactly the operations it would peform on
+     standard data.  */
+#define SEC_CONSTRUCTOR 0x080
+
+  /* The section has contents - a data section could be
+     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
+     <<SEC_HAS_CONTENTS>>  */
+#define SEC_HAS_CONTENTS 0x100
+
+  /* An instruction to the linker to not output the section
+     even if it has information which would normally be written.  */
+#define SEC_NEVER_LOAD 0x200
+
+  /* The section contains thread local data.  */
+#define SEC_THREAD_LOCAL 0x400
+
+  /* The section has GOT references.  This flag is only for the
+     linker, and is currently only used by the elf32-hppa back end.
+     It will be set if global offset table references were detected
+     in this section, which indicate to the linker that the section
+     contains PIC code, and must be handled specially when doing a
+     static link.  */
+#define SEC_HAS_GOT_REF 0x800
+
+  /* The section contains common symbols (symbols may be defined
+     multiple times, the value of a symbol is the amount of
+     space it requires, and the largest symbol value is the one
+     used).  Most targets have exactly one of these (which we
+     translate to bfd_com_section_ptr), but ECOFF has two.  */
+#define SEC_IS_COMMON 0x1000
+
+  /* The section contains only debugging information.  For
+     example, this is set for ELF .debug and .stab sections.
+     strip tests this flag to see if a section can be
+     discarded.  */
+#define SEC_DEBUGGING 0x2000
+
+  /* The contents of this section are held in memory pointed to
+     by the contents field.  This is checked by bfd_get_section_contents,
+     and the data is retrieved from memory if appropriate.  */
+#define SEC_IN_MEMORY 0x4000
+
+  /* The contents of this section are to be excluded by the
+     linker for executable and shared objects unless those
+     objects are to be further relocated.  */
+#define SEC_EXCLUDE 0x8000
+
+  /* The contents of this section are to be sorted based on the sum of
+     the symbol and addend values specified by the associated relocation
+     entries.  Entries without associated relocation entries will be
+     appended to the end of the section in an unspecified order.  */
+#define SEC_SORT_ENTRIES 0x10000
+
+  /* When linking, duplicate sections of the same name should be
+     discarded, rather than being combined into a single section as
+     is usually done.  This is similar to how common symbols are
+     handled.  See SEC_LINK_DUPLICATES below.  */
+#define SEC_LINK_ONCE 0x20000
+
+  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
+     should handle duplicate sections.  */
+#define SEC_LINK_DUPLICATES 0x40000
+
+  /* This value for SEC_LINK_DUPLICATES means that duplicate
+     sections with the same name should simply be discarded.  */
+#define SEC_LINK_DUPLICATES_DISCARD 0x0
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if there are any duplicate sections, although
+     it should still only link one copy.  */
+#define SEC_LINK_DUPLICATES_ONE_ONLY 0x80000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections are a different size.  */
+#define SEC_LINK_DUPLICATES_SAME_SIZE 0x100000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections contain different
+     contents.  */
+#define SEC_LINK_DUPLICATES_SAME_CONTENTS \
+  (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)
+
+  /* This section was created by the linker as part of dynamic
+     relocation or other arcane processing.  It is skipped when
+     going through the first-pass output, trusting that someone
+     else up the line will take care of it later.  */
+#define SEC_LINKER_CREATED 0x200000
+
+  /* This section should not be subject to garbage collection.
+     Also set to inform the linker that this section should not be
+     listed in the link map as discarded.  */
+#define SEC_KEEP 0x400000
+
+  /* This section contains "short" data, and should be placed
+     "near" the GP.  */
+#define SEC_SMALL_DATA 0x800000
+
+  /* Attempt to merge identical entities in the section.
+     Entity size is given in the entsize field.  */
+#define SEC_MERGE 0x1000000
+
+  /* If given with SEC_MERGE, entities to merge are zero terminated
+     strings where entsize specifies character size instead of fixed
+     size entries.  */
+#define SEC_STRINGS 0x2000000
+
+  /* This section contains data about section groups.  */
+#define SEC_GROUP 0x4000000
+
+  /* The section is a COFF shared library section.  This flag is
+     only for the linker.  If this type of section appears in
+     the input file, the linker must copy it to the output file
+     without changing the vma or size.  FIXME: Although this
+     was originally intended to be general, it really is COFF
+     specific (and the flag was renamed to indicate this).  It
+     might be cleaner to have some more general mechanism to
+     allow the back end to control what the linker does with
+     sections.  */
+#define SEC_COFF_SHARED_LIBRARY 0x10000000
+
+  /* This section contains data which may be shared with other
+     executables or shared objects. This is for COFF only.  */
+#define SEC_COFF_SHARED 0x20000000
+
+  /* When a section with this flag is being linked, then if the size of
+     the input section is less than a page, it should not cross a page
+     boundary.  If the size of the input section is one page or more,
+     it should be aligned on a page boundary.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_BLOCK 0x40000000
+
+  /* Conditionally link this section; do not link if there are no
+     references found to any symbol in the section.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_CLINK 0x80000000
+
+  /*  End of section flags.  */
+
+  /* Some internal packed boolean fields.  */
+
+  /* See the vma field.  */
+  unsigned int user_set_vma : 1;
+
+  /* A mark flag used by some of the linker backends.  */
+  unsigned int linker_mark : 1;
+
+  /* Another mark flag used by some of the linker backends.  Set for
+     output sections that have an input section.  */
+  unsigned int linker_has_input : 1;
+
+  /* Mark flags used by some linker backends for garbage collection.  */
+  unsigned int gc_mark : 1;
+  unsigned int gc_mark_from_eh : 1;
+
+  /* The following flags are used by the ELF linker. */
+
+  /* Mark sections which have been allocated to segments.  */
+  unsigned int segment_mark : 1;
+
+  /* Type of sec_info information.  */
+  unsigned int sec_info_type:3;
+#define ELF_INFO_TYPE_NONE      0
+#define ELF_INFO_TYPE_STABS     1
+#define ELF_INFO_TYPE_MERGE     2
+#define ELF_INFO_TYPE_EH_FRAME  3
+#define ELF_INFO_TYPE_JUST_SYMS 4
+
+  /* Nonzero if this section uses RELA relocations, rather than REL.  */
+  unsigned int use_rela_p:1;
+
+  /* Bits used by various backends.  The generic code doesn't touch
+     these fields.  */
+
+  /* Nonzero if this section has TLS related relocations.  */
+  unsigned int has_tls_reloc:1;
+
+  /* Nonzero if this section has a gp reloc.  */
+  unsigned int has_gp_reloc:1;
+
+  /* Nonzero if this section needs the relax finalize pass.  */
+  unsigned int need_finalize_relax:1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
+  /* End of internal packed boolean fields.  */
+
+  /*  The virtual memory address of the section - where it will be
+      at run time.  The symbols are relocated against this.  The
+      user_set_vma flag is maintained by bfd; if it's not set, the
+      backend can assign addresses (for example, in <<a.out>>, where
+      the default address for <<.data>> is dependent on the specific
+      target and various flags).  */
+  bfd_vma vma;
+
+  /*  The load address of the section - where it would be in a
+      rom image; really only used for writing section header
+      information.  */
+  bfd_vma lma;
+
+  /* The size of the section in octets, as it will be output.
+     Contains a value even if the section has no contents (e.g., the
+     size of <<.bss>>).  */
+  bfd_size_type size;
+
+  /* For input sections, the original size on disk of the section, in
+     octets.  This field is used by the linker relaxation code.  It is
+     currently only set for sections where the linker relaxation scheme
+     doesn't cache altered section and reloc contents (stabs, eh_frame,
+     SEC_MERGE, some coff relaxing targets), and thus the original size
+     needs to be kept to read the section multiple times.
+     For output sections, rawsize holds the section size calculated on
+     a previous linker relaxation pass.  */
+  bfd_size_type rawsize;
+
+  /* If this section is going to be output, then this value is the
+     offset in *bytes* into the output section of the first byte in the
+     input section (byte ==> smallest addressable unit on the
+     target).  In most cases, if this was going to start at the
+     100th octet (8-bit quantity) in the output section, this value
+     would be 100.  However, if the target byte size is 16 bits
+     (bfd_octets_per_byte is "2"), this value would be 50.  */
+  bfd_vma output_offset;
+
+  /* The output section through which to map on output.  */
+  struct bfd_section *output_section;
+
+  /* The alignment requirement of the section, as an exponent of 2 -
+     e.g., 3 aligns to 2^3 (or 8).  */
+  unsigned int alignment_power;
+
+  /* If an input section, a pointer to a vector of relocation
+     records for the data in this section.  */
+  struct reloc_cache_entry *relocation;
+
+  /* If an output section, a pointer to a vector of pointers to
+     relocation records for the data in this section.  */
+  struct reloc_cache_entry **orelocation;
+
+  /* The number of relocation records in one of the above.  */
+  unsigned reloc_count;
+
+  /* Information below is back end specific - and not always used
+     or updated.  */
+
+  /* File position of section data.  */
+  file_ptr filepos;
+
+  /* File position of relocation info.  */
+  file_ptr rel_filepos;
+
+  /* File position of line data.  */
+  file_ptr line_filepos;
+
+  /* Pointer to data for applications.  */
+  void *userdata;
+
+  /* If the SEC_IN_MEMORY flag is set, this points to the actual
+     contents.  */
+  unsigned char *contents;
+
+  /* Attached line number information.  */
+  alent *lineno;
+
+  /* Number of line number records.  */
+  unsigned int lineno_count;
+
+  /* Entity size for merging purposes.  */
+  unsigned int entsize;
+
+  /* Points to the kept section if this section is a link-once section,
+     and is discarded.  */
+  struct bfd_section *kept_section;
+
+  /* When a section is being output, this value changes as more
+     linenumbers are written out.  */
+  file_ptr moving_line_filepos;
+
+  /* What the section number is in the target world.  */
+  int target_index;
+
+  void *used_by_bfd;
+
+  /* If this is a constructor section then here is a list of the
+     relocations created to relocate items within it.  */
+  struct relent_chain *constructor_chain;
+
+  /* The BFD which owns the section.  */
+  bfd *owner;
+
+  /* A symbol which points at this section only.  */
+  struct bfd_symbol *symbol;
+  struct bfd_symbol **symbol_ptr_ptr;
+
+  /* Early in the link process, map_head and map_tail are used to build
+     a list of input sections attached to an output section.  Later,
+     output sections use these fields for a list of bfd_link_order
+     structs.  */
+  union {
+    struct bfd_link_order *link_order;
+    struct bfd_section *s;
+  } map_head, map_tail;
+} asection;
+
+/* These sections are global, and are managed by BFD.  The application
+   and target back end are not permitted to change the values in
+   these sections.  New code should use the section_ptr macros rather
+   than referring directly to the const sections.  The const sections
+   may eventually vanish.  */
+#define BFD_ABS_SECTION_NAME "*ABS*"
+#define BFD_UND_SECTION_NAME "*UND*"
+#define BFD_COM_SECTION_NAME "*COM*"
+#define BFD_IND_SECTION_NAME "*IND*"
+
+/* The absolute section.  */
+extern asection bfd_abs_section;
+#define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
+#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
+/* Pointer to the undefined section.  */
+extern asection bfd_und_section;
+#define bfd_und_section_ptr ((asection *) &bfd_und_section)
+#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
+/* Pointer to the common section.  */
+extern asection bfd_com_section;
+#define bfd_com_section_ptr ((asection *) &bfd_com_section)
+/* Pointer to the indirect section.  */
+extern asection bfd_ind_section;
+#define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
+#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
+
+#define bfd_is_const_section(SEC)              \
+ (   ((SEC) == bfd_abs_section_ptr)            \
+  || ((SEC) == bfd_und_section_ptr)            \
+  || ((SEC) == bfd_com_section_ptr)            \
+  || ((SEC) == bfd_ind_section_ptr))
+
+/* Macros to handle insertion and deletion of a bfd's sections.  These
+   only handle the list pointers, ie. do not adjust section_count,
+   target_index etc.  */
+#define bfd_section_list_remove(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      asection *_next = _s->next;                      \
+      asection *_prev = _s->prev;                      \
+      if (_prev)                                       \
+        _prev->next = _next;                           \
+      else                                             \
+        (ABFD)->sections = _next;                      \
+      if (_next)                                       \
+        _next->prev = _prev;                           \
+      else                                             \
+        (ABFD)->section_last = _prev;                  \
+    }                                                  \
+  while (0)
+#define bfd_section_list_append(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->next = NULL;                                 \
+      if (_abfd->section_last)                         \
+        {                                              \
+          _s->prev = _abfd->section_last;              \
+          _abfd->section_last->next = _s;              \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->prev = NULL;                             \
+          _abfd->sections = _s;                        \
+        }                                              \
+      _abfd->section_last = _s;                        \
+    }                                                  \
+  while (0)
+#define bfd_section_list_prepend(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->prev = NULL;                                 \
+      if (_abfd->sections)                             \
+        {                                              \
+          _s->next = _abfd->sections;                  \
+          _abfd->sections->prev = _s;                  \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->next = NULL;                             \
+          _abfd->section_last = _s;                    \
+        }                                              \
+      _abfd->sections = _s;                            \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_after(ABFD, A, S) \
+  do                                                   \
+    {                                                  \
+      asection *_a = A;                                \
+      asection *_s = S;                                \
+      asection *_next = _a->next;                      \
+      _s->next = _next;                                \
+      _s->prev = _a;                                   \
+      _a->next = _s;                                   \
+      if (_next)                                       \
+        _next->prev = _s;                              \
+      else                                             \
+        (ABFD)->section_last = _s;                     \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_before(ABFD, B, S) \
+  do                                                   \
+    {                                                  \
+      asection *_b = B;                                \
+      asection *_s = S;                                \
+      asection *_prev = _b->prev;                      \
+      _s->prev = _prev;                                \
+      _s->next = _b;                                   \
+      _b->prev = _s;                                   \
+      if (_prev)                                       \
+        _prev->next = _s;                              \
+      else                                             \
+        (ABFD)->sections = _s;                         \
+    }                                                  \
+  while (0)
+#define bfd_section_removed_from_list(ABFD, S) \
+  ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))
+
+#define BFD_FAKE_SECTION(SEC, FLAGS, SYM, NAME, IDX)                   \
+  /* name, id,  index, next, prev, flags, user_set_vma,            */  \
+  { NAME,  IDX, 0,     NULL, NULL, FLAGS, 0,                           \
+                                                                       \
+  /* linker_mark, linker_has_input, gc_mark, gc_mark_from_eh,      */  \
+     0,           0,                1,       0,                        \
+                                                                       \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_gp_reloc, need_finalize_relax, reloc_done,                */  \
+     0,            0,                   0,                             \
+                                                                       \
+  /* vma, lma, size, rawsize                                       */  \
+     0,   0,   0,    0,                                                \
+                                                                       \
+  /* output_offset, output_section,              alignment_power,  */  \
+     0,             (struct bfd_section *) &SEC, 0,                    \
+                                                                       \
+  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
+     NULL,       NULL,        0,           0,       0,                 \
+                                                                       \
+  /* line_filepos, userdata, contents, lineno, lineno_count,       */  \
+     0,            NULL,     NULL,     NULL,   0,                      \
+                                                                       \
+  /* entsize, kept_section, moving_line_filepos,                    */ \
+     0,       NULL,          0,                                        \
+                                                                       \
+  /* target_index, used_by_bfd, constructor_chain, owner,          */  \
+     0,            NULL,        NULL,              NULL,               \
+                                                                       \
+  /* symbol,                    symbol_ptr_ptr,                    */  \
+     (struct bfd_symbol *) SYM, &SEC.symbol,                           \
+                                                                       \
+  /* map_head, map_tail                                            */  \
+     { NULL }, { NULL }                                                \
+    }
+
+void bfd_section_list_clear (bfd *);
+
+asection *bfd_get_section_by_name (bfd *abfd, const char *name);
+
+asection *bfd_get_section_by_name_if
+   (bfd *abfd,
+    const char *name,
+    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+char *bfd_get_unique_section_name
+   (bfd *abfd, const char *templat, int *count);
+
+asection *bfd_make_section_old_way (bfd *abfd, const char *name);
+
+asection *bfd_make_section_anyway_with_flags
+   (bfd *abfd, const char *name, flagword flags);
+
+asection *bfd_make_section_anyway (bfd *abfd, const char *name);
+
+asection *bfd_make_section_with_flags
+   (bfd *, const char *name, flagword flags);
+
+asection *bfd_make_section (bfd *, const char *name);
+
+bfd_boolean bfd_set_section_flags
+   (bfd *abfd, asection *sec, flagword flags);
+
+void bfd_map_over_sections
+   (bfd *abfd,
+    void (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+asection *bfd_sections_find_if
+   (bfd *abfd,
+    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+bfd_boolean bfd_set_section_size
+   (bfd *abfd, asection *sec, bfd_size_type val);
+
+bfd_boolean bfd_set_section_contents
+   (bfd *abfd, asection *section, const void *data,
+    file_ptr offset, bfd_size_type count);
+
+bfd_boolean bfd_get_section_contents
+   (bfd *abfd, asection *section, void *location, file_ptr offset,
+    bfd_size_type count);
+
+bfd_boolean bfd_malloc_and_get_section
+   (bfd *abfd, asection *section, bfd_byte **buf);
+
+bfd_boolean bfd_copy_private_section_data
+   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
+
+#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
+     BFD_SEND (obfd, _bfd_copy_private_section_data, \
+               (ibfd, isection, obfd, osection))
+bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
+
+bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
+
+/* Extracted from archures.c.  */
+enum bfd_architecture
+{
+  bfd_arch_unknown,   /* File arch not known.  */
+  bfd_arch_obscure,   /* Arch known, not one of these.  */
+  bfd_arch_m68k,      /* Motorola 68xxx */
+#define bfd_mach_m68000 1
+#define bfd_mach_m68008 2
+#define bfd_mach_m68010 3
+#define bfd_mach_m68020 4
+#define bfd_mach_m68030 5
+#define bfd_mach_m68040 6
+#define bfd_mach_m68060 7
+#define bfd_mach_cpu32  8
+#define bfd_mach_fido   9
+#define bfd_mach_mcf_isa_a_nodiv 10
+#define bfd_mach_mcf_isa_a 11
+#define bfd_mach_mcf_isa_a_mac 12
+#define bfd_mach_mcf_isa_a_emac 13
+#define bfd_mach_mcf_isa_aplus 14
+#define bfd_mach_mcf_isa_aplus_mac 15
+#define bfd_mach_mcf_isa_aplus_emac 16
+#define bfd_mach_mcf_isa_b_nousp 17
+#define bfd_mach_mcf_isa_b_nousp_mac 18
+#define bfd_mach_mcf_isa_b_nousp_emac 19
+#define bfd_mach_mcf_isa_b 20
+#define bfd_mach_mcf_isa_b_mac 21
+#define bfd_mach_mcf_isa_b_emac 22
+#define bfd_mach_mcf_isa_b_float 23
+#define bfd_mach_mcf_isa_b_float_mac 24
+#define bfd_mach_mcf_isa_b_float_emac 25
+#define bfd_mach_mcf_isa_c 26
+#define bfd_mach_mcf_isa_c_mac 27
+#define bfd_mach_mcf_isa_c_emac 28
+  bfd_arch_vax,       /* DEC Vax */
+  bfd_arch_i960,      /* Intel 960 */
+    /* The order of the following is important.
+       lower number indicates a machine type that
+       only accepts a subset of the instructions
+       available to machines with higher numbers.
+       The exception is the "ca", which is
+       incompatible with all other machines except
+       "core".  */
+
+#define bfd_mach_i960_core      1
+#define bfd_mach_i960_ka_sa     2
+#define bfd_mach_i960_kb_sb     3
+#define bfd_mach_i960_mc        4
+#define bfd_mach_i960_xa        5
+#define bfd_mach_i960_ca        6
+#define bfd_mach_i960_jx        7
+#define bfd_mach_i960_hx        8
+
+  bfd_arch_or32,      /* OpenRISC 32 */
+
+  bfd_arch_sparc,     /* SPARC */
+#define bfd_mach_sparc                 1
+/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
+#define bfd_mach_sparc_sparclet        2
+#define bfd_mach_sparc_sparclite       3
+#define bfd_mach_sparc_v8plus          4
+#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_sparclite_le    6
+#define bfd_mach_sparc_v9              7
+#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
+#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
+/* Nonzero if MACH has the v9 instruction set.  */
+#define bfd_mach_sparc_v9_p(mach) \
+  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+   && (mach) != bfd_mach_sparc_sparclite_le)
+/* Nonzero if MACH is a 64 bit sparc architecture.  */
+#define bfd_mach_sparc_64bit_p(mach) \
+  ((mach) >= bfd_mach_sparc_v9 && (mach) != bfd_mach_sparc_v8plusb)
+  bfd_arch_spu,       /* PowerPC SPU */
+#define bfd_mach_spu           256 
+  bfd_arch_mips,      /* MIPS Rxxxx */
+#define bfd_mach_mips3000              3000
+#define bfd_mach_mips3900              3900
+#define bfd_mach_mips4000              4000
+#define bfd_mach_mips4010              4010
+#define bfd_mach_mips4100              4100
+#define bfd_mach_mips4111              4111
+#define bfd_mach_mips4120              4120
+#define bfd_mach_mips4300              4300
+#define bfd_mach_mips4400              4400
+#define bfd_mach_mips4600              4600
+#define bfd_mach_mips4650              4650
+#define bfd_mach_mips5000              5000
+#define bfd_mach_mips5400              5400
+#define bfd_mach_mips5500              5500
+#define bfd_mach_mips6000              6000
+#define bfd_mach_mips7000              7000
+#define bfd_mach_mips8000              8000
+#define bfd_mach_mips9000              9000
+#define bfd_mach_mips10000             10000
+#define bfd_mach_mips12000             12000
+#define bfd_mach_mips16                16
+#define bfd_mach_mips5                 5
+#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mipsisa32             32
+#define bfd_mach_mipsisa32r2           33
+#define bfd_mach_mipsisa64             64
+#define bfd_mach_mipsisa64r2           65
+  bfd_arch_i386,      /* Intel 386 */
+#define bfd_mach_i386_i386 1
+#define bfd_mach_i386_i8086 2
+#define bfd_mach_i386_i386_intel_syntax 3
+#define bfd_mach_x86_64 64
+#define bfd_mach_x86_64_intel_syntax 65
+  bfd_arch_we32k,     /* AT&T WE32xxx */
+  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
+  bfd_arch_i860,      /* Intel 860 */
+  bfd_arch_i370,      /* IBM 360/370 Mainframes */
+  bfd_arch_romp,      /* IBM ROMP PC/RT */
+  bfd_arch_convex,    /* Convex */
+  bfd_arch_m88k,      /* Motorola 88xxx */
+  bfd_arch_m98k,      /* Motorola 98xxx */
+  bfd_arch_pyramid,   /* Pyramid Technology */
+  bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
+#define bfd_mach_h8300    1
+#define bfd_mach_h8300h   2
+#define bfd_mach_h8300s   3
+#define bfd_mach_h8300hn  4
+#define bfd_mach_h8300sn  5
+#define bfd_mach_h8300sx  6
+#define bfd_mach_h8300sxn 7
+  bfd_arch_pdp11,     /* DEC PDP-11 */
+  bfd_arch_powerpc,   /* PowerPC */
+#define bfd_mach_ppc           32
+#define bfd_mach_ppc64         64
+#define bfd_mach_ppc_403       403
+#define bfd_mach_ppc_403gc     4030
+#define bfd_mach_ppc_505       505
+#define bfd_mach_ppc_601       601
+#define bfd_mach_ppc_602       602
+#define bfd_mach_ppc_603       603
+#define bfd_mach_ppc_ec603e    6031
+#define bfd_mach_ppc_604       604
+#define bfd_mach_ppc_620       620
+#define bfd_mach_ppc_630       630
+#define bfd_mach_ppc_750       750
+#define bfd_mach_ppc_860       860
+#define bfd_mach_ppc_a35       35
+#define bfd_mach_ppc_rs64ii    642
+#define bfd_mach_ppc_rs64iii   643
+#define bfd_mach_ppc_7400      7400
+#define bfd_mach_ppc_e500      500
+  bfd_arch_rs6000,    /* IBM RS/6000 */
+#define bfd_mach_rs6k          6000
+#define bfd_mach_rs6k_rs1      6001
+#define bfd_mach_rs6k_rsc      6003
+#define bfd_mach_rs6k_rs2      6002
+  bfd_arch_hppa,      /* HP PA RISC */
+#define bfd_mach_hppa10        10
+#define bfd_mach_hppa11        11
+#define bfd_mach_hppa20        20
+#define bfd_mach_hppa20w       25
+  bfd_arch_d10v,      /* Mitsubishi D10V */
+#define bfd_mach_d10v          1
+#define bfd_mach_d10v_ts2      2
+#define bfd_mach_d10v_ts3      3
+  bfd_arch_d30v,      /* Mitsubishi D30V */
+  bfd_arch_dlx,       /* DLX */
+  bfd_arch_m68hc11,   /* Motorola 68HC11 */
+  bfd_arch_m68hc12,   /* Motorola 68HC12 */
+#define bfd_mach_m6812_default 0
+#define bfd_mach_m6812         1
+#define bfd_mach_m6812s        2
+  bfd_arch_z8k,       /* Zilog Z8000 */
+#define bfd_mach_z8001         1
+#define bfd_mach_z8002         2
+  bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
+  bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
+#define bfd_mach_sh            1
+#define bfd_mach_sh2        0x20
+#define bfd_mach_sh_dsp     0x2d
+#define bfd_mach_sh2a       0x2a
+#define bfd_mach_sh2a_nofpu 0x2b
+#define bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu 0x2a1
+#define bfd_mach_sh2a_nofpu_or_sh3_nommu 0x2a2
+#define bfd_mach_sh2a_or_sh4  0x2a3
+#define bfd_mach_sh2a_or_sh3e 0x2a4
+#define bfd_mach_sh2e       0x2e
+#define bfd_mach_sh3        0x30
+#define bfd_mach_sh3_nommu  0x31
+#define bfd_mach_sh3_dsp    0x3d
+#define bfd_mach_sh3e       0x3e
+#define bfd_mach_sh4        0x40
+#define bfd_mach_sh4_nofpu  0x41
+#define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_sh4a       0x4a
+#define bfd_mach_sh4a_nofpu 0x4b
+#define bfd_mach_sh4al_dsp  0x4d
+#define bfd_mach_sh5        0x50
+  bfd_arch_alpha,     /* Dec Alpha */
+#define bfd_mach_alpha_ev4  0x10
+#define bfd_mach_alpha_ev5  0x20
+#define bfd_mach_alpha_ev6  0x30
+  bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
+#define bfd_mach_arm_unknown   0
+#define bfd_mach_arm_2         1
+#define bfd_mach_arm_2a        2
+#define bfd_mach_arm_3         3
+#define bfd_mach_arm_3M        4
+#define bfd_mach_arm_4         5
+#define bfd_mach_arm_4T        6
+#define bfd_mach_arm_5         7
+#define bfd_mach_arm_5T        8
+#define bfd_mach_arm_5TE       9
+#define bfd_mach_arm_XScale    10
+#define bfd_mach_arm_ep9312    11
+#define bfd_mach_arm_iWMMXt    12
+#define bfd_mach_arm_iWMMXt2   13
+  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
+  bfd_arch_w65,       /* WDC 65816 */
+  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
+  bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
+#define bfd_mach_tic3x         30
+#define bfd_mach_tic4x         40
+  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
+  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v850,      /* NEC V850 */
+#define bfd_mach_v850          1
+#define bfd_mach_v850e         'E'
+#define bfd_mach_v850e1        '1'
+  bfd_arch_arc,       /* ARC Cores */
+#define bfd_mach_arc_5         5
+#define bfd_mach_arc_6         6
+#define bfd_mach_arc_7         7
+#define bfd_mach_arc_8         8
+ bfd_arch_m32c,     /* Renesas M16C/M32C.  */
+#define bfd_mach_m16c        0x75
+#define bfd_mach_m32c        0x78
+  bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
+#define bfd_mach_m32r          1 /* For backwards compatibility.  */
+#define bfd_mach_m32rx         'x'
+#define bfd_mach_m32r2         '2'
+  bfd_arch_mn10200,   /* Matsushita MN10200 */
+  bfd_arch_mn10300,   /* Matsushita MN10300 */
+#define bfd_mach_mn10300               300
+#define bfd_mach_am33          330
+#define bfd_mach_am33_2        332
+  bfd_arch_fr30,
+#define bfd_mach_fr30          0x46523330
+  bfd_arch_frv,
+#define bfd_mach_frv           1
+#define bfd_mach_frvsimple     2
+#define bfd_mach_fr300         300
+#define bfd_mach_fr400         400
+#define bfd_mach_fr450         450
+#define bfd_mach_frvtomcat     499     /* fr500 prototype */
+#define bfd_mach_fr500         500
+#define bfd_mach_fr550         550
+  bfd_arch_mcore,
+  bfd_arch_mep,
+#define bfd_mach_mep           1
+#define bfd_mach_mep_h1        0x6831
+  bfd_arch_ia64,      /* HP/Intel ia64 */
+#define bfd_mach_ia64_elf64    64
+#define bfd_mach_ia64_elf32    32
+  bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
+#define bfd_mach_ip2022        1
+#define bfd_mach_ip2022ext     2
+ bfd_arch_iq2000,     /* Vitesse IQ2000.  */
+#define bfd_mach_iq2000        1
+#define bfd_mach_iq10          2
+  bfd_arch_mt,
+#define bfd_mach_ms1           1
+#define bfd_mach_mrisc2        2
+#define bfd_mach_ms2           3
+  bfd_arch_pj,
+  bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
+#define bfd_mach_avr1          1
+#define bfd_mach_avr2          2
+#define bfd_mach_avr3          3
+#define bfd_mach_avr4          4
+#define bfd_mach_avr5          5
+#define bfd_mach_avr6          6
+  bfd_arch_bfin,        /* ADI Blackfin */
+#define bfd_mach_bfin          1
+  bfd_arch_cr16,       /* National Semiconductor CompactRISC (ie CR16). */
+#define bfd_mach_cr16          1
+  bfd_arch_cr16c,       /* National Semiconductor CompactRISC. */
+#define bfd_mach_cr16c         1
+  bfd_arch_crx,       /*  National Semiconductor CRX.  */
+#define bfd_mach_crx           1
+  bfd_arch_cris,      /* Axis CRIS */
+#define bfd_mach_cris_v0_v10   255
+#define bfd_mach_cris_v32      32
+#define bfd_mach_cris_v10_v32  1032
+  bfd_arch_s390,      /* IBM s390 */
+#define bfd_mach_s390_31       31
+#define bfd_mach_s390_64       64
+  bfd_arch_score,     /* Sunplus score */ 
+  bfd_arch_openrisc,  /* OpenRISC */
+  bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
+  bfd_arch_xstormy16,
+#define bfd_mach_xstormy16     1
+  bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
+#define bfd_mach_msp11          11
+#define bfd_mach_msp110         110
+#define bfd_mach_msp12          12
+#define bfd_mach_msp13          13
+#define bfd_mach_msp14          14
+#define bfd_mach_msp15          15
+#define bfd_mach_msp16          16
+#define bfd_mach_msp21          21
+#define bfd_mach_msp31          31
+#define bfd_mach_msp32          32
+#define bfd_mach_msp33          33
+#define bfd_mach_msp41          41
+#define bfd_mach_msp42          42
+#define bfd_mach_msp43          43
+#define bfd_mach_msp44          44
+  bfd_arch_xc16x,     /* Infineon's XC16X Series.               */
+#define bfd_mach_xc16x         1
+#define bfd_mach_xc16xl        2
+#define bfd_mach_xc16xs         3
+  bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
+#define bfd_mach_xtensa        1
+   bfd_arch_maxq,     /* Dallas MAXQ 10/20 */
+#define bfd_mach_maxq10    10
+#define bfd_mach_maxq20    20
+  bfd_arch_z80,
+#define bfd_mach_z80strict      1 /* No undocumented opcodes.  */
+#define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
+#define bfd_mach_z80full        7 /* All undocumented instructions.  */
+#define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_last
+  };
+
+typedef struct bfd_arch_info
+{
+  int bits_per_word;
+  int bits_per_address;
+  int bits_per_byte;
+  enum bfd_architecture arch;
+  unsigned long mach;
+  const char *arch_name;
+  const char *printable_name;
+  unsigned int section_align_power;
+  /* TRUE if this is the default machine for the architecture.
+     The default arch should be the first entry for an arch so that
+     all the entries for that arch can be accessed via <<next>>.  */
+  bfd_boolean the_default;
+  const struct bfd_arch_info * (*compatible)
+    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
+
+  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
+
+  const struct bfd_arch_info *next;
+}
+bfd_arch_info_type;
+
+const char *bfd_printable_name (bfd *abfd);
+
+const bfd_arch_info_type *bfd_scan_arch (const char *string);
+
+const char **bfd_arch_list (void);
+
+const bfd_arch_info_type *bfd_arch_get_compatible
+   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
+
+void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
+
+enum bfd_architecture bfd_get_arch (bfd *abfd);
+
+unsigned long bfd_get_mach (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_address (bfd *abfd);
+
+const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
+
+const bfd_arch_info_type *bfd_lookup_arch
+   (enum bfd_architecture arch, unsigned long machine);
+
+const char *bfd_printable_arch_mach
+   (enum bfd_architecture arch, unsigned long machine);
+
+unsigned int bfd_octets_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_mach_octets_per_byte
+   (enum bfd_architecture arch, unsigned long machine);
+
+/* Extracted from reloc.c.  */
+typedef enum bfd_reloc_status
+{
+  /* No errors detected.  */
+  bfd_reloc_ok,
+
+  /* The relocation was performed, but there was an overflow.  */
+  bfd_reloc_overflow,
+
+  /* The address to relocate was not within the section supplied.  */
+  bfd_reloc_outofrange,
+
+  /* Used by special functions.  */
+  bfd_reloc_continue,
+
+  /* Unsupported relocation size requested.  */
+  bfd_reloc_notsupported,
+
+  /* Unused.  */
+  bfd_reloc_other,
+
+  /* The symbol to relocate against was undefined.  */
+  bfd_reloc_undefined,
+
+  /* The relocation was performed, but may not be ok - presently
+     generated only when linking i960 coff files with i960 b.out
+     symbols.  If this type is returned, the error_message argument
+     to bfd_perform_relocation will be set.  */
+  bfd_reloc_dangerous
+ }
+ bfd_reloc_status_type;
+
+
+typedef struct reloc_cache_entry
+{
+  /* A pointer into the canonical table of pointers.  */
+  struct bfd_symbol **sym_ptr_ptr;
+
+  /* offset in section.  */
+  bfd_size_type address;
+
+  /* addend for relocation value.  */
+  bfd_vma addend;
+
+  /* Pointer to how to perform the required relocation.  */
+  reloc_howto_type *howto;
+
+}
+arelent;
+
+enum complain_overflow
+{
+  /* Do not complain on overflow.  */
+  complain_overflow_dont,
+
+  /* Complain if the value overflows when considered as a signed
+     number one bit larger than the field.  ie. A bitfield of N bits
+     is allowed to represent -2**n to 2**n-1.  */
+  complain_overflow_bitfield,
+
+  /* Complain if the value overflows when considered as a signed
+     number.  */
+  complain_overflow_signed,
+
+  /* Complain if the value overflows when considered as an
+     unsigned number.  */
+  complain_overflow_unsigned
+};
+
+struct reloc_howto_struct
+{
+  /*  The type field has mainly a documentary use - the back end can
+      do what it wants with it, though normally the back end's
+      external idea of what a reloc number is stored
+      in this field.  For example, a PC relative word relocation
+      in a coff environment has the type 023 - because that's
+      what the outside world calls a R_PCRWORD reloc.  */
+  unsigned int type;
+
+  /*  The value the final relocation is shifted right by.  This drops
+      unwanted data from the relocation.  */
+  unsigned int rightshift;
+
+  /*  The size of the item to be relocated.  This is *not* a
+      power-of-two measure.  To get the number of bytes operated
+      on by a type of relocation, use bfd_get_reloc_size.  */
+  int size;
+
+  /*  The number of bits in the item to be relocated.  This is used
+      when doing overflow checking.  */
+  unsigned int bitsize;
+
+  /*  Notes that the relocation is relative to the location in the
+      data section of the addend.  The relocation function will
+      subtract from the relocation value the address of the location
+      being relocated.  */
+  bfd_boolean pc_relative;
+
+  /*  The bit position of the reloc value in the destination.
+      The relocated value is left shifted by this amount.  */
+  unsigned int bitpos;
+
+  /* What type of overflow error should be checked for when
+     relocating.  */
+  enum complain_overflow complain_on_overflow;
+
+  /* If this field is non null, then the supplied function is
+     called rather than the normal function.  This allows really
+     strange relocation methods to be accommodated (e.g., i960 callj
+     instructions).  */
+  bfd_reloc_status_type (*special_function)
+    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
+     bfd *, char **);
+
+  /* The textual name of the relocation type.  */
+  char *name;
+
+  /* Some formats record a relocation addend in the section contents
+     rather than with the relocation.  For ELF formats this is the
+     distinction between USE_REL and USE_RELA (though the code checks
+     for USE_REL == 1/0).  The value of this field is TRUE if the
+     addend is recorded with the section contents; when performing a
+     partial link (ld -r) the section contents (the data) will be
+     modified.  The value of this field is FALSE if addends are
+     recorded with the relocation (in arelent.addend); when performing
+     a partial link the relocation will be modified.
+     All relocations for all ELF USE_RELA targets should set this field
+     to FALSE (values of TRUE should be looked on with suspicion).
+     However, the converse is not true: not all relocations of all ELF
+     USE_REL targets set this field to TRUE.  Why this is so is peculiar
+     to each particular target.  For relocs that aren't used in partial
+     links (e.g. GOT stuff) it doesn't matter what this is set to.  */
+  bfd_boolean partial_inplace;
+
+  /* src_mask selects the part of the instruction (or data) to be used
+     in the relocation sum.  If the target relocations don't have an
+     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
+     dst_mask to extract the addend from the section contents.  If
+     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
+     field should be zero.  Non-zero values for ELF USE_RELA targets are
+     bogus as in those cases the value in the dst_mask part of the
+     section contents should be treated as garbage.  */
+  bfd_vma src_mask;
+
+  /* dst_mask selects which parts of the instruction (or data) are
+     replaced with a relocated value.  */
+  bfd_vma dst_mask;
+
+  /* When some formats create PC relative instructions, they leave
+     the value of the pc of the place being relocated in the offset
+     slot of the instruction, so that a PC relative relocation can
+     be made just by adding in an ordinary offset (e.g., sun3 a.out).
+     Some formats leave the displacement part of an instruction
+     empty (e.g., m88k bcs); this flag signals the fact.  */
+  bfd_boolean pcrel_offset;
+};
+
+#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
+  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
+#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
+  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
+         NAME, FALSE, 0, 0, IN)
+
+#define EMPTY_HOWTO(C) \
+  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
+         NULL, FALSE, 0, 0, FALSE)
+
+#define HOWTO_PREPARE(relocation, symbol)               \
+  {                                                     \
+    if (symbol != NULL)                                 \
+      {                                                 \
+        if (bfd_is_com_section (symbol->section))       \
+          {                                             \
+            relocation = 0;                             \
+          }                                             \
+        else                                            \
+          {                                             \
+            relocation = symbol->value;                 \
+          }                                             \
+      }                                                 \
+  }
+
+unsigned int bfd_get_reloc_size (reloc_howto_type *);
+
+typedef struct relent_chain
+{
+  arelent relent;
+  struct relent_chain *next;
+}
+arelent_chain;
+
+bfd_reloc_status_type bfd_check_overflow
+   (enum complain_overflow how,
+    unsigned int bitsize,
+    unsigned int rightshift,
+    unsigned int addrsize,
+    bfd_vma relocation);
+
+bfd_reloc_status_type bfd_perform_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data,
+    asection *input_section,
+    bfd *output_bfd,
+    char **error_message);
+
+bfd_reloc_status_type bfd_install_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data, bfd_vma data_start,
+    asection *input_section,
+    char **error_message);
+
+enum bfd_reloc_code_real {
+  _dummy_first_bfd_reloc_code_real,
+
+
+/* Basic absolute relocations of N bits.  */
+  BFD_RELOC_64,
+  BFD_RELOC_32,
+  BFD_RELOC_26,
+  BFD_RELOC_24,
+  BFD_RELOC_16,
+  BFD_RELOC_14,
+  BFD_RELOC_8,
+
+/* PC-relative relocations.  Sometimes these are relative to the address
+of the relocation itself; sometimes they are relative to the start of
+the section containing the relocation.  It depends on the specific target.
+
+The 24-bit relocation is used in some Intel 960 configurations.  */
+  BFD_RELOC_64_PCREL,
+  BFD_RELOC_32_PCREL,
+  BFD_RELOC_24_PCREL,
+  BFD_RELOC_16_PCREL,
+  BFD_RELOC_12_PCREL,
+  BFD_RELOC_8_PCREL,
+
+/* Section relative relocations.  Some targets need this for DWARF2.  */
+  BFD_RELOC_32_SECREL,
+
+/* For ELF.  */
+  BFD_RELOC_32_GOT_PCREL,
+  BFD_RELOC_16_GOT_PCREL,
+  BFD_RELOC_8_GOT_PCREL,
+  BFD_RELOC_32_GOTOFF,
+  BFD_RELOC_16_GOTOFF,
+  BFD_RELOC_LO16_GOTOFF,
+  BFD_RELOC_HI16_GOTOFF,
+  BFD_RELOC_HI16_S_GOTOFF,
+  BFD_RELOC_8_GOTOFF,
+  BFD_RELOC_64_PLT_PCREL,
+  BFD_RELOC_32_PLT_PCREL,
+  BFD_RELOC_24_PLT_PCREL,
+  BFD_RELOC_16_PLT_PCREL,
+  BFD_RELOC_8_PLT_PCREL,
+  BFD_RELOC_64_PLTOFF,
+  BFD_RELOC_32_PLTOFF,
+  BFD_RELOC_16_PLTOFF,
+  BFD_RELOC_LO16_PLTOFF,
+  BFD_RELOC_HI16_PLTOFF,
+  BFD_RELOC_HI16_S_PLTOFF,
+  BFD_RELOC_8_PLTOFF,
+
+/* Relocations used by 68K ELF.  */
+  BFD_RELOC_68K_GLOB_DAT,
+  BFD_RELOC_68K_JMP_SLOT,
+  BFD_RELOC_68K_RELATIVE,
+
+/* Linkage-table relative.  */
+  BFD_RELOC_32_BASEREL,
+  BFD_RELOC_16_BASEREL,
+  BFD_RELOC_LO16_BASEREL,
+  BFD_RELOC_HI16_BASEREL,
+  BFD_RELOC_HI16_S_BASEREL,
+  BFD_RELOC_8_BASEREL,
+  BFD_RELOC_RVA,
+
+/* Absolute 8-bit relocation, but used to form an address like 0xFFnn.  */
+  BFD_RELOC_8_FFnn,
+
+/* These PC-relative relocations are stored as word displacements --
+i.e., byte displacements shifted right two bits.  The 30-bit word
+displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
+SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
+signed 16-bit displacement is used on the MIPS, and the 23-bit
+displacement is used on the Alpha.  */
+  BFD_RELOC_32_PCREL_S2,
+  BFD_RELOC_16_PCREL_S2,
+  BFD_RELOC_23_PCREL_S2,
+
+/* High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
+the target word.  These are used on the SPARC.  */
+  BFD_RELOC_HI22,
+  BFD_RELOC_LO10,
+
+/* For systems that allocate a Global Pointer register, these are
+displacements off that register.  These relocation types are
+handled specially, because the value the register will have is
+decided relatively late.  */
+  BFD_RELOC_GPREL16,
+  BFD_RELOC_GPREL32,
+
+/* Reloc types used for i960/b.out.  */
+  BFD_RELOC_I960_CALLJ,
+
+/* SPARC ELF relocations.  There is probably some overlap with other
+relocation types already defined.  */
+  BFD_RELOC_NONE,
+  BFD_RELOC_SPARC_WDISP22,
+  BFD_RELOC_SPARC22,
+  BFD_RELOC_SPARC13,
+  BFD_RELOC_SPARC_GOT10,
+  BFD_RELOC_SPARC_GOT13,
+  BFD_RELOC_SPARC_GOT22,
+  BFD_RELOC_SPARC_PC10,
+  BFD_RELOC_SPARC_PC22,
+  BFD_RELOC_SPARC_WPLT30,
+  BFD_RELOC_SPARC_COPY,
+  BFD_RELOC_SPARC_GLOB_DAT,
+  BFD_RELOC_SPARC_JMP_SLOT,
+  BFD_RELOC_SPARC_RELATIVE,
+  BFD_RELOC_SPARC_UA16,
+  BFD_RELOC_SPARC_UA32,
+  BFD_RELOC_SPARC_UA64,
+
+/* I think these are specific to SPARC a.out (e.g., Sun 4).  */
+  BFD_RELOC_SPARC_BASE13,
+  BFD_RELOC_SPARC_BASE22,
+
+/* SPARC64 relocations  */
+#define BFD_RELOC_SPARC_64 BFD_RELOC_64
+  BFD_RELOC_SPARC_10,
+  BFD_RELOC_SPARC_11,
+  BFD_RELOC_SPARC_OLO10,
+  BFD_RELOC_SPARC_HH22,
+  BFD_RELOC_SPARC_HM10,
+  BFD_RELOC_SPARC_LM22,
+  BFD_RELOC_SPARC_PC_HH22,
+  BFD_RELOC_SPARC_PC_HM10,
+  BFD_RELOC_SPARC_PC_LM22,
+  BFD_RELOC_SPARC_WDISP16,
+  BFD_RELOC_SPARC_WDISP19,
+  BFD_RELOC_SPARC_7,
+  BFD_RELOC_SPARC_6,
+  BFD_RELOC_SPARC_5,
+#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
+  BFD_RELOC_SPARC_PLT32,
+  BFD_RELOC_SPARC_PLT64,
+  BFD_RELOC_SPARC_HIX22,
+  BFD_RELOC_SPARC_LOX10,
+  BFD_RELOC_SPARC_H44,
+  BFD_RELOC_SPARC_M44,
+  BFD_RELOC_SPARC_L44,
+  BFD_RELOC_SPARC_REGISTER,
+
+/* SPARC little endian relocation  */
+  BFD_RELOC_SPARC_REV32,
+
+/* SPARC TLS relocations  */
+  BFD_RELOC_SPARC_TLS_GD_HI22,
+  BFD_RELOC_SPARC_TLS_GD_LO10,
+  BFD_RELOC_SPARC_TLS_GD_ADD,
+  BFD_RELOC_SPARC_TLS_GD_CALL,
+  BFD_RELOC_SPARC_TLS_LDM_HI22,
+  BFD_RELOC_SPARC_TLS_LDM_LO10,
+  BFD_RELOC_SPARC_TLS_LDM_ADD,
+  BFD_RELOC_SPARC_TLS_LDM_CALL,
+  BFD_RELOC_SPARC_TLS_LDO_HIX22,
+  BFD_RELOC_SPARC_TLS_LDO_LOX10,
+  BFD_RELOC_SPARC_TLS_LDO_ADD,
+  BFD_RELOC_SPARC_TLS_IE_HI22,
+  BFD_RELOC_SPARC_TLS_IE_LO10,
+  BFD_RELOC_SPARC_TLS_IE_LD,
+  BFD_RELOC_SPARC_TLS_IE_LDX,
+  BFD_RELOC_SPARC_TLS_IE_ADD,
+  BFD_RELOC_SPARC_TLS_LE_HIX22,
+  BFD_RELOC_SPARC_TLS_LE_LOX10,
+  BFD_RELOC_SPARC_TLS_DTPMOD32,
+  BFD_RELOC_SPARC_TLS_DTPMOD64,
+  BFD_RELOC_SPARC_TLS_DTPOFF32,
+  BFD_RELOC_SPARC_TLS_DTPOFF64,
+  BFD_RELOC_SPARC_TLS_TPOFF32,
+  BFD_RELOC_SPARC_TLS_TPOFF64,
+
+/* SPU Relocations.  */
+  BFD_RELOC_SPU_IMM7,
+  BFD_RELOC_SPU_IMM8,
+  BFD_RELOC_SPU_IMM10,
+  BFD_RELOC_SPU_IMM10W,
+  BFD_RELOC_SPU_IMM16,
+  BFD_RELOC_SPU_IMM16W,
+  BFD_RELOC_SPU_IMM18,
+  BFD_RELOC_SPU_PCREL9a,
+  BFD_RELOC_SPU_PCREL9b,
+  BFD_RELOC_SPU_PCREL16,
+  BFD_RELOC_SPU_LO16,
+  BFD_RELOC_SPU_HI16,
+  BFD_RELOC_SPU_PPU32,
+  BFD_RELOC_SPU_PPU64,
+
+/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
+"addend" in some special way.
+For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
+writing; when reading, it will be the absolute section symbol.  The
+addend is the displacement in bytes of the "lda" instruction from
+the "ldah" instruction (which is at the address of this reloc).  */
+  BFD_RELOC_ALPHA_GPDISP_HI16,
+
+/* For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
+with GPDISP_HI16 relocs.  The addend is ignored when writing the
+relocations out, and is filled in with the file's GP value on
+reading, for convenience.  */
+  BFD_RELOC_ALPHA_GPDISP_LO16,
+
+/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
+relocation except that there is no accompanying GPDISP_LO16
+relocation.  */
+  BFD_RELOC_ALPHA_GPDISP,
+
+/* The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
+the assembler turns it into a LDQ instruction to load the address of
+the symbol, and then fills in a register in the real instruction.
+
+The LITERAL reloc, at the LDQ instruction, refers to the .lita
+section symbol.  The addend is ignored when writing, but is filled
+in with the file's GP value on reading, for convenience, as with the
+GPDISP_LO16 reloc.
+
+The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
+It should refer to the symbol to be referenced, as with 16_GOTOFF,
+but it generates output not based on the position within the .got
+section, but relative to the GP value chosen for the file during the
+final link stage.
+
+The LITUSE reloc, on the instruction using the loaded address, gives
+information to the linker that it might be able to use to optimize
+away some literal section references.  The symbol is ignored (read
+as the absolute section symbol), and the "addend" indicates the type
+of instruction using the register:
+1 - "memory" fmt insn
+2 - byte-manipulation (byte offset reg)
+3 - jsr (target of branch)  */
+  BFD_RELOC_ALPHA_LITERAL,
+  BFD_RELOC_ALPHA_ELF_LITERAL,
+  BFD_RELOC_ALPHA_LITUSE,
+
+/* The HINT relocation indicates a value that should be filled into the
+"hint" field of a jmp/jsr/ret instruction, for possible branch-
+prediction logic which may be provided on some processors.  */
+  BFD_RELOC_ALPHA_HINT,
+
+/* The LINKAGE relocation outputs a linkage pair in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_LINKAGE,
+
+/* The CODEADDR relocation outputs a STO_CA in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_CODEADDR,
+
+/* The GPREL_HI/LO relocations together form a 32-bit offset from the
+GP register.  */
+  BFD_RELOC_ALPHA_GPREL_HI16,
+  BFD_RELOC_ALPHA_GPREL_LO16,
+
+/* Like BFD_RELOC_23_PCREL_S2, except that the source and target must
+share a common GP, and the target address is adjusted for
+STO_ALPHA_STD_GPLOAD.  */
+  BFD_RELOC_ALPHA_BRSGP,
+
+/* Alpha thread-local storage relocations.  */
+  BFD_RELOC_ALPHA_TLSGD,
+  BFD_RELOC_ALPHA_TLSLDM,
+  BFD_RELOC_ALPHA_DTPMOD64,
+  BFD_RELOC_ALPHA_GOTDTPREL16,
+  BFD_RELOC_ALPHA_DTPREL64,
+  BFD_RELOC_ALPHA_DTPREL_HI16,
+  BFD_RELOC_ALPHA_DTPREL_LO16,
+  BFD_RELOC_ALPHA_DTPREL16,
+  BFD_RELOC_ALPHA_GOTTPREL16,
+  BFD_RELOC_ALPHA_TPREL64,
+  BFD_RELOC_ALPHA_TPREL_HI16,
+  BFD_RELOC_ALPHA_TPREL_LO16,
+  BFD_RELOC_ALPHA_TPREL16,
+
+/* Bits 27..2 of the relocation address shifted right 2 bits;
+simple reloc otherwise.  */
+  BFD_RELOC_MIPS_JMP,
+
+/* The MIPS16 jump instruction.  */
+  BFD_RELOC_MIPS16_JMP,
+
+/* MIPS16 GP relative reloc.  */
+  BFD_RELOC_MIPS16_GPREL,
+
+/* High 16 bits of 32-bit value; simple reloc.  */
+  BFD_RELOC_HI16,
+
+/* High 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_HI16_S,
+
+/* Low 16 bits.  */
+  BFD_RELOC_LO16,
+
+/* High 16 bits of 32-bit pc-relative value  */
+  BFD_RELOC_HI16_PCREL,
+
+/* High 16 bits of 32-bit pc-relative value, adjusted  */
+  BFD_RELOC_HI16_S_PCREL,
+
+/* Low 16 bits of pc-relative value  */
+  BFD_RELOC_LO16_PCREL,
+
+/* MIPS16 high 16 bits of 32-bit value.  */
+  BFD_RELOC_MIPS16_HI16,
+
+/* MIPS16 high 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_MIPS16_HI16_S,
+
+/* MIPS16 low 16 bits.  */
+  BFD_RELOC_MIPS16_LO16,
+
+/* Relocation against a MIPS literal section.  */
+  BFD_RELOC_MIPS_LITERAL,
+
+/* MIPS ELF relocations.  */
+  BFD_RELOC_MIPS_GOT16,
+  BFD_RELOC_MIPS_CALL16,
+  BFD_RELOC_MIPS_GOT_HI16,
+  BFD_RELOC_MIPS_GOT_LO16,
+  BFD_RELOC_MIPS_CALL_HI16,
+  BFD_RELOC_MIPS_CALL_LO16,
+  BFD_RELOC_MIPS_SUB,
+  BFD_RELOC_MIPS_GOT_PAGE,
+  BFD_RELOC_MIPS_GOT_OFST,
+  BFD_RELOC_MIPS_GOT_DISP,
+  BFD_RELOC_MIPS_SHIFT5,
+  BFD_RELOC_MIPS_SHIFT6,
+  BFD_RELOC_MIPS_INSERT_A,
+  BFD_RELOC_MIPS_INSERT_B,
+  BFD_RELOC_MIPS_DELETE,
+  BFD_RELOC_MIPS_HIGHEST,
+  BFD_RELOC_MIPS_HIGHER,
+  BFD_RELOC_MIPS_SCN_DISP,
+  BFD_RELOC_MIPS_REL16,
+  BFD_RELOC_MIPS_RELGOT,
+  BFD_RELOC_MIPS_JALR,
+  BFD_RELOC_MIPS_TLS_DTPMOD32,
+  BFD_RELOC_MIPS_TLS_DTPREL32,
+  BFD_RELOC_MIPS_TLS_DTPMOD64,
+  BFD_RELOC_MIPS_TLS_DTPREL64,
+  BFD_RELOC_MIPS_TLS_GD,
+  BFD_RELOC_MIPS_TLS_LDM,
+  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
+  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
+  BFD_RELOC_MIPS_TLS_GOTTPREL,
+  BFD_RELOC_MIPS_TLS_TPREL32,
+  BFD_RELOC_MIPS_TLS_TPREL64,
+  BFD_RELOC_MIPS_TLS_TPREL_HI16,
+  BFD_RELOC_MIPS_TLS_TPREL_LO16,
+
+
+/* MIPS ELF relocations (VxWorks extensions).  */
+  BFD_RELOC_MIPS_COPY,
+  BFD_RELOC_MIPS_JUMP_SLOT,
+
+
+/* Fujitsu Frv Relocations.  */
+  BFD_RELOC_FRV_LABEL16,
+  BFD_RELOC_FRV_LABEL24,
+  BFD_RELOC_FRV_LO16,
+  BFD_RELOC_FRV_HI16,
+  BFD_RELOC_FRV_GPREL12,
+  BFD_RELOC_FRV_GPRELU12,
+  BFD_RELOC_FRV_GPREL32,
+  BFD_RELOC_FRV_GPRELHI,
+  BFD_RELOC_FRV_GPRELLO,
+  BFD_RELOC_FRV_GOT12,
+  BFD_RELOC_FRV_GOTHI,
+  BFD_RELOC_FRV_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC,
+  BFD_RELOC_FRV_FUNCDESC_GOT12,
+  BFD_RELOC_FRV_FUNCDESC_GOTHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC_VALUE,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_FRV_GOTOFF12,
+  BFD_RELOC_FRV_GOTOFFHI,
+  BFD_RELOC_FRV_GOTOFFLO,
+  BFD_RELOC_FRV_GETTLSOFF,
+  BFD_RELOC_FRV_TLSDESC_VALUE,
+  BFD_RELOC_FRV_GOTTLSDESC12,
+  BFD_RELOC_FRV_GOTTLSDESCHI,
+  BFD_RELOC_FRV_GOTTLSDESCLO,
+  BFD_RELOC_FRV_TLSMOFF12,
+  BFD_RELOC_FRV_TLSMOFFHI,
+  BFD_RELOC_FRV_TLSMOFFLO,
+  BFD_RELOC_FRV_GOTTLSOFF12,
+  BFD_RELOC_FRV_GOTTLSOFFHI,
+  BFD_RELOC_FRV_GOTTLSOFFLO,
+  BFD_RELOC_FRV_TLSOFF,
+  BFD_RELOC_FRV_TLSDESC_RELAX,
+  BFD_RELOC_FRV_GETTLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSMOFF,
+
+
+/* This is a 24bit GOT-relative reloc for the mn10300.  */
+  BFD_RELOC_MN10300_GOTOFF24,
+
+/* This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT32,
+
+/* This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT24,
+
+/* This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT16,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_MN10300_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_MN10300_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_MN10300_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_MN10300_RELATIVE,
+
+
+/* i386/elf relocations  */
+  BFD_RELOC_386_GOT32,
+  BFD_RELOC_386_PLT32,
+  BFD_RELOC_386_COPY,
+  BFD_RELOC_386_GLOB_DAT,
+  BFD_RELOC_386_JUMP_SLOT,
+  BFD_RELOC_386_RELATIVE,
+  BFD_RELOC_386_GOTOFF,
+  BFD_RELOC_386_GOTPC,
+  BFD_RELOC_386_TLS_TPOFF,
+  BFD_RELOC_386_TLS_IE,
+  BFD_RELOC_386_TLS_GOTIE,
+  BFD_RELOC_386_TLS_LE,
+  BFD_RELOC_386_TLS_GD,
+  BFD_RELOC_386_TLS_LDM,
+  BFD_RELOC_386_TLS_LDO_32,
+  BFD_RELOC_386_TLS_IE_32,
+  BFD_RELOC_386_TLS_LE_32,
+  BFD_RELOC_386_TLS_DTPMOD32,
+  BFD_RELOC_386_TLS_DTPOFF32,
+  BFD_RELOC_386_TLS_TPOFF32,
+  BFD_RELOC_386_TLS_GOTDESC,
+  BFD_RELOC_386_TLS_DESC_CALL,
+  BFD_RELOC_386_TLS_DESC,
+
+/* x86-64/elf relocations  */
+  BFD_RELOC_X86_64_GOT32,
+  BFD_RELOC_X86_64_PLT32,
+  BFD_RELOC_X86_64_COPY,
+  BFD_RELOC_X86_64_GLOB_DAT,
+  BFD_RELOC_X86_64_JUMP_SLOT,
+  BFD_RELOC_X86_64_RELATIVE,
+  BFD_RELOC_X86_64_GOTPCREL,
+  BFD_RELOC_X86_64_32S,
+  BFD_RELOC_X86_64_DTPMOD64,
+  BFD_RELOC_X86_64_DTPOFF64,
+  BFD_RELOC_X86_64_TPOFF64,
+  BFD_RELOC_X86_64_TLSGD,
+  BFD_RELOC_X86_64_TLSLD,
+  BFD_RELOC_X86_64_DTPOFF32,
+  BFD_RELOC_X86_64_GOTTPOFF,
+  BFD_RELOC_X86_64_TPOFF32,
+  BFD_RELOC_X86_64_GOTOFF64,
+  BFD_RELOC_X86_64_GOTPC32,
+  BFD_RELOC_X86_64_GOT64,
+  BFD_RELOC_X86_64_GOTPCREL64,
+  BFD_RELOC_X86_64_GOTPC64,
+  BFD_RELOC_X86_64_GOTPLT64,
+  BFD_RELOC_X86_64_PLTOFF64,
+  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
+  BFD_RELOC_X86_64_TLSDESC_CALL,
+  BFD_RELOC_X86_64_TLSDESC,
+
+/* ns32k relocations  */
+  BFD_RELOC_NS32K_IMM_8,
+  BFD_RELOC_NS32K_IMM_16,
+  BFD_RELOC_NS32K_IMM_32,
+  BFD_RELOC_NS32K_IMM_8_PCREL,
+  BFD_RELOC_NS32K_IMM_16_PCREL,
+  BFD_RELOC_NS32K_IMM_32_PCREL,
+  BFD_RELOC_NS32K_DISP_8,
+  BFD_RELOC_NS32K_DISP_16,
+  BFD_RELOC_NS32K_DISP_32,
+  BFD_RELOC_NS32K_DISP_8_PCREL,
+  BFD_RELOC_NS32K_DISP_16_PCREL,
+  BFD_RELOC_NS32K_DISP_32_PCREL,
+
+/* PDP11 relocations  */
+  BFD_RELOC_PDP11_DISP_8_PCREL,
+  BFD_RELOC_PDP11_DISP_6_PCREL,
+
+/* Picojava relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_PJ_CODE_HI16,
+  BFD_RELOC_PJ_CODE_LO16,
+  BFD_RELOC_PJ_CODE_DIR16,
+  BFD_RELOC_PJ_CODE_DIR32,
+  BFD_RELOC_PJ_CODE_REL16,
+  BFD_RELOC_PJ_CODE_REL32,
+
+/* Power(rs6000) and PowerPC relocations.  */
+  BFD_RELOC_PPC_B26,
+  BFD_RELOC_PPC_BA26,
+  BFD_RELOC_PPC_TOC16,
+  BFD_RELOC_PPC_B16,
+  BFD_RELOC_PPC_B16_BRTAKEN,
+  BFD_RELOC_PPC_B16_BRNTAKEN,
+  BFD_RELOC_PPC_BA16,
+  BFD_RELOC_PPC_BA16_BRTAKEN,
+  BFD_RELOC_PPC_BA16_BRNTAKEN,
+  BFD_RELOC_PPC_COPY,
+  BFD_RELOC_PPC_GLOB_DAT,
+  BFD_RELOC_PPC_JMP_SLOT,
+  BFD_RELOC_PPC_RELATIVE,
+  BFD_RELOC_PPC_LOCAL24PC,
+  BFD_RELOC_PPC_EMB_NADDR32,
+  BFD_RELOC_PPC_EMB_NADDR16,
+  BFD_RELOC_PPC_EMB_NADDR16_LO,
+  BFD_RELOC_PPC_EMB_NADDR16_HI,
+  BFD_RELOC_PPC_EMB_NADDR16_HA,
+  BFD_RELOC_PPC_EMB_SDAI16,
+  BFD_RELOC_PPC_EMB_SDA2I16,
+  BFD_RELOC_PPC_EMB_SDA2REL,
+  BFD_RELOC_PPC_EMB_SDA21,
+  BFD_RELOC_PPC_EMB_MRKREF,
+  BFD_RELOC_PPC_EMB_RELSEC16,
+  BFD_RELOC_PPC_EMB_RELST_LO,
+  BFD_RELOC_PPC_EMB_RELST_HI,
+  BFD_RELOC_PPC_EMB_RELST_HA,
+  BFD_RELOC_PPC_EMB_BIT_FLD,
+  BFD_RELOC_PPC_EMB_RELSDA,
+  BFD_RELOC_PPC64_HIGHER,
+  BFD_RELOC_PPC64_HIGHER_S,
+  BFD_RELOC_PPC64_HIGHEST,
+  BFD_RELOC_PPC64_HIGHEST_S,
+  BFD_RELOC_PPC64_TOC16_LO,
+  BFD_RELOC_PPC64_TOC16_HI,
+  BFD_RELOC_PPC64_TOC16_HA,
+  BFD_RELOC_PPC64_TOC,
+  BFD_RELOC_PPC64_PLTGOT16,
+  BFD_RELOC_PPC64_PLTGOT16_LO,
+  BFD_RELOC_PPC64_PLTGOT16_HI,
+  BFD_RELOC_PPC64_PLTGOT16_HA,
+  BFD_RELOC_PPC64_ADDR16_DS,
+  BFD_RELOC_PPC64_ADDR16_LO_DS,
+  BFD_RELOC_PPC64_GOT16_DS,
+  BFD_RELOC_PPC64_GOT16_LO_DS,
+  BFD_RELOC_PPC64_PLT16_LO_DS,
+  BFD_RELOC_PPC64_SECTOFF_DS,
+  BFD_RELOC_PPC64_SECTOFF_LO_DS,
+  BFD_RELOC_PPC64_TOC16_DS,
+  BFD_RELOC_PPC64_TOC16_LO_DS,
+  BFD_RELOC_PPC64_PLTGOT16_DS,
+  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
+
+/* PowerPC and PowerPC64 thread-local storage relocations.  */
+  BFD_RELOC_PPC_TLS,
+  BFD_RELOC_PPC_DTPMOD,
+  BFD_RELOC_PPC_TPREL16,
+  BFD_RELOC_PPC_TPREL16_LO,
+  BFD_RELOC_PPC_TPREL16_HI,
+  BFD_RELOC_PPC_TPREL16_HA,
+  BFD_RELOC_PPC_TPREL,
+  BFD_RELOC_PPC_DTPREL16,
+  BFD_RELOC_PPC_DTPREL16_LO,
+  BFD_RELOC_PPC_DTPREL16_HI,
+  BFD_RELOC_PPC_DTPREL16_HA,
+  BFD_RELOC_PPC_DTPREL,
+  BFD_RELOC_PPC_GOT_TLSGD16,
+  BFD_RELOC_PPC_GOT_TLSGD16_LO,
+  BFD_RELOC_PPC_GOT_TLSGD16_HI,
+  BFD_RELOC_PPC_GOT_TLSGD16_HA,
+  BFD_RELOC_PPC_GOT_TLSLD16,
+  BFD_RELOC_PPC_GOT_TLSLD16_LO,
+  BFD_RELOC_PPC_GOT_TLSLD16_HI,
+  BFD_RELOC_PPC_GOT_TLSLD16_HA,
+  BFD_RELOC_PPC_GOT_TPREL16,
+  BFD_RELOC_PPC_GOT_TPREL16_LO,
+  BFD_RELOC_PPC_GOT_TPREL16_HI,
+  BFD_RELOC_PPC_GOT_TPREL16_HA,
+  BFD_RELOC_PPC_GOT_DTPREL16,
+  BFD_RELOC_PPC_GOT_DTPREL16_LO,
+  BFD_RELOC_PPC_GOT_DTPREL16_HI,
+  BFD_RELOC_PPC_GOT_DTPREL16_HA,
+  BFD_RELOC_PPC64_TPREL16_DS,
+  BFD_RELOC_PPC64_TPREL16_LO_DS,
+  BFD_RELOC_PPC64_TPREL16_HIGHER,
+  BFD_RELOC_PPC64_TPREL16_HIGHERA,
+  BFD_RELOC_PPC64_TPREL16_HIGHEST,
+  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
+  BFD_RELOC_PPC64_DTPREL16_DS,
+  BFD_RELOC_PPC64_DTPREL16_LO_DS,
+  BFD_RELOC_PPC64_DTPREL16_HIGHER,
+  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
+  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
+  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
+
+/* IBM 370/390 relocations  */
+  BFD_RELOC_I370_D12,
+
+/* The type of reloc used to build a constructor table - at the moment
+probably a 32 bit wide absolute relocation, but the target can choose.
+It generally does map to one of the other relocation types.  */
+  BFD_RELOC_CTOR,
+
+/* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BRANCH,
+
+/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BLX,
+
+/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_THUMB_PCREL_BLX,
+
+/* ARM 26-bit pc-relative branch for an unconditional BL or BLX instruction.  */
+  BFD_RELOC_ARM_PCREL_CALL,
+
+/* ARM 26-bit pc-relative branch for B or conditional BL instruction.  */
+  BFD_RELOC_ARM_PCREL_JUMP,
+
+/* Thumb 7-, 9-, 12-, 20-, 23-, and 25-bit pc-relative branches.
+The lowest bit must be zero and is not stored in the instruction.
+Note that the corresponding ELF R_ARM_THM_JUMPnn constant has an
+"nn" one smaller in all cases.  Note further that BRANCH23
+corresponds to R_ARM_THM_CALL.  */
+  BFD_RELOC_THUMB_PCREL_BRANCH7,
+  BFD_RELOC_THUMB_PCREL_BRANCH9,
+  BFD_RELOC_THUMB_PCREL_BRANCH12,
+  BFD_RELOC_THUMB_PCREL_BRANCH20,
+  BFD_RELOC_THUMB_PCREL_BRANCH23,
+  BFD_RELOC_THUMB_PCREL_BRANCH25,
+
+/* 12-bit immediate offset, used in ARM-format ldr and str instructions.  */
+  BFD_RELOC_ARM_OFFSET_IMM,
+
+/* 5-bit immediate offset, used in Thumb-format ldr and str instructions.  */
+  BFD_RELOC_ARM_THUMB_OFFSET,
+
+/* Pc-relative or absolute relocation depending on target.  Used for
+entries in .init_array sections.  */
+  BFD_RELOC_ARM_TARGET1,
+
+/* Read-only segment base relative address.  */
+  BFD_RELOC_ARM_ROSEGREL32,
+
+/* Data segment base relative address.  */
+  BFD_RELOC_ARM_SBREL32,
+
+/* This reloc is used for references to RTTI data from exception handling
+tables.  The actual definition depends on the target.  It may be a
+pc-relative or some form of GOT-indirect relocation.  */
+  BFD_RELOC_ARM_TARGET2,
+
+/* 31-bit PC relative address.  */
+  BFD_RELOC_ARM_PREL31,
+
+/* Low and High halfword relocations for MOVW and MOVT instructions.  */
+  BFD_RELOC_ARM_MOVW,
+  BFD_RELOC_ARM_MOVT,
+  BFD_RELOC_ARM_MOVW_PCREL,
+  BFD_RELOC_ARM_MOVT_PCREL,
+  BFD_RELOC_ARM_THUMB_MOVW,
+  BFD_RELOC_ARM_THUMB_MOVT,
+  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
+  BFD_RELOC_ARM_THUMB_MOVT_PCREL,
+
+/* Relocations for setting up GOTs and PLTs for shared libraries.  */
+  BFD_RELOC_ARM_JUMP_SLOT,
+  BFD_RELOC_ARM_GLOB_DAT,
+  BFD_RELOC_ARM_GOT32,
+  BFD_RELOC_ARM_PLT32,
+  BFD_RELOC_ARM_RELATIVE,
+  BFD_RELOC_ARM_GOTOFF,
+  BFD_RELOC_ARM_GOTPC,
+
+/* ARM thread-local storage relocations.  */
+  BFD_RELOC_ARM_TLS_GD32,
+  BFD_RELOC_ARM_TLS_LDO32,
+  BFD_RELOC_ARM_TLS_LDM32,
+  BFD_RELOC_ARM_TLS_DTPOFF32,
+  BFD_RELOC_ARM_TLS_DTPMOD32,
+  BFD_RELOC_ARM_TLS_TPOFF32,
+  BFD_RELOC_ARM_TLS_IE32,
+  BFD_RELOC_ARM_TLS_LE32,
+
+/* ARM group relocations.  */
+  BFD_RELOC_ARM_ALU_PC_G0_NC,
+  BFD_RELOC_ARM_ALU_PC_G0,
+  BFD_RELOC_ARM_ALU_PC_G1_NC,
+  BFD_RELOC_ARM_ALU_PC_G1,
+  BFD_RELOC_ARM_ALU_PC_G2,
+  BFD_RELOC_ARM_LDR_PC_G0,
+  BFD_RELOC_ARM_LDR_PC_G1,
+  BFD_RELOC_ARM_LDR_PC_G2,
+  BFD_RELOC_ARM_LDRS_PC_G0,
+  BFD_RELOC_ARM_LDRS_PC_G1,
+  BFD_RELOC_ARM_LDRS_PC_G2,
+  BFD_RELOC_ARM_LDC_PC_G0,
+  BFD_RELOC_ARM_LDC_PC_G1,
+  BFD_RELOC_ARM_LDC_PC_G2,
+  BFD_RELOC_ARM_ALU_SB_G0_NC,
+  BFD_RELOC_ARM_ALU_SB_G0,
+  BFD_RELOC_ARM_ALU_SB_G1_NC,
+  BFD_RELOC_ARM_ALU_SB_G1,
+  BFD_RELOC_ARM_ALU_SB_G2,
+  BFD_RELOC_ARM_LDR_SB_G0,
+  BFD_RELOC_ARM_LDR_SB_G1,
+  BFD_RELOC_ARM_LDR_SB_G2,
+  BFD_RELOC_ARM_LDRS_SB_G0,
+  BFD_RELOC_ARM_LDRS_SB_G1,
+  BFD_RELOC_ARM_LDRS_SB_G2,
+  BFD_RELOC_ARM_LDC_SB_G0,
+  BFD_RELOC_ARM_LDC_SB_G1,
+  BFD_RELOC_ARM_LDC_SB_G2,
+
+/* These relocs are only used within the ARM assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_ARM_IMMEDIATE,
+  BFD_RELOC_ARM_ADRL_IMMEDIATE,
+  BFD_RELOC_ARM_T32_IMMEDIATE,
+  BFD_RELOC_ARM_T32_ADD_IMM,
+  BFD_RELOC_ARM_T32_IMM12,
+  BFD_RELOC_ARM_T32_ADD_PC12,
+  BFD_RELOC_ARM_SHIFT_IMM,
+  BFD_RELOC_ARM_SMC,
+  BFD_RELOC_ARM_SWI,
+  BFD_RELOC_ARM_MULTI,
+  BFD_RELOC_ARM_CP_OFF_IMM,
+  BFD_RELOC_ARM_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_ADR_IMM,
+  BFD_RELOC_ARM_LDR_IMM,
+  BFD_RELOC_ARM_LITERAL,
+  BFD_RELOC_ARM_IN_POOL,
+  BFD_RELOC_ARM_OFFSET_IMM8,
+  BFD_RELOC_ARM_T32_OFFSET_U8,
+  BFD_RELOC_ARM_T32_OFFSET_IMM,
+  BFD_RELOC_ARM_HWLITERAL,
+  BFD_RELOC_ARM_THUMB_ADD,
+  BFD_RELOC_ARM_THUMB_IMM,
+  BFD_RELOC_ARM_THUMB_SHIFT,
+
+/* Renesas / SuperH SH relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_SH_PCDISP8BY2,
+  BFD_RELOC_SH_PCDISP12BY2,
+  BFD_RELOC_SH_IMM3,
+  BFD_RELOC_SH_IMM3U,
+  BFD_RELOC_SH_DISP12,
+  BFD_RELOC_SH_DISP12BY2,
+  BFD_RELOC_SH_DISP12BY4,
+  BFD_RELOC_SH_DISP12BY8,
+  BFD_RELOC_SH_DISP20,
+  BFD_RELOC_SH_DISP20BY8,
+  BFD_RELOC_SH_IMM4,
+  BFD_RELOC_SH_IMM4BY2,
+  BFD_RELOC_SH_IMM4BY4,
+  BFD_RELOC_SH_IMM8,
+  BFD_RELOC_SH_IMM8BY2,
+  BFD_RELOC_SH_IMM8BY4,
+  BFD_RELOC_SH_PCRELIMM8BY2,
+  BFD_RELOC_SH_PCRELIMM8BY4,
+  BFD_RELOC_SH_SWITCH16,
+  BFD_RELOC_SH_SWITCH32,
+  BFD_RELOC_SH_USES,
+  BFD_RELOC_SH_COUNT,
+  BFD_RELOC_SH_ALIGN,
+  BFD_RELOC_SH_CODE,
+  BFD_RELOC_SH_DATA,
+  BFD_RELOC_SH_LABEL,
+  BFD_RELOC_SH_LOOP_START,
+  BFD_RELOC_SH_LOOP_END,
+  BFD_RELOC_SH_COPY,
+  BFD_RELOC_SH_GLOB_DAT,
+  BFD_RELOC_SH_JMP_SLOT,
+  BFD_RELOC_SH_RELATIVE,
+  BFD_RELOC_SH_GOTPC,
+  BFD_RELOC_SH_GOT_LOW16,
+  BFD_RELOC_SH_GOT_MEDLOW16,
+  BFD_RELOC_SH_GOT_MEDHI16,
+  BFD_RELOC_SH_GOT_HI16,
+  BFD_RELOC_SH_GOTPLT_LOW16,
+  BFD_RELOC_SH_GOTPLT_MEDLOW16,
+  BFD_RELOC_SH_GOTPLT_MEDHI16,
+  BFD_RELOC_SH_GOTPLT_HI16,
+  BFD_RELOC_SH_PLT_LOW16,
+  BFD_RELOC_SH_PLT_MEDLOW16,
+  BFD_RELOC_SH_PLT_MEDHI16,
+  BFD_RELOC_SH_PLT_HI16,
+  BFD_RELOC_SH_GOTOFF_LOW16,
+  BFD_RELOC_SH_GOTOFF_MEDLOW16,
+  BFD_RELOC_SH_GOTOFF_MEDHI16,
+  BFD_RELOC_SH_GOTOFF_HI16,
+  BFD_RELOC_SH_GOTPC_LOW16,
+  BFD_RELOC_SH_GOTPC_MEDLOW16,
+  BFD_RELOC_SH_GOTPC_MEDHI16,
+  BFD_RELOC_SH_GOTPC_HI16,
+  BFD_RELOC_SH_COPY64,
+  BFD_RELOC_SH_GLOB_DAT64,
+  BFD_RELOC_SH_JMP_SLOT64,
+  BFD_RELOC_SH_RELATIVE64,
+  BFD_RELOC_SH_GOT10BY4,
+  BFD_RELOC_SH_GOT10BY8,
+  BFD_RELOC_SH_GOTPLT10BY4,
+  BFD_RELOC_SH_GOTPLT10BY8,
+  BFD_RELOC_SH_GOTPLT32,
+  BFD_RELOC_SH_SHMEDIA_CODE,
+  BFD_RELOC_SH_IMMU5,
+  BFD_RELOC_SH_IMMS6,
+  BFD_RELOC_SH_IMMS6BY32,
+  BFD_RELOC_SH_IMMU6,
+  BFD_RELOC_SH_IMMS10,
+  BFD_RELOC_SH_IMMS10BY2,
+  BFD_RELOC_SH_IMMS10BY4,
+  BFD_RELOC_SH_IMMS10BY8,
+  BFD_RELOC_SH_IMMS16,
+  BFD_RELOC_SH_IMMU16,
+  BFD_RELOC_SH_IMM_LOW16,
+  BFD_RELOC_SH_IMM_LOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDLOW16,
+  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDHI16,
+  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
+  BFD_RELOC_SH_IMM_HI16,
+  BFD_RELOC_SH_IMM_HI16_PCREL,
+  BFD_RELOC_SH_PT_16,
+  BFD_RELOC_SH_TLS_GD_32,
+  BFD_RELOC_SH_TLS_LD_32,
+  BFD_RELOC_SH_TLS_LDO_32,
+  BFD_RELOC_SH_TLS_IE_32,
+  BFD_RELOC_SH_TLS_LE_32,
+  BFD_RELOC_SH_TLS_DTPMOD32,
+  BFD_RELOC_SH_TLS_DTPOFF32,
+  BFD_RELOC_SH_TLS_TPOFF32,
+
+/* ARC Cores relocs.
+ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  The high 20 bits are installed in bits 26
+through 7 of the instruction.  */
+  BFD_RELOC_ARC_B22_PCREL,
+
+/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
+stored in the instruction.  The high 24 bits are installed in bits 23
+through 0.  */
+  BFD_RELOC_ARC_B26,
+
+/* ADI Blackfin 16 bit immediate absolute reloc.  */
+  BFD_RELOC_BFIN_16_IMM,
+
+/* ADI Blackfin 16 bit immediate absolute reloc higher 16 bits.  */
+  BFD_RELOC_BFIN_16_HIGH,
+
+/* ADI Blackfin 'a' part of LSETUP.  */
+  BFD_RELOC_BFIN_4_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_5_PCREL,
+
+/* ADI Blackfin 16 bit immediate absolute reloc lower 16 bits.  */
+  BFD_RELOC_BFIN_16_LOW,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_10_PCREL,
+
+/* ADI Blackfin 'b' part of LSETUP.  */
+  BFD_RELOC_BFIN_11_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP,
+
+/* ADI Blackfin Short jump, pcrel.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP_S,
+
+/* ADI Blackfin Call.x not implemented.  */
+  BFD_RELOC_BFIN_24_PCREL_CALL_X,
+
+/* ADI Blackfin Long Jump pcrel.  */
+  BFD_RELOC_BFIN_24_PCREL_JUMP_L,
+
+/* ADI Blackfin FD-PIC relocations.  */
+  BFD_RELOC_BFIN_GOT17M4,
+  BFD_RELOC_BFIN_GOTHI,
+  BFD_RELOC_BFIN_GOTLO,
+  BFD_RELOC_BFIN_FUNCDESC,
+  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
+  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
+  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
+  BFD_RELOC_BFIN_FUNCDESC_VALUE,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_BFIN_GOTOFF17M4,
+  BFD_RELOC_BFIN_GOTOFFHI,
+  BFD_RELOC_BFIN_GOTOFFLO,
+
+/* ADI Blackfin GOT relocation.  */
+  BFD_RELOC_BFIN_GOT,
+
+/* ADI Blackfin PLTPC relocation.  */
+  BFD_RELOC_BFIN_PLTPC,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PUSH,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_CONST,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_SUB,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MULT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_DIV,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MOD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_RSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_AND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_OR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_XOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LAND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LEN,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_NEG,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_COMP,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_HWPAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADDR,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_10_PCREL_R,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  This is the same as the previous reloc
+except it is in the left container, i.e.,
+shifted left 15 bits.  */
+  BFD_RELOC_D10V_10_PCREL_L,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18_PCREL,
+
+/* Mitsubishi D30V relocs.
+This is a 6-bit absolute reloc.  */
+  BFD_RELOC_D30V_6,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_9_PCREL,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_9_PCREL_R,
+
+/* This is a 12-bit absolute reloc with the
+right 3 bitsassumed to be 0.  */
+  BFD_RELOC_D30V_15,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_15_PCREL,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_15_PCREL_R,
+
+/* This is an 18-bit absolute reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21_PCREL,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_21_PCREL_R,
+
+/* This is a 32-bit absolute reloc.  */
+  BFD_RELOC_D30V_32,
+
+/* This is a 32-bit pc-relative reloc.  */
+  BFD_RELOC_D30V_32_PCREL,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_HI16_S,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_LO16,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_JMP26,
+
+/* Renesas M16C/M32C Relocations.  */
+  BFD_RELOC_M32C_HI8,
+  BFD_RELOC_M32C_RL_JUMP,
+  BFD_RELOC_M32C_RL_1ADDR,
+  BFD_RELOC_M32C_RL_2ADDR,
+
+/* Renesas M32R (formerly Mitsubishi M32R) relocs.
+This is a 24 bit absolute address.  */
+  BFD_RELOC_M32R_24,
+
+/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_10_PCREL,
+
+/* This is an 18-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_18_PCREL,
+
+/* This is a 26-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_26_PCREL,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as unsigned.  */
+  BFD_RELOC_M32R_HI16_ULO,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as signed.  */
+  BFD_RELOC_M32R_HI16_SLO,
+
+/* This is a 16-bit reloc containing the lower 16 bits of an address.  */
+  BFD_RELOC_M32R_LO16,
+
+/* This is a 16-bit reloc containing the small data area offset for use in
+add3, load, and store instructions.  */
+  BFD_RELOC_M32R_SDA16,
+
+/* For PIC.  */
+  BFD_RELOC_M32R_GOT24,
+  BFD_RELOC_M32R_26_PLTREL,
+  BFD_RELOC_M32R_COPY,
+  BFD_RELOC_M32R_GLOB_DAT,
+  BFD_RELOC_M32R_JMP_SLOT,
+  BFD_RELOC_M32R_RELATIVE,
+  BFD_RELOC_M32R_GOTOFF,
+  BFD_RELOC_M32R_GOTOFF_HI_ULO,
+  BFD_RELOC_M32R_GOTOFF_HI_SLO,
+  BFD_RELOC_M32R_GOTOFF_LO,
+  BFD_RELOC_M32R_GOTPC24,
+  BFD_RELOC_M32R_GOT16_HI_ULO,
+  BFD_RELOC_M32R_GOT16_HI_SLO,
+  BFD_RELOC_M32R_GOT16_LO,
+  BFD_RELOC_M32R_GOTPC_HI_ULO,
+  BFD_RELOC_M32R_GOTPC_HI_SLO,
+  BFD_RELOC_M32R_GOTPC_LO,
+
+/* This is a 9-bit reloc  */
+  BFD_RELOC_V850_9_PCREL,
+
+/* This is a 22-bit reloc  */
+  BFD_RELOC_V850_22_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer.  */
+  BFD_RELOC_V850_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+short data area pointer.  */
+  BFD_RELOC_V850_SDA_15_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_15_16_OFFSET,
+
+/* This is an 8 bit offset (of which only 6 bits are used) from the
+tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_6_8_OFFSET,
+
+/* This is an 8bit offset (of which only 7 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_7_8_OFFSET,
+
+/* This is a 7 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_7_7_OFFSET,
+
+/* This is a 16 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_16_16_OFFSET,
+
+/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_4_5_OFFSET,
+
+/* This is a 4 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_4_4_OFFSET,
+
+/* This is a 16 bit offset from the short data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,
+
+/* This is a 6 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_6_7_OFFSET,
+
+/* This is a 16 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_16_16_OFFSET,
+
+/* Used for relaxing indirect function calls.  */
+  BFD_RELOC_V850_LONGCALL,
+
+/* Used for relaxing indirect jumps.  */
+  BFD_RELOC_V850_LONGJUMP,
+
+/* Used to maintain alignment whilst relaxing.  */
+  BFD_RELOC_V850_ALIGN,
+
+/* This is a variation of BFD_RELOC_LO16 that can be used in v850e ld.bu
+instructions.  */
+  BFD_RELOC_V850_LO16_SPLIT_OFFSET,
+
+/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_32_PCREL,
+
+/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_16_PCREL,
+
+/* This is a 8bit DP reloc for the tms320c30, where the most
+significant 8 bits of a 24 bit word are placed into the least
+significant 8 bits of the opcode.  */
+  BFD_RELOC_TIC30_LDP,
+
+/* This is a 7bit reloc for the tms320c54x, where the least
+significant 7 bits of a 16 bit word are placed into the least
+significant 7 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTLS7,
+
+/* This is a 9bit DP reloc for the tms320c54x, where the most
+significant 9 bits of a 16 bit word are placed into the least
+significant 9 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTMS9,
+
+/* This is an extended address 23-bit reloc for the tms320c54x.  */
+  BFD_RELOC_TIC54X_23,
+
+/* This is a 16-bit reloc for the tms320c54x, where the least
+significant 16 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_16_OF_23,
+
+/* This is a reloc for the tms320c54x, where the most
+significant 7 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_MS7_OF_23,
+
+/* This is a 48 bit reloc for the FR30 that stores 32 bits.  */
+  BFD_RELOC_FR30_48,
+
+/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
+two sections.  */
+  BFD_RELOC_FR30_20,
+
+/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
+4 bits.  */
+  BFD_RELOC_FR30_6_IN_4,
+
+/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
+into 8 bits.  */
+  BFD_RELOC_FR30_8_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
+into 8 bits.  */
+  BFD_RELOC_FR30_9_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
+into 8 bits.  */
+  BFD_RELOC_FR30_10_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
+short offset into 8 bits.  */
+  BFD_RELOC_FR30_9_PCREL,
+
+/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
+short offset into 11 bits.  */
+  BFD_RELOC_FR30_12_PCREL,
+
+/* Motorola Mcore relocations.  */
+  BFD_RELOC_MCORE_PCREL_IMM8BY4,
+  BFD_RELOC_MCORE_PCREL_IMM11BY2,
+  BFD_RELOC_MCORE_PCREL_IMM4BY2,
+  BFD_RELOC_MCORE_PCREL_32,
+  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
+  BFD_RELOC_MCORE_RVA,
+
+/* Toshiba Media Processor Relocations.  */
+  BFD_RELOC_MEP_8,
+  BFD_RELOC_MEP_16,
+  BFD_RELOC_MEP_32,
+  BFD_RELOC_MEP_PCREL8A2,
+  BFD_RELOC_MEP_PCREL12A2,
+  BFD_RELOC_MEP_PCREL17A2,
+  BFD_RELOC_MEP_PCREL24A2,
+  BFD_RELOC_MEP_PCABS24A2,
+  BFD_RELOC_MEP_LOW16,
+  BFD_RELOC_MEP_HI16U,
+  BFD_RELOC_MEP_HI16S,
+  BFD_RELOC_MEP_GPREL,
+  BFD_RELOC_MEP_TPREL,
+  BFD_RELOC_MEP_TPREL7,
+  BFD_RELOC_MEP_TPREL7A2,
+  BFD_RELOC_MEP_TPREL7A4,
+  BFD_RELOC_MEP_UIMM24,
+  BFD_RELOC_MEP_ADDR24A4,
+  BFD_RELOC_MEP_GNU_VTINHERIT,
+  BFD_RELOC_MEP_GNU_VTENTRY,
+
+
+/* These are relocations for the GETA instruction.  */
+  BFD_RELOC_MMIX_GETA,
+  BFD_RELOC_MMIX_GETA_1,
+  BFD_RELOC_MMIX_GETA_2,
+  BFD_RELOC_MMIX_GETA_3,
+
+/* These are relocations for a conditional branch instruction.  */
+  BFD_RELOC_MMIX_CBRANCH,
+  BFD_RELOC_MMIX_CBRANCH_J,
+  BFD_RELOC_MMIX_CBRANCH_1,
+  BFD_RELOC_MMIX_CBRANCH_2,
+  BFD_RELOC_MMIX_CBRANCH_3,
+
+/* These are relocations for the PUSHJ instruction.  */
+  BFD_RELOC_MMIX_PUSHJ,
+  BFD_RELOC_MMIX_PUSHJ_1,
+  BFD_RELOC_MMIX_PUSHJ_2,
+  BFD_RELOC_MMIX_PUSHJ_3,
+  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,
+
+/* These are relocations for the JMP instruction.  */
+  BFD_RELOC_MMIX_JMP,
+  BFD_RELOC_MMIX_JMP_1,
+  BFD_RELOC_MMIX_JMP_2,
+  BFD_RELOC_MMIX_JMP_3,
+
+/* This is a relocation for a relative address as in a GETA instruction or
+a branch.  */
+  BFD_RELOC_MMIX_ADDR19,
+
+/* This is a relocation for a relative address as in a JMP instruction.  */
+  BFD_RELOC_MMIX_ADDR27,
+
+/* This is a relocation for an instruction field that may be a general
+register or a value 0..255.  */
+  BFD_RELOC_MMIX_REG_OR_BYTE,
+
+/* This is a relocation for an instruction field that may be a general
+register.  */
+  BFD_RELOC_MMIX_REG,
+
+/* This is a relocation for two instruction fields holding a register and
+an offset, the equivalent of the relocation.  */
+  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,
+
+/* This relocation is an assertion that the expression is not allocated as
+a global register.  It does not modify contents.  */
+  BFD_RELOC_MMIX_LOCAL,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
+short offset into 7 bits.  */
+  BFD_RELOC_AVR_7_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
+short offset into 12 bits.  */
+  BFD_RELOC_AVR_13_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
+program memory address) into 16 bits.  */
+  BFD_RELOC_AVR_16_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of program memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of 32 bit value) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_MS8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually data memory address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of data memory address) into 8 bit immediate value of
+SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(most high 8 bit of program memory address) into 8 bit immediate value
+of LDI or SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value (msb
+of 32 bit value) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_MS8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value 
+(command address) into 8 bit immediate value of LDI insn. If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+in the lower 128k.  */
+  BFD_RELOC_AVR_LO8_LDI_GS,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+below 128k.  */
+  BFD_RELOC_AVR_HI8_LDI_GS,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually command address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of 16 bit command address) into 8 bit immediate value
+of SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 6 bit of 22 bit command address) into 8 bit immediate
+value of SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM_NEG,
+
+/* This is a 32 bit reloc for the AVR that stores 23 bit value
+into 22 bits.  */
+  BFD_RELOC_AVR_CALL,
+
+/* This is a 16 bit reloc for the AVR that stores all needed bits
+for absolute addressing with ldi with overflow check to linktime  */
+  BFD_RELOC_AVR_LDI,
+
+/* This is a 6 bit reloc for the AVR that stores offset for ldd/std
+instructions  */
+  BFD_RELOC_AVR_6,
+
+/* This is a 6 bit reloc for the AVR that stores offset for adiw/sbiw
+instructions  */
+  BFD_RELOC_AVR_6_ADIW,
+
+/* Direct 12 bit.  */
+  BFD_RELOC_390_12,
+
+/* 12 bit GOT offset.  */
+  BFD_RELOC_390_GOT12,
+
+/* 32 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT32,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_390_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_390_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_390_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_390_RELATIVE,
+
+/* 32 bit PC relative offset to GOT.  */
+  BFD_RELOC_390_GOTPC,
+
+/* 16 bit GOT offset.  */
+  BFD_RELOC_390_GOT16,
+
+/* PC relative 16 bit shifted by 1.  */
+  BFD_RELOC_390_PC16DBL,
+
+/* 16 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT16DBL,
+
+/* PC relative 32 bit shifted by 1.  */
+  BFD_RELOC_390_PC32DBL,
+
+/* 32 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT32DBL,
+
+/* 32 bit PC rel. GOT shifted by 1.  */
+  BFD_RELOC_390_GOTPCDBL,
+
+/* 64 bit GOT offset.  */
+  BFD_RELOC_390_GOT64,
+
+/* 64 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT64,
+
+/* 32 bit rel. offset to GOT entry.  */
+  BFD_RELOC_390_GOTENT,
+
+/* 64 bit offset to GOT.  */
+  BFD_RELOC_390_GOTOFF64,
+
+/* 12-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT12,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT16,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT32,
+
+/* 64-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT64,
+
+/* 32-bit rel. offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLTENT,
+
+/* 16-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF16,
+
+/* 32-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF32,
+
+/* 64-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF64,
+
+/* s390 tls relocations.  */
+  BFD_RELOC_390_TLS_LOAD,
+  BFD_RELOC_390_TLS_GDCALL,
+  BFD_RELOC_390_TLS_LDCALL,
+  BFD_RELOC_390_TLS_GD32,
+  BFD_RELOC_390_TLS_GD64,
+  BFD_RELOC_390_TLS_GOTIE12,
+  BFD_RELOC_390_TLS_GOTIE32,
+  BFD_RELOC_390_TLS_GOTIE64,
+  BFD_RELOC_390_TLS_LDM32,
+  BFD_RELOC_390_TLS_LDM64,
+  BFD_RELOC_390_TLS_IE32,
+  BFD_RELOC_390_TLS_IE64,
+  BFD_RELOC_390_TLS_IEENT,
+  BFD_RELOC_390_TLS_LE32,
+  BFD_RELOC_390_TLS_LE64,
+  BFD_RELOC_390_TLS_LDO32,
+  BFD_RELOC_390_TLS_LDO64,
+  BFD_RELOC_390_TLS_DTPMOD,
+  BFD_RELOC_390_TLS_DTPOFF,
+  BFD_RELOC_390_TLS_TPOFF,
+
+/* Long displacement extension.  */
+  BFD_RELOC_390_20,
+  BFD_RELOC_390_GOT20,
+  BFD_RELOC_390_GOTPLT20,
+  BFD_RELOC_390_TLS_GOTIE20,
+
+/* Score relocations  */
+  BFD_RELOC_SCORE_DUMMY1,
+
+/* Low 16 bit for load/store  */
+  BFD_RELOC_SCORE_GPREL15,
+
+/* This is a 24-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_DUMMY2,
+  BFD_RELOC_SCORE_JMP,
+
+/* This is a 19-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_BRANCH,
+
+/* This is a 11-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE16_JMP,
+
+/* This is a 8-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE16_BRANCH,
+
+/* Undocumented Score relocs  */
+  BFD_RELOC_SCORE_GOT15,
+  BFD_RELOC_SCORE_GOT_LO16,
+  BFD_RELOC_SCORE_CALL15,
+  BFD_RELOC_SCORE_DUMMY_HI16,
+
+/* Scenix IP2K - 9-bit register number / data address  */
+  BFD_RELOC_IP2K_FR9,
+
+/* Scenix IP2K - 4-bit register/data bank number  */
+  BFD_RELOC_IP2K_BANK,
+
+/* Scenix IP2K - low 13 bits of instruction word address  */
+  BFD_RELOC_IP2K_ADDR16CJP,
+
+/* Scenix IP2K - high 3 bits of instruction word address  */
+  BFD_RELOC_IP2K_PAGE3,
+
+/* Scenix IP2K - ext/low/high 8 bits of data address  */
+  BFD_RELOC_IP2K_LO8DATA,
+  BFD_RELOC_IP2K_HI8DATA,
+  BFD_RELOC_IP2K_EX8DATA,
+
+/* Scenix IP2K - low/high 8 bits of instruction word address  */
+  BFD_RELOC_IP2K_LO8INSN,
+  BFD_RELOC_IP2K_HI8INSN,
+
+/* Scenix IP2K - even/odd PC modifier to modify snb pcl.0  */
+  BFD_RELOC_IP2K_PC_SKIP,
+
+/* Scenix IP2K - 16 bit word address in text section.  */
+  BFD_RELOC_IP2K_TEXT,
+
+/* Scenix IP2K - 7-bit sp or dp offset  */
+  BFD_RELOC_IP2K_FR_OFFSET,
+
+/* Scenix VPE4K coprocessor - data/insn-space addressing  */
+  BFD_RELOC_VPE4KMATH_DATA,
+  BFD_RELOC_VPE4KMATH_INSN,
+
+/* These two relocations are used by the linker to determine which of
+the entries in a C++ virtual function table are actually used.  When
+the --gc-sections option is given, the linker will zero out the entries
+that are not used, so that the code for those functions need not be
+included in the output.
+
+VTABLE_INHERIT is a zero-space relocation used to describe to the
+linker the inheritance tree of a C++ virtual function table.  The
+relocation's symbol should be the parent class' vtable, and the
+relocation should be located at the child vtable.
+
+VTABLE_ENTRY is a zero-space relocation that describes the use of a
+virtual function table entry.  The reloc's symbol should refer to the
+table of the class mentioned in the code.  Off of that base, an offset
+describes the entry that is being used.  For Rela hosts, this offset
+is stored in the reloc's addend.  For Rel hosts, we are forced to put
+this offset in the reloc's section offset.  */
+  BFD_RELOC_VTABLE_INHERIT,
+  BFD_RELOC_VTABLE_ENTRY,
+
+/* Intel IA64 Relocations.  */
+  BFD_RELOC_IA64_IMM14,
+  BFD_RELOC_IA64_IMM22,
+  BFD_RELOC_IA64_IMM64,
+  BFD_RELOC_IA64_DIR32MSB,
+  BFD_RELOC_IA64_DIR32LSB,
+  BFD_RELOC_IA64_DIR64MSB,
+  BFD_RELOC_IA64_DIR64LSB,
+  BFD_RELOC_IA64_GPREL22,
+  BFD_RELOC_IA64_GPREL64I,
+  BFD_RELOC_IA64_GPREL32MSB,
+  BFD_RELOC_IA64_GPREL32LSB,
+  BFD_RELOC_IA64_GPREL64MSB,
+  BFD_RELOC_IA64_GPREL64LSB,
+  BFD_RELOC_IA64_LTOFF22,
+  BFD_RELOC_IA64_LTOFF64I,
+  BFD_RELOC_IA64_PLTOFF22,
+  BFD_RELOC_IA64_PLTOFF64I,
+  BFD_RELOC_IA64_PLTOFF64MSB,
+  BFD_RELOC_IA64_PLTOFF64LSB,
+  BFD_RELOC_IA64_FPTR64I,
+  BFD_RELOC_IA64_FPTR32MSB,
+  BFD_RELOC_IA64_FPTR32LSB,
+  BFD_RELOC_IA64_FPTR64MSB,
+  BFD_RELOC_IA64_FPTR64LSB,
+  BFD_RELOC_IA64_PCREL21B,
+  BFD_RELOC_IA64_PCREL21BI,
+  BFD_RELOC_IA64_PCREL21M,
+  BFD_RELOC_IA64_PCREL21F,
+  BFD_RELOC_IA64_PCREL22,
+  BFD_RELOC_IA64_PCREL60B,
+  BFD_RELOC_IA64_PCREL64I,
+  BFD_RELOC_IA64_PCREL32MSB,
+  BFD_RELOC_IA64_PCREL32LSB,
+  BFD_RELOC_IA64_PCREL64MSB,
+  BFD_RELOC_IA64_PCREL64LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR22,
+  BFD_RELOC_IA64_LTOFF_FPTR64I,
+  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
+  BFD_RELOC_IA64_SEGREL32MSB,
+  BFD_RELOC_IA64_SEGREL32LSB,
+  BFD_RELOC_IA64_SEGREL64MSB,
+  BFD_RELOC_IA64_SEGREL64LSB,
+  BFD_RELOC_IA64_SECREL32MSB,
+  BFD_RELOC_IA64_SECREL32LSB,
+  BFD_RELOC_IA64_SECREL64MSB,
+  BFD_RELOC_IA64_SECREL64LSB,
+  BFD_RELOC_IA64_REL32MSB,
+  BFD_RELOC_IA64_REL32LSB,
+  BFD_RELOC_IA64_REL64MSB,
+  BFD_RELOC_IA64_REL64LSB,
+  BFD_RELOC_IA64_LTV32MSB,
+  BFD_RELOC_IA64_LTV32LSB,
+  BFD_RELOC_IA64_LTV64MSB,
+  BFD_RELOC_IA64_LTV64LSB,
+  BFD_RELOC_IA64_IPLTMSB,
+  BFD_RELOC_IA64_IPLTLSB,
+  BFD_RELOC_IA64_COPY,
+  BFD_RELOC_IA64_LTOFF22X,
+  BFD_RELOC_IA64_LDXMOV,
+  BFD_RELOC_IA64_TPREL14,
+  BFD_RELOC_IA64_TPREL22,
+  BFD_RELOC_IA64_TPREL64I,
+  BFD_RELOC_IA64_TPREL64MSB,
+  BFD_RELOC_IA64_TPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_TPREL22,
+  BFD_RELOC_IA64_DTPMOD64MSB,
+  BFD_RELOC_IA64_DTPMOD64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPMOD22,
+  BFD_RELOC_IA64_DTPREL14,
+  BFD_RELOC_IA64_DTPREL22,
+  BFD_RELOC_IA64_DTPREL64I,
+  BFD_RELOC_IA64_DTPREL32MSB,
+  BFD_RELOC_IA64_DTPREL32LSB,
+  BFD_RELOC_IA64_DTPREL64MSB,
+  BFD_RELOC_IA64_DTPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPREL22,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit high part of an absolute address.  */
+  BFD_RELOC_M68HC11_HI8,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit low part of an absolute address.  */
+  BFD_RELOC_M68HC11_LO8,
+
+/* Motorola 68HC11 reloc.
+This is the 3 bit of a value.  */
+  BFD_RELOC_M68HC11_3B,
+
+/* Motorola 68HC11 reloc.
+This reloc marks the beginning of a jump/call instruction.
+It is used for linker relaxation to correctly identify beginning
+of instruction and change some branches to use PC-relative
+addressing mode.  */
+  BFD_RELOC_M68HC11_RL_JUMP,
+
+/* Motorola 68HC11 reloc.
+This reloc marks a group of several instructions that gcc generates
+and for which the linker relaxation pass can modify and/or remove
+some of them.  */
+  BFD_RELOC_M68HC11_RL_GROUP,
+
+/* Motorola 68HC11 reloc.
+This is the 16-bit lower part of an address.  It is used for 'call'
+instruction to specify the symbol address without any special
+transformation (due to memory bank window).  */
+  BFD_RELOC_M68HC11_LO16,
+
+/* Motorola 68HC11 reloc.
+This is a 8-bit reloc that specifies the page number of an address.
+It is used by 'call' instruction to specify the page number of
+the symbol.  */
+  BFD_RELOC_M68HC11_PAGE,
+
+/* Motorola 68HC11 reloc.
+This is a 24-bit reloc that represents the address with a 16-bit
+value and a 8-bit page number.  The symbol address is transformed
+to follow the 16K memory bank of 68HC12 (seen as mapped in the window).  */
+  BFD_RELOC_M68HC11_24,
+
+/* Motorola 68HC12 reloc.
+This is the 5 bits of a value.  */
+  BFD_RELOC_M68HC12_5B,
+
+/* NS CR16C Relocations.  */
+  BFD_RELOC_16C_NUM08,
+  BFD_RELOC_16C_NUM08_C,
+  BFD_RELOC_16C_NUM16,
+  BFD_RELOC_16C_NUM16_C,
+  BFD_RELOC_16C_NUM32,
+  BFD_RELOC_16C_NUM32_C,
+  BFD_RELOC_16C_DISP04,
+  BFD_RELOC_16C_DISP04_C,
+  BFD_RELOC_16C_DISP08,
+  BFD_RELOC_16C_DISP08_C,
+  BFD_RELOC_16C_DISP16,
+  BFD_RELOC_16C_DISP16_C,
+  BFD_RELOC_16C_DISP24,
+  BFD_RELOC_16C_DISP24_C,
+  BFD_RELOC_16C_DISP24a,
+  BFD_RELOC_16C_DISP24a_C,
+  BFD_RELOC_16C_REG04,
+  BFD_RELOC_16C_REG04_C,
+  BFD_RELOC_16C_REG04a,
+  BFD_RELOC_16C_REG04a_C,
+  BFD_RELOC_16C_REG14,
+  BFD_RELOC_16C_REG14_C,
+  BFD_RELOC_16C_REG16,
+  BFD_RELOC_16C_REG16_C,
+  BFD_RELOC_16C_REG20,
+  BFD_RELOC_16C_REG20_C,
+  BFD_RELOC_16C_ABS20,
+  BFD_RELOC_16C_ABS20_C,
+  BFD_RELOC_16C_ABS24,
+  BFD_RELOC_16C_ABS24_C,
+  BFD_RELOC_16C_IMM04,
+  BFD_RELOC_16C_IMM04_C,
+  BFD_RELOC_16C_IMM16,
+  BFD_RELOC_16C_IMM16_C,
+  BFD_RELOC_16C_IMM20,
+  BFD_RELOC_16C_IMM20_C,
+  BFD_RELOC_16C_IMM24,
+  BFD_RELOC_16C_IMM24_C,
+  BFD_RELOC_16C_IMM32,
+  BFD_RELOC_16C_IMM32_C,
+
+/* NS CR16 Relocations.  */
+  BFD_RELOC_CR16_NUM8,
+  BFD_RELOC_CR16_NUM16,
+  BFD_RELOC_CR16_NUM32,
+  BFD_RELOC_CR16_NUM32a,
+  BFD_RELOC_CR16_REGREL0,
+  BFD_RELOC_CR16_REGREL4,
+  BFD_RELOC_CR16_REGREL4a,
+  BFD_RELOC_CR16_REGREL14,
+  BFD_RELOC_CR16_REGREL14a,
+  BFD_RELOC_CR16_REGREL16,
+  BFD_RELOC_CR16_REGREL20,
+  BFD_RELOC_CR16_REGREL20a,
+  BFD_RELOC_CR16_ABS20,
+  BFD_RELOC_CR16_ABS24,
+  BFD_RELOC_CR16_IMM4,
+  BFD_RELOC_CR16_IMM8,
+  BFD_RELOC_CR16_IMM16,
+  BFD_RELOC_CR16_IMM20,
+  BFD_RELOC_CR16_IMM24,
+  BFD_RELOC_CR16_IMM32,
+  BFD_RELOC_CR16_IMM32a,
+  BFD_RELOC_CR16_DISP4,
+  BFD_RELOC_CR16_DISP8,
+  BFD_RELOC_CR16_DISP16,
+  BFD_RELOC_CR16_DISP20,
+  BFD_RELOC_CR16_DISP24,
+  BFD_RELOC_CR16_DISP24a,
+
+/* NS CRX Relocations.  */
+  BFD_RELOC_CRX_REL4,
+  BFD_RELOC_CRX_REL8,
+  BFD_RELOC_CRX_REL8_CMP,
+  BFD_RELOC_CRX_REL16,
+  BFD_RELOC_CRX_REL24,
+  BFD_RELOC_CRX_REL32,
+  BFD_RELOC_CRX_REGREL12,
+  BFD_RELOC_CRX_REGREL22,
+  BFD_RELOC_CRX_REGREL28,
+  BFD_RELOC_CRX_REGREL32,
+  BFD_RELOC_CRX_ABS16,
+  BFD_RELOC_CRX_ABS32,
+  BFD_RELOC_CRX_NUM8,
+  BFD_RELOC_CRX_NUM16,
+  BFD_RELOC_CRX_NUM32,
+  BFD_RELOC_CRX_IMM16,
+  BFD_RELOC_CRX_IMM32,
+  BFD_RELOC_CRX_SWITCH8,
+  BFD_RELOC_CRX_SWITCH16,
+  BFD_RELOC_CRX_SWITCH32,
+
+/* These relocs are only used within the CRIS assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_CRIS_BDISP8,
+  BFD_RELOC_CRIS_UNSIGNED_5,
+  BFD_RELOC_CRIS_SIGNED_6,
+  BFD_RELOC_CRIS_UNSIGNED_6,
+  BFD_RELOC_CRIS_SIGNED_8,
+  BFD_RELOC_CRIS_UNSIGNED_8,
+  BFD_RELOC_CRIS_SIGNED_16,
+  BFD_RELOC_CRIS_UNSIGNED_16,
+  BFD_RELOC_CRIS_LAPCQ_OFFSET,
+  BFD_RELOC_CRIS_UNSIGNED_4,
+
+/* Relocs used in ELF shared libraries for CRIS.  */
+  BFD_RELOC_CRIS_COPY,
+  BFD_RELOC_CRIS_GLOB_DAT,
+  BFD_RELOC_CRIS_JUMP_SLOT,
+  BFD_RELOC_CRIS_RELATIVE,
+
+/* 32-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_32_GOT,
+
+/* 16-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_16_GOT,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_32_GOTPLT,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_16_GOTPLT,
+
+/* 32-bit offset to symbol, relative to GOT.  */
+  BFD_RELOC_CRIS_32_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to GOT.  */
+  BFD_RELOC_CRIS_32_PLT_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to this relocation.  */
+  BFD_RELOC_CRIS_32_PLT_PCREL,
+
+/* Intel i860 Relocations.  */
+  BFD_RELOC_860_COPY,
+  BFD_RELOC_860_GLOB_DAT,
+  BFD_RELOC_860_JUMP_SLOT,
+  BFD_RELOC_860_RELATIVE,
+  BFD_RELOC_860_PC26,
+  BFD_RELOC_860_PLT26,
+  BFD_RELOC_860_PC16,
+  BFD_RELOC_860_LOW0,
+  BFD_RELOC_860_SPLIT0,
+  BFD_RELOC_860_LOW1,
+  BFD_RELOC_860_SPLIT1,
+  BFD_RELOC_860_LOW2,
+  BFD_RELOC_860_SPLIT2,
+  BFD_RELOC_860_LOW3,
+  BFD_RELOC_860_LOGOT0,
+  BFD_RELOC_860_SPGOT0,
+  BFD_RELOC_860_LOGOT1,
+  BFD_RELOC_860_SPGOT1,
+  BFD_RELOC_860_LOGOTOFF0,
+  BFD_RELOC_860_SPGOTOFF0,
+  BFD_RELOC_860_LOGOTOFF1,
+  BFD_RELOC_860_SPGOTOFF1,
+  BFD_RELOC_860_LOGOTOFF2,
+  BFD_RELOC_860_LOGOTOFF3,
+  BFD_RELOC_860_LOPC,
+  BFD_RELOC_860_HIGHADJ,
+  BFD_RELOC_860_HAGOT,
+  BFD_RELOC_860_HAGOTOFF,
+  BFD_RELOC_860_HAPC,
+  BFD_RELOC_860_HIGH,
+  BFD_RELOC_860_HIGOT,
+  BFD_RELOC_860_HIGOTOFF,
+
+/* OpenRISC Relocations.  */
+  BFD_RELOC_OPENRISC_ABS_26,
+  BFD_RELOC_OPENRISC_REL_26,
+
+/* H8 elf Relocations.  */
+  BFD_RELOC_H8_DIR16A8,
+  BFD_RELOC_H8_DIR16R8,
+  BFD_RELOC_H8_DIR24A8,
+  BFD_RELOC_H8_DIR24R8,
+  BFD_RELOC_H8_DIR32A16,
+
+/* Sony Xstormy16 Relocations.  */
+  BFD_RELOC_XSTORMY16_REL_12,
+  BFD_RELOC_XSTORMY16_12,
+  BFD_RELOC_XSTORMY16_24,
+  BFD_RELOC_XSTORMY16_FPTR16,
+
+/* Self-describing complex relocations.  */
+  BFD_RELOC_RELC,
+
+
+/* Infineon Relocations.  */
+  BFD_RELOC_XC16X_PAG,
+  BFD_RELOC_XC16X_POF,
+  BFD_RELOC_XC16X_SEG,
+  BFD_RELOC_XC16X_SOF,
+
+/* Relocations used by VAX ELF.  */
+  BFD_RELOC_VAX_GLOB_DAT,
+  BFD_RELOC_VAX_JMP_SLOT,
+  BFD_RELOC_VAX_RELATIVE,
+
+/* Morpho MT - 16 bit immediate relocation.  */
+  BFD_RELOC_MT_PC16,
+
+/* Morpho MT - Hi 16 bits of an address.  */
+  BFD_RELOC_MT_HI16,
+
+/* Morpho MT - Low 16 bits of an address.  */
+  BFD_RELOC_MT_LO16,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTINHERIT,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTENTRY,
+
+/* Morpho MT - 8 bit immediate relocation.  */
+  BFD_RELOC_MT_PCINSN8,
+
+/* msp430 specific relocation codes  */
+  BFD_RELOC_MSP430_10_PCREL,
+  BFD_RELOC_MSP430_16_PCREL,
+  BFD_RELOC_MSP430_16,
+  BFD_RELOC_MSP430_16_PCREL_BYTE,
+  BFD_RELOC_MSP430_16_BYTE,
+  BFD_RELOC_MSP430_2X_PCREL,
+  BFD_RELOC_MSP430_RL_PCREL,
+
+/* IQ2000 Relocations.  */
+  BFD_RELOC_IQ2000_OFFSET_16,
+  BFD_RELOC_IQ2000_OFFSET_21,
+  BFD_RELOC_IQ2000_UHI16,
+
+/* Special Xtensa relocation used only by PLT entries in ELF shared
+objects to indicate that the runtime linker should set the value
+to one of its own internal functions or data structures.  */
+  BFD_RELOC_XTENSA_RTLD,
+
+/* Xtensa relocations for ELF shared objects.  */
+  BFD_RELOC_XTENSA_GLOB_DAT,
+  BFD_RELOC_XTENSA_JMP_SLOT,
+  BFD_RELOC_XTENSA_RELATIVE,
+
+/* Xtensa relocation used in ELF object files for symbols that may require
+PLT entries.  Otherwise, this is just a generic 32-bit relocation.  */
+  BFD_RELOC_XTENSA_PLT,
+
+/* Xtensa relocations to mark the difference of two local symbols.
+These are only needed to support linker relaxation and can be ignored
+when not relaxing.  The field is set to the value of the difference
+assuming no relaxation.  The relocation encodes the position of the
+first symbol so the linker can determine whether to adjust the field
+value.  */
+  BFD_RELOC_XTENSA_DIFF8,
+  BFD_RELOC_XTENSA_DIFF16,
+  BFD_RELOC_XTENSA_DIFF32,
+
+/* Generic Xtensa relocations for instruction operands.  Only the slot
+number is encoded in the relocation.  The relocation applies to the
+last PC-relative immediate operand, or if there are no PC-relative
+immediates, to the last immediate operand.  */
+  BFD_RELOC_XTENSA_SLOT0_OP,
+  BFD_RELOC_XTENSA_SLOT1_OP,
+  BFD_RELOC_XTENSA_SLOT2_OP,
+  BFD_RELOC_XTENSA_SLOT3_OP,
+  BFD_RELOC_XTENSA_SLOT4_OP,
+  BFD_RELOC_XTENSA_SLOT5_OP,
+  BFD_RELOC_XTENSA_SLOT6_OP,
+  BFD_RELOC_XTENSA_SLOT7_OP,
+  BFD_RELOC_XTENSA_SLOT8_OP,
+  BFD_RELOC_XTENSA_SLOT9_OP,
+  BFD_RELOC_XTENSA_SLOT10_OP,
+  BFD_RELOC_XTENSA_SLOT11_OP,
+  BFD_RELOC_XTENSA_SLOT12_OP,
+  BFD_RELOC_XTENSA_SLOT13_OP,
+  BFD_RELOC_XTENSA_SLOT14_OP,
+
+/* Alternate Xtensa relocations.  Only the slot is encoded in the
+relocation.  The meaning of these relocations is opcode-specific.  */
+  BFD_RELOC_XTENSA_SLOT0_ALT,
+  BFD_RELOC_XTENSA_SLOT1_ALT,
+  BFD_RELOC_XTENSA_SLOT2_ALT,
+  BFD_RELOC_XTENSA_SLOT3_ALT,
+  BFD_RELOC_XTENSA_SLOT4_ALT,
+  BFD_RELOC_XTENSA_SLOT5_ALT,
+  BFD_RELOC_XTENSA_SLOT6_ALT,
+  BFD_RELOC_XTENSA_SLOT7_ALT,
+  BFD_RELOC_XTENSA_SLOT8_ALT,
+  BFD_RELOC_XTENSA_SLOT9_ALT,
+  BFD_RELOC_XTENSA_SLOT10_ALT,
+  BFD_RELOC_XTENSA_SLOT11_ALT,
+  BFD_RELOC_XTENSA_SLOT12_ALT,
+  BFD_RELOC_XTENSA_SLOT13_ALT,
+  BFD_RELOC_XTENSA_SLOT14_ALT,
+
+/* Xtensa relocations for backward compatibility.  These have all been
+replaced by BFD_RELOC_XTENSA_SLOT0_OP.  */
+  BFD_RELOC_XTENSA_OP0,
+  BFD_RELOC_XTENSA_OP1,
+  BFD_RELOC_XTENSA_OP2,
+
+/* Xtensa relocation to mark that the assembler expanded the
+instructions from an original target.  The expansion size is
+encoded in the reloc size.  */
+  BFD_RELOC_XTENSA_ASM_EXPAND,
+
+/* Xtensa relocation to mark that the linker should simplify
+assembler-expanded instructions.  This is commonly used
+internally by the linker after analysis of a
+BFD_RELOC_XTENSA_ASM_EXPAND.  */
+  BFD_RELOC_XTENSA_ASM_SIMPLIFY,
+
+/* 8 bit signed offset in (ix+d) or (iy+d).  */
+  BFD_RELOC_Z80_DISP8,
+
+/* DJNZ offset.  */
+  BFD_RELOC_Z8K_DISP7,
+
+/* CALR offset.  */
+  BFD_RELOC_Z8K_CALLR,
+
+/* 4 bit value.  */
+  BFD_RELOC_Z8K_IMM4L,
+  BFD_RELOC_UNUSED };
+typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
+reloc_howto_type *bfd_reloc_type_lookup
+   (bfd *abfd, bfd_reloc_code_real_type code);
+reloc_howto_type *bfd_reloc_name_lookup
+   (bfd *abfd, const char *reloc_name);
+
+const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
+
+/* Extracted from syms.c.  */
+
+typedef struct bfd_symbol
+{
+  /* A pointer to the BFD which owns the symbol. This information
+     is necessary so that a back end can work out what additional
+     information (invisible to the application writer) is carried
+     with the symbol.
+
+     This field is *almost* redundant, since you can use section->owner
+     instead, except that some symbols point to the global sections
+     bfd_{abs,com,und}_section.  This could be fixed by making
+     these globals be per-bfd (or per-target-flavor).  FIXME.  */
+  struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
+
+  /* The text of the symbol. The name is left alone, and not copied; the
+     application may not alter it.  */
+  const char *name;
+
+  /* The value of the symbol.  This really should be a union of a
+     numeric value with a pointer, since some flags indicate that
+     a pointer to another symbol is stored here.  */
+  symvalue value;
+
+  /* Attributes of a symbol.  */
+#define BSF_NO_FLAGS    0x00
+
+  /* The symbol has local scope; <<static>> in <<C>>. The value
+     is the offset into the section of the data.  */
+#define BSF_LOCAL      0x01
+
+  /* The symbol has global scope; initialized data in <<C>>. The
+     value is the offset into the section of the data.  */
+#define BSF_GLOBAL     0x02
+
+  /* The symbol has global scope and is exported. The value is
+     the offset into the section of the data.  */
+#define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
+
+  /* A normal C symbol would be one of:
+     <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
+     <<BSF_GLOBAL>>.  */
+
+  /* The symbol is a debugging record. The value has an arbitrary
+     meaning, unless BSF_DEBUGGING_RELOC is also set.  */
+#define BSF_DEBUGGING  0x08
+
+  /* The symbol denotes a function entry point.  Used in ELF,
+     perhaps others someday.  */
+#define BSF_FUNCTION    0x10
+
+  /* Used by the linker.  */
+#define BSF_KEEP        0x20
+#define BSF_KEEP_G      0x40
+
+  /* A weak global symbol, overridable without warnings by
+     a regular global symbol of the same name.  */
+#define BSF_WEAK        0x80
+
+  /* This symbol was created to point to a section, e.g. ELF's
+     STT_SECTION symbols.  */
+#define BSF_SECTION_SYM 0x100
+
+  /* The symbol used to be a common symbol, but now it is
+     allocated.  */
+#define BSF_OLD_COMMON  0x200
+
+  /* The default value for common data.  */
+#define BFD_FORT_COMM_DEFAULT_VALUE 0
+
+  /* In some files the type of a symbol sometimes alters its
+     location in an output file - ie in coff a <<ISFCN>> symbol
+     which is also <<C_EXT>> symbol appears where it was
+     declared and not at the end of a section.  This bit is set
+     by the target BFD part to convey this information.  */
+#define BSF_NOT_AT_END    0x400
+
+  /* Signal that the symbol is the label of constructor section.  */
+#define BSF_CONSTRUCTOR   0x800
+
+  /* Signal that the symbol is a warning symbol.  The name is a
+     warning.  The name of the next symbol is the one to warn about;
+     if a reference is made to a symbol with the same name as the next
+     symbol, a warning is issued by the linker.  */
+#define BSF_WARNING       0x1000
+
+  /* Signal that the symbol is indirect.  This symbol is an indirect
+     pointer to the symbol with the same name as the next symbol.  */
+#define BSF_INDIRECT      0x2000
+
+  /* BSF_FILE marks symbols that contain a file name.  This is used
+     for ELF STT_FILE symbols.  */
+#define BSF_FILE          0x4000
+
+  /* Symbol is from dynamic linking information.  */
+#define BSF_DYNAMIC       0x8000
+
+  /* The symbol denotes a data object.  Used in ELF, and perhaps
+     others someday.  */
+#define BSF_OBJECT        0x10000
+
+  /* This symbol is a debugging symbol.  The value is the offset
+     into the section of the data.  BSF_DEBUGGING should be set
+     as well.  */
+#define BSF_DEBUGGING_RELOC 0x20000
+
+  /* This symbol is thread local.  Used in ELF.  */
+#define BSF_THREAD_LOCAL  0x40000
+
+  /* This symbol represents a complex relocation expression,
+     with the expression tree serialized in the symbol name.  */
+#define BSF_RELC 0x80000
+
+  /* This symbol represents a signed complex relocation expression,
+     with the expression tree serialized in the symbol name.  */
+#define BSF_SRELC 0x100000
+
+  flagword flags;
+
+  /* A pointer to the section to which this symbol is
+     relative.  This will always be non NULL, there are special
+     sections for undefined and absolute symbols.  */
+  struct bfd_section *section;
+
+  /* Back end special data.  */
+  union
+    {
+      void *p;
+      bfd_vma i;
+    }
+  udata;
+}
+asymbol;
+
+#define bfd_get_symtab_upper_bound(abfd) \
+     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
+
+bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
+
+bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
+
+#define bfd_is_local_label_name(abfd, name) \
+  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
+
+bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);
+
+#define bfd_is_target_special_symbol(abfd, sym) \
+  BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))
+
+#define bfd_canonicalize_symtab(abfd, location) \
+  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
+
+bfd_boolean bfd_set_symtab
+   (bfd *abfd, asymbol **location, unsigned int count);
+
+void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
+
+#define bfd_make_empty_symbol(abfd) \
+  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
+
+asymbol *_bfd_generic_make_empty_symbol (bfd *);
+
+#define bfd_make_debug_symbol(abfd,ptr,size) \
+  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
+
+int bfd_decode_symclass (asymbol *symbol);
+
+bfd_boolean bfd_is_undefined_symclass (int symclass);
+
+void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
+
+bfd_boolean bfd_copy_private_symbol_data
+   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
+
+#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
+  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
+            (ibfd, isymbol, obfd, osymbol))
+
+/* Extracted from bfd.c.  */
+struct bfd
+{
+  /* A unique identifier of the BFD  */
+  unsigned int id;
+
+  /* The filename the application opened the BFD with.  */
+  const char *filename;
+
+  /* A pointer to the target jump table.  */
+  const struct bfd_target *xvec;
+
+  /* The IOSTREAM, and corresponding IO vector that provide access
+     to the file backing the BFD.  */
+  void *iostream;
+  const struct bfd_iovec *iovec;
+
+  /* Is the file descriptor being cached?  That is, can it be closed as
+     needed, and re-opened when accessed later?  */
+  bfd_boolean cacheable;
+
+  /* Marks whether there was a default target specified when the
+     BFD was opened. This is used to select which matching algorithm
+     to use to choose the back end.  */
+  bfd_boolean target_defaulted;
+
+  /* The caching routines use these to maintain a
+     least-recently-used list of BFDs.  */
+  struct bfd *lru_prev, *lru_next;
+
+  /* When a file is closed by the caching routines, BFD retains
+     state information on the file here...  */
+  ufile_ptr where;
+
+  /* ... and here: (``once'' means at least once).  */
+  bfd_boolean opened_once;
+
+  /* Set if we have a locally maintained mtime value, rather than
+     getting it from the file each time.  */
+  bfd_boolean mtime_set;
+
+  /* File modified time, if mtime_set is TRUE.  */
+  long mtime;
+
+  /* Reserved for an unimplemented file locking extension.  */
+  int ifd;
+
+  /* The format which belongs to the BFD. (object, core, etc.)  */
+  bfd_format format;
+
+  /* The direction with which the BFD was opened.  */
+  enum bfd_direction
+    {
+      no_direction = 0,
+      read_direction = 1,
+      write_direction = 2,
+      both_direction = 3
+    }
+  direction;
+
+  /* Format_specific flags.  */
+  flagword flags;
+
+  /* Currently my_archive is tested before adding origin to
+     anything. I believe that this can become always an add of
+     origin, with origin set to 0 for non archive files.  */
+  ufile_ptr origin;
+
+  /* Remember when output has begun, to stop strange things
+     from happening.  */
+  bfd_boolean output_has_begun;
+
+  /* A hash table for section names.  */
+  struct bfd_hash_table section_htab;
+
+  /* Pointer to linked list of sections.  */
+  struct bfd_section *sections;
+
+  /* The last section on the section list.  */
+  struct bfd_section *section_last;
+
+  /* The number of sections.  */
+  unsigned int section_count;
+
+  /* Stuff only useful for object files:
+     The start address.  */
+  bfd_vma start_address;
+
+  /* Used for input and output.  */
+  unsigned int symcount;
+
+  /* Symbol table for output BFD (with symcount entries).  */
+  struct bfd_symbol  **outsymbols;
+
+  /* Used for slurped dynamic symbol tables.  */
+  unsigned int dynsymcount;
+
+  /* Pointer to structure which contains architecture information.  */
+  const struct bfd_arch_info *arch_info;
+
+  /* Flag set if symbols from this BFD should not be exported.  */
+  bfd_boolean no_export;
+
+  /* Stuff only useful for archives.  */
+  void *arelt_data;
+  struct bfd *my_archive;      /* The containing archive BFD.  */
+  struct bfd *archive_next;    /* The next BFD in the archive.  */
+  struct bfd *archive_head;    /* The first BFD in the archive.  */
+  bfd_boolean has_armap;
+
+  /* A chain of BFD structures involved in a link.  */
+  struct bfd *link_next;
+
+  /* A field used by _bfd_generic_link_add_archive_symbols.  This will
+     be used only for archive elements.  */
+  int archive_pass;
+
+  /* Used by the back end to hold private data.  */
+  union
+    {
+      struct aout_data_struct *aout_data;
+      struct artdata *aout_ar_data;
+      struct _oasys_data *oasys_obj_data;
+      struct _oasys_ar_data *oasys_ar_data;
+      struct coff_tdata *coff_obj_data;
+      struct pe_tdata *pe_obj_data;
+      struct xcoff_tdata *xcoff_obj_data;
+      struct ecoff_tdata *ecoff_obj_data;
+      struct ieee_data_struct *ieee_data;
+      struct ieee_ar_data_struct *ieee_ar_data;
+      struct srec_data_struct *srec_data;
+      struct ihex_data_struct *ihex_data;
+      struct tekhex_data_struct *tekhex_data;
+      struct elf_obj_tdata *elf_obj_data;
+      struct nlm_obj_tdata *nlm_obj_data;
+      struct bout_data_struct *bout_data;
+      struct mmo_data_struct *mmo_data;
+      struct sun_core_struct *sun_core_data;
+      struct sco5_core_struct *sco5_core_data;
+      struct trad_core_struct *trad_core_data;
+      struct som_data_struct *som_data;
+      struct hpux_core_struct *hpux_core_data;
+      struct hppabsd_core_struct *hppabsd_core_data;
+      struct sgi_core_struct *sgi_core_data;
+      struct lynx_core_struct *lynx_core_data;
+      struct osf_core_struct *osf_core_data;
+      struct cisco_core_struct *cisco_core_data;
+      struct versados_data_struct *versados_data;
+      struct netbsd_core_struct *netbsd_core_data;
+      struct mach_o_data_struct *mach_o_data;
+      struct mach_o_fat_data_struct *mach_o_fat_data;
+      struct bfd_pef_data_struct *pef_data;
+      struct bfd_pef_xlib_data_struct *pef_xlib_data;
+      struct bfd_sym_data_struct *sym_data;
+      void *any;
+    }
+  tdata;
+
+  /* Used by the application to hold private data.  */
+  void *usrdata;
+
+  /* Where all the allocated stuff under this BFD goes.  This is a
+     struct objalloc *, but we use void * to avoid requiring the inclusion
+     of objalloc.h.  */
+  void *memory;
+};
+
+typedef enum bfd_error
+{
+  bfd_error_no_error = 0,
+  bfd_error_system_call,
+  bfd_error_invalid_target,
+  bfd_error_wrong_format,
+  bfd_error_wrong_object_format,
+  bfd_error_invalid_operation,
+  bfd_error_no_memory,
+  bfd_error_no_symbols,
+  bfd_error_no_armap,
+  bfd_error_no_more_archived_files,
+  bfd_error_malformed_archive,
+  bfd_error_file_not_recognized,
+  bfd_error_file_ambiguously_recognized,
+  bfd_error_no_contents,
+  bfd_error_nonrepresentable_section,
+  bfd_error_no_debug_section,
+  bfd_error_bad_value,
+  bfd_error_file_truncated,
+  bfd_error_file_too_big,
+  bfd_error_on_input,
+  bfd_error_invalid_error_code
+}
+bfd_error_type;
+
+bfd_error_type bfd_get_error (void);
+
+void bfd_set_error (bfd_error_type error_tag, ...);
+
+const char *bfd_errmsg (bfd_error_type error_tag);
+
+void bfd_perror (const char *message);
+
+typedef void (*bfd_error_handler_type) (const char *, ...);
+
+bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
+
+void bfd_set_error_program_name (const char *);
+
+bfd_error_handler_type bfd_get_error_handler (void);
+
+long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
+
+long bfd_canonicalize_reloc
+   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
+
+void bfd_set_reloc
+   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
+
+bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
+
+int bfd_get_arch_size (bfd *abfd);
+
+int bfd_get_sign_extend_vma (bfd *abfd);
+
+bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
+
+unsigned int bfd_get_gp_size (bfd *abfd);
+
+void bfd_set_gp_size (bfd *abfd, unsigned int i);
+
+bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
+
+bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_header_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_header_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_merge_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
+
+#define bfd_set_private_flags(abfd, flags) \
+     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
+#define bfd_sizeof_headers(abfd, info) \
+       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, info))
+
+#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_nearest_line, \
+                 (abfd, sec, syms, off, file, func, line))
+
+#define bfd_find_line(abfd, syms, sym, file, line) \
+       BFD_SEND (abfd, _bfd_find_line, \
+                 (abfd, syms, sym, file, line))
+
+#define bfd_find_inliner_info(abfd, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_inliner_info, \
+                 (abfd, file, func, line))
+
+#define bfd_debug_info_start(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
+
+#define bfd_debug_info_end(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
+
+#define bfd_debug_info_accumulate(abfd, section) \
+       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
+
+#define bfd_stat_arch_elt(abfd, stat) \
+       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
+
+#define bfd_update_armap_timestamp(abfd) \
+       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
+
+#define bfd_set_arch_mach(abfd, arch, mach)\
+       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
+
+#define bfd_relax_section(abfd, section, link_info, again) \
+       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
+
+#define bfd_gc_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
+
+#define bfd_merge_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
+
+#define bfd_is_group_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))
+
+#define bfd_discard_group(abfd, sec) \
+       BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
+
+#define bfd_link_hash_table_create(abfd) \
+       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
+
+#define bfd_link_hash_table_free(abfd, hash) \
+       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
+
+#define bfd_link_add_symbols(abfd, info) \
+       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
+
+#define bfd_link_just_syms(abfd, sec, info) \
+       BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
+
+#define bfd_final_link(abfd, info) \
+       BFD_SEND (abfd, _bfd_final_link, (abfd, info))
+
+#define bfd_free_cached_info(abfd) \
+       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
+
+#define bfd_get_dynamic_symtab_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
+
+#define bfd_print_private_bfd_data(abfd, file)\
+       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
+
+#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
+
+#define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
+       BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
+                                                   dyncount, dynsyms, ret))
+
+#define bfd_get_dynamic_reloc_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
+
+#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
+
+extern bfd_byte *bfd_get_relocated_section_contents
+  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
+   bfd_boolean, asymbol **);
+
+bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
+
+struct bfd_preserve
+{
+  void *marker;
+  void *tdata;
+  flagword flags;
+  const struct bfd_arch_info *arch_info;
+  struct bfd_section *sections;
+  struct bfd_section *section_last;
+  unsigned int section_count;
+  struct bfd_hash_table section_htab;
+};
+
+bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_restore (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_finish (bfd *, struct bfd_preserve *);
+
+bfd_vma bfd_emul_get_maxpagesize (const char *);
+
+void bfd_emul_set_maxpagesize (const char *, bfd_vma);
+
+bfd_vma bfd_emul_get_commonpagesize (const char *);
+
+void bfd_emul_set_commonpagesize (const char *, bfd_vma);
+
+char *bfd_demangle (bfd *, const char *, int);
+
+/* Extracted from archive.c.  */
+symindex bfd_get_next_mapent
+   (bfd *abfd, symindex previous, carsym **sym);
+
+bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
+
+bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
+
+/* Extracted from corefile.c.  */
+const char *bfd_core_file_failing_command (bfd *abfd);
+
+int bfd_core_file_failing_signal (bfd *abfd);
+
+bfd_boolean core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+bfd_boolean generic_core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+/* Extracted from targets.c.  */
+#define BFD_SEND(bfd, message, arglist) \
+  ((*((bfd)->xvec->message)) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND
+#define BFD_SEND(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+    ((*((bfd)->xvec->message)) arglist) : \
+    (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND_FMT
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+   (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+
+enum bfd_flavour
+{
+  bfd_target_unknown_flavour,
+  bfd_target_aout_flavour,
+  bfd_target_coff_flavour,
+  bfd_target_ecoff_flavour,
+  bfd_target_xcoff_flavour,
+  bfd_target_elf_flavour,
+  bfd_target_ieee_flavour,
+  bfd_target_nlm_flavour,
+  bfd_target_oasys_flavour,
+  bfd_target_tekhex_flavour,
+  bfd_target_srec_flavour,
+  bfd_target_ihex_flavour,
+  bfd_target_som_flavour,
+  bfd_target_os9k_flavour,
+  bfd_target_versados_flavour,
+  bfd_target_msdos_flavour,
+  bfd_target_ovax_flavour,
+  bfd_target_evax_flavour,
+  bfd_target_mmo_flavour,
+  bfd_target_mach_o_flavour,
+  bfd_target_pef_flavour,
+  bfd_target_pef_xlib_flavour,
+  bfd_target_sym_flavour
+};
+
+enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+
+/* Forward declaration.  */
+typedef struct bfd_link_info _bfd_link_info;
+
+typedef struct bfd_target
+{
+  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
+  char *name;
+
+ /* The "flavour" of a back end is a general indication about
+    the contents of a file.  */
+  enum bfd_flavour flavour;
+
+  /* The order of bytes within the data area of a file.  */
+  enum bfd_endian byteorder;
+
+ /* The order of bytes within the header parts of a file.  */
+  enum bfd_endian header_byteorder;
+
+  /* A mask of all the flags which an executable may have set -
+     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  */
+  flagword object_flags;
+
+ /* A mask of all the flags which a section may have set - from
+    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  */
+  flagword section_flags;
+
+ /* The character normally found at the front of a symbol.
+    (if any), perhaps `_'.  */
+  char symbol_leading_char;
+
+ /* The pad character for file names within an archive header.  */
+  char ar_pad_char;
+
+  /* The maximum number of characters in an archive header.  */
+  unsigned short ar_max_namelen;
+
+  /* Entries for byte swapping for data. These are different from the
+     other entry points, since they don't take a BFD as the first argument.
+     Certain other handlers could do the same.  */
+  bfd_uint64_t   (*bfd_getx64) (const void *);
+  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
+  void           (*bfd_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_getx32) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
+  void           (*bfd_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_getx16) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
+  void           (*bfd_putx16) (bfd_vma, void *);
+
+  /* Byte swapping for the headers.  */
+  bfd_uint64_t   (*bfd_h_getx64) (const void *);
+  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
+  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_h_getx32) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
+  void           (*bfd_h_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_h_getx16) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
+  void           (*bfd_h_putx16) (bfd_vma, void *);
+
+  /* Format dependent routines: these are vectors of entry points
+     within the target vector structure, one for each format to check.  */
+
+  /* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  */
+  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
+
+  /* Set the format of a file being written.  */
+  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
+
+  /* Write cached information into a file being written, at <<bfd_close>>.  */
+  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
+
+
+  /* Generic entry points.  */
+#define BFD_JUMP_TABLE_GENERIC(NAME) \
+  NAME##_close_and_cleanup, \
+  NAME##_bfd_free_cached_info, \
+  NAME##_new_section_hook, \
+  NAME##_get_section_contents, \
+  NAME##_get_section_contents_in_window
+
+  /* Called when the BFD is being closed to do any necessary cleanup.  */
+  bfd_boolean (*_close_and_cleanup) (bfd *);
+  /* Ask the BFD to free all cached information.  */
+  bfd_boolean (*_bfd_free_cached_info) (bfd *);
+  /* Called when a new section is created.  */
+  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
+  /* Read the contents of a section.  */
+  bfd_boolean (*_bfd_get_section_contents)
+    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
+  bfd_boolean (*_bfd_get_section_contents_in_window)
+    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
+
+  /* Entry points to copy private data.  */
+#define BFD_JUMP_TABLE_COPY(NAME) \
+  NAME##_bfd_copy_private_bfd_data, \
+  NAME##_bfd_merge_private_bfd_data, \
+  _bfd_generic_init_private_section_data, \
+  NAME##_bfd_copy_private_section_data, \
+  NAME##_bfd_copy_private_symbol_data, \
+  NAME##_bfd_copy_private_header_data, \
+  NAME##_bfd_set_private_flags, \
+  NAME##_bfd_print_private_bfd_data
+
+  /* Called to copy BFD general private data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
+  /* Called to merge BFD general private data from one object file
+     to a common output file when linking.  */
+  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
+  /* Called to initialize BFD private section data from one object file
+     to another.  */
+#define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
+  BFD_SEND (obfd, _bfd_init_private_section_data, (ibfd, isec, obfd, osec, link_info))
+  bfd_boolean (*_bfd_init_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);
+  /* Called to copy BFD private section data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr);
+  /* Called to copy BFD private symbol data from one symbol
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_symbol_data)
+    (bfd *, asymbol *, bfd *, asymbol *);
+  /* Called to copy BFD private header data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_header_data)
+    (bfd *, bfd *);
+  /* Called to set private backend flags.  */
+  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
+
+  /* Called to print private BFD data.  */
+  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
+
+  /* Core file entry points.  */
+#define BFD_JUMP_TABLE_CORE(NAME) \
+  NAME##_core_file_failing_command, \
+  NAME##_core_file_failing_signal, \
+  NAME##_core_file_matches_executable_p
+
+  char *      (*_core_file_failing_command) (bfd *);
+  int         (*_core_file_failing_signal) (bfd *);
+  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
+
+  /* Archive entry points.  */
+#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
+  NAME##_slurp_armap, \
+  NAME##_slurp_extended_name_table, \
+  NAME##_construct_extended_name_table, \
+  NAME##_truncate_arname, \
+  NAME##_write_armap, \
+  NAME##_read_ar_hdr, \
+  NAME##_openr_next_archived_file, \
+  NAME##_get_elt_at_index, \
+  NAME##_generic_stat_arch_elt, \
+  NAME##_update_armap_timestamp
+
+  bfd_boolean (*_bfd_slurp_armap) (bfd *);
+  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
+  bfd_boolean (*_bfd_construct_extended_name_table)
+    (bfd *, char **, bfd_size_type *, const char **);
+  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
+  bfd_boolean (*write_armap)
+    (bfd *, unsigned int, struct orl *, unsigned int, int);
+  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
+  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
+#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
+  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
+  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
+  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
+
+  /* Entry points used for symbols.  */
+#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
+  NAME##_get_symtab_upper_bound, \
+  NAME##_canonicalize_symtab, \
+  NAME##_make_empty_symbol, \
+  NAME##_print_symbol, \
+  NAME##_get_symbol_info, \
+  NAME##_bfd_is_local_label_name, \
+  NAME##_bfd_is_target_special_symbol, \
+  NAME##_get_lineno, \
+  NAME##_find_nearest_line, \
+  _bfd_generic_find_line, \
+  NAME##_find_inliner_info, \
+  NAME##_bfd_make_debug_symbol, \
+  NAME##_read_minisymbols, \
+  NAME##_minisymbol_to_symbol
+
+  long        (*_bfd_get_symtab_upper_bound) (bfd *);
+  long        (*_bfd_canonicalize_symtab)
+    (bfd *, struct bfd_symbol **);
+  struct bfd_symbol *
+              (*_bfd_make_empty_symbol) (bfd *);
+  void        (*_bfd_print_symbol)
+    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+  void        (*_bfd_get_symbol_info)
+    (bfd *, struct bfd_symbol *, symbol_info *);
+#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
+  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
+  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
+  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
+  bfd_boolean (*_bfd_find_nearest_line)
+    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
+     const char **, const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_line)
+    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
+     const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_inliner_info)
+    (bfd *, const char **, const char **, unsigned int *);
+ /* Back-door to allow format-aware applications to create debug symbols
+    while using BFD for everything else.  Currently used by the assembler
+    when creating COFF files.  */
+  asymbol *   (*_bfd_make_debug_symbol)
+    (bfd *, void *, unsigned long size);
+#define bfd_read_minisymbols(b, d, m, s) \
+  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+  long        (*_read_minisymbols)
+    (bfd *, bfd_boolean, void **, unsigned int *);
+#define bfd_minisymbol_to_symbol(b, d, m, f) \
+  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+  asymbol *   (*_minisymbol_to_symbol)
+    (bfd *, bfd_boolean, const void *, asymbol *);
+
+  /* Routines for relocs.  */
+#define BFD_JUMP_TABLE_RELOCS(NAME) \
+  NAME##_get_reloc_upper_bound, \
+  NAME##_canonicalize_reloc, \
+  NAME##_bfd_reloc_type_lookup, \
+  NAME##_bfd_reloc_name_lookup
+
+  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+  long        (*_bfd_canonicalize_reloc)
+    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
+  /* See documentation on reloc types.  */
+  reloc_howto_type *
+              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
+  reloc_howto_type *
+              (*reloc_name_lookup) (bfd *, const char *);
+
+
+  /* Routines used when writing an object file.  */
+#define BFD_JUMP_TABLE_WRITE(NAME) \
+  NAME##_set_arch_mach, \
+  NAME##_set_section_contents
+
+  bfd_boolean (*_bfd_set_arch_mach)
+    (bfd *, enum bfd_architecture, unsigned long);
+  bfd_boolean (*_bfd_set_section_contents)
+    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
+
+  /* Routines used by the linker.  */
+#define BFD_JUMP_TABLE_LINK(NAME) \
+  NAME##_sizeof_headers, \
+  NAME##_bfd_get_relocated_section_contents, \
+  NAME##_bfd_relax_section, \
+  NAME##_bfd_link_hash_table_create, \
+  NAME##_bfd_link_hash_table_free, \
+  NAME##_bfd_link_add_symbols, \
+  NAME##_bfd_link_just_syms, \
+  NAME##_bfd_final_link, \
+  NAME##_bfd_link_split_section, \
+  NAME##_bfd_gc_sections, \
+  NAME##_bfd_merge_sections, \
+  NAME##_bfd_is_group_section, \
+  NAME##_bfd_discard_group, \
+  NAME##_section_already_linked \
+
+  int         (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
+  bfd_byte *  (*_bfd_get_relocated_section_contents)
+    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+     bfd_byte *, bfd_boolean, struct bfd_symbol **);
+
+  bfd_boolean (*_bfd_relax_section)
+    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
+
+  /* Create a hash table for the linker.  Different backends store
+     different information in this table.  */
+  struct bfd_link_hash_table *
+              (*_bfd_link_hash_table_create) (bfd *);
+
+  /* Release the memory associated with the linker hash table.  */
+  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
+
+  /* Add symbols from this object file into the hash table.  */
+  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
+
+  /* Indicate that we are only retrieving symbol values from this section.  */
+  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
+
+  /* Do a link based on the link_order structures attached to each
+     section of the BFD.  */
+  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
+
+  /* Should this section be split up into smaller pieces during linking.  */
+  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
+
+  /* Remove sections that are not referenced from the output.  */
+  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
+
+  /* Attempt to merge SEC_MERGE sections.  */
+  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
+
+  /* Is this section a member of a group?  */
+  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);
+
+  /* Discard members of a group.  */
+  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
+
+  /* Check if SEC has been already linked during a reloceatable or
+     final link.  */
+  void (*_section_already_linked) (bfd *, struct bfd_section *,
+                                   struct bfd_link_info *);
+
+  /* Routines to handle dynamic symbols and relocs.  */
+#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
+  NAME##_get_dynamic_symtab_upper_bound, \
+  NAME##_canonicalize_dynamic_symtab, \
+  NAME##_get_synthetic_symtab, \
+  NAME##_get_dynamic_reloc_upper_bound, \
+  NAME##_canonicalize_dynamic_reloc
+
+  /* Get the amount of memory required to hold the dynamic symbols.  */
+  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+  /* Read in the dynamic symbols.  */
+  long        (*_bfd_canonicalize_dynamic_symtab)
+    (bfd *, struct bfd_symbol **);
+  /* Create synthetized symbols.  */
+  long        (*_bfd_get_synthetic_symtab)
+    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
+     struct bfd_symbol **);
+  /* Get the amount of memory required to hold the dynamic relocs.  */
+  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+  /* Read in the dynamic relocs.  */
+  long        (*_bfd_canonicalize_dynamic_reloc)
+    (bfd *, arelent **, struct bfd_symbol **);
+
+  /* Opposite endian version of this target.  */
+  const struct bfd_target * alternative_target;
+
+  /* Data for use by back-end routines, which isn't
+     generic enough to belong in this structure.  */
+  const void *backend_data;
+
+} bfd_target;
+
+bfd_boolean bfd_set_default_target (const char *name);
+
+const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
+
+const char ** bfd_target_list (void);
+
+const bfd_target *bfd_search_for_target
+   (int (*search_func) (const bfd_target *, void *),
+    void *);
+
+/* Extracted from format.c.  */
+bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
+
+bfd_boolean bfd_check_format_matches
+   (bfd *abfd, bfd_format format, char ***matching);
+
+bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
+
+const char *bfd_format_string (bfd_format format);
+
+/* Extracted from linker.c.  */
+bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
+
+#define bfd_link_split_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))
+
+void bfd_section_already_linked (bfd *abfd, asection *sec,
+    struct bfd_link_info *info);
+
+#define bfd_section_already_linked(abfd, sec, info) \
+       BFD_SEND (abfd, _section_already_linked, (abfd, sec, info))
+
+/* Extracted from simple.c.  */
+bfd_byte *bfd_simple_get_relocated_section_contents
+   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
--- /dev/null
+++ b/bfd/bfd_stdint.h
@@ -0,0 +1,47 @@
+/* generated for  gcc (GCC) 4.2.4 (Ubuntu 4.2.4-3ubuntu4) */
+
+#ifndef GCC_GENERATED_STDINT_H
+#define GCC_GENERATED_STDINT_H 1
+
+#include <sys/types.h>
+#include <stdint.h>
+/* glibc uses these symbols as guards to prevent redefinitions.  */
+#ifdef __int8_t_defined
+#define _INT8_T
+#define _INT16_T
+#define _INT32_T
+#endif
+#ifdef __uint32_t_defined
+#define _UINT32_T
+#endif
+
+
+/* Some systems have guard macros to prevent redefinitions, define them.  */
+#ifndef _INT8_T
+#define _INT8_T
+#endif
+#ifndef _INT16_T
+#define _INT16_T
+#endif
+#ifndef _INT32_T
+#define _INT32_T
+#endif
+#ifndef _UINT8_T
+#define _UINT8_T
+#endif
+#ifndef _UINT16_T
+#define _UINT16_T
+#endif
+#ifndef _UINT32_T
+#define _UINT32_T
+#endif
+
+/* system headers have good uint64_t and int64_t */
+#ifndef _INT64_T
+#define _INT64_T
+#endif
+#ifndef _UINT64_T
+#define _UINT64_T
+#endif
+
+#endif /* GCC_GENERATED_STDINT_H */
--- a/bfd/configure
+++ b/bfd/configure
@@ -19041,6 +19041,7 @@ do
     bfd_efi_app_ia64_vec)	tb="$tb efi-app-ia64.lo pepigen.lo cofflink.lo"; target_size=64 ;;
     bfd_elf32_am33lin_vec)	tb="$tb elf32-am33lin.lo elf32.lo $elf" ;;
     bfd_elf32_avr_vec)		tb="$tb elf32-avr.lo elf32.lo $elf" ;;
+    bfd_elf32_avr32_vec)	tb="$tb elf32-avr32.lo elf32.lo $elf" ;;
     bfd_elf32_bfin_vec)		tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_bfinfdpic_vec)	tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_big_generic_vec) 	tb="$tb elf32-gen.lo elf32.lo $elf" ;;
--- /dev/null
+++ b/bfd/doc/bfd.h
@@ -0,0 +1,5493 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
+   generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c", 
+   "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c", 
+   "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c", 
+   "linker.c" and "simple.c".
+   Run "make headers" in your build bfd/ to regenerate.  */
+
+/* Main header file for the bfd library -- portable access to object files.
+
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   Contributed by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef __BFD_H_SEEN__
+#define __BFD_H_SEEN__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ansidecl.h"
+#include "symcat.h"
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#ifndef SABER
+/* This hack is to avoid a problem with some strict ANSI C preprocessors.
+   The problem is, "32_" is not a valid preprocessing token, and we don't
+   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
+   cause the inner CONCAT2 macros to be evaluated first, producing
+   still-valid pp-tokens.  Then the final concatenation can be done.  */
+#undef CONCAT4
+#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
+#endif
+#endif
+
+/* This is a utility macro to handle the situation where the code
+   wants to place a constant string into the code, followed by a
+   comma and then the length of the string.  Doing this by hand
+   is error prone, so using this macro is safer.  The macro will
+   also safely handle the case where a NULL is passed as the arg.  */
+#define STRING_COMMA_LEN(STR) (STR), ((STR) ? sizeof (STR) - 1 : 0)
+/* Unfortunately it is not possible to use the STRING_COMMA_LEN macro
+   to create the arguments to another macro, since the preprocessor
+   will mis-count the number of arguments to the outer macro (by not
+   evaluating STRING_COMMA_LEN and so missing the comma).  This is a
+   problem for example when trying to use STRING_COMMA_LEN to build
+   the arguments to the strncmp() macro.  Hence this alternative
+   definition of strncmp is provided here.
+   
+   Note - these macros do NOT work if STR2 is not a constant string.  */
+#define CONST_STRNEQ(STR1,STR2) (strncmp ((STR1), (STR2), sizeof (STR2) - 1) == 0)
+  /* strcpy() can have a similar problem, but since we know we are
+     copying a constant string, we can use memcpy which will be faster
+     since there is no need to check for a NUL byte inside STR.  We
+     can also save time if we do not need to copy the terminating NUL.  */
+#define LITMEMCPY(DEST,STR2) memcpy ((DEST), (STR2), sizeof (STR2) - 1)
+#define LITSTRCPY(DEST,STR2) memcpy ((DEST), (STR2), sizeof (STR2))
+
+
+/* The word size used by BFD on the host.  This may be 64 with a 32
+   bit target if the host is 64 bit, or if other 64 bit targets have
+   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
+#define BFD_ARCH_SIZE @wordsize@
+
+/* The word size of the default bfd target.  */
+#define BFD_DEFAULT_TARGET_SIZE @bfd_default_target_size@
+
+#define BFD_HOST_64BIT_LONG @BFD_HOST_64BIT_LONG@
+#define BFD_HOST_64BIT_LONG_LONG @BFD_HOST_64BIT_LONG_LONG@
+#define BFD_HOST_LONG_LONG @BFD_HOST_LONG_LONG@
+#if @BFD_HOST_64_BIT_DEFINED@
+#define BFD_HOST_64_BIT @BFD_HOST_64_BIT@
+#define BFD_HOST_U_64_BIT @BFD_HOST_U_64_BIT@
+typedef BFD_HOST_64_BIT bfd_int64_t;
+typedef BFD_HOST_U_64_BIT bfd_uint64_t;
+#endif
+
+#if BFD_ARCH_SIZE >= 64
+#define BFD64
+#endif
+
+#ifndef INLINE
+#if __GNUC__ >= 2
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+/* Declaring a type wide enough to hold a host long and a host pointer.  */
+#define BFD_HOSTPTR_T	@BFD_HOSTPTR_T@
+typedef BFD_HOSTPTR_T bfd_hostptr_t;
+
+/* Forward declaration.  */
+typedef struct bfd bfd;
+
+/* Boolean type used in bfd.  Too many systems define their own
+   versions of "boolean" for us to safely typedef a "boolean" of
+   our own.  Using an enum for "bfd_boolean" has its own set of
+   problems, with strange looking casts required to avoid warnings
+   on some older compilers.  Thus we just use an int.
+
+   General rule: Functions which are bfd_boolean return TRUE on
+   success and FALSE on failure (unless they're a predicate).  */
+
+typedef int bfd_boolean;
+#undef FALSE
+#undef TRUE
+#define FALSE 0
+#define TRUE 1
+
+#ifdef BFD64
+
+#ifndef BFD_HOST_64_BIT
+ #error No 64 bit integer type available
+#endif /* ! defined (BFD_HOST_64_BIT) */
+
+typedef BFD_HOST_U_64_BIT bfd_vma;
+typedef BFD_HOST_64_BIT bfd_signed_vma;
+typedef BFD_HOST_U_64_BIT bfd_size_type;
+typedef BFD_HOST_U_64_BIT symvalue;
+
+#ifndef fprintf_vma
+#if BFD_HOST_64BIT_LONG
+#define sprintf_vma(s,x) sprintf (s, "%016lx", x)
+#define fprintf_vma(f,x) fprintf (f, "%016lx", x)
+#elif BFD_HOST_64BIT_LONG_LONG
+#define sprintf_vma(s,x) sprintf (s, "%016llx", x)
+#define fprintf_vma(f,x) fprintf (f, "%016llx", x)
+#else
+#define _bfd_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
+#define _bfd_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
+#define fprintf_vma(s,x) \
+  fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#define sprintf_vma(s,x) \
+  sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#endif
+#endif
+
+#else /* not BFD64  */
+
+/* Represent a target address.  Also used as a generic unsigned type
+   which is guaranteed to be big enough to hold any arithmetic types
+   we need to deal with.  */
+typedef unsigned long bfd_vma;
+
+/* A generic signed type which is guaranteed to be big enough to hold any
+   arithmetic types we need to deal with.  Can be assumed to be compatible
+   with bfd_vma in the same way that signed and unsigned ints are compatible
+   (as parameters, in assignment, etc).  */
+typedef long bfd_signed_vma;
+
+typedef unsigned long symvalue;
+typedef unsigned long bfd_size_type;
+
+/* Print a bfd_vma x on stream s.  */
+#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
+#define sprintf_vma(s,x) sprintf (s, "%08lx", x)
+
+#endif /* not BFD64  */
+
+#define HALF_BFD_SIZE_TYPE \
+  (((bfd_size_type) 1) << (8 * sizeof (bfd_size_type) / 2))
+
+#ifndef BFD_HOST_64_BIT
+/* Fall back on a 32 bit type.  The idea is to make these types always
+   available for function return types, but in the case that
+   BFD_HOST_64_BIT is undefined such a function should abort or
+   otherwise signal an error.  */
+typedef bfd_signed_vma bfd_int64_t;
+typedef bfd_vma bfd_uint64_t;
+#endif
+
+/* An offset into a file.  BFD always uses the largest possible offset
+   based on the build time availability of fseek, fseeko, or fseeko64.  */
+typedef @bfd_file_ptr@ file_ptr;
+typedef unsigned @bfd_file_ptr@ ufile_ptr;
+
+extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
+extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);
+
+#define printf_vma(x) fprintf_vma(stdout,x)
+#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)
+
+typedef unsigned int flagword;	/* 32 bits of flags */
+typedef unsigned char bfd_byte;
+
+/* File formats.  */
+
+typedef enum bfd_format
+{
+  bfd_unknown = 0,	/* File format is unknown.  */
+  bfd_object,		/* Linker/assembler/compiler output.  */
+  bfd_archive,		/* Object archive file.  */
+  bfd_core,		/* Core dump.  */
+  bfd_type_end		/* Marks the end; don't use it!  */
+}
+bfd_format;
+
+/* Values that may appear in the flags field of a BFD.  These also
+   appear in the object_flags field of the bfd_target structure, where
+   they indicate the set of flags used by that backend (not all flags
+   are meaningful for all object file formats) (FIXME: at the moment,
+   the object_flags values have mostly just been copied from backend
+   to another, and are not necessarily correct).  */
+
+/* No flags.  */
+#define BFD_NO_FLAGS   	0x00
+
+/* BFD contains relocation entries.  */
+#define HAS_RELOC   	0x01
+
+/* BFD is directly executable.  */
+#define EXEC_P      	0x02
+
+/* BFD has line number information (basically used for F_LNNO in a
+   COFF header).  */
+#define HAS_LINENO  	0x04
+
+/* BFD has debugging information.  */
+#define HAS_DEBUG   	0x08
+
+/* BFD has symbols.  */
+#define HAS_SYMS    	0x10
+
+/* BFD has local symbols (basically used for F_LSYMS in a COFF
+   header).  */
+#define HAS_LOCALS  	0x20
+
+/* BFD is a dynamic object.  */
+#define DYNAMIC     	0x40
+
+/* Text section is write protected (if D_PAGED is not set, this is
+   like an a.out NMAGIC file) (the linker sets this by default, but
+   clears it for -r or -N).  */
+#define WP_TEXT     	0x80
+
+/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
+   linker sets this by default, but clears it for -r or -n or -N).  */
+#define D_PAGED     	0x100
+
+/* BFD is relaxable (this means that bfd_relax_section may be able to
+   do something) (sometimes bfd_relax_section can do something even if
+   this is not set).  */
+#define BFD_IS_RELAXABLE 0x200
+
+/* This may be set before writing out a BFD to request using a
+   traditional format.  For example, this is used to request that when
+   writing out an a.out object the symbols not be hashed to eliminate
+   duplicates.  */
+#define BFD_TRADITIONAL_FORMAT 0x400
+
+/* This flag indicates that the BFD contents are actually cached in
+   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
+#define BFD_IN_MEMORY 0x800
+
+/* The sections in this BFD specify a memory page.  */
+#define HAS_LOAD_PAGE 0x1000
+
+/* This BFD has been created by the linker and doesn't correspond
+   to any input file.  */
+#define BFD_LINKER_CREATED 0x2000
+
+/* Symbols and relocation.  */
+
+/* A count of carsyms (canonical archive symbols).  */
+typedef unsigned long symindex;
+
+/* How to perform a relocation.  */
+typedef const struct reloc_howto_struct reloc_howto_type;
+
+#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)
+
+/* General purpose part of a symbol X;
+   target specific parts are in libcoff.h, libaout.h, etc.  */
+
+#define bfd_get_section(x) ((x)->section)
+#define bfd_get_output_section(x) ((x)->section->output_section)
+#define bfd_set_section(x,y) ((x)->section) = (y)
+#define bfd_asymbol_base(x) ((x)->section->vma)
+#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
+#define bfd_asymbol_name(x) ((x)->name)
+/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
+#define bfd_asymbol_bfd(x) ((x)->the_bfd)
+#define bfd_asymbol_flavour(x) (bfd_asymbol_bfd(x)->xvec->flavour)
+
+/* A canonical archive symbol.  */
+/* This is a type pun with struct ranlib on purpose!  */
+typedef struct carsym
+{
+  char *name;
+  file_ptr file_offset;	/* Look here to find the file.  */
+}
+carsym;			/* To make these you call a carsymogen.  */
+
+/* Used in generating armaps (archive tables of contents).
+   Perhaps just a forward definition would do?  */
+struct orl 			/* Output ranlib.  */
+{
+  char **name;		/* Symbol name.  */
+  union
+  {
+    file_ptr pos;
+    bfd *abfd;
+  } u;			/* bfd* or file position.  */
+  int namidx;		/* Index into string table.  */
+};
+
+/* Linenumber stuff.  */
+typedef struct lineno_cache_entry
+{
+  unsigned int line_number;	/* Linenumber from start of function.  */
+  union
+  {
+    struct bfd_symbol *sym;	/* Function name.  */
+    bfd_vma offset;	    		/* Offset into section.  */
+  } u;
+}
+alent;
+
+/* Object and core file sections.  */
+
+#define	align_power(addr, align)	\
+  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
+
+typedef struct bfd_section *sec_ptr;
+
+#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
+#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
+#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
+#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
+#define bfd_section_name(bfd, ptr) ((ptr)->name)
+#define bfd_section_size(bfd, ptr) ((ptr)->size)
+#define bfd_get_section_size(ptr) ((ptr)->size)
+#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
+#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
+#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
+#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
+#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)
+
+#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)
+
+#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
+#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
+#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)
+/* Find the address one past the end of SEC.  */
+#define bfd_get_section_limit(bfd, sec) \
+  (((sec)->rawsize ? (sec)->rawsize : (sec)->size) \
+   / bfd_octets_per_byte (bfd))
+
+/* Return TRUE if section has been discarded.  */
+#define elf_discarded_section(sec)				\
+  (!bfd_is_abs_section (sec)					\
+   && bfd_is_abs_section ((sec)->output_section)		\
+   && (sec)->sec_info_type != ELF_INFO_TYPE_MERGE		\
+   && (sec)->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
+
+/* Forward define.  */
+struct stat;
+
+typedef enum bfd_print_symbol
+{
+  bfd_print_symbol_name,
+  bfd_print_symbol_more,
+  bfd_print_symbol_all
+} bfd_print_symbol_type;
+
+/* Information about a symbol that nm needs.  */
+
+typedef struct _symbol_info
+{
+  symvalue value;
+  char type;
+  const char *name;            /* Symbol name.  */
+  unsigned char stab_type;     /* Stab type.  */
+  char stab_other;             /* Stab other.  */
+  short stab_desc;             /* Stab desc.  */
+  const char *stab_name;       /* String for stab type.  */
+} symbol_info;
+
+/* Get the name of a stabs type code.  */
+
+extern const char *bfd_get_stab_name (int);
+
+/* Hash table routines.  There is no way to free up a hash table.  */
+
+/* An element in the hash table.  Most uses will actually use a larger
+   structure, and an instance of this will be the first field.  */
+
+struct bfd_hash_entry
+{
+  /* Next entry for this hash code.  */
+  struct bfd_hash_entry *next;
+  /* String being hashed.  */
+  const char *string;
+  /* Hash code.  This is the full hash code, not the index into the
+     table.  */
+  unsigned long hash;
+};
+
+/* A hash table.  */
+
+struct bfd_hash_table
+{
+  /* The hash array.  */
+  struct bfd_hash_entry **table;
+  /* A function used to create new elements in the hash table.  The
+     first entry is itself a pointer to an element.  When this
+     function is first invoked, this pointer will be NULL.  However,
+     having the pointer permits a hierarchy of method functions to be
+     built each of which calls the function in the superclass.  Thus
+     each function should be written to allocate a new block of memory
+     only if the argument is NULL.  */
+  struct bfd_hash_entry *(*newfunc)
+    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+   /* An objalloc for this hash table.  This is a struct objalloc *,
+     but we use void * to avoid requiring the inclusion of objalloc.h.  */
+  void *memory;
+  /* The number of slots in the hash table.  */
+  unsigned int size;
+  /* The number of entries in the hash table.  */
+  unsigned int count;
+  /* The size of elements.  */
+  unsigned int entsize;
+  /* If non-zero, don't grow the hash table.  */
+  unsigned int frozen:1;
+};
+
+/* Initialize a hash table.  */
+extern bfd_boolean bfd_hash_table_init
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int);
+
+/* Initialize a hash table specifying a size.  */
+extern bfd_boolean bfd_hash_table_init_n
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int, unsigned int);
+
+/* Free up a hash table.  */
+extern void bfd_hash_table_free
+  (struct bfd_hash_table *);
+
+/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
+   will be created for this string if one does not already exist.  The
+   COPY argument must be TRUE if this routine should copy the string
+   into newly allocated memory when adding an entry.  */
+extern struct bfd_hash_entry *bfd_hash_lookup
+  (struct bfd_hash_table *, const char *, bfd_boolean create,
+   bfd_boolean copy);
+
+/* Replace an entry in a hash table.  */
+extern void bfd_hash_replace
+  (struct bfd_hash_table *, struct bfd_hash_entry *old,
+   struct bfd_hash_entry *nw);
+
+/* Base method for creating a hash table entry.  */
+extern struct bfd_hash_entry *bfd_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+
+/* Grab some space for a hash table entry.  */
+extern void *bfd_hash_allocate
+  (struct bfd_hash_table *, unsigned int);
+
+/* Traverse a hash table in a random order, calling a function on each
+   element.  If the function returns FALSE, the traversal stops.  The
+   INFO argument is passed to the function.  */
+extern void bfd_hash_traverse
+  (struct bfd_hash_table *,
+   bfd_boolean (*) (struct bfd_hash_entry *, void *),
+   void *info);
+
+/* Allows the default size of a hash table to be configured. New hash
+   tables allocated using bfd_hash_table_init will be created with
+   this size.  */
+extern void bfd_hash_set_default_size (bfd_size_type);
+
+/* This structure is used to keep track of stabs in sections
+   information while linking.  */
+
+struct stab_info
+{
+  /* A hash table used to hold stabs strings.  */
+  struct bfd_strtab_hash *strings;
+  /* The header file hash table.  */
+  struct bfd_hash_table includes;
+  /* The first .stabstr section.  */
+  struct bfd_section *stabstr;
+};
+
+#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table
+
+/* User program access to BFD facilities.  */
+
+/* Direct I/O routines, for programs which know more about the object
+   file than BFD does.  Use higher level routines if possible.  */
+
+extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
+extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
+extern int bfd_seek (bfd *, file_ptr, int);
+extern file_ptr bfd_tell (bfd *);
+extern int bfd_flush (bfd *);
+extern int bfd_stat (bfd *, struct stat *);
+
+/* Deprecated old routines.  */
+#if __GNUC__
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#else
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#endif
+extern void warn_deprecated (const char *, const char *, int, const char *);
+
+/* Cast from const char * to char * so that caller can assign to
+   a char * without a warning.  */
+#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
+#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
+#define bfd_get_format(abfd) ((abfd)->format)
+#define bfd_get_target(abfd) ((abfd)->xvec->name)
+#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
+#define bfd_family_coff(abfd) \
+  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
+   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
+#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
+#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_header_big_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
+#define bfd_header_little_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_get_file_flags(abfd) ((abfd)->flags)
+#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
+#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
+#define bfd_my_archive(abfd) ((abfd)->my_archive)
+#define bfd_has_map(abfd) ((abfd)->has_armap)
+
+#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
+#define bfd_usrdata(abfd) ((abfd)->usrdata)
+
+#define bfd_get_start_address(abfd) ((abfd)->start_address)
+#define bfd_get_symcount(abfd) ((abfd)->symcount)
+#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
+#define bfd_count_sections(abfd) ((abfd)->section_count)
+
+#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)
+
+#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)
+
+#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)
+
+extern bfd_boolean bfd_cache_close
+  (bfd *abfd);
+/* NB: This declaration should match the autogenerated one in libbfd.h.  */
+
+extern bfd_boolean bfd_cache_close_all (void);
+
+extern bfd_boolean bfd_record_phdr
+  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
+   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
+
+/* Byte swapping routines.  */
+
+bfd_uint64_t bfd_getb64 (const void *);
+bfd_uint64_t bfd_getl64 (const void *);
+bfd_int64_t bfd_getb_signed_64 (const void *);
+bfd_int64_t bfd_getl_signed_64 (const void *);
+bfd_vma bfd_getb32 (const void *);
+bfd_vma bfd_getl32 (const void *);
+bfd_signed_vma bfd_getb_signed_32 (const void *);
+bfd_signed_vma bfd_getl_signed_32 (const void *);
+bfd_vma bfd_getb16 (const void *);
+bfd_vma bfd_getl16 (const void *);
+bfd_signed_vma bfd_getb_signed_16 (const void *);
+bfd_signed_vma bfd_getl_signed_16 (const void *);
+void bfd_putb64 (bfd_uint64_t, void *);
+void bfd_putl64 (bfd_uint64_t, void *);
+void bfd_putb32 (bfd_vma, void *);
+void bfd_putl32 (bfd_vma, void *);
+void bfd_putb16 (bfd_vma, void *);
+void bfd_putl16 (bfd_vma, void *);
+
+/* Byte swapping routines which take size and endiannes as arguments.  */
+
+bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
+void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
+
+extern bfd_boolean bfd_section_already_linked_table_init (void);
+extern void bfd_section_already_linked_table_free (void);
+
+/* Externally visible ECOFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct ecoff_debug_info;
+struct ecoff_debug_swap;
+struct ecoff_extr;
+struct bfd_symbol;
+struct bfd_link_info;
+struct bfd_link_hash_entry;
+struct bfd_elf_version_tree;
+#endif
+extern bfd_vma bfd_ecoff_get_gp_value
+  (bfd * abfd);
+extern bfd_boolean bfd_ecoff_set_gp_value
+  (bfd *abfd, bfd_vma gp_value);
+extern bfd_boolean bfd_ecoff_set_regmasks
+  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
+   unsigned long *cprmask);
+extern void *bfd_ecoff_debug_init
+  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern void bfd_ecoff_debug_free
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct ecoff_debug_info *input_debug,
+   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate_other
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_externals
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
+   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
+   void (*set_index) (struct bfd_symbol *, bfd_size_type));
+extern bfd_boolean bfd_ecoff_debug_one_external
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, const char *name,
+   struct ecoff_extr *esym);
+extern bfd_size_type bfd_ecoff_debug_size
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap);
+extern bfd_boolean bfd_ecoff_write_debug
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, file_ptr where);
+extern bfd_boolean bfd_ecoff_write_accumulated_debug
+  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap,
+   struct bfd_link_info *info, file_ptr where);
+
+/* Externally visible ELF routines.  */
+
+struct bfd_link_needed_list
+{
+  struct bfd_link_needed_list *next;
+  bfd *by;
+  const char *name;
+};
+
+enum dynamic_lib_link_class {
+  DYN_NORMAL = 0,
+  DYN_AS_NEEDED = 1,
+  DYN_DT_NEEDED = 2,
+  DYN_NO_ADD_NEEDED = 4,
+  DYN_NO_NEEDED = 8
+};
+
+enum notice_asneeded_action {
+  notice_as_needed,
+  notice_not_needed,
+  notice_needed
+};
+
+extern bfd_boolean bfd_elf_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
+   bfd_boolean);
+extern struct bfd_link_needed_list *bfd_elf_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_get_bfd_needed_list
+  (bfd *, struct bfd_link_needed_list **);
+extern bfd_boolean bfd_elf_size_dynamic_sections
+  (bfd *, const char *, const char *, const char *, const char * const *,
+   struct bfd_link_info *, struct bfd_section **,
+   struct bfd_elf_version_tree *);
+extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
+  (bfd *, struct bfd_link_info *);
+extern void bfd_elf_set_dt_needed_name
+  (bfd *, const char *);
+extern const char *bfd_elf_get_dt_soname
+  (bfd *);
+extern void bfd_elf_set_dyn_lib_class
+  (bfd *, enum dynamic_lib_link_class);
+extern int bfd_elf_get_dyn_lib_class
+  (bfd *);
+extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_discard_info
+  (bfd *, struct bfd_link_info *);
+extern unsigned int _bfd_elf_default_action_discarded
+  (struct bfd_section *);
+
+/* Return an upper bound on the number of bytes required to store a
+   copy of ABFD's program header table entries.  Return -1 if an error
+   occurs; bfd_get_error will return an appropriate code.  */
+extern long bfd_get_elf_phdr_upper_bound
+  (bfd *abfd);
+
+/* Copy ABFD's program header table entries to *PHDRS.  The entries
+   will be stored as an array of Elf_Internal_Phdr structures, as
+   defined in include/elf/internal.h.  To find out how large the
+   buffer needs to be, call bfd_get_elf_phdr_upper_bound.
+
+   Return the number of program header table entries read, or -1 if an
+   error occurs; bfd_get_error will return an appropriate code.  */
+extern int bfd_get_elf_phdrs
+  (bfd *abfd, void *phdrs);
+
+/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
+   reconstruct an ELF file by reading the segments out of remote memory
+   based on the ELF file header at EHDR_VMA and the ELF program headers it
+   points to.  If not null, *LOADBASEP is filled in with the difference
+   between the VMAs from which the segments were read, and the VMAs the
+   file headers (and hence BFD's idea of each section's VMA) put them at.
+
+   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
+   remote memory at target address VMA into the local buffer at MYADDR; it
+   should return zero on success or an `errno' code on failure.  TEMPL must
+   be a BFD for an ELF target with the word size and byte order found in
+   the remote memory.  */
+extern bfd *bfd_elf_bfd_from_remote_memory
+  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
+   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr, int len));
+
+/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
+extern int bfd_get_arch_size
+  (bfd *);
+
+/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
+extern int bfd_get_sign_extend_vma
+  (bfd *);
+
+extern struct bfd_section *_bfd_elf_tls_setup
+  (bfd *, struct bfd_link_info *);
+
+extern void _bfd_fix_excluded_sec_syms
+  (bfd *, struct bfd_link_info *);
+
+extern unsigned bfd_m68k_mach_to_features (int);
+
+extern int bfd_m68k_features_to_mach (unsigned);
+
+extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+/* SunOS shared library support routines for the linker.  */
+
+extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sunos_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_sunos_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, struct bfd_section **,
+   struct bfd_section **, struct bfd_section **);
+
+/* Linux shared library support routines for the linker.  */
+
+extern bfd_boolean bfd_i386linux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_m68klinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sparclinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+
+/* mmap hacks */
+
+struct _bfd_window_internal;
+typedef struct _bfd_window_internal bfd_window_internal;
+
+typedef struct _bfd_window
+{
+  /* What the user asked for.  */
+  void *data;
+  bfd_size_type size;
+  /* The actual window used by BFD.  Small user-requested read-only
+     regions sharing a page may share a single window into the object
+     file.  Read-write versions shouldn't until I've fixed things to
+     keep track of which portions have been claimed by the
+     application; don't want to give the same region back when the
+     application wants two writable copies!  */
+  struct _bfd_window_internal *i;
+}
+bfd_window;
+
+extern void bfd_init_window
+  (bfd_window *);
+extern void bfd_free_window
+  (bfd_window *);
+extern bfd_boolean bfd_get_file_window
+  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);
+
+/* XCOFF support routines for the linker.  */
+
+extern bfd_boolean bfd_xcoff_link_record_set
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
+extern bfd_boolean bfd_xcoff_import_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
+   const char *, const char *, const char *, unsigned int);
+extern bfd_boolean bfd_xcoff_export_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
+extern bfd_boolean bfd_xcoff_link_count_reloc
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, const char *, const char *,
+   unsigned long, unsigned long, unsigned long, bfd_boolean,
+   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
+extern bfd_boolean bfd_xcoff_link_generate_rtinit
+  (bfd *, const char *, const char *, bfd_boolean);
+
+/* XCOFF support routines for ar.  */
+extern bfd_boolean bfd_xcoff_ar_archive_set_magic
+  (bfd *, char *);
+
+/* Externally visible COFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct internal_syment;
+union internal_auxent;
+#endif
+
+extern bfd_boolean bfd_coff_get_syment
+  (bfd *, struct bfd_symbol *, struct internal_syment *);
+
+extern bfd_boolean bfd_coff_get_auxent
+  (bfd *, struct bfd_symbol *, int, union internal_auxent *);
+
+extern bfd_boolean bfd_coff_set_symbol_class
+  (bfd *, struct bfd_symbol *, unsigned int);
+
+extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
+
+/* ARM VFP11 erratum workaround support.  */
+typedef enum
+{
+  BFD_ARM_VFP11_FIX_DEFAULT,
+  BFD_ARM_VFP11_FIX_NONE,
+  BFD_ARM_VFP11_FIX_SCALAR,
+  BFD_ARM_VFP11_FIX_VECTOR
+} bfd_arm_vfp11_fix;
+
+extern void bfd_elf32_arm_init_maps
+  (bfd *);
+
+extern void bfd_elf32_arm_set_vfp11_fix
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_vfp11_fix_veneer_locations
+  (bfd *, struct bfd_link_info *);
+
+/* ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* PE ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_pe_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *);
+
+void bfd_elf32_arm_set_target_relocs
+  (bfd *, struct bfd_link_info *, int, char *, int, int, bfd_arm_vfp11_fix,
+   int, int);
+
+extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM mapping symbol support */
+#define BFD_ARM_SPECIAL_SYM_TYPE_MAP	(1 << 0)
+#define BFD_ARM_SPECIAL_SYM_TYPE_TAG	(1 << 1)
+#define BFD_ARM_SPECIAL_SYM_TYPE_OTHER  (1 << 2)
+#define BFD_ARM_SPECIAL_SYM_TYPE_ANY	(~0)
+extern bfd_boolean bfd_is_arm_special_symbol_name
+  (const char * name, int type);
+
+extern void bfd_elf32_arm_set_byteswap_code (struct bfd_link_info *, int);
+
+/* ARM Note section processing.  */
+extern bfd_boolean bfd_arm_merge_machines
+  (bfd *, bfd *);
+
+extern bfd_boolean bfd_arm_update_notes
+  (bfd *, const char *);
+
+extern unsigned int bfd_arm_get_mach_from_notes
+  (bfd *, const char *);
+
+/* TI COFF load page support.  */
+extern void bfd_ticoff_set_section_load_page
+  (struct bfd_section *, int);
+
+extern int bfd_ticoff_get_section_load_page
+  (struct bfd_section *);
+
+/* H8/300 functions.  */
+extern bfd_vma bfd_h8300_pad_address
+  (bfd *, bfd_vma);
+
+/* IA64 Itanium code generation.  Called from linker.  */
+extern void bfd_elf32_ia64_after_parse
+  (int);
+
+extern void bfd_elf64_ia64_after_parse
+  (int);
+
+/* This structure is used for a comdat section, as in PE.  A comdat
+   section is associated with a particular symbol.  When the linker
+   sees a comdat section, it keeps only one of the sections with a
+   given name and associated with a given symbol.  */
+
+struct coff_comdat_info
+{
+  /* The name of the symbol associated with a comdat section.  */
+  const char *name;
+
+  /* The local symbol table index of the symbol associated with a
+     comdat section.  This is only meaningful to the object file format
+     specific code; it is not an index into the list returned by
+     bfd_canonicalize_symtab.  */
+  long symbol;
+};
+
+extern struct coff_comdat_info *bfd_coff_get_comdat_section
+  (bfd *, struct bfd_section *);
+
+/* Extracted from init.c.  */
+void bfd_init (void);
+
+/* Extracted from opncls.c.  */
+bfd *bfd_fopen (const char *filename, const char *target,
+    const char *mode, int fd);
+
+bfd *bfd_openr (const char *filename, const char *target);
+
+bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
+
+bfd *bfd_openstreamr (const char *, const char *, void *);
+
+bfd *bfd_openr_iovec (const char *filename, const char *target,
+    void *(*open) (struct bfd *nbfd,
+    void *open_closure),
+    void *open_closure,
+    file_ptr (*pread) (struct bfd *nbfd,
+    void *stream,
+    void *buf,
+    file_ptr nbytes,
+    file_ptr offset),
+    int (*close) (struct bfd *nbfd,
+    void *stream),
+    int (*stat) (struct bfd *abfd,
+    void *stream,
+    struct stat *sb));
+
+bfd *bfd_openw (const char *filename, const char *target);
+
+bfd_boolean bfd_close (bfd *abfd);
+
+bfd_boolean bfd_close_all_done (bfd *);
+
+bfd *bfd_create (const char *filename, bfd *templ);
+
+bfd_boolean bfd_make_writable (bfd *abfd);
+
+bfd_boolean bfd_make_readable (bfd *abfd);
+
+unsigned long bfd_calc_gnu_debuglink_crc32
+   (unsigned long crc, const unsigned char *buf, bfd_size_type len);
+
+char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
+
+struct bfd_section *bfd_create_gnu_debuglink_section
+   (bfd *abfd, const char *filename);
+
+bfd_boolean bfd_fill_in_gnu_debuglink_section
+   (bfd *abfd, struct bfd_section *sect, const char *filename);
+
+/* Extracted from libbfd.c.  */
+
+/* Byte swapping macros for user section data.  */
+
+#define bfd_put_8(abfd, val, ptr) \
+  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
+#define bfd_put_signed_8 \
+  bfd_put_8
+#define bfd_get_8(abfd, ptr) \
+  (*(unsigned char *) (ptr) & 0xff)
+#define bfd_get_signed_8(abfd, ptr) \
+  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
+
+#define bfd_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
+#define bfd_put_signed_16 \
+  bfd_put_16
+#define bfd_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx16, (ptr))
+#define bfd_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
+
+#define bfd_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
+#define bfd_put_signed_32 \
+  bfd_put_32
+#define bfd_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx32, (ptr))
+#define bfd_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
+
+#define bfd_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
+#define bfd_put_signed_64 \
+  bfd_put_64
+#define bfd_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx64, (ptr))
+#define bfd_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
+
+#define bfd_get(bits, abfd, ptr)                       \
+  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
+   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
+   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
+   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
+   : (abort (), (bfd_vma) - 1))
+
+#define bfd_put(bits, abfd, val, ptr)                  \
+  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
+   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
+   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
+   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
+   : (abort (), (void) 0))
+
+
+/* Byte swapping macros for file header data.  */
+
+#define bfd_h_put_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_put_signed_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_get_8(abfd, ptr) \
+  bfd_get_8 (abfd, ptr)
+#define bfd_h_get_signed_8(abfd, ptr) \
+  bfd_get_signed_8 (abfd, ptr)
+
+#define bfd_h_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
+#define bfd_h_put_signed_16 \
+  bfd_h_put_16
+#define bfd_h_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx16, (ptr))
+#define bfd_h_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
+
+#define bfd_h_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
+#define bfd_h_put_signed_32 \
+  bfd_h_put_32
+#define bfd_h_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx32, (ptr))
+#define bfd_h_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
+
+#define bfd_h_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
+#define bfd_h_put_signed_64 \
+  bfd_h_put_64
+#define bfd_h_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx64, (ptr))
+#define bfd_h_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
+
+/* Aliases for the above, which should eventually go away.  */
+
+#define H_PUT_64  bfd_h_put_64
+#define H_PUT_32  bfd_h_put_32
+#define H_PUT_16  bfd_h_put_16
+#define H_PUT_8   bfd_h_put_8
+#define H_PUT_S64 bfd_h_put_signed_64
+#define H_PUT_S32 bfd_h_put_signed_32
+#define H_PUT_S16 bfd_h_put_signed_16
+#define H_PUT_S8  bfd_h_put_signed_8
+#define H_GET_64  bfd_h_get_64
+#define H_GET_32  bfd_h_get_32
+#define H_GET_16  bfd_h_get_16
+#define H_GET_8   bfd_h_get_8
+#define H_GET_S64 bfd_h_get_signed_64
+#define H_GET_S32 bfd_h_get_signed_32
+#define H_GET_S16 bfd_h_get_signed_16
+#define H_GET_S8  bfd_h_get_signed_8
+
+
+/* Extracted from bfdio.c.  */
+long bfd_get_mtime (bfd *abfd);
+
+file_ptr bfd_get_size (bfd *abfd);
+
+/* Extracted from bfdwin.c.  */
+/* Extracted from section.c.  */
+typedef struct bfd_section
+{
+  /* The name of the section; the name isn't a copy, the pointer is
+     the same as that passed to bfd_make_section.  */
+  const char *name;
+
+  /* A unique sequence number.  */
+  int id;
+
+  /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
+  int index;
+
+  /* The next section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *next;
+
+  /* The previous section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *prev;
+
+  /* The field flags contains attributes of the section. Some
+     flags are read in from the object file, and some are
+     synthesized from other information.  */
+  flagword flags;
+
+#define SEC_NO_FLAGS   0x000
+
+  /* Tells the OS to allocate space for this section when loading.
+     This is clear for a section containing debug information only.  */
+#define SEC_ALLOC      0x001
+
+  /* Tells the OS to load the section from the file when loading.
+     This is clear for a .bss section.  */
+#define SEC_LOAD       0x002
+
+  /* The section contains data still to be relocated, so there is
+     some relocation information too.  */
+#define SEC_RELOC      0x004
+
+  /* A signal to the OS that the section contains read only data.  */
+#define SEC_READONLY   0x008
+
+  /* The section contains code only.  */
+#define SEC_CODE       0x010
+
+  /* The section contains data only.  */
+#define SEC_DATA       0x020
+
+  /* The section will reside in ROM.  */
+#define SEC_ROM        0x040
+
+  /* The section contains constructor information. This section
+     type is used by the linker to create lists of constructors and
+     destructors used by <<g++>>. When a back end sees a symbol
+     which should be used in a constructor list, it creates a new
+     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
+     the symbol to it, and builds a relocation. To build the lists
+     of constructors, all the linker has to do is catenate all the
+     sections called <<__CTOR_LIST__>> and relocate the data
+     contained within - exactly the operations it would peform on
+     standard data.  */
+#define SEC_CONSTRUCTOR 0x080
+
+  /* The section has contents - a data section could be
+     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
+     <<SEC_HAS_CONTENTS>>  */
+#define SEC_HAS_CONTENTS 0x100
+
+  /* An instruction to the linker to not output the section
+     even if it has information which would normally be written.  */
+#define SEC_NEVER_LOAD 0x200
+
+  /* The section contains thread local data.  */
+#define SEC_THREAD_LOCAL 0x400
+
+  /* The section has GOT references.  This flag is only for the
+     linker, and is currently only used by the elf32-hppa back end.
+     It will be set if global offset table references were detected
+     in this section, which indicate to the linker that the section
+     contains PIC code, and must be handled specially when doing a
+     static link.  */
+#define SEC_HAS_GOT_REF 0x800
+
+  /* The section contains common symbols (symbols may be defined
+     multiple times, the value of a symbol is the amount of
+     space it requires, and the largest symbol value is the one
+     used).  Most targets have exactly one of these (which we
+     translate to bfd_com_section_ptr), but ECOFF has two.  */
+#define SEC_IS_COMMON 0x1000
+
+  /* The section contains only debugging information.  For
+     example, this is set for ELF .debug and .stab sections.
+     strip tests this flag to see if a section can be
+     discarded.  */
+#define SEC_DEBUGGING 0x2000
+
+  /* The contents of this section are held in memory pointed to
+     by the contents field.  This is checked by bfd_get_section_contents,
+     and the data is retrieved from memory if appropriate.  */
+#define SEC_IN_MEMORY 0x4000
+
+  /* The contents of this section are to be excluded by the
+     linker for executable and shared objects unless those
+     objects are to be further relocated.  */
+#define SEC_EXCLUDE 0x8000
+
+  /* The contents of this section are to be sorted based on the sum of
+     the symbol and addend values specified by the associated relocation
+     entries.  Entries without associated relocation entries will be
+     appended to the end of the section in an unspecified order.  */
+#define SEC_SORT_ENTRIES 0x10000
+
+  /* When linking, duplicate sections of the same name should be
+     discarded, rather than being combined into a single section as
+     is usually done.  This is similar to how common symbols are
+     handled.  See SEC_LINK_DUPLICATES below.  */
+#define SEC_LINK_ONCE 0x20000
+
+  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
+     should handle duplicate sections.  */
+#define SEC_LINK_DUPLICATES 0x40000
+
+  /* This value for SEC_LINK_DUPLICATES means that duplicate
+     sections with the same name should simply be discarded.  */
+#define SEC_LINK_DUPLICATES_DISCARD 0x0
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if there are any duplicate sections, although
+     it should still only link one copy.  */
+#define SEC_LINK_DUPLICATES_ONE_ONLY 0x80000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections are a different size.  */
+#define SEC_LINK_DUPLICATES_SAME_SIZE 0x100000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections contain different
+     contents.  */
+#define SEC_LINK_DUPLICATES_SAME_CONTENTS \
+  (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)
+
+  /* This section was created by the linker as part of dynamic
+     relocation or other arcane processing.  It is skipped when
+     going through the first-pass output, trusting that someone
+     else up the line will take care of it later.  */
+#define SEC_LINKER_CREATED 0x200000
+
+  /* This section should not be subject to garbage collection.
+     Also set to inform the linker that this section should not be
+     listed in the link map as discarded.  */
+#define SEC_KEEP 0x400000
+
+  /* This section contains "short" data, and should be placed
+     "near" the GP.  */
+#define SEC_SMALL_DATA 0x800000
+
+  /* Attempt to merge identical entities in the section.
+     Entity size is given in the entsize field.  */
+#define SEC_MERGE 0x1000000
+
+  /* If given with SEC_MERGE, entities to merge are zero terminated
+     strings where entsize specifies character size instead of fixed
+     size entries.  */
+#define SEC_STRINGS 0x2000000
+
+  /* This section contains data about section groups.  */
+#define SEC_GROUP 0x4000000
+
+  /* The section is a COFF shared library section.  This flag is
+     only for the linker.  If this type of section appears in
+     the input file, the linker must copy it to the output file
+     without changing the vma or size.  FIXME: Although this
+     was originally intended to be general, it really is COFF
+     specific (and the flag was renamed to indicate this).  It
+     might be cleaner to have some more general mechanism to
+     allow the back end to control what the linker does with
+     sections.  */
+#define SEC_COFF_SHARED_LIBRARY 0x10000000
+
+  /* This section contains data which may be shared with other
+     executables or shared objects. This is for COFF only.  */
+#define SEC_COFF_SHARED 0x20000000
+
+  /* When a section with this flag is being linked, then if the size of
+     the input section is less than a page, it should not cross a page
+     boundary.  If the size of the input section is one page or more,
+     it should be aligned on a page boundary.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_BLOCK 0x40000000
+
+  /* Conditionally link this section; do not link if there are no
+     references found to any symbol in the section.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_CLINK 0x80000000
+
+  /*  End of section flags.  */
+
+  /* Some internal packed boolean fields.  */
+
+  /* See the vma field.  */
+  unsigned int user_set_vma : 1;
+
+  /* A mark flag used by some of the linker backends.  */
+  unsigned int linker_mark : 1;
+
+  /* Another mark flag used by some of the linker backends.  Set for
+     output sections that have an input section.  */
+  unsigned int linker_has_input : 1;
+
+  /* Mark flags used by some linker backends for garbage collection.  */
+  unsigned int gc_mark : 1;
+  unsigned int gc_mark_from_eh : 1;
+
+  /* The following flags are used by the ELF linker. */
+
+  /* Mark sections which have been allocated to segments.  */
+  unsigned int segment_mark : 1;
+
+  /* Type of sec_info information.  */
+  unsigned int sec_info_type:3;
+#define ELF_INFO_TYPE_NONE      0
+#define ELF_INFO_TYPE_STABS     1
+#define ELF_INFO_TYPE_MERGE     2
+#define ELF_INFO_TYPE_EH_FRAME  3
+#define ELF_INFO_TYPE_JUST_SYMS 4
+
+  /* Nonzero if this section uses RELA relocations, rather than REL.  */
+  unsigned int use_rela_p:1;
+
+  /* Bits used by various backends.  The generic code doesn't touch
+     these fields.  */
+
+  /* Nonzero if this section has TLS related relocations.  */
+  unsigned int has_tls_reloc:1;
+
+  /* Nonzero if this section has a gp reloc.  */
+  unsigned int has_gp_reloc:1;
+
+  /* Nonzero if this section needs the relax finalize pass.  */
+  unsigned int need_finalize_relax:1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
+  /* End of internal packed boolean fields.  */
+
+  /*  The virtual memory address of the section - where it will be
+      at run time.  The symbols are relocated against this.  The
+      user_set_vma flag is maintained by bfd; if it's not set, the
+      backend can assign addresses (for example, in <<a.out>>, where
+      the default address for <<.data>> is dependent on the specific
+      target and various flags).  */
+  bfd_vma vma;
+
+  /*  The load address of the section - where it would be in a
+      rom image; really only used for writing section header
+      information.  */
+  bfd_vma lma;
+
+  /* The size of the section in octets, as it will be output.
+     Contains a value even if the section has no contents (e.g., the
+     size of <<.bss>>).  */
+  bfd_size_type size;
+
+  /* For input sections, the original size on disk of the section, in
+     octets.  This field is used by the linker relaxation code.  It is
+     currently only set for sections where the linker relaxation scheme
+     doesn't cache altered section and reloc contents (stabs, eh_frame,
+     SEC_MERGE, some coff relaxing targets), and thus the original size
+     needs to be kept to read the section multiple times.
+     For output sections, rawsize holds the section size calculated on
+     a previous linker relaxation pass.  */
+  bfd_size_type rawsize;
+
+  /* If this section is going to be output, then this value is the
+     offset in *bytes* into the output section of the first byte in the
+     input section (byte ==> smallest addressable unit on the
+     target).  In most cases, if this was going to start at the
+     100th octet (8-bit quantity) in the output section, this value
+     would be 100.  However, if the target byte size is 16 bits
+     (bfd_octets_per_byte is "2"), this value would be 50.  */
+  bfd_vma output_offset;
+
+  /* The output section through which to map on output.  */
+  struct bfd_section *output_section;
+
+  /* The alignment requirement of the section, as an exponent of 2 -
+     e.g., 3 aligns to 2^3 (or 8).  */
+  unsigned int alignment_power;
+
+  /* If an input section, a pointer to a vector of relocation
+     records for the data in this section.  */
+  struct reloc_cache_entry *relocation;
+
+  /* If an output section, a pointer to a vector of pointers to
+     relocation records for the data in this section.  */
+  struct reloc_cache_entry **orelocation;
+
+  /* The number of relocation records in one of the above.  */
+  unsigned reloc_count;
+
+  /* Information below is back end specific - and not always used
+     or updated.  */
+
+  /* File position of section data.  */
+  file_ptr filepos;
+
+  /* File position of relocation info.  */
+  file_ptr rel_filepos;
+
+  /* File position of line data.  */
+  file_ptr line_filepos;
+
+  /* Pointer to data for applications.  */
+  void *userdata;
+
+  /* If the SEC_IN_MEMORY flag is set, this points to the actual
+     contents.  */
+  unsigned char *contents;
+
+  /* Attached line number information.  */
+  alent *lineno;
+
+  /* Number of line number records.  */
+  unsigned int lineno_count;
+
+  /* Entity size for merging purposes.  */
+  unsigned int entsize;
+
+  /* Points to the kept section if this section is a link-once section,
+     and is discarded.  */
+  struct bfd_section *kept_section;
+
+  /* When a section is being output, this value changes as more
+     linenumbers are written out.  */
+  file_ptr moving_line_filepos;
+
+  /* What the section number is in the target world.  */
+  int target_index;
+
+  void *used_by_bfd;
+
+  /* If this is a constructor section then here is a list of the
+     relocations created to relocate items within it.  */
+  struct relent_chain *constructor_chain;
+
+  /* The BFD which owns the section.  */
+  bfd *owner;
+
+  /* A symbol which points at this section only.  */
+  struct bfd_symbol *symbol;
+  struct bfd_symbol **symbol_ptr_ptr;
+
+  /* Early in the link process, map_head and map_tail are used to build
+     a list of input sections attached to an output section.  Later,
+     output sections use these fields for a list of bfd_link_order
+     structs.  */
+  union {
+    struct bfd_link_order *link_order;
+    struct bfd_section *s;
+  } map_head, map_tail;
+} asection;
+
+/* These sections are global, and are managed by BFD.  The application
+   and target back end are not permitted to change the values in
+   these sections.  New code should use the section_ptr macros rather
+   than referring directly to the const sections.  The const sections
+   may eventually vanish.  */
+#define BFD_ABS_SECTION_NAME "*ABS*"
+#define BFD_UND_SECTION_NAME "*UND*"
+#define BFD_COM_SECTION_NAME "*COM*"
+#define BFD_IND_SECTION_NAME "*IND*"
+
+/* The absolute section.  */
+extern asection bfd_abs_section;
+#define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
+#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
+/* Pointer to the undefined section.  */
+extern asection bfd_und_section;
+#define bfd_und_section_ptr ((asection *) &bfd_und_section)
+#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
+/* Pointer to the common section.  */
+extern asection bfd_com_section;
+#define bfd_com_section_ptr ((asection *) &bfd_com_section)
+/* Pointer to the indirect section.  */
+extern asection bfd_ind_section;
+#define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
+#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
+
+#define bfd_is_const_section(SEC)              \
+ (   ((SEC) == bfd_abs_section_ptr)            \
+  || ((SEC) == bfd_und_section_ptr)            \
+  || ((SEC) == bfd_com_section_ptr)            \
+  || ((SEC) == bfd_ind_section_ptr))
+
+/* Macros to handle insertion and deletion of a bfd's sections.  These
+   only handle the list pointers, ie. do not adjust section_count,
+   target_index etc.  */
+#define bfd_section_list_remove(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      asection *_next = _s->next;                      \
+      asection *_prev = _s->prev;                      \
+      if (_prev)                                       \
+        _prev->next = _next;                           \
+      else                                             \
+        (ABFD)->sections = _next;                      \
+      if (_next)                                       \
+        _next->prev = _prev;                           \
+      else                                             \
+        (ABFD)->section_last = _prev;                  \
+    }                                                  \
+  while (0)
+#define bfd_section_list_append(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->next = NULL;                                 \
+      if (_abfd->section_last)                         \
+        {                                              \
+          _s->prev = _abfd->section_last;              \
+          _abfd->section_last->next = _s;              \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->prev = NULL;                             \
+          _abfd->sections = _s;                        \
+        }                                              \
+      _abfd->section_last = _s;                        \
+    }                                                  \
+  while (0)
+#define bfd_section_list_prepend(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->prev = NULL;                                 \
+      if (_abfd->sections)                             \
+        {                                              \
+          _s->next = _abfd->sections;                  \
+          _abfd->sections->prev = _s;                  \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->next = NULL;                             \
+          _abfd->section_last = _s;                    \
+        }                                              \
+      _abfd->sections = _s;                            \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_after(ABFD, A, S) \
+  do                                                   \
+    {                                                  \
+      asection *_a = A;                                \
+      asection *_s = S;                                \
+      asection *_next = _a->next;                      \
+      _s->next = _next;                                \
+      _s->prev = _a;                                   \
+      _a->next = _s;                                   \
+      if (_next)                                       \
+        _next->prev = _s;                              \
+      else                                             \
+        (ABFD)->section_last = _s;                     \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_before(ABFD, B, S) \
+  do                                                   \
+    {                                                  \
+      asection *_b = B;                                \
+      asection *_s = S;                                \
+      asection *_prev = _b->prev;                      \
+      _s->prev = _prev;                                \
+      _s->next = _b;                                   \
+      _b->prev = _s;                                   \
+      if (_prev)                                       \
+        _prev->next = _s;                              \
+      else                                             \
+        (ABFD)->sections = _s;                         \
+    }                                                  \
+  while (0)
+#define bfd_section_removed_from_list(ABFD, S) \
+  ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))
+
+#define BFD_FAKE_SECTION(SEC, FLAGS, SYM, NAME, IDX)                   \
+  /* name, id,  index, next, prev, flags, user_set_vma,            */  \
+  { NAME,  IDX, 0,     NULL, NULL, FLAGS, 0,                           \
+                                                                       \
+  /* linker_mark, linker_has_input, gc_mark, gc_mark_from_eh,      */  \
+     0,           0,                1,       0,                        \
+                                                                       \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_gp_reloc, need_finalize_relax, reloc_done,                */  \
+     0,            0,                   0,                             \
+                                                                       \
+  /* vma, lma, size, rawsize                                       */  \
+     0,   0,   0,    0,                                                \
+                                                                       \
+  /* output_offset, output_section,              alignment_power,  */  \
+     0,             (struct bfd_section *) &SEC, 0,                    \
+                                                                       \
+  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
+     NULL,       NULL,        0,           0,       0,                 \
+                                                                       \
+  /* line_filepos, userdata, contents, lineno, lineno_count,       */  \
+     0,            NULL,     NULL,     NULL,   0,                      \
+                                                                       \
+  /* entsize, kept_section, moving_line_filepos,                    */ \
+     0,       NULL,          0,                                        \
+                                                                       \
+  /* target_index, used_by_bfd, constructor_chain, owner,          */  \
+     0,            NULL,        NULL,              NULL,               \
+                                                                       \
+  /* symbol,                    symbol_ptr_ptr,                    */  \
+     (struct bfd_symbol *) SYM, &SEC.symbol,                           \
+                                                                       \
+  /* map_head, map_tail                                            */  \
+     { NULL }, { NULL }                                                \
+    }
+
+void bfd_section_list_clear (bfd *);
+
+asection *bfd_get_section_by_name (bfd *abfd, const char *name);
+
+asection *bfd_get_section_by_name_if
+   (bfd *abfd,
+    const char *name,
+    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+char *bfd_get_unique_section_name
+   (bfd *abfd, const char *templat, int *count);
+
+asection *bfd_make_section_old_way (bfd *abfd, const char *name);
+
+asection *bfd_make_section_anyway_with_flags
+   (bfd *abfd, const char *name, flagword flags);
+
+asection *bfd_make_section_anyway (bfd *abfd, const char *name);
+
+asection *bfd_make_section_with_flags
+   (bfd *, const char *name, flagword flags);
+
+asection *bfd_make_section (bfd *, const char *name);
+
+bfd_boolean bfd_set_section_flags
+   (bfd *abfd, asection *sec, flagword flags);
+
+void bfd_map_over_sections
+   (bfd *abfd,
+    void (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+asection *bfd_sections_find_if
+   (bfd *abfd,
+    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+bfd_boolean bfd_set_section_size
+   (bfd *abfd, asection *sec, bfd_size_type val);
+
+bfd_boolean bfd_set_section_contents
+   (bfd *abfd, asection *section, const void *data,
+    file_ptr offset, bfd_size_type count);
+
+bfd_boolean bfd_get_section_contents
+   (bfd *abfd, asection *section, void *location, file_ptr offset,
+    bfd_size_type count);
+
+bfd_boolean bfd_malloc_and_get_section
+   (bfd *abfd, asection *section, bfd_byte **buf);
+
+bfd_boolean bfd_copy_private_section_data
+   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
+
+#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
+     BFD_SEND (obfd, _bfd_copy_private_section_data, \
+               (ibfd, isection, obfd, osection))
+bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
+
+bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
+
+/* Extracted from archures.c.  */
+enum bfd_architecture
+{
+  bfd_arch_unknown,   /* File arch not known.  */
+  bfd_arch_obscure,   /* Arch known, not one of these.  */
+  bfd_arch_m68k,      /* Motorola 68xxx */
+#define bfd_mach_m68000 1
+#define bfd_mach_m68008 2
+#define bfd_mach_m68010 3
+#define bfd_mach_m68020 4
+#define bfd_mach_m68030 5
+#define bfd_mach_m68040 6
+#define bfd_mach_m68060 7
+#define bfd_mach_cpu32  8
+#define bfd_mach_fido   9
+#define bfd_mach_mcf_isa_a_nodiv 10
+#define bfd_mach_mcf_isa_a 11
+#define bfd_mach_mcf_isa_a_mac 12
+#define bfd_mach_mcf_isa_a_emac 13
+#define bfd_mach_mcf_isa_aplus 14
+#define bfd_mach_mcf_isa_aplus_mac 15
+#define bfd_mach_mcf_isa_aplus_emac 16
+#define bfd_mach_mcf_isa_b_nousp 17
+#define bfd_mach_mcf_isa_b_nousp_mac 18
+#define bfd_mach_mcf_isa_b_nousp_emac 19
+#define bfd_mach_mcf_isa_b 20
+#define bfd_mach_mcf_isa_b_mac 21
+#define bfd_mach_mcf_isa_b_emac 22
+#define bfd_mach_mcf_isa_b_float 23
+#define bfd_mach_mcf_isa_b_float_mac 24
+#define bfd_mach_mcf_isa_b_float_emac 25
+#define bfd_mach_mcf_isa_c 26
+#define bfd_mach_mcf_isa_c_mac 27
+#define bfd_mach_mcf_isa_c_emac 28
+  bfd_arch_vax,       /* DEC Vax */
+  bfd_arch_i960,      /* Intel 960 */
+    /* The order of the following is important.
+       lower number indicates a machine type that
+       only accepts a subset of the instructions
+       available to machines with higher numbers.
+       The exception is the "ca", which is
+       incompatible with all other machines except
+       "core".  */
+
+#define bfd_mach_i960_core      1
+#define bfd_mach_i960_ka_sa     2
+#define bfd_mach_i960_kb_sb     3
+#define bfd_mach_i960_mc        4
+#define bfd_mach_i960_xa        5
+#define bfd_mach_i960_ca        6
+#define bfd_mach_i960_jx        7
+#define bfd_mach_i960_hx        8
+
+  bfd_arch_or32,      /* OpenRISC 32 */
+
+  bfd_arch_sparc,     /* SPARC */
+#define bfd_mach_sparc                 1
+/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
+#define bfd_mach_sparc_sparclet        2
+#define bfd_mach_sparc_sparclite       3
+#define bfd_mach_sparc_v8plus          4
+#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_sparclite_le    6
+#define bfd_mach_sparc_v9              7
+#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
+#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
+/* Nonzero if MACH has the v9 instruction set.  */
+#define bfd_mach_sparc_v9_p(mach) \
+  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+   && (mach) != bfd_mach_sparc_sparclite_le)
+/* Nonzero if MACH is a 64 bit sparc architecture.  */
+#define bfd_mach_sparc_64bit_p(mach) \
+  ((mach) >= bfd_mach_sparc_v9 && (mach) != bfd_mach_sparc_v8plusb)
+  bfd_arch_spu,       /* PowerPC SPU */
+#define bfd_mach_spu           256 
+  bfd_arch_mips,      /* MIPS Rxxxx */
+#define bfd_mach_mips3000              3000
+#define bfd_mach_mips3900              3900
+#define bfd_mach_mips4000              4000
+#define bfd_mach_mips4010              4010
+#define bfd_mach_mips4100              4100
+#define bfd_mach_mips4111              4111
+#define bfd_mach_mips4120              4120
+#define bfd_mach_mips4300              4300
+#define bfd_mach_mips4400              4400
+#define bfd_mach_mips4600              4600
+#define bfd_mach_mips4650              4650
+#define bfd_mach_mips5000              5000
+#define bfd_mach_mips5400              5400
+#define bfd_mach_mips5500              5500
+#define bfd_mach_mips6000              6000
+#define bfd_mach_mips7000              7000
+#define bfd_mach_mips8000              8000
+#define bfd_mach_mips9000              9000
+#define bfd_mach_mips10000             10000
+#define bfd_mach_mips12000             12000
+#define bfd_mach_mips16                16
+#define bfd_mach_mips5                 5
+#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mipsisa32             32
+#define bfd_mach_mipsisa32r2           33
+#define bfd_mach_mipsisa64             64
+#define bfd_mach_mipsisa64r2           65
+  bfd_arch_i386,      /* Intel 386 */
+#define bfd_mach_i386_i386 1
+#define bfd_mach_i386_i8086 2
+#define bfd_mach_i386_i386_intel_syntax 3
+#define bfd_mach_x86_64 64
+#define bfd_mach_x86_64_intel_syntax 65
+  bfd_arch_we32k,     /* AT&T WE32xxx */
+  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
+  bfd_arch_i860,      /* Intel 860 */
+  bfd_arch_i370,      /* IBM 360/370 Mainframes */
+  bfd_arch_romp,      /* IBM ROMP PC/RT */
+  bfd_arch_convex,    /* Convex */
+  bfd_arch_m88k,      /* Motorola 88xxx */
+  bfd_arch_m98k,      /* Motorola 98xxx */
+  bfd_arch_pyramid,   /* Pyramid Technology */
+  bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
+#define bfd_mach_h8300    1
+#define bfd_mach_h8300h   2
+#define bfd_mach_h8300s   3
+#define bfd_mach_h8300hn  4
+#define bfd_mach_h8300sn  5
+#define bfd_mach_h8300sx  6
+#define bfd_mach_h8300sxn 7
+  bfd_arch_pdp11,     /* DEC PDP-11 */
+  bfd_arch_powerpc,   /* PowerPC */
+#define bfd_mach_ppc           32
+#define bfd_mach_ppc64         64
+#define bfd_mach_ppc_403       403
+#define bfd_mach_ppc_403gc     4030
+#define bfd_mach_ppc_505       505
+#define bfd_mach_ppc_601       601
+#define bfd_mach_ppc_602       602
+#define bfd_mach_ppc_603       603
+#define bfd_mach_ppc_ec603e    6031
+#define bfd_mach_ppc_604       604
+#define bfd_mach_ppc_620       620
+#define bfd_mach_ppc_630       630
+#define bfd_mach_ppc_750       750
+#define bfd_mach_ppc_860       860
+#define bfd_mach_ppc_a35       35
+#define bfd_mach_ppc_rs64ii    642
+#define bfd_mach_ppc_rs64iii   643
+#define bfd_mach_ppc_7400      7400
+#define bfd_mach_ppc_e500      500
+  bfd_arch_rs6000,    /* IBM RS/6000 */
+#define bfd_mach_rs6k          6000
+#define bfd_mach_rs6k_rs1      6001
+#define bfd_mach_rs6k_rsc      6003
+#define bfd_mach_rs6k_rs2      6002
+  bfd_arch_hppa,      /* HP PA RISC */
+#define bfd_mach_hppa10        10
+#define bfd_mach_hppa11        11
+#define bfd_mach_hppa20        20
+#define bfd_mach_hppa20w       25
+  bfd_arch_d10v,      /* Mitsubishi D10V */
+#define bfd_mach_d10v          1
+#define bfd_mach_d10v_ts2      2
+#define bfd_mach_d10v_ts3      3
+  bfd_arch_d30v,      /* Mitsubishi D30V */
+  bfd_arch_dlx,       /* DLX */
+  bfd_arch_m68hc11,   /* Motorola 68HC11 */
+  bfd_arch_m68hc12,   /* Motorola 68HC12 */
+#define bfd_mach_m6812_default 0
+#define bfd_mach_m6812         1
+#define bfd_mach_m6812s        2
+  bfd_arch_z8k,       /* Zilog Z8000 */
+#define bfd_mach_z8001         1
+#define bfd_mach_z8002         2
+  bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
+  bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
+#define bfd_mach_sh            1
+#define bfd_mach_sh2        0x20
+#define bfd_mach_sh_dsp     0x2d
+#define bfd_mach_sh2a       0x2a
+#define bfd_mach_sh2a_nofpu 0x2b
+#define bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu 0x2a1
+#define bfd_mach_sh2a_nofpu_or_sh3_nommu 0x2a2
+#define bfd_mach_sh2a_or_sh4  0x2a3
+#define bfd_mach_sh2a_or_sh3e 0x2a4
+#define bfd_mach_sh2e       0x2e
+#define bfd_mach_sh3        0x30
+#define bfd_mach_sh3_nommu  0x31
+#define bfd_mach_sh3_dsp    0x3d
+#define bfd_mach_sh3e       0x3e
+#define bfd_mach_sh4        0x40
+#define bfd_mach_sh4_nofpu  0x41
+#define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_sh4a       0x4a
+#define bfd_mach_sh4a_nofpu 0x4b
+#define bfd_mach_sh4al_dsp  0x4d
+#define bfd_mach_sh5        0x50
+  bfd_arch_alpha,     /* Dec Alpha */
+#define bfd_mach_alpha_ev4  0x10
+#define bfd_mach_alpha_ev5  0x20
+#define bfd_mach_alpha_ev6  0x30
+  bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
+#define bfd_mach_arm_unknown   0
+#define bfd_mach_arm_2         1
+#define bfd_mach_arm_2a        2
+#define bfd_mach_arm_3         3
+#define bfd_mach_arm_3M        4
+#define bfd_mach_arm_4         5
+#define bfd_mach_arm_4T        6
+#define bfd_mach_arm_5         7
+#define bfd_mach_arm_5T        8
+#define bfd_mach_arm_5TE       9
+#define bfd_mach_arm_XScale    10
+#define bfd_mach_arm_ep9312    11
+#define bfd_mach_arm_iWMMXt    12
+#define bfd_mach_arm_iWMMXt2   13
+  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
+  bfd_arch_w65,       /* WDC 65816 */
+  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
+  bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
+#define bfd_mach_tic3x         30
+#define bfd_mach_tic4x         40
+  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
+  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v850,      /* NEC V850 */
+#define bfd_mach_v850          1
+#define bfd_mach_v850e         'E'
+#define bfd_mach_v850e1        '1'
+  bfd_arch_arc,       /* ARC Cores */
+#define bfd_mach_arc_5         5
+#define bfd_mach_arc_6         6
+#define bfd_mach_arc_7         7
+#define bfd_mach_arc_8         8
+ bfd_arch_m32c,     /* Renesas M16C/M32C.  */
+#define bfd_mach_m16c        0x75
+#define bfd_mach_m32c        0x78
+  bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
+#define bfd_mach_m32r          1 /* For backwards compatibility.  */
+#define bfd_mach_m32rx         'x'
+#define bfd_mach_m32r2         '2'
+  bfd_arch_mn10200,   /* Matsushita MN10200 */
+  bfd_arch_mn10300,   /* Matsushita MN10300 */
+#define bfd_mach_mn10300               300
+#define bfd_mach_am33          330
+#define bfd_mach_am33_2        332
+  bfd_arch_fr30,
+#define bfd_mach_fr30          0x46523330
+  bfd_arch_frv,
+#define bfd_mach_frv           1
+#define bfd_mach_frvsimple     2
+#define bfd_mach_fr300         300
+#define bfd_mach_fr400         400
+#define bfd_mach_fr450         450
+#define bfd_mach_frvtomcat     499     /* fr500 prototype */
+#define bfd_mach_fr500         500
+#define bfd_mach_fr550         550
+  bfd_arch_mcore,
+  bfd_arch_mep,
+#define bfd_mach_mep           1
+#define bfd_mach_mep_h1        0x6831
+  bfd_arch_ia64,      /* HP/Intel ia64 */
+#define bfd_mach_ia64_elf64    64
+#define bfd_mach_ia64_elf32    32
+  bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
+#define bfd_mach_ip2022        1
+#define bfd_mach_ip2022ext     2
+ bfd_arch_iq2000,     /* Vitesse IQ2000.  */
+#define bfd_mach_iq2000        1
+#define bfd_mach_iq10          2
+  bfd_arch_mt,
+#define bfd_mach_ms1           1
+#define bfd_mach_mrisc2        2
+#define bfd_mach_ms2           3
+  bfd_arch_pj,
+  bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
+#define bfd_mach_avr1          1
+#define bfd_mach_avr2          2
+#define bfd_mach_avr3          3
+#define bfd_mach_avr4          4
+#define bfd_mach_avr5          5
+#define bfd_mach_avr6          6
+  bfd_arch_avr32,     /* Atmel AVR32 */
+#define bfd_mach_avr32_ap      7000
+#define bfd_mach_avr32_uc      3000
+#define bfd_mach_avr32_ucr1    3001
+#define bfd_mach_avr32_ucr2    3002
+  bfd_arch_bfin,        /* ADI Blackfin */
+#define bfd_mach_bfin          1
+  bfd_arch_cr16,       /* National Semiconductor CompactRISC (ie CR16). */
+#define bfd_mach_cr16          1
+  bfd_arch_cr16c,       /* National Semiconductor CompactRISC. */
+#define bfd_mach_cr16c         1
+  bfd_arch_crx,       /*  National Semiconductor CRX.  */
+#define bfd_mach_crx           1
+  bfd_arch_cris,      /* Axis CRIS */
+#define bfd_mach_cris_v0_v10   255
+#define bfd_mach_cris_v32      32
+#define bfd_mach_cris_v10_v32  1032
+  bfd_arch_s390,      /* IBM s390 */
+#define bfd_mach_s390_31       31
+#define bfd_mach_s390_64       64
+  bfd_arch_score,     /* Sunplus score */ 
+  bfd_arch_openrisc,  /* OpenRISC */
+  bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
+  bfd_arch_xstormy16,
+#define bfd_mach_xstormy16     1
+  bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
+#define bfd_mach_msp11          11
+#define bfd_mach_msp110         110
+#define bfd_mach_msp12          12
+#define bfd_mach_msp13          13
+#define bfd_mach_msp14          14
+#define bfd_mach_msp15          15
+#define bfd_mach_msp16          16
+#define bfd_mach_msp21          21
+#define bfd_mach_msp31          31
+#define bfd_mach_msp32          32
+#define bfd_mach_msp33          33
+#define bfd_mach_msp41          41
+#define bfd_mach_msp42          42
+#define bfd_mach_msp43          43
+#define bfd_mach_msp44          44
+  bfd_arch_xc16x,     /* Infineon's XC16X Series.               */
+#define bfd_mach_xc16x         1
+#define bfd_mach_xc16xl        2
+#define bfd_mach_xc16xs         3
+  bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
+#define bfd_mach_xtensa        1
+   bfd_arch_maxq,     /* Dallas MAXQ 10/20 */
+#define bfd_mach_maxq10    10
+#define bfd_mach_maxq20    20
+  bfd_arch_z80,
+#define bfd_mach_z80strict      1 /* No undocumented opcodes.  */
+#define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
+#define bfd_mach_z80full        7 /* All undocumented instructions.  */
+#define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_last
+  };
+
+typedef struct bfd_arch_info
+{
+  int bits_per_word;
+  int bits_per_address;
+  int bits_per_byte;
+  enum bfd_architecture arch;
+  unsigned long mach;
+  const char *arch_name;
+  const char *printable_name;
+  unsigned int section_align_power;
+  /* TRUE if this is the default machine for the architecture.
+     The default arch should be the first entry for an arch so that
+     all the entries for that arch can be accessed via <<next>>.  */
+  bfd_boolean the_default;
+  const struct bfd_arch_info * (*compatible)
+    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
+
+  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
+
+  const struct bfd_arch_info *next;
+}
+bfd_arch_info_type;
+
+const char *bfd_printable_name (bfd *abfd);
+
+const bfd_arch_info_type *bfd_scan_arch (const char *string);
+
+const char **bfd_arch_list (void);
+
+const bfd_arch_info_type *bfd_arch_get_compatible
+   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
+
+void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
+
+enum bfd_architecture bfd_get_arch (bfd *abfd);
+
+unsigned long bfd_get_mach (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_address (bfd *abfd);
+
+const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
+
+const bfd_arch_info_type *bfd_lookup_arch
+   (enum bfd_architecture arch, unsigned long machine);
+
+const char *bfd_printable_arch_mach
+   (enum bfd_architecture arch, unsigned long machine);
+
+unsigned int bfd_octets_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_mach_octets_per_byte
+   (enum bfd_architecture arch, unsigned long machine);
+
+/* Extracted from reloc.c.  */
+typedef enum bfd_reloc_status
+{
+  /* No errors detected.  */
+  bfd_reloc_ok,
+
+  /* The relocation was performed, but there was an overflow.  */
+  bfd_reloc_overflow,
+
+  /* The address to relocate was not within the section supplied.  */
+  bfd_reloc_outofrange,
+
+  /* Used by special functions.  */
+  bfd_reloc_continue,
+
+  /* Unsupported relocation size requested.  */
+  bfd_reloc_notsupported,
+
+  /* Unused.  */
+  bfd_reloc_other,
+
+  /* The symbol to relocate against was undefined.  */
+  bfd_reloc_undefined,
+
+  /* The relocation was performed, but may not be ok - presently
+     generated only when linking i960 coff files with i960 b.out
+     symbols.  If this type is returned, the error_message argument
+     to bfd_perform_relocation will be set.  */
+  bfd_reloc_dangerous
+ }
+ bfd_reloc_status_type;
+
+
+typedef struct reloc_cache_entry
+{
+  /* A pointer into the canonical table of pointers.  */
+  struct bfd_symbol **sym_ptr_ptr;
+
+  /* offset in section.  */
+  bfd_size_type address;
+
+  /* addend for relocation value.  */
+  bfd_vma addend;
+
+  /* Pointer to how to perform the required relocation.  */
+  reloc_howto_type *howto;
+
+}
+arelent;
+
+enum complain_overflow
+{
+  /* Do not complain on overflow.  */
+  complain_overflow_dont,
+
+  /* Complain if the value overflows when considered as a signed
+     number one bit larger than the field.  ie. A bitfield of N bits
+     is allowed to represent -2**n to 2**n-1.  */
+  complain_overflow_bitfield,
+
+  /* Complain if the value overflows when considered as a signed
+     number.  */
+  complain_overflow_signed,
+
+  /* Complain if the value overflows when considered as an
+     unsigned number.  */
+  complain_overflow_unsigned
+};
+
+struct reloc_howto_struct
+{
+  /*  The type field has mainly a documentary use - the back end can
+      do what it wants with it, though normally the back end's
+      external idea of what a reloc number is stored
+      in this field.  For example, a PC relative word relocation
+      in a coff environment has the type 023 - because that's
+      what the outside world calls a R_PCRWORD reloc.  */
+  unsigned int type;
+
+  /*  The value the final relocation is shifted right by.  This drops
+      unwanted data from the relocation.  */
+  unsigned int rightshift;
+
+  /*  The size of the item to be relocated.  This is *not* a
+      power-of-two measure.  To get the number of bytes operated
+      on by a type of relocation, use bfd_get_reloc_size.  */
+  int size;
+
+  /*  The number of bits in the item to be relocated.  This is used
+      when doing overflow checking.  */
+  unsigned int bitsize;
+
+  /*  Notes that the relocation is relative to the location in the
+      data section of the addend.  The relocation function will
+      subtract from the relocation value the address of the location
+      being relocated.  */
+  bfd_boolean pc_relative;
+
+  /*  The bit position of the reloc value in the destination.
+      The relocated value is left shifted by this amount.  */
+  unsigned int bitpos;
+
+  /* What type of overflow error should be checked for when
+     relocating.  */
+  enum complain_overflow complain_on_overflow;
+
+  /* If this field is non null, then the supplied function is
+     called rather than the normal function.  This allows really
+     strange relocation methods to be accommodated (e.g., i960 callj
+     instructions).  */
+  bfd_reloc_status_type (*special_function)
+    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
+     bfd *, char **);
+
+  /* The textual name of the relocation type.  */
+  char *name;
+
+  /* Some formats record a relocation addend in the section contents
+     rather than with the relocation.  For ELF formats this is the
+     distinction between USE_REL and USE_RELA (though the code checks
+     for USE_REL == 1/0).  The value of this field is TRUE if the
+     addend is recorded with the section contents; when performing a
+     partial link (ld -r) the section contents (the data) will be
+     modified.  The value of this field is FALSE if addends are
+     recorded with the relocation (in arelent.addend); when performing
+     a partial link the relocation will be modified.
+     All relocations for all ELF USE_RELA targets should set this field
+     to FALSE (values of TRUE should be looked on with suspicion).
+     However, the converse is not true: not all relocations of all ELF
+     USE_REL targets set this field to TRUE.  Why this is so is peculiar
+     to each particular target.  For relocs that aren't used in partial
+     links (e.g. GOT stuff) it doesn't matter what this is set to.  */
+  bfd_boolean partial_inplace;
+
+  /* src_mask selects the part of the instruction (or data) to be used
+     in the relocation sum.  If the target relocations don't have an
+     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
+     dst_mask to extract the addend from the section contents.  If
+     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
+     field should be zero.  Non-zero values for ELF USE_RELA targets are
+     bogus as in those cases the value in the dst_mask part of the
+     section contents should be treated as garbage.  */
+  bfd_vma src_mask;
+
+  /* dst_mask selects which parts of the instruction (or data) are
+     replaced with a relocated value.  */
+  bfd_vma dst_mask;
+
+  /* When some formats create PC relative instructions, they leave
+     the value of the pc of the place being relocated in the offset
+     slot of the instruction, so that a PC relative relocation can
+     be made just by adding in an ordinary offset (e.g., sun3 a.out).
+     Some formats leave the displacement part of an instruction
+     empty (e.g., m88k bcs); this flag signals the fact.  */
+  bfd_boolean pcrel_offset;
+};
+
+#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
+  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
+#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
+  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
+         NAME, FALSE, 0, 0, IN)
+
+#define EMPTY_HOWTO(C) \
+  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
+         NULL, FALSE, 0, 0, FALSE)
+
+#define HOWTO_PREPARE(relocation, symbol)               \
+  {                                                     \
+    if (symbol != NULL)                                 \
+      {                                                 \
+        if (bfd_is_com_section (symbol->section))       \
+          {                                             \
+            relocation = 0;                             \
+          }                                             \
+        else                                            \
+          {                                             \
+            relocation = symbol->value;                 \
+          }                                             \
+      }                                                 \
+  }
+
+unsigned int bfd_get_reloc_size (reloc_howto_type *);
+
+typedef struct relent_chain
+{
+  arelent relent;
+  struct relent_chain *next;
+}
+arelent_chain;
+
+bfd_reloc_status_type bfd_check_overflow
+   (enum complain_overflow how,
+    unsigned int bitsize,
+    unsigned int rightshift,
+    unsigned int addrsize,
+    bfd_vma relocation);
+
+bfd_reloc_status_type bfd_perform_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data,
+    asection *input_section,
+    bfd *output_bfd,
+    char **error_message);
+
+bfd_reloc_status_type bfd_install_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data, bfd_vma data_start,
+    asection *input_section,
+    char **error_message);
+
+enum bfd_reloc_code_real {
+  _dummy_first_bfd_reloc_code_real,
+
+
+/* Basic absolute relocations of N bits.  */
+  BFD_RELOC_64,
+  BFD_RELOC_32,
+  BFD_RELOC_26,
+  BFD_RELOC_24,
+  BFD_RELOC_16,
+  BFD_RELOC_14,
+  BFD_RELOC_8,
+
+/* PC-relative relocations.  Sometimes these are relative to the address
+of the relocation itself; sometimes they are relative to the start of
+the section containing the relocation.  It depends on the specific target.
+
+The 24-bit relocation is used in some Intel 960 configurations.  */
+  BFD_RELOC_64_PCREL,
+  BFD_RELOC_32_PCREL,
+  BFD_RELOC_24_PCREL,
+  BFD_RELOC_16_PCREL,
+  BFD_RELOC_12_PCREL,
+  BFD_RELOC_8_PCREL,
+
+/* Section relative relocations.  Some targets need this for DWARF2.  */
+  BFD_RELOC_32_SECREL,
+
+/* For ELF.  */
+  BFD_RELOC_32_GOT_PCREL,
+  BFD_RELOC_16_GOT_PCREL,
+  BFD_RELOC_8_GOT_PCREL,
+  BFD_RELOC_32_GOTOFF,
+  BFD_RELOC_16_GOTOFF,
+  BFD_RELOC_LO16_GOTOFF,
+  BFD_RELOC_HI16_GOTOFF,
+  BFD_RELOC_HI16_S_GOTOFF,
+  BFD_RELOC_8_GOTOFF,
+  BFD_RELOC_64_PLT_PCREL,
+  BFD_RELOC_32_PLT_PCREL,
+  BFD_RELOC_24_PLT_PCREL,
+  BFD_RELOC_16_PLT_PCREL,
+  BFD_RELOC_8_PLT_PCREL,
+  BFD_RELOC_64_PLTOFF,
+  BFD_RELOC_32_PLTOFF,
+  BFD_RELOC_16_PLTOFF,
+  BFD_RELOC_LO16_PLTOFF,
+  BFD_RELOC_HI16_PLTOFF,
+  BFD_RELOC_HI16_S_PLTOFF,
+  BFD_RELOC_8_PLTOFF,
+
+/* Relocations used by 68K ELF.  */
+  BFD_RELOC_68K_GLOB_DAT,
+  BFD_RELOC_68K_JMP_SLOT,
+  BFD_RELOC_68K_RELATIVE,
+
+/* Linkage-table relative.  */
+  BFD_RELOC_32_BASEREL,
+  BFD_RELOC_16_BASEREL,
+  BFD_RELOC_LO16_BASEREL,
+  BFD_RELOC_HI16_BASEREL,
+  BFD_RELOC_HI16_S_BASEREL,
+  BFD_RELOC_8_BASEREL,
+  BFD_RELOC_RVA,
+
+/* Absolute 8-bit relocation, but used to form an address like 0xFFnn.  */
+  BFD_RELOC_8_FFnn,
+
+/* These PC-relative relocations are stored as word displacements --
+i.e., byte displacements shifted right two bits.  The 30-bit word
+displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
+SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
+signed 16-bit displacement is used on the MIPS, and the 23-bit
+displacement is used on the Alpha.  */
+  BFD_RELOC_32_PCREL_S2,
+  BFD_RELOC_16_PCREL_S2,
+  BFD_RELOC_23_PCREL_S2,
+
+/* High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
+the target word.  These are used on the SPARC.  */
+  BFD_RELOC_HI22,
+  BFD_RELOC_LO10,
+
+/* For systems that allocate a Global Pointer register, these are
+displacements off that register.  These relocation types are
+handled specially, because the value the register will have is
+decided relatively late.  */
+  BFD_RELOC_GPREL16,
+  BFD_RELOC_GPREL32,
+
+/* Reloc types used for i960/b.out.  */
+  BFD_RELOC_I960_CALLJ,
+
+/* SPARC ELF relocations.  There is probably some overlap with other
+relocation types already defined.  */
+  BFD_RELOC_NONE,
+  BFD_RELOC_SPARC_WDISP22,
+  BFD_RELOC_SPARC22,
+  BFD_RELOC_SPARC13,
+  BFD_RELOC_SPARC_GOT10,
+  BFD_RELOC_SPARC_GOT13,
+  BFD_RELOC_SPARC_GOT22,
+  BFD_RELOC_SPARC_PC10,
+  BFD_RELOC_SPARC_PC22,
+  BFD_RELOC_SPARC_WPLT30,
+  BFD_RELOC_SPARC_COPY,
+  BFD_RELOC_SPARC_GLOB_DAT,
+  BFD_RELOC_SPARC_JMP_SLOT,
+  BFD_RELOC_SPARC_RELATIVE,
+  BFD_RELOC_SPARC_UA16,
+  BFD_RELOC_SPARC_UA32,
+  BFD_RELOC_SPARC_UA64,
+
+/* I think these are specific to SPARC a.out (e.g., Sun 4).  */
+  BFD_RELOC_SPARC_BASE13,
+  BFD_RELOC_SPARC_BASE22,
+
+/* SPARC64 relocations  */
+#define BFD_RELOC_SPARC_64 BFD_RELOC_64
+  BFD_RELOC_SPARC_10,
+  BFD_RELOC_SPARC_11,
+  BFD_RELOC_SPARC_OLO10,
+  BFD_RELOC_SPARC_HH22,
+  BFD_RELOC_SPARC_HM10,
+  BFD_RELOC_SPARC_LM22,
+  BFD_RELOC_SPARC_PC_HH22,
+  BFD_RELOC_SPARC_PC_HM10,
+  BFD_RELOC_SPARC_PC_LM22,
+  BFD_RELOC_SPARC_WDISP16,
+  BFD_RELOC_SPARC_WDISP19,
+  BFD_RELOC_SPARC_7,
+  BFD_RELOC_SPARC_6,
+  BFD_RELOC_SPARC_5,
+#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
+  BFD_RELOC_SPARC_PLT32,
+  BFD_RELOC_SPARC_PLT64,
+  BFD_RELOC_SPARC_HIX22,
+  BFD_RELOC_SPARC_LOX10,
+  BFD_RELOC_SPARC_H44,
+  BFD_RELOC_SPARC_M44,
+  BFD_RELOC_SPARC_L44,
+  BFD_RELOC_SPARC_REGISTER,
+
+/* SPARC little endian relocation  */
+  BFD_RELOC_SPARC_REV32,
+
+/* SPARC TLS relocations  */
+  BFD_RELOC_SPARC_TLS_GD_HI22,
+  BFD_RELOC_SPARC_TLS_GD_LO10,
+  BFD_RELOC_SPARC_TLS_GD_ADD,
+  BFD_RELOC_SPARC_TLS_GD_CALL,
+  BFD_RELOC_SPARC_TLS_LDM_HI22,
+  BFD_RELOC_SPARC_TLS_LDM_LO10,
+  BFD_RELOC_SPARC_TLS_LDM_ADD,
+  BFD_RELOC_SPARC_TLS_LDM_CALL,
+  BFD_RELOC_SPARC_TLS_LDO_HIX22,
+  BFD_RELOC_SPARC_TLS_LDO_LOX10,
+  BFD_RELOC_SPARC_TLS_LDO_ADD,
+  BFD_RELOC_SPARC_TLS_IE_HI22,
+  BFD_RELOC_SPARC_TLS_IE_LO10,
+  BFD_RELOC_SPARC_TLS_IE_LD,
+  BFD_RELOC_SPARC_TLS_IE_LDX,
+  BFD_RELOC_SPARC_TLS_IE_ADD,
+  BFD_RELOC_SPARC_TLS_LE_HIX22,
+  BFD_RELOC_SPARC_TLS_LE_LOX10,
+  BFD_RELOC_SPARC_TLS_DTPMOD32,
+  BFD_RELOC_SPARC_TLS_DTPMOD64,
+  BFD_RELOC_SPARC_TLS_DTPOFF32,
+  BFD_RELOC_SPARC_TLS_DTPOFF64,
+  BFD_RELOC_SPARC_TLS_TPOFF32,
+  BFD_RELOC_SPARC_TLS_TPOFF64,
+
+/* SPU Relocations.  */
+  BFD_RELOC_SPU_IMM7,
+  BFD_RELOC_SPU_IMM8,
+  BFD_RELOC_SPU_IMM10,
+  BFD_RELOC_SPU_IMM10W,
+  BFD_RELOC_SPU_IMM16,
+  BFD_RELOC_SPU_IMM16W,
+  BFD_RELOC_SPU_IMM18,
+  BFD_RELOC_SPU_PCREL9a,
+  BFD_RELOC_SPU_PCREL9b,
+  BFD_RELOC_SPU_PCREL16,
+  BFD_RELOC_SPU_LO16,
+  BFD_RELOC_SPU_HI16,
+  BFD_RELOC_SPU_PPU32,
+  BFD_RELOC_SPU_PPU64,
+
+/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
+"addend" in some special way.
+For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
+writing; when reading, it will be the absolute section symbol.  The
+addend is the displacement in bytes of the "lda" instruction from
+the "ldah" instruction (which is at the address of this reloc).  */
+  BFD_RELOC_ALPHA_GPDISP_HI16,
+
+/* For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
+with GPDISP_HI16 relocs.  The addend is ignored when writing the
+relocations out, and is filled in with the file's GP value on
+reading, for convenience.  */
+  BFD_RELOC_ALPHA_GPDISP_LO16,
+
+/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
+relocation except that there is no accompanying GPDISP_LO16
+relocation.  */
+  BFD_RELOC_ALPHA_GPDISP,
+
+/* The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
+the assembler turns it into a LDQ instruction to load the address of
+the symbol, and then fills in a register in the real instruction.
+
+The LITERAL reloc, at the LDQ instruction, refers to the .lita
+section symbol.  The addend is ignored when writing, but is filled
+in with the file's GP value on reading, for convenience, as with the
+GPDISP_LO16 reloc.
+
+The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
+It should refer to the symbol to be referenced, as with 16_GOTOFF,
+but it generates output not based on the position within the .got
+section, but relative to the GP value chosen for the file during the
+final link stage.
+
+The LITUSE reloc, on the instruction using the loaded address, gives
+information to the linker that it might be able to use to optimize
+away some literal section references.  The symbol is ignored (read
+as the absolute section symbol), and the "addend" indicates the type
+of instruction using the register:
+1 - "memory" fmt insn
+2 - byte-manipulation (byte offset reg)
+3 - jsr (target of branch)  */
+  BFD_RELOC_ALPHA_LITERAL,
+  BFD_RELOC_ALPHA_ELF_LITERAL,
+  BFD_RELOC_ALPHA_LITUSE,
+
+/* The HINT relocation indicates a value that should be filled into the
+"hint" field of a jmp/jsr/ret instruction, for possible branch-
+prediction logic which may be provided on some processors.  */
+  BFD_RELOC_ALPHA_HINT,
+
+/* The LINKAGE relocation outputs a linkage pair in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_LINKAGE,
+
+/* The CODEADDR relocation outputs a STO_CA in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_CODEADDR,
+
+/* The GPREL_HI/LO relocations together form a 32-bit offset from the
+GP register.  */
+  BFD_RELOC_ALPHA_GPREL_HI16,
+  BFD_RELOC_ALPHA_GPREL_LO16,
+
+/* Like BFD_RELOC_23_PCREL_S2, except that the source and target must
+share a common GP, and the target address is adjusted for
+STO_ALPHA_STD_GPLOAD.  */
+  BFD_RELOC_ALPHA_BRSGP,
+
+/* Alpha thread-local storage relocations.  */
+  BFD_RELOC_ALPHA_TLSGD,
+  BFD_RELOC_ALPHA_TLSLDM,
+  BFD_RELOC_ALPHA_DTPMOD64,
+  BFD_RELOC_ALPHA_GOTDTPREL16,
+  BFD_RELOC_ALPHA_DTPREL64,
+  BFD_RELOC_ALPHA_DTPREL_HI16,
+  BFD_RELOC_ALPHA_DTPREL_LO16,
+  BFD_RELOC_ALPHA_DTPREL16,
+  BFD_RELOC_ALPHA_GOTTPREL16,
+  BFD_RELOC_ALPHA_TPREL64,
+  BFD_RELOC_ALPHA_TPREL_HI16,
+  BFD_RELOC_ALPHA_TPREL_LO16,
+  BFD_RELOC_ALPHA_TPREL16,
+
+/* Bits 27..2 of the relocation address shifted right 2 bits;
+simple reloc otherwise.  */
+  BFD_RELOC_MIPS_JMP,
+
+/* The MIPS16 jump instruction.  */
+  BFD_RELOC_MIPS16_JMP,
+
+/* MIPS16 GP relative reloc.  */
+  BFD_RELOC_MIPS16_GPREL,
+
+/* High 16 bits of 32-bit value; simple reloc.  */
+  BFD_RELOC_HI16,
+
+/* High 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_HI16_S,
+
+/* Low 16 bits.  */
+  BFD_RELOC_LO16,
+
+/* High 16 bits of 32-bit pc-relative value  */
+  BFD_RELOC_HI16_PCREL,
+
+/* High 16 bits of 32-bit pc-relative value, adjusted  */
+  BFD_RELOC_HI16_S_PCREL,
+
+/* Low 16 bits of pc-relative value  */
+  BFD_RELOC_LO16_PCREL,
+
+/* MIPS16 high 16 bits of 32-bit value.  */
+  BFD_RELOC_MIPS16_HI16,
+
+/* MIPS16 high 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_MIPS16_HI16_S,
+
+/* MIPS16 low 16 bits.  */
+  BFD_RELOC_MIPS16_LO16,
+
+/* Relocation against a MIPS literal section.  */
+  BFD_RELOC_MIPS_LITERAL,
+
+/* MIPS ELF relocations.  */
+  BFD_RELOC_MIPS_GOT16,
+  BFD_RELOC_MIPS_CALL16,
+  BFD_RELOC_MIPS_GOT_HI16,
+  BFD_RELOC_MIPS_GOT_LO16,
+  BFD_RELOC_MIPS_CALL_HI16,
+  BFD_RELOC_MIPS_CALL_LO16,
+  BFD_RELOC_MIPS_SUB,
+  BFD_RELOC_MIPS_GOT_PAGE,
+  BFD_RELOC_MIPS_GOT_OFST,
+  BFD_RELOC_MIPS_GOT_DISP,
+  BFD_RELOC_MIPS_SHIFT5,
+  BFD_RELOC_MIPS_SHIFT6,
+  BFD_RELOC_MIPS_INSERT_A,
+  BFD_RELOC_MIPS_INSERT_B,
+  BFD_RELOC_MIPS_DELETE,
+  BFD_RELOC_MIPS_HIGHEST,
+  BFD_RELOC_MIPS_HIGHER,
+  BFD_RELOC_MIPS_SCN_DISP,
+  BFD_RELOC_MIPS_REL16,
+  BFD_RELOC_MIPS_RELGOT,
+  BFD_RELOC_MIPS_JALR,
+  BFD_RELOC_MIPS_TLS_DTPMOD32,
+  BFD_RELOC_MIPS_TLS_DTPREL32,
+  BFD_RELOC_MIPS_TLS_DTPMOD64,
+  BFD_RELOC_MIPS_TLS_DTPREL64,
+  BFD_RELOC_MIPS_TLS_GD,
+  BFD_RELOC_MIPS_TLS_LDM,
+  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
+  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
+  BFD_RELOC_MIPS_TLS_GOTTPREL,
+  BFD_RELOC_MIPS_TLS_TPREL32,
+  BFD_RELOC_MIPS_TLS_TPREL64,
+  BFD_RELOC_MIPS_TLS_TPREL_HI16,
+  BFD_RELOC_MIPS_TLS_TPREL_LO16,
+
+
+/* MIPS ELF relocations (VxWorks extensions).  */
+  BFD_RELOC_MIPS_COPY,
+  BFD_RELOC_MIPS_JUMP_SLOT,
+
+
+/* Fujitsu Frv Relocations.  */
+  BFD_RELOC_FRV_LABEL16,
+  BFD_RELOC_FRV_LABEL24,
+  BFD_RELOC_FRV_LO16,
+  BFD_RELOC_FRV_HI16,
+  BFD_RELOC_FRV_GPREL12,
+  BFD_RELOC_FRV_GPRELU12,
+  BFD_RELOC_FRV_GPREL32,
+  BFD_RELOC_FRV_GPRELHI,
+  BFD_RELOC_FRV_GPRELLO,
+  BFD_RELOC_FRV_GOT12,
+  BFD_RELOC_FRV_GOTHI,
+  BFD_RELOC_FRV_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC,
+  BFD_RELOC_FRV_FUNCDESC_GOT12,
+  BFD_RELOC_FRV_FUNCDESC_GOTHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC_VALUE,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_FRV_GOTOFF12,
+  BFD_RELOC_FRV_GOTOFFHI,
+  BFD_RELOC_FRV_GOTOFFLO,
+  BFD_RELOC_FRV_GETTLSOFF,
+  BFD_RELOC_FRV_TLSDESC_VALUE,
+  BFD_RELOC_FRV_GOTTLSDESC12,
+  BFD_RELOC_FRV_GOTTLSDESCHI,
+  BFD_RELOC_FRV_GOTTLSDESCLO,
+  BFD_RELOC_FRV_TLSMOFF12,
+  BFD_RELOC_FRV_TLSMOFFHI,
+  BFD_RELOC_FRV_TLSMOFFLO,
+  BFD_RELOC_FRV_GOTTLSOFF12,
+  BFD_RELOC_FRV_GOTTLSOFFHI,
+  BFD_RELOC_FRV_GOTTLSOFFLO,
+  BFD_RELOC_FRV_TLSOFF,
+  BFD_RELOC_FRV_TLSDESC_RELAX,
+  BFD_RELOC_FRV_GETTLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSMOFF,
+
+
+/* This is a 24bit GOT-relative reloc for the mn10300.  */
+  BFD_RELOC_MN10300_GOTOFF24,
+
+/* This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT32,
+
+/* This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT24,
+
+/* This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT16,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_MN10300_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_MN10300_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_MN10300_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_MN10300_RELATIVE,
+
+
+/* i386/elf relocations  */
+  BFD_RELOC_386_GOT32,
+  BFD_RELOC_386_PLT32,
+  BFD_RELOC_386_COPY,
+  BFD_RELOC_386_GLOB_DAT,
+  BFD_RELOC_386_JUMP_SLOT,
+  BFD_RELOC_386_RELATIVE,
+  BFD_RELOC_386_GOTOFF,
+  BFD_RELOC_386_GOTPC,
+  BFD_RELOC_386_TLS_TPOFF,
+  BFD_RELOC_386_TLS_IE,
+  BFD_RELOC_386_TLS_GOTIE,
+  BFD_RELOC_386_TLS_LE,
+  BFD_RELOC_386_TLS_GD,
+  BFD_RELOC_386_TLS_LDM,
+  BFD_RELOC_386_TLS_LDO_32,
+  BFD_RELOC_386_TLS_IE_32,
+  BFD_RELOC_386_TLS_LE_32,
+  BFD_RELOC_386_TLS_DTPMOD32,
+  BFD_RELOC_386_TLS_DTPOFF32,
+  BFD_RELOC_386_TLS_TPOFF32,
+  BFD_RELOC_386_TLS_GOTDESC,
+  BFD_RELOC_386_TLS_DESC_CALL,
+  BFD_RELOC_386_TLS_DESC,
+
+/* x86-64/elf relocations  */
+  BFD_RELOC_X86_64_GOT32,
+  BFD_RELOC_X86_64_PLT32,
+  BFD_RELOC_X86_64_COPY,
+  BFD_RELOC_X86_64_GLOB_DAT,
+  BFD_RELOC_X86_64_JUMP_SLOT,
+  BFD_RELOC_X86_64_RELATIVE,
+  BFD_RELOC_X86_64_GOTPCREL,
+  BFD_RELOC_X86_64_32S,
+  BFD_RELOC_X86_64_DTPMOD64,
+  BFD_RELOC_X86_64_DTPOFF64,
+  BFD_RELOC_X86_64_TPOFF64,
+  BFD_RELOC_X86_64_TLSGD,
+  BFD_RELOC_X86_64_TLSLD,
+  BFD_RELOC_X86_64_DTPOFF32,
+  BFD_RELOC_X86_64_GOTTPOFF,
+  BFD_RELOC_X86_64_TPOFF32,
+  BFD_RELOC_X86_64_GOTOFF64,
+  BFD_RELOC_X86_64_GOTPC32,
+  BFD_RELOC_X86_64_GOT64,
+  BFD_RELOC_X86_64_GOTPCREL64,
+  BFD_RELOC_X86_64_GOTPC64,
+  BFD_RELOC_X86_64_GOTPLT64,
+  BFD_RELOC_X86_64_PLTOFF64,
+  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
+  BFD_RELOC_X86_64_TLSDESC_CALL,
+  BFD_RELOC_X86_64_TLSDESC,
+
+/* ns32k relocations  */
+  BFD_RELOC_NS32K_IMM_8,
+  BFD_RELOC_NS32K_IMM_16,
+  BFD_RELOC_NS32K_IMM_32,
+  BFD_RELOC_NS32K_IMM_8_PCREL,
+  BFD_RELOC_NS32K_IMM_16_PCREL,
+  BFD_RELOC_NS32K_IMM_32_PCREL,
+  BFD_RELOC_NS32K_DISP_8,
+  BFD_RELOC_NS32K_DISP_16,
+  BFD_RELOC_NS32K_DISP_32,
+  BFD_RELOC_NS32K_DISP_8_PCREL,
+  BFD_RELOC_NS32K_DISP_16_PCREL,
+  BFD_RELOC_NS32K_DISP_32_PCREL,
+
+/* PDP11 relocations  */
+  BFD_RELOC_PDP11_DISP_8_PCREL,
+  BFD_RELOC_PDP11_DISP_6_PCREL,
+
+/* Picojava relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_PJ_CODE_HI16,
+  BFD_RELOC_PJ_CODE_LO16,
+  BFD_RELOC_PJ_CODE_DIR16,
+  BFD_RELOC_PJ_CODE_DIR32,
+  BFD_RELOC_PJ_CODE_REL16,
+  BFD_RELOC_PJ_CODE_REL32,
+
+/* Power(rs6000) and PowerPC relocations.  */
+  BFD_RELOC_PPC_B26,
+  BFD_RELOC_PPC_BA26,
+  BFD_RELOC_PPC_TOC16,
+  BFD_RELOC_PPC_B16,
+  BFD_RELOC_PPC_B16_BRTAKEN,
+  BFD_RELOC_PPC_B16_BRNTAKEN,
+  BFD_RELOC_PPC_BA16,
+  BFD_RELOC_PPC_BA16_BRTAKEN,
+  BFD_RELOC_PPC_BA16_BRNTAKEN,
+  BFD_RELOC_PPC_COPY,
+  BFD_RELOC_PPC_GLOB_DAT,
+  BFD_RELOC_PPC_JMP_SLOT,
+  BFD_RELOC_PPC_RELATIVE,
+  BFD_RELOC_PPC_LOCAL24PC,
+  BFD_RELOC_PPC_EMB_NADDR32,
+  BFD_RELOC_PPC_EMB_NADDR16,
+  BFD_RELOC_PPC_EMB_NADDR16_LO,
+  BFD_RELOC_PPC_EMB_NADDR16_HI,
+  BFD_RELOC_PPC_EMB_NADDR16_HA,
+  BFD_RELOC_PPC_EMB_SDAI16,
+  BFD_RELOC_PPC_EMB_SDA2I16,
+  BFD_RELOC_PPC_EMB_SDA2REL,
+  BFD_RELOC_PPC_EMB_SDA21,
+  BFD_RELOC_PPC_EMB_MRKREF,
+  BFD_RELOC_PPC_EMB_RELSEC16,
+  BFD_RELOC_PPC_EMB_RELST_LO,
+  BFD_RELOC_PPC_EMB_RELST_HI,
+  BFD_RELOC_PPC_EMB_RELST_HA,
+  BFD_RELOC_PPC_EMB_BIT_FLD,
+  BFD_RELOC_PPC_EMB_RELSDA,
+  BFD_RELOC_PPC64_HIGHER,
+  BFD_RELOC_PPC64_HIGHER_S,
+  BFD_RELOC_PPC64_HIGHEST,
+  BFD_RELOC_PPC64_HIGHEST_S,
+  BFD_RELOC_PPC64_TOC16_LO,
+  BFD_RELOC_PPC64_TOC16_HI,
+  BFD_RELOC_PPC64_TOC16_HA,
+  BFD_RELOC_PPC64_TOC,
+  BFD_RELOC_PPC64_PLTGOT16,
+  BFD_RELOC_PPC64_PLTGOT16_LO,
+  BFD_RELOC_PPC64_PLTGOT16_HI,
+  BFD_RELOC_PPC64_PLTGOT16_HA,
+  BFD_RELOC_PPC64_ADDR16_DS,
+  BFD_RELOC_PPC64_ADDR16_LO_DS,
+  BFD_RELOC_PPC64_GOT16_DS,
+  BFD_RELOC_PPC64_GOT16_LO_DS,
+  BFD_RELOC_PPC64_PLT16_LO_DS,
+  BFD_RELOC_PPC64_SECTOFF_DS,
+  BFD_RELOC_PPC64_SECTOFF_LO_DS,
+  BFD_RELOC_PPC64_TOC16_DS,
+  BFD_RELOC_PPC64_TOC16_LO_DS,
+  BFD_RELOC_PPC64_PLTGOT16_DS,
+  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
+
+/* PowerPC and PowerPC64 thread-local storage relocations.  */
+  BFD_RELOC_PPC_TLS,
+  BFD_RELOC_PPC_DTPMOD,
+  BFD_RELOC_PPC_TPREL16,
+  BFD_RELOC_PPC_TPREL16_LO,
+  BFD_RELOC_PPC_TPREL16_HI,
+  BFD_RELOC_PPC_TPREL16_HA,
+  BFD_RELOC_PPC_TPREL,
+  BFD_RELOC_PPC_DTPREL16,
+  BFD_RELOC_PPC_DTPREL16_LO,
+  BFD_RELOC_PPC_DTPREL16_HI,
+  BFD_RELOC_PPC_DTPREL16_HA,
+  BFD_RELOC_PPC_DTPREL,
+  BFD_RELOC_PPC_GOT_TLSGD16,
+  BFD_RELOC_PPC_GOT_TLSGD16_LO,
+  BFD_RELOC_PPC_GOT_TLSGD16_HI,
+  BFD_RELOC_PPC_GOT_TLSGD16_HA,
+  BFD_RELOC_PPC_GOT_TLSLD16,
+  BFD_RELOC_PPC_GOT_TLSLD16_LO,
+  BFD_RELOC_PPC_GOT_TLSLD16_HI,
+  BFD_RELOC_PPC_GOT_TLSLD16_HA,
+  BFD_RELOC_PPC_GOT_TPREL16,
+  BFD_RELOC_PPC_GOT_TPREL16_LO,
+  BFD_RELOC_PPC_GOT_TPREL16_HI,
+  BFD_RELOC_PPC_GOT_TPREL16_HA,
+  BFD_RELOC_PPC_GOT_DTPREL16,
+  BFD_RELOC_PPC_GOT_DTPREL16_LO,
+  BFD_RELOC_PPC_GOT_DTPREL16_HI,
+  BFD_RELOC_PPC_GOT_DTPREL16_HA,
+  BFD_RELOC_PPC64_TPREL16_DS,
+  BFD_RELOC_PPC64_TPREL16_LO_DS,
+  BFD_RELOC_PPC64_TPREL16_HIGHER,
+  BFD_RELOC_PPC64_TPREL16_HIGHERA,
+  BFD_RELOC_PPC64_TPREL16_HIGHEST,
+  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
+  BFD_RELOC_PPC64_DTPREL16_DS,
+  BFD_RELOC_PPC64_DTPREL16_LO_DS,
+  BFD_RELOC_PPC64_DTPREL16_HIGHER,
+  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
+  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
+  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
+
+/* IBM 370/390 relocations  */
+  BFD_RELOC_I370_D12,
+
+/* The type of reloc used to build a constructor table - at the moment
+probably a 32 bit wide absolute relocation, but the target can choose.
+It generally does map to one of the other relocation types.  */
+  BFD_RELOC_CTOR,
+
+/* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BRANCH,
+
+/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BLX,
+
+/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_THUMB_PCREL_BLX,
+
+/* ARM 26-bit pc-relative branch for an unconditional BL or BLX instruction.  */
+  BFD_RELOC_ARM_PCREL_CALL,
+
+/* ARM 26-bit pc-relative branch for B or conditional BL instruction.  */
+  BFD_RELOC_ARM_PCREL_JUMP,
+
+/* Thumb 7-, 9-, 12-, 20-, 23-, and 25-bit pc-relative branches.
+The lowest bit must be zero and is not stored in the instruction.
+Note that the corresponding ELF R_ARM_THM_JUMPnn constant has an
+"nn" one smaller in all cases.  Note further that BRANCH23
+corresponds to R_ARM_THM_CALL.  */
+  BFD_RELOC_THUMB_PCREL_BRANCH7,
+  BFD_RELOC_THUMB_PCREL_BRANCH9,
+  BFD_RELOC_THUMB_PCREL_BRANCH12,
+  BFD_RELOC_THUMB_PCREL_BRANCH20,
+  BFD_RELOC_THUMB_PCREL_BRANCH23,
+  BFD_RELOC_THUMB_PCREL_BRANCH25,
+
+/* 12-bit immediate offset, used in ARM-format ldr and str instructions.  */
+  BFD_RELOC_ARM_OFFSET_IMM,
+
+/* 5-bit immediate offset, used in Thumb-format ldr and str instructions.  */
+  BFD_RELOC_ARM_THUMB_OFFSET,
+
+/* Pc-relative or absolute relocation depending on target.  Used for
+entries in .init_array sections.  */
+  BFD_RELOC_ARM_TARGET1,
+
+/* Read-only segment base relative address.  */
+  BFD_RELOC_ARM_ROSEGREL32,
+
+/* Data segment base relative address.  */
+  BFD_RELOC_ARM_SBREL32,
+
+/* This reloc is used for references to RTTI data from exception handling
+tables.  The actual definition depends on the target.  It may be a
+pc-relative or some form of GOT-indirect relocation.  */
+  BFD_RELOC_ARM_TARGET2,
+
+/* 31-bit PC relative address.  */
+  BFD_RELOC_ARM_PREL31,
+
+/* Low and High halfword relocations for MOVW and MOVT instructions.  */
+  BFD_RELOC_ARM_MOVW,
+  BFD_RELOC_ARM_MOVT,
+  BFD_RELOC_ARM_MOVW_PCREL,
+  BFD_RELOC_ARM_MOVT_PCREL,
+  BFD_RELOC_ARM_THUMB_MOVW,
+  BFD_RELOC_ARM_THUMB_MOVT,
+  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
+  BFD_RELOC_ARM_THUMB_MOVT_PCREL,
+
+/* Relocations for setting up GOTs and PLTs for shared libraries.  */
+  BFD_RELOC_ARM_JUMP_SLOT,
+  BFD_RELOC_ARM_GLOB_DAT,
+  BFD_RELOC_ARM_GOT32,
+  BFD_RELOC_ARM_PLT32,
+  BFD_RELOC_ARM_RELATIVE,
+  BFD_RELOC_ARM_GOTOFF,
+  BFD_RELOC_ARM_GOTPC,
+
+/* ARM thread-local storage relocations.  */
+  BFD_RELOC_ARM_TLS_GD32,
+  BFD_RELOC_ARM_TLS_LDO32,
+  BFD_RELOC_ARM_TLS_LDM32,
+  BFD_RELOC_ARM_TLS_DTPOFF32,
+  BFD_RELOC_ARM_TLS_DTPMOD32,
+  BFD_RELOC_ARM_TLS_TPOFF32,
+  BFD_RELOC_ARM_TLS_IE32,
+  BFD_RELOC_ARM_TLS_LE32,
+
+/* ARM group relocations.  */
+  BFD_RELOC_ARM_ALU_PC_G0_NC,
+  BFD_RELOC_ARM_ALU_PC_G0,
+  BFD_RELOC_ARM_ALU_PC_G1_NC,
+  BFD_RELOC_ARM_ALU_PC_G1,
+  BFD_RELOC_ARM_ALU_PC_G2,
+  BFD_RELOC_ARM_LDR_PC_G0,
+  BFD_RELOC_ARM_LDR_PC_G1,
+  BFD_RELOC_ARM_LDR_PC_G2,
+  BFD_RELOC_ARM_LDRS_PC_G0,
+  BFD_RELOC_ARM_LDRS_PC_G1,
+  BFD_RELOC_ARM_LDRS_PC_G2,
+  BFD_RELOC_ARM_LDC_PC_G0,
+  BFD_RELOC_ARM_LDC_PC_G1,
+  BFD_RELOC_ARM_LDC_PC_G2,
+  BFD_RELOC_ARM_ALU_SB_G0_NC,
+  BFD_RELOC_ARM_ALU_SB_G0,
+  BFD_RELOC_ARM_ALU_SB_G1_NC,
+  BFD_RELOC_ARM_ALU_SB_G1,
+  BFD_RELOC_ARM_ALU_SB_G2,
+  BFD_RELOC_ARM_LDR_SB_G0,
+  BFD_RELOC_ARM_LDR_SB_G1,
+  BFD_RELOC_ARM_LDR_SB_G2,
+  BFD_RELOC_ARM_LDRS_SB_G0,
+  BFD_RELOC_ARM_LDRS_SB_G1,
+  BFD_RELOC_ARM_LDRS_SB_G2,
+  BFD_RELOC_ARM_LDC_SB_G0,
+  BFD_RELOC_ARM_LDC_SB_G1,
+  BFD_RELOC_ARM_LDC_SB_G2,
+
+/* These relocs are only used within the ARM assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_ARM_IMMEDIATE,
+  BFD_RELOC_ARM_ADRL_IMMEDIATE,
+  BFD_RELOC_ARM_T32_IMMEDIATE,
+  BFD_RELOC_ARM_T32_ADD_IMM,
+  BFD_RELOC_ARM_T32_IMM12,
+  BFD_RELOC_ARM_T32_ADD_PC12,
+  BFD_RELOC_ARM_SHIFT_IMM,
+  BFD_RELOC_ARM_SMC,
+  BFD_RELOC_ARM_SWI,
+  BFD_RELOC_ARM_MULTI,
+  BFD_RELOC_ARM_CP_OFF_IMM,
+  BFD_RELOC_ARM_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_ADR_IMM,
+  BFD_RELOC_ARM_LDR_IMM,
+  BFD_RELOC_ARM_LITERAL,
+  BFD_RELOC_ARM_IN_POOL,
+  BFD_RELOC_ARM_OFFSET_IMM8,
+  BFD_RELOC_ARM_T32_OFFSET_U8,
+  BFD_RELOC_ARM_T32_OFFSET_IMM,
+  BFD_RELOC_ARM_HWLITERAL,
+  BFD_RELOC_ARM_THUMB_ADD,
+  BFD_RELOC_ARM_THUMB_IMM,
+  BFD_RELOC_ARM_THUMB_SHIFT,
+
+/* Renesas / SuperH SH relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_SH_PCDISP8BY2,
+  BFD_RELOC_SH_PCDISP12BY2,
+  BFD_RELOC_SH_IMM3,
+  BFD_RELOC_SH_IMM3U,
+  BFD_RELOC_SH_DISP12,
+  BFD_RELOC_SH_DISP12BY2,
+  BFD_RELOC_SH_DISP12BY4,
+  BFD_RELOC_SH_DISP12BY8,
+  BFD_RELOC_SH_DISP20,
+  BFD_RELOC_SH_DISP20BY8,
+  BFD_RELOC_SH_IMM4,
+  BFD_RELOC_SH_IMM4BY2,
+  BFD_RELOC_SH_IMM4BY4,
+  BFD_RELOC_SH_IMM8,
+  BFD_RELOC_SH_IMM8BY2,
+  BFD_RELOC_SH_IMM8BY4,
+  BFD_RELOC_SH_PCRELIMM8BY2,
+  BFD_RELOC_SH_PCRELIMM8BY4,
+  BFD_RELOC_SH_SWITCH16,
+  BFD_RELOC_SH_SWITCH32,
+  BFD_RELOC_SH_USES,
+  BFD_RELOC_SH_COUNT,
+  BFD_RELOC_SH_ALIGN,
+  BFD_RELOC_SH_CODE,
+  BFD_RELOC_SH_DATA,
+  BFD_RELOC_SH_LABEL,
+  BFD_RELOC_SH_LOOP_START,
+  BFD_RELOC_SH_LOOP_END,
+  BFD_RELOC_SH_COPY,
+  BFD_RELOC_SH_GLOB_DAT,
+  BFD_RELOC_SH_JMP_SLOT,
+  BFD_RELOC_SH_RELATIVE,
+  BFD_RELOC_SH_GOTPC,
+  BFD_RELOC_SH_GOT_LOW16,
+  BFD_RELOC_SH_GOT_MEDLOW16,
+  BFD_RELOC_SH_GOT_MEDHI16,
+  BFD_RELOC_SH_GOT_HI16,
+  BFD_RELOC_SH_GOTPLT_LOW16,
+  BFD_RELOC_SH_GOTPLT_MEDLOW16,
+  BFD_RELOC_SH_GOTPLT_MEDHI16,
+  BFD_RELOC_SH_GOTPLT_HI16,
+  BFD_RELOC_SH_PLT_LOW16,
+  BFD_RELOC_SH_PLT_MEDLOW16,
+  BFD_RELOC_SH_PLT_MEDHI16,
+  BFD_RELOC_SH_PLT_HI16,
+  BFD_RELOC_SH_GOTOFF_LOW16,
+  BFD_RELOC_SH_GOTOFF_MEDLOW16,
+  BFD_RELOC_SH_GOTOFF_MEDHI16,
+  BFD_RELOC_SH_GOTOFF_HI16,
+  BFD_RELOC_SH_GOTPC_LOW16,
+  BFD_RELOC_SH_GOTPC_MEDLOW16,
+  BFD_RELOC_SH_GOTPC_MEDHI16,
+  BFD_RELOC_SH_GOTPC_HI16,
+  BFD_RELOC_SH_COPY64,
+  BFD_RELOC_SH_GLOB_DAT64,
+  BFD_RELOC_SH_JMP_SLOT64,
+  BFD_RELOC_SH_RELATIVE64,
+  BFD_RELOC_SH_GOT10BY4,
+  BFD_RELOC_SH_GOT10BY8,
+  BFD_RELOC_SH_GOTPLT10BY4,
+  BFD_RELOC_SH_GOTPLT10BY8,
+  BFD_RELOC_SH_GOTPLT32,
+  BFD_RELOC_SH_SHMEDIA_CODE,
+  BFD_RELOC_SH_IMMU5,
+  BFD_RELOC_SH_IMMS6,
+  BFD_RELOC_SH_IMMS6BY32,
+  BFD_RELOC_SH_IMMU6,
+  BFD_RELOC_SH_IMMS10,
+  BFD_RELOC_SH_IMMS10BY2,
+  BFD_RELOC_SH_IMMS10BY4,
+  BFD_RELOC_SH_IMMS10BY8,
+  BFD_RELOC_SH_IMMS16,
+  BFD_RELOC_SH_IMMU16,
+  BFD_RELOC_SH_IMM_LOW16,
+  BFD_RELOC_SH_IMM_LOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDLOW16,
+  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDHI16,
+  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
+  BFD_RELOC_SH_IMM_HI16,
+  BFD_RELOC_SH_IMM_HI16_PCREL,
+  BFD_RELOC_SH_PT_16,
+  BFD_RELOC_SH_TLS_GD_32,
+  BFD_RELOC_SH_TLS_LD_32,
+  BFD_RELOC_SH_TLS_LDO_32,
+  BFD_RELOC_SH_TLS_IE_32,
+  BFD_RELOC_SH_TLS_LE_32,
+  BFD_RELOC_SH_TLS_DTPMOD32,
+  BFD_RELOC_SH_TLS_DTPOFF32,
+  BFD_RELOC_SH_TLS_TPOFF32,
+
+/* ARC Cores relocs.
+ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  The high 20 bits are installed in bits 26
+through 7 of the instruction.  */
+  BFD_RELOC_ARC_B22_PCREL,
+
+/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
+stored in the instruction.  The high 24 bits are installed in bits 23
+through 0.  */
+  BFD_RELOC_ARC_B26,
+
+/* ADI Blackfin 16 bit immediate absolute reloc.  */
+  BFD_RELOC_BFIN_16_IMM,
+
+/* ADI Blackfin 16 bit immediate absolute reloc higher 16 bits.  */
+  BFD_RELOC_BFIN_16_HIGH,
+
+/* ADI Blackfin 'a' part of LSETUP.  */
+  BFD_RELOC_BFIN_4_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_5_PCREL,
+
+/* ADI Blackfin 16 bit immediate absolute reloc lower 16 bits.  */
+  BFD_RELOC_BFIN_16_LOW,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_10_PCREL,
+
+/* ADI Blackfin 'b' part of LSETUP.  */
+  BFD_RELOC_BFIN_11_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP,
+
+/* ADI Blackfin Short jump, pcrel.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP_S,
+
+/* ADI Blackfin Call.x not implemented.  */
+  BFD_RELOC_BFIN_24_PCREL_CALL_X,
+
+/* ADI Blackfin Long Jump pcrel.  */
+  BFD_RELOC_BFIN_24_PCREL_JUMP_L,
+
+/* ADI Blackfin FD-PIC relocations.  */
+  BFD_RELOC_BFIN_GOT17M4,
+  BFD_RELOC_BFIN_GOTHI,
+  BFD_RELOC_BFIN_GOTLO,
+  BFD_RELOC_BFIN_FUNCDESC,
+  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
+  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
+  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
+  BFD_RELOC_BFIN_FUNCDESC_VALUE,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_BFIN_GOTOFF17M4,
+  BFD_RELOC_BFIN_GOTOFFHI,
+  BFD_RELOC_BFIN_GOTOFFLO,
+
+/* ADI Blackfin GOT relocation.  */
+  BFD_RELOC_BFIN_GOT,
+
+/* ADI Blackfin PLTPC relocation.  */
+  BFD_RELOC_BFIN_PLTPC,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PUSH,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_CONST,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_SUB,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MULT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_DIV,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MOD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_RSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_AND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_OR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_XOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LAND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LEN,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_NEG,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_COMP,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_HWPAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADDR,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_10_PCREL_R,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  This is the same as the previous reloc
+except it is in the left container, i.e.,
+shifted left 15 bits.  */
+  BFD_RELOC_D10V_10_PCREL_L,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18_PCREL,
+
+/* Mitsubishi D30V relocs.
+This is a 6-bit absolute reloc.  */
+  BFD_RELOC_D30V_6,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_9_PCREL,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_9_PCREL_R,
+
+/* This is a 12-bit absolute reloc with the
+right 3 bitsassumed to be 0.  */
+  BFD_RELOC_D30V_15,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_15_PCREL,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_15_PCREL_R,
+
+/* This is an 18-bit absolute reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21_PCREL,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_21_PCREL_R,
+
+/* This is a 32-bit absolute reloc.  */
+  BFD_RELOC_D30V_32,
+
+/* This is a 32-bit pc-relative reloc.  */
+  BFD_RELOC_D30V_32_PCREL,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_HI16_S,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_LO16,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_JMP26,
+
+/* Renesas M16C/M32C Relocations.  */
+  BFD_RELOC_M32C_HI8,
+  BFD_RELOC_M32C_RL_JUMP,
+  BFD_RELOC_M32C_RL_1ADDR,
+  BFD_RELOC_M32C_RL_2ADDR,
+
+/* Renesas M32R (formerly Mitsubishi M32R) relocs.
+This is a 24 bit absolute address.  */
+  BFD_RELOC_M32R_24,
+
+/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_10_PCREL,
+
+/* This is an 18-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_18_PCREL,
+
+/* This is a 26-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_26_PCREL,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as unsigned.  */
+  BFD_RELOC_M32R_HI16_ULO,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as signed.  */
+  BFD_RELOC_M32R_HI16_SLO,
+
+/* This is a 16-bit reloc containing the lower 16 bits of an address.  */
+  BFD_RELOC_M32R_LO16,
+
+/* This is a 16-bit reloc containing the small data area offset for use in
+add3, load, and store instructions.  */
+  BFD_RELOC_M32R_SDA16,
+
+/* For PIC.  */
+  BFD_RELOC_M32R_GOT24,
+  BFD_RELOC_M32R_26_PLTREL,
+  BFD_RELOC_M32R_COPY,
+  BFD_RELOC_M32R_GLOB_DAT,
+  BFD_RELOC_M32R_JMP_SLOT,
+  BFD_RELOC_M32R_RELATIVE,
+  BFD_RELOC_M32R_GOTOFF,
+  BFD_RELOC_M32R_GOTOFF_HI_ULO,
+  BFD_RELOC_M32R_GOTOFF_HI_SLO,
+  BFD_RELOC_M32R_GOTOFF_LO,
+  BFD_RELOC_M32R_GOTPC24,
+  BFD_RELOC_M32R_GOT16_HI_ULO,
+  BFD_RELOC_M32R_GOT16_HI_SLO,
+  BFD_RELOC_M32R_GOT16_LO,
+  BFD_RELOC_M32R_GOTPC_HI_ULO,
+  BFD_RELOC_M32R_GOTPC_HI_SLO,
+  BFD_RELOC_M32R_GOTPC_LO,
+
+/* This is a 9-bit reloc  */
+  BFD_RELOC_V850_9_PCREL,
+
+/* This is a 22-bit reloc  */
+  BFD_RELOC_V850_22_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer.  */
+  BFD_RELOC_V850_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+short data area pointer.  */
+  BFD_RELOC_V850_SDA_15_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_15_16_OFFSET,
+
+/* This is an 8 bit offset (of which only 6 bits are used) from the
+tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_6_8_OFFSET,
+
+/* This is an 8bit offset (of which only 7 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_7_8_OFFSET,
+
+/* This is a 7 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_7_7_OFFSET,
+
+/* This is a 16 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_16_16_OFFSET,
+
+/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_4_5_OFFSET,
+
+/* This is a 4 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_4_4_OFFSET,
+
+/* This is a 16 bit offset from the short data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,
+
+/* This is a 6 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_6_7_OFFSET,
+
+/* This is a 16 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_16_16_OFFSET,
+
+/* Used for relaxing indirect function calls.  */
+  BFD_RELOC_V850_LONGCALL,
+
+/* Used for relaxing indirect jumps.  */
+  BFD_RELOC_V850_LONGJUMP,
+
+/* Used to maintain alignment whilst relaxing.  */
+  BFD_RELOC_V850_ALIGN,
+
+/* This is a variation of BFD_RELOC_LO16 that can be used in v850e ld.bu
+instructions.  */
+  BFD_RELOC_V850_LO16_SPLIT_OFFSET,
+
+/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_32_PCREL,
+
+/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_16_PCREL,
+
+/* This is a 8bit DP reloc for the tms320c30, where the most
+significant 8 bits of a 24 bit word are placed into the least
+significant 8 bits of the opcode.  */
+  BFD_RELOC_TIC30_LDP,
+
+/* This is a 7bit reloc for the tms320c54x, where the least
+significant 7 bits of a 16 bit word are placed into the least
+significant 7 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTLS7,
+
+/* This is a 9bit DP reloc for the tms320c54x, where the most
+significant 9 bits of a 16 bit word are placed into the least
+significant 9 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTMS9,
+
+/* This is an extended address 23-bit reloc for the tms320c54x.  */
+  BFD_RELOC_TIC54X_23,
+
+/* This is a 16-bit reloc for the tms320c54x, where the least
+significant 16 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_16_OF_23,
+
+/* This is a reloc for the tms320c54x, where the most
+significant 7 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_MS7_OF_23,
+
+/* This is a 48 bit reloc for the FR30 that stores 32 bits.  */
+  BFD_RELOC_FR30_48,
+
+/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
+two sections.  */
+  BFD_RELOC_FR30_20,
+
+/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
+4 bits.  */
+  BFD_RELOC_FR30_6_IN_4,
+
+/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
+into 8 bits.  */
+  BFD_RELOC_FR30_8_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
+into 8 bits.  */
+  BFD_RELOC_FR30_9_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
+into 8 bits.  */
+  BFD_RELOC_FR30_10_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
+short offset into 8 bits.  */
+  BFD_RELOC_FR30_9_PCREL,
+
+/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
+short offset into 11 bits.  */
+  BFD_RELOC_FR30_12_PCREL,
+
+/* Motorola Mcore relocations.  */
+  BFD_RELOC_MCORE_PCREL_IMM8BY4,
+  BFD_RELOC_MCORE_PCREL_IMM11BY2,
+  BFD_RELOC_MCORE_PCREL_IMM4BY2,
+  BFD_RELOC_MCORE_PCREL_32,
+  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
+  BFD_RELOC_MCORE_RVA,
+
+/* Toshiba Media Processor Relocations.  */
+  BFD_RELOC_MEP_8,
+  BFD_RELOC_MEP_16,
+  BFD_RELOC_MEP_32,
+  BFD_RELOC_MEP_PCREL8A2,
+  BFD_RELOC_MEP_PCREL12A2,
+  BFD_RELOC_MEP_PCREL17A2,
+  BFD_RELOC_MEP_PCREL24A2,
+  BFD_RELOC_MEP_PCABS24A2,
+  BFD_RELOC_MEP_LOW16,
+  BFD_RELOC_MEP_HI16U,
+  BFD_RELOC_MEP_HI16S,
+  BFD_RELOC_MEP_GPREL,
+  BFD_RELOC_MEP_TPREL,
+  BFD_RELOC_MEP_TPREL7,
+  BFD_RELOC_MEP_TPREL7A2,
+  BFD_RELOC_MEP_TPREL7A4,
+  BFD_RELOC_MEP_UIMM24,
+  BFD_RELOC_MEP_ADDR24A4,
+  BFD_RELOC_MEP_GNU_VTINHERIT,
+  BFD_RELOC_MEP_GNU_VTENTRY,
+
+
+/* These are relocations for the GETA instruction.  */
+  BFD_RELOC_MMIX_GETA,
+  BFD_RELOC_MMIX_GETA_1,
+  BFD_RELOC_MMIX_GETA_2,
+  BFD_RELOC_MMIX_GETA_3,
+
+/* These are relocations for a conditional branch instruction.  */
+  BFD_RELOC_MMIX_CBRANCH,
+  BFD_RELOC_MMIX_CBRANCH_J,
+  BFD_RELOC_MMIX_CBRANCH_1,
+  BFD_RELOC_MMIX_CBRANCH_2,
+  BFD_RELOC_MMIX_CBRANCH_3,
+
+/* These are relocations for the PUSHJ instruction.  */
+  BFD_RELOC_MMIX_PUSHJ,
+  BFD_RELOC_MMIX_PUSHJ_1,
+  BFD_RELOC_MMIX_PUSHJ_2,
+  BFD_RELOC_MMIX_PUSHJ_3,
+  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,
+
+/* These are relocations for the JMP instruction.  */
+  BFD_RELOC_MMIX_JMP,
+  BFD_RELOC_MMIX_JMP_1,
+  BFD_RELOC_MMIX_JMP_2,
+  BFD_RELOC_MMIX_JMP_3,
+
+/* This is a relocation for a relative address as in a GETA instruction or
+a branch.  */
+  BFD_RELOC_MMIX_ADDR19,
+
+/* This is a relocation for a relative address as in a JMP instruction.  */
+  BFD_RELOC_MMIX_ADDR27,
+
+/* This is a relocation for an instruction field that may be a general
+register or a value 0..255.  */
+  BFD_RELOC_MMIX_REG_OR_BYTE,
+
+/* This is a relocation for an instruction field that may be a general
+register.  */
+  BFD_RELOC_MMIX_REG,
+
+/* This is a relocation for two instruction fields holding a register and
+an offset, the equivalent of the relocation.  */
+  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,
+
+/* This relocation is an assertion that the expression is not allocated as
+a global register.  It does not modify contents.  */
+  BFD_RELOC_MMIX_LOCAL,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
+short offset into 7 bits.  */
+  BFD_RELOC_AVR_7_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
+short offset into 12 bits.  */
+  BFD_RELOC_AVR_13_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
+program memory address) into 16 bits.  */
+  BFD_RELOC_AVR_16_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of program memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of 32 bit value) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_MS8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually data memory address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of data memory address) into 8 bit immediate value of
+SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(most high 8 bit of program memory address) into 8 bit immediate value
+of LDI or SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value (msb
+of 32 bit value) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_MS8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value 
+(command address) into 8 bit immediate value of LDI insn. If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+in the lower 128k.  */
+  BFD_RELOC_AVR_LO8_LDI_GS,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+below 128k.  */
+  BFD_RELOC_AVR_HI8_LDI_GS,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually command address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of 16 bit command address) into 8 bit immediate value
+of SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 6 bit of 22 bit command address) into 8 bit immediate
+value of SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM_NEG,
+
+/* This is a 32 bit reloc for the AVR that stores 23 bit value
+into 22 bits.  */
+  BFD_RELOC_AVR_CALL,
+
+/* This is a 16 bit reloc for the AVR that stores all needed bits
+for absolute addressing with ldi with overflow check to linktime  */
+  BFD_RELOC_AVR_LDI,
+
+/* This is a 6 bit reloc for the AVR that stores offset for ldd/std
+instructions  */
+  BFD_RELOC_AVR_6,
+
+/* This is a 6 bit reloc for the AVR that stores offset for adiw/sbiw
+instructions  */
+  BFD_RELOC_AVR_6_ADIW,
+
+/* Difference between two labels: L2 - L1. The value of L1 is encoded
+as sym + addend, while the initial difference after assembly is
+inserted into the object file by the assembler.  */
+  BFD_RELOC_AVR32_DIFF32,
+  BFD_RELOC_AVR32_DIFF16,
+  BFD_RELOC_AVR32_DIFF8,
+
+/* Reference to a symbol through the Global Offset Table. The linker
+will allocate an entry for symbol in the GOT and insert the offset
+of this entry as the relocation value.  */
+  BFD_RELOC_AVR32_GOT32,
+  BFD_RELOC_AVR32_GOT16,
+  BFD_RELOC_AVR32_GOT8,
+
+/* Normal (non-pc-relative) code relocations. Alignment and signedness
+is indicated by the suffixes. S means signed, U means unsigned. W
+means word-aligned, H means halfword-aligned, neither means
+byte-aligned (no alignment.) SUB5 is the same relocation as 16S.  */
+  BFD_RELOC_AVR32_21S,
+  BFD_RELOC_AVR32_16U,
+  BFD_RELOC_AVR32_16S,
+  BFD_RELOC_AVR32_SUB5,
+  BFD_RELOC_AVR32_8S_EXT,
+  BFD_RELOC_AVR32_8S,
+  BFD_RELOC_AVR32_15S,
+
+/* PC-relative relocations are signed if neither 'U' nor 'S' is
+specified. However, we explicitly tack on a 'B' to indicate no
+alignment, to avoid confusion with data relocs. All of these resolve
+to sym + addend - offset, except the one with 'N' (negated) suffix.
+This particular one resolves to offset - sym - addend.  */
+  BFD_RELOC_AVR32_22H_PCREL,
+  BFD_RELOC_AVR32_18W_PCREL,
+  BFD_RELOC_AVR32_16B_PCREL,
+  BFD_RELOC_AVR32_16N_PCREL,
+  BFD_RELOC_AVR32_14UW_PCREL,
+  BFD_RELOC_AVR32_11H_PCREL,
+  BFD_RELOC_AVR32_10UW_PCREL,
+  BFD_RELOC_AVR32_9H_PCREL,
+  BFD_RELOC_AVR32_9UW_PCREL,
+
+/* Subtract the link-time address of the GOT from (symbol + addend)
+and insert the result.  */
+  BFD_RELOC_AVR32_GOTPC,
+
+/* Reference to a symbol through the GOT. The linker will allocate an
+entry for symbol in the GOT and insert the offset of this entry as
+the relocation value. addend must be zero. As usual, 'S' means
+signed, 'W' means word-aligned, etc.  */
+  BFD_RELOC_AVR32_GOTCALL,
+  BFD_RELOC_AVR32_LDA_GOT,
+  BFD_RELOC_AVR32_GOT21S,
+  BFD_RELOC_AVR32_GOT18SW,
+  BFD_RELOC_AVR32_GOT16S,
+
+/* 32-bit constant pool entry. I don't think 8- and 16-bit entries make
+a whole lot of sense.  */
+  BFD_RELOC_AVR32_32_CPENT,
+
+/* Constant pool references. Some of these relocations are signed,
+others are unsigned. It doesn't really matter, since the constant
+pool always comes after the code that references it.  */
+  BFD_RELOC_AVR32_CPCALL,
+  BFD_RELOC_AVR32_16_CP,
+  BFD_RELOC_AVR32_9W_CP,
+
+/* sym must be the absolute symbol. The addend specifies the alignment
+order, e.g. if addend is 2, the linker must add padding so that the
+next address is aligned to a 4-byte boundary.  */
+  BFD_RELOC_AVR32_ALIGN,
+
+/* Code relocations that will never make it to the output file.  */
+  BFD_RELOC_AVR32_14UW,
+  BFD_RELOC_AVR32_10UW,
+  BFD_RELOC_AVR32_10SW,
+  BFD_RELOC_AVR32_STHH_W,
+  BFD_RELOC_AVR32_7UW,
+  BFD_RELOC_AVR32_6S,
+  BFD_RELOC_AVR32_6UW,
+  BFD_RELOC_AVR32_4UH,
+  BFD_RELOC_AVR32_3U,
+
+/* Direct 12 bit.  */
+  BFD_RELOC_390_12,
+
+/* 12 bit GOT offset.  */
+  BFD_RELOC_390_GOT12,
+
+/* 32 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT32,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_390_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_390_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_390_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_390_RELATIVE,
+
+/* 32 bit PC relative offset to GOT.  */
+  BFD_RELOC_390_GOTPC,
+
+/* 16 bit GOT offset.  */
+  BFD_RELOC_390_GOT16,
+
+/* PC relative 16 bit shifted by 1.  */
+  BFD_RELOC_390_PC16DBL,
+
+/* 16 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT16DBL,
+
+/* PC relative 32 bit shifted by 1.  */
+  BFD_RELOC_390_PC32DBL,
+
+/* 32 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT32DBL,
+
+/* 32 bit PC rel. GOT shifted by 1.  */
+  BFD_RELOC_390_GOTPCDBL,
+
+/* 64 bit GOT offset.  */
+  BFD_RELOC_390_GOT64,
+
+/* 64 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT64,
+
+/* 32 bit rel. offset to GOT entry.  */
+  BFD_RELOC_390_GOTENT,
+
+/* 64 bit offset to GOT.  */
+  BFD_RELOC_390_GOTOFF64,
+
+/* 12-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT12,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT16,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT32,
+
+/* 64-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT64,
+
+/* 32-bit rel. offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLTENT,
+
+/* 16-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF16,
+
+/* 32-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF32,
+
+/* 64-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF64,
+
+/* s390 tls relocations.  */
+  BFD_RELOC_390_TLS_LOAD,
+  BFD_RELOC_390_TLS_GDCALL,
+  BFD_RELOC_390_TLS_LDCALL,
+  BFD_RELOC_390_TLS_GD32,
+  BFD_RELOC_390_TLS_GD64,
+  BFD_RELOC_390_TLS_GOTIE12,
+  BFD_RELOC_390_TLS_GOTIE32,
+  BFD_RELOC_390_TLS_GOTIE64,
+  BFD_RELOC_390_TLS_LDM32,
+  BFD_RELOC_390_TLS_LDM64,
+  BFD_RELOC_390_TLS_IE32,
+  BFD_RELOC_390_TLS_IE64,
+  BFD_RELOC_390_TLS_IEENT,
+  BFD_RELOC_390_TLS_LE32,
+  BFD_RELOC_390_TLS_LE64,
+  BFD_RELOC_390_TLS_LDO32,
+  BFD_RELOC_390_TLS_LDO64,
+  BFD_RELOC_390_TLS_DTPMOD,
+  BFD_RELOC_390_TLS_DTPOFF,
+  BFD_RELOC_390_TLS_TPOFF,
+
+/* Long displacement extension.  */
+  BFD_RELOC_390_20,
+  BFD_RELOC_390_GOT20,
+  BFD_RELOC_390_GOTPLT20,
+  BFD_RELOC_390_TLS_GOTIE20,
+
+/* Score relocations  */
+  BFD_RELOC_SCORE_DUMMY1,
+
+/* Low 16 bit for load/store  */
+  BFD_RELOC_SCORE_GPREL15,
+
+/* This is a 24-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_DUMMY2,
+  BFD_RELOC_SCORE_JMP,
+
+/* This is a 19-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_BRANCH,
+
+/* This is a 11-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE16_JMP,
+
+/* This is a 8-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE16_BRANCH,
+
+/* Undocumented Score relocs  */
+  BFD_RELOC_SCORE_GOT15,
+  BFD_RELOC_SCORE_GOT_LO16,
+  BFD_RELOC_SCORE_CALL15,
+  BFD_RELOC_SCORE_DUMMY_HI16,
+
+/* Scenix IP2K - 9-bit register number / data address  */
+  BFD_RELOC_IP2K_FR9,
+
+/* Scenix IP2K - 4-bit register/data bank number  */
+  BFD_RELOC_IP2K_BANK,
+
+/* Scenix IP2K - low 13 bits of instruction word address  */
+  BFD_RELOC_IP2K_ADDR16CJP,
+
+/* Scenix IP2K - high 3 bits of instruction word address  */
+  BFD_RELOC_IP2K_PAGE3,
+
+/* Scenix IP2K - ext/low/high 8 bits of data address  */
+  BFD_RELOC_IP2K_LO8DATA,
+  BFD_RELOC_IP2K_HI8DATA,
+  BFD_RELOC_IP2K_EX8DATA,
+
+/* Scenix IP2K - low/high 8 bits of instruction word address  */
+  BFD_RELOC_IP2K_LO8INSN,
+  BFD_RELOC_IP2K_HI8INSN,
+
+/* Scenix IP2K - even/odd PC modifier to modify snb pcl.0  */
+  BFD_RELOC_IP2K_PC_SKIP,
+
+/* Scenix IP2K - 16 bit word address in text section.  */
+  BFD_RELOC_IP2K_TEXT,
+
+/* Scenix IP2K - 7-bit sp or dp offset  */
+  BFD_RELOC_IP2K_FR_OFFSET,
+
+/* Scenix VPE4K coprocessor - data/insn-space addressing  */
+  BFD_RELOC_VPE4KMATH_DATA,
+  BFD_RELOC_VPE4KMATH_INSN,
+
+/* These two relocations are used by the linker to determine which of
+the entries in a C++ virtual function table are actually used.  When
+the --gc-sections option is given, the linker will zero out the entries
+that are not used, so that the code for those functions need not be
+included in the output.
+
+VTABLE_INHERIT is a zero-space relocation used to describe to the
+linker the inheritance tree of a C++ virtual function table.  The
+relocation's symbol should be the parent class' vtable, and the
+relocation should be located at the child vtable.
+
+VTABLE_ENTRY is a zero-space relocation that describes the use of a
+virtual function table entry.  The reloc's symbol should refer to the
+table of the class mentioned in the code.  Off of that base, an offset
+describes the entry that is being used.  For Rela hosts, this offset
+is stored in the reloc's addend.  For Rel hosts, we are forced to put
+this offset in the reloc's section offset.  */
+  BFD_RELOC_VTABLE_INHERIT,
+  BFD_RELOC_VTABLE_ENTRY,
+
+/* Intel IA64 Relocations.  */
+  BFD_RELOC_IA64_IMM14,
+  BFD_RELOC_IA64_IMM22,
+  BFD_RELOC_IA64_IMM64,
+  BFD_RELOC_IA64_DIR32MSB,
+  BFD_RELOC_IA64_DIR32LSB,
+  BFD_RELOC_IA64_DIR64MSB,
+  BFD_RELOC_IA64_DIR64LSB,
+  BFD_RELOC_IA64_GPREL22,
+  BFD_RELOC_IA64_GPREL64I,
+  BFD_RELOC_IA64_GPREL32MSB,
+  BFD_RELOC_IA64_GPREL32LSB,
+  BFD_RELOC_IA64_GPREL64MSB,
+  BFD_RELOC_IA64_GPREL64LSB,
+  BFD_RELOC_IA64_LTOFF22,
+  BFD_RELOC_IA64_LTOFF64I,
+  BFD_RELOC_IA64_PLTOFF22,
+  BFD_RELOC_IA64_PLTOFF64I,
+  BFD_RELOC_IA64_PLTOFF64MSB,
+  BFD_RELOC_IA64_PLTOFF64LSB,
+  BFD_RELOC_IA64_FPTR64I,
+  BFD_RELOC_IA64_FPTR32MSB,
+  BFD_RELOC_IA64_FPTR32LSB,
+  BFD_RELOC_IA64_FPTR64MSB,
+  BFD_RELOC_IA64_FPTR64LSB,
+  BFD_RELOC_IA64_PCREL21B,
+  BFD_RELOC_IA64_PCREL21BI,
+  BFD_RELOC_IA64_PCREL21M,
+  BFD_RELOC_IA64_PCREL21F,
+  BFD_RELOC_IA64_PCREL22,
+  BFD_RELOC_IA64_PCREL60B,
+  BFD_RELOC_IA64_PCREL64I,
+  BFD_RELOC_IA64_PCREL32MSB,
+  BFD_RELOC_IA64_PCREL32LSB,
+  BFD_RELOC_IA64_PCREL64MSB,
+  BFD_RELOC_IA64_PCREL64LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR22,
+  BFD_RELOC_IA64_LTOFF_FPTR64I,
+  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
+  BFD_RELOC_IA64_SEGREL32MSB,
+  BFD_RELOC_IA64_SEGREL32LSB,
+  BFD_RELOC_IA64_SEGREL64MSB,
+  BFD_RELOC_IA64_SEGREL64LSB,
+  BFD_RELOC_IA64_SECREL32MSB,
+  BFD_RELOC_IA64_SECREL32LSB,
+  BFD_RELOC_IA64_SECREL64MSB,
+  BFD_RELOC_IA64_SECREL64LSB,
+  BFD_RELOC_IA64_REL32MSB,
+  BFD_RELOC_IA64_REL32LSB,
+  BFD_RELOC_IA64_REL64MSB,
+  BFD_RELOC_IA64_REL64LSB,
+  BFD_RELOC_IA64_LTV32MSB,
+  BFD_RELOC_IA64_LTV32LSB,
+  BFD_RELOC_IA64_LTV64MSB,
+  BFD_RELOC_IA64_LTV64LSB,
+  BFD_RELOC_IA64_IPLTMSB,
+  BFD_RELOC_IA64_IPLTLSB,
+  BFD_RELOC_IA64_COPY,
+  BFD_RELOC_IA64_LTOFF22X,
+  BFD_RELOC_IA64_LDXMOV,
+  BFD_RELOC_IA64_TPREL14,
+  BFD_RELOC_IA64_TPREL22,
+  BFD_RELOC_IA64_TPREL64I,
+  BFD_RELOC_IA64_TPREL64MSB,
+  BFD_RELOC_IA64_TPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_TPREL22,
+  BFD_RELOC_IA64_DTPMOD64MSB,
+  BFD_RELOC_IA64_DTPMOD64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPMOD22,
+  BFD_RELOC_IA64_DTPREL14,
+  BFD_RELOC_IA64_DTPREL22,
+  BFD_RELOC_IA64_DTPREL64I,
+  BFD_RELOC_IA64_DTPREL32MSB,
+  BFD_RELOC_IA64_DTPREL32LSB,
+  BFD_RELOC_IA64_DTPREL64MSB,
+  BFD_RELOC_IA64_DTPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPREL22,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit high part of an absolute address.  */
+  BFD_RELOC_M68HC11_HI8,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit low part of an absolute address.  */
+  BFD_RELOC_M68HC11_LO8,
+
+/* Motorola 68HC11 reloc.
+This is the 3 bit of a value.  */
+  BFD_RELOC_M68HC11_3B,
+
+/* Motorola 68HC11 reloc.
+This reloc marks the beginning of a jump/call instruction.
+It is used for linker relaxation to correctly identify beginning
+of instruction and change some branches to use PC-relative
+addressing mode.  */
+  BFD_RELOC_M68HC11_RL_JUMP,
+
+/* Motorola 68HC11 reloc.
+This reloc marks a group of several instructions that gcc generates
+and for which the linker relaxation pass can modify and/or remove
+some of them.  */
+  BFD_RELOC_M68HC11_RL_GROUP,
+
+/* Motorola 68HC11 reloc.
+This is the 16-bit lower part of an address.  It is used for 'call'
+instruction to specify the symbol address without any special
+transformation (due to memory bank window).  */
+  BFD_RELOC_M68HC11_LO16,
+
+/* Motorola 68HC11 reloc.
+This is a 8-bit reloc that specifies the page number of an address.
+It is used by 'call' instruction to specify the page number of
+the symbol.  */
+  BFD_RELOC_M68HC11_PAGE,
+
+/* Motorola 68HC11 reloc.
+This is a 24-bit reloc that represents the address with a 16-bit
+value and a 8-bit page number.  The symbol address is transformed
+to follow the 16K memory bank of 68HC12 (seen as mapped in the window).  */
+  BFD_RELOC_M68HC11_24,
+
+/* Motorola 68HC12 reloc.
+This is the 5 bits of a value.  */
+  BFD_RELOC_M68HC12_5B,
+
+/* NS CR16C Relocations.  */
+  BFD_RELOC_16C_NUM08,
+  BFD_RELOC_16C_NUM08_C,
+  BFD_RELOC_16C_NUM16,
+  BFD_RELOC_16C_NUM16_C,
+  BFD_RELOC_16C_NUM32,
+  BFD_RELOC_16C_NUM32_C,
+  BFD_RELOC_16C_DISP04,
+  BFD_RELOC_16C_DISP04_C,
+  BFD_RELOC_16C_DISP08,
+  BFD_RELOC_16C_DISP08_C,
+  BFD_RELOC_16C_DISP16,
+  BFD_RELOC_16C_DISP16_C,
+  BFD_RELOC_16C_DISP24,
+  BFD_RELOC_16C_DISP24_C,
+  BFD_RELOC_16C_DISP24a,
+  BFD_RELOC_16C_DISP24a_C,
+  BFD_RELOC_16C_REG04,
+  BFD_RELOC_16C_REG04_C,
+  BFD_RELOC_16C_REG04a,
+  BFD_RELOC_16C_REG04a_C,
+  BFD_RELOC_16C_REG14,
+  BFD_RELOC_16C_REG14_C,
+  BFD_RELOC_16C_REG16,
+  BFD_RELOC_16C_REG16_C,
+  BFD_RELOC_16C_REG20,
+  BFD_RELOC_16C_REG20_C,
+  BFD_RELOC_16C_ABS20,
+  BFD_RELOC_16C_ABS20_C,
+  BFD_RELOC_16C_ABS24,
+  BFD_RELOC_16C_ABS24_C,
+  BFD_RELOC_16C_IMM04,
+  BFD_RELOC_16C_IMM04_C,
+  BFD_RELOC_16C_IMM16,
+  BFD_RELOC_16C_IMM16_C,
+  BFD_RELOC_16C_IMM20,
+  BFD_RELOC_16C_IMM20_C,
+  BFD_RELOC_16C_IMM24,
+  BFD_RELOC_16C_IMM24_C,
+  BFD_RELOC_16C_IMM32,
+  BFD_RELOC_16C_IMM32_C,
+
+/* NS CR16 Relocations.  */
+  BFD_RELOC_CR16_NUM8,
+  BFD_RELOC_CR16_NUM16,
+  BFD_RELOC_CR16_NUM32,
+  BFD_RELOC_CR16_NUM32a,
+  BFD_RELOC_CR16_REGREL0,
+  BFD_RELOC_CR16_REGREL4,
+  BFD_RELOC_CR16_REGREL4a,
+  BFD_RELOC_CR16_REGREL14,
+  BFD_RELOC_CR16_REGREL14a,
+  BFD_RELOC_CR16_REGREL16,
+  BFD_RELOC_CR16_REGREL20,
+  BFD_RELOC_CR16_REGREL20a,
+  BFD_RELOC_CR16_ABS20,
+  BFD_RELOC_CR16_ABS24,
+  BFD_RELOC_CR16_IMM4,
+  BFD_RELOC_CR16_IMM8,
+  BFD_RELOC_CR16_IMM16,
+  BFD_RELOC_CR16_IMM20,
+  BFD_RELOC_CR16_IMM24,
+  BFD_RELOC_CR16_IMM32,
+  BFD_RELOC_CR16_IMM32a,
+  BFD_RELOC_CR16_DISP4,
+  BFD_RELOC_CR16_DISP8,
+  BFD_RELOC_CR16_DISP16,
+  BFD_RELOC_CR16_DISP20,
+  BFD_RELOC_CR16_DISP24,
+  BFD_RELOC_CR16_DISP24a,
+
+/* NS CRX Relocations.  */
+  BFD_RELOC_CRX_REL4,
+  BFD_RELOC_CRX_REL8,
+  BFD_RELOC_CRX_REL8_CMP,
+  BFD_RELOC_CRX_REL16,
+  BFD_RELOC_CRX_REL24,
+  BFD_RELOC_CRX_REL32,
+  BFD_RELOC_CRX_REGREL12,
+  BFD_RELOC_CRX_REGREL22,
+  BFD_RELOC_CRX_REGREL28,
+  BFD_RELOC_CRX_REGREL32,
+  BFD_RELOC_CRX_ABS16,
+  BFD_RELOC_CRX_ABS32,
+  BFD_RELOC_CRX_NUM8,
+  BFD_RELOC_CRX_NUM16,
+  BFD_RELOC_CRX_NUM32,
+  BFD_RELOC_CRX_IMM16,
+  BFD_RELOC_CRX_IMM32,
+  BFD_RELOC_CRX_SWITCH8,
+  BFD_RELOC_CRX_SWITCH16,
+  BFD_RELOC_CRX_SWITCH32,
+
+/* These relocs are only used within the CRIS assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_CRIS_BDISP8,
+  BFD_RELOC_CRIS_UNSIGNED_5,
+  BFD_RELOC_CRIS_SIGNED_6,
+  BFD_RELOC_CRIS_UNSIGNED_6,
+  BFD_RELOC_CRIS_SIGNED_8,
+  BFD_RELOC_CRIS_UNSIGNED_8,
+  BFD_RELOC_CRIS_SIGNED_16,
+  BFD_RELOC_CRIS_UNSIGNED_16,
+  BFD_RELOC_CRIS_LAPCQ_OFFSET,
+  BFD_RELOC_CRIS_UNSIGNED_4,
+
+/* Relocs used in ELF shared libraries for CRIS.  */
+  BFD_RELOC_CRIS_COPY,
+  BFD_RELOC_CRIS_GLOB_DAT,
+  BFD_RELOC_CRIS_JUMP_SLOT,
+  BFD_RELOC_CRIS_RELATIVE,
+
+/* 32-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_32_GOT,
+
+/* 16-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_16_GOT,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_32_GOTPLT,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_16_GOTPLT,
+
+/* 32-bit offset to symbol, relative to GOT.  */
+  BFD_RELOC_CRIS_32_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to GOT.  */
+  BFD_RELOC_CRIS_32_PLT_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to this relocation.  */
+  BFD_RELOC_CRIS_32_PLT_PCREL,
+
+/* Intel i860 Relocations.  */
+  BFD_RELOC_860_COPY,
+  BFD_RELOC_860_GLOB_DAT,
+  BFD_RELOC_860_JUMP_SLOT,
+  BFD_RELOC_860_RELATIVE,
+  BFD_RELOC_860_PC26,
+  BFD_RELOC_860_PLT26,
+  BFD_RELOC_860_PC16,
+  BFD_RELOC_860_LOW0,
+  BFD_RELOC_860_SPLIT0,
+  BFD_RELOC_860_LOW1,
+  BFD_RELOC_860_SPLIT1,
+  BFD_RELOC_860_LOW2,
+  BFD_RELOC_860_SPLIT2,
+  BFD_RELOC_860_LOW3,
+  BFD_RELOC_860_LOGOT0,
+  BFD_RELOC_860_SPGOT0,
+  BFD_RELOC_860_LOGOT1,
+  BFD_RELOC_860_SPGOT1,
+  BFD_RELOC_860_LOGOTOFF0,
+  BFD_RELOC_860_SPGOTOFF0,
+  BFD_RELOC_860_LOGOTOFF1,
+  BFD_RELOC_860_SPGOTOFF1,
+  BFD_RELOC_860_LOGOTOFF2,
+  BFD_RELOC_860_LOGOTOFF3,
+  BFD_RELOC_860_LOPC,
+  BFD_RELOC_860_HIGHADJ,
+  BFD_RELOC_860_HAGOT,
+  BFD_RELOC_860_HAGOTOFF,
+  BFD_RELOC_860_HAPC,
+  BFD_RELOC_860_HIGH,
+  BFD_RELOC_860_HIGOT,
+  BFD_RELOC_860_HIGOTOFF,
+
+/* OpenRISC Relocations.  */
+  BFD_RELOC_OPENRISC_ABS_26,
+  BFD_RELOC_OPENRISC_REL_26,
+
+/* H8 elf Relocations.  */
+  BFD_RELOC_H8_DIR16A8,
+  BFD_RELOC_H8_DIR16R8,
+  BFD_RELOC_H8_DIR24A8,
+  BFD_RELOC_H8_DIR24R8,
+  BFD_RELOC_H8_DIR32A16,
+
+/* Sony Xstormy16 Relocations.  */
+  BFD_RELOC_XSTORMY16_REL_12,
+  BFD_RELOC_XSTORMY16_12,
+  BFD_RELOC_XSTORMY16_24,
+  BFD_RELOC_XSTORMY16_FPTR16,
+
+/* Self-describing complex relocations.  */
+  BFD_RELOC_RELC,
+
+
+/* Infineon Relocations.  */
+  BFD_RELOC_XC16X_PAG,
+  BFD_RELOC_XC16X_POF,
+  BFD_RELOC_XC16X_SEG,
+  BFD_RELOC_XC16X_SOF,
+
+/* Relocations used by VAX ELF.  */
+  BFD_RELOC_VAX_GLOB_DAT,
+  BFD_RELOC_VAX_JMP_SLOT,
+  BFD_RELOC_VAX_RELATIVE,
+
+/* Morpho MT - 16 bit immediate relocation.  */
+  BFD_RELOC_MT_PC16,
+
+/* Morpho MT - Hi 16 bits of an address.  */
+  BFD_RELOC_MT_HI16,
+
+/* Morpho MT - Low 16 bits of an address.  */
+  BFD_RELOC_MT_LO16,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTINHERIT,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTENTRY,
+
+/* Morpho MT - 8 bit immediate relocation.  */
+  BFD_RELOC_MT_PCINSN8,
+
+/* msp430 specific relocation codes  */
+  BFD_RELOC_MSP430_10_PCREL,
+  BFD_RELOC_MSP430_16_PCREL,
+  BFD_RELOC_MSP430_16,
+  BFD_RELOC_MSP430_16_PCREL_BYTE,
+  BFD_RELOC_MSP430_16_BYTE,
+  BFD_RELOC_MSP430_2X_PCREL,
+  BFD_RELOC_MSP430_RL_PCREL,
+
+/* IQ2000 Relocations.  */
+  BFD_RELOC_IQ2000_OFFSET_16,
+  BFD_RELOC_IQ2000_OFFSET_21,
+  BFD_RELOC_IQ2000_UHI16,
+
+/* Special Xtensa relocation used only by PLT entries in ELF shared
+objects to indicate that the runtime linker should set the value
+to one of its own internal functions or data structures.  */
+  BFD_RELOC_XTENSA_RTLD,
+
+/* Xtensa relocations for ELF shared objects.  */
+  BFD_RELOC_XTENSA_GLOB_DAT,
+  BFD_RELOC_XTENSA_JMP_SLOT,
+  BFD_RELOC_XTENSA_RELATIVE,
+
+/* Xtensa relocation used in ELF object files for symbols that may require
+PLT entries.  Otherwise, this is just a generic 32-bit relocation.  */
+  BFD_RELOC_XTENSA_PLT,
+
+/* Xtensa relocations to mark the difference of two local symbols.
+These are only needed to support linker relaxation and can be ignored
+when not relaxing.  The field is set to the value of the difference
+assuming no relaxation.  The relocation encodes the position of the
+first symbol so the linker can determine whether to adjust the field
+value.  */
+  BFD_RELOC_XTENSA_DIFF8,
+  BFD_RELOC_XTENSA_DIFF16,
+  BFD_RELOC_XTENSA_DIFF32,
+
+/* Generic Xtensa relocations for instruction operands.  Only the slot
+number is encoded in the relocation.  The relocation applies to the
+last PC-relative immediate operand, or if there are no PC-relative
+immediates, to the last immediate operand.  */
+  BFD_RELOC_XTENSA_SLOT0_OP,
+  BFD_RELOC_XTENSA_SLOT1_OP,
+  BFD_RELOC_XTENSA_SLOT2_OP,
+  BFD_RELOC_XTENSA_SLOT3_OP,
+  BFD_RELOC_XTENSA_SLOT4_OP,
+  BFD_RELOC_XTENSA_SLOT5_OP,
+  BFD_RELOC_XTENSA_SLOT6_OP,
+  BFD_RELOC_XTENSA_SLOT7_OP,
+  BFD_RELOC_XTENSA_SLOT8_OP,
+  BFD_RELOC_XTENSA_SLOT9_OP,
+  BFD_RELOC_XTENSA_SLOT10_OP,
+  BFD_RELOC_XTENSA_SLOT11_OP,
+  BFD_RELOC_XTENSA_SLOT12_OP,
+  BFD_RELOC_XTENSA_SLOT13_OP,
+  BFD_RELOC_XTENSA_SLOT14_OP,
+
+/* Alternate Xtensa relocations.  Only the slot is encoded in the
+relocation.  The meaning of these relocations is opcode-specific.  */
+  BFD_RELOC_XTENSA_SLOT0_ALT,
+  BFD_RELOC_XTENSA_SLOT1_ALT,
+  BFD_RELOC_XTENSA_SLOT2_ALT,
+  BFD_RELOC_XTENSA_SLOT3_ALT,
+  BFD_RELOC_XTENSA_SLOT4_ALT,
+  BFD_RELOC_XTENSA_SLOT5_ALT,
+  BFD_RELOC_XTENSA_SLOT6_ALT,
+  BFD_RELOC_XTENSA_SLOT7_ALT,
+  BFD_RELOC_XTENSA_SLOT8_ALT,
+  BFD_RELOC_XTENSA_SLOT9_ALT,
+  BFD_RELOC_XTENSA_SLOT10_ALT,
+  BFD_RELOC_XTENSA_SLOT11_ALT,
+  BFD_RELOC_XTENSA_SLOT12_ALT,
+  BFD_RELOC_XTENSA_SLOT13_ALT,
+  BFD_RELOC_XTENSA_SLOT14_ALT,
+
+/* Xtensa relocations for backward compatibility.  These have all been
+replaced by BFD_RELOC_XTENSA_SLOT0_OP.  */
+  BFD_RELOC_XTENSA_OP0,
+  BFD_RELOC_XTENSA_OP1,
+  BFD_RELOC_XTENSA_OP2,
+
+/* Xtensa relocation to mark that the assembler expanded the
+instructions from an original target.  The expansion size is
+encoded in the reloc size.  */
+  BFD_RELOC_XTENSA_ASM_EXPAND,
+
+/* Xtensa relocation to mark that the linker should simplify
+assembler-expanded instructions.  This is commonly used
+internally by the linker after analysis of a
+BFD_RELOC_XTENSA_ASM_EXPAND.  */
+  BFD_RELOC_XTENSA_ASM_SIMPLIFY,
+
+/* 8 bit signed offset in (ix+d) or (iy+d).  */
+  BFD_RELOC_Z80_DISP8,
+
+/* DJNZ offset.  */
+  BFD_RELOC_Z8K_DISP7,
+
+/* CALR offset.  */
+  BFD_RELOC_Z8K_CALLR,
+
+/* 4 bit value.  */
+  BFD_RELOC_Z8K_IMM4L,
+  BFD_RELOC_UNUSED };
+typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
+reloc_howto_type *bfd_reloc_type_lookup
+   (bfd *abfd, bfd_reloc_code_real_type code);
+reloc_howto_type *bfd_reloc_name_lookup
+   (bfd *abfd, const char *reloc_name);
+
+const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
+
+/* Extracted from syms.c.  */
+
+typedef struct bfd_symbol
+{
+  /* A pointer to the BFD which owns the symbol. This information
+     is necessary so that a back end can work out what additional
+     information (invisible to the application writer) is carried
+     with the symbol.
+
+     This field is *almost* redundant, since you can use section->owner
+     instead, except that some symbols point to the global sections
+     bfd_{abs,com,und}_section.  This could be fixed by making
+     these globals be per-bfd (or per-target-flavor).  FIXME.  */
+  struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
+
+  /* The text of the symbol. The name is left alone, and not copied; the
+     application may not alter it.  */
+  const char *name;
+
+  /* The value of the symbol.  This really should be a union of a
+     numeric value with a pointer, since some flags indicate that
+     a pointer to another symbol is stored here.  */
+  symvalue value;
+
+  /* Attributes of a symbol.  */
+#define BSF_NO_FLAGS    0x00
+
+  /* The symbol has local scope; <<static>> in <<C>>. The value
+     is the offset into the section of the data.  */
+#define BSF_LOCAL      0x01
+
+  /* The symbol has global scope; initialized data in <<C>>. The
+     value is the offset into the section of the data.  */
+#define BSF_GLOBAL     0x02
+
+  /* The symbol has global scope and is exported. The value is
+     the offset into the section of the data.  */
+#define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
+
+  /* A normal C symbol would be one of:
+     <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
+     <<BSF_GLOBAL>>.  */
+
+  /* The symbol is a debugging record. The value has an arbitrary
+     meaning, unless BSF_DEBUGGING_RELOC is also set.  */
+#define BSF_DEBUGGING  0x08
+
+  /* The symbol denotes a function entry point.  Used in ELF,
+     perhaps others someday.  */
+#define BSF_FUNCTION    0x10
+
+  /* Used by the linker.  */
+#define BSF_KEEP        0x20
+#define BSF_KEEP_G      0x40
+
+  /* A weak global symbol, overridable without warnings by
+     a regular global symbol of the same name.  */
+#define BSF_WEAK        0x80
+
+  /* This symbol was created to point to a section, e.g. ELF's
+     STT_SECTION symbols.  */
+#define BSF_SECTION_SYM 0x100
+
+  /* The symbol used to be a common symbol, but now it is
+     allocated.  */
+#define BSF_OLD_COMMON  0x200
+
+  /* The default value for common data.  */
+#define BFD_FORT_COMM_DEFAULT_VALUE 0
+
+  /* In some files the type of a symbol sometimes alters its
+     location in an output file - ie in coff a <<ISFCN>> symbol
+     which is also <<C_EXT>> symbol appears where it was
+     declared and not at the end of a section.  This bit is set
+     by the target BFD part to convey this information.  */
+#define BSF_NOT_AT_END    0x400
+
+  /* Signal that the symbol is the label of constructor section.  */
+#define BSF_CONSTRUCTOR   0x800
+
+  /* Signal that the symbol is a warning symbol.  The name is a
+     warning.  The name of the next symbol is the one to warn about;
+     if a reference is made to a symbol with the same name as the next
+     symbol, a warning is issued by the linker.  */
+#define BSF_WARNING       0x1000
+
+  /* Signal that the symbol is indirect.  This symbol is an indirect
+     pointer to the symbol with the same name as the next symbol.  */
+#define BSF_INDIRECT      0x2000
+
+  /* BSF_FILE marks symbols that contain a file name.  This is used
+     for ELF STT_FILE symbols.  */
+#define BSF_FILE          0x4000
+
+  /* Symbol is from dynamic linking information.  */
+#define BSF_DYNAMIC       0x8000
+
+  /* The symbol denotes a data object.  Used in ELF, and perhaps
+     others someday.  */
+#define BSF_OBJECT        0x10000
+
+  /* This symbol is a debugging symbol.  The value is the offset
+     into the section of the data.  BSF_DEBUGGING should be set
+     as well.  */
+#define BSF_DEBUGGING_RELOC 0x20000
+
+  /* This symbol is thread local.  Used in ELF.  */
+#define BSF_THREAD_LOCAL  0x40000
+
+  /* This symbol represents a complex relocation expression,
+     with the expression tree serialized in the symbol name.  */
+#define BSF_RELC 0x80000
+
+  /* This symbol represents a signed complex relocation expression,
+     with the expression tree serialized in the symbol name.  */
+#define BSF_SRELC 0x100000
+
+  flagword flags;
+
+  /* A pointer to the section to which this symbol is
+     relative.  This will always be non NULL, there are special
+     sections for undefined and absolute symbols.  */
+  struct bfd_section *section;
+
+  /* Back end special data.  */
+  union
+    {
+      void *p;
+      bfd_vma i;
+    }
+  udata;
+}
+asymbol;
+
+#define bfd_get_symtab_upper_bound(abfd) \
+     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
+
+bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
+
+bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
+
+#define bfd_is_local_label_name(abfd, name) \
+  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
+
+bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);
+
+#define bfd_is_target_special_symbol(abfd, sym) \
+  BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))
+
+#define bfd_canonicalize_symtab(abfd, location) \
+  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
+
+bfd_boolean bfd_set_symtab
+   (bfd *abfd, asymbol **location, unsigned int count);
+
+void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
+
+#define bfd_make_empty_symbol(abfd) \
+  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
+
+asymbol *_bfd_generic_make_empty_symbol (bfd *);
+
+#define bfd_make_debug_symbol(abfd,ptr,size) \
+  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
+
+int bfd_decode_symclass (asymbol *symbol);
+
+bfd_boolean bfd_is_undefined_symclass (int symclass);
+
+void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
+
+bfd_boolean bfd_copy_private_symbol_data
+   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
+
+#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
+  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
+            (ibfd, isymbol, obfd, osymbol))
+
+/* Extracted from bfd.c.  */
+struct bfd
+{
+  /* A unique identifier of the BFD  */
+  unsigned int id;
+
+  /* The filename the application opened the BFD with.  */
+  const char *filename;
+
+  /* A pointer to the target jump table.  */
+  const struct bfd_target *xvec;
+
+  /* The IOSTREAM, and corresponding IO vector that provide access
+     to the file backing the BFD.  */
+  void *iostream;
+  const struct bfd_iovec *iovec;
+
+  /* Is the file descriptor being cached?  That is, can it be closed as
+     needed, and re-opened when accessed later?  */
+  bfd_boolean cacheable;
+
+  /* Marks whether there was a default target specified when the
+     BFD was opened. This is used to select which matching algorithm
+     to use to choose the back end.  */
+  bfd_boolean target_defaulted;
+
+  /* The caching routines use these to maintain a
+     least-recently-used list of BFDs.  */
+  struct bfd *lru_prev, *lru_next;
+
+  /* When a file is closed by the caching routines, BFD retains
+     state information on the file here...  */
+  ufile_ptr where;
+
+  /* ... and here: (``once'' means at least once).  */
+  bfd_boolean opened_once;
+
+  /* Set if we have a locally maintained mtime value, rather than
+     getting it from the file each time.  */
+  bfd_boolean mtime_set;
+
+  /* File modified time, if mtime_set is TRUE.  */
+  long mtime;
+
+  /* Reserved for an unimplemented file locking extension.  */
+  int ifd;
+
+  /* The format which belongs to the BFD. (object, core, etc.)  */
+  bfd_format format;
+
+  /* The direction with which the BFD was opened.  */
+  enum bfd_direction
+    {
+      no_direction = 0,
+      read_direction = 1,
+      write_direction = 2,
+      both_direction = 3
+    }
+  direction;
+
+  /* Format_specific flags.  */
+  flagword flags;
+
+  /* Currently my_archive is tested before adding origin to
+     anything. I believe that this can become always an add of
+     origin, with origin set to 0 for non archive files.  */
+  ufile_ptr origin;
+
+  /* Remember when output has begun, to stop strange things
+     from happening.  */
+  bfd_boolean output_has_begun;
+
+  /* A hash table for section names.  */
+  struct bfd_hash_table section_htab;
+
+  /* Pointer to linked list of sections.  */
+  struct bfd_section *sections;
+
+  /* The last section on the section list.  */
+  struct bfd_section *section_last;
+
+  /* The number of sections.  */
+  unsigned int section_count;
+
+  /* Stuff only useful for object files:
+     The start address.  */
+  bfd_vma start_address;
+
+  /* Used for input and output.  */
+  unsigned int symcount;
+
+  /* Symbol table for output BFD (with symcount entries).  */
+  struct bfd_symbol  **outsymbols;
+
+  /* Used for slurped dynamic symbol tables.  */
+  unsigned int dynsymcount;
+
+  /* Pointer to structure which contains architecture information.  */
+  const struct bfd_arch_info *arch_info;
+
+  /* Flag set if symbols from this BFD should not be exported.  */
+  bfd_boolean no_export;
+
+  /* Stuff only useful for archives.  */
+  void *arelt_data;
+  struct bfd *my_archive;      /* The containing archive BFD.  */
+  struct bfd *archive_next;    /* The next BFD in the archive.  */
+  struct bfd *archive_head;    /* The first BFD in the archive.  */
+  bfd_boolean has_armap;
+
+  /* A chain of BFD structures involved in a link.  */
+  struct bfd *link_next;
+
+  /* A field used by _bfd_generic_link_add_archive_symbols.  This will
+     be used only for archive elements.  */
+  int archive_pass;
+
+  /* Used by the back end to hold private data.  */
+  union
+    {
+      struct aout_data_struct *aout_data;
+      struct artdata *aout_ar_data;
+      struct _oasys_data *oasys_obj_data;
+      struct _oasys_ar_data *oasys_ar_data;
+      struct coff_tdata *coff_obj_data;
+      struct pe_tdata *pe_obj_data;
+      struct xcoff_tdata *xcoff_obj_data;
+      struct ecoff_tdata *ecoff_obj_data;
+      struct ieee_data_struct *ieee_data;
+      struct ieee_ar_data_struct *ieee_ar_data;
+      struct srec_data_struct *srec_data;
+      struct ihex_data_struct *ihex_data;
+      struct tekhex_data_struct *tekhex_data;
+      struct elf_obj_tdata *elf_obj_data;
+      struct nlm_obj_tdata *nlm_obj_data;
+      struct bout_data_struct *bout_data;
+      struct mmo_data_struct *mmo_data;
+      struct sun_core_struct *sun_core_data;
+      struct sco5_core_struct *sco5_core_data;
+      struct trad_core_struct *trad_core_data;
+      struct som_data_struct *som_data;
+      struct hpux_core_struct *hpux_core_data;
+      struct hppabsd_core_struct *hppabsd_core_data;
+      struct sgi_core_struct *sgi_core_data;
+      struct lynx_core_struct *lynx_core_data;
+      struct osf_core_struct *osf_core_data;
+      struct cisco_core_struct *cisco_core_data;
+      struct versados_data_struct *versados_data;
+      struct netbsd_core_struct *netbsd_core_data;
+      struct mach_o_data_struct *mach_o_data;
+      struct mach_o_fat_data_struct *mach_o_fat_data;
+      struct bfd_pef_data_struct *pef_data;
+      struct bfd_pef_xlib_data_struct *pef_xlib_data;
+      struct bfd_sym_data_struct *sym_data;
+      void *any;
+    }
+  tdata;
+
+  /* Used by the application to hold private data.  */
+  void *usrdata;
+
+  /* Where all the allocated stuff under this BFD goes.  This is a
+     struct objalloc *, but we use void * to avoid requiring the inclusion
+     of objalloc.h.  */
+  void *memory;
+};
+
+typedef enum bfd_error
+{
+  bfd_error_no_error = 0,
+  bfd_error_system_call,
+  bfd_error_invalid_target,
+  bfd_error_wrong_format,
+  bfd_error_wrong_object_format,
+  bfd_error_invalid_operation,
+  bfd_error_no_memory,
+  bfd_error_no_symbols,
+  bfd_error_no_armap,
+  bfd_error_no_more_archived_files,
+  bfd_error_malformed_archive,
+  bfd_error_file_not_recognized,
+  bfd_error_file_ambiguously_recognized,
+  bfd_error_no_contents,
+  bfd_error_nonrepresentable_section,
+  bfd_error_no_debug_section,
+  bfd_error_bad_value,
+  bfd_error_file_truncated,
+  bfd_error_file_too_big,
+  bfd_error_on_input,
+  bfd_error_invalid_error_code
+}
+bfd_error_type;
+
+bfd_error_type bfd_get_error (void);
+
+void bfd_set_error (bfd_error_type error_tag, ...);
+
+const char *bfd_errmsg (bfd_error_type error_tag);
+
+void bfd_perror (const char *message);
+
+typedef void (*bfd_error_handler_type) (const char *, ...);
+
+bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
+
+void bfd_set_error_program_name (const char *);
+
+bfd_error_handler_type bfd_get_error_handler (void);
+
+long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
+
+long bfd_canonicalize_reloc
+   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
+
+void bfd_set_reloc
+   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
+
+bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
+
+int bfd_get_arch_size (bfd *abfd);
+
+int bfd_get_sign_extend_vma (bfd *abfd);
+
+bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
+
+unsigned int bfd_get_gp_size (bfd *abfd);
+
+void bfd_set_gp_size (bfd *abfd, unsigned int i);
+
+bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
+
+bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_header_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_header_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_merge_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
+
+#define bfd_set_private_flags(abfd, flags) \
+     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
+#define bfd_sizeof_headers(abfd, info) \
+       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, info))
+
+#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_nearest_line, \
+                 (abfd, sec, syms, off, file, func, line))
+
+#define bfd_find_line(abfd, syms, sym, file, line) \
+       BFD_SEND (abfd, _bfd_find_line, \
+                 (abfd, syms, sym, file, line))
+
+#define bfd_find_inliner_info(abfd, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_inliner_info, \
+                 (abfd, file, func, line))
+
+#define bfd_debug_info_start(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
+
+#define bfd_debug_info_end(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
+
+#define bfd_debug_info_accumulate(abfd, section) \
+       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
+
+#define bfd_stat_arch_elt(abfd, stat) \
+       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
+
+#define bfd_update_armap_timestamp(abfd) \
+       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
+
+#define bfd_set_arch_mach(abfd, arch, mach)\
+       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
+
+#define bfd_relax_section(abfd, section, link_info, again) \
+       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
+
+#define bfd_gc_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
+
+#define bfd_merge_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
+
+#define bfd_is_group_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))
+
+#define bfd_discard_group(abfd, sec) \
+       BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
+
+#define bfd_link_hash_table_create(abfd) \
+       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
+
+#define bfd_link_hash_table_free(abfd, hash) \
+       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
+
+#define bfd_link_add_symbols(abfd, info) \
+       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
+
+#define bfd_link_just_syms(abfd, sec, info) \
+       BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
+
+#define bfd_final_link(abfd, info) \
+       BFD_SEND (abfd, _bfd_final_link, (abfd, info))
+
+#define bfd_free_cached_info(abfd) \
+       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
+
+#define bfd_get_dynamic_symtab_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
+
+#define bfd_print_private_bfd_data(abfd, file)\
+       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
+
+#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
+
+#define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
+       BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
+                                                   dyncount, dynsyms, ret))
+
+#define bfd_get_dynamic_reloc_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
+
+#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
+
+extern bfd_byte *bfd_get_relocated_section_contents
+  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
+   bfd_boolean, asymbol **);
+
+bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
+
+struct bfd_preserve
+{
+  void *marker;
+  void *tdata;
+  flagword flags;
+  const struct bfd_arch_info *arch_info;
+  struct bfd_section *sections;
+  struct bfd_section *section_last;
+  unsigned int section_count;
+  struct bfd_hash_table section_htab;
+};
+
+bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_restore (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_finish (bfd *, struct bfd_preserve *);
+
+bfd_vma bfd_emul_get_maxpagesize (const char *);
+
+void bfd_emul_set_maxpagesize (const char *, bfd_vma);
+
+bfd_vma bfd_emul_get_commonpagesize (const char *);
+
+void bfd_emul_set_commonpagesize (const char *, bfd_vma);
+
+char *bfd_demangle (bfd *, const char *, int);
+
+/* Extracted from archive.c.  */
+symindex bfd_get_next_mapent
+   (bfd *abfd, symindex previous, carsym **sym);
+
+bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
+
+bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
+
+/* Extracted from corefile.c.  */
+const char *bfd_core_file_failing_command (bfd *abfd);
+
+int bfd_core_file_failing_signal (bfd *abfd);
+
+bfd_boolean core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+bfd_boolean generic_core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+/* Extracted from targets.c.  */
+#define BFD_SEND(bfd, message, arglist) \
+  ((*((bfd)->xvec->message)) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND
+#define BFD_SEND(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+    ((*((bfd)->xvec->message)) arglist) : \
+    (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND_FMT
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+   (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+
+enum bfd_flavour
+{
+  bfd_target_unknown_flavour,
+  bfd_target_aout_flavour,
+  bfd_target_coff_flavour,
+  bfd_target_ecoff_flavour,
+  bfd_target_xcoff_flavour,
+  bfd_target_elf_flavour,
+  bfd_target_ieee_flavour,
+  bfd_target_nlm_flavour,
+  bfd_target_oasys_flavour,
+  bfd_target_tekhex_flavour,
+  bfd_target_srec_flavour,
+  bfd_target_ihex_flavour,
+  bfd_target_som_flavour,
+  bfd_target_os9k_flavour,
+  bfd_target_versados_flavour,
+  bfd_target_msdos_flavour,
+  bfd_target_ovax_flavour,
+  bfd_target_evax_flavour,
+  bfd_target_mmo_flavour,
+  bfd_target_mach_o_flavour,
+  bfd_target_pef_flavour,
+  bfd_target_pef_xlib_flavour,
+  bfd_target_sym_flavour
+};
+
+enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+
+/* Forward declaration.  */
+typedef struct bfd_link_info _bfd_link_info;
+
+typedef struct bfd_target
+{
+  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
+  char *name;
+
+ /* The "flavour" of a back end is a general indication about
+    the contents of a file.  */
+  enum bfd_flavour flavour;
+
+  /* The order of bytes within the data area of a file.  */
+  enum bfd_endian byteorder;
+
+ /* The order of bytes within the header parts of a file.  */
+  enum bfd_endian header_byteorder;
+
+  /* A mask of all the flags which an executable may have set -
+     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  */
+  flagword object_flags;
+
+ /* A mask of all the flags which a section may have set - from
+    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  */
+  flagword section_flags;
+
+ /* The character normally found at the front of a symbol.
+    (if any), perhaps `_'.  */
+  char symbol_leading_char;
+
+ /* The pad character for file names within an archive header.  */
+  char ar_pad_char;
+
+  /* The maximum number of characters in an archive header.  */
+  unsigned short ar_max_namelen;
+
+  /* Entries for byte swapping for data. These are different from the
+     other entry points, since they don't take a BFD as the first argument.
+     Certain other handlers could do the same.  */
+  bfd_uint64_t   (*bfd_getx64) (const void *);
+  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
+  void           (*bfd_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_getx32) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
+  void           (*bfd_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_getx16) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
+  void           (*bfd_putx16) (bfd_vma, void *);
+
+  /* Byte swapping for the headers.  */
+  bfd_uint64_t   (*bfd_h_getx64) (const void *);
+  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
+  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_h_getx32) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
+  void           (*bfd_h_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_h_getx16) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
+  void           (*bfd_h_putx16) (bfd_vma, void *);
+
+  /* Format dependent routines: these are vectors of entry points
+     within the target vector structure, one for each format to check.  */
+
+  /* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  */
+  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
+
+  /* Set the format of a file being written.  */
+  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
+
+  /* Write cached information into a file being written, at <<bfd_close>>.  */
+  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
+
+
+  /* Generic entry points.  */
+#define BFD_JUMP_TABLE_GENERIC(NAME) \
+  NAME##_close_and_cleanup, \
+  NAME##_bfd_free_cached_info, \
+  NAME##_new_section_hook, \
+  NAME##_get_section_contents, \
+  NAME##_get_section_contents_in_window
+
+  /* Called when the BFD is being closed to do any necessary cleanup.  */
+  bfd_boolean (*_close_and_cleanup) (bfd *);
+  /* Ask the BFD to free all cached information.  */
+  bfd_boolean (*_bfd_free_cached_info) (bfd *);
+  /* Called when a new section is created.  */
+  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
+  /* Read the contents of a section.  */
+  bfd_boolean (*_bfd_get_section_contents)
+    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
+  bfd_boolean (*_bfd_get_section_contents_in_window)
+    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
+
+  /* Entry points to copy private data.  */
+#define BFD_JUMP_TABLE_COPY(NAME) \
+  NAME##_bfd_copy_private_bfd_data, \
+  NAME##_bfd_merge_private_bfd_data, \
+  _bfd_generic_init_private_section_data, \
+  NAME##_bfd_copy_private_section_data, \
+  NAME##_bfd_copy_private_symbol_data, \
+  NAME##_bfd_copy_private_header_data, \
+  NAME##_bfd_set_private_flags, \
+  NAME##_bfd_print_private_bfd_data
+
+  /* Called to copy BFD general private data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
+  /* Called to merge BFD general private data from one object file
+     to a common output file when linking.  */
+  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
+  /* Called to initialize BFD private section data from one object file
+     to another.  */
+#define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
+  BFD_SEND (obfd, _bfd_init_private_section_data, (ibfd, isec, obfd, osec, link_info))
+  bfd_boolean (*_bfd_init_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);
+  /* Called to copy BFD private section data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr);
+  /* Called to copy BFD private symbol data from one symbol
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_symbol_data)
+    (bfd *, asymbol *, bfd *, asymbol *);
+  /* Called to copy BFD private header data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_header_data)
+    (bfd *, bfd *);
+  /* Called to set private backend flags.  */
+  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
+
+  /* Called to print private BFD data.  */
+  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
+
+  /* Core file entry points.  */
+#define BFD_JUMP_TABLE_CORE(NAME) \
+  NAME##_core_file_failing_command, \
+  NAME##_core_file_failing_signal, \
+  NAME##_core_file_matches_executable_p
+
+  char *      (*_core_file_failing_command) (bfd *);
+  int         (*_core_file_failing_signal) (bfd *);
+  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
+
+  /* Archive entry points.  */
+#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
+  NAME##_slurp_armap, \
+  NAME##_slurp_extended_name_table, \
+  NAME##_construct_extended_name_table, \
+  NAME##_truncate_arname, \
+  NAME##_write_armap, \
+  NAME##_read_ar_hdr, \
+  NAME##_openr_next_archived_file, \
+  NAME##_get_elt_at_index, \
+  NAME##_generic_stat_arch_elt, \
+  NAME##_update_armap_timestamp
+
+  bfd_boolean (*_bfd_slurp_armap) (bfd *);
+  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
+  bfd_boolean (*_bfd_construct_extended_name_table)
+    (bfd *, char **, bfd_size_type *, const char **);
+  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
+  bfd_boolean (*write_armap)
+    (bfd *, unsigned int, struct orl *, unsigned int, int);
+  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
+  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
+#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
+  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
+  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
+  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
+
+  /* Entry points used for symbols.  */
+#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
+  NAME##_get_symtab_upper_bound, \
+  NAME##_canonicalize_symtab, \
+  NAME##_make_empty_symbol, \
+  NAME##_print_symbol, \
+  NAME##_get_symbol_info, \
+  NAME##_bfd_is_local_label_name, \
+  NAME##_bfd_is_target_special_symbol, \
+  NAME##_get_lineno, \
+  NAME##_find_nearest_line, \
+  _bfd_generic_find_line, \
+  NAME##_find_inliner_info, \
+  NAME##_bfd_make_debug_symbol, \
+  NAME##_read_minisymbols, \
+  NAME##_minisymbol_to_symbol
+
+  long        (*_bfd_get_symtab_upper_bound) (bfd *);
+  long        (*_bfd_canonicalize_symtab)
+    (bfd *, struct bfd_symbol **);
+  struct bfd_symbol *
+              (*_bfd_make_empty_symbol) (bfd *);
+  void        (*_bfd_print_symbol)
+    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+  void        (*_bfd_get_symbol_info)
+    (bfd *, struct bfd_symbol *, symbol_info *);
+#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
+  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
+  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
+  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
+  bfd_boolean (*_bfd_find_nearest_line)
+    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
+     const char **, const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_line)
+    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
+     const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_inliner_info)
+    (bfd *, const char **, const char **, unsigned int *);
+ /* Back-door to allow format-aware applications to create debug symbols
+    while using BFD for everything else.  Currently used by the assembler
+    when creating COFF files.  */
+  asymbol *   (*_bfd_make_debug_symbol)
+    (bfd *, void *, unsigned long size);
+#define bfd_read_minisymbols(b, d, m, s) \
+  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+  long        (*_read_minisymbols)
+    (bfd *, bfd_boolean, void **, unsigned int *);
+#define bfd_minisymbol_to_symbol(b, d, m, f) \
+  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+  asymbol *   (*_minisymbol_to_symbol)
+    (bfd *, bfd_boolean, const void *, asymbol *);
+
+  /* Routines for relocs.  */
+#define BFD_JUMP_TABLE_RELOCS(NAME) \
+  NAME##_get_reloc_upper_bound, \
+  NAME##_canonicalize_reloc, \
+  NAME##_bfd_reloc_type_lookup, \
+  NAME##_bfd_reloc_name_lookup
+
+  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+  long        (*_bfd_canonicalize_reloc)
+    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
+  /* See documentation on reloc types.  */
+  reloc_howto_type *
+              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
+  reloc_howto_type *
+              (*reloc_name_lookup) (bfd *, const char *);
+
+
+  /* Routines used when writing an object file.  */
+#define BFD_JUMP_TABLE_WRITE(NAME) \
+  NAME##_set_arch_mach, \
+  NAME##_set_section_contents
+
+  bfd_boolean (*_bfd_set_arch_mach)
+    (bfd *, enum bfd_architecture, unsigned long);
+  bfd_boolean (*_bfd_set_section_contents)
+    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
+
+  /* Routines used by the linker.  */
+#define BFD_JUMP_TABLE_LINK(NAME) \
+  NAME##_sizeof_headers, \
+  NAME##_bfd_get_relocated_section_contents, \
+  NAME##_bfd_relax_section, \
+  NAME##_bfd_link_hash_table_create, \
+  NAME##_bfd_link_hash_table_free, \
+  NAME##_bfd_link_add_symbols, \
+  NAME##_bfd_link_just_syms, \
+  NAME##_bfd_final_link, \
+  NAME##_bfd_link_split_section, \
+  NAME##_bfd_gc_sections, \
+  NAME##_bfd_merge_sections, \
+  NAME##_bfd_is_group_section, \
+  NAME##_bfd_discard_group, \
+  NAME##_section_already_linked \
+
+  int         (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
+  bfd_byte *  (*_bfd_get_relocated_section_contents)
+    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+     bfd_byte *, bfd_boolean, struct bfd_symbol **);
+
+  bfd_boolean (*_bfd_relax_section)
+    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
+
+  /* Create a hash table for the linker.  Different backends store
+     different information in this table.  */
+  struct bfd_link_hash_table *
+              (*_bfd_link_hash_table_create) (bfd *);
+
+  /* Release the memory associated with the linker hash table.  */
+  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
+
+  /* Add symbols from this object file into the hash table.  */
+  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
+
+  /* Indicate that we are only retrieving symbol values from this section.  */
+  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
+
+  /* Do a link based on the link_order structures attached to each
+     section of the BFD.  */
+  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
+
+  /* Should this section be split up into smaller pieces during linking.  */
+  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
+
+  /* Remove sections that are not referenced from the output.  */
+  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
+
+  /* Attempt to merge SEC_MERGE sections.  */
+  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
+
+  /* Is this section a member of a group?  */
+  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);
+
+  /* Discard members of a group.  */
+  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
+
+  /* Check if SEC has been already linked during a reloceatable or
+     final link.  */
+  void (*_section_already_linked) (bfd *, struct bfd_section *,
+                                   struct bfd_link_info *);
+
+  /* Routines to handle dynamic symbols and relocs.  */
+#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
+  NAME##_get_dynamic_symtab_upper_bound, \
+  NAME##_canonicalize_dynamic_symtab, \
+  NAME##_get_synthetic_symtab, \
+  NAME##_get_dynamic_reloc_upper_bound, \
+  NAME##_canonicalize_dynamic_reloc
+
+  /* Get the amount of memory required to hold the dynamic symbols.  */
+  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+  /* Read in the dynamic symbols.  */
+  long        (*_bfd_canonicalize_dynamic_symtab)
+    (bfd *, struct bfd_symbol **);
+  /* Create synthetized symbols.  */
+  long        (*_bfd_get_synthetic_symtab)
+    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
+     struct bfd_symbol **);
+  /* Get the amount of memory required to hold the dynamic relocs.  */
+  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+  /* Read in the dynamic relocs.  */
+  long        (*_bfd_canonicalize_dynamic_reloc)
+    (bfd *, arelent **, struct bfd_symbol **);
+
+  /* Opposite endian version of this target.  */
+  const struct bfd_target * alternative_target;
+
+  /* Data for use by back-end routines, which isn't
+     generic enough to belong in this structure.  */
+  const void *backend_data;
+
+} bfd_target;
+
+bfd_boolean bfd_set_default_target (const char *name);
+
+const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
+
+const char ** bfd_target_list (void);
+
+const bfd_target *bfd_search_for_target
+   (int (*search_func) (const bfd_target *, void *),
+    void *);
+
+/* Extracted from format.c.  */
+bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
+
+bfd_boolean bfd_check_format_matches
+   (bfd *abfd, bfd_format format, char ***matching);
+
+bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
+
+const char *bfd_format_string (bfd_format format);
+
+/* Extracted from linker.c.  */
+bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
+
+#define bfd_link_split_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))
+
+void bfd_section_already_linked (bfd *abfd, asection *sec,
+    struct bfd_link_info *info);
+
+#define bfd_section_already_linked(abfd, sec, info) \
+       BFD_SEND (abfd, _section_already_linked, (abfd, sec, info))
+
+/* Extracted from simple.c.  */
+bfd_byte *bfd_simple_get_relocated_section_contents
+   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
--- /dev/null
+++ b/bfd/doc/libbfd.h
@@ -0,0 +1,2074 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
+   generated from "libbfd-in.h", "init.c", "libbfd.c", "bfdio.c", 
+   "bfdwin.c", "cache.c", "reloc.c", "archures.c" and "elf.c".
+   Run "make headers" in your build bfd/ to regenerate.  */
+
+/* libbfd.h -- Declarations used by bfd library *implementation*.
+   (This include file is not for users of the library.)
+
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "hashtab.h"
+
+/* Align an address upward to a boundary, expressed as a number of bytes.
+   E.g. align to an 8-byte boundary with argument of 8.  Take care never
+   to wrap around if the address is within boundary-1 of the end of the
+   address space.  */
+#define BFD_ALIGN(this, boundary)					  \
+  ((((bfd_vma) (this) + (boundary) - 1) >= (bfd_vma) (this))		  \
+   ? (((bfd_vma) (this) + ((boundary) - 1)) & ~ (bfd_vma) ((boundary)-1)) \
+   : ~ (bfd_vma) 0)
+
+/* If you want to read and write large blocks, you might want to do it
+   in quanta of this amount */
+#define DEFAULT_BUFFERSIZE 8192
+
+/* Set a tdata field.  Can't use the other macros for this, since they
+   do casts, and casting to the left of assignment isn't portable.  */
+#define set_tdata(bfd, v) ((bfd)->tdata.any = (v))
+
+/* If BFD_IN_MEMORY is set for a BFD, then the iostream fields points
+   to an instance of this structure.  */
+
+struct bfd_in_memory
+{
+  /* Size of buffer.  */
+  bfd_size_type size;
+  /* Buffer holding contents of BFD.  */
+  bfd_byte *buffer;
+};
+
+struct section_hash_entry
+{
+  struct bfd_hash_entry root;
+  asection section;
+};
+
+/* tdata for an archive.  For an input archive, cache
+   needs to be free()'d.  For an output archive, symdefs do.  */
+
+struct artdata {
+  file_ptr first_file_filepos;
+  /* Speed up searching the armap */
+  htab_t cache;
+  bfd *archive_head;		/* Only interesting in output routines */
+  carsym *symdefs;		/* the symdef entries */
+  symindex symdef_count;	/* how many there are */
+  char *extended_names;		/* clever intel extension */
+  bfd_size_type extended_names_size; /* Size of extended names */
+  /* when more compilers are standard C, this can be a time_t */
+  long  armap_timestamp;	/* Timestamp value written into armap.
+				   This is used for BSD archives to check
+				   that the timestamp is recent enough
+				   for the BSD linker to not complain,
+				   just before we finish writing an
+				   archive.  */
+  file_ptr armap_datepos;	/* Position within archive to seek to
+				   rewrite the date field.  */
+  void *tdata;			/* Backend specific information.  */
+};
+
+#define bfd_ardata(bfd) ((bfd)->tdata.aout_ar_data)
+
+/* Goes in bfd's arelt_data slot */
+struct areltdata {
+  char * arch_header;		/* it's actually a string */
+  unsigned int parsed_size;	/* octets of filesize not including ar_hdr */
+  char *filename;		/* null-terminated */
+};
+
+#define arelt_size(bfd) (((struct areltdata *)((bfd)->arelt_data))->parsed_size)
+
+extern void *bfd_malloc
+  (bfd_size_type);
+extern void *bfd_realloc
+  (void *, bfd_size_type);
+extern void *bfd_zmalloc
+  (bfd_size_type);
+extern void *bfd_malloc2
+  (bfd_size_type, bfd_size_type);
+extern void *bfd_realloc2
+  (void *, bfd_size_type, bfd_size_type);
+extern void *bfd_zmalloc2
+  (bfd_size_type, bfd_size_type);
+
+extern void _bfd_default_error_handler (const char *s, ...);
+extern bfd_error_handler_type _bfd_error_handler;
+
+/* These routines allocate and free things on the BFD's objalloc.  */
+
+extern void *bfd_alloc
+  (bfd *, bfd_size_type);
+extern void *bfd_zalloc
+  (bfd *, bfd_size_type);
+extern void *bfd_alloc2
+  (bfd *, bfd_size_type, bfd_size_type);
+extern void *bfd_zalloc2
+  (bfd *, bfd_size_type, bfd_size_type);
+extern void bfd_release
+  (bfd *, void *);
+
+bfd * _bfd_create_empty_archive_element_shell
+  (bfd *obfd);
+bfd * _bfd_look_for_bfd_in_cache
+  (bfd *, file_ptr);
+bfd_boolean _bfd_add_bfd_to_archive_cache
+  (bfd *, file_ptr, bfd *);
+bfd_boolean _bfd_generic_mkarchive
+  (bfd *abfd);
+const bfd_target *bfd_generic_archive_p
+  (bfd *abfd);
+bfd_boolean bfd_slurp_armap
+  (bfd *abfd);
+bfd_boolean bfd_slurp_bsd_armap_f2
+  (bfd *abfd);
+#define bfd_slurp_bsd_armap bfd_slurp_armap
+#define bfd_slurp_coff_armap bfd_slurp_armap
+bfd_boolean _bfd_slurp_extended_name_table
+  (bfd *abfd);
+extern bfd_boolean _bfd_construct_extended_name_table
+  (bfd *, bfd_boolean, char **, bfd_size_type *);
+bfd_boolean _bfd_write_archive_contents
+  (bfd *abfd);
+bfd_boolean _bfd_compute_and_write_armap
+  (bfd *, unsigned int elength);
+bfd *_bfd_get_elt_at_filepos
+  (bfd *archive, file_ptr filepos);
+extern bfd *_bfd_generic_get_elt_at_index
+  (bfd *, symindex);
+bfd * _bfd_new_bfd
+  (void);
+void _bfd_delete_bfd
+  (bfd *);
+bfd_boolean _bfd_free_cached_info
+  (bfd *);
+
+bfd_boolean bfd_false
+  (bfd *ignore);
+bfd_boolean bfd_true
+  (bfd *ignore);
+void *bfd_nullvoidptr
+  (bfd *ignore);
+int bfd_0
+  (bfd *ignore);
+unsigned int bfd_0u
+  (bfd *ignore);
+long bfd_0l
+  (bfd *ignore);
+long _bfd_n1
+  (bfd *ignore);
+void bfd_void
+  (bfd *ignore);
+
+bfd *_bfd_new_bfd_contained_in
+  (bfd *);
+const bfd_target *_bfd_dummy_target
+  (bfd *abfd);
+
+void bfd_dont_truncate_arname
+  (bfd *abfd, const char *filename, char *hdr);
+void bfd_bsd_truncate_arname
+  (bfd *abfd, const char *filename, char *hdr);
+void bfd_gnu_truncate_arname
+  (bfd *abfd, const char *filename, char *hdr);
+
+bfd_boolean bsd_write_armap
+  (bfd *arch, unsigned int elength, struct orl *map, unsigned int orl_count,
+   int stridx);
+
+bfd_boolean coff_write_armap
+  (bfd *arch, unsigned int elength, struct orl *map, unsigned int orl_count,
+   int stridx);
+
+extern void *_bfd_generic_read_ar_hdr
+  (bfd *);
+extern void _bfd_ar_spacepad
+  (char *, size_t, const char *, long);
+
+extern void *_bfd_generic_read_ar_hdr_mag
+  (bfd *, const char *);
+
+bfd * bfd_generic_openr_next_archived_file
+  (bfd *archive, bfd *last_file);
+
+int bfd_generic_stat_arch_elt
+  (bfd *, struct stat *);
+
+#define _bfd_read_ar_hdr(abfd) \
+  BFD_SEND (abfd, _bfd_read_ar_hdr_fn, (abfd))
+
+/* Generic routines to use for BFD_JUMP_TABLE_GENERIC.  Use
+   BFD_JUMP_TABLE_GENERIC (_bfd_generic).  */
+
+#define _bfd_generic_close_and_cleanup bfd_true
+#define _bfd_generic_bfd_free_cached_info bfd_true
+extern bfd_boolean _bfd_generic_new_section_hook
+  (bfd *, asection *);
+extern bfd_boolean _bfd_generic_get_section_contents
+  (bfd *, asection *, void *, file_ptr, bfd_size_type);
+extern bfd_boolean _bfd_generic_get_section_contents_in_window
+  (bfd *, asection *, bfd_window *, file_ptr, bfd_size_type);
+
+/* Generic routines to use for BFD_JUMP_TABLE_COPY.  Use
+   BFD_JUMP_TABLE_COPY (_bfd_generic).  */
+
+#define _bfd_generic_bfd_copy_private_bfd_data \
+  ((bfd_boolean (*) (bfd *, bfd *)) bfd_true)
+#define _bfd_generic_bfd_merge_private_bfd_data \
+  ((bfd_boolean (*) (bfd *, bfd *)) bfd_true)
+#define _bfd_generic_bfd_set_private_flags \
+  ((bfd_boolean (*) (bfd *, flagword)) bfd_true)
+#define _bfd_generic_bfd_copy_private_section_data \
+  ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true)
+#define _bfd_generic_bfd_copy_private_symbol_data \
+  ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true)
+#define _bfd_generic_bfd_copy_private_header_data \
+  ((bfd_boolean (*) (bfd *, bfd *)) bfd_true)
+#define _bfd_generic_bfd_print_private_bfd_data \
+  ((bfd_boolean (*) (bfd *, void *)) bfd_true)
+
+extern bfd_boolean _bfd_generic_init_private_section_data
+  (bfd *, asection *, bfd *, asection *, struct bfd_link_info *);
+
+/* Routines to use for BFD_JUMP_TABLE_CORE when there is no core file
+   support.  Use BFD_JUMP_TABLE_CORE (_bfd_nocore).  */
+
+extern char *_bfd_nocore_core_file_failing_command
+  (bfd *);
+extern int _bfd_nocore_core_file_failing_signal
+  (bfd *);
+extern bfd_boolean _bfd_nocore_core_file_matches_executable_p
+  (bfd *, bfd *);
+
+/* Routines to use for BFD_JUMP_TABLE_ARCHIVE when there is no archive
+   file support.  Use BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive).  */
+
+#define _bfd_noarchive_slurp_armap bfd_false
+#define _bfd_noarchive_slurp_extended_name_table bfd_false
+#define _bfd_noarchive_construct_extended_name_table \
+  ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) \
+   bfd_false)
+#define _bfd_noarchive_truncate_arname \
+  ((void (*) (bfd *, const char *, char *)) bfd_void)
+#define _bfd_noarchive_write_armap \
+  ((bfd_boolean (*) (bfd *, unsigned int, struct orl *, unsigned int, int)) \
+   bfd_false)
+#define _bfd_noarchive_read_ar_hdr bfd_nullvoidptr
+#define _bfd_noarchive_openr_next_archived_file \
+  ((bfd *(*) (bfd *, bfd *)) bfd_nullvoidptr)
+#define _bfd_noarchive_get_elt_at_index \
+  ((bfd *(*) (bfd *, symindex)) bfd_nullvoidptr)
+#define _bfd_noarchive_generic_stat_arch_elt bfd_generic_stat_arch_elt
+#define _bfd_noarchive_update_armap_timestamp bfd_false
+
+/* Routines to use for BFD_JUMP_TABLE_ARCHIVE to get BSD style
+   archives.  Use BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_bsd).  */
+
+#define _bfd_archive_bsd_slurp_armap bfd_slurp_bsd_armap
+#define _bfd_archive_bsd_slurp_extended_name_table \
+  _bfd_slurp_extended_name_table
+extern bfd_boolean _bfd_archive_bsd_construct_extended_name_table
+  (bfd *, char **, bfd_size_type *, const char **);
+#define _bfd_archive_bsd_truncate_arname bfd_bsd_truncate_arname
+#define _bfd_archive_bsd_write_armap bsd_write_armap
+#define _bfd_archive_bsd_read_ar_hdr _bfd_generic_read_ar_hdr
+#define _bfd_archive_bsd_openr_next_archived_file \
+  bfd_generic_openr_next_archived_file
+#define _bfd_archive_bsd_get_elt_at_index _bfd_generic_get_elt_at_index
+#define _bfd_archive_bsd_generic_stat_arch_elt \
+  bfd_generic_stat_arch_elt
+extern bfd_boolean _bfd_archive_bsd_update_armap_timestamp
+  (bfd *);
+
+/* Routines to use for BFD_JUMP_TABLE_ARCHIVE to get COFF style
+   archives.  Use BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff).  */
+
+#define _bfd_archive_coff_slurp_armap bfd_slurp_coff_armap
+#define _bfd_archive_coff_slurp_extended_name_table \
+  _bfd_slurp_extended_name_table
+extern bfd_boolean _bfd_archive_coff_construct_extended_name_table
+  (bfd *, char **, bfd_size_type *, const char **);
+#define _bfd_archive_coff_truncate_arname bfd_dont_truncate_arname
+#define _bfd_archive_coff_write_armap coff_write_armap
+#define _bfd_archive_coff_read_ar_hdr _bfd_generic_read_ar_hdr
+#define _bfd_archive_coff_openr_next_archived_file \
+  bfd_generic_openr_next_archived_file
+#define _bfd_archive_coff_get_elt_at_index _bfd_generic_get_elt_at_index
+#define _bfd_archive_coff_generic_stat_arch_elt \
+  bfd_generic_stat_arch_elt
+#define _bfd_archive_coff_update_armap_timestamp bfd_true
+
+/* Routines to use for BFD_JUMP_TABLE_SYMBOLS where there is no symbol
+   support.  Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).  */
+
+#define _bfd_nosymbols_get_symtab_upper_bound _bfd_n1
+#define _bfd_nosymbols_canonicalize_symtab \
+  ((long (*) (bfd *, asymbol **)) _bfd_n1)
+#define _bfd_nosymbols_make_empty_symbol _bfd_generic_make_empty_symbol
+#define _bfd_nosymbols_print_symbol \
+  ((void (*) (bfd *, void *, asymbol *, bfd_print_symbol_type)) bfd_void)
+#define _bfd_nosymbols_get_symbol_info \
+  ((void (*) (bfd *, asymbol *, symbol_info *)) bfd_void)
+#define _bfd_nosymbols_bfd_is_local_label_name \
+  ((bfd_boolean (*) (bfd *, const char *)) bfd_false)
+#define _bfd_nosymbols_bfd_is_target_special_symbol \
+  ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
+#define _bfd_nosymbols_get_lineno \
+  ((alent *(*) (bfd *, asymbol *)) bfd_nullvoidptr)
+#define _bfd_nosymbols_find_nearest_line \
+  ((bfd_boolean (*) (bfd *, asection *, asymbol **, bfd_vma, const char **, \
+		     const char **, unsigned int *)) \
+   bfd_false)
+#define _bfd_nosymbols_find_inliner_info \
+  ((bfd_boolean (*) (bfd *, const char **, const char **, unsigned int *)) \
+   bfd_false)
+#define _bfd_nosymbols_bfd_make_debug_symbol \
+  ((asymbol *(*) (bfd *, void *, unsigned long)) bfd_nullvoidptr)
+#define _bfd_nosymbols_read_minisymbols \
+  ((long (*) (bfd *, bfd_boolean, void **, unsigned int *)) _bfd_n1)
+#define _bfd_nosymbols_minisymbol_to_symbol \
+  ((asymbol *(*) (bfd *, bfd_boolean, const void *, asymbol *)) \
+   bfd_nullvoidptr)
+
+/* Routines to use for BFD_JUMP_TABLE_RELOCS when there is no reloc
+   support.  Use BFD_JUMP_TABLE_RELOCS (_bfd_norelocs).  */
+
+extern long _bfd_norelocs_get_reloc_upper_bound (bfd *, asection *);
+extern long _bfd_norelocs_canonicalize_reloc (bfd *, asection *,
+					      arelent **, asymbol **);
+#define _bfd_norelocs_bfd_reloc_type_lookup \
+  ((reloc_howto_type *(*) (bfd *, bfd_reloc_code_real_type)) bfd_nullvoidptr)
+#define _bfd_norelocs_bfd_reloc_name_lookup \
+  ((reloc_howto_type *(*) (bfd *, const char *)) bfd_nullvoidptr)
+
+/* Routines to use for BFD_JUMP_TABLE_WRITE for targets which may not
+   be written.  Use BFD_JUMP_TABLE_WRITE (_bfd_nowrite).  */
+
+#define _bfd_nowrite_set_arch_mach \
+  ((bfd_boolean (*) (bfd *, enum bfd_architecture, unsigned long)) \
+   bfd_false)
+#define _bfd_nowrite_set_section_contents \
+  ((bfd_boolean (*) (bfd *, asection *, const void *, file_ptr, bfd_size_type)) \
+   bfd_false)
+
+/* Generic routines to use for BFD_JUMP_TABLE_WRITE.  Use
+   BFD_JUMP_TABLE_WRITE (_bfd_generic).  */
+
+#define _bfd_generic_set_arch_mach bfd_default_set_arch_mach
+extern bfd_boolean _bfd_generic_set_section_contents
+  (bfd *, asection *, const void *, file_ptr, bfd_size_type);
+
+/* Routines to use for BFD_JUMP_TABLE_LINK for targets which do not
+   support linking.  Use BFD_JUMP_TABLE_LINK (_bfd_nolink).  */
+
+#define _bfd_nolink_sizeof_headers \
+  ((int (*) (bfd *, struct bfd_link_info *)) bfd_0)
+#define _bfd_nolink_bfd_get_relocated_section_contents \
+  ((bfd_byte *(*) (bfd *, struct bfd_link_info *, struct bfd_link_order *, \
+		   bfd_byte *, bfd_boolean, asymbol **)) \
+   bfd_nullvoidptr)
+#define _bfd_nolink_bfd_relax_section \
+  ((bfd_boolean (*) \
+    (bfd *, asection *, struct bfd_link_info *, bfd_boolean *)) \
+   bfd_false)
+#define _bfd_nolink_bfd_gc_sections \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) \
+   bfd_false)
+#define _bfd_nolink_bfd_merge_sections \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) \
+   bfd_false)
+#define _bfd_nolink_bfd_is_group_section \
+  ((bfd_boolean (*) (bfd *, const struct bfd_section *)) \
+   bfd_false)
+#define _bfd_nolink_bfd_discard_group \
+  ((bfd_boolean (*) (bfd *, struct bfd_section *)) \
+   bfd_false)
+#define _bfd_nolink_bfd_link_hash_table_create \
+  ((struct bfd_link_hash_table *(*) (bfd *)) bfd_nullvoidptr)
+#define _bfd_nolink_bfd_link_hash_table_free \
+  ((void (*) (struct bfd_link_hash_table *)) bfd_void)
+#define _bfd_nolink_bfd_link_add_symbols \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) bfd_false)
+#define _bfd_nolink_bfd_link_just_syms \
+  ((void (*) (asection *, struct bfd_link_info *)) bfd_void)
+#define _bfd_nolink_bfd_final_link \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) bfd_false)
+#define _bfd_nolink_bfd_link_split_section \
+  ((bfd_boolean (*) (bfd *, struct bfd_section *)) bfd_false)
+#define _bfd_nolink_section_already_linked \
+  ((void (*) (bfd *, struct bfd_section *, struct bfd_link_info *)) bfd_void)
+
+/* Routines to use for BFD_JUMP_TABLE_DYNAMIC for targets which do not
+   have dynamic symbols or relocs.  Use BFD_JUMP_TABLE_DYNAMIC
+   (_bfd_nodynamic).  */
+
+#define _bfd_nodynamic_get_dynamic_symtab_upper_bound _bfd_n1
+#define _bfd_nodynamic_canonicalize_dynamic_symtab \
+  ((long (*) (bfd *, asymbol **)) _bfd_n1)
+#define _bfd_nodynamic_get_synthetic_symtab \
+  ((long (*) (bfd *, long, asymbol **, long, asymbol **, asymbol **)) _bfd_n1)
+#define _bfd_nodynamic_get_dynamic_reloc_upper_bound _bfd_n1
+#define _bfd_nodynamic_canonicalize_dynamic_reloc \
+  ((long (*) (bfd *, arelent **, asymbol **)) _bfd_n1)
+
+/* Generic routine to determine of the given symbol is a local
+   label.  */
+extern bfd_boolean bfd_generic_is_local_label_name
+  (bfd *, const char *);
+
+/* Generic minisymbol routines.  */
+extern long _bfd_generic_read_minisymbols
+  (bfd *, bfd_boolean, void **, unsigned int *);
+extern asymbol *_bfd_generic_minisymbol_to_symbol
+  (bfd *, bfd_boolean, const void *, asymbol *);
+
+/* Find the nearest line using .stab/.stabstr sections.  */
+extern bfd_boolean _bfd_stab_section_find_nearest_line
+  (bfd *, asymbol **, asection *, bfd_vma, bfd_boolean *,
+   const char **, const char **, unsigned int *, void **);
+
+/* Find the nearest line using DWARF 1 debugging information.  */
+extern bfd_boolean _bfd_dwarf1_find_nearest_line
+  (bfd *, asection *, asymbol **, bfd_vma, const char **,
+   const char **, unsigned int *);
+
+/* Find the nearest line using DWARF 2 debugging information.  */
+extern bfd_boolean _bfd_dwarf2_find_nearest_line
+  (bfd *, asection *, asymbol **, bfd_vma, const char **, const char **,
+   unsigned int *, unsigned int, void **);
+
+/* Find the line using DWARF 2 debugging information.  */
+extern bfd_boolean _bfd_dwarf2_find_line
+  (bfd *, asymbol **, asymbol *, const char **,
+   unsigned int *, unsigned int, void **);
+
+bfd_boolean _bfd_generic_find_line
+  (bfd *, asymbol **, asymbol *, const char **, unsigned int *);
+
+/* Find inliner info after calling bfd_find_nearest_line. */
+extern bfd_boolean _bfd_dwarf2_find_inliner_info
+  (bfd *, const char **, const char **, unsigned int *, void **);
+  
+/* Create a new section entry.  */
+extern struct bfd_hash_entry *bfd_section_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+
+/* A routine to create entries for a bfd_link_hash_table.  */
+extern struct bfd_hash_entry *_bfd_link_hash_newfunc
+  (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
+   const char *string);
+
+/* Initialize a bfd_link_hash_table.  */
+extern bfd_boolean _bfd_link_hash_table_init
+  (struct bfd_link_hash_table *, bfd *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int);
+
+/* Generic link hash table creation routine.  */
+extern struct bfd_link_hash_table *_bfd_generic_link_hash_table_create
+  (bfd *);
+
+/* Generic link hash table destruction routine.  */
+extern void _bfd_generic_link_hash_table_free
+  (struct bfd_link_hash_table *);
+
+/* Generic add symbol routine.  */
+extern bfd_boolean _bfd_generic_link_add_symbols
+  (bfd *, struct bfd_link_info *);
+
+/* Generic add symbol routine.  This version is used by targets for
+   which the linker must collect constructors and destructors by name,
+   as the collect2 program does.  */
+extern bfd_boolean _bfd_generic_link_add_symbols_collect
+  (bfd *, struct bfd_link_info *);
+
+/* Generic archive add symbol routine.  */
+extern bfd_boolean _bfd_generic_link_add_archive_symbols
+  (bfd *, struct bfd_link_info *,
+   bfd_boolean (*) (bfd *, struct bfd_link_info *, bfd_boolean *));
+
+/* Forward declaration to avoid prototype errors.  */
+typedef struct bfd_link_hash_entry _bfd_link_hash_entry;
+
+/* Generic routine to add a single symbol.  */
+extern bfd_boolean _bfd_generic_link_add_one_symbol
+  (struct bfd_link_info *, bfd *, const char *name, flagword,
+   asection *, bfd_vma, const char *, bfd_boolean copy,
+   bfd_boolean constructor, struct bfd_link_hash_entry **);
+
+/* Generic routine to mark section as supplying symbols only.  */
+extern void _bfd_generic_link_just_syms
+  (asection *, struct bfd_link_info *);
+
+/* Generic link routine.  */
+extern bfd_boolean _bfd_generic_final_link
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean _bfd_generic_link_split_section
+  (bfd *, struct bfd_section *);
+
+extern void _bfd_generic_section_already_linked
+  (bfd *, struct bfd_section *, struct bfd_link_info *);
+
+/* Generic reloc_link_order processing routine.  */
+extern bfd_boolean _bfd_generic_reloc_link_order
+  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
+
+/* Default link order processing routine.  */
+extern bfd_boolean _bfd_default_link_order
+  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
+
+/* Count the number of reloc entries in a link order list.  */
+extern unsigned int _bfd_count_link_order_relocs
+  (struct bfd_link_order *);
+
+/* Final link relocation routine.  */
+extern bfd_reloc_status_type _bfd_final_link_relocate
+  (reloc_howto_type *, bfd *, asection *, bfd_byte *,
+   bfd_vma, bfd_vma, bfd_vma);
+
+/* Relocate a particular location by a howto and a value.  */
+extern bfd_reloc_status_type _bfd_relocate_contents
+  (reloc_howto_type *, bfd *, bfd_vma, bfd_byte *);
+
+/* Clear a given location using a given howto.  */
+extern void _bfd_clear_contents (reloc_howto_type *howto, bfd *input_bfd,
+				 bfd_byte *location);
+
+/* Link stabs in sections in the first pass.  */
+
+extern bfd_boolean _bfd_link_section_stabs
+  (bfd *, struct stab_info *, asection *, asection *, void **,
+   bfd_size_type *);
+
+/* Eliminate stabs for discarded functions and symbols.  */
+extern bfd_boolean _bfd_discard_section_stabs
+  (bfd *, asection *, void *, bfd_boolean (*) (bfd_vma, void *), void *);
+
+/* Write out the .stab section when linking stabs in sections.  */
+
+extern bfd_boolean _bfd_write_section_stabs
+  (bfd *, struct stab_info *, asection *, void **, bfd_byte *);
+
+/* Write out the .stabstr string table when linking stabs in sections.  */
+
+extern bfd_boolean _bfd_write_stab_strings
+  (bfd *, struct stab_info *);
+
+/* Find an offset within a .stab section when linking stabs in
+   sections.  */
+
+extern bfd_vma _bfd_stab_section_offset
+  (asection *, void *, bfd_vma);
+
+/* Register a SEC_MERGE section as a candidate for merging.  */
+
+extern bfd_boolean _bfd_add_merge_section
+  (bfd *, void **, asection *, void **);
+
+/* Attempt to merge SEC_MERGE sections.  */
+
+extern bfd_boolean _bfd_merge_sections
+  (bfd *, struct bfd_link_info *, void *, void (*) (bfd *, asection *));
+
+/* Write out a merged section.  */
+
+extern bfd_boolean _bfd_write_merged_section
+  (bfd *, asection *, void *);
+
+/* Find an offset within a modified SEC_MERGE section.  */
+
+extern bfd_vma _bfd_merged_section_offset
+  (bfd *, asection **, void *, bfd_vma);
+
+/* Create a string table.  */
+extern struct bfd_strtab_hash *_bfd_stringtab_init
+  (void);
+
+/* Create an XCOFF .debug section style string table.  */
+extern struct bfd_strtab_hash *_bfd_xcoff_stringtab_init
+  (void);
+
+/* Free a string table.  */
+extern void _bfd_stringtab_free
+  (struct bfd_strtab_hash *);
+
+/* Get the size of a string table.  */
+extern bfd_size_type _bfd_stringtab_size
+  (struct bfd_strtab_hash *);
+
+/* Add a string to a string table.  */
+extern bfd_size_type _bfd_stringtab_add
+  (struct bfd_strtab_hash *, const char *, bfd_boolean hash, bfd_boolean copy);
+
+/* Write out a string table.  */
+extern bfd_boolean _bfd_stringtab_emit
+  (bfd *, struct bfd_strtab_hash *);
+
+/* Check that endianness of input and output file match.  */
+extern bfd_boolean _bfd_generic_verify_endian_match
+  (bfd *, bfd *);
+
+/* Macros to tell if bfds are read or write enabled.
+
+   Note that bfds open for read may be scribbled into if the fd passed
+   to bfd_fdopenr is actually open both for read and write
+   simultaneously.  However an output bfd will never be open for
+   read.  Therefore sometimes you want to check bfd_read_p or
+   !bfd_read_p, and only sometimes bfd_write_p.
+*/
+
+#define	bfd_read_p(abfd) \
+  ((abfd)->direction == read_direction || (abfd)->direction == both_direction)
+#define	bfd_write_p(abfd) \
+  ((abfd)->direction == write_direction || (abfd)->direction == both_direction)
+
+void bfd_assert
+  (const char*,int);
+
+#define BFD_ASSERT(x) \
+  do { if (!(x)) bfd_assert(__FILE__,__LINE__); } while (0)
+
+#define BFD_FAIL() \
+  do { bfd_assert(__FILE__,__LINE__); } while (0)
+
+extern void _bfd_abort
+  (const char *, int, const char *) ATTRIBUTE_NORETURN;
+
+/* if gcc >= 2.6, we can give a function name, too */
+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6)
+#define __PRETTY_FUNCTION__  ((char *) NULL)
+#endif
+
+#undef abort
+#define abort() _bfd_abort (__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+/* Manipulate a system FILE but using BFD's "file_ptr", rather than
+   the system "off_t" or "off64_t", as the offset.  */
+extern file_ptr real_ftell (FILE *file);
+extern int real_fseek (FILE *file, file_ptr offset, int whence);
+extern FILE *real_fopen (const char *filename, const char *modes);
+
+/* List of supported target vectors, and the default vector (if
+   bfd_default_vector[0] is NULL, there is no default).  */
+extern const bfd_target * const *bfd_target_vector;
+extern const bfd_target *bfd_default_vector[];
+
+/* List of associated target vectors.  */
+extern const bfd_target * const *bfd_associated_vector;
+
+/* Functions shared by the ECOFF and MIPS ELF backends, which have no
+   other common header files.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct ecoff_find_line;
+#endif
+
+extern bfd_boolean _bfd_ecoff_locate_line
+  (bfd *, asection *, bfd_vma, struct ecoff_debug_info * const,
+   const struct ecoff_debug_swap * const, struct ecoff_find_line *,
+   const char **, const char **, unsigned int *);
+extern bfd_boolean _bfd_ecoff_get_accumulated_pdr
+  (void *, bfd_byte *);
+extern bfd_boolean _bfd_ecoff_get_accumulated_sym
+  (void *, bfd_byte *);
+extern bfd_boolean _bfd_ecoff_get_accumulated_ss
+  (void *, bfd_byte *);
+
+extern bfd_vma _bfd_get_gp_value
+  (bfd *);
+extern void _bfd_set_gp_value
+  (bfd *, bfd_vma);
+
+/* Function shared by the COFF and ELF SH backends, which have no
+   other common header files.  */
+
+#ifndef _bfd_sh_align_load_span
+extern bfd_boolean _bfd_sh_align_load_span
+  (bfd *, asection *, bfd_byte *,
+   bfd_boolean (*) (bfd *, asection *, void *, bfd_byte *, bfd_vma),
+   void *, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *);
+#endif
+
+/* This is the shape of the elements inside the already_linked hash
+   table. It maps a name onto a list of already_linked elements with
+   the same name.  */
+
+struct bfd_section_already_linked_hash_entry
+{
+  struct bfd_hash_entry root;
+  struct bfd_section_already_linked *entry;
+};
+
+struct bfd_section_already_linked
+{
+  struct bfd_section_already_linked *next;
+  asection *sec;
+};
+
+extern struct bfd_section_already_linked_hash_entry *
+  bfd_section_already_linked_table_lookup (const char *);
+extern bfd_boolean bfd_section_already_linked_table_insert
+  (struct bfd_section_already_linked_hash_entry *, asection *);
+extern void bfd_section_already_linked_table_traverse
+  (bfd_boolean (*) (struct bfd_section_already_linked_hash_entry *,
+		    void *), void *);
+
+extern bfd_vma read_unsigned_leb128 (bfd *, bfd_byte *, unsigned int *);
+extern bfd_signed_vma read_signed_leb128 (bfd *, bfd_byte *, unsigned int *);
+
+/* Extracted from init.c.  */
+/* Extracted from libbfd.c.  */
+bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
+
+unsigned int bfd_log2 (bfd_vma x);
+
+/* Extracted from bfdio.c.  */
+struct bfd_iovec
+{
+  /* To avoid problems with macros, a "b" rather than "f"
+     prefix is prepended to each method name.  */
+  /* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching
+     bytes starting at PTR.  Return the number of bytes actually
+     transfered (a read past end-of-file returns less than NBYTES),
+     or -1 (setting <<bfd_error>>) if an error occurs.  */
+  file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
+  file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
+                      file_ptr nbytes);
+  /* Return the current IOSTREAM file offset, or -1 (setting <<bfd_error>>
+     if an error occurs.  */
+  file_ptr (*btell) (struct bfd *abfd);
+  /* For the following, on successful completion a value of 0 is returned.
+     Otherwise, a value of -1 is returned (and  <<bfd_error>> is set).  */
+  int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
+  int (*bclose) (struct bfd *abfd);
+  int (*bflush) (struct bfd *abfd);
+  int (*bstat) (struct bfd *abfd, struct stat *sb);
+};
+/* Extracted from bfdwin.c.  */
+struct _bfd_window_internal {
+  struct _bfd_window_internal *next;
+  void *data;
+  bfd_size_type size;
+  int refcount : 31;           /* should be enough...  */
+  unsigned mapped : 1;         /* 1 = mmap, 0 = malloc */
+};
+/* Extracted from cache.c.  */
+bfd_boolean bfd_cache_init (bfd *abfd);
+
+bfd_boolean bfd_cache_close (bfd *abfd);
+
+FILE* bfd_open_file (bfd *abfd);
+
+/* Extracted from reloc.c.  */
+#ifdef _BFD_MAKE_TABLE_bfd_reloc_code_real
+
+static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
+
+  "BFD_RELOC_64",
+  "BFD_RELOC_32",
+  "BFD_RELOC_26",
+  "BFD_RELOC_24",
+  "BFD_RELOC_16",
+  "BFD_RELOC_14",
+  "BFD_RELOC_8",
+  "BFD_RELOC_64_PCREL",
+  "BFD_RELOC_32_PCREL",
+  "BFD_RELOC_24_PCREL",
+  "BFD_RELOC_16_PCREL",
+  "BFD_RELOC_12_PCREL",
+  "BFD_RELOC_8_PCREL",
+  "BFD_RELOC_32_SECREL",
+  "BFD_RELOC_32_GOT_PCREL",
+  "BFD_RELOC_16_GOT_PCREL",
+  "BFD_RELOC_8_GOT_PCREL",
+  "BFD_RELOC_32_GOTOFF",
+  "BFD_RELOC_16_GOTOFF",
+  "BFD_RELOC_LO16_GOTOFF",
+  "BFD_RELOC_HI16_GOTOFF",
+  "BFD_RELOC_HI16_S_GOTOFF",
+  "BFD_RELOC_8_GOTOFF",
+  "BFD_RELOC_64_PLT_PCREL",
+  "BFD_RELOC_32_PLT_PCREL",
+  "BFD_RELOC_24_PLT_PCREL",
+  "BFD_RELOC_16_PLT_PCREL",
+  "BFD_RELOC_8_PLT_PCREL",
+  "BFD_RELOC_64_PLTOFF",
+  "BFD_RELOC_32_PLTOFF",
+  "BFD_RELOC_16_PLTOFF",
+  "BFD_RELOC_LO16_PLTOFF",
+  "BFD_RELOC_HI16_PLTOFF",
+  "BFD_RELOC_HI16_S_PLTOFF",
+  "BFD_RELOC_8_PLTOFF",
+  "BFD_RELOC_68K_GLOB_DAT",
+  "BFD_RELOC_68K_JMP_SLOT",
+  "BFD_RELOC_68K_RELATIVE",
+  "BFD_RELOC_32_BASEREL",
+  "BFD_RELOC_16_BASEREL",
+  "BFD_RELOC_LO16_BASEREL",
+  "BFD_RELOC_HI16_BASEREL",
+  "BFD_RELOC_HI16_S_BASEREL",
+  "BFD_RELOC_8_BASEREL",
+  "BFD_RELOC_RVA",
+  "BFD_RELOC_8_FFnn",
+  "BFD_RELOC_32_PCREL_S2",
+  "BFD_RELOC_16_PCREL_S2",
+  "BFD_RELOC_23_PCREL_S2",
+  "BFD_RELOC_HI22",
+  "BFD_RELOC_LO10",
+  "BFD_RELOC_GPREL16",
+  "BFD_RELOC_GPREL32",
+  "BFD_RELOC_I960_CALLJ",
+  "BFD_RELOC_NONE",
+  "BFD_RELOC_SPARC_WDISP22",
+  "BFD_RELOC_SPARC22",
+  "BFD_RELOC_SPARC13",
+  "BFD_RELOC_SPARC_GOT10",
+  "BFD_RELOC_SPARC_GOT13",
+  "BFD_RELOC_SPARC_GOT22",
+  "BFD_RELOC_SPARC_PC10",
+  "BFD_RELOC_SPARC_PC22",
+  "BFD_RELOC_SPARC_WPLT30",
+  "BFD_RELOC_SPARC_COPY",
+  "BFD_RELOC_SPARC_GLOB_DAT",
+  "BFD_RELOC_SPARC_JMP_SLOT",
+  "BFD_RELOC_SPARC_RELATIVE",
+  "BFD_RELOC_SPARC_UA16",
+  "BFD_RELOC_SPARC_UA32",
+  "BFD_RELOC_SPARC_UA64",
+  "BFD_RELOC_SPARC_BASE13",
+  "BFD_RELOC_SPARC_BASE22",
+  "BFD_RELOC_SPARC_10",
+  "BFD_RELOC_SPARC_11",
+  "BFD_RELOC_SPARC_OLO10",
+  "BFD_RELOC_SPARC_HH22",
+  "BFD_RELOC_SPARC_HM10",
+  "BFD_RELOC_SPARC_LM22",
+  "BFD_RELOC_SPARC_PC_HH22",
+  "BFD_RELOC_SPARC_PC_HM10",
+  "BFD_RELOC_SPARC_PC_LM22",
+  "BFD_RELOC_SPARC_WDISP16",
+  "BFD_RELOC_SPARC_WDISP19",
+  "BFD_RELOC_SPARC_7",
+  "BFD_RELOC_SPARC_6",
+  "BFD_RELOC_SPARC_5",
+  "BFD_RELOC_SPARC_PLT32",
+  "BFD_RELOC_SPARC_PLT64",
+  "BFD_RELOC_SPARC_HIX22",
+  "BFD_RELOC_SPARC_LOX10",
+  "BFD_RELOC_SPARC_H44",
+  "BFD_RELOC_SPARC_M44",
+  "BFD_RELOC_SPARC_L44",
+  "BFD_RELOC_SPARC_REGISTER",
+  "BFD_RELOC_SPARC_REV32",
+  "BFD_RELOC_SPARC_TLS_GD_HI22",
+  "BFD_RELOC_SPARC_TLS_GD_LO10",
+  "BFD_RELOC_SPARC_TLS_GD_ADD",
+  "BFD_RELOC_SPARC_TLS_GD_CALL",
+  "BFD_RELOC_SPARC_TLS_LDM_HI22",
+  "BFD_RELOC_SPARC_TLS_LDM_LO10",
+  "BFD_RELOC_SPARC_TLS_LDM_ADD",
+  "BFD_RELOC_SPARC_TLS_LDM_CALL",
+  "BFD_RELOC_SPARC_TLS_LDO_HIX22",
+  "BFD_RELOC_SPARC_TLS_LDO_LOX10",
+  "BFD_RELOC_SPARC_TLS_LDO_ADD",
+  "BFD_RELOC_SPARC_TLS_IE_HI22",
+  "BFD_RELOC_SPARC_TLS_IE_LO10",
+  "BFD_RELOC_SPARC_TLS_IE_LD",
+  "BFD_RELOC_SPARC_TLS_IE_LDX",
+  "BFD_RELOC_SPARC_TLS_IE_ADD",
+  "BFD_RELOC_SPARC_TLS_LE_HIX22",
+  "BFD_RELOC_SPARC_TLS_LE_LOX10",
+  "BFD_RELOC_SPARC_TLS_DTPMOD32",
+  "BFD_RELOC_SPARC_TLS_DTPMOD64",
+  "BFD_RELOC_SPARC_TLS_DTPOFF32",
+  "BFD_RELOC_SPARC_TLS_DTPOFF64",
+  "BFD_RELOC_SPARC_TLS_TPOFF32",
+  "BFD_RELOC_SPARC_TLS_TPOFF64",
+  "BFD_RELOC_SPU_IMM7",
+  "BFD_RELOC_SPU_IMM8",
+  "BFD_RELOC_SPU_IMM10",
+  "BFD_RELOC_SPU_IMM10W",
+  "BFD_RELOC_SPU_IMM16",
+  "BFD_RELOC_SPU_IMM16W",
+  "BFD_RELOC_SPU_IMM18",
+  "BFD_RELOC_SPU_PCREL9a",
+  "BFD_RELOC_SPU_PCREL9b",
+  "BFD_RELOC_SPU_PCREL16",
+  "BFD_RELOC_SPU_LO16",
+  "BFD_RELOC_SPU_HI16",
+  "BFD_RELOC_SPU_PPU32",
+  "BFD_RELOC_SPU_PPU64",
+  "BFD_RELOC_ALPHA_GPDISP_HI16",
+  "BFD_RELOC_ALPHA_GPDISP_LO16",
+  "BFD_RELOC_ALPHA_GPDISP",
+  "BFD_RELOC_ALPHA_LITERAL",
+  "BFD_RELOC_ALPHA_ELF_LITERAL",
+  "BFD_RELOC_ALPHA_LITUSE",
+  "BFD_RELOC_ALPHA_HINT",
+  "BFD_RELOC_ALPHA_LINKAGE",
+  "BFD_RELOC_ALPHA_CODEADDR",
+  "BFD_RELOC_ALPHA_GPREL_HI16",
+  "BFD_RELOC_ALPHA_GPREL_LO16",
+  "BFD_RELOC_ALPHA_BRSGP",
+  "BFD_RELOC_ALPHA_TLSGD",
+  "BFD_RELOC_ALPHA_TLSLDM",
+  "BFD_RELOC_ALPHA_DTPMOD64",
+  "BFD_RELOC_ALPHA_GOTDTPREL16",
+  "BFD_RELOC_ALPHA_DTPREL64",
+  "BFD_RELOC_ALPHA_DTPREL_HI16",
+  "BFD_RELOC_ALPHA_DTPREL_LO16",
+  "BFD_RELOC_ALPHA_DTPREL16",
+  "BFD_RELOC_ALPHA_GOTTPREL16",
+  "BFD_RELOC_ALPHA_TPREL64",
+  "BFD_RELOC_ALPHA_TPREL_HI16",
+  "BFD_RELOC_ALPHA_TPREL_LO16",
+  "BFD_RELOC_ALPHA_TPREL16",
+  "BFD_RELOC_MIPS_JMP",
+  "BFD_RELOC_MIPS16_JMP",
+  "BFD_RELOC_MIPS16_GPREL",
+  "BFD_RELOC_HI16",
+  "BFD_RELOC_HI16_S",
+  "BFD_RELOC_LO16",
+  "BFD_RELOC_HI16_PCREL",
+  "BFD_RELOC_HI16_S_PCREL",
+  "BFD_RELOC_LO16_PCREL",
+  "BFD_RELOC_MIPS16_HI16",
+  "BFD_RELOC_MIPS16_HI16_S",
+  "BFD_RELOC_MIPS16_LO16",
+  "BFD_RELOC_MIPS_LITERAL",
+  "BFD_RELOC_MIPS_GOT16",
+  "BFD_RELOC_MIPS_CALL16",
+  "BFD_RELOC_MIPS_GOT_HI16",
+  "BFD_RELOC_MIPS_GOT_LO16",
+  "BFD_RELOC_MIPS_CALL_HI16",
+  "BFD_RELOC_MIPS_CALL_LO16",
+  "BFD_RELOC_MIPS_SUB",
+  "BFD_RELOC_MIPS_GOT_PAGE",
+  "BFD_RELOC_MIPS_GOT_OFST",
+  "BFD_RELOC_MIPS_GOT_DISP",
+  "BFD_RELOC_MIPS_SHIFT5",
+  "BFD_RELOC_MIPS_SHIFT6",
+  "BFD_RELOC_MIPS_INSERT_A",
+  "BFD_RELOC_MIPS_INSERT_B",
+  "BFD_RELOC_MIPS_DELETE",
+  "BFD_RELOC_MIPS_HIGHEST",
+  "BFD_RELOC_MIPS_HIGHER",
+  "BFD_RELOC_MIPS_SCN_DISP",
+  "BFD_RELOC_MIPS_REL16",
+  "BFD_RELOC_MIPS_RELGOT",
+  "BFD_RELOC_MIPS_JALR",
+  "BFD_RELOC_MIPS_TLS_DTPMOD32",
+  "BFD_RELOC_MIPS_TLS_DTPREL32",
+  "BFD_RELOC_MIPS_TLS_DTPMOD64",
+  "BFD_RELOC_MIPS_TLS_DTPREL64",
+  "BFD_RELOC_MIPS_TLS_GD",
+  "BFD_RELOC_MIPS_TLS_LDM",
+  "BFD_RELOC_MIPS_TLS_DTPREL_HI16",
+  "BFD_RELOC_MIPS_TLS_DTPREL_LO16",
+  "BFD_RELOC_MIPS_TLS_GOTTPREL",
+  "BFD_RELOC_MIPS_TLS_TPREL32",
+  "BFD_RELOC_MIPS_TLS_TPREL64",
+  "BFD_RELOC_MIPS_TLS_TPREL_HI16",
+  "BFD_RELOC_MIPS_TLS_TPREL_LO16",
+
+  "BFD_RELOC_MIPS_COPY",
+  "BFD_RELOC_MIPS_JUMP_SLOT",
+
+  "BFD_RELOC_FRV_LABEL16",
+  "BFD_RELOC_FRV_LABEL24",
+  "BFD_RELOC_FRV_LO16",
+  "BFD_RELOC_FRV_HI16",
+  "BFD_RELOC_FRV_GPREL12",
+  "BFD_RELOC_FRV_GPRELU12",
+  "BFD_RELOC_FRV_GPREL32",
+  "BFD_RELOC_FRV_GPRELHI",
+  "BFD_RELOC_FRV_GPRELLO",
+  "BFD_RELOC_FRV_GOT12",
+  "BFD_RELOC_FRV_GOTHI",
+  "BFD_RELOC_FRV_GOTLO",
+  "BFD_RELOC_FRV_FUNCDESC",
+  "BFD_RELOC_FRV_FUNCDESC_GOT12",
+  "BFD_RELOC_FRV_FUNCDESC_GOTHI",
+  "BFD_RELOC_FRV_FUNCDESC_GOTLO",
+  "BFD_RELOC_FRV_FUNCDESC_VALUE",
+  "BFD_RELOC_FRV_FUNCDESC_GOTOFF12",
+  "BFD_RELOC_FRV_FUNCDESC_GOTOFFHI",
+  "BFD_RELOC_FRV_FUNCDESC_GOTOFFLO",
+  "BFD_RELOC_FRV_GOTOFF12",
+  "BFD_RELOC_FRV_GOTOFFHI",
+  "BFD_RELOC_FRV_GOTOFFLO",
+  "BFD_RELOC_FRV_GETTLSOFF",
+  "BFD_RELOC_FRV_TLSDESC_VALUE",
+  "BFD_RELOC_FRV_GOTTLSDESC12",
+  "BFD_RELOC_FRV_GOTTLSDESCHI",
+  "BFD_RELOC_FRV_GOTTLSDESCLO",
+  "BFD_RELOC_FRV_TLSMOFF12",
+  "BFD_RELOC_FRV_TLSMOFFHI",
+  "BFD_RELOC_FRV_TLSMOFFLO",
+  "BFD_RELOC_FRV_GOTTLSOFF12",
+  "BFD_RELOC_FRV_GOTTLSOFFHI",
+  "BFD_RELOC_FRV_GOTTLSOFFLO",
+  "BFD_RELOC_FRV_TLSOFF",
+  "BFD_RELOC_FRV_TLSDESC_RELAX",
+  "BFD_RELOC_FRV_GETTLSOFF_RELAX",
+  "BFD_RELOC_FRV_TLSOFF_RELAX",
+  "BFD_RELOC_FRV_TLSMOFF",
+
+  "BFD_RELOC_MN10300_GOTOFF24",
+  "BFD_RELOC_MN10300_GOT32",
+  "BFD_RELOC_MN10300_GOT24",
+  "BFD_RELOC_MN10300_GOT16",
+  "BFD_RELOC_MN10300_COPY",
+  "BFD_RELOC_MN10300_GLOB_DAT",
+  "BFD_RELOC_MN10300_JMP_SLOT",
+  "BFD_RELOC_MN10300_RELATIVE",
+
+  "BFD_RELOC_386_GOT32",
+  "BFD_RELOC_386_PLT32",
+  "BFD_RELOC_386_COPY",
+  "BFD_RELOC_386_GLOB_DAT",
+  "BFD_RELOC_386_JUMP_SLOT",
+  "BFD_RELOC_386_RELATIVE",
+  "BFD_RELOC_386_GOTOFF",
+  "BFD_RELOC_386_GOTPC",
+  "BFD_RELOC_386_TLS_TPOFF",
+  "BFD_RELOC_386_TLS_IE",
+  "BFD_RELOC_386_TLS_GOTIE",
+  "BFD_RELOC_386_TLS_LE",
+  "BFD_RELOC_386_TLS_GD",
+  "BFD_RELOC_386_TLS_LDM",
+  "BFD_RELOC_386_TLS_LDO_32",
+  "BFD_RELOC_386_TLS_IE_32",
+  "BFD_RELOC_386_TLS_LE_32",
+  "BFD_RELOC_386_TLS_DTPMOD32",
+  "BFD_RELOC_386_TLS_DTPOFF32",
+  "BFD_RELOC_386_TLS_TPOFF32",
+  "BFD_RELOC_386_TLS_GOTDESC",
+  "BFD_RELOC_386_TLS_DESC_CALL",
+  "BFD_RELOC_386_TLS_DESC",
+  "BFD_RELOC_X86_64_GOT32",
+  "BFD_RELOC_X86_64_PLT32",
+  "BFD_RELOC_X86_64_COPY",
+  "BFD_RELOC_X86_64_GLOB_DAT",
+  "BFD_RELOC_X86_64_JUMP_SLOT",
+  "BFD_RELOC_X86_64_RELATIVE",
+  "BFD_RELOC_X86_64_GOTPCREL",
+  "BFD_RELOC_X86_64_32S",
+  "BFD_RELOC_X86_64_DTPMOD64",
+  "BFD_RELOC_X86_64_DTPOFF64",
+  "BFD_RELOC_X86_64_TPOFF64",
+  "BFD_RELOC_X86_64_TLSGD",
+  "BFD_RELOC_X86_64_TLSLD",
+  "BFD_RELOC_X86_64_DTPOFF32",
+  "BFD_RELOC_X86_64_GOTTPOFF",
+  "BFD_RELOC_X86_64_TPOFF32",
+  "BFD_RELOC_X86_64_GOTOFF64",
+  "BFD_RELOC_X86_64_GOTPC32",
+  "BFD_RELOC_X86_64_GOT64",
+  "BFD_RELOC_X86_64_GOTPCREL64",
+  "BFD_RELOC_X86_64_GOTPC64",
+  "BFD_RELOC_X86_64_GOTPLT64",
+  "BFD_RELOC_X86_64_PLTOFF64",
+  "BFD_RELOC_X86_64_GOTPC32_TLSDESC",
+  "BFD_RELOC_X86_64_TLSDESC_CALL",
+  "BFD_RELOC_X86_64_TLSDESC",
+  "BFD_RELOC_NS32K_IMM_8",
+  "BFD_RELOC_NS32K_IMM_16",
+  "BFD_RELOC_NS32K_IMM_32",
+  "BFD_RELOC_NS32K_IMM_8_PCREL",
+  "BFD_RELOC_NS32K_IMM_16_PCREL",
+  "BFD_RELOC_NS32K_IMM_32_PCREL",
+  "BFD_RELOC_NS32K_DISP_8",
+  "BFD_RELOC_NS32K_DISP_16",
+  "BFD_RELOC_NS32K_DISP_32",
+  "BFD_RELOC_NS32K_DISP_8_PCREL",
+  "BFD_RELOC_NS32K_DISP_16_PCREL",
+  "BFD_RELOC_NS32K_DISP_32_PCREL",
+  "BFD_RELOC_PDP11_DISP_8_PCREL",
+  "BFD_RELOC_PDP11_DISP_6_PCREL",
+  "BFD_RELOC_PJ_CODE_HI16",
+  "BFD_RELOC_PJ_CODE_LO16",
+  "BFD_RELOC_PJ_CODE_DIR16",
+  "BFD_RELOC_PJ_CODE_DIR32",
+  "BFD_RELOC_PJ_CODE_REL16",
+  "BFD_RELOC_PJ_CODE_REL32",
+  "BFD_RELOC_PPC_B26",
+  "BFD_RELOC_PPC_BA26",
+  "BFD_RELOC_PPC_TOC16",
+  "BFD_RELOC_PPC_B16",
+  "BFD_RELOC_PPC_B16_BRTAKEN",
+  "BFD_RELOC_PPC_B16_BRNTAKEN",
+  "BFD_RELOC_PPC_BA16",
+  "BFD_RELOC_PPC_BA16_BRTAKEN",
+  "BFD_RELOC_PPC_BA16_BRNTAKEN",
+  "BFD_RELOC_PPC_COPY",
+  "BFD_RELOC_PPC_GLOB_DAT",
+  "BFD_RELOC_PPC_JMP_SLOT",
+  "BFD_RELOC_PPC_RELATIVE",
+  "BFD_RELOC_PPC_LOCAL24PC",
+  "BFD_RELOC_PPC_EMB_NADDR32",
+  "BFD_RELOC_PPC_EMB_NADDR16",
+  "BFD_RELOC_PPC_EMB_NADDR16_LO",
+  "BFD_RELOC_PPC_EMB_NADDR16_HI",
+  "BFD_RELOC_PPC_EMB_NADDR16_HA",
+  "BFD_RELOC_PPC_EMB_SDAI16",
+  "BFD_RELOC_PPC_EMB_SDA2I16",
+  "BFD_RELOC_PPC_EMB_SDA2REL",
+  "BFD_RELOC_PPC_EMB_SDA21",
+  "BFD_RELOC_PPC_EMB_MRKREF",
+  "BFD_RELOC_PPC_EMB_RELSEC16",
+  "BFD_RELOC_PPC_EMB_RELST_LO",
+  "BFD_RELOC_PPC_EMB_RELST_HI",
+  "BFD_RELOC_PPC_EMB_RELST_HA",
+  "BFD_RELOC_PPC_EMB_BIT_FLD",
+  "BFD_RELOC_PPC_EMB_RELSDA",
+  "BFD_RELOC_PPC64_HIGHER",
+  "BFD_RELOC_PPC64_HIGHER_S",
+  "BFD_RELOC_PPC64_HIGHEST",
+  "BFD_RELOC_PPC64_HIGHEST_S",
+  "BFD_RELOC_PPC64_TOC16_LO",
+  "BFD_RELOC_PPC64_TOC16_HI",
+  "BFD_RELOC_PPC64_TOC16_HA",
+  "BFD_RELOC_PPC64_TOC",
+  "BFD_RELOC_PPC64_PLTGOT16",
+  "BFD_RELOC_PPC64_PLTGOT16_LO",
+  "BFD_RELOC_PPC64_PLTGOT16_HI",
+  "BFD_RELOC_PPC64_PLTGOT16_HA",
+  "BFD_RELOC_PPC64_ADDR16_DS",
+  "BFD_RELOC_PPC64_ADDR16_LO_DS",
+  "BFD_RELOC_PPC64_GOT16_DS",
+  "BFD_RELOC_PPC64_GOT16_LO_DS",
+  "BFD_RELOC_PPC64_PLT16_LO_DS",
+  "BFD_RELOC_PPC64_SECTOFF_DS",
+  "BFD_RELOC_PPC64_SECTOFF_LO_DS",
+  "BFD_RELOC_PPC64_TOC16_DS",
+  "BFD_RELOC_PPC64_TOC16_LO_DS",
+  "BFD_RELOC_PPC64_PLTGOT16_DS",
+  "BFD_RELOC_PPC64_PLTGOT16_LO_DS",
+  "BFD_RELOC_PPC_TLS",
+  "BFD_RELOC_PPC_DTPMOD",
+  "BFD_RELOC_PPC_TPREL16",
+  "BFD_RELOC_PPC_TPREL16_LO",
+  "BFD_RELOC_PPC_TPREL16_HI",
+  "BFD_RELOC_PPC_TPREL16_HA",
+  "BFD_RELOC_PPC_TPREL",
+  "BFD_RELOC_PPC_DTPREL16",
+  "BFD_RELOC_PPC_DTPREL16_LO",
+  "BFD_RELOC_PPC_DTPREL16_HI",
+  "BFD_RELOC_PPC_DTPREL16_HA",
+  "BFD_RELOC_PPC_DTPREL",
+  "BFD_RELOC_PPC_GOT_TLSGD16",
+  "BFD_RELOC_PPC_GOT_TLSGD16_LO",
+  "BFD_RELOC_PPC_GOT_TLSGD16_HI",
+  "BFD_RELOC_PPC_GOT_TLSGD16_HA",
+  "BFD_RELOC_PPC_GOT_TLSLD16",
+  "BFD_RELOC_PPC_GOT_TLSLD16_LO",
+  "BFD_RELOC_PPC_GOT_TLSLD16_HI",
+  "BFD_RELOC_PPC_GOT_TLSLD16_HA",
+  "BFD_RELOC_PPC_GOT_TPREL16",
+  "BFD_RELOC_PPC_GOT_TPREL16_LO",
+  "BFD_RELOC_PPC_GOT_TPREL16_HI",
+  "BFD_RELOC_PPC_GOT_TPREL16_HA",
+  "BFD_RELOC_PPC_GOT_DTPREL16",
+  "BFD_RELOC_PPC_GOT_DTPREL16_LO",
+  "BFD_RELOC_PPC_GOT_DTPREL16_HI",
+  "BFD_RELOC_PPC_GOT_DTPREL16_HA",
+  "BFD_RELOC_PPC64_TPREL16_DS",
+  "BFD_RELOC_PPC64_TPREL16_LO_DS",
+  "BFD_RELOC_PPC64_TPREL16_HIGHER",
+  "BFD_RELOC_PPC64_TPREL16_HIGHERA",
+  "BFD_RELOC_PPC64_TPREL16_HIGHEST",
+  "BFD_RELOC_PPC64_TPREL16_HIGHESTA",
+  "BFD_RELOC_PPC64_DTPREL16_DS",
+  "BFD_RELOC_PPC64_DTPREL16_LO_DS",
+  "BFD_RELOC_PPC64_DTPREL16_HIGHER",
+  "BFD_RELOC_PPC64_DTPREL16_HIGHERA",
+  "BFD_RELOC_PPC64_DTPREL16_HIGHEST",
+  "BFD_RELOC_PPC64_DTPREL16_HIGHESTA",
+  "BFD_RELOC_I370_D12",
+  "BFD_RELOC_CTOR",
+  "BFD_RELOC_ARM_PCREL_BRANCH",
+  "BFD_RELOC_ARM_PCREL_BLX",
+  "BFD_RELOC_THUMB_PCREL_BLX",
+  "BFD_RELOC_ARM_PCREL_CALL",
+  "BFD_RELOC_ARM_PCREL_JUMP",
+  "BFD_RELOC_THUMB_PCREL_BRANCH7",
+  "BFD_RELOC_THUMB_PCREL_BRANCH9",
+  "BFD_RELOC_THUMB_PCREL_BRANCH12",
+  "BFD_RELOC_THUMB_PCREL_BRANCH20",
+  "BFD_RELOC_THUMB_PCREL_BRANCH23",
+  "BFD_RELOC_THUMB_PCREL_BRANCH25",
+  "BFD_RELOC_ARM_OFFSET_IMM",
+  "BFD_RELOC_ARM_THUMB_OFFSET",
+  "BFD_RELOC_ARM_TARGET1",
+  "BFD_RELOC_ARM_ROSEGREL32",
+  "BFD_RELOC_ARM_SBREL32",
+  "BFD_RELOC_ARM_TARGET2",
+  "BFD_RELOC_ARM_PREL31",
+  "BFD_RELOC_ARM_MOVW",
+  "BFD_RELOC_ARM_MOVT",
+  "BFD_RELOC_ARM_MOVW_PCREL",
+  "BFD_RELOC_ARM_MOVT_PCREL",
+  "BFD_RELOC_ARM_THUMB_MOVW",
+  "BFD_RELOC_ARM_THUMB_MOVT",
+  "BFD_RELOC_ARM_THUMB_MOVW_PCREL",
+  "BFD_RELOC_ARM_THUMB_MOVT_PCREL",
+  "BFD_RELOC_ARM_JUMP_SLOT",
+  "BFD_RELOC_ARM_GLOB_DAT",
+  "BFD_RELOC_ARM_GOT32",
+  "BFD_RELOC_ARM_PLT32",
+  "BFD_RELOC_ARM_RELATIVE",
+  "BFD_RELOC_ARM_GOTOFF",
+  "BFD_RELOC_ARM_GOTPC",
+  "BFD_RELOC_ARM_TLS_GD32",
+  "BFD_RELOC_ARM_TLS_LDO32",
+  "BFD_RELOC_ARM_TLS_LDM32",
+  "BFD_RELOC_ARM_TLS_DTPOFF32",
+  "BFD_RELOC_ARM_TLS_DTPMOD32",
+  "BFD_RELOC_ARM_TLS_TPOFF32",
+  "BFD_RELOC_ARM_TLS_IE32",
+  "BFD_RELOC_ARM_TLS_LE32",
+  "BFD_RELOC_ARM_ALU_PC_G0_NC",
+  "BFD_RELOC_ARM_ALU_PC_G0",
+  "BFD_RELOC_ARM_ALU_PC_G1_NC",
+  "BFD_RELOC_ARM_ALU_PC_G1",
+  "BFD_RELOC_ARM_ALU_PC_G2",
+  "BFD_RELOC_ARM_LDR_PC_G0",
+  "BFD_RELOC_ARM_LDR_PC_G1",
+  "BFD_RELOC_ARM_LDR_PC_G2",
+  "BFD_RELOC_ARM_LDRS_PC_G0",
+  "BFD_RELOC_ARM_LDRS_PC_G1",
+  "BFD_RELOC_ARM_LDRS_PC_G2",
+  "BFD_RELOC_ARM_LDC_PC_G0",
+  "BFD_RELOC_ARM_LDC_PC_G1",
+  "BFD_RELOC_ARM_LDC_PC_G2",
+  "BFD_RELOC_ARM_ALU_SB_G0_NC",
+  "BFD_RELOC_ARM_ALU_SB_G0",
+  "BFD_RELOC_ARM_ALU_SB_G1_NC",
+  "BFD_RELOC_ARM_ALU_SB_G1",
+  "BFD_RELOC_ARM_ALU_SB_G2",
+  "BFD_RELOC_ARM_LDR_SB_G0",
+  "BFD_RELOC_ARM_LDR_SB_G1",
+  "BFD_RELOC_ARM_LDR_SB_G2",
+  "BFD_RELOC_ARM_LDRS_SB_G0",
+  "BFD_RELOC_ARM_LDRS_SB_G1",
+  "BFD_RELOC_ARM_LDRS_SB_G2",
+  "BFD_RELOC_ARM_LDC_SB_G0",
+  "BFD_RELOC_ARM_LDC_SB_G1",
+  "BFD_RELOC_ARM_LDC_SB_G2",
+  "BFD_RELOC_ARM_IMMEDIATE",
+  "BFD_RELOC_ARM_ADRL_IMMEDIATE",
+  "BFD_RELOC_ARM_T32_IMMEDIATE",
+  "BFD_RELOC_ARM_T32_ADD_IMM",
+  "BFD_RELOC_ARM_T32_IMM12",
+  "BFD_RELOC_ARM_T32_ADD_PC12",
+  "BFD_RELOC_ARM_SHIFT_IMM",
+  "BFD_RELOC_ARM_SMC",
+  "BFD_RELOC_ARM_SWI",
+  "BFD_RELOC_ARM_MULTI",
+  "BFD_RELOC_ARM_CP_OFF_IMM",
+  "BFD_RELOC_ARM_CP_OFF_IMM_S2",
+  "BFD_RELOC_ARM_T32_CP_OFF_IMM",
+  "BFD_RELOC_ARM_T32_CP_OFF_IMM_S2",
+  "BFD_RELOC_ARM_ADR_IMM",
+  "BFD_RELOC_ARM_LDR_IMM",
+  "BFD_RELOC_ARM_LITERAL",
+  "BFD_RELOC_ARM_IN_POOL",
+  "BFD_RELOC_ARM_OFFSET_IMM8",
+  "BFD_RELOC_ARM_T32_OFFSET_U8",
+  "BFD_RELOC_ARM_T32_OFFSET_IMM",
+  "BFD_RELOC_ARM_HWLITERAL",
+  "BFD_RELOC_ARM_THUMB_ADD",
+  "BFD_RELOC_ARM_THUMB_IMM",
+  "BFD_RELOC_ARM_THUMB_SHIFT",
+  "BFD_RELOC_SH_PCDISP8BY2",
+  "BFD_RELOC_SH_PCDISP12BY2",
+  "BFD_RELOC_SH_IMM3",
+  "BFD_RELOC_SH_IMM3U",
+  "BFD_RELOC_SH_DISP12",
+  "BFD_RELOC_SH_DISP12BY2",
+  "BFD_RELOC_SH_DISP12BY4",
+  "BFD_RELOC_SH_DISP12BY8",
+  "BFD_RELOC_SH_DISP20",
+  "BFD_RELOC_SH_DISP20BY8",
+  "BFD_RELOC_SH_IMM4",
+  "BFD_RELOC_SH_IMM4BY2",
+  "BFD_RELOC_SH_IMM4BY4",
+  "BFD_RELOC_SH_IMM8",
+  "BFD_RELOC_SH_IMM8BY2",
+  "BFD_RELOC_SH_IMM8BY4",
+  "BFD_RELOC_SH_PCRELIMM8BY2",
+  "BFD_RELOC_SH_PCRELIMM8BY4",
+  "BFD_RELOC_SH_SWITCH16",
+  "BFD_RELOC_SH_SWITCH32",
+  "BFD_RELOC_SH_USES",
+  "BFD_RELOC_SH_COUNT",
+  "BFD_RELOC_SH_ALIGN",
+  "BFD_RELOC_SH_CODE",
+  "BFD_RELOC_SH_DATA",
+  "BFD_RELOC_SH_LABEL",
+  "BFD_RELOC_SH_LOOP_START",
+  "BFD_RELOC_SH_LOOP_END",
+  "BFD_RELOC_SH_COPY",
+  "BFD_RELOC_SH_GLOB_DAT",
+  "BFD_RELOC_SH_JMP_SLOT",
+  "BFD_RELOC_SH_RELATIVE",
+  "BFD_RELOC_SH_GOTPC",
+  "BFD_RELOC_SH_GOT_LOW16",
+  "BFD_RELOC_SH_GOT_MEDLOW16",
+  "BFD_RELOC_SH_GOT_MEDHI16",
+  "BFD_RELOC_SH_GOT_HI16",
+  "BFD_RELOC_SH_GOTPLT_LOW16",
+  "BFD_RELOC_SH_GOTPLT_MEDLOW16",
+  "BFD_RELOC_SH_GOTPLT_MEDHI16",
+  "BFD_RELOC_SH_GOTPLT_HI16",
+  "BFD_RELOC_SH_PLT_LOW16",
+  "BFD_RELOC_SH_PLT_MEDLOW16",
+  "BFD_RELOC_SH_PLT_MEDHI16",
+  "BFD_RELOC_SH_PLT_HI16",
+  "BFD_RELOC_SH_GOTOFF_LOW16",
+  "BFD_RELOC_SH_GOTOFF_MEDLOW16",
+  "BFD_RELOC_SH_GOTOFF_MEDHI16",
+  "BFD_RELOC_SH_GOTOFF_HI16",
+  "BFD_RELOC_SH_GOTPC_LOW16",
+  "BFD_RELOC_SH_GOTPC_MEDLOW16",
+  "BFD_RELOC_SH_GOTPC_MEDHI16",
+  "BFD_RELOC_SH_GOTPC_HI16",
+  "BFD_RELOC_SH_COPY64",
+  "BFD_RELOC_SH_GLOB_DAT64",
+  "BFD_RELOC_SH_JMP_SLOT64",
+  "BFD_RELOC_SH_RELATIVE64",
+  "BFD_RELOC_SH_GOT10BY4",
+  "BFD_RELOC_SH_GOT10BY8",
+  "BFD_RELOC_SH_GOTPLT10BY4",
+  "BFD_RELOC_SH_GOTPLT10BY8",
+  "BFD_RELOC_SH_GOTPLT32",
+  "BFD_RELOC_SH_SHMEDIA_CODE",
+  "BFD_RELOC_SH_IMMU5",
+  "BFD_RELOC_SH_IMMS6",
+  "BFD_RELOC_SH_IMMS6BY32",
+  "BFD_RELOC_SH_IMMU6",
+  "BFD_RELOC_SH_IMMS10",
+  "BFD_RELOC_SH_IMMS10BY2",
+  "BFD_RELOC_SH_IMMS10BY4",
+  "BFD_RELOC_SH_IMMS10BY8",
+  "BFD_RELOC_SH_IMMS16",
+  "BFD_RELOC_SH_IMMU16",
+  "BFD_RELOC_SH_IMM_LOW16",
+  "BFD_RELOC_SH_IMM_LOW16_PCREL",
+  "BFD_RELOC_SH_IMM_MEDLOW16",
+  "BFD_RELOC_SH_IMM_MEDLOW16_PCREL",
+  "BFD_RELOC_SH_IMM_MEDHI16",
+  "BFD_RELOC_SH_IMM_MEDHI16_PCREL",
+  "BFD_RELOC_SH_IMM_HI16",
+  "BFD_RELOC_SH_IMM_HI16_PCREL",
+  "BFD_RELOC_SH_PT_16",
+  "BFD_RELOC_SH_TLS_GD_32",
+  "BFD_RELOC_SH_TLS_LD_32",
+  "BFD_RELOC_SH_TLS_LDO_32",
+  "BFD_RELOC_SH_TLS_IE_32",
+  "BFD_RELOC_SH_TLS_LE_32",
+  "BFD_RELOC_SH_TLS_DTPMOD32",
+  "BFD_RELOC_SH_TLS_DTPOFF32",
+  "BFD_RELOC_SH_TLS_TPOFF32",
+  "BFD_RELOC_ARC_B22_PCREL",
+  "BFD_RELOC_ARC_B26",
+  "BFD_RELOC_BFIN_16_IMM",
+  "BFD_RELOC_BFIN_16_HIGH",
+  "BFD_RELOC_BFIN_4_PCREL",
+  "BFD_RELOC_BFIN_5_PCREL",
+  "BFD_RELOC_BFIN_16_LOW",
+  "BFD_RELOC_BFIN_10_PCREL",
+  "BFD_RELOC_BFIN_11_PCREL",
+  "BFD_RELOC_BFIN_12_PCREL_JUMP",
+  "BFD_RELOC_BFIN_12_PCREL_JUMP_S",
+  "BFD_RELOC_BFIN_24_PCREL_CALL_X",
+  "BFD_RELOC_BFIN_24_PCREL_JUMP_L",
+  "BFD_RELOC_BFIN_GOT17M4",
+  "BFD_RELOC_BFIN_GOTHI",
+  "BFD_RELOC_BFIN_GOTLO",
+  "BFD_RELOC_BFIN_FUNCDESC",
+  "BFD_RELOC_BFIN_FUNCDESC_GOT17M4",
+  "BFD_RELOC_BFIN_FUNCDESC_GOTHI",
+  "BFD_RELOC_BFIN_FUNCDESC_GOTLO",
+  "BFD_RELOC_BFIN_FUNCDESC_VALUE",
+  "BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4",
+  "BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI",
+  "BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO",
+  "BFD_RELOC_BFIN_GOTOFF17M4",
+  "BFD_RELOC_BFIN_GOTOFFHI",
+  "BFD_RELOC_BFIN_GOTOFFLO",
+  "BFD_RELOC_BFIN_GOT",
+  "BFD_RELOC_BFIN_PLTPC",
+  "BFD_ARELOC_BFIN_PUSH",
+  "BFD_ARELOC_BFIN_CONST",
+  "BFD_ARELOC_BFIN_ADD",
+  "BFD_ARELOC_BFIN_SUB",
+  "BFD_ARELOC_BFIN_MULT",
+  "BFD_ARELOC_BFIN_DIV",
+  "BFD_ARELOC_BFIN_MOD",
+  "BFD_ARELOC_BFIN_LSHIFT",
+  "BFD_ARELOC_BFIN_RSHIFT",
+  "BFD_ARELOC_BFIN_AND",
+  "BFD_ARELOC_BFIN_OR",
+  "BFD_ARELOC_BFIN_XOR",
+  "BFD_ARELOC_BFIN_LAND",
+  "BFD_ARELOC_BFIN_LOR",
+  "BFD_ARELOC_BFIN_LEN",
+  "BFD_ARELOC_BFIN_NEG",
+  "BFD_ARELOC_BFIN_COMP",
+  "BFD_ARELOC_BFIN_PAGE",
+  "BFD_ARELOC_BFIN_HWPAGE",
+  "BFD_ARELOC_BFIN_ADDR",
+  "BFD_RELOC_D10V_10_PCREL_R",
+  "BFD_RELOC_D10V_10_PCREL_L",
+  "BFD_RELOC_D10V_18",
+  "BFD_RELOC_D10V_18_PCREL",
+  "BFD_RELOC_D30V_6",
+  "BFD_RELOC_D30V_9_PCREL",
+  "BFD_RELOC_D30V_9_PCREL_R",
+  "BFD_RELOC_D30V_15",
+  "BFD_RELOC_D30V_15_PCREL",
+  "BFD_RELOC_D30V_15_PCREL_R",
+  "BFD_RELOC_D30V_21",
+  "BFD_RELOC_D30V_21_PCREL",
+  "BFD_RELOC_D30V_21_PCREL_R",
+  "BFD_RELOC_D30V_32",
+  "BFD_RELOC_D30V_32_PCREL",
+  "BFD_RELOC_DLX_HI16_S",
+  "BFD_RELOC_DLX_LO16",
+  "BFD_RELOC_DLX_JMP26",
+  "BFD_RELOC_M32C_HI8",
+  "BFD_RELOC_M32C_RL_JUMP",
+  "BFD_RELOC_M32C_RL_1ADDR",
+  "BFD_RELOC_M32C_RL_2ADDR",
+  "BFD_RELOC_M32R_24",
+  "BFD_RELOC_M32R_10_PCREL",
+  "BFD_RELOC_M32R_18_PCREL",
+  "BFD_RELOC_M32R_26_PCREL",
+  "BFD_RELOC_M32R_HI16_ULO",
+  "BFD_RELOC_M32R_HI16_SLO",
+  "BFD_RELOC_M32R_LO16",
+  "BFD_RELOC_M32R_SDA16",
+  "BFD_RELOC_M32R_GOT24",
+  "BFD_RELOC_M32R_26_PLTREL",
+  "BFD_RELOC_M32R_COPY",
+  "BFD_RELOC_M32R_GLOB_DAT",
+  "BFD_RELOC_M32R_JMP_SLOT",
+  "BFD_RELOC_M32R_RELATIVE",
+  "BFD_RELOC_M32R_GOTOFF",
+  "BFD_RELOC_M32R_GOTOFF_HI_ULO",
+  "BFD_RELOC_M32R_GOTOFF_HI_SLO",
+  "BFD_RELOC_M32R_GOTOFF_LO",
+  "BFD_RELOC_M32R_GOTPC24",
+  "BFD_RELOC_M32R_GOT16_HI_ULO",
+  "BFD_RELOC_M32R_GOT16_HI_SLO",
+  "BFD_RELOC_M32R_GOT16_LO",
+  "BFD_RELOC_M32R_GOTPC_HI_ULO",
+  "BFD_RELOC_M32R_GOTPC_HI_SLO",
+  "BFD_RELOC_M32R_GOTPC_LO",
+  "BFD_RELOC_V850_9_PCREL",
+  "BFD_RELOC_V850_22_PCREL",
+  "BFD_RELOC_V850_SDA_16_16_OFFSET",
+  "BFD_RELOC_V850_SDA_15_16_OFFSET",
+  "BFD_RELOC_V850_ZDA_16_16_OFFSET",
+  "BFD_RELOC_V850_ZDA_15_16_OFFSET",
+  "BFD_RELOC_V850_TDA_6_8_OFFSET",
+  "BFD_RELOC_V850_TDA_7_8_OFFSET",
+  "BFD_RELOC_V850_TDA_7_7_OFFSET",
+  "BFD_RELOC_V850_TDA_16_16_OFFSET",
+  "BFD_RELOC_V850_TDA_4_5_OFFSET",
+  "BFD_RELOC_V850_TDA_4_4_OFFSET",
+  "BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET",
+  "BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET",
+  "BFD_RELOC_V850_CALLT_6_7_OFFSET",
+  "BFD_RELOC_V850_CALLT_16_16_OFFSET",
+  "BFD_RELOC_V850_LONGCALL",
+  "BFD_RELOC_V850_LONGJUMP",
+  "BFD_RELOC_V850_ALIGN",
+  "BFD_RELOC_V850_LO16_SPLIT_OFFSET",
+  "BFD_RELOC_MN10300_32_PCREL",
+  "BFD_RELOC_MN10300_16_PCREL",
+  "BFD_RELOC_TIC30_LDP",
+  "BFD_RELOC_TIC54X_PARTLS7",
+  "BFD_RELOC_TIC54X_PARTMS9",
+  "BFD_RELOC_TIC54X_23",
+  "BFD_RELOC_TIC54X_16_OF_23",
+  "BFD_RELOC_TIC54X_MS7_OF_23",
+  "BFD_RELOC_FR30_48",
+  "BFD_RELOC_FR30_20",
+  "BFD_RELOC_FR30_6_IN_4",
+  "BFD_RELOC_FR30_8_IN_8",
+  "BFD_RELOC_FR30_9_IN_8",
+  "BFD_RELOC_FR30_10_IN_8",
+  "BFD_RELOC_FR30_9_PCREL",
+  "BFD_RELOC_FR30_12_PCREL",
+  "BFD_RELOC_MCORE_PCREL_IMM8BY4",
+  "BFD_RELOC_MCORE_PCREL_IMM11BY2",
+  "BFD_RELOC_MCORE_PCREL_IMM4BY2",
+  "BFD_RELOC_MCORE_PCREL_32",
+  "BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2",
+  "BFD_RELOC_MCORE_RVA",
+  "BFD_RELOC_MEP_8",
+  "BFD_RELOC_MEP_16",
+  "BFD_RELOC_MEP_32",
+  "BFD_RELOC_MEP_PCREL8A2",
+  "BFD_RELOC_MEP_PCREL12A2",
+  "BFD_RELOC_MEP_PCREL17A2",
+  "BFD_RELOC_MEP_PCREL24A2",
+  "BFD_RELOC_MEP_PCABS24A2",
+  "BFD_RELOC_MEP_LOW16",
+  "BFD_RELOC_MEP_HI16U",
+  "BFD_RELOC_MEP_HI16S",
+  "BFD_RELOC_MEP_GPREL",
+  "BFD_RELOC_MEP_TPREL",
+  "BFD_RELOC_MEP_TPREL7",
+  "BFD_RELOC_MEP_TPREL7A2",
+  "BFD_RELOC_MEP_TPREL7A4",
+  "BFD_RELOC_MEP_UIMM24",
+  "BFD_RELOC_MEP_ADDR24A4",
+  "BFD_RELOC_MEP_GNU_VTINHERIT",
+  "BFD_RELOC_MEP_GNU_VTENTRY",
+
+  "BFD_RELOC_MMIX_GETA",
+  "BFD_RELOC_MMIX_GETA_1",
+  "BFD_RELOC_MMIX_GETA_2",
+  "BFD_RELOC_MMIX_GETA_3",
+  "BFD_RELOC_MMIX_CBRANCH",
+  "BFD_RELOC_MMIX_CBRANCH_J",
+  "BFD_RELOC_MMIX_CBRANCH_1",
+  "BFD_RELOC_MMIX_CBRANCH_2",
+  "BFD_RELOC_MMIX_CBRANCH_3",
+  "BFD_RELOC_MMIX_PUSHJ",
+  "BFD_RELOC_MMIX_PUSHJ_1",
+  "BFD_RELOC_MMIX_PUSHJ_2",
+  "BFD_RELOC_MMIX_PUSHJ_3",
+  "BFD_RELOC_MMIX_PUSHJ_STUBBABLE",
+  "BFD_RELOC_MMIX_JMP",
+  "BFD_RELOC_MMIX_JMP_1",
+  "BFD_RELOC_MMIX_JMP_2",
+  "BFD_RELOC_MMIX_JMP_3",
+  "BFD_RELOC_MMIX_ADDR19",
+  "BFD_RELOC_MMIX_ADDR27",
+  "BFD_RELOC_MMIX_REG_OR_BYTE",
+  "BFD_RELOC_MMIX_REG",
+  "BFD_RELOC_MMIX_BASE_PLUS_OFFSET",
+  "BFD_RELOC_MMIX_LOCAL",
+  "BFD_RELOC_AVR_7_PCREL",
+  "BFD_RELOC_AVR_13_PCREL",
+  "BFD_RELOC_AVR_16_PM",
+  "BFD_RELOC_AVR_LO8_LDI",
+  "BFD_RELOC_AVR_HI8_LDI",
+  "BFD_RELOC_AVR_HH8_LDI",
+  "BFD_RELOC_AVR_MS8_LDI",
+  "BFD_RELOC_AVR_LO8_LDI_NEG",
+  "BFD_RELOC_AVR_HI8_LDI_NEG",
+  "BFD_RELOC_AVR_HH8_LDI_NEG",
+  "BFD_RELOC_AVR_MS8_LDI_NEG",
+  "BFD_RELOC_AVR_LO8_LDI_PM",
+  "BFD_RELOC_AVR_LO8_LDI_GS",
+  "BFD_RELOC_AVR_HI8_LDI_PM",
+  "BFD_RELOC_AVR_HI8_LDI_GS",
+  "BFD_RELOC_AVR_HH8_LDI_PM",
+  "BFD_RELOC_AVR_LO8_LDI_PM_NEG",
+  "BFD_RELOC_AVR_HI8_LDI_PM_NEG",
+  "BFD_RELOC_AVR_HH8_LDI_PM_NEG",
+  "BFD_RELOC_AVR_CALL",
+  "BFD_RELOC_AVR_LDI",
+  "BFD_RELOC_AVR_6",
+  "BFD_RELOC_AVR_6_ADIW",
+  "BFD_RELOC_AVR32_DIFF32",
+  "BFD_RELOC_AVR32_DIFF16",
+  "BFD_RELOC_AVR32_DIFF8",
+  "BFD_RELOC_AVR32_GOT32",
+  "BFD_RELOC_AVR32_GOT16",
+  "BFD_RELOC_AVR32_GOT8",
+  "BFD_RELOC_AVR32_21S",
+  "BFD_RELOC_AVR32_16U",
+  "BFD_RELOC_AVR32_16S",
+  "BFD_RELOC_AVR32_SUB5",
+  "BFD_RELOC_AVR32_8S_EXT",
+  "BFD_RELOC_AVR32_8S",
+  "BFD_RELOC_AVR32_15S",
+  "BFD_RELOC_AVR32_22H_PCREL",
+  "BFD_RELOC_AVR32_18W_PCREL",
+  "BFD_RELOC_AVR32_16B_PCREL",
+  "BFD_RELOC_AVR32_16N_PCREL",
+  "BFD_RELOC_AVR32_14UW_PCREL",
+  "BFD_RELOC_AVR32_11H_PCREL",
+  "BFD_RELOC_AVR32_10UW_PCREL",
+  "BFD_RELOC_AVR32_9H_PCREL",
+  "BFD_RELOC_AVR32_9UW_PCREL",
+  "BFD_RELOC_AVR32_GOTPC",
+  "BFD_RELOC_AVR32_GOTCALL",
+  "BFD_RELOC_AVR32_LDA_GOT",
+  "BFD_RELOC_AVR32_GOT21S",
+  "BFD_RELOC_AVR32_GOT18SW",
+  "BFD_RELOC_AVR32_GOT16S",
+  "BFD_RELOC_AVR32_32_CPENT",
+  "BFD_RELOC_AVR32_CPCALL",
+  "BFD_RELOC_AVR32_16_CP",
+  "BFD_RELOC_AVR32_9W_CP",
+  "BFD_RELOC_AVR32_ALIGN",
+  "BFD_RELOC_AVR32_14UW",
+  "BFD_RELOC_AVR32_10UW",
+  "BFD_RELOC_AVR32_10SW",
+  "BFD_RELOC_AVR32_STHH_W",
+  "BFD_RELOC_AVR32_7UW",
+  "BFD_RELOC_AVR32_6S",
+  "BFD_RELOC_AVR32_6UW",
+  "BFD_RELOC_AVR32_4UH",
+  "BFD_RELOC_AVR32_3U",
+  "BFD_RELOC_390_12",
+  "BFD_RELOC_390_GOT12",
+  "BFD_RELOC_390_PLT32",
+  "BFD_RELOC_390_COPY",
+  "BFD_RELOC_390_GLOB_DAT",
+  "BFD_RELOC_390_JMP_SLOT",
+  "BFD_RELOC_390_RELATIVE",
+  "BFD_RELOC_390_GOTPC",
+  "BFD_RELOC_390_GOT16",
+  "BFD_RELOC_390_PC16DBL",
+  "BFD_RELOC_390_PLT16DBL",
+  "BFD_RELOC_390_PC32DBL",
+  "BFD_RELOC_390_PLT32DBL",
+  "BFD_RELOC_390_GOTPCDBL",
+  "BFD_RELOC_390_GOT64",
+  "BFD_RELOC_390_PLT64",
+  "BFD_RELOC_390_GOTENT",
+  "BFD_RELOC_390_GOTOFF64",
+  "BFD_RELOC_390_GOTPLT12",
+  "BFD_RELOC_390_GOTPLT16",
+  "BFD_RELOC_390_GOTPLT32",
+  "BFD_RELOC_390_GOTPLT64",
+  "BFD_RELOC_390_GOTPLTENT",
+  "BFD_RELOC_390_PLTOFF16",
+  "BFD_RELOC_390_PLTOFF32",
+  "BFD_RELOC_390_PLTOFF64",
+  "BFD_RELOC_390_TLS_LOAD",
+  "BFD_RELOC_390_TLS_GDCALL",
+  "BFD_RELOC_390_TLS_LDCALL",
+  "BFD_RELOC_390_TLS_GD32",
+  "BFD_RELOC_390_TLS_GD64",
+  "BFD_RELOC_390_TLS_GOTIE12",
+  "BFD_RELOC_390_TLS_GOTIE32",
+  "BFD_RELOC_390_TLS_GOTIE64",
+  "BFD_RELOC_390_TLS_LDM32",
+  "BFD_RELOC_390_TLS_LDM64",
+  "BFD_RELOC_390_TLS_IE32",
+  "BFD_RELOC_390_TLS_IE64",
+  "BFD_RELOC_390_TLS_IEENT",
+  "BFD_RELOC_390_TLS_LE32",
+  "BFD_RELOC_390_TLS_LE64",
+  "BFD_RELOC_390_TLS_LDO32",
+  "BFD_RELOC_390_TLS_LDO64",
+  "BFD_RELOC_390_TLS_DTPMOD",
+  "BFD_RELOC_390_TLS_DTPOFF",
+  "BFD_RELOC_390_TLS_TPOFF",
+  "BFD_RELOC_390_20",
+  "BFD_RELOC_390_GOT20",
+  "BFD_RELOC_390_GOTPLT20",
+  "BFD_RELOC_390_TLS_GOTIE20",
+  "BFD_RELOC_SCORE_DUMMY1",
+  "BFD_RELOC_SCORE_GPREL15",
+  "BFD_RELOC_SCORE_DUMMY2",
+  "BFD_RELOC_SCORE_JMP",
+  "BFD_RELOC_SCORE_BRANCH",
+  "BFD_RELOC_SCORE16_JMP",
+  "BFD_RELOC_SCORE16_BRANCH",
+  "BFD_RELOC_SCORE_GOT15",
+  "BFD_RELOC_SCORE_GOT_LO16",
+  "BFD_RELOC_SCORE_CALL15",
+  "BFD_RELOC_SCORE_DUMMY_HI16",
+  "BFD_RELOC_IP2K_FR9",
+  "BFD_RELOC_IP2K_BANK",
+  "BFD_RELOC_IP2K_ADDR16CJP",
+  "BFD_RELOC_IP2K_PAGE3",
+  "BFD_RELOC_IP2K_LO8DATA",
+  "BFD_RELOC_IP2K_HI8DATA",
+  "BFD_RELOC_IP2K_EX8DATA",
+  "BFD_RELOC_IP2K_LO8INSN",
+  "BFD_RELOC_IP2K_HI8INSN",
+  "BFD_RELOC_IP2K_PC_SKIP",
+  "BFD_RELOC_IP2K_TEXT",
+  "BFD_RELOC_IP2K_FR_OFFSET",
+  "BFD_RELOC_VPE4KMATH_DATA",
+  "BFD_RELOC_VPE4KMATH_INSN",
+  "BFD_RELOC_VTABLE_INHERIT",
+  "BFD_RELOC_VTABLE_ENTRY",
+  "BFD_RELOC_IA64_IMM14",
+  "BFD_RELOC_IA64_IMM22",
+  "BFD_RELOC_IA64_IMM64",
+  "BFD_RELOC_IA64_DIR32MSB",
+  "BFD_RELOC_IA64_DIR32LSB",
+  "BFD_RELOC_IA64_DIR64MSB",
+  "BFD_RELOC_IA64_DIR64LSB",
+  "BFD_RELOC_IA64_GPREL22",
+  "BFD_RELOC_IA64_GPREL64I",
+  "BFD_RELOC_IA64_GPREL32MSB",
+  "BFD_RELOC_IA64_GPREL32LSB",
+  "BFD_RELOC_IA64_GPREL64MSB",
+  "BFD_RELOC_IA64_GPREL64LSB",
+  "BFD_RELOC_IA64_LTOFF22",
+  "BFD_RELOC_IA64_LTOFF64I",
+  "BFD_RELOC_IA64_PLTOFF22",
+  "BFD_RELOC_IA64_PLTOFF64I",
+  "BFD_RELOC_IA64_PLTOFF64MSB",
+  "BFD_RELOC_IA64_PLTOFF64LSB",
+  "BFD_RELOC_IA64_FPTR64I",
+  "BFD_RELOC_IA64_FPTR32MSB",
+  "BFD_RELOC_IA64_FPTR32LSB",
+  "BFD_RELOC_IA64_FPTR64MSB",
+  "BFD_RELOC_IA64_FPTR64LSB",
+  "BFD_RELOC_IA64_PCREL21B",
+  "BFD_RELOC_IA64_PCREL21BI",
+  "BFD_RELOC_IA64_PCREL21M",
+  "BFD_RELOC_IA64_PCREL21F",
+  "BFD_RELOC_IA64_PCREL22",
+  "BFD_RELOC_IA64_PCREL60B",
+  "BFD_RELOC_IA64_PCREL64I",
+  "BFD_RELOC_IA64_PCREL32MSB",
+  "BFD_RELOC_IA64_PCREL32LSB",
+  "BFD_RELOC_IA64_PCREL64MSB",
+  "BFD_RELOC_IA64_PCREL64LSB",
+  "BFD_RELOC_IA64_LTOFF_FPTR22",
+  "BFD_RELOC_IA64_LTOFF_FPTR64I",
+  "BFD_RELOC_IA64_LTOFF_FPTR32MSB",
+  "BFD_RELOC_IA64_LTOFF_FPTR32LSB",
+  "BFD_RELOC_IA64_LTOFF_FPTR64MSB",
+  "BFD_RELOC_IA64_LTOFF_FPTR64LSB",
+  "BFD_RELOC_IA64_SEGREL32MSB",
+  "BFD_RELOC_IA64_SEGREL32LSB",
+  "BFD_RELOC_IA64_SEGREL64MSB",
+  "BFD_RELOC_IA64_SEGREL64LSB",
+  "BFD_RELOC_IA64_SECREL32MSB",
+  "BFD_RELOC_IA64_SECREL32LSB",
+  "BFD_RELOC_IA64_SECREL64MSB",
+  "BFD_RELOC_IA64_SECREL64LSB",
+  "BFD_RELOC_IA64_REL32MSB",
+  "BFD_RELOC_IA64_REL32LSB",
+  "BFD_RELOC_IA64_REL64MSB",
+  "BFD_RELOC_IA64_REL64LSB",
+  "BFD_RELOC_IA64_LTV32MSB",
+  "BFD_RELOC_IA64_LTV32LSB",
+  "BFD_RELOC_IA64_LTV64MSB",
+  "BFD_RELOC_IA64_LTV64LSB",
+  "BFD_RELOC_IA64_IPLTMSB",
+  "BFD_RELOC_IA64_IPLTLSB",
+  "BFD_RELOC_IA64_COPY",
+  "BFD_RELOC_IA64_LTOFF22X",
+  "BFD_RELOC_IA64_LDXMOV",
+  "BFD_RELOC_IA64_TPREL14",
+  "BFD_RELOC_IA64_TPREL22",
+  "BFD_RELOC_IA64_TPREL64I",
+  "BFD_RELOC_IA64_TPREL64MSB",
+  "BFD_RELOC_IA64_TPREL64LSB",
+  "BFD_RELOC_IA64_LTOFF_TPREL22",
+  "BFD_RELOC_IA64_DTPMOD64MSB",
+  "BFD_RELOC_IA64_DTPMOD64LSB",
+  "BFD_RELOC_IA64_LTOFF_DTPMOD22",
+  "BFD_RELOC_IA64_DTPREL14",
+  "BFD_RELOC_IA64_DTPREL22",
+  "BFD_RELOC_IA64_DTPREL64I",
+  "BFD_RELOC_IA64_DTPREL32MSB",
+  "BFD_RELOC_IA64_DTPREL32LSB",
+  "BFD_RELOC_IA64_DTPREL64MSB",
+  "BFD_RELOC_IA64_DTPREL64LSB",
+  "BFD_RELOC_IA64_LTOFF_DTPREL22",
+  "BFD_RELOC_M68HC11_HI8",
+  "BFD_RELOC_M68HC11_LO8",
+  "BFD_RELOC_M68HC11_3B",
+  "BFD_RELOC_M68HC11_RL_JUMP",
+  "BFD_RELOC_M68HC11_RL_GROUP",
+  "BFD_RELOC_M68HC11_LO16",
+  "BFD_RELOC_M68HC11_PAGE",
+  "BFD_RELOC_M68HC11_24",
+  "BFD_RELOC_M68HC12_5B",
+  "BFD_RELOC_16C_NUM08",
+  "BFD_RELOC_16C_NUM08_C",
+  "BFD_RELOC_16C_NUM16",
+  "BFD_RELOC_16C_NUM16_C",
+  "BFD_RELOC_16C_NUM32",
+  "BFD_RELOC_16C_NUM32_C",
+  "BFD_RELOC_16C_DISP04",
+  "BFD_RELOC_16C_DISP04_C",
+  "BFD_RELOC_16C_DISP08",
+  "BFD_RELOC_16C_DISP08_C",
+  "BFD_RELOC_16C_DISP16",
+  "BFD_RELOC_16C_DISP16_C",
+  "BFD_RELOC_16C_DISP24",
+  "BFD_RELOC_16C_DISP24_C",
+  "BFD_RELOC_16C_DISP24a",
+  "BFD_RELOC_16C_DISP24a_C",
+  "BFD_RELOC_16C_REG04",
+  "BFD_RELOC_16C_REG04_C",
+  "BFD_RELOC_16C_REG04a",
+  "BFD_RELOC_16C_REG04a_C",
+  "BFD_RELOC_16C_REG14",
+  "BFD_RELOC_16C_REG14_C",
+  "BFD_RELOC_16C_REG16",
+  "BFD_RELOC_16C_REG16_C",
+  "BFD_RELOC_16C_REG20",
+  "BFD_RELOC_16C_REG20_C",
+  "BFD_RELOC_16C_ABS20",
+  "BFD_RELOC_16C_ABS20_C",
+  "BFD_RELOC_16C_ABS24",
+  "BFD_RELOC_16C_ABS24_C",
+  "BFD_RELOC_16C_IMM04",
+  "BFD_RELOC_16C_IMM04_C",
+  "BFD_RELOC_16C_IMM16",
+  "BFD_RELOC_16C_IMM16_C",
+  "BFD_RELOC_16C_IMM20",
+  "BFD_RELOC_16C_IMM20_C",
+  "BFD_RELOC_16C_IMM24",
+  "BFD_RELOC_16C_IMM24_C",
+  "BFD_RELOC_16C_IMM32",
+  "BFD_RELOC_16C_IMM32_C",
+  "BFD_RELOC_CR16_NUM8",
+  "BFD_RELOC_CR16_NUM16",
+  "BFD_RELOC_CR16_NUM32",
+  "BFD_RELOC_CR16_NUM32a",
+  "BFD_RELOC_CR16_REGREL0",
+  "BFD_RELOC_CR16_REGREL4",
+  "BFD_RELOC_CR16_REGREL4a",
+  "BFD_RELOC_CR16_REGREL14",
+  "BFD_RELOC_CR16_REGREL14a",
+  "BFD_RELOC_CR16_REGREL16",
+  "BFD_RELOC_CR16_REGREL20",
+  "BFD_RELOC_CR16_REGREL20a",
+  "BFD_RELOC_CR16_ABS20",
+  "BFD_RELOC_CR16_ABS24",
+  "BFD_RELOC_CR16_IMM4",
+  "BFD_RELOC_CR16_IMM8",
+  "BFD_RELOC_CR16_IMM16",
+  "BFD_RELOC_CR16_IMM20",
+  "BFD_RELOC_CR16_IMM24",
+  "BFD_RELOC_CR16_IMM32",
+  "BFD_RELOC_CR16_IMM32a",
+  "BFD_RELOC_CR16_DISP4",
+  "BFD_RELOC_CR16_DISP8",
+  "BFD_RELOC_CR16_DISP16",
+  "BFD_RELOC_CR16_DISP20",
+  "BFD_RELOC_CR16_DISP24",
+  "BFD_RELOC_CR16_DISP24a",
+  "BFD_RELOC_CRX_REL4",
+  "BFD_RELOC_CRX_REL8",
+  "BFD_RELOC_CRX_REL8_CMP",
+  "BFD_RELOC_CRX_REL16",
+  "BFD_RELOC_CRX_REL24",
+  "BFD_RELOC_CRX_REL32",
+  "BFD_RELOC_CRX_REGREL12",
+  "BFD_RELOC_CRX_REGREL22",
+  "BFD_RELOC_CRX_REGREL28",
+  "BFD_RELOC_CRX_REGREL32",
+  "BFD_RELOC_CRX_ABS16",
+  "BFD_RELOC_CRX_ABS32",
+  "BFD_RELOC_CRX_NUM8",
+  "BFD_RELOC_CRX_NUM16",
+  "BFD_RELOC_CRX_NUM32",
+  "BFD_RELOC_CRX_IMM16",
+  "BFD_RELOC_CRX_IMM32",
+  "BFD_RELOC_CRX_SWITCH8",
+  "BFD_RELOC_CRX_SWITCH16",
+  "BFD_RELOC_CRX_SWITCH32",
+  "BFD_RELOC_CRIS_BDISP8",
+  "BFD_RELOC_CRIS_UNSIGNED_5",
+  "BFD_RELOC_CRIS_SIGNED_6",
+  "BFD_RELOC_CRIS_UNSIGNED_6",
+  "BFD_RELOC_CRIS_SIGNED_8",
+  "BFD_RELOC_CRIS_UNSIGNED_8",
+  "BFD_RELOC_CRIS_SIGNED_16",
+  "BFD_RELOC_CRIS_UNSIGNED_16",
+  "BFD_RELOC_CRIS_LAPCQ_OFFSET",
+  "BFD_RELOC_CRIS_UNSIGNED_4",
+  "BFD_RELOC_CRIS_COPY",
+  "BFD_RELOC_CRIS_GLOB_DAT",
+  "BFD_RELOC_CRIS_JUMP_SLOT",
+  "BFD_RELOC_CRIS_RELATIVE",
+  "BFD_RELOC_CRIS_32_GOT",
+  "BFD_RELOC_CRIS_16_GOT",
+  "BFD_RELOC_CRIS_32_GOTPLT",
+  "BFD_RELOC_CRIS_16_GOTPLT",
+  "BFD_RELOC_CRIS_32_GOTREL",
+  "BFD_RELOC_CRIS_32_PLT_GOTREL",
+  "BFD_RELOC_CRIS_32_PLT_PCREL",
+  "BFD_RELOC_860_COPY",
+  "BFD_RELOC_860_GLOB_DAT",
+  "BFD_RELOC_860_JUMP_SLOT",
+  "BFD_RELOC_860_RELATIVE",
+  "BFD_RELOC_860_PC26",
+  "BFD_RELOC_860_PLT26",
+  "BFD_RELOC_860_PC16",
+  "BFD_RELOC_860_LOW0",
+  "BFD_RELOC_860_SPLIT0",
+  "BFD_RELOC_860_LOW1",
+  "BFD_RELOC_860_SPLIT1",
+  "BFD_RELOC_860_LOW2",
+  "BFD_RELOC_860_SPLIT2",
+  "BFD_RELOC_860_LOW3",
+  "BFD_RELOC_860_LOGOT0",
+  "BFD_RELOC_860_SPGOT0",
+  "BFD_RELOC_860_LOGOT1",
+  "BFD_RELOC_860_SPGOT1",
+  "BFD_RELOC_860_LOGOTOFF0",
+  "BFD_RELOC_860_SPGOTOFF0",
+  "BFD_RELOC_860_LOGOTOFF1",
+  "BFD_RELOC_860_SPGOTOFF1",
+  "BFD_RELOC_860_LOGOTOFF2",
+  "BFD_RELOC_860_LOGOTOFF3",
+  "BFD_RELOC_860_LOPC",
+  "BFD_RELOC_860_HIGHADJ",
+  "BFD_RELOC_860_HAGOT",
+  "BFD_RELOC_860_HAGOTOFF",
+  "BFD_RELOC_860_HAPC",
+  "BFD_RELOC_860_HIGH",
+  "BFD_RELOC_860_HIGOT",
+  "BFD_RELOC_860_HIGOTOFF",
+  "BFD_RELOC_OPENRISC_ABS_26",
+  "BFD_RELOC_OPENRISC_REL_26",
+  "BFD_RELOC_H8_DIR16A8",
+  "BFD_RELOC_H8_DIR16R8",
+  "BFD_RELOC_H8_DIR24A8",
+  "BFD_RELOC_H8_DIR24R8",
+  "BFD_RELOC_H8_DIR32A16",
+  "BFD_RELOC_XSTORMY16_REL_12",
+  "BFD_RELOC_XSTORMY16_12",
+  "BFD_RELOC_XSTORMY16_24",
+  "BFD_RELOC_XSTORMY16_FPTR16",
+  "BFD_RELOC_RELC",
+
+  "BFD_RELOC_XC16X_PAG",
+  "BFD_RELOC_XC16X_POF",
+  "BFD_RELOC_XC16X_SEG",
+  "BFD_RELOC_XC16X_SOF",
+  "BFD_RELOC_VAX_GLOB_DAT",
+  "BFD_RELOC_VAX_JMP_SLOT",
+  "BFD_RELOC_VAX_RELATIVE",
+  "BFD_RELOC_MT_PC16",
+  "BFD_RELOC_MT_HI16",
+  "BFD_RELOC_MT_LO16",
+  "BFD_RELOC_MT_GNU_VTINHERIT",
+  "BFD_RELOC_MT_GNU_VTENTRY",
+  "BFD_RELOC_MT_PCINSN8",
+  "BFD_RELOC_MSP430_10_PCREL",
+  "BFD_RELOC_MSP430_16_PCREL",
+  "BFD_RELOC_MSP430_16",
+  "BFD_RELOC_MSP430_16_PCREL_BYTE",
+  "BFD_RELOC_MSP430_16_BYTE",
+  "BFD_RELOC_MSP430_2X_PCREL",
+  "BFD_RELOC_MSP430_RL_PCREL",
+  "BFD_RELOC_IQ2000_OFFSET_16",
+  "BFD_RELOC_IQ2000_OFFSET_21",
+  "BFD_RELOC_IQ2000_UHI16",
+  "BFD_RELOC_XTENSA_RTLD",
+  "BFD_RELOC_XTENSA_GLOB_DAT",
+  "BFD_RELOC_XTENSA_JMP_SLOT",
+  "BFD_RELOC_XTENSA_RELATIVE",
+  "BFD_RELOC_XTENSA_PLT",
+  "BFD_RELOC_XTENSA_DIFF8",
+  "BFD_RELOC_XTENSA_DIFF16",
+  "BFD_RELOC_XTENSA_DIFF32",
+  "BFD_RELOC_XTENSA_SLOT0_OP",
+  "BFD_RELOC_XTENSA_SLOT1_OP",
+  "BFD_RELOC_XTENSA_SLOT2_OP",
+  "BFD_RELOC_XTENSA_SLOT3_OP",
+  "BFD_RELOC_XTENSA_SLOT4_OP",
+  "BFD_RELOC_XTENSA_SLOT5_OP",
+  "BFD_RELOC_XTENSA_SLOT6_OP",
+  "BFD_RELOC_XTENSA_SLOT7_OP",
+  "BFD_RELOC_XTENSA_SLOT8_OP",
+  "BFD_RELOC_XTENSA_SLOT9_OP",
+  "BFD_RELOC_XTENSA_SLOT10_OP",
+  "BFD_RELOC_XTENSA_SLOT11_OP",
+  "BFD_RELOC_XTENSA_SLOT12_OP",
+  "BFD_RELOC_XTENSA_SLOT13_OP",
+  "BFD_RELOC_XTENSA_SLOT14_OP",
+  "BFD_RELOC_XTENSA_SLOT0_ALT",
+  "BFD_RELOC_XTENSA_SLOT1_ALT",
+  "BFD_RELOC_XTENSA_SLOT2_ALT",
+  "BFD_RELOC_XTENSA_SLOT3_ALT",
+  "BFD_RELOC_XTENSA_SLOT4_ALT",
+  "BFD_RELOC_XTENSA_SLOT5_ALT",
+  "BFD_RELOC_XTENSA_SLOT6_ALT",
+  "BFD_RELOC_XTENSA_SLOT7_ALT",
+  "BFD_RELOC_XTENSA_SLOT8_ALT",
+  "BFD_RELOC_XTENSA_SLOT9_ALT",
+  "BFD_RELOC_XTENSA_SLOT10_ALT",
+  "BFD_RELOC_XTENSA_SLOT11_ALT",
+  "BFD_RELOC_XTENSA_SLOT12_ALT",
+  "BFD_RELOC_XTENSA_SLOT13_ALT",
+  "BFD_RELOC_XTENSA_SLOT14_ALT",
+  "BFD_RELOC_XTENSA_OP0",
+  "BFD_RELOC_XTENSA_OP1",
+  "BFD_RELOC_XTENSA_OP2",
+  "BFD_RELOC_XTENSA_ASM_EXPAND",
+  "BFD_RELOC_XTENSA_ASM_SIMPLIFY",
+  "BFD_RELOC_Z80_DISP8",
+  "BFD_RELOC_Z8K_DISP7",
+  "BFD_RELOC_Z8K_CALLR",
+  "BFD_RELOC_Z8K_IMM4L",
+ "@@overflow: BFD_RELOC_UNUSED@@",
+};
+#endif
+
+reloc_howto_type *bfd_default_reloc_type_lookup
+   (bfd *abfd, bfd_reloc_code_real_type  code);
+
+bfd_boolean bfd_generic_relax_section
+   (bfd *abfd,
+    asection *section,
+    struct bfd_link_info *,
+    bfd_boolean *);
+
+bfd_boolean bfd_generic_gc_sections
+   (bfd *, struct bfd_link_info *);
+
+bfd_boolean bfd_generic_merge_sections
+   (bfd *, struct bfd_link_info *);
+
+bfd_byte *bfd_generic_get_relocated_section_contents
+   (bfd *abfd,
+    struct bfd_link_info *link_info,
+    struct bfd_link_order *link_order,
+    bfd_byte *data,
+    bfd_boolean relocatable,
+    asymbol **symbols);
+
+/* Extracted from archures.c.  */
+extern const bfd_arch_info_type bfd_default_arch_struct;
+bfd_boolean bfd_default_set_arch_mach
+   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);
+
+const bfd_arch_info_type *bfd_default_compatible
+   (const bfd_arch_info_type *a, const bfd_arch_info_type *b);
+
+bfd_boolean bfd_default_scan
+   (const struct bfd_arch_info *info, const char *string);
+
+/* Extracted from elf.c.  */
+struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);
+
--- /dev/null
+++ b/bfd/doc/libcoff.h
@@ -0,0 +1,936 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
+   generated from "libcoff-in.h" and "coffcode.h".
+   Run "make headers" in your build bfd/ to regenerate.  */
+
+/* BFD COFF object file private structure.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "bfdlink.h"
+
+/* Object file tdata; access macros.  */
+
+#define coff_data(bfd)		      ((bfd)->tdata.coff_obj_data)
+#define exec_hdr(bfd)		      (coff_data (bfd)->hdr)
+#define obj_pe(bfd)                   (coff_data (bfd)->pe)
+#define obj_symbols(bfd)	      (coff_data (bfd)->symbols)
+#define	obj_sym_filepos(bfd)	      (coff_data (bfd)->sym_filepos)
+#define obj_relocbase(bfd)	      (coff_data (bfd)->relocbase)
+#define obj_raw_syments(bfd)	      (coff_data (bfd)->raw_syments)
+#define obj_raw_syment_count(bfd)     (coff_data (bfd)->raw_syment_count)
+#define obj_convert(bfd)	      (coff_data (bfd)->conversion_table)
+#define obj_conv_table_size(bfd)      (coff_data (bfd)->conv_table_size)
+#define obj_coff_external_syms(bfd)   (coff_data (bfd)->external_syms)
+#define obj_coff_keep_syms(bfd)	      (coff_data (bfd)->keep_syms)
+#define obj_coff_strings(bfd)	      (coff_data (bfd)->strings)
+#define obj_coff_keep_strings(bfd)    (coff_data (bfd)->keep_strings)
+#define obj_coff_sym_hashes(bfd)      (coff_data (bfd)->sym_hashes)
+#define obj_coff_strings_written(bfd) (coff_data (bfd)->strings_written)
+#define obj_coff_local_toc_table(bfd) (coff_data (bfd)->local_toc_sym_map)
+
+/* `Tdata' information kept for COFF files.  */
+
+typedef struct coff_tdata
+{
+  struct coff_symbol_struct *symbols;	/* Symtab for input bfd.  */
+  unsigned int *conversion_table;
+  int conv_table_size;
+  file_ptr sym_filepos;
+
+  struct coff_ptr_struct *raw_syments;
+  unsigned long raw_syment_count;
+
+  /* These are only valid once writing has begun.  */
+  long int relocbase;
+
+  /* These members communicate important constants about the symbol table
+     to GDB's symbol-reading code.  These `constants' unfortunately vary
+     from coff implementation to implementation...  */
+  unsigned local_n_btmask;
+  unsigned local_n_btshft;
+  unsigned local_n_tmask;
+  unsigned local_n_tshift;
+  unsigned local_symesz;
+  unsigned local_auxesz;
+  unsigned local_linesz;
+
+  /* The unswapped external symbols.  May be NULL.  Read by
+     _bfd_coff_get_external_symbols.  */
+  void * external_syms;
+  /* If this is TRUE, the external_syms may not be freed.  */
+  bfd_boolean keep_syms;
+
+  /* The string table.  May be NULL.  Read by
+     _bfd_coff_read_string_table.  */
+  char *strings;
+  /* If this is TRUE, the strings may not be freed.  */
+  bfd_boolean keep_strings;
+  /* If this is TRUE, the strings have been written out already.  */
+  bfd_boolean strings_written;
+
+  /* Is this a PE format coff file?  */
+  int pe;
+  /* Used by the COFF backend linker.  */
+  struct coff_link_hash_entry **sym_hashes;
+
+  /* Used by the pe linker for PowerPC.  */
+  int *local_toc_sym_map;
+
+  struct bfd_link_info *link_info;
+
+  /* Used by coff_find_nearest_line.  */
+  void * line_info;
+
+  /* A place to stash dwarf2 info for this bfd.  */
+  void * dwarf2_find_line_info;
+
+  /* The timestamp from the COFF file header.  */
+  long timestamp;
+
+  /* Copy of some of the f_flags bits in the COFF filehdr structure,
+     used by ARM code.  */
+  flagword flags;
+
+} coff_data_type;
+
+/* Tdata for pe image files.  */
+typedef struct pe_tdata
+{
+  coff_data_type coff;
+  struct internal_extra_pe_aouthdr pe_opthdr;
+  int dll;
+  int has_reloc_section;
+  bfd_boolean (*in_reloc_p) (bfd *, reloc_howto_type *);
+  flagword real_flags;
+  int target_subsystem;
+  bfd_boolean force_minimum_alignment;
+} pe_data_type;
+
+#define pe_data(bfd)		((bfd)->tdata.pe_obj_data)
+
+/* Tdata for XCOFF files.  */
+
+struct xcoff_tdata
+{
+  /* Basic COFF information.  */
+  coff_data_type coff;
+
+  /* TRUE if this is an XCOFF64 file. */
+  bfd_boolean xcoff64;
+
+  /* TRUE if a large a.out header should be generated.  */
+  bfd_boolean full_aouthdr;
+
+  /* TOC value.  */
+  bfd_vma toc;
+
+  /* Index of section holding TOC.  */
+  int sntoc;
+
+  /* Index of section holding entry point.  */
+  int snentry;
+
+  /* .text alignment from optional header.  */
+  int text_align_power;
+
+  /* .data alignment from optional header.  */
+  int data_align_power;
+
+  /* modtype from optional header.  */
+  short modtype;
+
+  /* cputype from optional header.  */
+  short cputype;
+
+  /* maxdata from optional header.  */
+  bfd_vma maxdata;
+
+  /* maxstack from optional header.  */
+  bfd_vma maxstack;
+
+  /* Used by the XCOFF backend linker.  */
+  asection **csects;
+  unsigned long *debug_indices;
+  unsigned int import_file_id;
+};
+
+#define xcoff_data(abfd) ((abfd)->tdata.xcoff_obj_data)
+
+/* We take the address of the first element of an asymbol to ensure that the
+   macro is only ever applied to an asymbol.  */
+#define coffsymbol(asymbol) ((coff_symbol_type *)(&((asymbol)->the_bfd)))
+
+/* The used_by_bfd field of a section may be set to a pointer to this
+   structure.  */
+
+struct coff_section_tdata
+{
+  /* The relocs, swapped into COFF internal form.  This may be NULL.  */
+  struct internal_reloc *relocs;
+  /* If this is TRUE, the relocs entry may not be freed.  */
+  bfd_boolean keep_relocs;
+  /* The section contents.  This may be NULL.  */
+  bfd_byte *contents;
+  /* If this is TRUE, the contents entry may not be freed.  */
+  bfd_boolean keep_contents;
+  /* Information cached by coff_find_nearest_line.  */
+  bfd_vma offset;
+  unsigned int i;
+  const char *function;
+  /* Optional information about a COMDAT entry; NULL if not COMDAT. */
+  struct coff_comdat_info *comdat;
+  int line_base;
+  /* A pointer used for .stab linking optimizations.  */
+  void * stab_info;
+  /* Available for individual backends.  */
+  void * tdata;
+};
+
+/* An accessor macro for the coff_section_tdata structure.  */
+#define coff_section_data(abfd, sec) \
+  ((struct coff_section_tdata *) (sec)->used_by_bfd)
+
+/* Tdata for sections in XCOFF files.  This is used by the linker.  */
+
+struct xcoff_section_tdata
+{
+  /* Used for XCOFF csects created by the linker; points to the real
+     XCOFF section which contains this csect.  */
+  asection *enclosing;
+  /* The lineno_count field for the enclosing section, because we are
+     going to clobber it there.  */
+  unsigned int lineno_count;
+  /* The first and one past the last symbol indices for symbols used
+     by this csect.  */
+  unsigned long first_symndx;
+  unsigned long last_symndx;
+};
+
+/* An accessor macro the xcoff_section_tdata structure.  */
+#define xcoff_section_data(abfd, sec) \
+  ((struct xcoff_section_tdata *) coff_section_data ((abfd), (sec))->tdata)
+
+/* Tdata for sections in PE files.  */
+
+struct pei_section_tdata
+{
+  /* The virtual size of the section.  */
+  bfd_size_type virt_size;
+  /* The PE section flags.  */
+  long pe_flags;
+};
+
+/* An accessor macro for the pei_section_tdata structure.  */
+#define pei_section_data(abfd, sec) \
+  ((struct pei_section_tdata *) coff_section_data ((abfd), (sec))->tdata)
+
+/* COFF linker hash table entries.  */
+
+struct coff_link_hash_entry
+{
+  struct bfd_link_hash_entry root;
+
+  /* Symbol index in output file.  Set to -1 initially.  Set to -2 if
+     there is a reloc against this symbol.  */
+  long indx;
+
+  /* Symbol type.  */
+  unsigned short type;
+
+  /* Symbol class.  */
+  unsigned char class;
+
+  /* Number of auxiliary entries.  */
+  char numaux;
+
+  /* BFD to take auxiliary entries from.  */
+  bfd *auxbfd;
+
+  /* Pointer to array of auxiliary entries, if any.  */
+  union internal_auxent *aux;
+
+  /* Flag word; legal values follow.  */
+  unsigned short coff_link_hash_flags;
+  /* Symbol is a PE section symbol.  */
+#define COFF_LINK_HASH_PE_SECTION_SYMBOL (01)
+};
+
+/* COFF linker hash table.  */
+
+struct coff_link_hash_table
+{
+  struct bfd_link_hash_table root;
+  /* A pointer to information used to link stabs in sections.  */
+  struct stab_info stab_info;
+};
+
+/* Look up an entry in a COFF linker hash table.  */
+
+#define coff_link_hash_lookup(table, string, create, copy, follow)	\
+  ((struct coff_link_hash_entry *)					\
+   bfd_link_hash_lookup (&(table)->root, (string), (create),		\
+			 (copy), (follow)))
+
+/* Traverse a COFF linker hash table.  */
+
+#define coff_link_hash_traverse(table, func, info)			\
+  (bfd_link_hash_traverse						\
+   (&(table)->root,							\
+    (bfd_boolean (*) (struct bfd_link_hash_entry *, void *)) (func), \
+    (info)))
+
+/* Get the COFF linker hash table from a link_info structure.  */
+
+#define coff_hash_table(p) ((struct coff_link_hash_table *) ((p)->hash))
+
+/* Functions in coffgen.c.  */
+extern const bfd_target *coff_object_p
+  (bfd *);
+extern struct bfd_section *coff_section_from_bfd_index
+  (bfd *, int);
+extern long coff_get_symtab_upper_bound
+  (bfd *);
+extern long coff_canonicalize_symtab
+  (bfd *, asymbol **);
+extern int coff_count_linenumbers
+  (bfd *);
+extern struct coff_symbol_struct *coff_symbol_from
+  (bfd *, asymbol *);
+extern bfd_boolean coff_renumber_symbols
+  (bfd *, int *);
+extern void coff_mangle_symbols
+  (bfd *);
+extern bfd_boolean coff_write_symbols
+  (bfd *);
+extern bfd_boolean coff_write_linenumbers
+  (bfd *);
+extern alent *coff_get_lineno
+  (bfd *, asymbol *);
+extern asymbol *coff_section_symbol
+  (bfd *, char *);
+extern bfd_boolean _bfd_coff_get_external_symbols
+  (bfd *);
+extern const char *_bfd_coff_read_string_table
+  (bfd *);
+extern bfd_boolean _bfd_coff_free_symbols
+  (bfd *);
+extern struct coff_ptr_struct *coff_get_normalized_symtab
+  (bfd *);
+extern long coff_get_reloc_upper_bound
+  (bfd *, sec_ptr);
+extern asymbol *coff_make_empty_symbol
+  (bfd *);
+extern void coff_print_symbol
+  (bfd *, void * filep, asymbol *, bfd_print_symbol_type);
+extern void coff_get_symbol_info
+  (bfd *, asymbol *, symbol_info *ret);
+extern bfd_boolean _bfd_coff_is_local_label_name
+  (bfd *, const char *);
+extern asymbol *coff_bfd_make_debug_symbol
+  (bfd *, void *, unsigned long);
+extern bfd_boolean coff_find_nearest_line
+  (bfd *, asection *, asymbol **, bfd_vma, const char **,
+   const char **, unsigned int *);
+extern bfd_boolean coff_find_inliner_info
+  (bfd *, const char **, const char **, unsigned int *);
+extern int coff_sizeof_headers
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_coff_reloc16_relax_section
+  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
+extern bfd_byte *bfd_coff_reloc16_get_relocated_section_contents
+  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+   bfd_byte *, bfd_boolean, asymbol **);
+extern bfd_vma bfd_coff_reloc16_get_value
+  (arelent *, struct bfd_link_info *, asection *);
+extern void bfd_perform_slip
+  (bfd *, unsigned int, asection *, bfd_vma);
+
+/* Functions and types in cofflink.c.  */
+
+#define STRING_SIZE_SIZE 4
+
+/* We use a hash table to merge identical enum, struct, and union
+   definitions in the linker.  */
+
+/* Information we keep for a single element (an enum value, a
+   structure or union field) in the debug merge hash table.  */
+
+struct coff_debug_merge_element
+{
+  /* Next element.  */
+  struct coff_debug_merge_element *next;
+
+  /* Name.  */
+  const char *name;
+
+  /* Type.  */
+  unsigned int type;
+
+  /* Symbol index for complex type.  */
+  long tagndx;
+};
+
+/* A linked list of debug merge entries for a given name.  */
+
+struct coff_debug_merge_type
+{
+  /* Next type with the same name.  */
+  struct coff_debug_merge_type *next;
+
+  /* Class of type.  */
+  int class;
+
+  /* Symbol index where this type is defined.  */
+  long indx;
+
+  /* List of elements.  */
+  struct coff_debug_merge_element *elements;
+};
+
+/* Information we store in the debug merge hash table.  */
+
+struct coff_debug_merge_hash_entry
+{
+  struct bfd_hash_entry root;
+
+  /* A list of types with this name.  */
+  struct coff_debug_merge_type *types;
+};
+
+/* The debug merge hash table.  */
+
+struct coff_debug_merge_hash_table
+{
+  struct bfd_hash_table root;
+};
+
+/* Initialize a COFF debug merge hash table.  */
+
+#define coff_debug_merge_hash_table_init(table) \
+  (bfd_hash_table_init (&(table)->root, _bfd_coff_debug_merge_hash_newfunc, \
+			sizeof (struct coff_debug_merge_hash_entry)))
+
+/* Free a COFF debug merge hash table.  */
+
+#define coff_debug_merge_hash_table_free(table) \
+  (bfd_hash_table_free (&(table)->root))
+
+/* Look up an entry in a COFF debug merge hash table.  */
+
+#define coff_debug_merge_hash_lookup(table, string, create, copy) \
+  ((struct coff_debug_merge_hash_entry *) \
+   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
+
+/* Information we keep for each section in the output file when doing
+   a relocatable link.  */
+
+struct coff_link_section_info
+{
+  /* The relocs to be output.  */
+  struct internal_reloc *relocs;
+  /* For each reloc against a global symbol whose index was not known
+     when the reloc was handled, the global hash table entry.  */
+  struct coff_link_hash_entry **rel_hashes;
+};
+
+/* Information that we pass around while doing the final link step.  */
+
+struct coff_final_link_info
+{
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* Used to indicate failure in traversal routine.  */
+  bfd_boolean failed;
+  /* If doing "task linking" set only during the time when we want the
+     global symbol writer to convert the storage class of defined global
+     symbols from global to static. */
+  bfd_boolean global_to_static;
+  /* Hash table for long symbol names.  */
+  struct bfd_strtab_hash *strtab;
+  /* When doing a relocatable link, an array of information kept for
+     each output section, indexed by the target_index field.  */
+  struct coff_link_section_info *section_info;
+  /* Symbol index of last C_FILE symbol (-1 if none).  */
+  long last_file_index;
+  /* Contents of last C_FILE symbol.  */
+  struct internal_syment last_file;
+  /* Symbol index of first aux entry of last .bf symbol with an empty
+     endndx field (-1 if none).  */
+  long last_bf_index;
+  /* Contents of last_bf_index aux entry.  */
+  union internal_auxent last_bf;
+  /* Hash table used to merge debug information.  */
+  struct coff_debug_merge_hash_table debug_merge;
+  /* Buffer large enough to hold swapped symbols of any input file.  */
+  struct internal_syment *internal_syms;
+  /* Buffer large enough to hold sections of symbols of any input file.  */
+  asection **sec_ptrs;
+  /* Buffer large enough to hold output indices of symbols of any
+     input file.  */
+  long *sym_indices;
+  /* Buffer large enough to hold output symbols for any input file.  */
+  bfd_byte *outsyms;
+  /* Buffer large enough to hold external line numbers for any input
+     section.  */
+  bfd_byte *linenos;
+  /* Buffer large enough to hold any input section.  */
+  bfd_byte *contents;
+  /* Buffer large enough to hold external relocs of any input section.  */
+  bfd_byte *external_relocs;
+  /* Buffer large enough to hold swapped relocs of any input section.  */
+  struct internal_reloc *internal_relocs;
+};
+
+/* Most COFF variants have no way to record the alignment of a
+   section.  This struct is used to set a specific alignment based on
+   the name of the section.  */
+
+struct coff_section_alignment_entry
+{
+  /* The section name.  */
+  const char *name;
+
+  /* This is either (unsigned int) -1, indicating that the section
+     name must match exactly, or it is the number of letters which
+     must match at the start of the name.  */
+  unsigned int comparison_length;
+
+  /* These macros may be used to fill in the first two fields in a
+     structure initialization.  */
+#define COFF_SECTION_NAME_EXACT_MATCH(name) (name), ((unsigned int) -1)
+#define COFF_SECTION_NAME_PARTIAL_MATCH(name) (name), (sizeof (name) - 1)
+
+  /* Only use this entry if the default section alignment for this
+     target is at least that much (as a power of two).  If this field
+     is COFF_ALIGNMENT_FIELD_EMPTY, it should be ignored.  */
+  unsigned int default_alignment_min;
+
+  /* Only use this entry if the default section alignment for this
+     target is no greater than this (as a power of two).  If this
+     field is COFF_ALIGNMENT_FIELD_EMPTY, it should be ignored.  */
+  unsigned int default_alignment_max;
+
+#define COFF_ALIGNMENT_FIELD_EMPTY ((unsigned int) -1)
+
+  /* The desired alignment for this section (as a power of two).  */
+  unsigned int alignment_power;
+};
+
+extern struct bfd_hash_entry *_bfd_coff_link_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+extern bfd_boolean _bfd_coff_link_hash_table_init
+  (struct coff_link_hash_table *, bfd *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int);
+extern struct bfd_link_hash_table *_bfd_coff_link_hash_table_create
+  (bfd *);
+extern const char *_bfd_coff_internal_syment_name
+  (bfd *, const struct internal_syment *, char *);
+extern bfd_boolean _bfd_coff_link_add_symbols
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_coff_final_link
+  (bfd *, struct bfd_link_info *);
+extern struct internal_reloc *_bfd_coff_read_internal_relocs
+  (bfd *, asection *, bfd_boolean, bfd_byte *, bfd_boolean,
+   struct internal_reloc *);
+extern bfd_boolean _bfd_coff_generic_relocate_section
+  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+   struct internal_reloc *, struct internal_syment *, asection **);
+extern struct bfd_hash_entry *_bfd_coff_debug_merge_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+extern bfd_boolean _bfd_coff_write_global_sym
+  (struct coff_link_hash_entry *, void *);
+extern bfd_boolean _bfd_coff_write_task_globals
+  (struct coff_link_hash_entry *, void *);
+extern bfd_boolean _bfd_coff_link_input_bfd
+  (struct coff_final_link_info *, bfd *);
+extern bfd_boolean _bfd_coff_reloc_link_order
+  (bfd *, struct coff_final_link_info *, asection *,
+   struct bfd_link_order *);
+
+
+#define coff_get_section_contents_in_window \
+  _bfd_generic_get_section_contents_in_window
+
+/* Functions in xcofflink.c.  */
+
+extern long _bfd_xcoff_get_dynamic_symtab_upper_bound
+  (bfd *);
+extern long _bfd_xcoff_canonicalize_dynamic_symtab
+  (bfd *, asymbol **);
+extern long _bfd_xcoff_get_dynamic_reloc_upper_bound
+  (bfd *);
+extern long _bfd_xcoff_canonicalize_dynamic_reloc
+  (bfd *, arelent **, asymbol **);
+extern struct bfd_link_hash_table *_bfd_xcoff_bfd_link_hash_table_create
+  (bfd *);
+extern void _bfd_xcoff_bfd_link_hash_table_free
+  (struct bfd_link_hash_table *);
+extern bfd_boolean _bfd_xcoff_bfd_link_add_symbols
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_xcoff_bfd_final_link
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_ppc_xcoff_relocate_section
+  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+   struct internal_reloc *, struct internal_syment *, asection **);
+
+/* Functions in coff-ppc.c.  FIXME: These are called be pe.em in the
+   linker, and so should start with bfd and be declared in bfd.h.  */
+
+extern bfd_boolean ppc_allocate_toc_section
+  (struct bfd_link_info *);
+extern bfd_boolean ppc_process_before_allocation
+  (bfd *, struct bfd_link_info *);
+
+/* Extracted from coffcode.h.  */
+typedef struct coff_ptr_struct
+{
+  /* Remembers the offset from the first symbol in the file for
+     this symbol. Generated by coff_renumber_symbols. */
+  unsigned int offset;
+
+  /* Should the value of this symbol be renumbered.  Used for
+     XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  */
+  unsigned int fix_value : 1;
+
+  /* Should the tag field of this symbol be renumbered.
+     Created by coff_pointerize_aux. */
+  unsigned int fix_tag : 1;
+
+  /* Should the endidx field of this symbol be renumbered.
+     Created by coff_pointerize_aux. */
+  unsigned int fix_end : 1;
+
+  /* Should the x_csect.x_scnlen field be renumbered.
+     Created by coff_pointerize_aux. */
+  unsigned int fix_scnlen : 1;
+
+  /* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the
+     index into the line number entries.  Set by coff_slurp_symbol_table.  */
+  unsigned int fix_line : 1;
+
+  /* The container for the symbol structure as read and translated
+     from the file. */
+  union
+  {
+    union internal_auxent auxent;
+    struct internal_syment syment;
+  } u;
+} combined_entry_type;
+
+
+/* Each canonical asymbol really looks like this: */
+
+typedef struct coff_symbol_struct
+{
+  /* The actual symbol which the rest of BFD works with */
+  asymbol symbol;
+
+  /* A pointer to the hidden information for this symbol */
+  combined_entry_type *native;
+
+  /* A pointer to the linenumber information for this symbol */
+  struct lineno_cache_entry *lineno;
+
+  /* Have the line numbers been relocated yet ? */
+  bfd_boolean done_lineno;
+} coff_symbol_type;
+/* COFF symbol classifications.  */
+
+enum coff_symbol_classification
+{
+  /* Global symbol.  */
+  COFF_SYMBOL_GLOBAL,
+  /* Common symbol.  */
+  COFF_SYMBOL_COMMON,
+  /* Undefined symbol.  */
+  COFF_SYMBOL_UNDEFINED,
+  /* Local symbol.  */
+  COFF_SYMBOL_LOCAL,
+  /* PE section symbol.  */
+  COFF_SYMBOL_PE_SECTION
+};
+
+typedef struct
+{
+  void (*_bfd_coff_swap_aux_in)
+    (bfd *, void *, int, int, int, int, void *);
+
+  void (*_bfd_coff_swap_sym_in)
+    (bfd *, void *, void *);
+
+  void (*_bfd_coff_swap_lineno_in)
+    (bfd *, void *, void *);
+
+  unsigned int (*_bfd_coff_swap_aux_out)
+    (bfd *, void *, int, int, int, int, void *);
+
+  unsigned int (*_bfd_coff_swap_sym_out)
+    (bfd *, void *, void *);
+
+  unsigned int (*_bfd_coff_swap_lineno_out)
+    (bfd *, void *, void *);
+
+  unsigned int (*_bfd_coff_swap_reloc_out)
+    (bfd *, void *, void *);
+
+  unsigned int (*_bfd_coff_swap_filehdr_out)
+    (bfd *, void *, void *);
+
+  unsigned int (*_bfd_coff_swap_aouthdr_out)
+    (bfd *, void *, void *);
+
+  unsigned int (*_bfd_coff_swap_scnhdr_out)
+    (bfd *, void *, void *);
+
+  unsigned int _bfd_filhsz;
+  unsigned int _bfd_aoutsz;
+  unsigned int _bfd_scnhsz;
+  unsigned int _bfd_symesz;
+  unsigned int _bfd_auxesz;
+  unsigned int _bfd_relsz;
+  unsigned int _bfd_linesz;
+  unsigned int _bfd_filnmlen;
+  bfd_boolean _bfd_coff_long_filenames;
+  bfd_boolean _bfd_coff_long_section_names;
+  unsigned int _bfd_coff_default_section_alignment_power;
+  bfd_boolean _bfd_coff_force_symnames_in_strings;
+  unsigned int _bfd_coff_debug_string_prefix_length;
+
+  void (*_bfd_coff_swap_filehdr_in)
+    (bfd *, void *, void *);
+
+  void (*_bfd_coff_swap_aouthdr_in)
+    (bfd *, void *, void *);
+
+  void (*_bfd_coff_swap_scnhdr_in)
+    (bfd *, void *, void *);
+
+  void (*_bfd_coff_swap_reloc_in)
+    (bfd *abfd, void *, void *);
+
+  bfd_boolean (*_bfd_coff_bad_format_hook)
+    (bfd *, void *);
+
+  bfd_boolean (*_bfd_coff_set_arch_mach_hook)
+    (bfd *, void *);
+
+  void * (*_bfd_coff_mkobject_hook)
+    (bfd *, void *, void *);
+
+  bfd_boolean (*_bfd_styp_to_sec_flags_hook)
+    (bfd *, void *, const char *, asection *, flagword *);
+
+  void (*_bfd_set_alignment_hook)
+    (bfd *, asection *, void *);
+
+  bfd_boolean (*_bfd_coff_slurp_symbol_table)
+    (bfd *);
+
+  bfd_boolean (*_bfd_coff_symname_in_debug)
+    (bfd *, struct internal_syment *);
+
+  bfd_boolean (*_bfd_coff_pointerize_aux_hook)
+    (bfd *, combined_entry_type *, combined_entry_type *,
+            unsigned int, combined_entry_type *);
+
+  bfd_boolean (*_bfd_coff_print_aux)
+    (bfd *, FILE *, combined_entry_type *, combined_entry_type *,
+            combined_entry_type *, unsigned int);
+
+  void (*_bfd_coff_reloc16_extra_cases)
+    (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
+           bfd_byte *, unsigned int *, unsigned int *);
+
+  int (*_bfd_coff_reloc16_estimate)
+    (bfd *, asection *, arelent *, unsigned int,
+            struct bfd_link_info *);
+
+  enum coff_symbol_classification (*_bfd_coff_classify_symbol)
+    (bfd *, struct internal_syment *);
+
+  bfd_boolean (*_bfd_coff_compute_section_file_positions)
+    (bfd *);
+
+  bfd_boolean (*_bfd_coff_start_final_link)
+    (bfd *, struct bfd_link_info *);
+
+  bfd_boolean (*_bfd_coff_relocate_section)
+    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+            struct internal_reloc *, struct internal_syment *, asection **);
+
+  reloc_howto_type *(*_bfd_coff_rtype_to_howto)
+    (bfd *, asection *, struct internal_reloc *,
+            struct coff_link_hash_entry *, struct internal_syment *,
+            bfd_vma *);
+
+  bfd_boolean (*_bfd_coff_adjust_symndx)
+    (bfd *, struct bfd_link_info *, bfd *, asection *,
+            struct internal_reloc *, bfd_boolean *);
+
+  bfd_boolean (*_bfd_coff_link_add_one_symbol)
+    (struct bfd_link_info *, bfd *, const char *, flagword,
+            asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
+            struct bfd_link_hash_entry **);
+
+  bfd_boolean (*_bfd_coff_link_output_has_begun)
+    (bfd *, struct coff_final_link_info *);
+
+  bfd_boolean (*_bfd_coff_final_link_postscript)
+    (bfd *, struct coff_final_link_info *);
+
+} bfd_coff_backend_data;
+
+#define coff_backend_info(abfd) \
+  ((bfd_coff_backend_data *) (abfd)->xvec->backend_data)
+
+#define bfd_coff_swap_aux_in(a,e,t,c,ind,num,i) \
+  ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i))
+
+#define bfd_coff_swap_sym_in(a,e,i) \
+  ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i))
+
+#define bfd_coff_swap_lineno_in(a,e,i) \
+  ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i))
+
+#define bfd_coff_swap_reloc_out(abfd, i, o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o))
+
+#define bfd_coff_swap_lineno_out(abfd, i, o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o))
+
+#define bfd_coff_swap_aux_out(a,i,t,c,ind,num,o) \
+  ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o))
+
+#define bfd_coff_swap_sym_out(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o))
+
+#define bfd_coff_swap_scnhdr_out(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o))
+
+#define bfd_coff_swap_filehdr_out(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o))
+
+#define bfd_coff_swap_aouthdr_out(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
+
+#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
+#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
+#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
+#define bfd_coff_symesz(abfd) (coff_backend_info (abfd)->_bfd_symesz)
+#define bfd_coff_auxesz(abfd) (coff_backend_info (abfd)->_bfd_auxesz)
+#define bfd_coff_relsz(abfd)  (coff_backend_info (abfd)->_bfd_relsz)
+#define bfd_coff_linesz(abfd) (coff_backend_info (abfd)->_bfd_linesz)
+#define bfd_coff_filnmlen(abfd) (coff_backend_info (abfd)->_bfd_filnmlen)
+#define bfd_coff_long_filenames(abfd) \
+  (coff_backend_info (abfd)->_bfd_coff_long_filenames)
+#define bfd_coff_long_section_names(abfd) \
+  (coff_backend_info (abfd)->_bfd_coff_long_section_names)
+#define bfd_coff_default_section_alignment_power(abfd) \
+  (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power)
+#define bfd_coff_swap_filehdr_in(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o))
+
+#define bfd_coff_swap_aouthdr_in(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o))
+
+#define bfd_coff_swap_scnhdr_in(abfd, i,o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o))
+
+#define bfd_coff_swap_reloc_in(abfd, i, o) \
+  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o))
+
+#define bfd_coff_bad_format_hook(abfd, filehdr) \
+  ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr))
+
+#define bfd_coff_set_arch_mach_hook(abfd, filehdr)\
+  ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr))
+#define bfd_coff_mkobject_hook(abfd, filehdr, aouthdr)\
+  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook)\
+   (abfd, filehdr, aouthdr))
+
+#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name, section, flags_ptr)\
+  ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook)\
+   (abfd, scnhdr, name, section, flags_ptr))
+
+#define bfd_coff_set_alignment_hook(abfd, sec, scnhdr)\
+  ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr))
+
+#define bfd_coff_slurp_symbol_table(abfd)\
+  ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd))
+
+#define bfd_coff_symname_in_debug(abfd, sym)\
+  ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym))
+
+#define bfd_coff_force_symnames_in_strings(abfd)\
+  (coff_backend_info (abfd)->_bfd_coff_force_symnames_in_strings)
+
+#define bfd_coff_debug_string_prefix_length(abfd)\
+  (coff_backend_info (abfd)->_bfd_coff_debug_string_prefix_length)
+
+#define bfd_coff_print_aux(abfd, file, base, symbol, aux, indaux)\
+  ((coff_backend_info (abfd)->_bfd_coff_print_aux)\
+   (abfd, file, base, symbol, aux, indaux))
+
+#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order,\
+                                     reloc, data, src_ptr, dst_ptr)\
+  ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\
+   (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr))
+
+#define bfd_coff_reloc16_estimate(abfd, section, reloc, shrink, link_info)\
+  ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\
+   (abfd, section, reloc, shrink, link_info))
+
+#define bfd_coff_classify_symbol(abfd, sym)\
+  ((coff_backend_info (abfd)->_bfd_coff_classify_symbol)\
+   (abfd, sym))
+
+#define bfd_coff_compute_section_file_positions(abfd)\
+  ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\
+   (abfd))
+
+#define bfd_coff_start_final_link(obfd, info)\
+  ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\
+   (obfd, info))
+#define bfd_coff_relocate_section(obfd,info,ibfd,o,con,rel,isyms,secs)\
+  ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\
+   (obfd, info, ibfd, o, con, rel, isyms, secs))
+#define bfd_coff_rtype_to_howto(abfd, sec, rel, h, sym, addendp)\
+  ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\
+   (abfd, sec, rel, h, sym, addendp))
+#define bfd_coff_adjust_symndx(obfd, info, ibfd, sec, rel, adjustedp)\
+  ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\
+   (obfd, info, ibfd, sec, rel, adjustedp))
+#define bfd_coff_link_add_one_symbol(info, abfd, name, flags, section,\
+                                     value, string, cp, coll, hashp)\
+  ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
+   (info, abfd, name, flags, section, value, string, cp, coll, hashp))
+
+#define bfd_coff_link_output_has_begun(a,p) \
+  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
+#define bfd_coff_final_link_postscript(a,p) \
+  ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a, p))
+
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -1601,6 +1601,48 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_AVR_LDI",
   "BFD_RELOC_AVR_6",
   "BFD_RELOC_AVR_6_ADIW",
+  "BFD_RELOC_AVR32_DIFF32",
+  "BFD_RELOC_AVR32_DIFF16",
+  "BFD_RELOC_AVR32_DIFF8",
+  "BFD_RELOC_AVR32_GOT32",
+  "BFD_RELOC_AVR32_GOT16",
+  "BFD_RELOC_AVR32_GOT8",
+  "BFD_RELOC_AVR32_21S",
+  "BFD_RELOC_AVR32_16U",
+  "BFD_RELOC_AVR32_16S",
+  "BFD_RELOC_AVR32_SUB5",
+  "BFD_RELOC_AVR32_8S_EXT",
+  "BFD_RELOC_AVR32_8S",
+  "BFD_RELOC_AVR32_15S",
+  "BFD_RELOC_AVR32_22H_PCREL",
+  "BFD_RELOC_AVR32_18W_PCREL",
+  "BFD_RELOC_AVR32_16B_PCREL",
+  "BFD_RELOC_AVR32_16N_PCREL",
+  "BFD_RELOC_AVR32_14UW_PCREL",
+  "BFD_RELOC_AVR32_11H_PCREL",
+  "BFD_RELOC_AVR32_10UW_PCREL",
+  "BFD_RELOC_AVR32_9H_PCREL",
+  "BFD_RELOC_AVR32_9UW_PCREL",
+  "BFD_RELOC_AVR32_GOTPC",
+  "BFD_RELOC_AVR32_GOTCALL",
+  "BFD_RELOC_AVR32_LDA_GOT",
+  "BFD_RELOC_AVR32_GOT21S",
+  "BFD_RELOC_AVR32_GOT18SW",
+  "BFD_RELOC_AVR32_GOT16S",
+  "BFD_RELOC_AVR32_32_CPENT",
+  "BFD_RELOC_AVR32_CPCALL",
+  "BFD_RELOC_AVR32_16_CP",
+  "BFD_RELOC_AVR32_9W_CP",
+  "BFD_RELOC_AVR32_ALIGN",
+  "BFD_RELOC_AVR32_14UW",
+  "BFD_RELOC_AVR32_10UW",
+  "BFD_RELOC_AVR32_10SW",
+  "BFD_RELOC_AVR32_STHH_W",
+  "BFD_RELOC_AVR32_7UW",
+  "BFD_RELOC_AVR32_6S",
+  "BFD_RELOC_AVR32_6UW",
+  "BFD_RELOC_AVR32_4UH",
+  "BFD_RELOC_AVR32_3U",
   "BFD_RELOC_390_12",
   "BFD_RELOC_390_GOT12",
   "BFD_RELOC_390_PLT32",
--- /dev/null
+++ b/bfd/libtool
@@ -0,0 +1,7871 @@
+#! /bin/bash
+
+# libtool - Provide generalized library-building support services.
+# Generated automatically by config.status (bfd) 2.18
+# Libtool was configured on host hcegtvedt:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags=""
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Whether or not to build shared libraries.
+build_libtool_libs=no
+
+# Which release of libtool.m4 was used?
+macro_version=2.2.4
+macro_revision=1.2976
+
+# Whether or not to build static libraries.
+build_old_libs=yes
+
+# What type of objects to build.
+pic_mode=default
+
+# Whether or not to optimize for fast installation.
+fast_install=needless
+
+# The host system.
+host_alias=i686-pc-linux-gnu
+host=i686-pc-linux-gnu
+host_os=linux-gnu
+
+# The build system.
+build_alias=i686-pc-linux-gnu
+build=i686-pc-linux-gnu
+build_os=linux-gnu
+
+# A sed program that does not truncate output.
+SED="/bin/sed"
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP="/bin/grep"
+
+# An ERE matcher.
+EGREP="/bin/grep -E"
+
+# A literal string matcher.
+FGREP="/bin/grep -F"
+
+# A BSD- or MS-compatible name lister.
+NM="nm"
+
+# Whether we need soft or hard links.
+LN_S="ln -s"
+
+# What is the maximum length of a command?
+max_cmd_len=805306365
+
+# Object file suffix (normally "o").
+objext=o
+
+# Executable file suffix (normally "").
+exeext=
+
+# whether the shell understands "unset".
+lt_unset=unset
+
+# turn spaces into newlines.
+SP2NL="tr \\040 \\012"
+
+# turn newlines into spaces.
+NL2SP="tr \\015\\012 \\040\\040"
+
+# How to create reloadable object files.
+reload_flag=" -r"
+reload_cmds="\$LD\$reload_flag -o \$output\$reload_objs"
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method="pass_all"
+
+# Command to use when deplibs_check_method == "file_magic".
+file_magic_cmd="\$MAGIC_CMD"
+
+# The archiver.
+AR="ar"
+AR_FLAGS="cru"
+
+# A symbol stripping program.
+STRIP="strip"
+
+# Commands used to install an old-style archive.
+RANLIB="ranlib"
+old_postinstall_cmds="chmod 644 \$oldlib~\$RANLIB \$oldlib"
+old_postuninstall_cmds=""
+
+# A C compiler.
+LTCC="gcc"
+
+# LTCC compiler flags.
+LTCFLAGS="-g -O2"
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe="sed -n -e 's/^.*[	 ]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[	 ][	 ]*\\([_A-Za-z][_A-Za-z0-9]*\\)\$/\\1 \\2 \\2/p'"
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl="sed -n -e 's/^T .* \\(.*\\)\$/extern int \\1();/p' -e 's/^[ABCDGIRSTW]* .* \\(.*\\)\$/extern char \\1;/p'"
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address="sed -n -e 's/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (void *) 0},/p' -e 's/^[ABCDGIRSTW]* \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (void *) \\&\\2},/p'"
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (void *) 0},/p' -e 's/^[ABCDGIRSTW]* \\([^ ]*\\) \\(lib[^ ]*\\)\$/  {\"\\2\", (void *) \\&\\2},/p' -e 's/^[ABCDGIRSTW]* \\([^ ]*\\) \\([^ ]*\\)\$/  {\"lib\\2\", (void *) \\&\\2},/p'"
+
+# The name of the directory that contains temporary libtool files.
+objdir=.libs
+
+# Shell to use when invoking shell scripts.
+SHELL="/bin/bash"
+
+# An echo program that does not interpret backslashes.
+ECHO="echo"
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=file
+
+# Must we lock files when doing compilation?
+need_locks="no"
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=""
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=""
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=""
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=""
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=""
+
+# Old archive suffix (normally "a").
+libext=a
+
+# Shared library suffix (normally ".so").
+shrext_cmds=".so"
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=""
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink="PATH LD_LIBRARY_PATH LD_RUN_PATH GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=no
+
+# Do we need a version for libraries?
+need_version=no
+
+# Library versioning type.
+version_type=linux
+
+# Shared library runtime path variable.
+runpath_var=LD_RUN_PATH
+
+# Shared library path variable.
+shlibpath_var=LD_LIBRARY_PATH
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=no
+
+# Format of library name prefix.
+libname_spec="lib\$name"
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec="\${libname}\${release}\${shared_ext}\$versuffix \${libname}\${release}\${shared_ext}\$major \$libname\${shared_ext}"
+
+# The coded name of the library, if different from the real name.
+soname_spec="\${libname}\${release}\${shared_ext}\$major"
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=""
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=""
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds="PATH=\\\"\\\$PATH:/sbin\\\" ldconfig -n \$libdir"
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=""
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=yes
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec="/usr/lib/gcc/i486-linux-gnu/4.2.4 /usr/lib /lib"
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec="/lib /usr/lib /lib/i486-linux-gnu /usr/lib/i486-linux-gnu /usr/lib/alsa-lib /usr/local/lib "
+
+# Whether dlopen is supported.
+dlopen_support=unknown
+
+# Whether dlopen of programs is supported.
+dlopen_self=unknown
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=unknown
+
+# Commands to strip libraries.
+old_striplib="strip --strip-debug"
+striplib="strip --strip-unneeded"
+
+
+# The linker used to build libraries.
+LD="ld"
+
+# Commands used to build an old-style archive.
+old_archive_cmds="\$AR \$AR_FLAGS \$oldlib\$oldobjs~\$RANLIB \$oldlib"
+
+# A language specific compiler.
+CC="gcc"
+
+# Is the compiler the GNU compiler?
+with_gcc=yes
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=" -fno-builtin"
+
+# How to pass a linker flag through the compiler.
+wl="-Wl,"
+
+# Additional compiler flags for building library objects.
+pic_flag=" -fPIC -DPIC"
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag="-static"
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o="yes"
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=yes
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=no
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec="\${wl}--export-dynamic"
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec="\${wl}--whole-archive\$convenience \${wl}--no-whole-archive"
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object="no"
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=""
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=""
+
+# Commands used to build a shared archive.
+archive_cmds="\$CC -shared \$libobjs \$deplibs \$compiler_flags \${wl}-soname \$wl\$soname -o \$lib"
+archive_expsym_cmds="echo \\\"{ global:\\\" > \$output_objdir/\$libname.ver~
+	    cat \$export_symbols | sed -e \\\"s/\\\\(.*\\\\)/\\\\1;/\\\" >> \$output_objdir/\$libname.ver~
+	    echo \\\"local: *; };\\\" >> \$output_objdir/\$libname.ver~
+	    \$CC -shared \$libobjs \$deplibs \$compiler_flags \${wl}-soname \$wl\$soname \${wl}-version-script \${wl}\$output_objdir/\$libname.ver -o \$lib"
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=""
+module_expsym_cmds=""
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld="yes"
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=""
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=""
+
+# Flag to hardcode $libdir into a binary during linking.
+# This must work even if $libdir does not exist
+hardcode_libdir_flag_spec="\${wl}-rpath \${wl}\$libdir"
+
+# If ld is used when linking, flag to hardcode $libdir into a binary
+# during linking.  This must work even if $libdir does not exist.
+hardcode_libdir_flag_spec_ld=""
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=""
+
+# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=no
+
+# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting ${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=no
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=no
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=unsupported
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=no
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=no
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=unknown
+
+# Fix the shell variable $srcfile for the compiler.
+fix_srcfile_path=""
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=no
+
+# The commands to list exported symbols.
+export_symbols_cmds="\$NM \$libobjs \$convenience | \$global_symbol_pipe | \$SED 's/.* //' | sort | uniq > \$export_symbols"
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms="_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*"
+
+# Symbols that must always be exported.
+include_expsyms=""
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=""
+
+# Specify filename containing input files.
+file_list_spec=""
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=immediate
+
+# ### END LIBTOOL CONFIG
+
+# Generated from ltmain.m4sh; do not edit by hand
+
+# ltmain.sh (GNU libtool 1.2435 2007/03/18 18:44:42) 2.1a
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#     --config             show all configuration variables
+#     --debug              enable verbose shell tracing
+# -n, --dry-run            display commands without modifying any files
+#     --features           display basic configuration information and exit
+#     --mode=MODE          use operation mode MODE
+#     --preserve-dup-deps  don't remove duplicate dependency libraries
+#     --quiet, --silent    don't print informational messages
+#     --tag=TAG            use configuration variables from tag TAG
+# -v, --verbose            print informational messages (default)
+#     --version            print version information
+# -h, --help               print short or long help message
+#
+# MODE must be one of the following:
+#
+#       clean              remove files from the build directory
+#       compile            compile a source file into a libtool object
+#       execute            automatically set library path, then run a program
+#       finish             complete the installation of libtool libraries
+#       install            install libraries or executables
+#       link               create a library or an executable
+#       uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#       host-triplet:	$host
+#       shell:		$SHELL
+#       compiler:		$LTCC
+#       compiler flags:		$LTCFLAGS
+#       linker:		$LD (gnu? $with_gnu_ld)
+#       $progname:		(GNU libtool 1.2435 2007/03/18 18:44:42) 2.1a
+#       automake:		$automake_version
+#       autoconf:		$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION=2.1a
+TIMESTAMP=" 1.2435 2007/03/18 18:44:42"
+package_revision=1.2435
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# NLS nuisances: We save the old values to restore during execute mode.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+for lt_var in LANG LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	fi"
+done
+
+$lt_unset CDPATH
+
+
+
+
+
+: ${CP="cp -f"}
+: ${ECHO="echo"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
+: ${LN_S="ln -s"}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SED="/bin/sed"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+# In the unlikely event $progname began with a '-', it would play havoc with
+# func_echo (imagine progname=-n), so we prepend ./ in that case:
+progname=`$ECHO "X$progpath" | $Xsed -e "$basename" -e 's,^-,./-,'`
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=`$ECHO "X$progpath" | $Xsed -e "$dirname"`
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=:
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"}
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $ECHO "$progname${mode+: }$mode: warning: "${1+"$@"} 1>&2
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "X$my_directory_path" | $Xsed -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "X$my_dir_list" | $Xsed -e 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "X$my_tmpdir" | $Xsed
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "X$1" | $Xsed -e "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "X$1" | $Xsed \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $SED -n '/^# Usage:/,/# -h/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    $ECHO
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help
+# Echo long help message to standard output and exit.
+func_help ()
+{
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
+	p
+     }' < "$progpath"
+    exit $?
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    func_error "missing argument for $1"
+    exit_cmd=exit
+}
+
+exit_cmd=:
+
+
+
+
+
+# Check that we have a working $ECHO.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t'; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell, and then maybe $ECHO will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+magic="%%%MAGIC variable%%%"
+
+
+# Global variables.
+# $mode is unset
+nonopt=
+execute_dlfiles=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+opt_dry_run=false
+opt_duplicate_deps=false
+opt_silent=false
+opt_debug=:
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    $ECHO "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $ECHO "enable shared libraries"
+    else
+      $ECHO "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $ECHO "enable static libraries"
+    else
+      $ECHO "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$mode'"
+        ;;
+    esac
+
+    $ECHO
+    $ECHO "Try \`$progname --help' for more information about other modes."
+
+    exit $?
+}
+
+# Generated shell functions inserted here.
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $* ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1+=\$2"
+}
+# Generated shell functions inserted here.
+
+
+# Parse options once, thoroughly.  This comes as soon as possible in
+# the script to make things like `libtool --version' happen quickly.
+{
+
+  # Shorthand for --mode=foo, only valid as the first argument
+  case $1 in
+  clean|clea|cle|cl)
+    shift; set dummy --mode clean ${1+"$@"}; shift
+    ;;
+  compile|compil|compi|comp|com|co|c)
+    shift; set dummy --mode compile ${1+"$@"}; shift
+    ;;
+  execute|execut|execu|exec|exe|ex|e)
+    shift; set dummy --mode execute ${1+"$@"}; shift
+    ;;
+  finish|finis|fini|fin|fi|f)
+    shift; set dummy --mode finish ${1+"$@"}; shift
+    ;;
+  install|instal|insta|inst|ins|in|i)
+    shift; set dummy --mode install ${1+"$@"}; shift
+    ;;
+  link|lin|li|l)
+    shift; set dummy --mode link ${1+"$@"}; shift
+    ;;
+  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+    shift; set dummy --mode uninstall ${1+"$@"}; shift
+    ;;
+  esac
+
+  # Parse non-mode specific arguments:
+  while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+      --config)		func_config 					;;
+
+      --debug)		preserve_args="$preserve_args $opt"
+	    		func_echo "enabling shell trace mode"
+	    		opt_debug='set -x'
+			$opt_debug
+			;;
+
+      -dlopen)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			execute_dlfiles="$execute_dlfiles $1"
+			shift
+			;;
+
+      --dry-run | -n)	opt_dry_run=:					;;
+      --features)       func_features					;;
+      --finish)		mode="finish"					;;
+
+      --mode)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+	    		case $1 in
+			  # Valid mode arguments:
+			  clean)	;;
+			  compile)	;;
+			  execute)	;;
+			  finish)	;;
+			  install)	;;
+			  link)		;;
+			  relink)	;;
+			  uninstall)	;;
+
+			  # Catch anything else as an error
+			  *) func_error "invalid argument for $opt"
+			     exit_cmd=exit
+			     break
+			     ;;
+		        esac
+
+	    		mode="$1"
+			shift
+			;;
+
+      --preserve-dup-deps)
+      			opt_duplicate_deps=:				;;
+
+      --quiet|--silent)	preserve_args="$preserve_args $opt"
+	    		opt_silent=:
+			;;
+
+      --verbose| -v)	preserve_args="$preserve_args $opt"
+	    		opt_silent=false
+			;;
+
+      --tag)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			preserve_args="$preserve_args $opt $1"
+			func_enable_tag "$1"	# tagname is set here
+			shift
+			;;
+
+      # Separate optargs to long options:
+      -dlopen=*|--mode=*|--tag=*)
+			func_opt_split "$opt"
+			set dummy "$func_opt_split_opt" "$func_opt_split_arg" ${1+"$@"}
+			shift
+			;;
+
+      -\?|-h)		func_usage					;;
+      --help)		opt_help=:					;;
+      --version)	func_version					;;
+
+      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
+
+      *)		nonopt="$opt"
+      			break
+			;;
+    esac
+  done
+
+  # Now that we've collected a possible --mode arg, show help if necessary
+  $opt_help && func_mode_help
+
+  case $host in
+    *cygwin* | *mingw* | *pw32*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps
+      ;;
+  esac
+
+  # Having warned about all mis-specified options, bail out if
+  # anything was wrong.
+  $exit_cmd $EXIT_FAILURE
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+{
+  # Sanity checks first:
+  func_check_version_match
+
+  if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+    func_fatal_configuration "not configured to build any kind of library"
+  fi
+
+  test -z "$mode" && func_fatal_error "error: you must specify a MODE."
+
+
+  # Darwin sucks
+  eval std_shrext=\"$shrext_cmds\"
+
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    func_error "unrecognized option \`-dlopen'"
+    $ECHO "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+}
+
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    $SED -e 4q "$1" 2>/dev/null \
+      | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -r "$1" && exec 5<&1 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 1<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_lalib_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+        func_quote_for_eval "$arg"
+	CC_quoted="$CC_quoted $func_quote_for_eval_result"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_quote_for_eval "$arg"
+	      CC_quoted="$CC_quoted $func_quote_for_eval_result"
+	    done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_echo "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_echo "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_echo "extracting global C symbols from \`$progfile'"
+	    $opt_dry_run || eval "$NM $progfile | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin | *mingw* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_echo "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+	  $opt_dry_run || {
+	    eval '$ECHO ": $name " >> "$nlist"'
+	    eval "$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	  }
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    $ECHO '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+"
+	  case $host in
+	  *cygwin* | *mingw* )
+	    $ECHO >> "$output_objdir/$my_dlsyms" "\
+/* DATA imports from DLLs on WIN32 con't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs.  */"
+	    lt_dlsym_const= ;;
+	  *osf5*)
+	    echo >> "$output_objdir/$my_dlsyms" "\
+/* This system does not cope well with relocations in const data */"
+	    lt_dlsym_const= ;;
+	  *)
+	    lt_dlsym_const=const ;;
+	  esac
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+extern $lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+$lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+  	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) symtab_cflags="$symtab_cflags $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \$f_ex_an_ar_oldlib)" 'exit $?'
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  extracted_serial=`expr $extracted_serial + 1`
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_echo "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename $darwin_archive`
+	  darwin_arches=`lipo -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_echo "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      lipo -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print| xargs basename | sort -u | $NL2SP`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      lipo -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      mv -f "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          pie_flag="$pie_flag $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_quote_for_eval "$arg"
+	    lastarg="$lastarg $func_quote_for_eval_result"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_quote_for_eval "$lastarg"
+      base_compile="$base_compile $func_quote_for_eval_result"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    xform='[cCFSifmso]'
+    case $libobj in
+    *.ada) xform=ada ;;
+    *.adb) xform=adb ;;
+    *.ads) xform=ads ;;
+    *.asm) xform=asm ;;
+    *.c++) xform=c++ ;;
+    *.cc) xform=cc ;;
+    *.ii) xform=ii ;;
+    *.class) xform=class ;;
+    *.cpp) xform=cpp ;;
+    *.cxx) xform=cxx ;;
+    *.[fF][09]?) xform='[fF][09].' ;;
+    *.for) xform=for ;;
+    *.java) xform=java ;;
+    *.obj) xform=obj ;;
+    esac
+
+    libobj=`$ECHO "X$libobj" | $Xsed -e "s/\.$xform$/.lo/"`
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"' 	&()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_basename "$obj"
+    objname="$func_basename_result"
+    func_dirname "$obj" "/" ""
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    trap "$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE" 1 2 15
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+      removelist="$removelist $output_obj $lockfile"
+      trap "$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE" 1 2 15
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    $opt_dry_run || $RM "$libobj" "${libobj}T"
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      $opt_dry_run || $RM "$lobj" "$output_obj"
+
+      func_show_eval "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      $opt_dry_run || $RM "$obj" "$output_obj"
+      func_show_eval "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = compile && func_mode_compile ${1+"$@"}
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_p "$file"; then
+	  func_source "$file"
+
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_quote_for_eval "$file"
+      args="$args $func_quote_for_eval_result"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	$ECHO "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    $ECHO "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $ECHO "   $libdir"
+    done
+    $ECHO
+    $ECHO "If you ever happen to want to link against installed libraries"
+    $ECHO "in a given directory, LIBDIR, you must either use libtool, and"
+    $ECHO "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $ECHO "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $ECHO "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $ECHO "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $ECHO "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $ECHO "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $ECHO "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $ECHO
+
+    $ECHO "See any operating system documentation about shared libraries for"
+    case $host in
+      solaris2.[6789]|solaris2.1[0-9])
+        $ECHO "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	$ECHO "pages."
+	;;
+      *)
+        $ECHO "more information, such as the ld(1) and ld.so(8) manual pages."
+        ;;
+    esac
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $ECHO "X$nonopt" | $GREP shtool >/dev/null; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    install_prog="$install_prog$func_quote_for_eval_result"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+      	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      install_prog="$install_prog $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname "$dest" "" "."
+      destdir="$func_dirname_result"
+      func_basename "$dest"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "X$destdir" | $Xsed -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin*|*mingw*)
+	    func_stripname '' '.exe' "$file"
+	    wrapper=$func_stripname_result
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	    # See comment for -static flag below, for more details.
+	    func_append compile_command " $link_static_flag"
+	    func_append finalize_command " $link_static_flag"
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) deplibs="$deplibs $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+   	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+  	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  weak_libs="$weak_libs $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	# The effects of -all-static are defined in a previous loop.
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname '-L' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+	  testbindir=`$ECHO "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) new_inherited_linker_flags="$new_inherited_linker_flags $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $wl$func_quote_for_eval_result"
+	  linker_flags="$linker_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -F/path gives path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_duplicate_deps ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link) libs="$deplibs %DEPLIBS% $dependency_libs" ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  case $lib in
+	  *.la)	func_source "$lib" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+            deplib_base=`$ECHO "X$deplib" | $Xsed -e "$basename"`
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) deplibs="$deplibs $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  for searchdir in $newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    dir=$func_stripname_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"X$deplib\"" 2>/dev/null | $Xsed -e 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		$ECHO
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because the file extensions .$libext of this argument makes me believe"
+		$ECHO "*** that it is just a static archive that I should not use here."
+	      else
+		$ECHO
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "X$inherited_linker_flags" | $Xsed -e 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) new_inherited_linker_flags="$new_inherited_linker_flags $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO "X $dependency_libs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "prog,link"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags $inherited_linker_flags"
+	fi
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    deplibs="$deplib $deplibs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	    # Keep a list of preopened convenience libraries to check
+	    # that they are being used correctly in the link pass.
+	    test -z "$libdir" && \
+		dlpreconveniencelibs="$dlpreconveniencelibs $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         newlib_search_path="$newlib_search_path $func_stripname_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) temp_rpath="$temp_rpath$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw*)
+	      # No point in relinking DLLs because paths are not encoded
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    $ECHO
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw*)
+		major=`expr $current - $age`
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_echo "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_echo "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  $ECHO
+			  $ECHO "*** And there doesn't seem to be a static archive available"
+			  $ECHO "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $ECHO
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** I have the capability to make that library automatically link in when"
+	    $ECHO "*** you link to this library.  But I can only do this if you have a"
+	    $ECHO "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $ECHO "*** But as you try to build a module library, libtool will still create "
+	      $ECHO "*** a static module, that should work as long as the dlopening application"
+	      $ECHO "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$ECHO
+		$ECHO "*** However, this would only work if libtool was able to extract symbol"
+		$ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$ECHO "*** not find such a program.  So, this module is probably useless."
+		$ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_dirname "$deplib" "" "."
+		dir="$func_dirname_result"
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`otool -L $depdepl | $SED -n -e '3q;2,2p' | $SED -e 's/(.*//'`
+		      darwin_install_name=`$ECHO $darwin_install_name`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`otool64 -L $depdepl | $SED -n -e '3q;2,2p' | $SED -e 's/(.*//'`
+                          darwin_install_name=`$ECHO $darwin_install_name`
+                      fi
+		      compiler_flags="$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      linker_flags="$linker_flags -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      test -n "$deplibs" && \
+	func_warning "\`-l' and \`-L' are ignored for archives"
+
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  $ECHO
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows|none)
+	    current=`expr $number_major + $number_minor`
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    current=`expr $number_major + $number_minor - 1`
+	    age="$number_minor"
+	    revision="$number_minor"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  major=.`expr $current - $age`
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  minor_current=`expr $current + 1`
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  major=`expr $current - $age + 1`
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    iface=`expr $revision - $loop`
+	    loop=`expr $loop - 1`
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  major=.`expr $current - $age`
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  major=.`expr $current - $age`
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    iface=`expr $current - $loop`
+	    loop=`expr $loop - 1`
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  major=`expr $current - $age`
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      libobjs="$libobjs $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "X$lib_search_path " | $Xsed -e "s% $path % %g"`
+      #	deplibs=`$ECHO "X$deplibs " | $Xsed -e "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "X$dependency_libs " | $Xsed -e "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+ 	    ;;
+ 	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      name=`expr $i : '-l\(.*\)'`
+	      # If $name is empty we are operating on a -L argument.
+	      if test "$name" != "" && test "$name" != "0"; then
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $ECHO
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    $ECHO "*** I have the capability to make that library automatically link in when"
+		    $ECHO "*** you link to this library.  But I can only do this if you have a"
+		    $ECHO "*** shared version of the library, which I believe you do not have"
+		    $ECHO "*** because a test_compile did reveal that the linker did not use it for"
+		    $ECHO "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+	      else
+		newdeplibs="$newdeplibs $i"
+	      fi
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      name=`expr $i : '-l\(.*\)'`
+	      # If $name is empty we are operating on a -L argument.
+	      if test "$name" != "" && test "$name" != "0"; then
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $ECHO
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      $ECHO "*** I have the capability to make that library automatically link in when"
+		      $ECHO "*** you link to this library.  But I can only do this if you have a"
+		      $ECHO "*** shared version of the library, which you do not appear to have"
+		      $ECHO "*** because a test_compile did reveal that the linker did not use this one"
+		      $ECHO "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $ECHO
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $ECHO "*** make it link in!  You will probably need to install it or some"
+		  $ECHO "*** library that it depends on before this library will be fully"
+		  $ECHO "*** functional.  Installing it before continuing would be even better."
+		fi
+	      else
+		newdeplibs="$newdeplibs $i"
+	      fi
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    name=`expr $a_deplib : '-l\(.*\)'`
+	    # If $name is empty we are operating on a -L argument.
+	    if test "$name" != "" && test  "$name" != "0"; then
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	    else
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	    fi
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    name=`expr $a_deplib : '-l\(.*\)'`
+	    # If $name is empty we are operating on a -L argument.
+	    if test -n "$name" && test "$name" != "0"; then
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"X$potent_lib\"" 2>/dev/null | $Xsed -e 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	    else
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	    fi
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO "X $deplibs" | $Xsed \
+	      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO "X $tmp_deplibs" | $Xsed -e "s,$i,,"`
+	    done
+	  fi
+	  if $ECHO "X $tmp_deplibs" | $Xsed -e 's/[ 	]//g' |
+	     $GREP . >/dev/null; then
+	    $ECHO
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $ECHO "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $ECHO "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $ECHO "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $ECHO
+	    $ECHO "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $ECHO "*** a static module, that should work as long as the dlopening"
+	    $ECHO "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $ECHO
+	      $ECHO "*** However, this would only work if libtool was able to extract symbol"
+	      $ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $ECHO "*** not find such a program.  So, this module is probably useless."
+	      $ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $ECHO "*** The inter-library dependencies that have been dropped here will be"
+	    $ECHO "*** automatically added whenever a program is linked with this library"
+	    $ECHO "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $ECHO
+	      $ECHO "*** Since this library must not contain undefined symbols,"
+	      $ECHO "*** because either the platform does not support them or"
+	      $ECHO "*** it was explicitly requested with -no-undefined,"
+	      $ECHO "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO "X $deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  delfiles="$delfiles $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_echo "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      if len=`expr "X$cmd" : ".*"` &&
+	       test "$len" -le "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_echo "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_echo "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    tmp_deplibs="$tmp_deplibs $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   len=`expr "X$test_cmds" : ".*" 2>/dev/null` &&
+	   test "$len" -le "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$ECHO "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_echo "creating GNU ld script: $output"
+	    $ECHO 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    $ECHO ')' >> $output
+	    delfiles="$delfiles $output"
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_echo "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    delfiles="$delfiles $output"
+	    output=$firstobj\"$file_list_spec$output\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_echo "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		eval test_cmds=\"$reload_cmds $objlist $last_robj\"
+		if test "X$objlist" = X ||
+		   { len=`expr "X$test_cmds" : ".*" 2>/dev/null` &&
+		     test "$len" -le "$max_cmd_len"; }; then
+		  objlist="$objlist $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  k=`expr $k + 1`
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=$obj
+		  len=1
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+
+	      # Set up a command to remove the reloadable object files
+	      # after they are used.
+	      i=0
+	      while test "$i" -lt "$k"
+	      do
+		i=`expr $i + 1`
+		delfiles="$delfiles $output_objdir/$output_la-${i}.$objext"
+	      done
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_echo "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_echo "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_echo "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  libobjs="$libobjs $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      test -n "$deplibs" && \
+	func_warning "\`-l' and \`-L' are ignored for objects"
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "X$tmp_whole_archive_flags" | $Xsed -e 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      compile_command="$compile_command ${wl}-bind_at_load"
+	      finalize_command="$finalize_command ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      # Now create the wrapper script.
+      func_echo "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $ECHO for shipping.
+      if test "X$ECHO" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$ECHO "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$ECHO "X$ECHO" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    output_name=`basename $output`
+	    output_path=`dirname $output`
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    cat > $cwrappersource <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "/bin/sh $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat >> $cwrappersource<<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+/* -DDEBUG is fairly common in CFLAGS.  */
+#undef DEBUG
+#if defined DEBUGWRAPPER
+# define DEBUG(format, ...) fprintf(stderr, format, __VA_ARGS__)
+#else
+# define DEBUG(format, ...)
+#endif
+
+const char *program_name = NULL;
+
+void * xmalloc (size_t num);
+char * xstrdup (const char *string);
+const char * base_name (const char *name);
+char * find_executable(const char *wrapper);
+int    check_executable(const char *path);
+char * strendzap(char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  DEBUG("(main) argv[0]      : %s\n",argv[0]);
+  DEBUG("(main) program_name : %s\n",program_name);
+  newargz = XMALLOC(char *, argc+2);
+EOF
+
+	    cat >> $cwrappersource <<EOF
+  newargz[0] = (char *) xstrdup("$SHELL");
+EOF
+
+	    cat >> $cwrappersource <<"EOF"
+  newargz[1] = find_executable(argv[0]);
+  if (newargz[1] == NULL)
+    lt_fatal("Couldn't find %s", argv[0]);
+  DEBUG("(main) found exe at : %s\n",newargz[1]);
+  /* we know the script has the same name, without the .exe */
+  /* so make sure newargz[1] doesn't end in .exe */
+  strendzap(newargz[1],".exe");
+  for (i = 1; i < argc; i++)
+    newargz[i+1] = xstrdup(argv[i]);
+  newargz[argc+1] = NULL;
+
+  for (i=0; i<argc+1; i++)
+  {
+    DEBUG("(main) newargz[%d]   : %s\n",i,newargz[i]);
+    ;
+  }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat >> $cwrappersource <<EOF
+  execv("$SHELL",(char const **)newargz);
+EOF
+	      ;;
+	      *)
+		cat >> $cwrappersource <<EOF
+  execv("$SHELL",newargz);
+EOF
+	      ;;
+	    esac
+
+	    cat >> $cwrappersource <<"EOF"
+  return 127;
+}
+
+void *
+xmalloc (size_t num)
+{
+  void * p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1), string) : NULL
+;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char)name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable(const char * path)
+{
+  struct stat st;
+
+  DEBUG("(check_executable)  : %s\n", path ? (*path ? path : "EMPTY!") : "NULL!");
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0) &&
+      (
+	/* MinGW & native WIN32 do not support S_IXOTH or S_IXGRP */
+#if defined (S_IXOTH)
+       ((st.st_mode & S_IXOTH) == S_IXOTH) ||
+#endif
+#if defined (S_IXGRP)
+       ((st.st_mode & S_IXGRP) == S_IXGRP) ||
+#endif
+       ((st.st_mode & S_IXUSR) == S_IXUSR))
+      )
+    return 1;
+  else
+    return 0;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise */
+char *
+find_executable (const char* wrapper)
+{
+  int has_slash = 0;
+  const char* p;
+  const char* p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char* concat_name;
+
+  DEBUG("(find_executable)  : %s\n", wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!");
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char)wrapper[0]) && wrapper[1] == ':')
+  {
+    concat_name = xstrdup (wrapper);
+    if (check_executable(concat_name))
+      return concat_name;
+    XFREE(concat_name);
+  }
+  else
+  {
+#endif
+    if (IS_DIR_SEPARATOR (wrapper[0]))
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable(concat_name))
+	return concat_name;
+      XFREE(concat_name);
+    }
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+    {
+      has_slash = 1;
+      break;
+    }
+  if (!has_slash)
+  {
+    /* no slashes; search PATH */
+    const char* path = getenv ("PATH");
+    if (path != NULL)
+    {
+      for (p = path; *p; p = p_next)
+      {
+	const char* q;
+	size_t p_len;
+	for (q = p; *q; q++)
+	  if (IS_PATH_SEPARATOR(*q))
+	    break;
+	p_len = q - p;
+	p_next = (*q == '\0' ? q : q + 1);
+	if (p_len == 0)
+	{
+	  /* empty path: current directory */
+	  if (getcwd (tmp, LT_PATHMAX) == NULL)
+	    lt_fatal ("getcwd failed");
+	  tmp_len = strlen(tmp);
+	  concat_name = XMALLOC(char, tmp_len + 1 + strlen(wrapper) + 1);
+	  memcpy (concat_name, tmp, tmp_len);
+	  concat_name[tmp_len] = '/';
+	  strcpy (concat_name + tmp_len + 1, wrapper);
+	}
+	else
+	{
+	  concat_name = XMALLOC(char, p_len + 1 + strlen(wrapper) + 1);
+	  memcpy (concat_name, p, p_len);
+	  concat_name[p_len] = '/';
+	  strcpy (concat_name + p_len + 1, wrapper);
+	}
+	if (check_executable(concat_name))
+	  return concat_name;
+	XFREE(concat_name);
+      }
+    }
+    /* not found in PATH; assume curdir */
+  }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen(tmp);
+  concat_name = XMALLOC(char, tmp_len + 1 + strlen(wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable(concat_name))
+    return concat_name;
+  XFREE(concat_name);
+  return NULL;
+}
+
+char *
+strendzap(char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert(str != NULL);
+  assert(pat != NULL);
+
+  len = strlen(str);
+  patlen = strlen(pat);
+
+  if (patlen <= len)
+  {
+    str += len - patlen;
+    if (strcmp(str, pat) == 0)
+      *str = '\0';
+  }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char * mode,
+	  const char * message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+EOF
+	  # we should really use a build-platform specific compiler
+	  # here, but OTOH, the wrappers (shell script and this C one)
+	  # are only useful if you want to execute the "real" binary.
+	  # Since the "real" binary is built for $host, then this
+	  # wrapper might as well be built for $host, too.
+	  $opt_dry_run || $LTCC $LTCFLAGS -s -o $cwrapper $cwrappersource
+	  ;;
+	esac
+	$RM $output
+	trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	$ECHO > $output "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    ECHO=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`{ \$ECHO '\t'; } 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$ECHO works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$ECHO will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$ECHO >> $output "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO >> $output "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO >> $output "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO >> $output "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO >> $output "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO >> $output "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $ECHO >> $output "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$ECHO >> $output "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2*)
+	  $ECHO >> $output "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $ECHO >> $output "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$ECHO >> $output "\
+      \$ECHO \"\$0: cannot exec \$program \$*\"
+      exit 1
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    $ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+	chmod +x $output
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    oldobjs="$oldobjs $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  oldobjs="$oldobjs $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $ECHO "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		counter=`expr $counter + 1`
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+	eval cmds=\"$old_archive_cmds\"
+
+	if len=`expr "X$cmds" : ".*" 2>/dev/null` &&
+	   test "$len" -le "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_echo "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  for obj in $save_oldobjs
+	  do
+	    oldobjs="$objlist $obj"
+	    objlist="$objlist $obj"
+	    eval test_cmds=\"$old_archive_cmds\"
+	    if len=`expr "X$test_cmds" : ".*" 2>/dev/null` &&
+	       test "$len" -le "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_echo "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlfiles="$newdlfiles $libdir/$name"
+		;;
+	      *) newdlfiles="$newdlfiles $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlprefiles="$newdlprefiles $libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$mode" = link || test "$mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) RM="$RM $arg"; rmforce=yes ;;
+      -*) RM="$RM $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    relink_command=
+	    func_source $dir/$noexename
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$mode" = uninstall || test "$mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -312,6 +312,7 @@ ALL_MACHINES = \
 	cpu-arc.lo \
 	cpu-arm.lo \
 	cpu-avr.lo \
+	cpu-avr32.lo \
 	cpu-bfin.lo \
 	cpu-cr16.lo \
 	cpu-cr16c.lo \
@@ -493,6 +494,7 @@ BFD32_BACKENDS = \
 	elf32-arc.lo \
 	elf32-arm.lo \
 	elf32-avr.lo \
+	elf32-avr32.lo \
 	elf32-bfin.lo \
 	elf32-cr16.lo \
 	elf32-cr16c.lo \
@@ -1908,6 +1910,10 @@ elf32-cr16.lo: elf32-cr16.c $(INCDIR)/fi
   $(INCDIR)/hashtab.h $(INCDIR)/libiberty.h elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/elf/cr16.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
+elf32-avr32.lo: elf32-avr32.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/avr32.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-cr16c.lo: elf32-cr16c.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/cr16c.h \
   $(INCDIR)/elf/reloc-macros.h elf-bfd.h $(INCDIR)/elf/common.h \
--- /dev/null
+++ b/bfd/po/Makefile.in
@@ -0,0 +1,297 @@
+# Makefile for program source directory in GNU NLS utilities package.
+# Copyright (C) 1995, 1996, 1997 by Ulrich Drepper <drepper@gnu.ai.mit.edu>
+# Copyright 2001, 2003, 2006 Free Software Foundation, Inc.
+#
+# This file may be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+PACKAGE = bfd
+VERSION = 2.18
+
+SHELL = /bin/sh
+
+
+srcdir = .
+top_srcdir = ..
+
+top_builddir = ..
+
+prefix = /usr
+exec_prefix = ${prefix}
+datadir = $(prefix)/share
+localedir = $(datadir)/locale
+gnulocaledir = $(prefix)/share/locale
+gettextsrcdir = $(prefix)/share/gettext/po
+subdir = po
+
+DESTDIR =
+
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+MKINSTALLDIRS = $(top_builddir)/./../mkinstalldirs
+
+CC = gcc
+GENCAT = gencat
+GMSGFMT = PATH=../src:$$PATH /usr/bin/msgfmt
+MSGFMT = /usr/bin/msgfmt
+XGETTEXT = PATH=../src:$$PATH /usr/bin/xgettext
+MSGMERGE = PATH=../src:$$PATH msgmerge
+
+DEFS = -DHAVE_CONFIG_H
+CFLAGS = -g -O2
+CPPFLAGS = 
+
+INCLUDES = -I.. -I$(top_srcdir)/intl
+
+COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS)
+
+SOURCES = cat-id-tbl.c
+POFILES = @POFILES@
+GMOFILES = @GMOFILES@
+DISTFILES = ChangeLog Makefile.in.in SRC-POTFILES.in BLD-POTFILES.in $(PACKAGE).pot \
+stamp-cat-id $(POFILES) $(GMOFILES) $(SOURCES)
+
+# Note - the following line gets processed by bfd/configure and amended
+# to contain the full list of source dir POTFILES.
+SRC-POTFILES = \
+
+# Note - the following line gets processed by bfd/configure and amended
+# to contain the full list of build dir POTFILES.
+BLD-POTFILES = \
+
+CATALOGS =  da.gmo es.gmo fr.gmo ja.gmo ro.gmo rw.gmo sv.gmo tr.gmo vi.gmo zh_CN.gmo da.gmo es.gmo fr.gmo ja.gmo ro.gmo rw.gmo sv.gmo tr.gmo vi.gmo zh_CN.gmo
+CATOBJEXT = .gmo
+INSTOBJEXT = .mo
+
+.SUFFIXES:
+.SUFFIXES: .c .o .po .pox .gmo .mo .msg .cat
+
+.c.o:
+	$(COMPILE) $<
+
+.po.pox:
+	$(MAKE) $(PACKAGE).pot
+	$(MSGMERGE) $< $(srcdir)/$(PACKAGE).pot -o $*.pox
+
+.po.mo:
+	$(MSGFMT) -o $@ $<
+
+.po.gmo:
+	file=`echo $* | sed 's,.*/,,'`.gmo \
+	  && rm -f $$file && $(GMSGFMT) -o $$file $<
+
+.po.cat:
+	sed -f ../intl/po2msg.sed < $< > $*.msg \
+	  && rm -f $@ && $(GENCAT) $@ $*.msg
+
+
+all: all-yes
+
+all-yes: $(CATALOGS) # $(PACKAGE).pot
+all-no:
+
+$(srcdir)/$(PACKAGE).pot: $(SRC-POTFILES) $(BLD-POTFILES)
+	$(XGETTEXT) --default-domain=$(PACKAGE) \
+	  --directory=$(top_srcdir) \
+	  --add-comments --keyword=_ --keyword=N_ \
+	  --msgid-bugs-address=bug-binutils@gnu.org \
+	  --files-from=$(srcdir)/SRC-POTFILES.in 
+	$(XGETTEXT) --default-domain=$(PACKAGE) \
+	  --directory=.. \
+	  --directory=. \
+	  --add-comments --keyword=_ --keyword=N_ \
+	  --join-existing \
+	  --msgid-bugs-address=bug-binutils@gnu.org \
+	  --files-from=$(srcdir)/BLD-POTFILES.in
+	rm -f $(srcdir)/$(PACKAGE).pot
+	mv $(PACKAGE).po $(srcdir)/$(PACKAGE).pot
+
+$(srcdir)/cat-id-tbl.c: stamp-cat-id; @:
+$(srcdir)/stamp-cat-id: $(PACKAGE).pot
+	rm -f cat-id-tbl.tmp
+	sed -f ../intl/po2tbl.sed $(srcdir)/$(PACKAGE).pot \
+		| sed -e "s/@PACKAGE NAME@/$(PACKAGE)/" > cat-id-tbl.tmp
+	if cmp -s cat-id-tbl.tmp $(srcdir)/cat-id-tbl.c; then \
+	  rm cat-id-tbl.tmp; \
+	else \
+	  echo cat-id-tbl.c changed; \
+	  rm -f $(srcdir)/cat-id-tbl.c; \
+	  mv cat-id-tbl.tmp $(srcdir)/cat-id-tbl.c; \
+	fi
+	cd $(srcdir) && rm -f stamp-cat-id && echo timestamp > stamp-cat-id
+
+
+install: install-exec install-data
+install-exec:
+install-info:
+install-html:
+install-data: install-data-yes
+install-data-no: all
+install-data-yes: all
+	if test -r $(MKINSTALLDIRS); then \
+	  $(MKINSTALLDIRS) $(DESTDIR)$(datadir); \
+	else \
+	  $(top_srcdir)/mkinstalldirs $(DESTDIR)$(datadir); \
+	fi
+	@catalogs='$(CATALOGS)'; \
+	for cat in $$catalogs; do \
+	  cat=`basename $$cat`; \
+	  case "$$cat" in \
+	    *.gmo) destdir=$(gnulocaledir);; \
+	    *)     destdir=$(localedir);; \
+	  esac; \
+	  lang=`echo $$cat | sed 's/\$(CATOBJEXT)$$//'`; \
+	  dir=$(DESTDIR)$$destdir/$$lang/LC_MESSAGES; \
+	  if test -r $(MKINSTALLDIRS); then \
+	    $(MKINSTALLDIRS) $$dir; \
+	  else \
+	    $(top_srcdir)/mkinstalldirs $$dir; \
+	  fi; \
+	  if test -r $$cat; then \
+	    $(INSTALL_DATA) $$cat $$dir/$(PACKAGE)$(INSTOBJEXT); \
+	    echo "installing $$cat as $$dir/$(PACKAGE)$(INSTOBJEXT)"; \
+	  else \
+	    $(INSTALL_DATA) $(srcdir)/$$cat $$dir/$(PACKAGE)$(INSTOBJEXT); \
+	    echo "installing $(srcdir)/$$cat as" \
+		 "$$dir/$(PACKAGE)$(INSTOBJEXT)"; \
+	  fi; \
+	  if test -r $$cat.m; then \
+	    $(INSTALL_DATA) $$cat.m $$dir/$(PACKAGE)$(INSTOBJEXT).m; \
+	    echo "installing $$cat.m as $$dir/$(PACKAGE)$(INSTOBJEXT).m"; \
+	  else \
+	    if test -r $(srcdir)/$$cat.m ; then \
+	      $(INSTALL_DATA) $(srcdir)/$$cat.m \
+		$$dir/$(PACKAGE)$(INSTOBJEXT).m; \
+	      echo "installing $(srcdir)/$$cat as" \
+		   "$$dir/$(PACKAGE)$(INSTOBJEXT).m"; \
+	    else \
+	      true; \
+	    fi; \
+	  fi; \
+	done
+	if test "$(PACKAGE)" = "gettext"; then \
+	  if test -r $(MKINSTALLDIRS); then \
+	    $(MKINSTALLDIRS) $(DESTDIR)$(gettextsrcdir); \
+	  else \
+	    $(top_srcdir)/mkinstalldirs $(DESTDIR)$(gettextsrcdir); \
+	  fi; \
+	  $(INSTALL_DATA) $(srcdir)/Makefile.in.in \
+			  $(DESTDIR)$(gettextsrcdir)/Makefile.in.in; \
+	else \
+	  : ; \
+	fi
+
+# Define this as empty until I found a useful application.
+installcheck:
+
+uninstall:
+	catalogs='$(CATALOGS)'; \
+	for cat in $$catalogs; do \
+	  cat=`basename $$cat`; \
+	  lang=`echo $$cat | sed 's/\$(CATOBJEXT)$$//'`; \
+	  rm -f $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT); \
+	  rm -f $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT).m; \
+	  rm -f $(DESTDIR)$(gnulocaledir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT); \
+	  rm -f $(DESTDIR)$(gnulocaledir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT).m; \
+	done
+	rm -f $(DESTDIR)$(gettextsrcdir)/po-Makefile.in.in
+
+check: all
+
+cat-id-tbl.o: ../intl/libgettext.h
+
+html dvi pdf ps info tags TAGS ID:
+
+mostlyclean:
+	rm -f core core.* *.pox $(PACKAGE).po *.old.po cat-id-tbl.tmp
+	rm -fr *.o
+
+clean: mostlyclean
+
+distclean: clean
+	rm -f Makefile Makefile.in *.mo *.msg *.cat *.cat.m
+	rm -f SRC-POTFILES BLD-POTFILES 
+
+maintainer-clean: distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+	rm -f $(GMOFILES) SRC-POTFILES.in BLD-POTFILES.in
+
+distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
+dist distdir: update-po $(DISTFILES)
+	dists="$(DISTFILES)"; \
+	for file in $$dists; do \
+	  ln $(srcdir)/$$file $(distdir) 2> /dev/null \
+	    || cp -p $(srcdir)/$$file $(distdir); \
+	done
+
+update-po: Makefile
+	$(MAKE) $(PACKAGE).pot
+	PATH=`pwd`/../src:$$PATH; \
+	cd $(srcdir); \
+	catalogs='$(CATALOGS)'; \
+	for cat in $$catalogs; do \
+	  cat=`basename $$cat`; \
+	  lang=`echo $$cat | sed 's/\$(CATOBJEXT)$$//'`; \
+	  mv $$lang.po $$lang.old.po; \
+	  echo "$$lang:"; \
+	  if $(MSGMERGE) $$lang.old.po $(PACKAGE).pot -o $$lang.po; then \
+	    rm -f $$lang.old.po; \
+	  else \
+	    echo "msgmerge for $$cat failed!"; \
+	    rm -f $$lang.po; \
+	    mv $$lang.old.po $$lang.po; \
+	  fi; \
+	done
+
+SRC-POTFILES: SRC-POTFILES.in
+	( if test 'x$(srcdir)' != 'x.'; then \
+	    posrcprefix='$(top_srcdir)/'; \
+	  else \
+	    posrcprefix="../"; \
+	  fi; \
+	  rm -f $@-t $@ \
+	    && (sed -e '/^#/d' \
+	            -e '/^[ 	]*$$/d' \
+		    -e "s@.*@	$$posrcprefix& \\\\@" < $(srcdir)/$@.in \
+		| sed -e '$$s/\\$$//') > $@-t \
+	    && chmod a-w $@-t \
+	    && mv $@-t $@ )
+
+BLD-POTFILES: BLD-POTFILES.in
+	  ( rm -f $@-t $@ \
+	    && (sed -e '/^#/d' \
+	            -e '/^[ 	]*$$/d' \
+		    -e "s@.*@	../& \\\\@" < $(srcdir)/$@.in \
+		| sed -e '$$s/\\$$//') > $@-t \
+	    && chmod a-w $@-t \
+	    && mv $@-t $@ )
+
+SRC-POTFILES.in: # ../Makefile
+	cd .. && $(MAKE) po/SRC-POTFILES.in
+
+BLD-POTFILES.in: # ../Makefile
+	cd .. && $(MAKE) po/BLD-POTFILES.in
+
+# Note - The presence of SRC-POTFILES and BLD-POTFILES as dependencies
+# here breaks the implementation of the 'distclean' rule for maintainers.
+# This is because if 'make distclean' is run in the BFD directory, the
+# Makefile there will be deleted before 'distclean' is made here, and so
+# the dependency SRC-POTFILES -> SRC-POTFILES.in -> ../Makefile cannot
+# be satisfied.
+#
+# The SRC-POTFILES and BLD-POTFILES dependencies cannot be removed,
+# however since it is necessary that these files be built during
+# *configure* time, so that configure can insert them into the
+# po/Makefile that it is creating, so that the Makefile will have
+# the correct dependencies.
+Makefile: Make-in ../config.status SRC-POTFILES BLD-POTFILES
+	cd .. \
+	  && CONFIG_FILES=$(subdir)/Makefile.in:$(subdir)/Make-in \
+	     CONFIG_HEADERS= $(SHELL) ./config.status
+
+# Tell versions [3.59,3.63) of GNU make not to export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
--- a/binutils/Makefile.in
+++ b/binutils/Makefile.in
@@ -1327,7 +1327,7 @@ readelf.o: readelf.c sysdep.h $(INCDIR)/
   $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h bucomm.h dwarf.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/h8.h $(INCDIR)/elf/reloc-macros.h $(INCDIR)/elf/alpha.h \
-  $(INCDIR)/elf/arc.h $(INCDIR)/elf/arm.h $(INCDIR)/elf/avr.h \
+  $(INCDIR)/elf/arc.h $(INCDIR)/elf/arm.h $(INCDIR)/elf/avr.h $(INCDIR)/elf/avr32.h\
   $(INCDIR)/elf/bfin.h $(INCDIR)/elf/cris.h $(INCDIR)/elf/crx.h \
   $(INCDIR)/elf/d10v.h $(INCDIR)/elf/d30v.h $(INCDIR)/elf/dlx.h \
   $(INCDIR)/elf/fr30.h $(INCDIR)/elf/frv.h $(INCDIR)/elf/hppa.h \
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -384,7 +384,34 @@ ALL_EMULATIONS = \
 	eavr3.o \
 	eavr4.o \
 	eavr5.o \
-	eavr6.o \
+    eavr6.o \
+	eavr32elf_ap7000.o \
+	eavr32elf_ap7001.o \
+	eavr32elf_ap7002.o \
+	eavr32elf_ap7200.o \
+	eavr32elf_uc3a0128.o \
+	eavr32elf_uc3a0256.o \
+	eavr32elf_uc3a0512.o \
+	eavr32elf_uc3a0512es.o \
+	eavr32elf_uc3a1128.o \
+	eavr32elf_uc3a1256.o \
+	eavr32elf_uc3a1512es.o \
+	eavr32elf_uc3a1512.o \
+	eavr32elf_uc3a364.o \
+	eavr32elf_uc3a364s.o \
+	eavr32elf_uc3a3128.o \
+	eavr32elf_uc3a3128s.o \
+	eavr32elf_uc3a3256.o \
+	eavr32elf_uc3a3256s.o \
+	eavr32elf_uc3b064.o \
+	eavr32elf_uc3b0128.o \
+	eavr32elf_uc3b0256es.o \
+	eavr32elf_uc3b0256.o \
+	eavr32elf_uc3b164.o \
+	eavr32elf_uc3b1128.o \
+	eavr32elf_uc3b1256es.o \
+	eavr32elf_uc3b1256.o \
+	eavr32linux.o \
 	ecoff_i860.o \
 	ecoff_sparc.o \
 	eelf32_spu.o \
@@ -1448,6 +1475,114 @@ eavr6.c: $(srcdir)/emulparams/avr6.sh $(
   $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avr6 "$(tdir_avr2)"
+eavr32elf_ap7000.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7000 "$(tdir_avr32)" avr32elf
+eavr32elf_ap7001.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7001 "$(tdir_avr32)" avr32elf
+eavr32elf_ap7002.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7002 "$(tdir_avr32)" avr32elf
+eavr32elf_ap7200.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_ap7200 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0512.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0512 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a0512es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a0512es "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1512.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1512 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a1512es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a1512es "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a364.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a364 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a364s.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a364s "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3128s.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3128s "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3a3256s.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3a3256s "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b064.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b064 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b0128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b0128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b0256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b0256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b0256es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b0256es "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b164.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b164 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b1128.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b1128 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b1256.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b1256 "$(tdir_avr32)" avr32elf
+eavr32elf_uc3b1256es.c: $(srcdir)/emulparams/avr32elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf_xip.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32elf_uc3b1256es "$(tdir_avr32)" avr32elf
+eavr32linux.c: $(srcdir)/emulparams/avr32linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/avr32elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} avr32linux "$(tdir_avr32)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
@@ -2679,7 +2814,9 @@ install-exec-local: ld-new$(EXEEXT)
 	  || $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
 	fi
 
-install-data-local:
+# We want install to imply install-info as per GNU standards, despite the
+# cygnus option.
+install-data-local: install-info
 	$(mkinstalldirs) $(DESTDIR)$(scriptdir)/ldscripts
 	for f in ldscripts/*; do \
 	  $(INSTALL_DATA) $$f $(DESTDIR)$(scriptdir)/$$f ; \
--- /dev/null
+++ b/libiberty/required-list
@@ -0,0 +1 @@
+./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o ./alloca.o ./argv.o ./choose-temp.o ./concat.o ./cp-demint.o ./dyn-string.o ./fdmatch.o ./fibheap.o ./filename_cmp.o ./floatformat.o ./fnmatch.o ./fopen_unlocked.o ./getopt.o ./getopt1.o ./getpwd.o ./getruntime.o ./hashtab.o ./hex.o ./lbasename.o ./lrealpath.o ./make-relative-prefix.o ./make-temp-file.o ./objalloc.o ./obstack.o ./partition.o ./pexecute.o ./physmem.o ./pex-common.o ./pex-one.o ./pex-unix.o ./safe-ctype.o ./sort.o ./spaces.o ./splay-tree.o ./strerror.o ./strsignal.o ./unlink-if-ordinary.o ./xatexit.o ./xexit.o ./xmalloc.o ./xmemdup.o ./xstrdup.o ./xstrerror.o ./xstrndup.o
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -11418,6 +11418,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_arc_arch)		ta="$ta arc-dis.lo arc-opc.lo arc-ext.lo" ;;
 	bfd_arm_arch)		ta="$ta arm-dis.lo" ;;
 	bfd_avr_arch)		ta="$ta avr-dis.lo" ;;
+	bfd_avr32_arch)		ta="$ta avr32-asm.lo avr32-dis.lo avr32-opc.lo" ;;
 	bfd_bfin_arch)		ta="$ta bfin-dis.lo" ;;
 	bfd_cr16_arch)    	ta="$ta cr16-dis.lo cr16-opc.lo" ;;
 	bfd_cris_arch)		ta="$ta cris-dis.lo cris-opc.lo cgen-bitset.lo" ;;
@@ -11476,7 +11477,7 @@ if test x${all_targets} = xfalse ; then
 				ta="$ta sh64-dis.lo sh64-opc.lo"
 				archdefs="$archdefs -DINCLUDE_SHMEDIA"
 				break;;
-	    esac;
+	    esac
 	  done
 				ta="$ta sh-dis.lo cgen-bitset.lo" ;;
 	bfd_sparc_arch)		ta="$ta sparc-dis.lo sparc-opc.lo" ;;
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -257,6 +257,7 @@ LIBIBERTY = ../libiberty/libiberty.a
 # Header files.
 HFILES = \
 	cgen-ops.h cgen-types.h \
+	avr32-asm.h avr32-opc.h \
 	fr30-desc.h fr30-opc.h \
 	frv-desc.h frv-opc.h \
 	h8500-opc.h \
@@ -291,6 +292,9 @@ CFILES = \
 	arc-ext.c \
 	arm-dis.c \
 	avr-dis.c \
+	avr32-asm.c \
+	avr32-dis.c \
+	avr32-opc.c \
 	bfin-dis.c \
 	cgen-asm.c \
 	cgen-bitset.c \
@@ -445,6 +449,9 @@ ALL_MACHINES = \
 	arc-ext.lo \
 	arm-dis.lo \
 	avr-dis.lo \
+	avr32-asm.lo \
+	avr32-dis.lo \
+	avr32-opc.lo \
 	bfin-dis.lo \
 	cgen-asm.lo \
 	cgen-bitset.lo \
@@ -1225,6 +1232,15 @@ avr-dis.lo: avr-dis.c sysdep.h config.h 
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h \
   opintl.h $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/avr.h
+avr32-asm.lo: avr32-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h opintl.h \
+  $(INCDIR)/xregex.h $(INCDIR)/xregex2.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
+avr32-dis.lo: avr32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
+  avr32-opc.h opintl.h
+avr32-opc.lo: avr32-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h $(INCDIR)/libiberty.h
 bfin-dis.lo: bfin-dis.c $(INCDIR)/opcode/bfin.h $(INCDIR)/dis-asm.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h
 cgen-asm.lo: cgen-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
